From 810c2afe0c7e1be9352ad512b337110b100bfe3a Mon Sep 17 00:00:00 2001
From: John Crispin <blogic@openwrt.org>
Date: Sun, 16 Mar 2014 08:51:14 +0000
Subject: [PATCH 36/57] NET: add mt7621 ethernet driver

---
 arch/mips/include/asm/rt2880/board-custom.h   |  153 +++
 arch/mips/include/asm/rt2880/eureka_ep430.h   |  204 ++++
 arch/mips/include/asm/rt2880/generic.h        |   42 +
 arch/mips/include/asm/rt2880/lm.h             |   32 +
 arch/mips/include/asm/rt2880/prom.h           |   50 +
 arch/mips/include/asm/rt2880/rt_mmap.h        |  796 ++++++++++++++++
 arch/mips/include/asm/rt2880/serial_rt2880.h  |  443 +++++++++
 arch/mips/include/asm/rt2880/sizes.h          |   52 +
 arch/mips/include/asm/rt2880/surfboard.h      |   70 ++
 arch/mips/include/asm/rt2880/surfboardint.h   |  190 ++++
 arch/mips/include/asm/rt2880/war.h            |   25 +
 drivers/net/ethernet/Kconfig                  |    1 +
 drivers/net/ethernet/Makefile                 |    1 +
 drivers/net/ethernet/raeth/Kconfig            |  344 +++++++
 drivers/net/ethernet/raeth/Makefile           |    7 +
 drivers/net/ethernet/raeth/ethtool_readme.txt |   44 +
 drivers/net/ethernet/raeth/mii_mgr.c          |  166 ++++
 drivers/net/ethernet/raeth/ra2882ethreg.h     | 1268 +++++++++++++++++++++++++
 drivers/net/ethernet/raeth/ra_ioctl.h         |   92 ++
 drivers/net/ethernet/raeth/ra_mac.c           |   98 ++
 drivers/net/ethernet/raeth/ra_mac.h           |   35 +
 drivers/net/ethernet/raeth/raether.c          |  693 ++++++++++++++
 drivers/net/ethernet/raeth/raether.h          |   92 ++
 drivers/net/ethernet/raeth/raether_pdma.c     |  212 +++++
 drivers/net/ethernet/raeth/raether_qdma.c     |  805 ++++++++++++++++
 25 files changed, 5915 insertions(+)
 create mode 100644 arch/mips/include/asm/rt2880/board-custom.h
 create mode 100644 arch/mips/include/asm/rt2880/eureka_ep430.h
 create mode 100644 arch/mips/include/asm/rt2880/generic.h
 create mode 100644 arch/mips/include/asm/rt2880/lm.h
 create mode 100644 arch/mips/include/asm/rt2880/prom.h
 create mode 100644 arch/mips/include/asm/rt2880/rt_mmap.h
 create mode 100644 arch/mips/include/asm/rt2880/serial_rt2880.h
 create mode 100644 arch/mips/include/asm/rt2880/sizes.h
 create mode 100644 arch/mips/include/asm/rt2880/surfboard.h
 create mode 100644 arch/mips/include/asm/rt2880/surfboardint.h
 create mode 100644 arch/mips/include/asm/rt2880/war.h
 create mode 100644 drivers/net/ethernet/raeth/Kconfig
 create mode 100644 drivers/net/ethernet/raeth/Makefile
 create mode 100644 drivers/net/ethernet/raeth/ethtool_readme.txt
 create mode 100644 drivers/net/ethernet/raeth/mii_mgr.c
 create mode 100644 drivers/net/ethernet/raeth/ra2882ethreg.h
 create mode 100644 drivers/net/ethernet/raeth/ra_ioctl.h
 create mode 100644 drivers/net/ethernet/raeth/ra_mac.c
 create mode 100644 drivers/net/ethernet/raeth/ra_mac.h
 create mode 100644 drivers/net/ethernet/raeth/raether.c
 create mode 100644 drivers/net/ethernet/raeth/raether.h
 create mode 100644 drivers/net/ethernet/raeth/raether_pdma.c
 create mode 100644 drivers/net/ethernet/raeth/raether_qdma.c

diff --git a/arch/mips/include/asm/rt2880/board-custom.h b/arch/mips/include/asm/rt2880/board-custom.h
new file mode 100644
index 0000000..120e846
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/board-custom.h
@@ -0,0 +1,153 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ */
+/* MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+#ifndef __ARCH_ARM_MACH_MT6575_CUSTOM_BOARD_H
+#define __ARCH_ARM_MACH_MT6575_CUSTOM_BOARD_H
+
+#include <linux/autoconf.h>
+
+/*=======================================================================*/
+/* MT6575 SD                                                             */
+/*=======================================================================*/
+#ifdef MTK_EMMC_SUPPORT
+#define CFG_DEV_MSDC0
+#endif
+#define CFG_DEV_MSDC1
+#define CFG_DEV_MSDC2
+#define CFG_DEV_MSDC3
+#if defined(CONFIG_MTK_COMBO) || defined(CONFIG_MTK_COMBO_MODULE)
+/*
+SDIO slot index number used by connectivity combo chip:
+0: invalid (used by memory card)
+1: MSDC1
+2: MSDC2
+*/
+#define CONFIG_MTK_WCN_CMB_SDIO_SLOT  (2) /* MSDC2 */
+#else
+#undef CONFIG_MTK_WCN_CMB_SDIO_SLOT
+#endif
+
+#if 0 /* FIXME. */
+/*=======================================================================*/
+/* MT6575 UART                                                           */
+/*=======================================================================*/
+#define CFG_DEV_UART1
+#define CFG_DEV_UART2
+#define CFG_DEV_UART3
+#define CFG_DEV_UART4
+
+#define CFG_UART_PORTS          (4)
+
+/*=======================================================================*/
+/* MT6575 I2C                                                            */
+/*=======================================================================*/
+#define CFG_DEV_I2C
+//#define CFG_I2C_HIGH_SPEED_MODE
+//#define CFG_I2C_DMA_MODE
+
+/*=======================================================================*/
+/* MT6575 ADB                                                            */
+/*=======================================================================*/
+#define ADB_SERIAL "E1K"
+
+#endif
+
+/*=======================================================================*/
+/* MT6575 NAND FLASH                                                     */
+/*=======================================================================*/
+#if 0
+#define RAMDOM_READ 1<<0
+#define CACHE_READ  1<<1
+/*******************************************************************************
+ * NFI & ECC Configuration 
+ *******************************************************************************/
+typedef struct
+{
+    u16 id;			//deviceid+menuid
+    u8  addr_cycle;
+    u8  iowidth;
+    u16 totalsize;	
+    u16 blocksize;
+    u16 pagesize;
+    u32 timmingsetting;
+    char devciename[14];
+    u32 advancedmode;   //
+}flashdev_info,*pflashdev_info;
+
+static const flashdev_info g_FlashTable[]={
+    //micro
+    {0xAA2C,  5,  8,  256,	128,  2048,  0x01113,  "MT29F2G08ABD",	0},
+    {0xB12C,  4,  16, 128,	128,  2048,  0x01113,  "MT29F1G16ABC",	0},
+    {0xBA2C,  5,  16, 256,	128,  2048,  0x01113,  "MT29F2G16ABD",	0}, 
+    {0xAC2C,  5,  8,  512,	128,  2048,  0x01113,  "MT29F4G08ABC",	0},
+    {0xBC2C,  5,  16, 512,	128,  2048,  0x44333,  "MT29F4G16ABD",	0},
+    //samsung 
+    {0xBAEC,  5,  16, 256,	128,  2048,  0x01123,  "K522H1GACE",	0},
+    {0xBCEC,  5,  16, 512,	128,  2048,  0x01123,  "K524G2GACB",	0},
+    {0xDAEC,  5,  8,  256,	128,  2048,  0x33222,  "K9F2G08U0A",	RAMDOM_READ},
+    {0xF1EC,  4,  8,  128,	128,  2048,  0x01123,  "K9F1G08U0A",	RAMDOM_READ},
+    {0xAAEC,  5,  8,  256,	128,  2048,  0x01123,  "K9F2G08R0A",	0},
+    //hynix
+    {0xD3AD,  5,  8,  1024, 256,  2048,  0x44333,  "HY27UT088G2A",	0},
+    {0xA1AD,  4,  8,  128,	128,  2048,  0x01123,  "H8BCSOPJOMCP",	0},
+    {0xBCAD,  5,  16, 512,	128,  2048,  0x01123,  "H8BCSOUNOMCR",	0},
+    {0xBAAD,  5,  16, 256,	128,  2048,  0x01123,  "H8BCSOSNOMCR",	0},
+    //toshiba
+    {0x9598,  5,  16, 816,	128,  2048,  0x00113,  "TY9C000000CMG", 0},
+    {0x9498,  5,  16, 375,	128,  2048,  0x00113,  "TY9C000000CMG", 0},
+    {0xC198,  4,  16, 128,	128,  2048,  0x44333,  "TC58NWGOS8C",	0},
+    {0xBA98,  5,  16, 256,	128,  2048,  0x02113,  "TC58NYG1S8C",	0},
+    //st-micro
+    {0xBA20,  5,  16, 256,	128,  2048,  0x01123,  "ND02CGR4B2DI6", 0},
+
+    // elpida
+    {0xBC20,  5,  16, 512,  128,  2048,  0x01123,  "04GR4B2DDI6",   0},
+    {0x0000,  0,  0,  0,	0,	  0,	 0, 	   "xxxxxxxxxxxxx", 0}
+};
+#endif
+	
+	
+#define NFI_DEFAULT_ACCESS_TIMING        (0x44333)
+
+//uboot only support 1 cs
+#define NFI_CS_NUM                  (2)
+#define NFI_DEFAULT_CS				(0)
+
+#define USE_AHB_MODE                	(1)
+
+#define PLATFORM_EVB                (1)
+
+#endif /* __ARCH_ARM_MACH_MT6575_CUSTOM_BOARD_H */
+
diff --git a/arch/mips/include/asm/rt2880/eureka_ep430.h b/arch/mips/include/asm/rt2880/eureka_ep430.h
new file mode 100644
index 0000000..e42a992
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/eureka_ep430.h
@@ -0,0 +1,204 @@
+/**************************************************************************
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ */
+
+#ifndef _EUREKA_EP430_H
+#define _EUREKA_EP430_H
+
+
+#include <asm/addrspace.h>		/* for KSEG1ADDR() */
+#include <asm/byteorder.h>		/* for cpu_to_le32() */
+#include <asm/mach-ralink/rt_mmap.h>
+
+
+/*
+ * Because of an error/peculiarity in the Galileo chip, we need to swap the
+ * bytes when running bigendian.
+ */
+
+#define MV_WRITE(ofs, data)  \
+        *(volatile u32 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le32(data)
+#define MV_READ(ofs, data)   \
+        *(data) = le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
+#define MV_READ_DATA(ofs)    \
+        le32_to_cpu(*(volatile u32 *)(RALINK_PCI_BASE+(ofs)))
+
+#define MV_WRITE_16(ofs, data)  \
+        *(volatile u16 *)(RALINK_PCI_BASE+(ofs)) = cpu_to_le16(data)
+#define MV_READ_16(ofs, data)   \
+        *(data) = le16_to_cpu(*(volatile u16 *)(RALINK_PCI_BASE+(ofs)))
+
+#define MV_WRITE_8(ofs, data)  \
+        *(volatile u8 *)(RALINK_PCI_BASE+(ofs)) = data
+#define MV_READ_8(ofs, data)   \
+        *(data) = *(volatile u8 *)(RALINK_PCI_BASE+(ofs))
+
+#define MV_SET_REG_BITS(ofs,bits) \
+	(*((volatile u32 *)(RALINK_PCI_BASE+(ofs)))) |= ((u32)cpu_to_le32(bits))
+#define MV_RESET_REG_BITS(ofs,bits) \
+	(*((volatile u32 *)(RALINK_PCI_BASE+(ofs)))) &= ~((u32)cpu_to_le32(bits))
+
+#define RALINK_PCI_CONFIG_ADDR 		    	0x20
+#define RALINK_PCI_CONFIG_DATA_VIRTUAL_REG   	0x24
+
+#if defined(CONFIG_RALINK_RT2880) || defined(CONFIG_RALINK_RT2883)
+#define RALINK_PCI_PCICFG_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
+#define RALINK_PCI_PCIRAW_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0004)
+#define RALINK_PCI_PCIINT_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0008)
+#define RALINK_PCI_PCIMSK_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + 0x0010)
+#define RALINK_PCI_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + 0x0018)
+#define RALINK_PCI_IMBASEBAR1_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + 0x001C)
+#define RALINK_PCI_MEMBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
+#define RALINK_PCI_IOBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCI_ID 			*(volatile u32 *)(RALINK_PCI_BASE + 0x0030)
+#define RALINK_PCI_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0034)
+#define RALINK_PCI_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0038)
+#define RALINK_PCI_ARBCTL 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0080)
+#define RALINK_PCI_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + 0x0050)
+
+#elif defined(CONFIG_RALINK_RT3883)
+
+#define RALINK_PCI_PCICFG_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
+#define RALINK_PCI_PCIRAW_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0004)
+#define RALINK_PCI_PCIINT_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0008)
+#define RALINK_PCI_PCIMSK_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_IMBASEBAR1_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + 0x001C)
+#define RALINK_PCI_MEMBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
+#define RALINK_PCI_IOBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCI_ARBCTL 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0080)
+
+/*
+PCI0 --> PCI 
+PCI1 --> PCIe
+*/
+#define RT3883_PCI_OFFSET	0x1000
+#define RT3883_PCIE_OFFSET	0x2000
+
+#define RALINK_PCI0_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCI_OFFSET + 0x0010)
+#define RALINK_PCI0_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCI_OFFSET + 0x0018)
+#define RALINK_PCI0_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCI_OFFSET + 0x0030)
+#define RALINK_PCI0_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCI_OFFSET + 0x0034)
+#define RALINK_PCI0_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCI_OFFSET + 0x0038)
+
+#define RALINK_PCI1_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCIE_OFFSET + 0x0010)
+#define RALINK_PCI1_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCIE_OFFSET + 0x0018)
+#define RALINK_PCI1_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCIE_OFFSET + 0x0030)
+#define RALINK_PCI1_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCIE_OFFSET + 0x0034)
+#define RALINK_PCI1_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCIE_OFFSET + 0x0038)
+#define RALINK_PCI1_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT3883_PCIE_OFFSET + 0x0050)
+
+#elif defined(CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_MT7620) || defined(CONFIG_RALINK_MT7628)
+
+#define RALINK_PCI_PCICFG_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
+#define RALINK_PCI_PCIRAW_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0004)
+#define RALINK_PCI_PCIINT_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0008)
+#define RALINK_PCI_PCIMSK_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_IMBASEBAR1_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + 0x001C)
+#define RALINK_PCI_MEMBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
+#define RALINK_PCI_IOBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCI_ARBCTL 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0080)
+
+/*
+PCI0 --> PCIe 0 
+PCI1 --> PCIe 1
+*/
+#define RT6855_PCIE0_OFFSET	0x2000
+#define RT6855_PCIE1_OFFSET	0x3000
+
+#define RALINK_PCI0_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0010)
+#define RALINK_PCI0_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0018)
+#define RALINK_PCI0_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0030)
+#define RALINK_PCI0_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
+#define RALINK_PCI0_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
+#define RALINK_PCI0_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
+#define RALINK_PCI0_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0060)
+#define RALINK_PCI0_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0064)
+
+#define RALINK_PCI1_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
+#define RALINK_PCI1_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
+#define RALINK_PCI1_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0030)
+#define RALINK_PCI1_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
+#define RALINK_PCI1_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
+#define RALINK_PCI1_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
+#define RALINK_PCI1_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0060)
+#define RALINK_PCI1_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0064)
+
+#elif defined (CONFIG_RALINK_MT7621)
+
+#define RALINK_PCI_PCICFG_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0000)
+#define RALINK_PCI_PCIRAW_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0004)
+#define RALINK_PCI_PCIINT_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0008)
+#define RALINK_PCI_PCIMSK_ADDR 		*(volatile u32 *)(RALINK_PCI_BASE + 0x000C)
+#define RALINK_PCI_IMBASEBAR1_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + 0x001C)
+#define RALINK_PCI_MEMBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0028)
+#define RALINK_PCI_IOBASE 		*(volatile u32 *)(RALINK_PCI_BASE + 0x002C)
+#define RALINK_PCI_ARBCTL 		*(volatile u32 *)(RALINK_PCI_BASE + 0x0080)
+
+/*
+PCI0 --> PCIe 0 
+PCI1 --> PCIe 1
+PCI2 --> PCIe 2
+*/
+#define RT6855_PCIE0_OFFSET	0x2000
+#define RT6855_PCIE1_OFFSET	0x3000
+#define RT6855_PCIE2_OFFSET	0x4000
+
+#define RALINK_PCI0_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0010)
+#define RALINK_PCI0_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0018)
+#define RALINK_PCI0_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0030)
+#define RALINK_PCI0_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0034)
+#define RALINK_PCI0_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0038)
+#define RALINK_PCI0_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0050)
+#define RALINK_PCI0_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0060)
+#define RALINK_PCI0_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE0_OFFSET + 0x0064)
+
+#define RALINK_PCI1_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0010)
+#define RALINK_PCI1_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0018)
+#define RALINK_PCI1_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0030)
+#define RALINK_PCI1_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0034)
+#define RALINK_PCI1_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0038)
+#define RALINK_PCI1_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0050)
+#define RALINK_PCI1_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0060)
+#define RALINK_PCI1_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE1_OFFSET + 0x0064)
+
+#define RALINK_PCI2_BAR0SETUP_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0010)
+#define RALINK_PCI2_IMBASEBAR0_ADDR 	*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0018)
+#define RALINK_PCI2_ID 			*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0030)
+#define RALINK_PCI2_CLASS 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0034)
+#define RALINK_PCI2_SUBID 		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0038)
+#define RALINK_PCI2_STATUS		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0050)
+#define RALINK_PCI2_DERR		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0060)
+#define RALINK_PCI2_ECRC		*(volatile u32 *)(RALINK_PCI_BASE + RT6855_PCIE2_OFFSET + 0x0064)
+
+#define RALINK_PCIEPHY_P0P1_CTL_OFFSET	(RALINK_PCI_BASE + 0x9000)
+#define RALINK_PCIEPHY_P2_CTL_OFFSET	(RALINK_PCI_BASE + 0xA000)
+
+#elif defined(CONFIG_RALINK_RT3052) || defined(CONFIG_RALINK_RT3352) || defined(CONFIG_RALINK_RT5350) 
+#else
+#error "undefined in PCI"
+#endif
+
+#endif
diff --git a/arch/mips/include/asm/rt2880/generic.h b/arch/mips/include/asm/rt2880/generic.h
new file mode 100644
index 0000000..4128f91
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/generic.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2001 Palmchip Corporation.  All rights reserved.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * Defines of the Palmchip boards specific address-MAP, registers, etc.
+ */
+#ifndef __ASM_SURFBOARD_GENERIC_H
+#define __ASM_SURFBOARD_GENERIC_H
+
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+#include <asm/mach-ralink/rt_mmap.h>
+
+/*
+ * Reset register.
+ */
+#define SOFTRES_REG       (KSEG1ADDR(RALINK_SYSCTL_BASE+0x34))
+#define GORESET           (0x1)
+
+/*
+ * Power-off register
+ */
+#define POWER_DIR_REG     (KSEG1ADDR(RALINK_PIO_BASE+0x24))
+#define POWER_DIR_OUTPUT  (0x80)	/* GPIO 7 */
+#define POWER_POL_REG     (KSEG1ADDR(RALINK_PIO_BASE+0x28))
+#define POWEROFF_REG      (KSEG1ADDR(RALINK_PIO_BASE+0x20))
+#define POWEROFF          (0x0)		/* drive low */
+
+
+#endif  /* __ASM_SURFBOARD_GENERIC_H */
diff --git a/arch/mips/include/asm/rt2880/lm.h b/arch/mips/include/asm/rt2880/lm.h
new file mode 100644
index 0000000..25e2930
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/lm.h
@@ -0,0 +1,32 @@
+#include <linux/version.h>
+
+struct lm_device {
+	struct device		dev;
+	struct resource		resource;
+	unsigned int		irq;
+	unsigned int		id;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+	void			*lm_drvdata;
+#endif
+};
+
+struct lm_driver {
+	struct device_driver	drv;
+	int			(*probe)(struct lm_device *);
+	void			(*remove)(struct lm_device *);
+	int			(*suspend)(struct lm_device *, u32);
+	int			(*resume)(struct lm_device *);
+};
+
+int lm_driver_register(struct lm_driver *drv);
+void lm_driver_unregister(struct lm_driver *drv);
+
+int lm_device_register(struct lm_device *dev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+# define lm_get_drvdata(lm)	((lm)->lm_drvdata)
+# define lm_set_drvdata(lm,d)	do { (lm)->lm_drvdata = (d); } while (0)
+#else
+# define lm_get_drvdata(lm)	dev_get_drvdata(&(lm)->dev)
+# define lm_set_drvdata(lm,d)	dev_set_drvdata(&(lm)->dev, d)
+#endif
diff --git a/arch/mips/include/asm/rt2880/prom.h b/arch/mips/include/asm/rt2880/prom.h
new file mode 100644
index 0000000..51be9b0
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/prom.h
@@ -0,0 +1,50 @@
+/*
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * MIPS boards bootprom interface for the Linux kernel.
+ *
+ */
+
+#ifndef _MIPS_PROM_H
+#define _MIPS_PROM_H
+
+extern char *prom_getcmdline(void);
+extern char *prom_getenv(char *name);
+extern void setup_prom_printf(int tty_no);
+extern void prom_setup_printf(int tty_no);
+extern void prom_printf(char *fmt, ...);
+extern void prom_init_cmdline(void);
+extern void prom_meminit(void);
+extern void prom_fixup_mem_map(unsigned long start_mem, unsigned long end_mem);
+extern void prom_free_prom_memory (void);
+extern void mips_display_message(const char *str);
+extern void mips_display_word(unsigned int num);
+extern int get_ethernet_addr(char *ethernet_addr);
+
+/* Memory descriptor management. */
+#define PROM_MAX_PMEMBLOCKS    32
+struct prom_pmemblock {
+        unsigned long base; /* Within KSEG0. */
+        unsigned int size;  /* In bytes. */
+        unsigned int type;  /* free or prom memory */
+};
+
+#endif /* !(_MIPS_PROM_H) */
diff --git a/arch/mips/include/asm/rt2880/rt_mmap.h b/arch/mips/include/asm/rt2880/rt_mmap.h
new file mode 100644
index 0000000..0e8f051
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/rt_mmap.h
@@ -0,0 +1,796 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     register definition for Ralink RT-series SoC
+ *
+ *  Copyright 2007 Ralink Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ */
+
+#ifndef __RALINK_MMAP__
+#define __RALINK_MMAP__
+
+#if defined (CONFIG_RALINK_RT2880_SHUTTLE)
+
+#define RALINK_SYSCTL_BASE 		0xA0300000
+#define RALINK_TIMER_BASE		0xA0300100
+#define RALINK_INTCL_BASE		0xA0300200
+#define RALINK_MEMCTRL_BASE		0xA0300300
+#define RALINK_UART_BASE		0xA0300500
+#define RALINK_PIO_BASE			0xA0300600
+#define RALINK_I2C_BASE			0xA0300900
+#define RALINK_SPI_BASE			0xA0300B00
+#define RALINK_UART_LITE_BASE		0xA0300C00
+#define RALINK_FRAME_ENGINE_BASE	0xA0310000
+#define RALINK_EMBEDD_ROM_BASE		0xA0400000
+#define RALINK_PCI_BASE			0xA0500000
+#define RALINK_11N_MAC_BASE		0xA0600000
+
+//Interrupt Controller
+#define RALINK_INTCTL_TIMER0		(1<<0)
+#define RALINK_INTCTL_WDTIMER		(1<<1)
+#define RALINK_INTCTL_UART		(1<<2)
+#define RALINK_INTCTL_PIO		(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UARTLITE		(1<<8)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<23)
+
+//Reset Control Register
+#define RALINK_TIMER_RST		(1<<1)
+#define RALINK_INTC_RST			(1<<2)
+#define RALINK_MC_RST			(1<<3)
+#define RALINK_CPU_RST			(1<<4)
+#define RALINK_UART_RST			(1<<5)
+#define RALINK_PIO_RST			(1<<6)
+#define RALINK_I2C_RST			(1<<9)
+#define RALINK_SPI_RST			(1<<11)
+#define RALINK_UART2_RST		(1<<12)
+#define RALINK_PCI_RST			(1<<16)
+#define RALINK_2860_RST			(1<<17)
+#define RALINK_FE_RST			(1<<18)
+#define RALINK_PCM_RST			(1<<19)
+
+
+#elif defined (CONFIG_RALINK_RT2880_MP)
+
+#define RALINK_SYSCTL_BASE 		0xA0300000
+#define RALINK_TIMER_BASE		0xA0300100
+#define RALINK_INTCL_BASE		0xA0300200
+#define RALINK_MEMCTRL_BASE		0xA0300300
+#define RALINK_UART_BASE		0xA0300500
+#define RALINK_PIO_BASE			0xA0300600
+#define RALINK_I2C_BASE			0xA0300900
+#define RALINK_SPI_BASE			0xA0300B00
+#define RALINK_UART_LITE_BASE		0x00300C00
+#define RALINK_FRAME_ENGINE_BASE	0xA0400000
+#define RALINK_EMBEDD_ROM_BASE		0xA0410000
+#define RALINK_PCI_BASE			0xA0440000
+#define RALINK_11N_MAC_BASE		0xA0480000
+
+//Interrupt Controller
+#define RALINK_INTCTL_TIMER0		(1<<0)
+#define RALINK_INTCTL_WDTIMER		(1<<1)
+#define RALINK_INTCTL_UART		(1<<2)
+#define RALINK_INTCTL_PIO		(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UARTLITE		(1<<8)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<23)
+
+//Reset Control Register
+#define RALINK_TIMER_RST		(1<<1)
+#define RALINK_INTC_RST			(1<<2)
+#define RALINK_MC_RST			(1<<3)
+#define RALINK_CPU_RST			(1<<4)
+#define RALINK_UART_RST			(1<<5)
+#define RALINK_PIO_RST			(1<<6)
+#define RALINK_I2C_RST			(1<<9)
+#define RALINK_SPI_RST			(1<<11)
+#define RALINK_UART2_RST		(1<<12)
+#define RALINK_PCI_RST			(1<<16)
+#define RALINK_2860_RST			(1<<17)
+#define RALINK_FE_RST			(1<<18)
+#define RALINK_PCM_RST			(1<<19)
+
+#elif defined (CONFIG_RALINK_RT3052) 
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_PCM_BASE			0xB0000400
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_GDMA_BASE		0xB0000700
+#define RALINK_NAND_CTRL_BASE		0xB0000800
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_OTG_BASE		0x101C0000
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_NAND		(1<<8)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_ESW		(1<<17)
+#define RALINK_INTCTL_OTG		(1<<18)
+#define RALINK_INTCTL_OTG_IRQN		18
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_CPU_RST			(1<<1)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_RT2872_RST		(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_OTG_RST			(1<<22)
+#define RALINK_SW_RST			(1<<23)
+#define RALINK_EPHY_RST			(1<<24)
+
+#elif defined (CONFIG_RALINK_RT3352)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_NAND_CTRL_BASE		0xB0000800
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_PCM_BASE			0xB0002000
+#define RALINK_GDMA_BASE		0xB0002800
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_USB_DEV_BASE		0x10120000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_HOST_BASE		0x101C0000
+
+#define RALINK_MCNT_CFG			0xB0000D00
+#define RALINK_COMPARE			0xB0000D04
+#define RALINK_COUNT			0xB0000D08
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_ESW		(1<<17)
+#define RALINK_INTCTL_OTG		(1<<18)
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_WLAN_RST			(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_UHST_RST			(1<<22)
+#define RALINK_ESW_RST			(1<<23)
+#define RALINK_EPHY_RST			(1<<24)
+#define RALINK_UDEV_RST			(1<<25)
+
+
+//Clock Conf Register
+#define RALINK_UPHY1_CLK_EN		(1<<20)
+#define RALINK_UPHY0_CLK_EN		(1<<18)
+#define RALINK_GE1_CLK_EN		(1<<16)
+
+
+#elif defined (CONFIG_RALINK_RT5350)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_PCM_BASE			0xB0002000
+#define RALINK_GDMA_BASE		0xB0002800
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_USB_DEV_BASE		0x10120000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_HOST_BASE		0x101C0000
+
+#define RALINK_MCNT_CFG			0xB0000D00
+#define RALINK_COMPARE			0xB0000D04
+#define RALINK_COUNT			0xB0000D08
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_ESW		(1<<17)
+#define RALINK_INTCTL_USB_HOST		(1<<18)
+#define RALINK_INTCTL_USB_DEV		(1<<19)
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_WLAN_RST			(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_UHST_RST			(1<<22)
+#define RALINK_ESW_RST			(1<<23)
+#define RALINK_EPHY_RST			(1<<24)
+#define RALINK_UDEV_RST			(1<<25)
+#define RALINK_MIPSC_RST		(1<<28)
+
+//Clock Conf Register
+#define RALINK_UPHY0_CLK_EN		(1<<18)
+#define RALINK_GE1_CLK_EN		(1<<16)
+
+#elif defined (CONFIG_RALINK_RT2883)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_PCM_BASE			0xB0000400
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_GDMA_BASE		0xB0000700
+#define RALINK_NAND_CTRL_BASE		0xB0000800
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_PCI_BASE			0xB0140000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_OTG_BASE		0x101C0000
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_NAND		(1<<8)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_OTG		(1<<18)
+#define RALINK_INTCTL_OTG_IRQN		18
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_CPU_RST			(1<<1)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_WLAN_RST			(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_OTG_RST			(1<<22)
+#define RALINK_PCIE_RST			(1<<23)
+
+#elif defined (CONFIG_RALINK_RT3883)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_NOR_CTRL_BASE		0xB0000700
+#define RALINK_NAND_CTRL_BASE		0xB0000810
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_PCM_BASE			0xB0002000
+#define RALINK_GDMA_BASE		0xB0002800
+#define RALINK_CODEC1_BASE		0xB0003000
+#define RALINK_CODEC2_BASE		0xB0003800
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_USB_DEV_BASE		0x10120000
+#define RALINK_PCI_BASE			0xB0140000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_HOST_BASE		0x101C0000
+#define RALINK_PCIE_BASE		0xB0200000
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_NAND		(1<<8)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_UHST		(1<<18)
+#define RALINK_INTCTL_UDEV		(1<<19)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_NAND_RST			(1<<15)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_WLAN_RST			(1<<20)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_UHST_RST			(1<<22)
+#define RALINK_PCIE_RST			(1<<23)
+#define RALINK_PCI_RST			(1<<24)
+#define RALINK_UDEV_RST			(1<<25)
+#define RALINK_FLASH_RST		(1<<26)
+
+//Clock Conf Register
+#define RALINK_UPHY1_CLK_EN		(1<<20)
+#define RALINK_UPHY0_CLK_EN		(1<<18)
+#define RALINK_GE1_CLK_EN		(1<<16)
+
+#elif defined (CONFIG_RALINK_RT6855)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_NAND_CTRL_BASE		0xB0000800
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_PCM_BASE			0xB0002000
+#define RALINK_GDMA_BASE		0xB0002800
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_PCI_BASE                 0xB0140000
+#define RALINK_USB_DEV_BASE		0x10120000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_HOST_BASE		0x101C0000
+
+#define RALINK_MCNT_CFG			0xB0000D00
+#define RALINK_COMPARE			0xB0000D04
+#define RALINK_COUNT			0xB0000D08
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_ESW		(1<<17)
+#define RALINK_INTCTL_OTG		(1<<18)
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_UHST_RST			(1<<22)
+#define RALINK_ESW_RST			(1<<23)
+#define RALINK_EPHY_RST			(1<<24)
+#define RALINK_UDEV_RST			(1<<25)
+#define RALINK_PCIE0_RST		(1<<26)
+#define RALINK_PCIE1_RST		(1<<27)
+
+//Clock Conf Register
+#define RALINK_UPHY0_CLK_EN		(1<<25)
+#define RALINK_PCIE0_CLK_EN		(1<<26)
+#define RALINK_PCIE1_CLK_EN		(1<<27)
+
+
+#elif defined (CONFIG_RALINK_MT7620)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_RBUS_MATRIXCTL_BASE	0xB0000400
+#define RALINK_UART_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_NAND_CTRL_BASE		0xB0000810
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE_BASE		0x10000C00
+#define RALINK_MIPS_CNT_BASE		0x10000D00
+#define RALINK_PCM_BASE			0xB0002000
+#define RALINK_GDMA_BASE		0xB0002800
+#define RALINK_CRYPTO_ENGINE_BASE	0xB0004000
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_PPE_BASE			0xB0100C00
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_USB_DEV_BASE		0x10120000
+#define RALINK_MSDC_BASE		0xB0130000
+#define RALINK_PCI_BASE                 0xB0140000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_HOST_BASE		0x101C0000
+
+#define RALINK_MCNT_CFG			0xB0000D00
+#define RALINK_COMPARE			0xB0000D04
+#define RALINK_COUNT			0xB0000D08
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL		(1<<0)
+#define RALINK_INTCTL_TIMER0		(1<<1)
+#define RALINK_INTCTL_WDTIMER		(1<<2)
+#define RALINK_INTCTL_ILL_ACCESS	(1<<3)
+#define RALINK_INTCTL_PCM		(1<<4)
+#define RALINK_INTCTL_UART		(1<<5)
+#define RALINK_INTCTL_PIO		(1<<6)
+#define RALINK_INTCTL_DMA		(1<<7)
+#define RALINK_INTCTL_PC		(1<<9)
+#define RALINK_INTCTL_I2S		(1<<10)
+#define RALINK_INTCTL_SPI		(1<<11)
+#define RALINK_INTCTL_UARTLITE		(1<<12)
+#define RALINK_INTCTL_CRYPTO		(1<<13)
+#define RALINK_INTCTL_ESW		(1<<17)
+#define RALINK_INTCTL_UHST		(1<<18)
+#define RALINK_INTCTL_UDEV		(1<<19)
+#define RALINK_INTCTL_GLOBAL		(1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_UART_RST			(1<<12)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UARTL_RST		(1<<19)
+#define RALINK_FE_RST			(1<<21)
+#define RALINK_UHST_RST			(1<<22)
+#define RALINK_ESW_RST			(1<<23)
+#define RALINK_EPHY_RST			(1<<24)
+#define RALINK_UDEV_RST			(1<<25)
+#define RALINK_PCIE0_RST		(1<<26)
+#define RALINK_PCIE1_RST		(1<<27)
+#define RALINK_MIPS_CNT_RST		(1<<28)
+#define RALINK_CRYPTO_RST		(1<<29)
+
+//Clock Conf Register
+#define RALINK_UPHY0_CLK_EN		(1<<25)
+#define RALINK_UPHY1_CLK_EN		(1<<22)
+#define RALINK_PCIE0_CLK_EN		(1<<26)
+#define RALINK_PCIE1_CLK_EN		(1<<27)
+
+//CPU PLL CFG Register
+#define CPLL_SW_CONFIG                  (0x1UL << 31)
+#define CPLL_MULT_RATIO_SHIFT           16
+#define CPLL_MULT_RATIO                 (0x7UL << CPLL_MULT_RATIO_SHIFT)
+#define CPLL_DIV_RATIO_SHIFT            10
+#define CPLL_DIV_RATIO                  (0x3UL << CPLL_DIV_RATIO_SHIFT)
+#define BASE_CLOCK                      40      /* Mhz */
+
+#elif defined (CONFIG_RALINK_MT7621)
+
+#define RALINK_SYSCTL_BASE		0xBE000000
+#define RALINK_TIMER_BASE		0xBE000100
+#define RALINK_INTCL_BASE		0xBE000200
+#define RALINK_RBUS_MATRIXCTL_BASE	0xBE000400
+#define RALINK_MIPS_CNT_BASE		0x1E000500
+#define RALINK_PIO_BASE			0xBE000600
+#define RALINK_SPDIF_BASE		0xBE000700
+#define RALINK_I2C_BASE			0xBE000900
+#define RALINK_I2S_BASE			0xBE000A00
+#define RALINK_SPI_BASE			0xBE000B00
+#define RALINK_UART_LITE1_BASE		0x1E000C00
+#define RALINK_UART_LITE_BASE		RALINK_UART_LITE1_BASE
+#define RALINK_UART_LITE2_BASE		0x1E000D00
+#define RALINK_UART_BASE		RALINK_UART_LITE2_BASE
+#define RALINK_UART_LITE3_BASE		0x1E000E00
+#define RALINK_ANA_CTRL_BASE		0xBE000F00
+#define RALINK_PCM_BASE			0xBE002000
+#define RALINK_GDMA_BASE		0xBE002800
+#define RALINK_NAND_CTRL_BASE		0xBE003000
+#define RALINK_NANDECC_CTRL_BASE	0xBE003800
+#define RALINK_CRYPTO_ENGINE_BASE	0xBE004000
+#define RALINK_MEMCTRL_BASE		0xBE005000
+#define RALINK_EXT_MC_ARB_BASE		0xBE006000
+#define RALINK_HS_DMA_BASE		0xBE007000
+#define RALINK_FRAME_ENGINE_BASE	0xBE100000
+#define RALINK_PPE_BASE			0xBE100C00
+#define RALINK_ETH_SW_BASE		0xBE110000
+#define RALINK_ROM_BASE			0xBE118000
+#define RALINK_MSDC_BASE		0xBE130000
+#define RALINK_PCI_BASE                 0xBE140000
+#define RALINK_USB_HOST_BASE		0x1E1C0000
+#define RALINK_11N_MAC_BASE		0xBE180000 //Unused
+
+#define RALINK_MCNT_CFG			0xBE000500
+#define RALINK_COMPARE			0xBE000504
+#define RALINK_COUNT			0xBE000508
+
+//Interrupt Controller
+#define RALINK_INTCTL_FE		(1<<3)
+#define RALINK_INTCTL_PCIE0		(1<<4)
+#define RALINK_INTCTL_SYSCTL		(1<<6)
+#define RALINK_INTCTL_I2C		(1<<8)
+#define RALINK_INTCTL_DRAMC		(1<<9)
+#define RALINK_INTCTL_PCM		(1<<10)
+#define RALINK_INTCTL_HSDMA		(1<<11)
+#define RALINK_INTCTL_PIO		(1<<12)
+#define RALINK_INTCTL_DMA		(1<<13)
+#define RALINK_INTCTL_NFI		(1<<14)
+#define RALINK_INTCTL_NFIECC		(1<<15)
+#define RALINK_INTCTL_I2S		(1<<16)
+#define RALINK_INTCTL_SPI		(1<<17)
+#define RALINK_INTCTL_SPDIF		(1<<18)
+#define RALINK_INTCTL_CRYPTO		(1<<19)
+#define RALINK_INTCTL_SDXC		(1<<20)
+#define RALINK_INTCTL_PCTRL		(1<<21)
+#define RALINK_INTCTL_USB		(1<<22)
+#define RALINK_INTCTL_SWITCH		(1<<23)
+#define RALINK_INTCTL_PCIE1		(1<<24)
+#define RALINK_INTCTL_PCIE2		(1<<25)
+#define RALINK_INTCTL_UART1		(1<<26)
+#define RALINK_INTCTL_UART2		(1<<27)
+#define RALINK_INTCTL_UART3		(1<<28)
+#define RALINK_INTCTL_WDTIMER		(1<<29)
+#define RALINK_INTCTL_TIMER0		(1<<30)
+#define RALINK_INTCTL_TIMER1		(1<<31)
+
+
+//Reset Control Register
+#define RALINK_SYS_RST			(1<<0)
+#define RALINK_MCM_RST			(1<<1)
+#define RALINK_HSDMA_RST		(1<<2)
+#define RALINK_FE_RST			(1<<6)
+#define RALINK_SPDIF_RST		(1<<7)
+#define RALINK_TIMER_RST		(1<<8)
+#define RALINK_INTC_RST			(1<<9)
+#define RALINK_MC_RST			(1<<10)
+#define RALINK_PCM_RST			(1<<11)
+#define RALINK_PIO_RST			(1<<13)
+#define RALINK_DMA_RST			(1<<14)
+#define RALINK_NAND_RST			(1<<15)
+#define RALINK_I2C_RST			(1<<16)
+#define RALINK_I2S_RST			(1<<17)
+#define RALINK_SPI_RST			(1<<18)
+#define RALINK_UART1_RST		(1<<19)
+#define RALINK_UART2_RST		(1<<20)
+#define RALINK_UART3_RST		(1<<21)
+#define RALINK_ETH_RST			(1<<23)
+#define RALINK_PCIE0_RST		(1<<24)
+#define RALINK_PCIE1_RST		(1<<25)
+#define RALINK_PCIE2_RST		(1<<26)
+#define RALINK_AUX_STCK_RST		(1<<28)
+#define RALINK_CRYPTO_RST		(1<<29)
+#define RALINK_SDXC_RST			(1<<30)
+#define RALINK_PPE_RST			(1<<31)
+
+//Clock Conf Register
+#define RALINK_PCIE0_CLK_EN		(1<<24)
+#define RALINK_PCIE1_CLK_EN		(1<<25)
+#define RALINK_PCIE2_CLK_EN		(1<<26)
+//#define RALINK_UPHY0_CLK_EN		(1<<27)
+//#define RALINK_UPHY1_CLK_EN		(1<<28)
+
+//CPU PLL CFG Register
+#define CPLL_SW_CONFIG                  (0x1UL << 31)
+#define CPLL_MULT_RATIO_SHIFT           16
+#define CPLL_MULT_RATIO                 (0x7UL << CPLL_MULT_RATIO_SHIFT)
+#define CPLL_DIV_RATIO_SHIFT            10
+#define CPLL_DIV_RATIO                  (0x3UL << CPLL_DIV_RATIO_SHIFT)
+#define BASE_CLOCK                      40      /* Mhz */
+
+#define RALINK_TESTSTAT			0xBE000018
+#define RALINK_TESTSTAT2		0xBE00001C
+
+#elif defined (CONFIG_RALINK_MT7628)
+
+#define RALINK_SYSCTL_BASE		0xB0000000
+#define RALINK_TIMER_BASE		0xB0000100
+#define RALINK_INTCL_BASE		0xB0000200
+#define RALINK_MEMCTRL_BASE		0xB0000300
+#define RALINK_RBUS_MATRIXCTL_BASE	0xB0000400
+#define RALINK_MIPS_CNT_BASE		0x10000500
+#define RALINK_PIO_BASE			0xB0000600
+#define RALINK_SPI_SLAVE_BASE		0xB0000700
+#define RALINK_I2C_BASE			0xB0000900
+#define RALINK_I2S_BASE			0xB0000A00
+#define RALINK_SPI_BASE			0xB0000B00
+#define RALINK_UART_LITE1_BASE		0x10000C00
+#define RALINK_UART_LITE_BASE		RALINK_UART_LITE1_BASE
+#define RALINK_UART_LITE2_BASE		0x10000D00
+#define RALINK_UART_BASE		RALINK_UART_LITE2_BASE
+#define RALINK_UART_LITE3_BASE		0x10000E00
+#define RALINK_PCM_BASE			0xB0002000
+#define RALINK_GDMA_BASE		0xB0002800
+#define RALINK_AES_ENGINE_BASE		0xB0004000
+#define RALINK_CRYPTO_ENGINE_BASE	RALINK_AES_ENGINE_BASE
+#define RALINK_FRAME_ENGINE_BASE	0xB0100000
+#define RALINK_PPE_BASE			0xB0100C00
+#define RALINK_ETH_SW_BASE		0xB0110000
+#define RALINK_USB_DEV_BASE		0xB0120000
+#define RALINK_MSDC_BASE		0xB0130000
+#define RALINK_PCI_BASE                 0xB0140000
+#define RALINK_11N_MAC_BASE		0xB0180000
+#define RALINK_USB_HOST_BASE		0x101C0000
+
+#define RALINK_MCNT_CFG			0xB0000500
+#define RALINK_COMPARE			0xB0000504
+#define RALINK_COUNT			0xB0000508
+
+
+//Interrupt Controller
+#define RALINK_INTCTL_SYSCTL            (1<<0)
+#define RALINK_INTCTL_TIMER0            (1<<1)
+#define RALINK_INTCTL_WDTIMER           (1<<2)
+#define RALINK_INTCTL_ILL_ACCESS        (1<<3)
+#define RALINK_INTCTL_PCM               (1<<4)
+#define RALINK_INTCTL_UART              (1<<5)
+#define RALINK_INTCTL_PIO               (1<<6)
+#define RALINK_INTCTL_DMA               (1<<7)
+#define RALINK_INTCTL_PC                (1<<9)
+#define RALINK_INTCTL_I2S               (1<<10)
+#define RALINK_INTCTL_SPI               (1<<11)
+#define RALINK_INTCTL_UARTLITE          (1<<12)
+#define RALINK_INTCTL_CRYPTO            (1<<13)
+#define RALINK_INTCTL_ESW               (1<<17)
+#define RALINK_INTCTL_UHST              (1<<18)
+#define RALINK_INTCTL_UDEV              (1<<19)
+#define RALINK_INTCTL_GLOBAL            (1<<31)
+
+//Reset Control Register
+#define RALINK_SYS_RST                  (1<<0)
+#define RALINK_TIMER_RST                (1<<8)
+#define RALINK_INTC_RST                 (1<<9)
+#define RALINK_MC_RST                   (1<<10)
+#define RALINK_PCM_RST                  (1<<11)
+#define RALINK_UART_RST                 (1<<12)
+#define RALINK_PIO_RST                  (1<<13)
+#define RALINK_DMA_RST                  (1<<14)
+#define RALINK_I2C_RST                  (1<<16)
+#define RALINK_I2S_RST                  (1<<17)
+#define RALINK_SPI_RST                  (1<<18)
+#define RALINK_UARTL_RST                (1<<19)
+#define RALINK_FE_RST                   (1<<21)
+#define RALINK_UHST_RST                 (1<<22)
+#define RALINK_ESW_RST                  (1<<23)
+#define RALINK_EPHY_RST                 (1<<24)
+#define RALINK_UDEV_RST                 (1<<25)
+#define RALINK_PCIE0_RST                (1<<26)
+#define RALINK_PCIE1_RST                (1<<27)
+#define RALINK_MIPS_CNT_RST             (1<<28)
+#define RALINK_CRYPTO_RST               (1<<29)
+
+//Clock Conf Register
+#define RALINK_UPHY0_CLK_EN		(1<<25)
+#define RALINK_UPHY1_CLK_EN		(1<<22)
+#define RALINK_PCIE0_CLK_EN		(1<<26)
+#define RALINK_PCIE1_CLK_EN		(1<<27)
+
+//CPU PLL CFG Register
+#define CPLL_SW_CONFIG                  (0x1UL << 31)
+#define CPLL_MULT_RATIO_SHIFT           16
+#define CPLL_MULT_RATIO                 (0x7UL << CPLL_MULT_RATIO_SHIFT)
+#define CPLL_DIV_RATIO_SHIFT            10
+#define CPLL_DIV_RATIO                  (0x3UL << CPLL_DIV_RATIO_SHIFT)
+#define BASE_CLOCK                      40      /* Mhz */
+
+#endif
+#endif
diff --git a/arch/mips/include/asm/rt2880/serial_rt2880.h b/arch/mips/include/asm/rt2880/serial_rt2880.h
new file mode 100644
index 0000000..74f024f
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/serial_rt2880.h
@@ -0,0 +1,443 @@
+/**************************************************************************
+ *
+ *  BRIEF MODULE DESCRIPTION
+ *     serial port definition for Ralink RT2880 solution
+ *
+ *  Copyright 2007 Ralink Inc. (bruce_chang@ralinktech.com.tw)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ **************************************************************************
+ * May 2007 Bruce Chang
+ *
+ * Initial Release
+ *
+ *
+ *
+ **************************************************************************
+ */
+
+#if defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
+#define RT2880_UART_RBR_OFFSET  0x00
+#define RT2880_UART_TBR_OFFSET  0x00
+#define RT2880_UART_IER_OFFSET  0x04
+#define RT2880_UART_IIR_OFFSET  0x08
+#define RT2880_UART_FCR_OFFSET  0x08
+#define RT2880_UART_LCR_OFFSET  0x0C
+#define RT2880_UART_MCR_OFFSET  0x10
+#define RT2880_UART_LSR_OFFSET  0x14
+#define RT2880_UART_DLL_OFFSET  0x00
+#define RT2880_UART_DLM_OFFSET  0x04
+#else
+#define RT2880_UART_RBR_OFFSET  0x00
+#define RT2880_UART_TBR_OFFSET  0x04
+#define RT2880_UART_IER_OFFSET  0x08
+#define RT2880_UART_IIR_OFFSET  0x0C
+#define RT2880_UART_FCR_OFFSET  0x10
+#define RT2880_UART_LCR_OFFSET  0x14
+#define RT2880_UART_MCR_OFFSET  0x18
+#define RT2880_UART_LSR_OFFSET  0x1C
+#define RT2880_UART_DLL_OFFSET  0x2C
+#define RT2880_UART_DLM_OFFSET  0x30
+#endif
+
+#define RBR(x)          *(volatile u32 *)((x)+RT2880_UART_RBR_OFFSET)
+#define TBR(x)          *(volatile u32 *)((x)+RT2880_UART_TBR_OFFSET)
+#define IER(x)          *(volatile u32 *)((x)+RT2880_UART_IER_OFFSET)
+#define IIR(x)          *(volatile u32 *)((x)+RT2880_UART_IIR_OFFSET)
+#define FCR(x)          *(volatile u32 *)((x)+RT2880_UART_FCR_OFFSET)
+#define LCR(x)          *(volatile u32 *)((x)+RT2880_UART_LCR_OFFSET)
+#define MCR(x)          *(volatile u32 *)((x)+RT2880_UART_MCR_OFFSET)
+#define LSR(x)          *(volatile u32 *)((x)+RT2880_UART_LSR_OFFSET)
+#define DLL(x)          *(volatile u32 *)((x)+RT2880_UART_DLL_OFFSET)
+#define DLM(x)          *(volatile u32 *)((x)+RT2880_UART_DLM_OFFSET)
+
+
+#if defined (CONFIG_RALINK_RT2880) || \
+    defined (CONFIG_RALINK_RT2883) || \
+    defined (CONFIG_RALINK_RT3883) || \
+    defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || \
+    defined (CONFIG_RALINK_RT6855) || \
+    defined (CONFIG_RALINK_MT7620) || \
+    defined (CONFIG_RALINK_RT3052)
+
+#define UART_RX		0	/* In:  Receive buffer (DLAB=0) */
+
+#define UART_TX		4	/* Out: Transmit buffer (DLAB=0) */
+#define UART_TRG	4	/* (LCR=BF) FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels
+				 * XR16C85x only
+				 */
+
+#define UART_IER	8	/* Out: Interrupt Enable Register */
+#define UART_FCTR	8	/* (LCR=BF) Feature Control Register
+				 * XR16C85x only
+				 */
+
+#define UART_IIR	12	/* In:  Interrupt ID Register */
+#define UART_EFR	12	/* I/O: Extended Features Register */
+				/* (DLAB=1, 16C660 only) */
+
+#define UART_FCR	16	/* Out: FIFO Control Register */
+#define UART_LCR	20	/* Out: Line Control Register */
+#define UART_MCR	24	/* Out: Modem Control Register */
+#define UART_LSR	28	/* In:  Line Status Register */
+#define UART_MSR	32	/* In:  Modem Status Register */
+#define UART_SCR	36	/* I/O: Scratch Register */
+#define UART_DLL	44	/* Out: Divisor Latch Low (DLAB=1) */
+/* Since surfboard uart cannot be accessed by byte, using UART_DLM will cause
+ * unpredictable values to be written to the Divisor Latch
+ */
+#define UART_DLM	48	/* Out: Divisor Latch High (DLAB=1) */
+
+#else
+
+#define UART_RX		0	/* In:  Receive buffer */
+#define UART_TX		0	/* Out: Transmit buffer */
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+				 * In: Fifo count
+				 * Out: Fifo custom trigger levels */
+
+#define UART_DLM	4	/* Out: Divisor Latch High */
+#define UART_IER	4	/* Out: Interrupt Enable Register */
+#define UART_FCTR	4	/* Feature Control Register */
+
+#define UART_IIR	8	/* In:  Interrupt ID Register */
+#define UART_FCR	8	/* Out: FIFO Control Register */
+#define UART_EFR	8	/* I/O: Extended Features Register */
+
+#define UART_LCR	12	/* Out: Line Control Register */
+#define UART_MCR	16	/* Out: Modem Control Register */
+#define UART_LSR	20	/* In:  Line Status Register */
+#define UART_MSR	24	/* In:  Modem Status Register */
+#define UART_SCR	28	/* I/O: Scratch Register */
+#define UART_EMSR	28	/* Extended Mode Select Register */
+
+#endif
+/*
+ * DLAB=0
+ */
+//#define UART_IER	1	/* Out: Interrupt Enable Register */
+#define UART_IER_MSI		0x08 /* Enable Modem status interrupt */
+#define UART_IER_RLSI		0x04 /* Enable receiver line status interrupt */
+#define UART_IER_THRI		0x02 /* Enable Transmitter holding register int. */
+#define UART_IER_RDI		0x01 /* Enable receiver data interrupt */
+/*
+ * Sleep mode for ST16650 and TI16750.  For the ST16650, EFR[4]=1
+ */
+#define UART_IERX_SLEEP		0x10 /* Enable sleep mode */
+
+//#define UART_IIR	2	/* In:  Interrupt ID Register */
+#define UART_IIR_NO_INT		0x01 /* No interrupts pending */
+#define UART_IIR_ID		0x06 /* Mask for the interrupt ID */
+#define UART_IIR_MSI		0x00 /* Modem status interrupt */
+#define UART_IIR_THRI		0x02 /* Transmitter holding register empty */
+#define UART_IIR_RDI		0x04 /* Receiver data interrupt */
+#define UART_IIR_RLSI		0x06 /* Receiver line status interrupt */
+
+//#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_FCR_ENABLE_FIFO	0x01 /* Enable the FIFO */
+#define UART_FCR_CLEAR_RCVR	0x02 /* Clear the RCVR FIFO */
+#define UART_FCR_CLEAR_XMIT	0x04 /* Clear the XMIT FIFO */
+#define UART_FCR_DMA_SELECT	0x08 /* For DMA applications */
+/*
+ * Note: The FIFO trigger levels are chip specific:
+ *	RX:76 = 00  01  10  11	TX:54 = 00  01  10  11
+ * PC16550D:	 1   4   8  14		xx  xx  xx  xx
+ * TI16C550A:	 1   4   8  14          xx  xx  xx  xx
+ * TI16C550C:	 1   4   8  14          xx  xx  xx  xx
+ * ST16C550:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C650:	 8  16  24  28		16   8  24  30	PORT_16650V2
+ * NS16C552:	 1   4   8  14		xx  xx  xx  xx
+ * ST16C654:	 8  16  56  60		 8  16  32  56	PORT_16654
+ * TI16C750:	 1  16  32  56		xx  xx  xx  xx	PORT_16750
+ * TI16C752:	 8  16  56  60		 8  16  32  56
+ */
+#define UART_FCR_R_TRIG_00	0x00
+#define UART_FCR_R_TRIG_01	0x40
+#define UART_FCR_R_TRIG_10	0x80
+#define UART_FCR_R_TRIG_11	0xc0
+#define UART_FCR_T_TRIG_00	0x00
+#define UART_FCR_T_TRIG_01	0x10
+#define UART_FCR_T_TRIG_10	0x20
+#define UART_FCR_T_TRIG_11	0x30
+
+#define UART_FCR_TRIGGER_MASK	0xC0 /* Mask for the FIFO trigger range */
+#define UART_FCR_TRIGGER_1	0x00 /* Mask for trigger set at 1 */
+#define UART_FCR_TRIGGER_4	0x40 /* Mask for trigger set at 4 */
+#define UART_FCR_TRIGGER_8	0x80 /* Mask for trigger set at 8 */
+#define UART_FCR_TRIGGER_14	0xC0 /* Mask for trigger set at 14 */
+/* 16650 definitions */
+#define UART_FCR6_R_TRIGGER_8	0x00 /* Mask for receive trigger set at 1 */
+#define UART_FCR6_R_TRIGGER_16	0x40 /* Mask for receive trigger set at 4 */
+#define UART_FCR6_R_TRIGGER_24  0x80 /* Mask for receive trigger set at 8 */
+#define UART_FCR6_R_TRIGGER_28	0xC0 /* Mask for receive trigger set at 14 */
+#define UART_FCR6_T_TRIGGER_16	0x00 /* Mask for transmit trigger set at 16 */
+#define UART_FCR6_T_TRIGGER_8	0x10 /* Mask for transmit trigger set at 8 */
+#define UART_FCR6_T_TRIGGER_24  0x20 /* Mask for transmit trigger set at 24 */
+#define UART_FCR6_T_TRIGGER_30	0x30 /* Mask for transmit trigger set at 30 */
+#define UART_FCR7_64BYTE	0x20 /* Go into 64 byte mode (TI16C750) */
+
+//#define UART_LCR	3	/* Out: Line Control Register */
+/*
+ * Note: if the word length is 5 bits (UART_LCR_WLEN5), then setting 
+ * UART_LCR_STOP will select 1.5 stop bits, not 2 stop bits.
+ */
+#define UART_LCR_DLAB		0x80 /* Divisor latch access bit */
+#define UART_LCR_SBC		0x40 /* Set break control */
+#define UART_LCR_SPAR		0x20 /* Stick parity (?) */
+#define UART_LCR_EPAR		0x10 /* Even parity select */
+#define UART_LCR_PARITY		0x08 /* Parity Enable */
+#define UART_LCR_STOP		0x04 /* Stop bits: 0=1 bit, 1=2 bits */
+#define UART_LCR_WLEN5		0x00 /* Wordlength: 5 bits */
+#define UART_LCR_WLEN6		0x01 /* Wordlength: 6 bits */
+#define UART_LCR_WLEN7		0x02 /* Wordlength: 7 bits */
+#define UART_LCR_WLEN8		0x03 /* Wordlength: 8 bits */
+
+//#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_MCR_CLKSEL		0x80 /* Divide clock by 4 (TI16C752, EFR[4]=1) */
+#define UART_MCR_TCRTLR		0x40 /* Access TCR/TLR (TI16C752, EFR[4]=1) */
+#define UART_MCR_XONANY		0x20 /* Enable Xon Any (TI16C752, EFR[4]=1) */
+#define UART_MCR_AFE		0x20 /* Enable auto-RTS/CTS (TI16C550C/TI16C750) */
+#define UART_MCR_LOOP		0x10 /* Enable loopback test mode */
+#define UART_MCR_OUT2		0x08 /* Out2 complement */
+#define UART_MCR_OUT1		0x04 /* Out1 complement */
+#define UART_MCR_RTS		0x02 /* RTS complement */
+#define UART_MCR_DTR		0x01 /* DTR complement */
+
+//#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_TEMT		0x40 /* Transmitter empty */
+#define UART_LSR_THRE		0x20 /* Transmit-hold-register empty */
+#define UART_LSR_BI		0x10 /* Break interrupt indicator */
+#define UART_LSR_FE		0x08 /* Frame error indicator */
+#define UART_LSR_PE		0x04 /* Parity error indicator */
+#define UART_LSR_OE		0x02 /* Overrun error indicator */
+#define UART_LSR_DR		0x01 /* Receiver data ready */
+
+//#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_MSR_DCD		0x80 /* Data Carrier Detect */
+#define UART_MSR_RI		0x40 /* Ring Indicator */
+#define UART_MSR_DSR		0x20 /* Data Set Ready */
+#define UART_MSR_CTS		0x10 /* Clear to Send */
+#define UART_MSR_DDCD		0x08 /* Delta DCD */
+#define UART_MSR_TERI		0x04 /* Trailing edge ring indicator */
+#define UART_MSR_DDSR		0x02 /* Delta DSR */
+#define UART_MSR_DCTS		0x01 /* Delta CTS */
+#define UART_MSR_ANY_DELTA	0x0F /* Any of the delta bits! */
+
+//#define UART_SCR	7	/* I/O: Scratch Register */
+
+/*
+ * DLAB=1
+ */
+//#define UART_DLL	0	/* Out: Divisor Latch Low */
+//#define UART_DLM	1	/* Out: Divisor Latch High */
+
+/*
+ * LCR=0xBF (or DLAB=1 for 16C660)
+ */
+//#define UART_EFR	2	/* I/O: Extended Features Register */
+#define UART_EFR_CTS		0x80 /* CTS flow control */
+#define UART_EFR_RTS		0x40 /* RTS flow control */
+#define UART_EFR_SCD		0x20 /* Special character detect */
+#define UART_EFR_ECB		0x10 /* Enhanced control bit */
+/*
+ * the low four bits control software flow control
+ */
+
+/*
+ * LCR=0xBF, TI16C752, ST16650, ST16650A, ST16654
+ */
+#define UART_XON1	4	/* I/O: Xon character 1 */
+#define UART_XON2	5	/* I/O: Xon character 2 */
+#define UART_XOFF1	6	/* I/O: Xoff character 1 */
+#define UART_XOFF2	7	/* I/O: Xoff character 2 */
+
+/*
+ * EFR[4]=1 MCR[6]=1, TI16C752
+ */
+#define UART_TI752_TCR	6	/* I/O: transmission control register */
+#define UART_TI752_TLR	7	/* I/O: trigger level register */
+
+/*
+ * LCR=0xBF, XR16C85x
+ */
+//#define UART_TRG	0	/* FCTR bit 7 selects Rx or Tx
+//				 * In: Fifo count
+//				 * Out: Fifo custom trigger levels */
+/*
+ * These are the definitions for the Programmable Trigger Register
+ */
+#define UART_TRG_1		0x01
+#define UART_TRG_4		0x04
+#define UART_TRG_8		0x08
+#define UART_TRG_16		0x10
+#define UART_TRG_32		0x20
+#define UART_TRG_64		0x40
+#define UART_TRG_96		0x60
+#define UART_TRG_120		0x78
+#define UART_TRG_128		0x80
+
+//#define UART_FCTR	1	/* Feature Control Register */
+#define UART_FCTR_RTS_NODELAY	0x00  /* RTS flow control delay */
+#define UART_FCTR_RTS_4DELAY	0x01
+#define UART_FCTR_RTS_6DELAY	0x02
+#define UART_FCTR_RTS_8DELAY	0x03
+#define UART_FCTR_IRDA		0x04  /* IrDa data encode select */
+#define UART_FCTR_TX_INT	0x08  /* Tx interrupt type select */
+#define UART_FCTR_TRGA		0x00  /* Tx/Rx 550 trigger table select */
+#define UART_FCTR_TRGB		0x10  /* Tx/Rx 650 trigger table select */
+#define UART_FCTR_TRGC		0x20  /* Tx/Rx 654 trigger table select */
+#define UART_FCTR_TRGD		0x30  /* Tx/Rx 850 programmable trigger select */
+#define UART_FCTR_SCR_SWAP	0x40  /* Scratch pad register swap */
+#define UART_FCTR_RX		0x00  /* Programmable trigger mode select */
+#define UART_FCTR_TX		0x80  /* Programmable trigger mode select */
+
+/*
+ * LCR=0xBF, FCTR[6]=1
+ */
+//#define UART_EMSR	7	/* Extended Mode Select Register */
+#define UART_EMSR_FIFO_COUNT	0x01  /* Rx/Tx select */
+#define UART_EMSR_ALT_COUNT	0x02  /* Alternating count select */
+
+/*
+ * The Intel XScale on-chip UARTs define these bits
+ */
+#define UART_IER_DMAE	0x80	/* DMA Requests Enable */
+#define UART_IER_UUE	0x40	/* UART Unit Enable */
+#define UART_IER_NRZE	0x20	/* NRZ coding Enable */
+#define UART_IER_RTOIE	0x10	/* Receiver Time Out Interrupt Enable */
+
+#define UART_IIR_TOD	0x08	/* Character Timeout Indication Detected */
+
+#define UART_FCR_PXAR1	0x00	/* receive FIFO treshold = 1 */
+#define UART_FCR_PXAR8	0x40	/* receive FIFO treshold = 8 */
+#define UART_FCR_PXAR16	0x80	/* receive FIFO treshold = 16 */
+#define UART_FCR_PXAR32	0xc0	/* receive FIFO treshold = 32 */
+
+
+
+
+/*
+ * These register definitions are for the 16C950
+ */
+#define UART_ASR	0x01	/* Additional Status Register */
+#define UART_RFL	0x03	/* Receiver FIFO level */
+#define UART_TFL 	0x04	/* Transmitter FIFO level */
+#define UART_ICR	0x05	/* Index Control Register */
+
+/* The 16950 ICR registers */
+#define UART_ACR	0x00	/* Additional Control Register */
+#define UART_CPR	0x01	/* Clock Prescalar Register */
+#define UART_TCR	0x02	/* Times Clock Register */
+#define UART_CKS	0x03	/* Clock Select Register */
+#define UART_TTL	0x04	/* Transmitter Interrupt Trigger Level */
+#define UART_RTL	0x05	/* Receiver Interrupt Trigger Level */
+#define UART_FCL	0x06	/* Flow Control Level Lower */
+#define UART_FCH	0x07	/* Flow Control Level Higher */
+#define UART_ID1	0x08	/* ID #1 */
+#define UART_ID2	0x09	/* ID #2 */
+#define UART_ID3	0x0A	/* ID #3 */
+#define UART_REV	0x0B	/* Revision */
+#define UART_CSR	0x0C	/* Channel Software Reset */
+#define UART_NMR	0x0D	/* Nine-bit Mode Register */
+#define UART_CTR	0xFF
+
+/*
+ * The 16C950 Additional Control Reigster
+ */
+#define UART_ACR_RXDIS	0x01	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Receiver disable */
+#define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
+#define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
+#define UART_ACR_ICRRD	0x40	/* ICR Read enable */
+#define UART_ACR_ASREN	0x80	/* Additional status enable */
+
+
+
+/*
+ * These definitions are for the RSA-DV II/S card, from
+ *
+ * Kiyokazu SUTO <suto@ks-and-ks.ne.jp>
+ */
+
+#define UART_RSA_BASE (-8)
+
+#define UART_RSA_MSR ((UART_RSA_BASE) + 0) /* I/O: Mode Select Register */
+
+#define UART_RSA_MSR_SWAP (1 << 0) /* Swap low/high 8 bytes in I/O port addr */
+#define UART_RSA_MSR_FIFO (1 << 2) /* Enable the external FIFO */
+#define UART_RSA_MSR_FLOW (1 << 3) /* Enable the auto RTS/CTS flow control */
+#define UART_RSA_MSR_ITYP (1 << 4) /* Level (1) / Edge triger (0) */
+
+#define UART_RSA_IER ((UART_RSA_BASE) + 1) /* I/O: Interrupt Enable Register */
+
+#define UART_RSA_IER_Rx_FIFO_H (1 << 0) /* Enable Rx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_H (1 << 1) /* Enable Tx FIFO half full int. */
+#define UART_RSA_IER_Tx_FIFO_E (1 << 2) /* Enable Tx FIFO empty int. */
+#define UART_RSA_IER_Rx_TOUT (1 << 3) /* Enable char receive timeout int */
+#define UART_RSA_IER_TIMER (1 << 4) /* Enable timer interrupt */
+
+#define UART_RSA_SRR ((UART_RSA_BASE) + 2) /* IN: Status Read Register */
+
+#define UART_RSA_SRR_Tx_FIFO_NEMP (1 << 0) /* Tx FIFO is not empty (1) */
+#define UART_RSA_SRR_Tx_FIFO_NHFL (1 << 1) /* Tx FIFO is not half full (1) */
+#define UART_RSA_SRR_Tx_FIFO_NFUL (1 << 2) /* Tx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NEMP (1 << 3) /* Rx FIFO is not empty (1) */
+#define UART_RSA_SRR_Rx_FIFO_NHFL (1 << 4) /* Rx FIFO is not half full (1) */
+#define UART_RSA_SRR_Rx_FIFO_NFUL (1 << 5) /* Rx FIFO is not full (1) */
+#define UART_RSA_SRR_Rx_TOUT (1 << 6) /* Character reception timeout occurred (1) */
+#define UART_RSA_SRR_TIMER (1 << 7) /* Timer interrupt occurred */
+
+#define UART_RSA_FRR ((UART_RSA_BASE) + 2) /* OUT: FIFO Reset Register */
+
+#define UART_RSA_TIVSR ((UART_RSA_BASE) + 3) /* I/O: Timer Interval Value Set Register */
+
+#define UART_RSA_TCR ((UART_RSA_BASE) + 4) /* OUT: Timer Control Register */
+
+#define UART_RSA_TCR_SWITCH (1 << 0) /* Timer on */
+
+/*
+ * The RSA DSV/II board has two fixed clock frequencies.  One is the
+ * standard rate, and the other is 8 times faster.
+ */
+#define SERIAL_RSA_BAUD_BASE (921600)
+#define SERIAL_RSA_BAUD_BASE_LO (SERIAL_RSA_BAUD_BASE / 8)
+
+/*
+ * Extra serial register definitions for the internal UARTs
+ * in TI OMAP processors.
+ */
+#define UART_OMAP_MDR1		0x08	/* Mode definition register */
+#define UART_OMAP_MDR2		0x09	/* Mode definition register 2 */
+#define UART_OMAP_SCR		0x10	/* Supplementary control register */
+#define UART_OMAP_SSR		0x11	/* Supplementary status register */
+#define UART_OMAP_EBLR		0x12	/* BOF length register */
+#define UART_OMAP_OSC_12M_SEL	0x13	/* OMAP1510 12MHz osc select */
+#define UART_OMAP_MVER		0x14	/* Module version register */
+#define UART_OMAP_SYSC		0x15	/* System configuration register */
+#define UART_OMAP_SYSS		0x16	/* System status register */
+
+
diff --git a/arch/mips/include/asm/rt2880/sizes.h b/arch/mips/include/asm/rt2880/sizes.h
new file mode 100644
index 0000000..7f50ae0
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/sizes.h
@@ -0,0 +1,52 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* DO NOT EDIT!! - this file automatically generated
+ *                 from .s file by awk -f s2h.awk
+ */
+/*  Size definitions
+ *  Copyright (C) ARM Limited 1998. All rights reserved.
+ */
+
+#ifndef __sizes_h
+#define __sizes_h                       1
+
+/* handy sizes */
+#define SZ_1K                           0x00000400
+#define SZ_4K                           0x00001000
+#define SZ_8K                           0x00002000
+#define SZ_16K                          0x00004000
+#define SZ_64K                          0x00010000
+#define SZ_128K                         0x00020000
+#define SZ_256K                         0x00040000
+#define SZ_512K                         0x00080000
+
+#define SZ_1M                           0x00100000
+#define SZ_2M                           0x00200000
+#define SZ_4M                           0x00400000
+#define SZ_8M                           0x00800000
+#define SZ_16M                          0x01000000
+#define SZ_32M                          0x02000000
+#define SZ_64M                          0x04000000
+#define SZ_128M                         0x08000000
+#define SZ_256M                         0x10000000
+#define SZ_512M                         0x20000000
+
+#define SZ_1G                           0x40000000
+#define SZ_2G                           0x80000000
+
+#endif
+
+/*         END */
diff --git a/arch/mips/include/asm/rt2880/surfboard.h b/arch/mips/include/asm/rt2880/surfboard.h
new file mode 100644
index 0000000..373da34
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/surfboard.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2001 Palmchip Corporation.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ */
+#ifndef _SURFBOARD_H
+#define _SURFBOARD_H
+
+#include <asm/addrspace.h>
+
+
+
+/*
+ * Surfboard system clock.
+ * This is the default value and maybe overidden by System Clock passed on the
+ * command line (sysclk=).
+ */
+#define SURFBOARD_SYSTEM_CLOCK		(125000000)
+
+/*
+ * Surfboard UART base baud rate = System Clock / 16.
+ * Ex. (14.7456 MHZ / 16) = 921600
+ *     (32.0000 MHZ / 16) = 2000000
+ */
+#define SURFBOARD_BAUD_DIV	(16)
+#define SURFBOARD_BASE_BAUD	(SURFBOARD_SYSTEM_CLOCK / SURFBOARD_BAUD_DIV)
+
+/*
+ * Maximum number of IDE Controllers
+ * Surfboard only has one ide (ide0), so only 2 drives are
+ * possible.  (no need to check for more hwifs.)
+ */
+//#define MAX_IDE_HWIFS		(1)	/* Surfboard/Wakeboard */
+#define MAX_IDE_HWIFS		(2)	/* Graphite board */
+
+#define GCMP_BASE_ADDR                  0x1fbf8000
+#define GCMP_ADDRSPACE_SZ               (256 * 1024)
+
+/*
+ *  * GIC Specific definitions
+ *   */
+#define GIC_BASE_ADDR                   0x1fbc0000
+#define GIC_ADDRSPACE_SZ                (128 * 1024)
+#define MIPS_GIC_IRQ_BASE		(MIPS_CPU_IRQ_BASE)
+
+/* GIC's Nomenclature for Core Interrupt Pins */
+#define GIC_CPU_INT0            0 /* Core Interrupt 2   */
+#define GIC_CPU_INT1            1 /* .                  */
+#define GIC_CPU_INT2            2 /* .                  */
+#define GIC_CPU_INT3            3 /* .                  */
+#define GIC_CPU_INT4            4 /* .                  */
+#define GIC_CPU_INT5            5 /* Core Interrupt 5   */
+
+#endif /* !(_SURFBOARD_H) */
diff --git a/arch/mips/include/asm/rt2880/surfboardint.h b/arch/mips/include/asm/rt2880/surfboardint.h
new file mode 100644
index 0000000..671cca5
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/surfboardint.h
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2001 Palmchip Corporation.  All rights reserved.
+ *
+ * ########################################################################
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ * ########################################################################
+ *
+ * Defines for the Surfboard interrupt controller.
+ *
+ */
+#ifndef _SURFBOARDINT_H
+#define _SURFBOARDINT_H
+
+/* Number of IRQ supported on hw interrupt 0. */
+#if defined (CONFIG_RALINK_RT2880)
+#define RALINK_CPU_TIMER_IRQ 	 6	/* mips timer */
+#define SURFBOARDINT_GPIO	 7	/* GPIO */
+#define SURFBOARDINT_UART1	 8	/* UART Lite */
+#define SURFBOARDINT_UART	 9	/* UART */
+#define SURFBOARDINT_TIMER0	 10	/* timer0 */
+#elif defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT2883) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined (CONFIG_RALINK_MT7620) 
+#define RALINK_CPU_TIMER_IRQ 	 5	/* mips timer */
+#define SURFBOARDINT_GPIO	 6	/* GPIO */
+#define SURFBOARDINT_DMA	 7	/* DMA */
+#define SURFBOARDINT_NAND	 8	/* NAND */
+#define SURFBOARDINT_PC	 	 9	/* Performance counter */
+#define SURFBOARDINT_I2S 	 10	/* I2S */
+#define SURFBOARDINT_SDXC        14     /* SDXC */
+#define SURFBOARDINT_ESW	 17	/* ESW */
+#define SURFBOARDINT_UART1	 12 	/* UART Lite */
+#define SURFBOARDINT_CRYPTO      13     /* CryptoEngine */
+#define SURFBOARDINT_SYSCTL 	 32	/* SYSCTL */
+#define SURFBOARDINT_TIMER0	 33	/* timer0 */
+#define SURFBOARDINT_WDG	 34	/* watch dog */
+#define SURFBOARDINT_ILL_ACC	 35	/* illegal access */
+#define SURFBOARDINT_PCM	 36	/* PCM */
+#define SURFBOARDINT_UART	 37	/* UART */
+#define RALINK_INT_PCIE0         13	/* PCIE0 */
+#define RALINK_INT_PCIE1	 14	/* PCIE1 */
+
+
+#elif defined (CONFIG_RALINK_MT7628)
+#define SURFBOARDINT_SYSCTL      0      /* SYSCTL */
+#define SURFBOARDINT_PCM         4      /* PCM */
+#define SURFBOARDINT_GPIO        6      /* GPIO */
+#define SURFBOARDINT_DMA         7      /* DMA */
+#define SURFBOARDINT_PC          9      /* Performance counter */
+#define SURFBOARDINT_I2S         10     /* I2S */
+#define SURFBOARDINT_SPI         11     /* SPI */
+#define SURFBOARDINT_AES         13     /* AES */
+#define SURFBOARDINT_CRYPTO      13     /* CryptoEngine */
+#define SURFBOARDINT_SDXC        14     /* SDXC */
+#define SURFBOARDINT_ESW         17     /* ESW */
+#define SURFBOARDINT_USB         18     /* USB */
+#define SURFBOARDINT_UART_LITE1  20     /* UART Lite */
+#define SURFBOARDINT_UART_LITE2  21     /* UART Lite */
+#define SURFBOARDINT_UART_LITE3  22     /* UART Lite */
+#define SURFBOARDINT_UART1       SURFBOARDINT_UART_LITE1
+#define SURFBOARDINT_UART        SURFBOARDINT_UART_LITE2
+#define SURFBOARDINT_WDG         23     /* WDG timer */
+#define SURFBOARDINT_TIMER0      24     /* Timer0 */
+#define SURFBOARDINT_TIMER1      25     /* Timer1 */
+#define SURFBOARDINT_ILL_ACC     35     /* illegal access */
+#define RALINK_INT_PCIE0         2     /* PCIE0 */
+
+
+#elif defined (CONFIG_RALINK_MT7621)
+
+#define SURFBOARDINT_FE	 	 3	/* FE */
+#define SURFBOARDINT_PCIE0 	 4	/* PCIE0 */
+#define SURFBOARDINT_SYSCTL	 6	/* SYSCTL */
+#define SURFBOARDINT_I2C         8      /* I2C */
+#define SURFBOARDINT_DRAMC	 9	/* DRAMC */
+#define SURFBOARDINT_PCM	 10	/* PCM */
+#define SURFBOARDINT_HSGDMA	 11	/* HSGDMA */
+#define SURFBOARDINT_GPIO	 12	/* GPIO */
+#define SURFBOARDINT_DMA	 13	/* GDMA */
+#define SURFBOARDINT_NAND	 14	/* NAND */
+#define SURFBOARDINT_NAND_ECC    15     /* NFI ECC */
+#define SURFBOARDINT_I2S 	 16	/* I2S */
+#define SURFBOARDINT_SPI 	 17	/* SPI */
+#define SURFBOARDINT_SPDIF 	 18	/* SPDIF */
+#define SURFBOARDINT_CRYPTO      19     /* CryptoEngine */
+#define SURFBOARDINT_SDXC        20     /* SDXC */
+#define SURFBOARDINT_PCTRL       21     /* Performance counter */
+#define SURFBOARDINT_USB	 22	/* USB */
+#define SURFBOARDINT_ESW         31     /* Switch */
+#define SURFBOARDINT_PCIE1 	 24	/* PCIE1 */
+#define SURFBOARDINT_PCIE2 	 25	/* PCIE2 */
+#define SURFBOARDINT_UART_LITE1  26     /* UART Lite */
+#define SURFBOARDINT_UART_LITE2  27     /* UART Lite */
+#define SURFBOARDINT_UART_LITE3  28     /* UART Lite */
+#define SURFBOARDINT_UART        SURFBOARDINT_UART_LITE2 //ttyS0
+#define SURFBOARDINT_UART1       SURFBOARDINT_UART_LITE1 //ttyS1
+
+#define SURFBOARDINT_WDG	 29	/* WDG timer */
+#define SURFBOARDINT_TIMER0	 30	/* Timer0 */
+#define SURFBOARDINT_TIMER1      31     /* Timer1 */
+
+#define RALINK_INT_PCIE0	 SURFBOARDINT_PCIE0
+#define RALINK_INT_PCIE1	 SURFBOARDINT_PCIE1
+#define RALINK_INT_PCIE2	 SURFBOARDINT_PCIE2
+
+#elif defined (CONFIG_RALINK_RT3883)
+#define RALINK_CPU_TIMER_IRQ     5      /* mips timer */
+#define SURFBOARDINT_GPIO        6      /* GPIO */
+#define SURFBOARDINT_DMA         7      /* DMA */
+#define SURFBOARDINT_NAND        8      /* NAND */
+#define SURFBOARDINT_PC          9      /* Performance counter */
+#define SURFBOARDINT_I2S         10     /* I2S */
+#define SURFBOARDINT_UART1       12     /* UART Lite */
+#define SURFBOARDINT_PCI         18     /* PCI */
+#define SURFBOARDINT_UDEV        19     /* USB Device */
+#define SURFBOARDINT_UHST        20     /* USB Host */
+#define SURFBOARDINT_SYSCTL      32     /* SYSCTL */
+#define SURFBOARDINT_TIMER0      33     /* timer0 */
+#define SURFBOARDINT_ILL_ACC     35     /* illegal access */
+#define SURFBOARDINT_PCM         36     /* PCM */
+#define SURFBOARDINT_UART        37     /* UART */
+#endif
+
+#define SURFBOARDINT_END 	 64
+#define RT2880_INTERINT_START 	 40
+
+/* Global interrupt bit definitions */
+#define C_SURFBOARD_GLOBAL_INT	31
+#define M_SURFBOARD_GLOBAL_INT	(1 << C_SURFBOARD_GLOBAL_INT)
+
+/* added ??? */
+#define RALINK_SDRAM_ILL_ACC_ADDR  *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x310)
+#define RALINK_SDRAM_ILL_ACC_TYPE  *(volatile u32 *)(RALINK_SYSCTL_BASE + 0x314)
+/* end of added, bobtseng */
+
+/*
+ * Surfboard registers are memory mapped on 32-bit aligned boundaries and
+ * only word access are allowed.
+ */
+#if defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
+#define RALINK_IRQ0STAT		(RALINK_INTCL_BASE + 0x9C) //IRQ_STAT
+#define RALINK_IRQ1STAT		(RALINK_INTCL_BASE + 0xA0) //FIQ_STAT
+#define RALINK_INTTYPE		(RALINK_INTCL_BASE + 0x6C) //FIQ_SEL
+#define RALINK_INTRAW		(RALINK_INTCL_BASE + 0xA4) //INT_PURE
+#define RALINK_INTENA		(RALINK_INTCL_BASE + 0x80) //IRQ_MASK_SET
+#define RALINK_INTDIS		(RALINK_INTCL_BASE + 0x78) //IRQ_MASK_CLR
+#else
+#define RALINK_IRQ0STAT		(RALINK_INTCL_BASE + 0x0)
+#define RALINK_IRQ1STAT		(RALINK_INTCL_BASE + 0x4)
+#define RALINK_INTTYPE		(RALINK_INTCL_BASE + 0x20)
+#define RALINK_INTRAW		(RALINK_INTCL_BASE + 0x30)
+#define RALINK_INTENA		(RALINK_INTCL_BASE + 0x34)
+#define RALINK_INTDIS		(RALINK_INTCL_BASE + 0x38)
+#endif
+
+/* bobtseng added ++, 2006.3.6. */
+#define read_32bit_cp0_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+        ".set\tpush\n\t"                                        \
+        ".set\treorder\n\t"                                     \
+        "mfc0\t%0,"STR(source)"\n\t"                            \
+        ".set\tpop"                                             \
+        : "=r" (__res));                                        \
+        __res;})
+        
+#define write_32bit_cp0_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc0\t%0,"STR(register)"\n\t"                          \
+        "nop"                                                   \
+        : : "r" (value));
+        
+/* bobtseng added --, 2006.3.6. */
+
+void surfboardint_init(void);
+u32 get_surfboard_sysclk(void);
+
+
+#endif /* !(_SURFBOARDINT_H) */
diff --git a/arch/mips/include/asm/rt2880/war.h b/arch/mips/include/asm/rt2880/war.h
new file mode 100644
index 0000000..7c6931d
--- /dev/null
+++ b/arch/mips/include/asm/rt2880/war.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_MIPS_WAR_H
+#define __ASM_MIPS_MACH_MIPS_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	1
+#define MIPS_CACHE_SYNC_WAR		1
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	1
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_MIPS_WAR_H */
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index ef6a274..1b9b3b2 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -135,6 +135,7 @@ source "drivers/net/ethernet/packetengines/Kconfig"
 source "drivers/net/ethernet/pasemi/Kconfig"
 source "drivers/net/ethernet/qlogic/Kconfig"
 source "drivers/net/ethernet/ralink/Kconfig"
+source "drivers/net/ethernet/raeth/Kconfig"
 source "drivers/net/ethernet/realtek/Kconfig"
 source "drivers/net/ethernet/renesas/Kconfig"
 source "drivers/net/ethernet/rdc/Kconfig"
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index 7c3eb7b..e66b3bb 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -57,6 +57,7 @@ obj-$(CONFIG_NET_PACKET_ENGINE) += packetengines/
 obj-$(CONFIG_NET_VENDOR_PASEMI) += pasemi/
 obj-$(CONFIG_NET_VENDOR_QLOGIC) += qlogic/
 obj-$(CONFIG_NET_RALINK) += ralink/
+obj-$(CONFIG_RAETH) += raeth/
 obj-$(CONFIG_NET_VENDOR_REALTEK) += realtek/
 obj-$(CONFIG_SH_ETH) += renesas/
 obj-$(CONFIG_NET_VENDOR_RDC) += rdc/
diff --git a/drivers/net/ethernet/raeth/Kconfig b/drivers/net/ethernet/raeth/Kconfig
new file mode 100644
index 0000000..e24b52c
--- /dev/null
+++ b/drivers/net/ethernet/raeth/Kconfig
@@ -0,0 +1,344 @@
+
+config RA_NAT_NONE
+	bool
+	default y
+	depends on RALINK
+
+config MT7621_ASIC
+	bool
+	default y
+	depends on SOC_MT7621
+
+config RALINK_MT7621
+	bool
+	default y
+	depends on SOC_MT7621
+
+config RAETH
+        tristate "Ralink GMAC"
+	depends on SOC_MT7621
+        ---help---
+          This driver supports Ralink gigabit ethernet family of
+          adapters.
+
+config PDMA_NEW
+        bool
+	default y if  (RALINK_MT7620 || RALINK_MT7621)
+        depends on RAETH
+
+config RAETH_SCATTER_GATHER_RX_DMA
+        bool
+	default y if (RALINK_MT7620 || RALINK_MT7621)
+        depends on RAETH
+
+
+choice
+	prompt "Network BottomHalves"	
+        depends on RAETH
+	default RA_NETWORK_WORKQUEUE_BH
+
+	config RA_NETWORK_TASKLET_BH
+	bool "Tasklet"
+
+	config RA_NETWORK_WORKQUEUE_BH
+	bool "Work Queue"
+
+	config RAETH_NAPI
+        bool "NAPI"
+
+endchoice
+
+#config TASKLET_WORKQUEUE_SW
+#        bool "Tasklet and Workqueue switch"
+#        depends on RA_NETWORK_TASKLET_BH
+
+config RAETH_SKB_RECYCLE_2K
+        bool "SKB Recycling"
+        depends on RAETH
+
+config RAETH_SPECIAL_TAG
+        bool "Ralink Special Tag (0x810x)"
+        depends on RAETH && RT_3052_ESW
+
+#config RAETH_JUMBOFRAME
+#        bool "Jumbo Frame up to 4K bytes"
+#        depends on RAETH && !(RALINK_RT3052 || RALINK_RT3352 || RALINK_RT5350 || RALINK_MT7628)
+
+config RAETH_CHECKSUM_OFFLOAD
+        bool "TCP/UDP/IP checksum offload"
+	default y
+        depends on RAETH && !RALINK_RT2880
+
+#config RAETH_SW_FC
+#        bool "When TX ring is full, inform kernel stop transmit and stop RX handler"
+#	 default n
+#        depends on RAETH
+
+config 32B_DESC
+        bool "32bytes TX/RX description"
+	default n
+        depends on RAETH && (RALINK_MT7620 || RALINK_MT7621)
+        ---help---
+          At this moment, you cannot enable 32B description with Multiple RX ring at the same time.
+
+config RAETH_LRO
+        bool "LRO (Large Receive Offload )"
+	select INET_LRO
+        depends on RAETH && (RALINK_RT6855A || RALINK_MT7620 || RALINK_MT7621)
+
+config RAETH_HW_VLAN_TX
+        bool "Transmit VLAN HW (DoubleVLAN is not supported)"
+        depends on RAETH && !(RALINK_RT5350 || RALINK_MT7628)
+        ---help---
+          Please disable HW_VLAN_TX if you need double vlan
+
+config RAETH_HW_VLAN_RX
+        bool "Receive VLAN HW (DoubleVLAN is not supported)"
+        depends on RAETH && RALINK_MT7621
+        ---help---
+          Please disable HW_VLAN_RX if you need double vlan
+
+config RAETH_TSO
+        bool "TSOV4 (Tcp Segmentaton Offload)"
+	depends on (RAETH_HW_VLAN_TX && (RALINK_RT6855 || RALINK_RT6855A || RALINK_MT7620)) || RALINK_MT7621
+
+config RAETH_TSOV6
+        bool "TSOV6 (Tcp Segmentaton Offload)"
+	depends on RAETH_TSO
+
+config RAETH_RW_PDMAPTR_FROM_VAR
+	bool
+	default y if RALINK_RT6855A || RALINK_MT7620
+        depends on RAETH
+
+#config RAETH_QOS
+#        bool "QoS Feature"
+#        depends on RAETH && !RALINK_RT2880 && !RALINK_MT7620 && !RALINK_MT7621 && !RAETH_TSO
+
+choice
+        prompt "QoS Type"
+        depends on RAETH_QOS
+        default DSCP_QOS_DSCP
+
+config  RAETH_QOS_DSCP_BASED
+        bool "DSCP-based"
+        depends on RAETH_QOS 
+
+config  RAETH_QOS_VPRI_BASED
+        bool "VPRI-based"
+        depends on RAETH_QOS
+
+endchoice
+
+config RAETH_QDMA
+        bool "Choose QDMA instead PDMA"
+	default n
+        depends on RAETH && RALINK_MT7621
+
+choice
+        prompt "GMAC is connected to"
+        depends on RAETH
+        default GE1_RGMII_FORCE_1000
+
+config  GE1_MII_FORCE_100
+        bool "MII_FORCE_100 (10/100M Switch)"
+        depends on (RALINK_RT2880 || RALINK_RT3883 || RALINK_MT7621) 
+
+config  GE1_MII_AN
+        bool "MII_AN (100Phy)"
+        depends on (RALINK_RT2880 || RALINK_RT3883 || RALINK_MT7621) 
+
+config  GE1_RVMII_FORCE_100
+        bool "RvMII_FORCE_100 (CPU)"
+        depends on (RALINK_RT2880 || RALINK_RT3883 || RALINK_MT7621) 
+
+config  GE1_RGMII_FORCE_1000
+        bool "RGMII_FORCE_1000 (GigaSW, CPU)"
+        depends on (RALINK_RT2880 || RALINK_RT3883)
+	select RALINK_SPI
+
+config  GE1_RGMII_FORCE_1000
+        bool "RGMII_FORCE_1000 (GigaSW, CPU)"
+        depends on (RALINK_MT7621)
+	select RT_3052_ESW
+
+config  GE1_TRGMII_FORCE_1200
+        bool "TRGMII_FORCE_1200 (GigaSW, CPU)"
+        depends on (RALINK_MT7621)
+	select RT_3052_ESW
+
+config  GE1_RGMII_AN
+        bool "RGMII_AN (GigaPhy)"
+        depends on (RALINK_RT2880 || RALINK_RT3883 || RALINK_MT7621) 
+
+config  GE1_RGMII_NONE
+        bool "NONE (NO CONNECT)"
+        depends on (RALINK_MT7621)
+
+endchoice
+
+config  RT_3052_ESW
+        bool "Ralink Embedded Switch"
+	default y
+        depends on (RALINK_RT3052 || RALINK_RT3352 || RALINK_RT5350 || RALINK_RT6855 || RALINK_RT6855A || RALINK_MT7620 || RALINK_MT7621 || RALINK_MT7628)
+
+config LAN_WAN_SUPPORT
+        bool "LAN/WAN Partition"
+        depends on RAETH_ROUTER || RT_3052_ESW
+
+choice
+        prompt "Switch Board Layout Type"
+        depends on LAN_WAN_SUPPORT || P5_RGMII_TO_MAC_MODE ||  GE1_RGMII_FORCE_1000 || GE1_TRGMII_FORCE_1200 || GE2_RGMII_FORCE_1000
+	default WAN_AT_P0
+
+	config  WAN_AT_P4
+	        bool "LLLL/W"
+		
+	config  WAN_AT_P0
+	        bool "W/LLLL"
+endchoice
+
+config	RALINK_VISTA_BASIC
+	bool 'Vista Basic Logo for IC+ 175C'
+        depends on LAN_WAN_SUPPORT && (RALINK_RT2880 || RALINK_RT3883)
+
+config	ESW_DOUBLE_VLAN_TAG
+	bool
+	default y if RT_3052_ESW
+
+config RAETH_HAS_PORT4
+        bool "Port 4 Support"
+        depends on RAETH && RALINK_MT7620
+choice
+        prompt "Target Mode"
+        depends on RAETH_HAS_PORT4
+	default P4_RGMII_TO_MAC_MODE
+
+	config P4_MAC_TO_PHY_MODE
+		bool "Giga_Phy (RGMII)"
+	config  GE_RGMII_MT7530_P0_AN
+		bool "GE_RGMII_MT7530_P0_AN (MT7530 Internal GigaPhy)"
+	config  GE_RGMII_MT7530_P4_AN
+		bool "GE_RGMII_MT7530_P4_AN (MT7530 Internal GigaPhy)"
+	config P4_RGMII_TO_MAC_MODE
+		bool "Giga_SW/iNIC (RGMII)"
+	config P4_MII_TO_MAC_MODE
+		bool "External_CPU (MII_RvMII)"
+	config P4_RMII_TO_MAC_MODE
+		bool "External_CPU (RvMII_MII)"
+endchoice
+
+config  MAC_TO_GIGAPHY_MODE_ADDR2
+        hex "Port4 Phy Address"
+	default 0x4
+        depends on P4_MAC_TO_PHY_MODE
+
+config RAETH_HAS_PORT5
+        bool "Port 5 Support"
+        depends on RAETH && (RALINK_RT3052 || RALINK_RT3352 || RALINK_RT6855 || RALINK_RT6855A || RALINK_MT7620)
+choice
+        prompt "Target Mode"
+        depends on RAETH_HAS_PORT5
+	default P5_RGMII_TO_MAC_MODE
+
+	config P5_MAC_TO_PHY_MODE
+		bool "Giga_Phy (RGMII)"
+	config P5_RGMII_TO_MAC_MODE
+		bool "Giga_SW/iNIC (RGMII)"
+	config P5_RGMII_TO_MT7530_MODE
+		bool "MT7530 Giga_SW (RGMII)"
+		depends on RALINK_MT7620
+	config P5_MII_TO_MAC_MODE
+		bool "External_CPU (MII_RvMII)"
+	config P5_RMII_TO_MAC_MODE
+		bool "External_CPU (RvMII_MII)"
+endchoice
+
+config  MAC_TO_GIGAPHY_MODE_ADDR
+        hex "GE1 Phy Address"
+	default 0x1F
+        depends on GE1_MII_AN || GE1_RGMII_AN
+
+config  MAC_TO_GIGAPHY_MODE_ADDR
+        hex "Port5 Phy Address"
+	default 0x5
+        depends on P5_MAC_TO_PHY_MODE
+
+config RAETH_GMAC2
+        bool "GMAC2 Support"
+        depends on RAETH && (RALINK_RT3883 || RALINK_MT7621)
+
+choice
+        prompt "GMAC2 is connected to"
+        depends on RAETH_GMAC2
+        default GE2_RGMII_AN
+
+config  GE2_MII_FORCE_100
+        bool "MII_FORCE_100 (10/100M Switch)"
+        depends on RAETH_GMAC2
+
+config  GE2_MII_AN
+        bool "MII_AN (100Phy)"
+        depends on RAETH_GMAC2
+
+config  GE2_RVMII_FORCE_100
+        bool "RvMII_FORCE_100 (CPU)"
+        depends on RAETH_GMAC2
+
+config  GE2_RGMII_FORCE_1000
+        bool "RGMII_FORCE_1000 (GigaSW, CPU)"
+        depends on RAETH_GMAC2
+	select RALINK_SPI
+
+config  GE2_RGMII_AN
+        bool "RGMII_AN (GigaPhy)"
+        depends on RAETH_GMAC2
+
+config  GE2_INTERNAL_GPHY
+        bool "Internal GigaPHY"
+        depends on RAETH_GMAC2
+	select LAN_WAN_SUPPORT
+
+endchoice
+
+config  GE_RGMII_INTERNAL_P0_AN
+	bool
+        depends on GE2_INTERNAL_GPHY
+	default y if WAN_AT_P0
+
+config  GE_RGMII_INTERNAL_P4_AN
+	bool
+        depends on GE2_INTERNAL_GPHY
+	default y if WAN_AT_P4
+
+config  MAC_TO_GIGAPHY_MODE_ADDR2
+        hex
+	default 0 if GE_RGMII_INTERNAL_P0_AN
+	default 4 if GE_RGMII_INTERNAL_P4_AN
+        depends on GE_RGMII_INTERNAL_P0_AN || GE_RGMII_INTERNAL_P4_AN
+
+config  MAC_TO_GIGAPHY_MODE_ADDR2
+        hex "GE2 Phy Address"
+	default 0x1E
+        depends on GE2_MII_AN || GE2_RGMII_AN
+
+#force 100M
+config RAETH_ROUTER
+bool
+default y if GE1_MII_FORCE_100 || GE2_MII_FORCE_100 || GE1_RVMII_FORCE_100 || GE2_RVMII_FORCE_100
+
+#force 1000M
+config MAC_TO_MAC_MODE
+bool
+default y if GE1_RGMII_FORCE_1000 || GE2_RGMII_FORCE_1000
+depends on (RALINK_RT2880 || RALINK_RT3883) 
+
+#AN
+config GIGAPHY
+bool
+default y if GE1_RGMII_AN || GE2_RGMII_AN
+
+#AN
+config 100PHY
+bool
+default y if GE1_MII_AN || GE2_MII_AN
diff --git a/drivers/net/ethernet/raeth/Makefile b/drivers/net/ethernet/raeth/Makefile
new file mode 100644
index 0000000..94c19bd
--- /dev/null
+++ b/drivers/net/ethernet/raeth/Makefile
@@ -0,0 +1,7 @@
+obj-$(CONFIG_RAETH) += raeth.o
+raeth-objs := ra_mac.o mii_mgr.o
+raeth-objs += raether_pdma.o
+EXTRA_CFLAGS   += -DWORKQUEUE_BH
+#EXTRA_CFLAGS   += -DCONFIG_RAETH_MULTIPLE_RX_RING
+
+raeth-objs += raether.o
diff --git a/drivers/net/ethernet/raeth/ethtool_readme.txt b/drivers/net/ethernet/raeth/ethtool_readme.txt
new file mode 100644
index 0000000..10e918b
--- /dev/null
+++ b/drivers/net/ethernet/raeth/ethtool_readme.txt
@@ -0,0 +1,44 @@
+
+Ethtool readme for selecting different PHY address.
+
+Before doing any ethtool command you should make sure the current PHY
+address is expected. The default PHY address is 1(port 1).
+
+You can change current PHY address to X(0~4) by doing follow command:
+# echo X > /proc/rt2880/gmac
+
+Ethtool command also would show the current PHY address as following.
+
+# ethtool  eth2
+Settings for eth2:
+        Supported ports: [ TP MII ]
+        Supported link modes:   10baseT/Half 10baseT/Full
+                                100baseT/Half 100baseT/Full
+        Supports auto-negotiation: Yes
+        Advertised link modes:  10baseT/Half 10baseT/Full
+                                100baseT/Half 100baseT/Full
+        Advertised auto-negotiation: No
+        Speed: 10Mb/s
+        Duplex: Full
+        Port: MII
+        PHYAD: 1
+        Transceiver: internal
+        Auto-negotiation: off
+        Current message level: 0x00000000 (0)
+        Link detected: no
+
+
+The "PHYAD" field shows the current PHY address.
+
+
+
+Usage example
+1) show port1 info
+# echo 1 > /proc/rt2880/gmac		# change phy address to 1
+# ethtool eth2
+
+2) show port0 info
+# echo 0 > /proc/rt2880/gmac		# change phy address to 0
+# ethtool eth2
+
+
diff --git a/drivers/net/ethernet/raeth/mii_mgr.c b/drivers/net/ethernet/raeth/mii_mgr.c
new file mode 100644
index 0000000..3de0a74
--- /dev/null
+++ b/drivers/net/ethernet/raeth/mii_mgr.c
@@ -0,0 +1,166 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+#include <asm/rt2880/rt_mmap.h>
+#endif
+
+#include "ra2882ethreg.h"
+#include "raether.h"
+
+
+#define PHY_CONTROL_0 		0x0004   
+#define MDIO_PHY_CONTROL_0	(RALINK_ETH_SW_BASE + PHY_CONTROL_0)
+#define enable_mdio(x)
+
+
+u32 __mii_mgr_read(u32 phy_addr, u32 phy_register, u32 *read_data)
+{
+	u32 volatile status = 0;
+	u32 rc = 0;
+	unsigned long volatile t_start = jiffies;
+	u32 volatile data = 0;
+
+	/* We enable mdio gpio purpose register, and disable it when exit. */
+	enable_mdio(1);
+
+	// make sure previous read operation is complete
+	while (1) {
+			// 0 : Read/write operation complete
+		if(!( sysRegRead(MDIO_PHY_CONTROL_0) & (0x1 << 31))) 
+		{
+			break;
+		}
+		else if (time_after(jiffies, t_start + 5*HZ)) {
+			enable_mdio(0);
+			printk("\n MDIO Read operation is ongoing !!\n");
+			return rc;
+		}
+	}
+
+	data  = (0x01 << 16) | (0x02 << 18) | (phy_addr << 20) | (phy_register << 25);
+	sysRegWrite(MDIO_PHY_CONTROL_0, data);
+	data |= (1<<31);
+	sysRegWrite(MDIO_PHY_CONTROL_0, data);
+	//printk("\n Set Command [0x%08X] to PHY !!\n",MDIO_PHY_CONTROL_0);
+
+
+	// make sure read operation is complete
+	t_start = jiffies;
+	while (1) {
+		if (!(sysRegRead(MDIO_PHY_CONTROL_0) & (0x1 << 31))) {
+			status = sysRegRead(MDIO_PHY_CONTROL_0);
+			*read_data = (u32)(status & 0x0000FFFF);
+
+			enable_mdio(0);
+			return 1;
+		}
+		else if (time_after(jiffies, t_start+5*HZ)) {
+			enable_mdio(0);
+			printk("\n MDIO Read operation is ongoing and Time Out!!\n");
+			return 0;
+		}
+	}
+}
+
+u32 __mii_mgr_write(u32 phy_addr, u32 phy_register, u32 write_data)
+{
+	unsigned long volatile t_start=jiffies;
+	u32 volatile data;
+
+	enable_mdio(1);
+
+	// make sure previous write operation is complete
+	while(1) {
+		if (!(sysRegRead(MDIO_PHY_CONTROL_0) & (0x1 << 31))) 
+		{
+			break;
+		}
+		else if (time_after(jiffies, t_start + 5 * HZ)) {
+			enable_mdio(0);
+			printk("\n MDIO Write operation ongoing\n");
+			return 0;
+		}
+	}
+	/*add 1 us delay to make sequencial write more robus*/
+        udelay(1);
+
+	data = (0x01 << 16)| (1<<18) | (phy_addr << 20) | (phy_register << 25) | write_data;
+	sysRegWrite(MDIO_PHY_CONTROL_0, data);
+	data |= (1<<31);
+	sysRegWrite(MDIO_PHY_CONTROL_0, data); //start operation
+	//printk("\n Set Command [0x%08X] to PHY !!\n",MDIO_PHY_CONTROL_0);
+
+	t_start = jiffies;
+
+	// make sure write operation is complete
+	while (1) {
+		if (!(sysRegRead(MDIO_PHY_CONTROL_0) & (0x1 << 31))) //0 : Read/write operation complete
+		{
+			enable_mdio(0);
+			return 1;
+		}
+		else if (time_after(jiffies, t_start + 5 * HZ)) {
+			enable_mdio(0);
+			printk("\n MDIO Write operation Time Out\n");
+			return 0;
+		}
+	}
+}
+
+u32 mii_mgr_read(u32 phy_addr, u32 phy_register, u32 *read_data)
+{
+        u32 low_word;
+        u32 high_word;
+        if(phy_addr==31) 
+	{
+                //phase1: write page address phase
+                if(__mii_mgr_write(phy_addr, 0x1f, ((phy_register >> 6) & 0x3FF))) {
+                        //phase2: write address & read low word phase
+                        if(__mii_mgr_read(phy_addr, (phy_register >> 2) & 0xF, &low_word)) {
+                                //phase3: write address & read high word phase
+                                if(__mii_mgr_read(phy_addr, (0x1 << 4), &high_word)) {
+                                        *read_data = (high_word << 16) | (low_word & 0xFFFF);
+					return 1;
+                                }
+                        }
+                }
+        } else 
+	{
+                if(__mii_mgr_read(phy_addr, phy_register, read_data)) {
+                        return 1;
+                }
+        }
+
+        return 0;
+}
+
+u32 mii_mgr_write(u32 phy_addr, u32 phy_register, u32 write_data)
+{
+        if(phy_addr == 31) 
+	{
+                //phase1: write page address phase
+                if(__mii_mgr_write(phy_addr, 0x1f, (phy_register >> 6) & 0x3FF)) {
+                        //phase2: write address & read low word phase
+                        if(__mii_mgr_write(phy_addr, ((phy_register >> 2) & 0xF), write_data & 0xFFFF)) {
+                                //phase3: write address & read high word phase
+                                if(__mii_mgr_write(phy_addr, (0x1 << 4), write_data >> 16)) {
+                                        return 1;
+                                }
+                        }
+                }
+        } else 
+	{
+                if(__mii_mgr_write(phy_addr, phy_register, write_data)) {
+                        return 1;
+                }
+        }
+
+        return 0;
+}
+
+EXPORT_SYMBOL(mii_mgr_write);
+EXPORT_SYMBOL(mii_mgr_read);
diff --git a/drivers/net/ethernet/raeth/ra2882ethreg.h b/drivers/net/ethernet/raeth/ra2882ethreg.h
new file mode 100644
index 0000000..05b789e
--- /dev/null
+++ b/drivers/net/ethernet/raeth/ra2882ethreg.h
@@ -0,0 +1,1268 @@
+#ifndef RA2882ETHREG_H
+#define RA2882ETHREG_H
+
+#include <linux/mii.h>		// for struct mii_if_info in ra2882ethreg.h
+#include <linux/version.h>	/* check linux version for 2.4 and 2.6 compatibility */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <asm/rt2880/rt_mmap.h>
+#endif
+#include "raether.h"
+
+#ifdef WORKQUEUE_BH
+#include <linux/workqueue.h>
+#endif // WORKQUEUE_BH //
+#ifdef CONFIG_RAETH_LRO
+#include <linux/inet_lro.h>
+#endif
+
+#define MAX_PACKET_SIZE	1514
+#define	MIN_PACKET_SIZE 60
+
+#define phys_to_bus(a) (a & 0x1FFFFFFF)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#define BIT(x)	((1 << x))
+#endif
+#define ETHER_ADDR_LEN  6
+
+/*  Phy Vender ID list */
+
+#define EV_ICPLUS_PHY_ID0 0x0243  
+#define EV_ICPLUS_PHY_ID1 0x0D90  
+#define EV_MARVELL_PHY_ID0 0x0141  
+#define EV_MARVELL_PHY_ID1 0x0CC2  
+#define EV_VTSS_PHY_ID0 0x0007
+#define EV_VTSS_PHY_ID1 0x0421
+
+/*
+     FE_INT_STATUS
+*/
+#if defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+    defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
+
+#define RX_COHERENT      BIT(31)
+#define RX_DLY_INT       BIT(30)
+#define TX_COHERENT      BIT(29)
+#define TX_DLY_INT       BIT(28)
+
+#define RX_DONE_INT1     BIT(17)
+#define RX_DONE_INT0     BIT(16)
+
+#define TX_DONE_INT3     BIT(3)
+#define TX_DONE_INT2     BIT(2)
+#define TX_DONE_INT1     BIT(1)
+#define TX_DONE_INT0     BIT(0)
+
+#if defined (CONFIG_RALINK_MT7621)
+#define RLS_COHERENT     BIT(29)
+#define RLS_DLY_INT      BIT(28)
+#define RLS_DONE_INT     BIT(0)
+#endif
+
+#else
+//#define CNT_PPE_AF       BIT(31)     
+//#define CNT_GDM_AF       BIT(29)
+#define PSE_P2_FC	 BIT(26)
+#define GDM_CRC_DROP     BIT(25)
+#define PSE_BUF_DROP     BIT(24)
+#define GDM_OTHER_DROP	 BIT(23)
+#define PSE_P1_FC        BIT(22)
+#define PSE_P0_FC        BIT(21)
+#define PSE_FQ_EMPTY     BIT(20)
+#define GE1_STA_CHG      BIT(18)
+#define TX_COHERENT      BIT(17)
+#define RX_COHERENT      BIT(16)
+
+#define TX_DONE_INT3     BIT(11)
+#define TX_DONE_INT2     BIT(10)
+#define TX_DONE_INT1     BIT(9)
+#define TX_DONE_INT0     BIT(8)
+#define RX_DONE_INT1     RX_DONE_INT0
+#define RX_DONE_INT0     BIT(2)
+#define TX_DLY_INT       BIT(1)
+#define RX_DLY_INT       BIT(0)
+#endif
+
+#define FE_INT_ALL		(TX_DONE_INT3 | TX_DONE_INT2 | \
+			         TX_DONE_INT1 | TX_DONE_INT0 | \
+	                         RX_DONE_INT0 )
+
+#if defined (CONFIG_RALINK_MT7621)
+#define QFE_INT_ALL		(RLS_DONE_INT | RX_DONE_INT0 | RX_DONE_INT1)
+#define QFE_INT_DLY_INIT	(RLS_DLY_INT | RX_DLY_INT)
+
+#define NUM_QDMA_PAGE		256
+#define QDMA_PAGE_SIZE      2048
+#endif
+/*
+ * SW_INT_STATUS
+ */
+#if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_MT7628)
+#define PORT0_QUEUE_FULL        BIT(14) //port0 queue full
+#define PORT1_QUEUE_FULL        BIT(15) //port1 queue full
+#define PORT2_QUEUE_FULL        BIT(16) //port2 queue full
+#define PORT3_QUEUE_FULL        BIT(17) //port3 queue full
+#define PORT4_QUEUE_FULL        BIT(18) //port4 queue full
+#define PORT5_QUEUE_FULL        BIT(19) //port5 queue full
+#define PORT6_QUEUE_FULL        BIT(20) //port6 queue full
+#define SHARED_QUEUE_FULL       BIT(23) //shared queue full
+#define QUEUE_EXHAUSTED         BIT(24) //global queue is used up and all packets are dropped
+#define BC_STROM                BIT(25) //the device is undergoing broadcast storm
+#define PORT_ST_CHG             BIT(26) //Port status change
+#define UNSECURED_ALERT         BIT(27) //Intruder alert
+#define ABNORMAL_ALERT          BIT(28) //Abnormal
+
+#define ESW_ISR			(RALINK_ETH_SW_BASE + 0x00)
+#define ESW_IMR			(RALINK_ETH_SW_BASE + 0x04)
+#define ESW_INT_ALL		(PORT_ST_CHG)
+
+#elif defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+      defined (CONFIG_RALINK_MT7620)
+#define MIB_INT                 BIT(25)
+#define ACL_INT			BIT(24)
+#define P5_LINK_CH		BIT(5)
+#define P4_LINK_CH		BIT(4)
+#define P3_LINK_CH		BIT(3)
+#define P2_LINK_CH		BIT(2)
+#define P1_LINK_CH		BIT(1)
+#define P0_LINK_CH		BIT(0)
+
+#define RX_GOCT_CNT		BIT(4)
+#define RX_GOOD_CNT		BIT(6)
+#define TX_GOCT_CNT		BIT(17)
+#define TX_GOOD_CNT		BIT(19)
+
+#define MSK_RX_GOCT_CNT		BIT(4)
+#define MSK_RX_GOOD_CNT		BIT(6)
+#define MSK_TX_GOCT_CNT		BIT(17)
+#define MSK_TX_GOOD_CNT		BIT(19)
+#define MSK_CNT_INT_ALL		(MSK_RX_GOCT_CNT | MSK_RX_GOOD_CNT | MSK_TX_GOCT_CNT | MSK_TX_GOOD_CNT) 
+//#define MSK_CNT_INT_ALL		(MSK_RX_GOOD_CNT | MSK_TX_GOOD_CNT) 
+
+
+#define ESW_IMR			(RALINK_ETH_SW_BASE + 0x7000 + 0x8)
+#define ESW_ISR			(RALINK_ETH_SW_BASE + 0x7000 + 0xC)
+#define ESW_INT_ALL		(P0_LINK_CH | P1_LINK_CH | P2_LINK_CH | P3_LINK_CH | P4_LINK_CH | P5_LINK_CH | ACL_INT | MIB_INT)
+#define ESW_AISR		(RALINK_ETH_SW_BASE + 0x8)
+#define ESW_P0_IntSn		(RALINK_ETH_SW_BASE + 0x4004)
+#define ESW_P1_IntSn		(RALINK_ETH_SW_BASE + 0x4104)
+#define ESW_P2_IntSn		(RALINK_ETH_SW_BASE + 0x4204)
+#define ESW_P3_IntSn		(RALINK_ETH_SW_BASE + 0x4304)
+#define ESW_P4_IntSn		(RALINK_ETH_SW_BASE + 0x4404)
+#define ESW_P5_IntSn		(RALINK_ETH_SW_BASE + 0x4504)
+#define ESW_P6_IntSn		(RALINK_ETH_SW_BASE + 0x4604)
+#define ESW_P0_IntMn		(RALINK_ETH_SW_BASE + 0x4008)
+#define ESW_P1_IntMn		(RALINK_ETH_SW_BASE + 0x4108)
+#define ESW_P2_IntMn		(RALINK_ETH_SW_BASE + 0x4208)
+#define ESW_P3_IntMn		(RALINK_ETH_SW_BASE + 0x4308)
+#define ESW_P4_IntMn		(RALINK_ETH_SW_BASE + 0x4408)
+#define ESW_P5_IntMn		(RALINK_ETH_SW_BASE + 0x4508)
+#define ESW_P6_IntMn		(RALINK_ETH_SW_BASE + 0x4608)
+
+#if defined (CONFIG_RALINK_MT7620) 
+#define ESW_P7_IntSn		(RALINK_ETH_SW_BASE + 0x4704)
+#define ESW_P7_IntMn		(RALINK_ETH_SW_BASE + 0x4708)
+#endif
+
+
+#define ESW_PHY_POLLING		(RALINK_ETH_SW_BASE + 0x7000)
+
+#elif defined (CONFIG_RALINK_MT7621)
+
+#define ESW_PHY_POLLING		(RALINK_ETH_SW_BASE + 0x0000)
+
+#define P5_LINK_CH		BIT(5)
+#define P4_LINK_CH		BIT(4)
+#define P3_LINK_CH		BIT(3)
+#define P2_LINK_CH		BIT(2)
+#define P1_LINK_CH		BIT(1)
+#define P0_LINK_CH		BIT(0)
+
+
+#endif // CONFIG_RALINK_RT3052 || CONFIG_RALINK_RT3352 || CONFIG_RALINK_RT5350 || defined (CONFIG_RALINK_MT7628)//
+
+#define RX_BUF_ALLOC_SIZE	2000
+#define FASTPATH_HEADROOM   	64
+
+#define ETHER_BUFFER_ALIGN	32		///// Align on a cache line
+
+#define ETHER_ALIGNED_RX_SKB_ADDR(addr) \
+        ((((unsigned long)(addr) + ETHER_BUFFER_ALIGN - 1) & \
+        ~(ETHER_BUFFER_ALIGN - 1)) - (unsigned long)(addr))
+
+#ifdef CONFIG_PSEUDO_SUPPORT
+typedef struct _PSEUDO_ADAPTER {
+    struct net_device *RaethDev;
+    struct net_device *PseudoDev;
+    struct net_device_stats stat;
+#if defined (CONFIG_ETHTOOL) /*&& defined (CONFIG_RAETH_ROUTER)*/
+	struct mii_if_info	mii_info;
+#endif
+
+} PSEUDO_ADAPTER, PPSEUDO_ADAPTER;
+
+#define MAX_PSEUDO_ENTRY               1
+#endif
+
+
+
+/* Register Categories Definition */
+#define RAFRAMEENGINE_OFFSET	0x0000
+#define RAGDMA_OFFSET		0x0020
+#define RAPSE_OFFSET		0x0040
+#define RAGDMA2_OFFSET		0x0060
+#define RACDMA_OFFSET		0x0080
+#if defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+    defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
+
+#define RAPDMA_OFFSET		0x0800
+#define SDM_OFFSET		0x0C00
+#else
+#define RAPDMA_OFFSET		0x0100
+#endif
+#define RAPPE_OFFSET		0x0200
+#define RACMTABLE_OFFSET	0x0400
+#define RAPOLICYTABLE_OFFSET	0x1000
+
+
+/* Register Map Detail */
+/* RT3883 */
+#define SYSCFG1			(RALINK_SYSCTL_BASE + 0x14)
+
+#if defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_MT7628)
+
+/* 1. PDMA */
+#define TX_BASE_PTR0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x000)
+#define TX_MAX_CNT0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x004)
+#define TX_CTX_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x008)
+#define TX_DTX_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x00C)
+
+#define TX_BASE_PTR1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x010)
+#define TX_MAX_CNT1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x014)
+#define TX_CTX_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x018)
+#define TX_DTX_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x01C)
+
+#define TX_BASE_PTR2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x020)
+#define TX_MAX_CNT2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x024)
+#define TX_CTX_IDX2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x028)
+#define TX_DTX_IDX2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x02C)
+
+#define TX_BASE_PTR3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x030)
+#define TX_MAX_CNT3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x034)
+#define TX_CTX_IDX3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x038)
+#define TX_DTX_IDX3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x03C)
+
+#define RX_BASE_PTR0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x100)
+#define RX_MAX_CNT0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x104)
+#define RX_CALC_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x108)
+#define RX_DRX_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x10C)
+
+#define RX_BASE_PTR1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x110)
+#define RX_MAX_CNT1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x114)
+#define RX_CALC_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x118)
+#define RX_DRX_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x11C)
+
+#define PDMA_INFO		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x200)
+#define PDMA_GLO_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x204)
+#define PDMA_RST_IDX		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x208)
+#define PDMA_RST_CFG		(PDMA_RST_IDX)
+#define DLY_INT_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x20C)
+#define FREEQ_THRES		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x210)
+#define INT_STATUS		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x220)
+#define FE_INT_STATUS		(INT_STATUS)
+#define INT_MASK		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x228)
+#define FE_INT_ENABLE		(INT_MASK)
+#define PDMA_WRR		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x280)
+#define PDMA_SCH_CFG		(PDMA_WRR)
+
+#define SDM_CON			(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x00)  //Switch DMA configuration
+#define SDM_RRING		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x04)  //Switch DMA Rx Ring
+#define SDM_TRING		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x08)  //Switch DMA Tx Ring
+#define SDM_MAC_ADRL		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x0C)  //Switch MAC address LSB
+#define SDM_MAC_ADRH		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x10)  //Switch MAC Address MSB
+#define SDM_TPCNT		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x100) //Switch DMA Tx packet count
+#define SDM_TBCNT		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x104) //Switch DMA Tx byte count
+#define SDM_RPCNT		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x108) //Switch DMA rx packet count
+#define SDM_RBCNT		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x10C) //Switch DMA rx byte count
+#define SDM_CS_ERR		(RALINK_FRAME_ENGINE_BASE+SDM_OFFSET+0x110) //Switch DMA rx checksum error count
+
+#elif defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+      defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621) 
+
+/* Old FE with New PDMA */
+#define PDMA_RELATED            0x0800
+/* 1. PDMA */
+#define TX_BASE_PTR0            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x000)
+#define TX_MAX_CNT0             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x004)
+#define TX_CTX_IDX0             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x008)
+#define TX_DTX_IDX0             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x00C)
+
+#define TX_BASE_PTR1            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x010)
+#define TX_MAX_CNT1             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x014)
+#define TX_CTX_IDX1             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x018)
+#define TX_DTX_IDX1             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x01C)
+
+#define TX_BASE_PTR2            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x020)
+#define TX_MAX_CNT2             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x024)
+#define TX_CTX_IDX2             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x028)
+#define TX_DTX_IDX2             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x02C)
+
+#define TX_BASE_PTR3            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x030)
+#define TX_MAX_CNT3             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x034)
+#define TX_CTX_IDX3             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x038)
+#define TX_DTX_IDX3             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x03C)
+
+#define RX_BASE_PTR0            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x100)
+#define RX_MAX_CNT0             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x104)
+#define RX_CALC_IDX0            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x108)
+#define RX_DRX_IDX0             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x10C)
+
+#define RX_BASE_PTR1            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x110)
+#define RX_MAX_CNT1             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x114)
+#define RX_CALC_IDX1            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x118)
+#define RX_DRX_IDX1             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x11C)
+
+#define PDMA_INFO               (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x200)
+#define PDMA_GLO_CFG            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x204)
+#define PDMA_RST_IDX            (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x208)
+#define PDMA_RST_CFG            (PDMA_RST_IDX)
+#define DLY_INT_CFG             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x20C)
+#define FREEQ_THRES             (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x210)
+#define INT_STATUS              (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x220)
+#define FE_INT_STATUS		(INT_STATUS)
+#define INT_MASK                (RALINK_FRAME_ENGINE_BASE + PDMA_RELATED+0x228)
+#define FE_INT_ENABLE		(INT_MASK)
+#define SCH_Q01_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x280)
+#define SCH_Q23_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x284)
+
+#define FE_GLO_CFG          RALINK_FRAME_ENGINE_BASE + 0x00
+#define FE_RST_GL           RALINK_FRAME_ENGINE_BASE + 0x04
+#define FE_INT_STATUS2	    RALINK_FRAME_ENGINE_BASE + 0x08
+#define FE_INT_ENABLE2	    RALINK_FRAME_ENGINE_BASE + 0x0c
+//#define FC_DROP_STA         RALINK_FRAME_ENGINE_BASE + 0x18
+#define FOE_TS_T            RALINK_FRAME_ENGINE_BASE + 0x10
+
+#if defined (CONFIG_RALINK_MT7620)
+#define GDMA1_RELATED       0x0600
+#define GDMA1_FWD_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x00)
+#define GDMA1_SHPR_CFG      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x04)
+#define GDMA1_MAC_ADRL      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x08)
+#define GDMA1_MAC_ADRH      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x0C)
+#elif defined (CONFIG_RALINK_MT7621)
+#define GDMA1_RELATED       0x0500
+#define GDMA1_FWD_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x00)
+#define GDMA1_SHPR_CFG      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x04)
+#define GDMA1_MAC_ADRL      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x08)
+#define GDMA1_MAC_ADRH      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x0C)
+
+#define GDMA2_RELATED       0x1500
+#define GDMA2_FWD_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x00)
+#define GDMA2_SHPR_CFG      (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x04)
+#define GDMA2_MAC_ADRL      (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x08)
+#define GDMA2_MAC_ADRH      (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x0C)
+#else
+#define GDMA1_RELATED       0x0020
+#define GDMA1_FWD_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x00)
+#define GDMA1_SCH_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x04)
+#define GDMA1_SHPR_CFG      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x08)
+#define GDMA1_MAC_ADRL      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x0C)
+#define GDMA1_MAC_ADRH      (RALINK_FRAME_ENGINE_BASE + GDMA1_RELATED + 0x10)
+
+#define GDMA2_RELATED       0x0060
+#define GDMA2_FWD_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x00)
+#define GDMA2_SCH_CFG       (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x04)
+#define GDMA2_SHPR_CFG      (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x08)
+#define GDMA2_MAC_ADRL      (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x0C)
+#define GDMA2_MAC_ADRH      (RALINK_FRAME_ENGINE_BASE + GDMA2_RELATED + 0x10)
+#endif
+
+#if defined (CONFIG_RALINK_MT7620)
+#define PSE_RELATED         0x0500
+#define PSE_FQFC_CFG        (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x00)
+#define PSE_IQ_CFG          (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x04)
+#define PSE_QUE_STA         (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x08)
+#else
+#define PSE_RELATED         0x0040
+#define PSE_FQ_CFG          (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x00)
+#define CDMA_FC_CFG         (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x04)
+#define GDMA1_FC_CFG        (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x08)
+#define GDMA2_FC_CFG        (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x0C)
+#define CDMA_OQ_STA         (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x10)
+#define GDMA1_OQ_STA        (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x14)
+#define GDMA2_OQ_STA        (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x18)
+#define PSE_IQ_STA          (RALINK_FRAME_ENGINE_BASE + PSE_RELATED + 0x1C)
+#endif
+
+
+#if defined (CONFIG_RALINK_MT7620)
+#define CDMA_RELATED        0x0400
+#define CDMA_CSG_CFG        (RALINK_FRAME_ENGINE_BASE + CDMA_RELATED + 0x00)
+#define SMACCR0		    (RALINK_ETH_SW_BASE + 0x3FE4)
+#define SMACCR1		    (RALINK_ETH_SW_BASE + 0x3FE8)
+#define CKGCR               (RALINK_ETH_SW_BASE + 0x3FF0)
+#elif defined (CONFIG_RALINK_MT7621)
+#define CDMA_RELATED        0x0400
+#define CDMA_CSG_CFG        (RALINK_FRAME_ENGINE_BASE + CDMA_RELATED + 0x00) //fake definition
+#define CDMP_IG_CTRL        (RALINK_FRAME_ENGINE_BASE + CDMA_RELATED + 0x00)
+#define CDMP_EG_CTRL        (RALINK_FRAME_ENGINE_BASE + CDMA_RELATED + 0x04)
+#else
+#define CDMA_RELATED        0x0080
+#define CDMA_CSG_CFG        (RALINK_FRAME_ENGINE_BASE + CDMA_RELATED + 0x00)
+#define CDMA_SCH_CFG        (RALINK_FRAME_ENGINE_BASE + CDMA_RELATED + 0x04)
+#define SMACCR0		    (RALINK_ETH_SW_BASE + 0x30E4)
+#define SMACCR1		    (RALINK_ETH_SW_BASE + 0x30E8)
+#define CKGCR               (RALINK_ETH_SW_BASE + 0x30F0)
+#endif
+
+#define PDMA_FC_CFG	    (RALINK_FRAME_ENGINE_BASE+0x100)
+
+
+#if defined (CONFIG_RALINK_MT7621)
+/*kurtis: add QDMA define*/
+
+#define CLK_CFG_0		(RALINK_SYSCTL_BASE + 0x2C)
+#define PAD_RGMII2_MDIO_CFG     (RALINK_SYSCTL_BASE + 0x58)
+
+#define QDMA_RELATED            0x1800
+#define  QTX_CFG_0          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x000)
+#define  QTX_SCH_0          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x004)
+#define  QTX_HEAD_0         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x008)
+#define  QTX_TAIL_0         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x00C)
+#define  QTX_CFG_1          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x010)
+#define  QTX_SCH_1          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x014)
+#define  QTX_HEAD_1         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x018)
+#define  QTX_TAIL_1         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x01C)
+#define  QTX_CFG_2          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x020)
+#define  QTX_SCH_2          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x024)
+#define  QTX_HEAD_2         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x028)
+#define  QTX_TAIL_2         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x02C)
+#define  QTX_CFG_3          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x030)
+#define  QTX_SCH_3          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x034)
+#define  QTX_HEAD_3         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x038)
+#define  QTX_TAIL_3         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x03C)
+#define  QTX_CFG_4          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x040)
+#define  QTX_SCH_4          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x044)
+#define  QTX_HEAD_4         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x048)
+#define  QTX_TAIL_4         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x04C)
+#define  QTX_CFG_5          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x050)
+#define  QTX_SCH_5          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x054)
+#define  QTX_HEAD_5         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x058)
+#define  QTX_TAIL_5         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x05C)
+#define  QTX_CFG_6          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x060)
+#define  QTX_SCH_6          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x064)
+#define  QTX_HEAD_6         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x068)
+#define  QTX_TAIL_6         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x06C)
+#define  QTX_CFG_7          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x070)
+#define  QTX_SCH_7          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x074)
+#define  QTX_HEAD_7         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x078)
+#define  QTX_TAIL_7         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x07C)
+#define  QTX_CFG_8          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x080)
+#define  QTX_SCH_8          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x084)
+#define  QTX_HEAD_8         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x088)
+#define  QTX_TAIL_8         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x08C)
+#define  QTX_CFG_9          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x090)
+#define  QTX_SCH_9          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x094)
+#define  QTX_HEAD_9         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x098)
+#define  QTX_TAIL_9         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x09C)
+#define  QTX_CFG_10         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0A0)
+#define  QTX_SCH_10         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0A4)
+#define  QTX_HEAD_10        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0A8)
+#define  QTX_TAIL_10        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0AC)
+#define  QTX_CFG_11         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0B0)
+#define  QTX_SCH_11         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0B4)
+#define  QTX_HEAD_11        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0B8)
+#define  QTX_TAIL_11        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0BC)
+#define  QTX_CFG_12         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0C0)
+#define  QTX_SCH_12         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0C4)
+#define  QTX_HEAD_12        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0C8)
+#define  QTX_TAIL_12        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0CC)
+#define  QTX_CFG_13         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0D0)
+#define  QTX_SCH_13         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0D4)
+#define  QTX_HEAD_13        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0D8)
+#define  QTX_TAIL_13        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0DC)
+#define  QTX_CFG_14         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0E0)
+#define  QTX_SCH_14         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0E4)
+#define  QTX_HEAD_14        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0E8)
+#define  QTX_TAIL_14        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0EC)
+#define  QTX_CFG_15         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0F0)
+#define  QTX_SCH_15         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0F4)
+#define  QTX_HEAD_15        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0F8)
+#define  QTX_TAIL_15        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x0FC)
+#define  QRX_BASE_PTR_0     (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x100)
+#define  QRX_MAX_CNT_0      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x104)
+#define  QRX_CRX_IDX_0      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x108)
+#define  QRX_DRX_IDX_0      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x10C)
+#define  QRX_BASE_PTR_1     (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x110)
+#define  QRX_MAX_CNT_1      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x114)
+#define  QRX_CRX_IDX_1      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x118)
+#define  QRX_DRX_IDX_1      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x11C)
+#define  QDMA_INFO          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x200)
+#define  QDMA_GLO_CFG       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x204)
+#define  QDMA_RST_IDX       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x208)
+#define  QDMA_RST_CFG       (QDMA_RST_IDX)
+#define  QDMA_DELAY_INT     (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x20C)
+#define  QDMA_FC_THRES      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x210)
+#define  QDMA_TX_SCH        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x214)
+#define  QDMA_INT_STS       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x218)
+#define  QFE_INT_STATUS		  (QDMA_INT_STS)
+#define  QDMA_INT_MASK      (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x21C)
+#define  QFE_INT_ENABLE		  (QDMA_INT_MASK)
+#define  QDMA_TRTCM         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x220)
+#define  QDMA_DATA0         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x224)
+#define  QDMA_DATA1         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x228)
+#define  QDMA_RED_THRES     (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x22C)
+#define  QDMA_TEST          (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x230)
+#define  QDMA_DMA           (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x234)
+#define  QDMA_BMU           (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x238)
+#define  QDMA_HRED1         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x240)
+#define  QDMA_HRED2         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x244)
+#define  QDMA_SRED1         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x248)
+#define  QDMA_SRED2         (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x24C)
+#define  QTX_CTX_PTR        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x300)
+#define  QTX_DTX_PTR        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x304)
+#define  QTX_FWD_CNT        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x308)
+#define  QTX_CRX_PTR        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x310)
+#define  QTX_DRX_PTR        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x314)
+#define  QTX_RLS_CNT        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x318)
+#define  QDMA_FQ_HEAD       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x320)
+#define  QDMA_FQ_TAIL       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x324)
+#define  QDMA_FQ_CNT        (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x328)
+#define  QDMA_FQ_BLEN       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x32C)
+#define  QTX_Q0MIN_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x350)
+#define  QTX_Q1MIN_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x354)
+#define  QTX_Q2MIN_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x358)
+#define  QTX_Q3MIN_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x35C)
+#define  QTX_Q0MAX_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x360)
+#define  QTX_Q1MAX_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x364)
+#define  QTX_Q2MAX_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x368)
+#define  QTX_Q3MAX_BK       (RALINK_FRAME_ENGINE_BASE + QDMA_RELATED + 0x36C)
+
+
+#endif/*MT7621 QDMA*/
+
+#else
+
+/* 1. Frame Engine Global Registers */
+#define MDIO_ACCESS		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x00)
+#define MDIO_CFG 		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x04)
+#define FE_GLO_CFG		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x08)
+#define FE_RST_GL		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x0C)
+#define FE_INT_STATUS		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x10)
+#define FE_INT_ENABLE		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x14)
+#define MDIO_CFG2		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x18) //Original:FC_DROP_STA
+#define FOC_TS_T		(RALINK_FRAME_ENGINE_BASE+RAFRAMEENGINE_OFFSET+0x1C)
+
+
+/* 2. GDMA Registers */
+#define	GDMA1_FWD_CFG		(RALINK_FRAME_ENGINE_BASE+RAGDMA_OFFSET+0x00)
+#define GDMA1_SCH_CFG		(RALINK_FRAME_ENGINE_BASE+RAGDMA_OFFSET+0x04)
+#define GDMA1_SHPR_CFG		(RALINK_FRAME_ENGINE_BASE+RAGDMA_OFFSET+0x08)
+#define GDMA1_MAC_ADRL		(RALINK_FRAME_ENGINE_BASE+RAGDMA_OFFSET+0x0C)
+#define GDMA1_MAC_ADRH		(RALINK_FRAME_ENGINE_BASE+RAGDMA_OFFSET+0x10)
+
+#define	GDMA2_FWD_CFG		(RALINK_FRAME_ENGINE_BASE+RAGDMA2_OFFSET+0x00)
+#define GDMA2_SCH_CFG		(RALINK_FRAME_ENGINE_BASE+RAGDMA2_OFFSET+0x04)
+#define GDMA2_SHPR_CFG		(RALINK_FRAME_ENGINE_BASE+RAGDMA2_OFFSET+0x08)
+#define GDMA2_MAC_ADRL		(RALINK_FRAME_ENGINE_BASE+RAGDMA2_OFFSET+0x0C)
+#define GDMA2_MAC_ADRH		(RALINK_FRAME_ENGINE_BASE+RAGDMA2_OFFSET+0x10)
+
+/* 3. PSE */
+#define PSE_FQ_CFG		(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x00)
+#define CDMA_FC_CFG		(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x04)
+#define GDMA1_FC_CFG		(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x08)
+#define GDMA2_FC_CFG		(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x0C)
+#define PDMA_FC_CFG		(RALINK_FRAME_ENGINE_BASE+0x1f0)
+
+/* 4. CDMA */
+#define CDMA_CSG_CFG		(RALINK_FRAME_ENGINE_BASE+RACDMA_OFFSET+0x00)
+#define CDMA_SCH_CFG		(RALINK_FRAME_ENGINE_BASE+RACDMA_OFFSET+0x04)
+/* skip ppoe sid and vlan id definition */
+
+
+/* 5. PDMA */
+#define PDMA_GLO_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x00)
+#define PDMA_RST_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x04)
+#define PDMA_SCH_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x08)
+
+#define DLY_INT_CFG		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x0C)
+
+#define TX_BASE_PTR0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x10)
+#define TX_MAX_CNT0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x14)
+#define TX_CTX_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x18)
+#define TX_DTX_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x1C)
+
+#define TX_BASE_PTR1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x20)
+#define TX_MAX_CNT1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x24)
+#define TX_CTX_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x28)
+#define TX_DTX_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x2C)
+
+#define TX_BASE_PTR2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x40)
+#define TX_MAX_CNT2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x44)
+#define TX_CTX_IDX2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x48)
+#define TX_DTX_IDX2		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x4C)
+
+#define TX_BASE_PTR3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x50)
+#define TX_MAX_CNT3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x54)
+#define TX_CTX_IDX3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x58)
+#define TX_DTX_IDX3		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x5C)
+
+#define RX_BASE_PTR0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x30)
+#define RX_MAX_CNT0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x34)
+#define RX_CALC_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x38)
+#define RX_DRX_IDX0		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x3C)
+
+#define RX_BASE_PTR1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x40)
+#define RX_MAX_CNT1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x44)
+#define RX_CALC_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x48)
+#define RX_DRX_IDX1		(RALINK_FRAME_ENGINE_BASE+RAPDMA_OFFSET+0x4C)
+
+#endif
+
+#define DELAY_INT_INIT		0x84048404
+#define FE_INT_DLY_INIT		(TX_DLY_INT | RX_DLY_INT)
+
+
+#if !defined (CONFIG_RALINK_RT5350) && !defined (CONFIG_RALINK_MT7628)
+
+/* 6. Counter and Meter Table */
+#define PPE_AC_BCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x000) /* PPE Accounting Group 0 Byte Cnt */
+#define PPE_AC_PCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x004) /* PPE Accounting Group 0 Packet Cnt */
+/* 0 ~ 63 */
+
+#define PPE_MTR_CNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x200) /* 0 ~ 63 */
+/* skip... */
+#define PPE_MTR_CNT63		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x2FC)
+
+#define GDMA_TX_GBCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x300) /* Transmit good byte cnt for GEport */
+#define GDMA_TX_GPCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x304) /* Transmit good pkt cnt for GEport */
+#define GDMA_TX_SKIPCNT0	(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x308) /* Transmit skip cnt for GEport */
+#define GDMA_TX_COLCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x30C) /* Transmit collision cnt for GEport */
+
+/* update these address mapping to fit data sheet v0.26, by bobtseng, 2007.6.14 */
+#define GDMA_RX_GBCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x320)
+#define GDMA_RX_GPCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x324)
+#define GDMA_RX_OERCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x328)
+#define GDMA_RX_FERCNT0 	(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x32C)
+#define GDMA_RX_SERCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x330)
+#define GDMA_RX_LERCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x334)
+#define GDMA_RX_CERCNT0		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x338)
+#define GDMA_RX_FCCNT1		(RALINK_FRAME_ENGINE_BASE+RACMTABLE_OFFSET+0x33C)
+
+#endif
+
+
+/* Per Port Packet Counts in RT3052, added by bobtseng 2009.4.17. */
+#define	PORT0_PKCOUNT		(0xb01100e8)
+#define	PORT1_PKCOUNT		(0xb01100ec)
+#define	PORT2_PKCOUNT		(0xb01100f0)
+#define	PORT3_PKCOUNT		(0xb01100f4)
+#define	PORT4_PKCOUNT		(0xb01100f8)
+#define	PORT5_PKCOUNT		(0xb01100fc)
+
+
+// PHYS_TO_K1
+#define PHYS_TO_K1(physaddr) KSEG1ADDR(physaddr)
+
+
+#define sysRegRead(phys)        \
+        (*(volatile unsigned int *)PHYS_TO_K1(phys))
+
+#define sysRegWrite(phys, val)  \
+        ((*(volatile unsigned int *)PHYS_TO_K1(phys)) = (val))
+
+#define u_long	unsigned long
+#define u32	unsigned int
+#define u16	unsigned short
+
+
+/* ====================================== */
+#define GDM1_DISPAD       BIT(18)
+#define GDM1_DISCRC       BIT(17)
+
+//GDMA1 uni-cast frames destination port
+#define GDM1_ICS_EN   	   (0x1 << 22)
+#define GDM1_TCS_EN   	   (0x1 << 21)
+#define GDM1_UCS_EN   	   (0x1 << 20)
+#define GDM1_JMB_EN   	   (0x1 << 19)
+#define GDM1_STRPCRC   	   (0x1 << 16)
+#define GDM1_UFRC_P_CPU     (0 << 12)
+#if defined (CONFIG_RALINK_MT7621)
+#define GDM1_UFRC_P_PPE     (4 << 12)
+#else
+#define GDM1_UFRC_P_PPE     (6 << 12)
+#endif
+
+//GDMA1 broad-cast MAC address frames
+#define GDM1_BFRC_P_CPU     (0 << 8)
+#if defined (CONFIG_RALINK_MT7621)
+#define GDM1_BFRC_P_PPE     (4 << 8)
+#else
+#define GDM1_BFRC_P_PPE     (6 << 8)
+#endif
+
+//GDMA1 multi-cast MAC address frames
+#define GDM1_MFRC_P_CPU     (0 << 4)
+#if defined (CONFIG_RALINK_MT7621)
+#define GDM1_MFRC_P_PPE     (4 << 4)
+#else
+#define GDM1_MFRC_P_PPE     (6 << 4)
+#endif
+
+//GDMA1 other MAC address frames destination port
+#define GDM1_OFRC_P_CPU     (0 << 0)
+#if defined (CONFIG_RALINK_MT7621)
+#define GDM1_OFRC_P_PPE     (4 << 0)
+#else
+#define GDM1_OFRC_P_PPE     (6 << 0)
+#endif
+
+#if defined (CONFIG_RALINK_RT6856) || defined (CONFIG_RALINK_MT7620) || defined (CONFIG_RALINK_MT7621)
+/* checksum generator registers are removed */
+#define ICS_GEN_EN          (0 << 2)
+#define UCS_GEN_EN          (0 << 1)
+#define TCS_GEN_EN          (0 << 0)
+#else
+#define ICS_GEN_EN          (1 << 2)
+#define UCS_GEN_EN          (1 << 1)
+#define TCS_GEN_EN          (1 << 0)
+#endif
+
+// MDIO_CFG	bit
+#define MDIO_CFG_GP1_FC_TX	(1 << 11)
+#define MDIO_CFG_GP1_FC_RX	(1 << 10)
+
+/* ====================================== */
+/* ====================================== */
+#define GP1_LNK_DWN     BIT(9) 
+#define GP1_AN_FAIL     BIT(8) 
+/* ====================================== */
+/* ====================================== */
+#define PSE_RESET       BIT(0)
+/* ====================================== */
+#define PST_DRX_IDX1       BIT(17)
+#define PST_DRX_IDX0       BIT(16)
+#define PST_DTX_IDX3       BIT(3)
+#define PST_DTX_IDX2       BIT(2)
+#define PST_DTX_IDX1       BIT(1)
+#define PST_DTX_IDX0       BIT(0)
+
+#define RX_2B_OFFSET	  BIT(31)
+#define DESC_32B_EN	  BIT(8)
+#define TX_WB_DDONE       BIT(6)
+#define RX_DMA_BUSY       BIT(3)
+#define TX_DMA_BUSY       BIT(1)
+#define RX_DMA_EN         BIT(2)
+#define TX_DMA_EN         BIT(0)
+
+#define PDMA_BT_SIZE_4DWORDS     (0<<4)
+#define PDMA_BT_SIZE_8DWORDS     (1<<4)
+#define PDMA_BT_SIZE_16DWORDS    (2<<4)
+#define PDMA_BT_SIZE_32DWORDS    (3<<4)
+
+/* Register bits.
+ */
+
+#define MACCFG_RXEN		(1<<2)
+#define MACCFG_TXEN		(1<<3)
+#define MACCFG_PROMISC		(1<<18)
+#define MACCFG_RXMCAST		(1<<19)
+#define MACCFG_FDUPLEX		(1<<20)
+#define MACCFG_PORTSEL		(1<<27)
+#define MACCFG_HBEATDIS		(1<<28)
+
+
+#define DMACTL_SR		(1<<1)	/* Start/Stop Receive */
+#define DMACTL_ST		(1<<13)	/* Start/Stop Transmission Command */
+
+#define DMACFG_SWR		(1<<0)	/* Software Reset */
+#define DMACFG_BURST32		(32<<8)
+
+#define DMASTAT_TS		0x00700000	/* Transmit Process State */
+#define DMASTAT_RS		0x000e0000	/* Receive Process State */
+
+#define MACCFG_INIT		0 //(MACCFG_FDUPLEX) // | MACCFG_PORTSEL)
+
+
+
+/* Descriptor bits.
+ */
+#define R_OWN		0x80000000	/* Own Bit */
+#define RD_RER		0x02000000	/* Receive End Of Ring */
+#define RD_LS		0x00000100	/* Last Descriptor */
+#define RD_ES		0x00008000	/* Error Summary */
+#define RD_CHAIN	0x01000000	/* Chained */
+
+/* Word 0 */
+#define T_OWN		0x80000000	/* Own Bit */
+#define TD_ES		0x00008000	/* Error Summary */
+
+/* Word 1 */
+#define TD_LS		0x40000000	/* Last Segment */
+#define TD_FS		0x20000000	/* First Segment */
+#define TD_TER		0x08000000	/* Transmit End Of Ring */
+#define TD_CHAIN	0x01000000	/* Chained */
+
+
+#define TD_SET		0x08000000	/* Setup Packet */
+
+
+#define POLL_DEMAND 1
+
+#define RSTCTL	(0x34)
+#define RSTCTL_RSTENET1	(1<<19)
+#define RSTCTL_RSTENET2	(1<<20)
+
+#define INIT_VALUE_OF_RT2883_PSE_FQ_CFG		0xff908000
+#define INIT_VALUE_OF_PSE_FQFC_CFG		0x80504000
+#define INIT_VALUE_OF_FORCE_100_FD		0x1001BC01
+#define INIT_VALUE_OF_FORCE_1000_FD		0x1F01DC01
+
+// Define Whole FE Reset Register
+#define RSTCTRL         (RALINK_SYSCTL_BASE + 0x34)
+
+/*=========================================
+      PDMA RX Descriptor Format define
+=========================================*/
+
+//-------------------------------------------------
+typedef struct _PDMA_RXD_INFO1_  PDMA_RXD_INFO1_T;
+
+struct _PDMA_RXD_INFO1_
+{
+    unsigned int    PDP0;
+};
+//-------------------------------------------------
+typedef struct _PDMA_RXD_INFO2_    PDMA_RXD_INFO2_T;
+
+struct _PDMA_RXD_INFO2_
+{
+    unsigned int    PLEN1                 : 14;
+    unsigned int    LS1                   : 1;
+    unsigned int    TAG                   : 1;
+    unsigned int    PLEN0                 : 14;
+    unsigned int    LS0                   : 1;
+    unsigned int    DDONE_bit             : 1;
+};
+//-------------------------------------------------
+typedef struct _PDMA_RXD_INFO3_  PDMA_RXD_INFO3_T;
+
+struct _PDMA_RXD_INFO3_
+{
+    unsigned int    VID:16;
+    unsigned int    TPID:16;
+};
+//-------------------------------------------------
+typedef struct _PDMA_RXD_INFO4_    PDMA_RXD_INFO4_T;
+
+struct _PDMA_RXD_INFO4_
+{
+#if defined (CONFIG_RALINK_MT7620)
+    unsigned int    FOE_Entry           : 14;
+    unsigned int    CRSN		: 5;
+    unsigned int    SPORT		: 3;
+    unsigned int    L4F			: 1;
+    unsigned int    L4VLD		: 1;
+    unsigned int    TACK		: 1;
+    unsigned int    IP4F		: 1;
+    unsigned int    IP4			: 1;
+    unsigned int    IP6			: 1;
+    unsigned int    UN_USE1		: 4;
+#elif defined (CONFIG_RALINK_MT7621)
+    unsigned int    FOE_Entry           : 14;
+    unsigned int    CRSN		: 5;
+    unsigned int    SP			: 4;
+    unsigned int    L4F			: 1;
+    unsigned int    L4VLD		: 1;
+    unsigned int    TACK		: 1;
+    unsigned int    IP4F		: 1;
+    unsigned int    IP4			: 1;
+    unsigned int    IP6			: 1;
+    unsigned int    UN_USE1		: 3;
+#else
+    unsigned int    FOE_Entry           : 14;
+    unsigned int    FVLD                : 1;
+    unsigned int    UN_USE1             : 1;
+    unsigned int    AI                  : 8;
+    unsigned int    SP                  : 3;
+    unsigned int    AIS                 : 1;
+    unsigned int    L4F                 : 1;
+    unsigned int    IPF                  : 1;
+    unsigned int    L4FVLD_bit           : 1;
+    unsigned int    IPFVLD_bit           : 1;
+#endif
+};
+
+
+struct PDMA_rxdesc {
+	PDMA_RXD_INFO1_T rxd_info1;
+	PDMA_RXD_INFO2_T rxd_info2;
+	PDMA_RXD_INFO3_T rxd_info3;
+	PDMA_RXD_INFO4_T rxd_info4;
+#ifdef CONFIG_32B_DESC
+	unsigned int     rxd_info5;
+	unsigned int     rxd_info6;
+	unsigned int     rxd_info7;
+	unsigned int     rxd_info8;
+#endif
+};
+
+/*=========================================
+      PDMA TX Descriptor Format define
+=========================================*/
+//-------------------------------------------------
+typedef struct _PDMA_TXD_INFO1_  PDMA_TXD_INFO1_T;
+
+struct _PDMA_TXD_INFO1_
+{
+    unsigned int    SDP0;
+};
+//-------------------------------------------------
+typedef struct _PDMA_TXD_INFO2_    PDMA_TXD_INFO2_T;
+
+struct _PDMA_TXD_INFO2_
+{
+    unsigned int    SDL1                  : 14;
+    unsigned int    LS1_bit               : 1;
+    unsigned int    BURST_bit             : 1;
+    unsigned int    SDL0                  : 14;
+    unsigned int    LS0_bit               : 1;
+    unsigned int    DDONE_bit             : 1;
+};
+//-------------------------------------------------
+typedef struct _PDMA_TXD_INFO3_  PDMA_TXD_INFO3_T;
+
+struct _PDMA_TXD_INFO3_
+{
+    unsigned int    SDP1;
+};
+//-------------------------------------------------
+typedef struct _PDMA_TXD_INFO4_    PDMA_TXD_INFO4_T;
+
+struct _PDMA_TXD_INFO4_
+{
+#if defined (CONFIG_RALINK_MT7620)
+    unsigned int    VPRI_VIDX           : 8;
+    unsigned int    SIDX                : 4;
+    unsigned int    INSP                : 1;
+    unsigned int    RESV            	: 2;
+    unsigned int    UDF            	: 5;
+    unsigned int    FP_BMAP            	: 8;
+    unsigned int    TSO			: 1;
+    unsigned int    TUI_CO		: 3;
+#elif defined (CONFIG_RALINK_MT7621)
+    unsigned int    VLAN_TAG		:17; // INSV(1)+VPRI(3)+CFI(1)+VID(12)
+    unsigned int    RESV                : 2;
+    unsigned int    UDF                 : 6;
+    unsigned int    FPORT               : 3;
+    unsigned int    TSO			: 1;
+    unsigned int    TUI_CO		: 3;
+#else
+    unsigned int    VPRI_VIDX           : 8;
+    unsigned int    SIDX                : 4;
+    unsigned int    INSP                : 1;
+    unsigned int    RESV            	: 1;
+    unsigned int    UN_USE3             : 2;
+    unsigned int    QN                  : 3;
+    unsigned int    UN_USE2             : 1;
+    unsigned int    UDF			: 4;
+    unsigned int    PN                  : 3;
+    unsigned int    UN_USE1             : 1;
+    unsigned int    TSO			: 1;
+    unsigned int    TUI_CO		: 3;
+#endif
+};
+
+
+struct PDMA_txdesc {
+	PDMA_TXD_INFO1_T txd_info1;
+	PDMA_TXD_INFO2_T txd_info2;
+	PDMA_TXD_INFO3_T txd_info3;
+	PDMA_TXD_INFO4_T txd_info4;
+#ifdef CONFIG_32B_DESC
+	unsigned int     txd_info5;
+	unsigned int     txd_info6;
+	unsigned int     txd_info7;
+	unsigned int     txd_info8;
+#endif
+};
+
+
+#if defined (CONFIG_RALINK_MT7621)
+/*=========================================
+      QDMA TX Descriptor Format define
+=========================================*/
+//-------------------------------------------------
+typedef struct _QDMA_TXD_INFO1_  QDMA_TXD_INFO1_T;
+
+struct _QDMA_TXD_INFO1_
+{
+    unsigned int    SDP;
+};
+//-------------------------------------------------
+typedef struct _QDMA_TXD_INFO2_    QDMA_TXD_INFO2_T;
+
+struct _QDMA_TXD_INFO2_
+{
+    unsigned int    NDP;
+};
+//-------------------------------------------------
+typedef struct _QDMA_TXD_INFO3_  QDMA_TXD_INFO3_T;
+
+struct _QDMA_TXD_INFO3_
+{
+    unsigned int    QID                   : 4;
+    unsigned int    RESV                  : 10;
+    unsigned int    SWC_bit               : 1;	
+    unsigned int    BURST_bit             : 1;
+    unsigned int    SDL                   : 14;
+    unsigned int    LS_bit               : 1;
+    unsigned int    OWN_bit             : 1;
+};
+//-------------------------------------------------
+typedef struct _QDMA_TXD_INFO4_    QDMA_TXD_INFO4_T;
+
+struct _QDMA_TXD_INFO4_
+{
+    unsigned int    VLAN_TAG		:17; // INSV(1)+VPRI(3)+CFI(1)+VID(12)
+    unsigned int    RESV                : 2;
+    unsigned int    UDF                 : 6;
+    unsigned int    FPORT               : 3;
+    unsigned int    TSO			: 1;
+    unsigned int    TUI_CO		: 3;
+};
+
+
+struct QDMA_txdesc {
+	QDMA_TXD_INFO1_T txd_info1;
+	QDMA_TXD_INFO2_T txd_info2;
+	QDMA_TXD_INFO3_T txd_info3;
+	QDMA_TXD_INFO4_T txd_info4;
+#ifdef CONFIG_32B_DESC
+	unsigned int     txd_info5;
+	unsigned int     txd_info6;
+	unsigned int     txd_info7;
+	unsigned int     txd_info8;
+#endif
+};
+#endif
+
+#define phys_to_bus(a) (a & 0x1FFFFFFF)
+
+#define PHY_Enable_Auto_Nego		0x1000
+#define PHY_Restart_Auto_Nego		0x0200
+
+/* PHY_STAT_REG = 1; */
+#define PHY_Auto_Neco_Comp	0x0020
+#define PHY_Link_Status		0x0004
+
+/* PHY_AUTO_NEGO_REG = 4; */
+#define PHY_Cap_10_Half  0x0020
+#define PHY_Cap_10_Full  0x0040
+#define	PHY_Cap_100_Half 0x0080
+#define	PHY_Cap_100_Full 0x0100
+
+/* proc definition */
+
+#if !defined (CONFIG_RALINK_RT6855) && !defined(CONFIG_RALINK_RT6855A) && \
+    !defined (CONFIG_RALINK_MT7620) && !defined (CONFIG_RALINK_MT7621) 
+#define CDMA_OQ_STA	(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x4c)
+#define GDMA1_OQ_STA	(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x50)
+#define PPE_OQ_STA	(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x54)
+#define PSE_IQ_STA	(RALINK_FRAME_ENGINE_BASE+RAPSE_OFFSET+0x58)
+#endif
+
+#define PROCREG_CONTROL_FILE      "/var/run/procreg_control"
+#if defined (CONFIG_RALINK_RT2880)
+#define PROCREG_DIR             "rt2880"
+#elif defined (CONFIG_RALINK_RT3052)
+#define PROCREG_DIR             "rt3052"
+#elif defined (CONFIG_RALINK_RT3352)
+#define PROCREG_DIR             "rt3352"
+#elif defined (CONFIG_RALINK_RT5350)
+#define PROCREG_DIR             "rt5350"
+#elif defined (CONFIG_RALINK_RT2883)
+#define PROCREG_DIR             "rt2883"
+#elif defined (CONFIG_RALINK_RT3883)
+#define PROCREG_DIR             "rt3883"
+#elif defined (CONFIG_RALINK_RT6855)
+#define PROCREG_DIR             "rt6855"
+#elif defined (CONFIG_RALINK_MT7620)
+#define PROCREG_DIR             "mt7620"
+#elif defined (CONFIG_RALINK_MT7621)
+#define PROCREG_DIR             "mt7621"
+#elif defined (CONFIG_RALINK_MT7628)
+#define PROCREG_DIR             "mt7628"
+#elif defined (CONFIG_RALINK_RT6855A)
+#define PROCREG_DIR             "rt6855a"
+#else
+#define PROCREG_DIR             "rt2880"
+#endif
+#define PROCREG_SKBFREE		"skb_free"
+#define PROCREG_TXRING		"tx_ring"
+#define PROCREG_RXRING		"rx_ring"
+#define PROCREG_NUM_OF_TXD	"num_of_txd"
+#define PROCREG_TSO_LEN		"tso_len"
+#define PROCREG_LRO_STATS	"lro_stats"
+#define PROCREG_GMAC		"gmac"
+#define PROCREG_GMAC2           "gmac2"
+#define PROCREG_CP0		"cp0"
+#define PROCREG_RAQOS		"qos"
+#define PROCREG_READ_VAL	"regread_value"
+#define PROCREG_WRITE_VAL	"regwrite_value"
+#define PROCREG_ADDR	  	"reg_addr"
+#define PROCREG_CTL		"procreg_control"
+#define PROCREG_RXDONE_INTR	"rxdone_intr_count"
+#define PROCREG_ESW_INTR	"esw_intr_count"
+#define PROCREG_ESW_CNT		"esw_cnt"
+#define PROCREG_SNMP		"snmp"
+#if defined (TASKLET_WORKQUEUE_SW)
+#define PROCREG_SCHE		"schedule"
+#endif
+#define PROCREG_QDMA            "qdma"
+
+struct rt2880_reg_op_data {
+  char	name[64];
+  unsigned int reg_addr;
+  unsigned int op;
+  unsigned int reg_value;
+};        
+
+#ifdef CONFIG_RAETH_LRO
+struct lro_counters {
+        u32 lro_aggregated;
+        u32 lro_flushed;
+        u32 lro_no_desc;
+};
+
+struct lro_para_struct {
+	unsigned int lan_ip1;
+};
+
+#endif // CONFIG_RAETH_LRO //
+
+
+
+
+typedef struct end_device
+{
+
+    unsigned int        tx_cpu_owner_idx0;
+    unsigned int        rx_cpu_owner_idx0;
+    unsigned int        fe_int_status;
+    unsigned int        tx_full; 
+    
+#if !defined (CONFIG_RAETH_QDMA)
+    unsigned int	phy_tx_ring0;
+#else
+    /* QDMA Tx  PTR */
+    struct sk_buff *free_skb[NUM_TX_DESC];
+    unsigned int tx_dma_ptr;
+    unsigned int tx_cpu_ptr;
+    unsigned int free_txd_num;
+	unsigned int free_txd_head;
+	unsigned int free_txd_tail;	
+    struct QDMA_txdesc *txd_pool;
+    dma_addr_t phy_txd_pool;
+//    unsigned int phy_txd_pool;
+    unsigned int txd_pool_info[NUM_TX_DESC];
+#endif
+
+    unsigned int	phy_rx_ring0, phy_rx_ring1;
+
+#if defined (CONFIG_RALINK_RT3052) || defined (CONFIG_RALINK_RT3352) || \
+    defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_RT6855) || \
+    defined(CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7620) || \
+    defined(CONFIG_RALINK_MT7621) || defined (CONFIG_RALINK_MT7628)
+    //send signal to user application to notify link status changed
+    struct work_struct  kill_sig_wq;
+#endif
+
+    struct work_struct  reset_task;
+#ifdef WORKQUEUE_BH
+    struct work_struct  rx_wq;
+#else
+#if defined (TASKLET_WORKQUEUE_SW)
+    struct work_struct  rx_wq;
+#endif
+#endif // WORKQUEUE_BH //
+
+#if defined(CONFIG_RAETH_QOS)
+    struct		sk_buff *	   skb_free[NUM_TX_RINGS][NUM_TX_DESC];
+    unsigned int	free_idx[NUM_TX_RINGS];
+#else
+    struct		sk_buff*	   skb_free[NUM_TX_DESC];
+    unsigned int	free_idx;
+#endif
+
+    struct              net_device_stats stat;  /* The new statistics table. */
+    spinlock_t          page_lock;              /* Page register locks */
+    struct PDMA_txdesc *tx_ring0;
+#if defined(CONFIG_RAETH_QOS)
+    struct PDMA_txdesc *tx_ring1;
+    struct PDMA_txdesc *tx_ring2;
+    struct PDMA_txdesc *tx_ring3;
+#endif
+    struct PDMA_rxdesc *rx_ring0;
+    struct sk_buff     *netrx0_skbuf[NUM_RX_DESC];
+#if defined (CONFIG_RAETH_MULTIPLE_RX_RING)
+    struct PDMA_rxdesc *rx_ring1;
+    struct sk_buff     *netrx1_skbuf[NUM_RX_DESC];
+#endif
+#ifdef CONFIG_RAETH_NAPI
+    atomic_t irq_sem;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+    struct napi_struct napi;
+#endif
+#endif
+#ifdef CONFIG_PSEUDO_SUPPORT
+    struct net_device *PseudoDev;
+    unsigned int isPseudo;
+#endif
+#if defined (CONFIG_ETHTOOL) /*&& defined (CONFIG_RAETH_ROUTER)*/
+	struct mii_if_info	mii_info;
+#endif
+#ifdef CONFIG_RAETH_LRO
+    struct lro_counters lro_counters;
+    struct net_lro_mgr lro_mgr;
+    struct net_lro_desc lro_arr[8];
+#endif
+#ifdef CONFIG_RAETH_HW_VLAN_RX
+    struct vlan_group *vlgrp;
+#endif
+} END_DEVICE, *pEND_DEVICE;
+
+
+#define RAETH_VERSION	"v3.0"
+
+#endif
+
+#ifdef CONFIG_RAETH_QDMA
+#define DMA_GLO_CFG QDMA_GLO_CFG
+#define GDMA1_FWD_PORT 0x5555
+#define GDMA2_FWD_PORT 0x5555
+#define RAETH_RX_CALC_IDX0 QRX_CRX_IDX_0
+#define RAETH_RX_CALC_IDX1 QRX_CRX_IDX_1
+#define RAETH_FE_INT_STATUS QFE_INT_STATUS
+#define RAETH_FE_INT_ALL QFE_INT_ALL
+#define RAETH_FE_INT_ENABLE QFE_INT_ENABLE
+#define RAETH_FE_INT_DLY_INIT QFE_INT_DLY_INIT
+#define RAETH_FE_INT_SETTING RX_DONE_INT0 | RX_DONE_INT1 | RLS_DONE_INT
+#define RAETH_TX_DLY_INT RLS_DLY_INT
+#define RAETH_TX_DONE_INT0 RLS_DONE_INT
+#define RAETH_DLY_INT_CFG QDMA_DELAY_INT
+#else
+#define DMA_GLO_CFG PDMA_GLO_CFG
+#define GDMA1_FWD_PORT 0x0000
+#define GDMA2_FWD_PORT 0x0000
+#define RAETH_RX_CALC_IDX0 RX_CALC_IDX0
+#define RAETH_RX_CALC_IDX1 RX_CALC_IDX1
+#define RAETH_FE_INT_STATUS FE_INT_STATUS
+#define RAETH_FE_INT_ALL FE_INT_ALL
+#define RAETH_FE_INT_ENABLE FE_INT_ENABLE
+#define RAETH_FE_INT_DLY_INIT FE_INT_DLY_INIT
+#define RAETH_FE_INT_SETTING RX_DONE_INT0 | RX_DONE_INT1 | TX_DONE_INT0 | TX_DONE_INT1 | TX_DONE_INT2 | TX_DONE_INT3
+#define RAETH_TX_DLY_INT TX_DLY_INT
+#define RAETH_TX_DONE_INT0 TX_DONE_INT0
+#define RAETH_DLY_INT_CFG DLY_INT_CFG
+#endif
diff --git a/drivers/net/ethernet/raeth/ra_ioctl.h b/drivers/net/ethernet/raeth/ra_ioctl.h
new file mode 100644
index 0000000..eac0964
--- /dev/null
+++ b/drivers/net/ethernet/raeth/ra_ioctl.h
@@ -0,0 +1,92 @@
+#ifndef _RAETH_IOCTL_H
+#define _RAETH_IOCTL_H
+
+/* ioctl commands */
+#define RAETH_ESW_REG_READ		0x89F1
+#define RAETH_ESW_REG_WRITE		0x89F2
+#define RAETH_MII_READ			0x89F3
+#define RAETH_MII_WRITE			0x89F4
+#define RAETH_ESW_INGRESS_RATE		0x89F5
+#define RAETH_ESW_EGRESS_RATE		0x89F6
+#define RAETH_ESW_PHY_DUMP		0x89F7
+#define RAETH_QDMA_REG_READ		0x89F8
+#define RAETH_QDMA_REG_WRITE		0x89F9
+#define RAETH_QDMA_QUEUE_MAPPING        0x89FA
+#define RAETH_QDMA_READ_CPU_CLK         0x89FB
+
+#if defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+    defined (CONFIG_RALINK_MT7620) || defined(CONFIG_RALINK_MT7621)
+
+#define REG_ESW_WT_MAC_MFC              0x10
+#define REG_ESW_WT_MAC_ATA1             0x74
+#define REG_ESW_WT_MAC_ATA2             0x78
+#define REG_ESW_WT_MAC_ATWD             0x7C
+#define REG_ESW_WT_MAC_ATC              0x80 
+
+#define REG_ESW_TABLE_TSRA1		0x84
+#define REG_ESW_TABLE_TSRA2		0x88
+#define REG_ESW_TABLE_ATRD		0x8C
+
+
+#define REG_ESW_VLAN_VTCR		0x90
+#define REG_ESW_VLAN_VAWD1		0x94
+#define REG_ESW_VLAN_VAWD2		0x98
+
+
+#define REG_ESW_VLAN_ID_BASE		0x100
+
+//#define REG_ESW_VLAN_ID_BASE		0x50
+#define REG_ESW_VLAN_MEMB_BASE		0x70
+#define REG_ESW_TABLE_SEARCH		0x24
+#define REG_ESW_TABLE_STATUS0		0x28
+#define REG_ESW_TABLE_STATUS1		0x2C
+#define REG_ESW_TABLE_STATUS2		0x30
+#define REG_ESW_WT_MAC_AD0		0x34
+#define REG_ESW_WT_MAC_AD1		0x38
+#define REG_ESW_WT_MAC_AD2		0x3C
+
+#else
+/* rt3052 embedded ethernet switch registers */
+#define REG_ESW_VLAN_ID_BASE		0x50
+#define REG_ESW_VLAN_MEMB_BASE		0x70
+#define REG_ESW_TABLE_SEARCH		0x24
+#define REG_ESW_TABLE_STATUS0		0x28
+#define REG_ESW_TABLE_STATUS1		0x2C
+#define REG_ESW_TABLE_STATUS2		0x30
+#define REG_ESW_WT_MAC_AD0		0x34
+#define REG_ESW_WT_MAC_AD1		0x38
+#define REG_ESW_WT_MAC_AD2		0x3C
+#endif
+
+
+#if defined(CONFIG_RALINK_RT3352) || defined (CONFIG_RALINK_RT5350) || defined (CONFIG_RALINK_MT7628)
+#define REG_ESW_MAX			0x16C
+#elif defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+      defined (CONFIG_RALINK_MT7620)
+#define REG_ESW_MAX			0x7FFFF
+#else //RT305x, RT3350
+#define REG_ESW_MAX			0xFC
+#endif
+#define REG_HQOS_MAX			0x3FFF
+
+
+typedef struct rt3052_esw_reg {
+	unsigned int off;
+	unsigned int val;
+} esw_reg;
+
+typedef struct ralink_mii_ioctl_data {
+	__u32	phy_id;
+	__u32	reg_num;
+	__u32	val_in;
+	__u32	val_out;
+} ra_mii_ioctl_data;
+
+typedef struct rt335x_esw_reg {
+	unsigned int on_off;
+	unsigned int port;
+	unsigned int bw;/*Mbps*/
+} esw_rate;
+
+
+#endif
diff --git a/drivers/net/ethernet/raeth/ra_mac.c b/drivers/net/ethernet/raeth/ra_mac.c
new file mode 100644
index 0000000..8e07a06
--- /dev/null
+++ b/drivers/net/ethernet/raeth/ra_mac.c
@@ -0,0 +1,98 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/signal.h>
+#include <linux/irq.h>
+#include <linux/ctype.h>
+
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include <asm/rt2880/surfboardint.h>	/* for cp0 reg access, added by bobtseng */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+//#include <linux/mca.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+#if defined(CONFIG_USER_SNMPD)
+#include <linux/seq_file.h>
+#endif
+
+
+
+#include "ra2882ethreg.h"
+#include "raether.h"
+#include "ra_mac.h"
+
+extern struct net_device *dev_raether;
+
+
+void ra2880stop(END_DEVICE *ei_local)
+{
+	unsigned int regValue;
+	printk("ra2880stop()...");
+
+	regValue = sysRegRead(PDMA_GLO_CFG);
+	regValue &= ~(TX_WB_DDONE | RX_DMA_EN | TX_DMA_EN);
+	sysRegWrite(PDMA_GLO_CFG, regValue);
+	printk("-> %s 0x%08x 0x%08x\n", "PDMA_GLO_CFG", PDMA_GLO_CFG, regValue);
+	printk("Done\n");
+}
+
+void ei_irq_clear(void)
+{
+        sysRegWrite(FE_INT_STATUS, 0xFFFFFFFF);
+	printk("-> %s 0x%08x 0x%08x\n", "FE_INT_STATUS", FE_INT_STATUS, 0xFFFFFFFF);
+}
+
+void rt2880_gmac_hard_reset(void)
+{
+	sysRegWrite(RSTCTRL, RALINK_FE_RST);
+	printk("-> %s 0x%08x 0x%08x\n", "RSTCTRL", RSTCTRL, RALINK_FE_RST);
+	sysRegWrite(RSTCTRL, 0);
+	printk("-> %s 0x%08x 0x%08x\n", "RSTCTRL", RSTCTRL, 0);
+}
+
+void ra2880EnableInterrupt()
+{
+	unsigned int regValue = sysRegRead(FE_INT_ENABLE);
+	sysRegWrite(FE_INT_ENABLE, regValue);
+	printk("-> %s 0x%08x 0x%08x\n", "FE_INT_ENABLE", FE_INT_ENABLE, regValue);
+}
+
+void ra2880MacAddressSet(unsigned char p[6])
+{
+        unsigned long regValue;
+
+	regValue = (p[0] << 8) | (p[1]);
+        sysRegWrite(GDMA1_MAC_ADRH, regValue);
+	printk("-> %s 0x%08x 0x%08x\n", "GDMA1_MAC_ADRH", GDMA1_MAC_ADRH, regValue);
+
+        regValue = (p[2] << 24) | (p[3] <<16) | (p[4] << 8) | p[5];
+	printk("-> %s 0x%08x 0x%08x\n", "GDMA1_MAC_ADRL", GDMA1_MAC_ADRL, regValue);
+        sysRegWrite(GDMA1_MAC_ADRL, regValue);
+
+        return;
+}
+
+
diff --git a/drivers/net/ethernet/raeth/ra_mac.h b/drivers/net/ethernet/raeth/ra_mac.h
new file mode 100644
index 0000000..4f4e6ae
--- /dev/null
+++ b/drivers/net/ethernet/raeth/ra_mac.h
@@ -0,0 +1,35 @@
+#ifndef RA_MAC_H
+#define RA_MAC_H
+
+void ra2880stop(END_DEVICE *ei_local);
+void ra2880MacAddressSet(unsigned char p[6]);
+void ra2880Mac2AddressSet(unsigned char p[6]);
+void ethtool_init(struct net_device *dev);
+
+void ra2880EnableInterrupt(void);
+
+void dump_qos(void);
+void dump_reg(void);
+void dump_cp0(void);
+
+int debug_proc_init(void);
+void debug_proc_exit(void);
+
+#if defined (CONFIG_RALINK_RT6855) || defined(CONFIG_RALINK_RT6855A) || \
+           defined (CONFIG_RALINK_MT7620) || defined(CONFIG_RALINK_MT7621)
+void enable_auto_negotiate(int unused);
+#else
+void enable_auto_negotiate(int ge);
+#endif
+
+void rt2880_gmac_hard_reset(void);
+
+int TsoLenUpdate(int tso_len);
+int NumOfTxdUpdate(int num_of_txd);
+
+#ifdef CONFIG_RAETH_LRO
+int LroStatsUpdate(struct net_lro_mgr *lro_mgr, bool all_flushed);
+#endif
+int getnext(const char *src, int separator, char *dest);
+int str_to_ip(unsigned int *ip, const char *str);
+#endif
diff --git a/drivers/net/ethernet/raeth/raether.c b/drivers/net/ethernet/raeth/raether.c
new file mode 100644
index 0000000..b6cbc40
--- /dev/null
+++ b/drivers/net/ethernet/raeth/raether.c
@@ -0,0 +1,693 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/if_ether.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+
+#include <asm/rt2880/rt_mmap.h>
+#include "ra2882ethreg.h"
+#include "raether.h"
+#include "ra_mac.h"
+#include "ra_ioctl.h"
+
+static int rt2880_eth_recv(struct net_device* dev);
+int reg_dbg = 0;
+
+void setup_internal_gsw(void);
+
+#define	MAX_RX_LENGTH	1536
+
+struct net_device		*dev_raether;
+
+static int rx_dma_owner_idx; 
+static int rx_dma_owner_idx0;
+static int pending_recv;
+static struct PDMA_rxdesc	*rx_ring;
+static unsigned long tx_ring_full=0;
+
+#define KSEG1                   0xa0000000
+#define PHYS_TO_VIRT(x)         ((void *)((x) | KSEG1))
+#define VIRT_TO_PHYS(x)         ((unsigned long)(x) & ~KSEG1)
+
+extern int fe_dma_init(struct net_device *dev);
+extern int ei_start_xmit(struct sk_buff* skb, struct net_device *dev, int gmac_no);
+extern void ei_xmit_housekeeping(unsigned long unused);
+extern inline int rt2880_eth_send(struct net_device* dev, struct sk_buff *skb, int gmac_no);
+
+static int ei_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = p;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	if(netif_running(dev))
+		return -EBUSY;
+
+        ra2880MacAddressSet(addr->sa_data);
+	return 0;
+}
+
+
+void set_fe_dma_glo_cfg(void)
+{
+        int dma_glo_cfg=0;
+
+	dma_glo_cfg = (TX_WB_DDONE | RX_DMA_EN | TX_DMA_EN | PDMA_BT_SIZE_16DWORDS);
+
+	dma_glo_cfg |= (RX_2B_OFFSET);
+
+	sysRegWrite(DMA_GLO_CFG, dma_glo_cfg);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "DMA_GLO_CFG", DMA_GLO_CFG, dma_glo_cfg);
+}
+
+int forward_config(struct net_device *dev)
+{
+	unsigned int	regVal, regCsg;
+
+	regVal = sysRegRead(GDMA1_FWD_CFG);
+	regCsg = sysRegRead(CDMA_CSG_CFG);
+
+	//set unicast/multicast/broadcast frame to cpu
+	regVal &= ~0xFFFF;
+	regVal |= GDMA1_FWD_PORT;
+	regCsg &= ~0x7;
+
+	//disable ipv4 header checksum check
+	regVal &= ~GDM1_ICS_EN;
+	regCsg &= ~ICS_GEN_EN;
+
+	//disable tcp checksum check
+	regVal &= ~GDM1_TCS_EN;
+	regCsg &= ~TCS_GEN_EN;
+
+	//disable udp checksum check
+	regVal &= ~GDM1_UCS_EN;
+	regCsg &= ~UCS_GEN_EN;
+
+
+	dev->features &= ~NETIF_F_IP_CSUM; /* disable checksum TCP/UDP over IPv4 */
+
+
+	sysRegWrite(GDMA1_FWD_CFG, regVal);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "GDMA1_FWD_CFG", GDMA1_FWD_CFG, regVal);
+	sysRegWrite(CDMA_CSG_CFG, regCsg);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "CDMA_CSG_CFG", CDMA_CSG_CFG, regCsg);
+
+	regVal = 0x1;
+	sysRegWrite(FE_RST_GL, regVal);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "FE_RST_GL", FE_RST_GL, regVal);
+	sysRegWrite(FE_RST_GL, 0);	// update for RSTCTL issue
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "FE_RST_GL", FE_RST_GL, 1);
+
+	regCsg = sysRegRead(CDMA_CSG_CFG);
+	printk("CDMA_CSG_CFG = %0X\n",regCsg);
+	regVal = sysRegRead(GDMA1_FWD_CFG);
+	printk("GDMA1_FWD_CFG = %0X\n",regVal);
+
+	return 1;
+}
+
+
+static int rt2880_eth_recv(struct net_device* dev)
+{
+	struct sk_buff	*skb, *rx_skb;
+	unsigned int	length = 0;
+	unsigned long	RxProcessed;
+
+
+	int bReschedule = 0;
+	END_DEVICE* 	ei_local = netdev_priv(dev);
+
+
+
+	RxProcessed = 0;
+
+	rx_dma_owner_idx0 = (sysRegRead(RAETH_RX_CALC_IDX0) + 1) % NUM_RX_DESC;
+
+	for ( ; ; ) {
+
+		if (RxProcessed++ > NUM_RX_MAX_PROCESS)
+                {
+                        // need to reschedule rx handle
+                        bReschedule = 1;
+                        break;
+                }
+
+
+
+		if (ei_local->rx_ring0[rx_dma_owner_idx0].rxd_info2.DDONE_bit == 1)  {
+		    rx_ring = ei_local->rx_ring0;
+		    rx_dma_owner_idx = rx_dma_owner_idx0;
+		} else {
+		    break;
+		}
+
+		/* skb processing */
+		length = rx_ring[rx_dma_owner_idx].rxd_info2.PLEN0;
+		rx_skb = ei_local->netrx0_skbuf[rx_dma_owner_idx];
+		rx_skb->data = ei_local->netrx0_skbuf[rx_dma_owner_idx]->data;
+		rx_skb->len 	= length;
+
+		rx_skb->data += NET_IP_ALIGN;
+
+		rx_skb->tail 	= rx_skb->data + length;
+
+		rx_skb->dev 	  = dev;
+		rx_skb->protocol  = eth_type_trans(rx_skb,dev);
+
+		    rx_skb->ip_summed = CHECKSUM_NONE;
+
+
+		/* We have to check the free memory size is big enough
+		 * before pass the packet to cpu*/
+		skb = __dev_alloc_skb(MAX_RX_LENGTH + NET_IP_ALIGN, GFP_ATOMIC);
+
+		if (unlikely(skb == NULL))
+		{
+			printk(KERN_ERR "skb not available...\n");
+				ei_local->stat.rx_dropped++;
+                        bReschedule = 1;
+			break;
+		}
+
+         {
+                netif_rx(rx_skb);
+         }
+
+		{
+			ei_local->stat.rx_packets++;
+			ei_local->stat.rx_bytes += length;
+		}
+
+
+		rx_ring[rx_dma_owner_idx].rxd_info2.PLEN0 = MAX_RX_LENGTH;
+		rx_ring[rx_dma_owner_idx].rxd_info2.LS0 = 0;
+		rx_ring[rx_dma_owner_idx].rxd_info2.DDONE_bit = 0;
+		rx_ring[rx_dma_owner_idx].rxd_info1.PDP0 = dma_map_single(NULL, skb->data, MAX_RX_LENGTH, PCI_DMA_FROMDEVICE);
+
+		/*  Move point to next RXD which wants to alloc*/
+		sysRegWrite(RAETH_RX_CALC_IDX0, rx_dma_owner_idx);
+		if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RAETH_RX_CALC_IDX0", RAETH_RX_CALC_IDX0, rx_dma_owner_idx);
+		ei_local->netrx0_skbuf[rx_dma_owner_idx] = skb;
+
+		/* Update to Next packet point that was received.
+		 */
+		rx_dma_owner_idx0 = (sysRegRead(RAETH_RX_CALC_IDX0) + 1) % NUM_RX_DESC;
+	}	/* for */
+
+	return bReschedule;
+}
+
+void ei_receive_workq(struct work_struct *work)
+{
+	struct net_device *dev = dev_raether;
+	END_DEVICE *ei_local = netdev_priv(dev);
+	unsigned long reg_int_mask=0;
+	int bReschedule=0;
+
+
+	if(tx_ring_full==0){
+		bReschedule = rt2880_eth_recv(dev);
+		if(bReschedule)
+		{
+			schedule_work(&ei_local->rx_wq);
+		}else{
+			reg_int_mask=sysRegRead(RAETH_FE_INT_ENABLE);
+			sysRegWrite(RAETH_FE_INT_ENABLE, reg_int_mask| RX_DLY_INT);
+			if (reg_dbg) printk("-> %s 0x%08x 0x%08lx\n", "RAETH_FE_INT_ENABLE", RAETH_FE_INT_ENABLE, reg_int_mask| RX_DLY_INT);
+		}
+	}else{
+                schedule_work(&ei_local->rx_wq);
+	}
+}
+
+
+static irqreturn_t ei_interrupt(int irq, void *dev_id)
+{
+	unsigned long reg_int_val;
+	unsigned long reg_int_mask=0;
+	unsigned int recv = 0;
+	unsigned int transmit __maybe_unused = 0;
+	unsigned long flags;
+
+	struct net_device *dev = (struct net_device *) dev_id;
+	END_DEVICE *ei_local = netdev_priv(dev);
+
+	if (dev == NULL)
+	{
+		printk (KERN_ERR "net_interrupt(): irq %x for unknown device.\n", IRQ_ENET0);
+		return IRQ_NONE;
+	}
+
+
+	spin_lock_irqsave(&(ei_local->page_lock), flags);
+	reg_int_val = sysRegRead(RAETH_FE_INT_STATUS);
+
+	if((reg_int_val & RX_DLY_INT))
+		recv = 1;
+	
+	if (reg_int_val & RAETH_TX_DLY_INT)
+		transmit = 1;
+
+	sysRegWrite(RAETH_FE_INT_STATUS, RAETH_FE_INT_DLY_INIT);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08lx\n", "RAETH_FE_INT_STATUS", RAETH_FE_INT_STATUS, RAETH_FE_INT_DLY_INIT);
+
+	ei_xmit_housekeeping(0);
+
+	if (((recv == 1) || (pending_recv ==1)) && (tx_ring_full==0))
+	{
+		reg_int_mask = sysRegRead(RAETH_FE_INT_ENABLE);
+		sysRegWrite(RAETH_FE_INT_ENABLE, reg_int_mask & ~(RX_DLY_INT));
+		if (reg_dbg) printk("-> %s 0x%08x 0x%08lx\n", "RAETH_FE_INT_ENABLE", RAETH_FE_INT_ENABLE, reg_int_mask & ~(RX_DLY_INT));
+		pending_recv=0;
+		schedule_work(&ei_local->rx_wq);
+	} 
+	else if (recv == 1 && tx_ring_full==1) 
+	{
+		pending_recv=1;
+	}
+	spin_unlock_irqrestore(&(ei_local->page_lock), flags);
+
+	return IRQ_HANDLED;
+}
+
+static void esw_link_status_changed(int port_no, void *dev_id)
+{
+    unsigned int reg_val;
+    mii_mgr_read(31, (0x3008 + (port_no*0x100)), &reg_val);
+    if(reg_val & 0x1) {
+	printk("ESW: Link Status Changed - Port%d Link UP\n", port_no);
+    } else {	    
+	printk("ESW: Link Status Changed - Port%d Link Down\n", port_no);
+    }
+}
+
+
+static irqreturn_t esw_interrupt(int irq, void *dev_id)
+{
+	unsigned long flags;
+	unsigned int reg_int_val;
+	struct net_device *dev = (struct net_device *) dev_id;
+	END_DEVICE *ei_local = netdev_priv(dev);
+
+	spin_lock_irqsave(&(ei_local->page_lock), flags);
+        mii_mgr_read(31, 0x700c, &reg_int_val);
+
+	if (reg_int_val & P4_LINK_CH) {
+	    esw_link_status_changed(4, dev_id);
+	}
+
+	if (reg_int_val & P3_LINK_CH) {
+	    esw_link_status_changed(3, dev_id);
+	}
+	if (reg_int_val & P2_LINK_CH) {
+	    esw_link_status_changed(2, dev_id);
+	}
+	if (reg_int_val & P1_LINK_CH) {
+	    esw_link_status_changed(1, dev_id);
+	}
+	if (reg_int_val & P0_LINK_CH) {
+	    esw_link_status_changed(0, dev_id);
+	}
+
+        mii_mgr_write(31, 0x700c, 0x1f); //ack switch link change
+	spin_unlock_irqrestore(&(ei_local->page_lock), flags);
+	return IRQ_HANDLED;
+}
+
+
+
+static int ei_start_xmit_fake(struct sk_buff* skb, struct net_device *dev)
+{
+	return ei_start_xmit(skb, dev, 1);
+}
+
+static int ei_change_mtu(struct net_device *dev, int new_mtu)
+{
+	unsigned long flags;
+	END_DEVICE *ei_local = netdev_priv(dev);  // get priv ei_local pointer from net_dev structure
+
+	if ( ei_local == NULL ) {
+		printk(KERN_EMERG "%s: ei_change_mtu passed a non-existent private pointer from net_dev!\n", dev->name);
+		return -ENXIO;
+	}
+
+	spin_lock_irqsave(&ei_local->page_lock, flags);
+
+	if ( (new_mtu > 4096) || (new_mtu < 64)) {
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+		return -EINVAL;
+	}
+
+	if ( new_mtu > 1500 ) {
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+		return -EINVAL;
+	}
+
+	dev->mtu = new_mtu;
+
+	spin_unlock_irqrestore(&ei_local->page_lock, flags);
+	return 0;
+}
+
+
+static const struct net_device_ops ei_netdev_ops = {
+        .ndo_init               = rather_probe,
+        .ndo_open               = ei_open,
+        .ndo_stop               = ei_close,
+        .ndo_start_xmit         = ei_start_xmit_fake,
+        .ndo_set_mac_address    = eth_mac_addr,
+        .ndo_change_mtu         = ei_change_mtu,
+        .ndo_validate_addr      = eth_validate_addr,
+};
+
+void ra2880_setup_dev_fptable(struct net_device *dev)
+{
+	RAETH_PRINT(__FUNCTION__ "is called!\n");
+
+	dev->netdev_ops		= &ei_netdev_ops;
+#define TX_TIMEOUT (5*HZ)
+	dev->watchdog_timeo = TX_TIMEOUT;
+
+}
+
+void fe_reset(void)
+{
+	u32 val;
+	val = sysRegRead(RSTCTRL);
+
+	val = val | RALINK_FE_RST;
+	sysRegWrite(RSTCTRL, val);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RSTCTRL", RSTCTRL, val);
+	val = val & ~(RALINK_FE_RST);
+	sysRegWrite(RSTCTRL, val);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RSTCTRL", RSTCTRL, val);
+}
+
+void ei_reset_task(struct work_struct *work)
+{
+	struct net_device *dev = dev_raether;
+
+	ei_close(dev);
+	ei_open(dev);
+
+	return;
+}
+
+void ei_tx_timeout(struct net_device *dev)
+{
+        END_DEVICE *ei_local = netdev_priv(dev);
+
+        schedule_work(&ei_local->reset_task);
+}
+
+int __init rather_probe(struct net_device *dev)
+{
+	END_DEVICE *ei_local = netdev_priv(dev);
+	struct sockaddr addr;
+	unsigned char mac_addr01234[5] = {0x00, 0x0C, 0x43, 0x28, 0x80};
+
+	fe_reset();
+	net_srandom(jiffies);
+	memcpy(addr.sa_data, mac_addr01234, 5);
+	addr.sa_data[5] = net_random()&0xFF;
+	ei_set_mac_addr(dev, &addr);
+	spin_lock_init(&ei_local->page_lock);
+	ether_setup(dev);
+
+	return 0;
+}
+
+
+int ei_open(struct net_device *dev)
+{
+	int i, err;
+	unsigned long flags;
+	END_DEVICE *ei_local;
+
+
+	if (!try_module_get(THIS_MODULE))
+	{
+		printk("%s: Cannot reserve module\n", __FUNCTION__);
+		return -1;
+	}
+	printk("Raeth %s (",RAETH_VERSION);
+	printk("Workqueue");
+
+	printk(")\n");
+  	ei_local = netdev_priv(dev); // get device pointer from System
+	// unsigned int flags;
+
+	if (ei_local == NULL)
+	{
+		printk(KERN_EMERG "%s: ei_open passed a non-existent device!\n", dev->name);
+		return -ENXIO;
+	}
+
+        /* receiving packet buffer allocation - NUM_RX_DESC x MAX_RX_LENGTH */
+        for ( i = 0; i < NUM_RX_DESC; i++)
+        {
+                ei_local->netrx0_skbuf[i] = dev_alloc_skb(MAX_RX_LENGTH + NET_IP_ALIGN);
+                if (ei_local->netrx0_skbuf[i] == NULL ) {
+                        printk("rx skbuff buffer allocation failed!");
+		} else {
+		}
+        }
+
+	spin_lock_irqsave(&(ei_local->page_lock), flags);
+        fe_dma_init(dev);
+	fe_sw_init(); //initialize fe and switch register
+	err = request_irq( dev->irq, ei_interrupt, 0, dev->name, dev);	// try to fix irq in open
+	if (err)
+	    return err;
+
+	if ( dev->dev_addr != NULL) {
+	    ra2880MacAddressSet((void *)(dev->dev_addr));
+	} else {
+	    printk("dev->dev_addr is empty !\n");
+	} 
+        mii_mgr_write(31, 0x7008, 0x1f); //enable switch link change intr
+	err = request_irq(31, esw_interrupt, IRQF_DISABLED, "Ralink_ESW", dev);
+	if (err)
+	    return err;
+
+        sysRegWrite(RAETH_DLY_INT_CFG, DELAY_INT_INIT);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RAETH_DLY_INT_CFG", RAETH_DLY_INT_CFG, DELAY_INT_INIT);
+    	sysRegWrite(RAETH_FE_INT_ENABLE, RAETH_FE_INT_DLY_INIT);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08lx\n", "RAETH_FE_INT_ENABLE", RAETH_FE_INT_ENABLE, RAETH_FE_INT_DLY_INIT);
+
+ 	INIT_WORK(&ei_local->reset_task, ei_reset_task);
+
+ 	INIT_WORK(&ei_local->rx_wq, ei_receive_workq);
+
+	netif_start_queue(dev);
+
+
+	spin_unlock_irqrestore(&(ei_local->page_lock), flags);
+
+
+	forward_config(dev);
+	return 0;
+}
+
+int ei_close(struct net_device *dev)
+{
+	int i;
+	END_DEVICE *ei_local = netdev_priv(dev);        // device pointer
+	unsigned long flags;
+	spin_lock_irqsave(&(ei_local->page_lock), flags);
+
+	cancel_work_sync(&ei_local->reset_task);
+	netif_stop_queue(dev);
+	ra2880stop(ei_local);
+	msleep(10);
+
+	cancel_work_sync(&ei_local->rx_wq);
+	free_irq(dev->irq, dev);
+	free_irq(31, dev);
+	for ( i = 0; i < NUM_RX_DESC; i++)
+	{
+		if (ei_local->netrx0_skbuf[i] != NULL) {
+			dev_kfree_skb(ei_local->netrx0_skbuf[i]);
+			ei_local->netrx0_skbuf[i] = NULL;
+		}
+	}
+	if (ei_local->tx_ring0 != NULL) {
+		pci_free_consistent(NULL, NUM_TX_DESC*sizeof(struct PDMA_txdesc), ei_local->tx_ring0, ei_local->phy_tx_ring0);
+	}
+	pci_free_consistent(NULL, NUM_RX_DESC*sizeof(struct PDMA_rxdesc), ei_local->rx_ring0, ei_local->phy_rx_ring0);
+
+	printk("Free TX/RX Ring Memory!\n");
+
+//	fe_reset();
+	spin_unlock_irqrestore(&(ei_local->page_lock), flags);
+
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+
+void setup_internal_gsw(void)
+{
+	u32	i;
+	u32	regValue;
+
+	/* reduce RGMII2 PAD driving strength */
+	*(volatile u_long *)(PAD_RGMII2_MDIO_CFG) &= ~(0x3 << 4);
+
+	//RGMII1=Normal mode
+	*(volatile u_long *)(RALINK_SYSCTL_BASE + 0x60) &= ~(0x1 << 14);
+
+	//GMAC1= RGMII mode
+	*(volatile u_long *)(SYSCFG1) &= ~(0x3 << 12);
+
+	//enable MDIO to control MT7530
+	regValue = le32_to_cpu(*(volatile u_long *)(RALINK_SYSCTL_BASE + 0x60));
+	regValue &= ~(0x3 << 12);
+	*(volatile u_long *)(RALINK_SYSCTL_BASE + 0x60) = regValue;
+
+	for(i=0;i<=4;i++)
+        {
+		//turn off PHY
+               mii_mgr_read(i, 0x0 ,&regValue);
+	       regValue |= (0x1<<11);
+	       mii_mgr_write(i, 0x0, regValue);	
+	}
+        mii_mgr_write(31, 0x7000, 0x3); //reset switch
+        udelay(10);
+
+	if(sysRegRead(0xbe00000c)==0x00030101) {
+		sysRegWrite(RALINK_ETH_SW_BASE+0x100, 0x2005e30b);//(GE1, Force 1000M/FD, FC ON)
+		if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RALINK_ETH_SW_BASE+0x100", RALINK_ETH_SW_BASE+0x100, 0x2005e30b);
+		mii_mgr_write(31, 0x3600, 0x5e30b);
+	} else {
+		sysRegWrite(RALINK_ETH_SW_BASE+0x100, 0x2005e33b);//(GE1, Force 1000M/FD, FC ON)
+		if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RALINK_ETH_SW_BASE+0x100", RALINK_ETH_SW_BASE+0x100, 0x2005e33b);
+		mii_mgr_write(31, 0x3600, 0x5e33b);
+	}
+
+	sysRegWrite(RALINK_ETH_SW_BASE+0x200, 0x00008000);//(GE2, Link down)
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RALINK_ETH_SW_BASE+0x200", RALINK_ETH_SW_BASE+0x200, 0x00008000);
+
+	//regValue = 0x117ccf; //Enable Port 6, P5 as GMAC5, P5 disable*/
+	mii_mgr_read(31, 0x7804 ,&regValue);
+	regValue &= ~(1<<8); //Enable Port 6
+	regValue |= (1<<6); //Disable Port 5
+	regValue |= (1<<13); //Port 5 as GMAC, no Internal PHY
+
+	regValue |= (1<<16);//change HW-TRAP
+	printk("change HW-TRAP to 0x%x!!!!!!!!!!!!",regValue);
+	mii_mgr_write(31, 0x7804 ,regValue);
+	regValue = *(volatile u_long *)(RALINK_SYSCTL_BASE + 0x10);
+	regValue = (regValue >> 6) & 0x7;
+	if(regValue >= 6) { //25Mhz Xtal
+		/* do nothing */
+	} else if(regValue >=3) { //40Mhz
+
+	    mii_mgr_write(0, 13, 0x1f);  // disable MT7530 core clock
+	    mii_mgr_write(0, 14, 0x410);
+	    mii_mgr_write(0, 13, 0x401f);
+	    mii_mgr_write(0, 14, 0x0);
+
+	    mii_mgr_write(0, 13, 0x1f);  // disable MT7530 PLL
+	    mii_mgr_write(0, 14, 0x40d);
+	    mii_mgr_write(0, 13, 0x401f);
+	    mii_mgr_write(0, 14, 0x2020);
+
+	    mii_mgr_write(0, 13, 0x1f);  // for MT7530 core clock = 500Mhz
+	    mii_mgr_write(0, 14, 0x40e);  
+	    mii_mgr_write(0, 13, 0x401f);  
+	    mii_mgr_write(0, 14, 0x119);   
+
+	    mii_mgr_write(0, 13, 0x1f);  // enable MT7530 PLL
+	    mii_mgr_write(0, 14, 0x40d);
+	    mii_mgr_write(0, 13, 0x401f);
+	    mii_mgr_write(0, 14, 0x2820);
+
+	    udelay(20); //suggest by CD
+
+	    mii_mgr_write(0, 13, 0x1f);  // enable MT7530 core clock
+	    mii_mgr_write(0, 14, 0x410);
+	    mii_mgr_write(0, 13, 0x401f);
+	}else { //20Mhz Xtal
+
+		/* TODO */
+
+	}
+	mii_mgr_write(0, 14, 0x1);  /*RGMII*/
+
+#if 1
+	mii_mgr_write(31, 0x7b00, 0x102);  //delay setting for 10/1000M
+	mii_mgr_write(31, 0x7b04, 0x14);  //delay setting for 10/1000M
+#else
+	mii_mgr_write(31, 0x7b00, 8);  // delay setting for 100M
+	mii_mgr_write(31, 0x7b04, 0x14);  // for 100M
+#endif
+	/*Tx Driving*/
+	mii_mgr_write(31, 0x7a54, 0x44);  //lower driving
+	mii_mgr_write(31, 0x7a5c, 0x44);  //lower driving
+	mii_mgr_write(31, 0x7a64, 0x44);  //lower driving
+	mii_mgr_write(31, 0x7a6c, 0x44);  //lower driving
+	mii_mgr_write(31, 0x7a74, 0x44);  //lower driving
+	mii_mgr_write(31, 0x7a7c, 0x44);  //lower driving
+
+	for(i=0;i<=4;i++)
+        {
+	//turn on PHY
+                mii_mgr_read(i, 0x0 ,&regValue);
+	        regValue &= ~(0x1<<11);
+	        mii_mgr_write(i, 0x0, regValue);
+	}
+
+	mii_mgr_read(31, 0x7808 ,&regValue);
+        regValue |= (3<<16); //Enable INTR
+	mii_mgr_write(31, 0x7808 ,regValue);
+}
+
+int __init ra2882eth_init(void)
+{
+	int ret;
+	struct net_device *dev = alloc_etherdev(sizeof(END_DEVICE));
+	if (!dev)
+		return -ENOMEM;
+
+	strcpy(dev->name, DEV_NAME);
+	dev->irq  = IRQ_ENET0;
+	dev->addr_len = 6;
+	dev->base_addr = RALINK_FRAME_ENGINE_BASE;
+
+	rather_probe(dev);
+	ra2880_setup_dev_fptable(dev);
+
+	if ( register_netdev(dev) != 0) {
+		printk(KERN_WARNING " " __FILE__ ": No ethernet port found.\n");
+		return -ENXIO;
+	}
+	ret = 0;
+
+	dev_raether = dev;
+	return ret;
+}
+
+void fe_sw_init(void)
+{
+	setup_internal_gsw();
+}
+
+
+void ra2882eth_cleanup_module(void)
+{
+}
+EXPORT_SYMBOL(set_fe_dma_glo_cfg);
+module_init(ra2882eth_init);
+module_exit(ra2882eth_cleanup_module);
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/raeth/raether.h b/drivers/net/ethernet/raeth/raether.h
new file mode 100644
index 0000000..49326d1
--- /dev/null
+++ b/drivers/net/ethernet/raeth/raether.h
@@ -0,0 +1,92 @@
+#ifndef RA2882ETHEND_H
+#define RA2882ETHEND_H
+
+#ifdef DSP_VIA_NONCACHEABLE
+#define ESRAM_BASE	0xa0800000	/* 0x0080-0000  ~ 0x00807FFF */
+#else
+#define ESRAM_BASE	0x80800000	/* 0x0080-0000  ~ 0x00807FFF */
+#endif
+
+#define RX_RING_BASE	((int)(ESRAM_BASE + 0x7000))
+#define TX_RING_BASE	((int)(ESRAM_BASE + 0x7800))
+
+#if defined(CONFIG_RALINK_RT2880)
+#define NUM_TX_RINGS 	1
+#else
+#define NUM_TX_RINGS 	4
+#endif
+#ifdef MEMORY_OPTIMIZATION
+#ifdef CONFIG_RAETH_ROUTER
+#define NUM_RX_DESC     128
+#define NUM_TX_DESC    	128
+#elif CONFIG_RT_3052_ESW
+#define NUM_RX_DESC     64
+#define NUM_TX_DESC     64
+#else
+#define NUM_RX_DESC     128
+#define NUM_TX_DESC     128
+#endif
+//#define NUM_RX_MAX_PROCESS 32
+#define NUM_RX_MAX_PROCESS 64
+#else
+#if defined (CONFIG_RAETH_ROUTER)
+#define NUM_RX_DESC     256
+#define NUM_TX_DESC    	256
+#elif defined (CONFIG_RT_3052_ESW)
+#define NUM_RX_DESC     256
+#define NUM_TX_DESC     256
+#else
+#define NUM_RX_DESC     256
+#define NUM_TX_DESC     256
+#endif
+#if defined(CONFIG_RALINK_RT3883) || defined(CONFIG_RALINK_MT7620) 
+#define NUM_RX_MAX_PROCESS 2
+#else
+#define NUM_RX_MAX_PROCESS 16
+#endif
+#endif
+
+#define DEV_NAME        "eth0"
+#define DEV2_NAME       "eth3"
+
+#if defined (CONFIG_RALINK_RT6855A) || defined (CONFIG_RALINK_MT7621)
+#define GMAC0_OFFSET    0xE000
+#define GMAC2_OFFSET    0xE006
+#else
+#define GMAC0_OFFSET    0x28 
+#define GMAC2_OFFSET    0x22
+#endif
+
+#if defined(CONFIG_RALINK_RT6855A)
+#define IRQ_ENET0	22
+#else
+#define IRQ_ENET0	11 	/* hardware interrupt #3, defined in RT2880 Soc Design Spec Rev 0.03, pp43 */
+#endif
+
+#define FE_INT_STATUS_REG (*(volatile unsigned long *)(FE_INT_STATUS))
+#define FE_INT_STATUS_CLEAN(reg) (*(volatile unsigned long *)(FE_INT_STATUS)) = reg
+
+//#define RAETH_DEBUG
+#ifdef RAETH_DEBUG
+#define RAETH_PRINT(fmt, args...) printk(KERN_INFO fmt, ## args)
+#else
+#define RAETH_PRINT(fmt, args...) { }
+#endif
+
+struct net_device_stats *ra_get_stats(struct net_device *dev);
+
+void ei_tx_timeout(struct net_device *dev);
+int rather_probe(struct net_device *dev);
+int ei_open(struct net_device *dev);
+int ei_close(struct net_device *dev);
+
+int ra2882eth_init(void);
+void ra2882eth_cleanup_module(void);
+
+void ei_xmit_housekeeping(unsigned long data);
+
+u32 mii_mgr_read(u32 phy_addr, u32 phy_register, u32 *read_data);
+u32 mii_mgr_write(u32 phy_addr, u32 phy_register, u32 write_data);
+void fe_sw_init(void);
+
+#endif
diff --git a/drivers/net/ethernet/raeth/raether_pdma.c b/drivers/net/ethernet/raeth/raether_pdma.c
new file mode 100644
index 0000000..4f1b154
--- /dev/null
+++ b/drivers/net/ethernet/raeth/raether_pdma.c
@@ -0,0 +1,212 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/if_ether.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <asm/rt2880/rt_mmap.h>
+#include "ra2882ethreg.h"
+#include "raether.h"
+#include "ra_mac.h"
+
+#define	MAX_RX_LENGTH	1536
+
+extern int reg_dbg;
+extern struct net_device		*dev_raether;
+static unsigned long tx_ring_full=0;
+
+#define KSEG1                   0xa0000000
+#define PHYS_TO_VIRT(x)         ((void *)((x) | KSEG1))
+#define VIRT_TO_PHYS(x)         ((unsigned long)(x) & ~KSEG1)
+
+extern void set_fe_dma_glo_cfg(void);
+
+int fe_dma_init(struct net_device *dev)
+{
+
+	int		i;
+	unsigned int	regVal;
+	END_DEVICE* ei_local = netdev_priv(dev);
+
+	while(1)
+	{
+		regVal = sysRegRead(PDMA_GLO_CFG);
+		if((regVal & RX_DMA_BUSY))
+		{
+			printk("\n  RX_DMA_BUSY !!! ");
+			continue;
+		}
+		if((regVal & TX_DMA_BUSY))
+		{
+			printk("\n  TX_DMA_BUSY !!! ");
+			continue;
+		}
+		break;
+	}
+
+	for (i=0;i<NUM_TX_DESC;i++){
+		ei_local->skb_free[i]=0;
+	}
+	ei_local->free_idx =0;
+	ei_local->tx_ring0 = pci_alloc_consistent(NULL, NUM_TX_DESC * sizeof(struct PDMA_txdesc), &ei_local->phy_tx_ring0);
+	printk("\nphy_tx_ring = 0x%08x, tx_ring = 0x%p\n", ei_local->phy_tx_ring0, ei_local->tx_ring0);
+
+	for (i=0; i < NUM_TX_DESC; i++) {
+		memset(&ei_local->tx_ring0[i],0,sizeof(struct PDMA_txdesc));
+		ei_local->tx_ring0[i].txd_info2.LS0_bit = 1;
+		ei_local->tx_ring0[i].txd_info2.DDONE_bit = 1;
+
+	}
+
+	/* Initial RX Ring 0*/
+	ei_local->rx_ring0 = pci_alloc_consistent(NULL, NUM_RX_DESC * sizeof(struct PDMA_rxdesc), &ei_local->phy_rx_ring0);
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		memset(&ei_local->rx_ring0[i],0,sizeof(struct PDMA_rxdesc));
+		ei_local->rx_ring0[i].rxd_info2.DDONE_bit = 0;
+		ei_local->rx_ring0[i].rxd_info2.LS0 = 0;
+		ei_local->rx_ring0[i].rxd_info2.PLEN0 = MAX_RX_LENGTH;
+		ei_local->rx_ring0[i].rxd_info1.PDP0 = dma_map_single(NULL, ei_local->netrx0_skbuf[i]->data, MAX_RX_LENGTH, PCI_DMA_FROMDEVICE);
+	}
+	printk("\nphy_rx_ring0 = 0x%08x, rx_ring0 = 0x%p\n",ei_local->phy_rx_ring0,ei_local->rx_ring0);
+
+
+	regVal = sysRegRead(PDMA_GLO_CFG);
+	regVal &= 0x000000FF;
+	sysRegWrite(PDMA_GLO_CFG, regVal);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "PDMA_GLO_CFG", PDMA_GLO_CFG, regVal);
+
+	regVal=sysRegRead(PDMA_GLO_CFG);
+
+	/* Tell the adapter where the TX/RX rings are located. */
+        sysRegWrite(TX_BASE_PTR0, phys_to_bus((u32) ei_local->phy_tx_ring0));
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "TX_BASE_PTR0", TX_BASE_PTR0, phys_to_bus((u32) ei_local->phy_tx_ring0));
+	sysRegWrite(TX_MAX_CNT0, cpu_to_le32((u32) NUM_TX_DESC));
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "TX_MAX_CNT0", TX_MAX_CNT0, cpu_to_le32((u32) NUM_TX_DESC));
+	sysRegWrite(TX_CTX_IDX0, 0);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "TX_CTX_IDX0", TX_CTX_IDX0, 0);
+	sysRegWrite(PDMA_RST_CFG, PST_DTX_IDX0);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08lx\n", "PDMA_RST_CFG", PDMA_RST_CFG, PST_DTX_IDX0);
+
+	sysRegWrite(RX_BASE_PTR0, phys_to_bus((u32) ei_local->phy_rx_ring0));
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RX_BASE_PTR0", RX_BASE_PTR0, phys_to_bus((u32) ei_local->phy_rx_ring0));
+	sysRegWrite(RX_MAX_CNT0,  cpu_to_le32((u32) NUM_RX_DESC));
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RX_MAX_CNT0", RX_MAX_CNT0, cpu_to_le32((u32) NUM_RX_DESC));
+	sysRegWrite(RX_CALC_IDX0, cpu_to_le32((u32) (NUM_RX_DESC - 1)));
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08x\n", "RX_CALC_IDX0", RX_CALC_IDX0, cpu_to_le32((u32) (NUM_RX_DESC - 1)));
+	sysRegWrite(PDMA_RST_CFG, PST_DRX_IDX0);
+	if (reg_dbg) printk("-> %s 0x%08x 0x%08lx\n", "PDMA_RST_CFG", PDMA_RST_CFG, PST_DRX_IDX0);
+
+	set_fe_dma_glo_cfg();
+
+	return 1;
+}
+
+inline int rt2880_eth_send(struct net_device* dev, struct sk_buff *skb, int gmac_no)
+{
+	unsigned int	length=skb->len;
+	END_DEVICE*	ei_local = netdev_priv(dev);
+	unsigned long	tx_cpu_owner_idx0 = sysRegRead(TX_CTX_IDX0);
+
+	while(ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info2.DDONE_bit == 0)
+	{
+			ei_local->stat.tx_errors++;
+	}
+
+	ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info1.SDP0 = virt_to_phys(skb->data);
+	ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info2.SDL0 = length;
+	if (gmac_no == 1) {
+		ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info4.FPORT = 1;
+	}else {
+		ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info4.FPORT = 2;
+	}
+	ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info2.DDONE_bit = 0;
+	tx_cpu_owner_idx0 = (tx_cpu_owner_idx0+1) % NUM_TX_DESC;
+	while(ei_local->tx_ring0[tx_cpu_owner_idx0].txd_info2.DDONE_bit == 0)
+	{
+		ei_local->stat.tx_errors++;
+	}
+	sysRegWrite(TX_CTX_IDX0, cpu_to_le32((u32)tx_cpu_owner_idx0));
+
+	{
+		ei_local->stat.tx_packets++;
+		ei_local->stat.tx_bytes += length;
+	}
+
+	return length;
+}
+
+int ei_start_xmit(struct sk_buff* skb, struct net_device *dev, int gmac_no)
+{
+	END_DEVICE *ei_local = netdev_priv(dev);
+	unsigned long flags;
+	unsigned long tx_cpu_owner_idx;
+	unsigned int tx_cpu_owner_idx_next;
+	unsigned int num_of_txd;
+	unsigned int tx_cpu_owner_idx_next2;
+
+	dev->trans_start = jiffies;	/* save the timestamp */
+	spin_lock_irqsave(&ei_local->page_lock, flags);
+	dma_cache_sync(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+
+	tx_cpu_owner_idx = sysRegRead(TX_CTX_IDX0);
+	num_of_txd = 1;
+	tx_cpu_owner_idx_next = (tx_cpu_owner_idx + num_of_txd) % NUM_TX_DESC;
+
+	if(((ei_local->skb_free[tx_cpu_owner_idx]) ==0) && (ei_local->skb_free[tx_cpu_owner_idx_next]==0)){
+		rt2880_eth_send(dev, skb, gmac_no);
+
+		tx_cpu_owner_idx_next2 = (tx_cpu_owner_idx_next + 1) % NUM_TX_DESC;
+
+		if(ei_local->skb_free[tx_cpu_owner_idx_next2]!=0){
+		}
+	}else {
+			ei_local->stat.tx_dropped++;
+		kfree_skb(skb);
+		spin_unlock_irqrestore(&ei_local->page_lock, flags);
+		return 0;
+	}
+
+	ei_local->skb_free[tx_cpu_owner_idx] = skb;
+	spin_unlock_irqrestore(&ei_local->page_lock, flags);
+	return 0;
+}
+
+void ei_xmit_housekeeping(unsigned long unused)
+{
+    struct net_device *dev = dev_raether;
+    END_DEVICE *ei_local = netdev_priv(dev);
+    struct PDMA_txdesc *tx_desc;
+    unsigned long skb_free_idx;
+    unsigned long tx_dtx_idx __maybe_unused;
+    unsigned long reg_int_mask=0;
+
+	tx_dtx_idx = sysRegRead(TX_DTX_IDX0);
+	tx_desc = ei_local->tx_ring0;
+	skb_free_idx = ei_local->free_idx;
+	if ((ei_local->skb_free[skb_free_idx]) != 0 && tx_desc[skb_free_idx].txd_info2.DDONE_bit==1) {
+		while(tx_desc[skb_free_idx].txd_info2.DDONE_bit==1 && (ei_local->skb_free[skb_free_idx])!=0 ){
+	    dev_kfree_skb_any(ei_local->skb_free[skb_free_idx]);
+	    ei_local->skb_free[skb_free_idx]=0;
+	    skb_free_idx = (skb_free_idx +1) % NUM_TX_DESC;
+	}
+
+	netif_wake_queue(dev);
+		tx_ring_full=0;
+		ei_local->free_idx = skb_free_idx;
+	}
+
+    reg_int_mask=sysRegRead(FE_INT_ENABLE);
+    sysRegWrite(FE_INT_ENABLE, reg_int_mask| TX_DLY_INT);
+}
+
+EXPORT_SYMBOL(ei_start_xmit);
+EXPORT_SYMBOL(ei_xmit_housekeeping);
+EXPORT_SYMBOL(fe_dma_init);
+EXPORT_SYMBOL(rt2880_eth_send);
diff --git a/drivers/net/ethernet/raeth/raether_qdma.c b/drivers/net/ethernet/raeth/raether_qdma.c
new file mode 100644
index 0000000..4ad2f42
--- /dev/null
+++ b/drivers/net/ethernet/raeth/raether_qdma.c
@@ -0,0 +1,805 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/if_ether.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/rt2880/surfboardint.h>
+#if defined (CONFIG_RAETH_TSO)
+#include <linux/tcp.h>
+#include <net/ipv6.h>
+#include <linux/ip.h>
+#include <net/ip.h>
+#include <net/tcp.h>
+#include <linux/in.h>
+#include <linux/ppp_defs.h>
+#include <linux/if_pppox.h>
+#endif
+#include <linux/delay.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35)
+#include <linux/sched.h>
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+#include <asm/rt2880/rt_mmap.h>
+#else
+#include <linux/libata-compat.h>
+#endif
+ 
+#include "ra2882ethreg.h"
+#include "raether.h"
+#include "ra_mac.h"
+#include "ra_ioctl.h"
+#include "ra_rfrw.h"
+#ifdef CONFIG_RAETH_NETLINK
+#include "ra_netlink.h"
+#endif
+#if defined (CONFIG_RAETH_QOS)
+#include "ra_qos.h"
+#endif
+
+#if defined (CONFIG_RA_HW_NAT) || defined (CONFIG_RA_HW_NAT_MODULE)
+#include "../../../net/nat/hw_nat/ra_nat.h"
+#endif
+
+#if defined (TASKLET_WORKQUEUE_SW)
+int init_schedule;
+int working_schedule;
+#endif
+
+
+#if !defined(CONFIG_RA_NAT_NONE)
+/* bruce+
+ */
+extern int (*ra_sw_nat_hook_rx)(struct sk_buff *skb);
+extern int (*ra_sw_nat_hook_tx)(struct sk_buff *skb, int gmac_no);
+#endif
+
+#if defined(CONFIG_RA_CLASSIFIER)||defined(CONFIG_RA_CLASSIFIER_MODULE)
+/* Qwert+
+ */
+#include <asm/mipsregs.h>
+extern int (*ra_classifier_hook_tx)(struct sk_buff *skb, unsigned long cur_cycle);
+extern int (*ra_classifier_hook_rx)(struct sk_buff *skb, unsigned long cur_cycle);
+#endif /* CONFIG_RA_CLASSIFIER */
+
+#if defined (CONFIG_RALINK_RT3052_MP2)
+int32_t mcast_rx(struct sk_buff * skb);
+int32_t mcast_tx(struct sk_buff * skb);
+#endif
+
+#ifdef RA_MTD_RW_BY_NUM
+int ra_mtd_read(int num, loff_t from, size_t len, u_char *buf);
+#else
+int ra_mtd_read_nm(char *name, loff_t from, size_t len, u_char *buf);
+#endif
+
+/* gmac driver feature set config */
+#if defined (CONFIG_RAETH_NAPI) || defined (CONFIG_RAETH_QOS)
+#undef DELAY_INT
+#else
+#define DELAY_INT	1
+#endif
+
+//#define CONFIG_UNH_TEST
+/* end of config */
+
+#if defined (CONFIG_RAETH_JUMBOFRAME)
+#define	MAX_RX_LENGTH	4096
+#else
+#define	MAX_RX_LENGTH	1536
+#endif
+
+extern struct net_device		*dev_raether;
+
+#if defined (CONFIG_RAETH_MULTIPLE_RX_RING)
+static int rx_dma_owner_idx1;
+#ifdef CONFIG_RAETH_RW_PDMAPTR_FROM_VAR
+static int rx_calc_idx1;
+#endif
+#endif
+#ifdef CONFIG_RAETH_RW_PDMAPTR_FROM_VAR
+static int rx_calc_idx0;
+static unsigned long tx_cpu_owner_idx0=0;
+#endif
+static unsigned long tx_ring_full=0;
+
+#if defined (CONFIG_ETHTOOL) && defined (CONFIG_RAETH_ROUTER)
+#include "ra_ethtool.h"
+extern struct ethtool_ops	ra_ethtool_ops;
+#ifdef CONFIG_PSEUDO_SUPPORT
+extern struct ethtool_ops	ra_virt_ethtool_ops;
+#endif // CONFIG_PSEUDO_SUPPORT //
+#endif // (CONFIG_ETHTOOL //
+
+#ifdef CONFIG_RALINK_VISTA_BASIC
+int is_switch_175c = 1;
+#endif
+
+//skb->mark to queue mapping table
+extern unsigned int M2Q_table[64];
+
+
+#define KSEG1                   0xa0000000
+#define PHYS_TO_VIRT(x)         ((void *)((x) | KSEG1))
+#define VIRT_TO_PHYS(x)         ((unsigned long)(x) & ~KSEG1)
+
+extern void set_fe_dma_glo_cfg(void);
+
+
+/**
+ *
+ * @brief: get the TXD index from its address
+ *
+ * @param: cpu_ptr
+ *
+ * @return: TXD index
+*/
+
+static unsigned int GET_TXD_OFFSET(struct QDMA_txdesc **cpu_ptr)
+{
+	struct net_device *dev = dev_raether;
+	END_DEVICE *ei_local = netdev_priv(dev);
+	int ctx_offset;
+  	ctx_offset = (((((u32)*cpu_ptr) <<8)>>8) - ((((u32)ei_local->txd_pool)<<8)>>8))/ sizeof(struct QDMA_txdesc);
+	ctx_offset = (*cpu_ptr - ei_local->txd_pool);
+
+  	return ctx_offset;
+} 
+
+
+
+/**
+ * @brief get free TXD from TXD queue
+ *
+ * @param free_txd
+ *
+ * @return 
+ */
+static int get_free_txd(struct QDMA_txdesc **free_txd)
+{
+	struct net_device *dev = dev_raether;
+	END_DEVICE *ei_local = netdev_priv(dev);
+	unsigned int tmp_idx;
+
+	if(ei_local->free_txd_num > 0){
+		tmp_idx = ei_local->free_txd_head;
+		ei_local->free_txd_head = ei_local->txd_pool_info[tmp_idx];
+		ei_local->free_txd_num -= 1;
+		*free_txd = &ei_local->txd_pool[tmp_idx];
+		return tmp_idx;
+	}else
+		return NUM_TX_DESC;	
+}
+
+
+/**
+ * @brief add free TXD into TXD queue
+ *
+ * @param free_txd
+ *
+ * @return 
+ */
+int put_free_txd(int free_txd_idx)
+{
+	struct net_device *dev = dev_raether;
+	END_DEVICE *ei_local = netdev_priv(dev);
+	ei_local->txd_pool_info[ei_local->free_txd_tail] = free_txd_idx;
+	ei_local->free_txd_tail = free_txd_idx;
+	ei_local->txd_pool_info[free_txd_idx] = NUM_TX_DESC;
+        ei_local->free_txd_num += 1;
+	return 1;
+}
+
+/*define qdma initial alloc*/
+/**
+ * @brief 
+ *
+ * @param net_dev
+ *
+ * @return  0: fail
+ *	    1: success
+ */
+bool qdma_tx_desc_alloc(void)
+{
+	struct net_device *dev = dev_raether;
+	END_DEVICE *ei_local = netdev_priv(dev);
+	struct QDMA_txdesc *free_txd = NULL;
+	unsigned int txd_idx;
+	int i = 0;
+
+
+	ei_local->txd_pool = pci_alloc_consistent(NULL, sizeof(struct QDMA_txdesc) * NUM_TX_DESC, &ei_local->phy_txd_pool);
+	printk("txd_pool=%p phy_txd_pool=%08X\n", ei_local->txd_pool , ei_local->phy_txd_pool);
+
+	if (ei_local->txd_pool == NULL) {
+		printk("adapter->txd_pool allocation failed!\n");
+		return 0;
+	}
+	printk("ei_local->skb_free start address is 0x%p.\n", ei_local->skb_free);
+	//set all txd_pool_info to 0.
+	for ( i = 0; i < NUM_TX_DESC; i++)
+	{
+		ei_local->skb_free[i]= 0;
+		ei_local->txd_pool_info[i] = i + 1;
+		ei_local->txd_pool[i].txd_info3.LS_bit = 1;
+		ei_local->txd_pool[i].txd_info3.OWN_bit = 1;
+	}
+
+	ei_local->free_txd_head = 0;
+	ei_local->free_txd_tail = NUM_TX_DESC - 1;
+	ei_local->free_txd_num = NUM_TX_DESC;
+	
+
+	//get free txd from txd pool
+	txd_idx = get_free_txd(&free_txd);
+	if( txd_idx == NUM_TX_DESC) {
+		printk("get_free_txd fail\n");
+		return 0;
+	}
+	
+	//add null TXD for transmit
+	ei_local->tx_dma_ptr = VIRT_TO_PHYS(free_txd);
+	ei_local->tx_cpu_ptr = VIRT_TO_PHYS(free_txd);
+	sysRegWrite(QTX_CTX_PTR, ei_local->tx_cpu_ptr);
+	sysRegWrite(QTX_DTX_PTR, ei_local->tx_dma_ptr);
+	
+	//get free txd from txd pool
+
+	txd_idx = get_free_txd(&free_txd);
+	if( txd_idx == NUM_TX_DESC) {
+		printk("get_free_txd fail\n");
+		return 0;
+	}
+	// add null TXD for release
+	sysRegWrite(QTX_CRX_PTR, VIRT_TO_PHYS(free_txd));
+	sysRegWrite(QTX_DRX_PTR, VIRT_TO_PHYS(free_txd));
+	
+	printk("free_txd: %p, ei_local->cpu_ptr: %08X\n", free_txd, ei_local->tx_cpu_ptr);
+	
+	printk(" POOL  HEAD_PTR | DMA_PTR | CPU_PTR \n");
+	printk("----------------+---------+--------\n");
+#if 1
+	printk("     0x%p 0x%08X 0x%08X\n",ei_local->txd_pool,
+			ei_local->tx_dma_ptr, ei_local->tx_cpu_ptr);
+#endif
+	return 1;
+}
+
+bool fq_qdma_init(void)
+{
+	struct QDMA_txdesc *free_head = NULL;
+	unsigned int free_head_phy;
+	unsigned int free_tail_phy;
+	unsigned int *free_page_head = NULL;
+	unsigned int free_page_head_phy;
+	int i;
+    
+	free_head = pci_alloc_consistent(NULL, NUM_QDMA_PAGE * sizeof(struct QDMA_txdesc), &free_head_phy);
+	if (unlikely(free_head == NULL)){
+		printk(KERN_ERR "QDMA FQ decriptor not available...\n");
+		return 0;
+	}
+	memset(free_head, 0x0, sizeof(struct QDMA_txdesc) * NUM_QDMA_PAGE);
+
+	free_page_head = pci_alloc_consistent(NULL, NUM_QDMA_PAGE * QDMA_PAGE_SIZE, &free_page_head_phy);
+	if (unlikely(free_page_head == NULL)){
+		printk(KERN_ERR "QDMA FQ pager not available...\n");
+		return 0;
+	}	
+	for (i=0; i < NUM_QDMA_PAGE; i++) {
+		free_head[i].txd_info1.SDP = (free_page_head_phy + (i * QDMA_PAGE_SIZE));
+		if(i < (NUM_QDMA_PAGE-1)){
+			free_head[i].txd_info2.NDP = (free_head_phy + ((i+1) * sizeof(struct QDMA_txdesc)));
+
+
+#if 0
+			printk("free_head_phy[%d] is 0x%x!!!\n",i, VIRT_TO_PHYS(&free_head[i]) );
+			printk("free_head[%d] is 0x%x!!!\n",i, &free_head[i] );
+			printk("free_head[%d].txd_info1.SDP is 0x%x!!!\n",i, free_head[i].txd_info1.SDP );
+			printk("free_head[%d].txd_info2.NDP is 0x%x!!!\n",i, free_head[i].txd_info2.NDP );
+#endif
+		}
+		free_head[i].txd_info3.SDL = QDMA_PAGE_SIZE;
+
+	}
+	free_tail_phy = (free_head_phy + (u32)((NUM_QDMA_PAGE-1) * sizeof(struct QDMA_txdesc)));
+
+	printk("free_head_phy is 0x%x!!!\n", free_head_phy);
+	printk("free_tail_phy is 0x%x!!!\n", free_tail_phy);
+	sysRegWrite(QDMA_FQ_HEAD, (u32)free_head_phy);
+	sysRegWrite(QDMA_FQ_TAIL, (u32)free_tail_phy);
+	sysRegWrite(QDMA_FQ_CNT, ((NUM_TX_DESC << 16) | NUM_QDMA_PAGE));
+	sysRegWrite(QDMA_FQ_BLEN, QDMA_PAGE_SIZE << 16);
+    return 1;
+}
+
+int fe_dma_init(struct net_device *dev)
+{
+
+	int i;
+	unsigned int	regVal;
+	END_DEVICE* ei_local = netdev_priv(dev);
+
+	fq_qdma_init();
+
+	while(1)
+	{
+		regVal = sysRegRead(QDMA_GLO_CFG);
+		if((regVal & RX_DMA_BUSY))
+		{
+			printk("\n  RX_DMA_BUSY !!! ");
+			continue;
+		}
+		if((regVal & TX_DMA_BUSY))
+		{
+			printk("\n  TX_DMA_BUSY !!! ");
+			continue;
+		}
+		break;
+	}
+	/*tx desc alloc, add a NULL TXD to HW*/
+
+	qdma_tx_desc_alloc();
+
+
+	/* Initial RX Ring 0*/
+#ifdef CONFIG_32B_DESC
+    	ei_local->rx_ring0 = kmalloc(NUM_RX_DESC * sizeof(struct PDMA_rxdesc), GFP_KERNEL);
+	ei_local->phy_rx_ring0 = virt_to_phys(ei_local->rx_ring0);
+#else
+	ei_local->rx_ring0 = pci_alloc_consistent(NULL, NUM_RX_DESC * sizeof(struct PDMA_rxdesc), &ei_local->phy_rx_ring0);
+#endif
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		memset(&ei_local->rx_ring0[i],0,sizeof(struct PDMA_rxdesc));
+	    	ei_local->rx_ring0[i].rxd_info2.DDONE_bit = 0;
+#if defined (CONFIG_RAETH_SCATTER_GATHER_RX_DMA)
+		ei_local->rx_ring0[i].rxd_info2.LS0 = 0;
+		ei_local->rx_ring0[i].rxd_info2.PLEN0 = MAX_RX_LENGTH;
+#else
+		ei_local->rx_ring0[i].rxd_info2.LS0 = 1;
+#endif
+		ei_local->rx_ring0[i].rxd_info1.PDP0 = dma_map_single(NULL, ei_local->netrx0_skbuf[i]->data, MAX_RX_LENGTH, PCI_DMA_FROMDEVICE);
+	}
+	printk("\nphy_rx_ring0 = 0x%08x, rx_ring0 = 0x%p\n",ei_local->phy_rx_ring0,ei_local->rx_ring0);
+
+#if defined (CONFIG_RAETH_MULTIPLE_RX_RING)
+	/* Initial RX Ring 1*/
+#ifdef CONFIG_32B_DESC
+    	ei_local->rx_ring1 = kmalloc(NUM_RX_DESC * sizeof(struct PDMA_rxdesc), GFP_KERNEL);
+	ei_local->phy_rx_ring1 = virt_to_phys(ei_local->rx_ring1);
+#else
+	ei_local->rx_ring1 = pci_alloc_consistent(NULL, NUM_RX_DESC * sizeof(struct PDMA_rxdesc), &ei_local->phy_rx_ring1);
+#endif
+	for (i = 0; i < NUM_RX_DESC; i++) {
+		memset(&ei_local->rx_ring1[i],0,sizeof(struct PDMA_rxdesc));
+	    	ei_local->rx_ring1[i].rxd_info2.DDONE_bit = 0;
+#if defined (CONFIG_RAETH_SCATTER_GATHER_RX_DMA)
+		ei_local->rx_ring0[i].rxd_info2.LS0 = 0;
+		ei_local->rx_ring0[i].rxd_info2.PLEN0 = MAX_RX_LENGTH;
+#else
+		ei_local->rx_ring1[i].rxd_info2.LS0 = 1;
+#endif
+		ei_local->rx_ring1[i].rxd_info1.PDP0 = dma_map_single(NULL, ei_local->netrx1_skbuf[i]->data, MAX_RX_LENGTH, PCI_DMA_FROMDEVICE);
+	}
+	printk("\nphy_rx_ring1 = 0x%08x, rx_ring1 = 0x%p\n",ei_local->phy_rx_ring1,ei_local->rx_ring1);
+#endif
+
+	regVal = sysRegRead(QDMA_GLO_CFG);
+	regVal &= 0x000000FF;
+   	sysRegWrite(QDMA_GLO_CFG, regVal);
+	regVal=sysRegRead(QDMA_GLO_CFG);
+
+	/* Tell the adapter where the TX/RX rings are located. */
+	
+	sysRegWrite(QRX_BASE_PTR_0, phys_to_bus((u32) ei_local->phy_rx_ring0));
+	sysRegWrite(QRX_MAX_CNT_0,  cpu_to_le32((u32) NUM_RX_DESC));
+	sysRegWrite(QRX_CRX_IDX_0, cpu_to_le32((u32) (NUM_RX_DESC - 1)));
+#ifdef CONFIG_RAETH_RW_PDMAPTR_FROM_VAR
+	rx_calc_idx0 = rx_dma_owner_idx0 =  sysRegRead(QRX_CRX_IDX_0);
+#endif
+	sysRegWrite(QDMA_RST_CFG, PST_DRX_IDX0);
+#if defined (CONFIG_RAETH_MULTIPLE_RX_RING)
+	sysRegWrite(QRX_BASE_PTR_1, phys_to_bus((u32) ei_local->phy_rx_ring1));
+	sysRegWrite(QRX_MAX_CNT_1,  cpu_to_le32((u32) NUM_RX_DESC));
+	sysRegWrite(QRX_CRX_IDX_1, cpu_to_le32((u32) (NUM_RX_DESC - 1)));
+#ifdef CONFIG_RAETH_RW_PDMAPTR_FROM_VAR
+	rx_calc_idx1 = rx_dma_owner_idx1 =  sysRegRead(QRX_CRX_IDX_1);
+#endif
+	sysRegWrite(QDMA_RST_CFG, PST_DRX_IDX1);
+#endif
+
+	set_fe_dma_glo_cfg();
+	
+	return 1;
+}
+
+inline int rt2880_eth_send(struct net_device* dev, struct sk_buff *skb, int gmac_no)
+{
+	unsigned int	length=skb->len;
+	END_DEVICE*	ei_local = netdev_priv(dev);
+	
+	struct QDMA_txdesc *cpu_ptr;
+
+	struct QDMA_txdesc *dma_ptr __maybe_unused;
+	struct QDMA_txdesc *free_txd;
+	int  ctx_offset;
+#if defined (CONFIG_RAETH_TSO)
+	struct iphdr *iph = NULL;
+        struct QDMA_txdesc *init_cpu_ptr;
+        struct tcphdr *th = NULL;
+	struct skb_frag_struct *frag;
+	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+	int i=0;
+	int init_txd_idx;
+#endif // CONFIG_RAETH_TSO //
+
+#if defined (CONFIG_RAETH_TSOV6)
+	struct ipv6hdr *ip6h = NULL;
+#endif
+
+#ifdef CONFIG_PSEUDO_SUPPORT
+	PSEUDO_ADAPTER *pAd;
+#endif
+	cpu_ptr = PHYS_TO_VIRT(ei_local->tx_cpu_ptr);
+	dma_ptr = PHYS_TO_VIRT(ei_local->tx_dma_ptr);
+	ctx_offset = GET_TXD_OFFSET(&cpu_ptr);
+	ei_local->skb_free[ctx_offset] = skb;
+#if defined (CONFIG_RAETH_TSO)
+        init_cpu_ptr = cpu_ptr;
+        init_txd_idx = ctx_offset;
+#endif
+
+#if !defined (CONFIG_RAETH_TSO)
+
+	//2. prepare data
+	cpu_ptr->txd_info1.SDP = VIRT_TO_PHYS(skb->data);
+	cpu_ptr->txd_info3.SDL = skb->len;
+	
+	if (gmac_no == 1) {
+		cpu_ptr->txd_info4.FPORT = 1;
+	}else {
+		cpu_ptr->txd_info4.FPORT = 2;
+	}
+
+
+  cpu_ptr->txd_info3.QID = M2Q_table[skb->mark];
+#if 0 
+	iph = (struct iphdr *)skb_network_header(skb);
+        if (iph->tos == 0xe0)
+		cpu_ptr->txd_info3.QID = 3;
+	else if (iph->tos == 0xa0) 
+		cpu_ptr->txd_info3.QID = 2;	
+        else if (iph->tos == 0x20)
+		cpu_ptr->txd_info3.QID = 1;
+        else 
+		cpu_ptr->txd_info3.QID = 0;
+#endif
+
+#if defined (CONFIG_RAETH_CHECKSUM_OFFLOAD) && ! defined(CONFIG_RALINK_RT5350) && !defined (CONFIG_RALINK_MT7628)
+	if (skb->ip_summed == CHECKSUM_PARTIAL){
+	    cpu_ptr->txd_info4.TUI_CO = 7;
+	}else {
+	    cpu_ptr->txd_info4.TUI_CO = 0;
+	}
+#endif
+
+#ifdef CONFIG_RAETH_HW_VLAN_TX
+	if(vlan_tx_tag_present(skb)) {
+	    cpu_ptr->txd_info4.VLAN_TAG = 0x10000 | vlan_tx_tag_get(skb);
+	}else {
+	    cpu_ptr->txd_info4.VLAN_TAG = 0;
+	}
+#endif
+
+#if defined (CONFIG_RA_HW_NAT) || defined (CONFIG_RA_HW_NAT_MODULE)
+	if(FOE_MAGIC_TAG(skb) == FOE_MAGIC_PPE) {
+		if(ra_sw_nat_hook_rx!= NULL){
+		    cpu_ptr->txd_info4.FPORT = 4; /* PPE */
+		    FOE_MAGIC_TAG(skb) = 0;
+	    }
+  }
+#endif
+#if 0
+	cpu_ptr->txd_info4.FPORT = 4; /* PPE */
+	cpu_ptr->txd_info4.UDF = 0x2F;
+#endif
+		
+	dma_cache_sync(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+	cpu_ptr->txd_info3.SWC_bit = 1;
+
+	//3. get NULL TXD and decrease free_tx_num by 1.
+	ctx_offset = get_free_txd(&free_txd);
+	if(ctx_offset == NUM_TX_DESC) {
+	    printk("get_free_txd fail\n"); // this should not happen. free_txd_num is 2 at least.
+	    return 0;
+	}
+
+	//4. hook new TXD in the end of queue
+	cpu_ptr->txd_info2.NDP = VIRT_TO_PHYS(free_txd);
+
+
+	//5. move CPU_PTR to new TXD
+	ei_local->tx_cpu_ptr = VIRT_TO_PHYS(free_txd);	
+	cpu_ptr->txd_info3.OWN_bit = 0;
+	sysRegWrite(QTX_CTX_PTR, ei_local->tx_cpu_ptr);
+	
+#if 0 
+	printk("----------------------------------------------\n");
+	printk("txd_info1:%08X \n",*(int *)&cpu_ptr->txd_info1);
+	printk("txd_info2:%08X \n",*(int *)&cpu_ptr->txd_info2);
+	printk("txd_info3:%08X \n",*(int *)&cpu_ptr->txd_info3);
+	printk("txd_info4:%08X \n",*(int *)&cpu_ptr->txd_info4);
+#endif			
+
+#else //#if !defined (CONFIG_RAETH_TSO)	
+        cpu_ptr->txd_info1.SDP = VIRT_TO_PHYS(skb->data);
+	cpu_ptr->txd_info3.SDL = (length - skb->data_len);
+	cpu_ptr->txd_info3.LS_bit = nr_frags ? 0:1;
+	if (gmac_no == 1) {
+		cpu_ptr->txd_info4.FPORT = 1;
+	}else {
+		cpu_ptr->txd_info4.FPORT = 2;
+	}
+	
+	cpu_ptr->txd_info4.TSO = 0;
+        cpu_ptr->txd_info3.QID = M2Q_table[skb->mark]; 	
+#if defined (CONFIG_RAETH_CHECKSUM_OFFLOAD) && ! defined(CONFIG_RALINK_RT5350) && !defined (CONFIG_RALINK_MT7628)
+	if (skb->ip_summed == CHECKSUM_PARTIAL){
+	    cpu_ptr->txd_info4.TUI_CO = 7;
+	}else {
+	    cpu_ptr->txd_info4.TUI_CO = 0;
+	}
+#endif
+
+#ifdef CONFIG_RAETH_HW_VLAN_TX
+	if(vlan_tx_tag_present(skb)) {
+	    cpu_ptr->txd_info4.VLAN_TAG = 0x10000 | vlan_tx_tag_get(skb);
+	}else {
+	    cpu_ptr->txd_info4.VLAN_TAG = 0;
+	}
+#endif
+
+#if defined (CONFIG_RA_HW_NAT) || defined (CONFIG_RA_HW_NAT_MODULE)
+	if(FOE_MAGIC_TAG(skb) == FOE_MAGIC_PPE) {
+	    if(ra_sw_nat_hook_rx!= NULL){
+		    cpu_ptr->txd_info4.FPORT = 4; /* PPE */
+		    FOE_MAGIC_TAG(skb) = 0;
+	    }
+	}
+#endif
+
+        cpu_ptr->txd_info3.SWC_bit = 1;
+
+        ctx_offset = get_free_txd(&free_txd);
+        if(ctx_offset == NUM_TX_DESC) {
+            printk("get_free_txd fail\n"); 
+        return 0;
+	}
+        cpu_ptr->txd_info2.NDP = VIRT_TO_PHYS(free_txd);
+        ei_local->tx_cpu_ptr = VIRT_TO_PHYS(free_txd);
+  
+        if(nr_frags > 0) {
+            for(i=0;i<nr_frags;i++) {
+	        frag = &skb_shinfo(skb)->frags[i];
+                cpu_ptr = free_txd;
+		cpu_ptr->txd_info3.QID = M2Q_table[skb->mark];
+            	cpu_ptr->txd_info1.SDP = pci_map_page(NULL, frag->page, frag->page_offset, frag->size, PCI_DMA_TODEVICE);
+	        cpu_ptr->txd_info3.SDL = frag->size;
+	        cpu_ptr->txd_info3.LS_bit = (i==nr_frags-1)?1:0;
+	        cpu_ptr->txd_info3.OWN_bit = 0;
+	        cpu_ptr->txd_info3.SWC_bit = 1;
+                ei_local->skb_free[ctx_offset] = (i==nr_frags-1)?skb:(struct  sk_buff *)0xFFFFFFFF; //MAGIC ID
+ 	  
+          	ctx_offset = get_free_txd(&free_txd);
+	        cpu_ptr->txd_info2.NDP = VIRT_TO_PHYS(free_txd);
+	        ei_local->tx_cpu_ptr = VIRT_TO_PHYS(free_txd);				
+	    }
+	    ei_local->skb_free[init_txd_idx]= (struct  sk_buff *)0xFFFFFFFF; //MAGIC ID
+	}
+
+	if(skb_shinfo(skb)->gso_segs > 1) {
+
+//		TsoLenUpdate(skb->len);
+
+		/* TCP over IPv4 */
+		iph = (struct iphdr *)skb_network_header(skb);
+#if defined (CONFIG_RAETH_TSOV6)
+		/* TCP over IPv6 */
+		ip6h = (struct ipv6hdr *)skb_network_header(skb);
+#endif				
+		if((iph->version == 4) && (iph->protocol == IPPROTO_TCP)) {
+			th = (struct tcphdr *)skb_transport_header(skb);
+
+			init_cpu_ptr->txd_info4.TSO = 1;
+
+			th->check = htons(skb_shinfo(skb)->gso_size);
+			dma_cache_sync(NULL, th, sizeof(struct tcphdr), DMA_TO_DEVICE);
+		} 
+	    
+#if defined (CONFIG_RAETH_TSOV6)
+		/* TCP over IPv6 */
+		//ip6h = (struct ipv6hdr *)skb_network_header(skb);
+		else if ((ip6h->version == 6) && (ip6h->nexthdr == NEXTHDR_TCP)) {
+			th = (struct tcphdr *)skb_transport_header(skb);
+#ifdef CONFIG_RAETH_RW_PDMAPTR_FROM_VAR
+			init_cpu_ptr->txd_info4.TSO = 1;
+#else
+			init_cpu_ptr->txd_info4.TSO = 1;
+#endif
+			th->check = htons(skb_shinfo(skb)->gso_size);
+			dma_cache_sync(NULL, th, sizeof(struct tcphdr), DMA_TO_DEVICE);
+		}
+#endif
+	}
+
+		
+//	dma_cache_sync(NULL, skb->data, skb->len, DMA_TO_DEVICE);  
+
+	init_cpu_ptr->txd_info3.OWN_bit = 0;
+#endif // CONFIG_RAETH_TSO //
+
+	sysRegWrite(QTX_CTX_PTR, ei_local->tx_cpu_ptr);
+
+#ifdef CONFIG_PSEUDO_SUPPORT
+	if (gmac_no == 2) {
+		if (ei_local->PseudoDev != NULL) {
+				pAd = netdev_priv(ei_local->PseudoDev);
+				pAd->stat.tx_packets++;
+				pAd->stat.tx_bytes += length;
+			}
+		} else
+		
+#endif
+        {
+	ei_local->stat.tx_packets++;
+	ei_local->stat.tx_bytes += skb->len;
+	}
+	return length;
+}
+
+int ei_start_xmit(struct sk_buff* skb, struct net_device *dev, int gmac_no)
+{
+	END_DEVICE *ei_local = netdev_priv(dev);
+	unsigned long flags;
+	unsigned int num_of_txd;
+#if defined (CONFIG_RAETH_TSO)
+	unsigned int nr_frags = skb_shinfo(skb)->nr_frags;
+#endif
+#ifdef CONFIG_PSEUDO_SUPPORT
+	PSEUDO_ADAPTER *pAd;
+#endif
+
+#if !defined(CONFIG_RA_NAT_NONE)
+         if(ra_sw_nat_hook_tx!= NULL)
+         {
+	   spin_lock_irqsave(&ei_local->page_lock, flags);
+           if(ra_sw_nat_hook_tx(skb, gmac_no)==1){
+	   	spin_unlock_irqrestore(&ei_local->page_lock, flags);
+	   }else{
+	        kfree_skb(skb);
+	   	spin_unlock_irqrestore(&ei_local->page_lock, flags);
+	   	return 0;
+	   }
+         }
+#endif
+
+
+
+	dev->trans_start = jiffies;	/* save the timestamp */
+	spin_lock_irqsave(&ei_local->page_lock, flags);
+	dma_cache_sync(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+
+
+//check free_txd_num before calling rt288_eth_send()
+
+#if defined (CONFIG_RAETH_TSO)
+	num_of_txd = (nr_frags==0) ? 1 : (nr_frags + 1);
+#else
+	num_of_txd = 1;
+#endif
+   
+#if defined(CONFIG_RALINK_MT7621)
+    if(sysRegRead(0xbe00000c)==0x00030101) {
+	    ei_xmit_housekeeping(0);
+    }
+#endif
+	
+
+    if ((ei_local->free_txd_num > num_of_txd + 1) && (ei_local->free_txd_num != NUM_TX_DESC))
+    {
+        rt2880_eth_send(dev, skb, gmac_no); // need to modify rt2880_eth_send() for QDMA
+		if (ei_local->free_txd_num < 3)
+		{
+#if defined (CONFIG_RAETH_STOP_RX_WHEN_TX_FULL) 		    
+		    netif_stop_queue(dev);
+#ifdef CONFIG_PSEUDO_SUPPORT
+		    netif_stop_queue(ei_local->PseudoDev);
+#endif
+		    tx_ring_full = 1;
+#endif
+		}
+    } else {  
+#ifdef CONFIG_PSEUDO_SUPPORT
+		if (gmac_no == 2) 
+		{
+			if (ei_local->PseudoDev != NULL) 
+			{
+			    pAd = netdev_priv(ei_local->PseudoDev);
+			    pAd->stat.tx_dropped++;
+		    }
+		} else
+#endif
+		ei_local->stat.tx_dropped++;
+		kfree_skb(skb);
+                spin_unlock_irqrestore(&ei_local->page_lock, flags);
+		return 0;
+     }	
+	spin_unlock_irqrestore(&ei_local->page_lock, flags);
+	return 0;
+}
+
+void ei_xmit_housekeeping(unsigned long unused)
+{
+    struct net_device *dev = dev_raether;
+    END_DEVICE *ei_local = netdev_priv(dev);
+#ifndef CONFIG_RAETH_NAPI
+    unsigned long reg_int_mask=0;
+#endif
+    struct QDMA_txdesc *dma_ptr = NULL;
+    struct QDMA_txdesc *cpu_ptr = NULL;
+    struct QDMA_txdesc *tmp_ptr = NULL;
+    unsigned int htx_offset = 0;
+
+    dma_ptr = PHYS_TO_VIRT(sysRegRead(QTX_DRX_PTR));
+    cpu_ptr = PHYS_TO_VIRT(sysRegRead(QTX_CRX_PTR));
+    if(cpu_ptr != dma_ptr && (cpu_ptr->txd_info3.OWN_bit == 1)) {
+	while(cpu_ptr != dma_ptr && (cpu_ptr->txd_info3.OWN_bit == 1)) {
+
+	    //1. keep cpu next TXD			
+	    tmp_ptr = PHYS_TO_VIRT(cpu_ptr->txd_info2.NDP);
+            htx_offset = GET_TXD_OFFSET(&tmp_ptr);
+            //2. free skb meomry
+#if defined (CONFIG_RAETH_TSO)
+	    if(ei_local->skb_free[htx_offset]!=(struct  sk_buff *)0xFFFFFFFF) {
+		    dev_kfree_skb_any(ei_local->skb_free[htx_offset]); 
+	    }
+#else
+	    dev_kfree_skb_any(ei_local->skb_free[htx_offset]); 
+#endif			
+                
+	    //3. release TXD
+	    htx_offset = GET_TXD_OFFSET(&cpu_ptr);			
+	    put_free_txd(htx_offset);
+
+            netif_wake_queue(dev);
+#ifdef CONFIG_PSEUDO_SUPPORT
+	    netif_wake_queue(ei_local->PseudoDev);
+#endif			
+	    tx_ring_full=0;
+                
+	    //4. update cpu_ptr to next ptr
+	    cpu_ptr = tmp_ptr;
+	}
+    }
+    sysRegWrite(QTX_CRX_PTR, VIRT_TO_PHYS(cpu_ptr));
+#ifndef CONFIG_RAETH_NAPI
+    reg_int_mask=sysRegRead(QFE_INT_ENABLE);
+#if defined (DELAY_INT)
+    sysRegWrite(FE_INT_ENABLE, reg_int_mask| RLS_DLY_INT);
+#else
+
+    sysRegWrite(FE_INT_ENABLE, reg_int_mask | RLS_DONE_INT);
+#endif
+#endif //CONFIG_RAETH_NAPI//
+}
+
+EXPORT_SYMBOL(ei_start_xmit);
+EXPORT_SYMBOL(ei_xmit_housekeeping);
+EXPORT_SYMBOL(fe_dma_init);
+EXPORT_SYMBOL(rt2880_eth_send);
-- 
1.7.10.4

