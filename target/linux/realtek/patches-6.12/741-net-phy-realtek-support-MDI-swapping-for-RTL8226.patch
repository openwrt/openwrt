From 672a9bfb2e01ecaf40e5b92e9cc564589ffc251d Mon Sep 17 00:00:00 2001
From: Jan Hoffmann <jan@3e8.eu>
Date: Tue, 23 Dec 2025 20:07:53 +0100
Subject: [PATCH] net: phy: realtek: support MDI swapping for RTL8226

Add support for swapping the MDI pairs (ABCD->DCBA) when the property
"realtek,mdi-swap-enable" is specified.

For now, only implement it for RTL8226, where it is needed to make the
PHYs in Zyxel XGS1010-12 rev A1 work.

Other similar PHYs, like RTL8221B also support MDI swapping. However,
at least in Zyxel XGS1212-12 rev B1 this is already handled by strapping
pins and does not require manual configuration. Later PHY variants also
don't need swapping of adccal_offset/rg_lpf_cap_xg/rg_lpf_cap, so
special handling is needed if support for other PHYs is added at some
point.

Signed-off-by: Jan Hoffmann <jan@3e8.eu>
---
 drivers/net/phy/realtek/realtek_main.c | 159 ++++++++++++++++++++++++-
 1 file changed, 158 insertions(+), 1 deletion(-)

--- a/drivers/net/phy/realtek/realtek_main.c
+++ b/drivers/net/phy/realtek/realtek_main.c
@@ -1370,6 +1370,163 @@ static int rtl822xb_config_init_war(stru
 	return ret;
 }
 
+static int rtl8226_mdi_swap(struct phy_device *phydev)
+{
+	int ret;
+	int val_p0, val_p1, val_p2, val_p3;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND1, 0x6a21, BIT(5), BIT(5));
+	if (ret < 0)
+		return ret;
+
+	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xd068);
+	if (ret < 0)
+		return ret;
+
+	if (!(ret & BIT(1))) {
+		/* already swapped */
+		return 0;
+	}
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x7, 0x1);
+	if (ret < 0)
+		return ret;
+
+	/* swap adccal_offset */
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 0 << 3);
+	if (ret < 0)
+		return ret;
+
+	val_p0 = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xd06a);
+	if (val_p0 < 0)
+		return val_p0;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 1 << 3);
+	if (ret < 0)
+		return ret;
+
+	val_p1 = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xd06a);
+	if (val_p1 < 0)
+		return val_p1;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 2 << 3);
+	if (ret < 0)
+		return ret;
+
+	val_p2 = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xd06a);
+	if (val_p2 < 0)
+		return val_p2;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 3 << 3);
+	if (ret < 0)
+		return ret;
+
+	val_p3 = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xd06a);
+	if (val_p3 < 0)
+		return val_p3;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 0 << 3);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xd06a, val_p3);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 1 << 3);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xd06a, val_p2);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 2 << 3);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xd06a, val_p1);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xd068, 0x3 << 3, 3 << 3);
+	if (ret < 0)
+		return ret;
+
+	ret = phy_write_mmd(phydev, MDIO_MMD_VEND2, 0xd06a, val_p0);
+	if (ret < 0)
+		return ret;
+
+	/* swap rg_lpf_cap_xg */
+
+	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xbd5a);
+	if (ret < 0)
+		return ret;
+
+	val_p0 = ret & 0x1f;
+	val_p1 = (ret >> 8) & 0x1f;
+
+	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xbd5c);
+	if (ret < 0)
+		return ret;
+
+	val_p2 = ret & 0x1f;
+	val_p3 = (ret >> 8) & 0x1f;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xbd5a, 0x1f1f,
+		val_p3 | (val_p2 << 8));
+	if (ret < 0)
+		return ret;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xbd5c, 0x1f1f,
+		val_p1 | (val_p0 << 8));
+	if (ret < 0)
+		return ret;
+
+	/* swap rg_lpf_cap */
+
+	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xbc18);
+	if (ret < 0)
+		return ret;
+
+	val_p0 = ret & 0x1f;
+	val_p1 = (ret >> 8) & 0x1f;
+
+	ret = phy_read_mmd(phydev, MDIO_MMD_VEND2, 0xbc1a);
+	if (ret < 0)
+		return ret;
+
+	val_p2 = ret & 0x1f;
+	val_p3 = (ret >> 8) & 0x1f;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xbc18, 0x1f1f,
+		val_p3 | (val_p2 << 8));
+	if (ret < 0)
+		return ret;
+
+	ret = phy_modify_mmd(phydev, MDIO_MMD_VEND2, 0xbc1a, 0x1f1f,
+		val_p1 | (val_p0 << 8));
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int rtl8226_config_init(struct phy_device *phydev)
+{
+	int ret;
+
+	if (of_property_read_bool(phydev->mdio.dev.of_node, "realtek,mdi-swap-enable")) {
+		ret = rtl8226_mdi_swap(phydev);
+		if (ret < 0)
+			return ret;
+	}
+
+	return rtl822x_config_init(phydev);
+}
+
+
 static int rtl822xb_get_rate_matching(struct phy_device *phydev,
 				      phy_interface_t iface)
 {
@@ -2206,7 +2363,7 @@ static struct phy_driver realtek_drvs[]
 		.soft_reset     = rtl822x_c45_soft_reset,
 		.get_features   = rtl822x_c45_get_features,
 		.config_aneg    = rtl822x_c45_config_aneg,
-		.config_init    = rtl822x_config_init,
+		.config_init    = rtl8226_config_init,
 		.read_status    = rtl822xb_c45_read_status,
 		.suspend        = genphy_c45_pma_suspend,
 		.resume         = rtlgen_c45_resume,
