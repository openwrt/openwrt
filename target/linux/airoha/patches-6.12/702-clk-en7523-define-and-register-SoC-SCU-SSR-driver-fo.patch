From a07fe509d2709e54b1dfb195b6b4c8f92024e98e Mon Sep 17 00:00:00 2001
From: Christian Marangi <ansuelsmth@gmail.com>
Date: Thu, 20 Mar 2025 14:00:28 +0100
Subject: [PATCH] clk: en7523: define and register SoC SCU SSR driver for
 EN7581

Define all the possible interface modes and register the SoC SCU SSR
platform driver for EN7581.

Failing to register the SCU SSR driver is not a critical error (example
the SoC driver is not enable) but will prevent PCIe or USB port to
function correctly.

Reference to the SSR pdev are stored in the new en7523 priv struct.

Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
---
 drivers/clk/clk-en7523.c       | 99 ++++++++++++++++++++++++++++++++--
 include/linux/clk/clk-en7523.h | 10 ++++
 2 files changed, 106 insertions(+), 3 deletions(-)
 create mode 100644 include/linux/clk/clk-en7523.h

--- a/drivers/clk/clk-en7523.c
+++ b/drivers/clk/clk-en7523.c
@@ -3,6 +3,7 @@
 #include <linux/bitfield.h>
 #include <linux/delay.h>
 #include <linux/clk-provider.h>
+#include <linux/clk/clk-en7523.h>
 #include <linux/io.h>
 #include <linux/mfd/syscon.h>
 #include <linux/of_platform.h>
@@ -10,10 +11,12 @@
 #include <linux/property.h>
 #include <linux/regmap.h>
 #include <linux/reset-controller.h>
+#include <linux/soc/airoha/airoha-scu-ssr.h>
 #include <dt-bindings/clock/en7523-clk.h>
 #include <dt-bindings/reset/airoha,en7523-reset.h>
 #include <dt-bindings/reset/airoha,en7581-reset.h>
 #include <dt-bindings/reset/airoha,an7583-reset.h>
+#include <dt-bindings/soc/airoha,scu-ssr.h>
 
 #define RST_NR_PER_BANK			32
 
@@ -92,6 +95,7 @@ struct en_clk_soc_data {
 	const struct clk_ops pcie_ops;
 	int (*hw_init)(struct platform_device *pdev,
 		       const struct en_clk_soc_data *soc_data,
+		       struct en_clk_priv *priv,
 		       struct clk_hw_onecell_data *clk_data);
 };
 
@@ -558,6 +562,51 @@ static const u16 en7581_rst_map[] = {
 	[EN7581_XPON_MAC_RST]		= RST_NR_PER_BANK + 31,
 };
 
+static unsigned int an7581_serdes_wifi1_possible_modes[] = {
+	AIROHA_SCU_SERDES_MODE_PCIE0_X1,
+	AIROHA_SCU_SERDES_MODE_PCIE0_X2,
+	AIROHA_SCU_SERDES_MODE_ETHERNET,
+};
+
+static unsigned int an7581_serdes_wifi2_possible_modes[] = {
+	AIROHA_SCU_SERDES_MODE_PCIE1_X1,
+	AIROHA_SCU_SERDES_MODE_PCIE0_X2,
+	AIROHA_SCU_SERDES_MODE_ETHERNET,
+};
+
+static unsigned int an7581_serdes_usb1_possible_modes[] = {
+	AIROHA_SCU_SERDES_MODE_USB3,
+	AIROHA_SCU_SERDES_MODE_ETHERNET,
+};
+
+static unsigned int an7581_serdes_usb2_possible_modes[] = {
+	AIROHA_SCU_SERDES_MODE_PCIE2_X1,
+	AIROHA_SCU_SERDES_MODE_ETHERNET,
+};
+
+static const struct airoha_scu_ssr_serdes_info an7581_ports_info[] = {
+	[AIROHA_SCU_SERDES_WIFI1] = {
+		.possible_modes = an7581_serdes_wifi1_possible_modes,
+		.num_modes = ARRAY_SIZE(an7581_serdes_wifi1_possible_modes),
+	},
+	[AIROHA_SCU_SERDES_WIFI2] = {
+		.possible_modes = an7581_serdes_wifi2_possible_modes,
+		.num_modes = ARRAY_SIZE(an7581_serdes_wifi2_possible_modes),
+	},
+	[AIROHA_SCU_SERDES_USB1] = {
+		.possible_modes = an7581_serdes_usb1_possible_modes,
+		.num_modes = ARRAY_SIZE(an7581_serdes_usb1_possible_modes),
+	},
+	[AIROHA_SCU_SERDES_USB2] = {
+		.possible_modes = an7581_serdes_usb2_possible_modes,
+		.num_modes = ARRAY_SIZE(an7581_serdes_usb2_possible_modes),
+	},
+};
+
+static const struct airoha_scu_ssr_data an7581_scu_ssr_data = {
+	.ports_info = an7581_ports_info,
+};
+
 static const u16 an7583_rst_map[] = {
 	/* RST_CTRL2 */
 	[AN7583_XPON_PHY_RST]		= 0,
@@ -989,6 +1038,7 @@ static const struct regmap_config en7523
 
 static int en7523_clk_hw_init(struct platform_device *pdev,
 			      const struct en_clk_soc_data *soc_data,
+			      struct en_clk_priv *priv,
 			      struct clk_hw_onecell_data *clk_data)
 {
 	void __iomem *base, *np_base;
@@ -1098,8 +1148,33 @@ static int en7581_reset_register(struct
 	return devm_reset_controller_register(dev, &rst_data->rcdev);
 }
 
+static void en7581_clk_register_ssr(struct platform_device *pdev,
+				    struct en_clk_priv *priv)
+{
+	struct platform_device_info pinfo = { };
+	struct platform_device *ssr_pdev;
+
+	pinfo.name = "airoha-scu-ssr";
+	pinfo.parent = &pdev->dev;
+	pinfo.id = PLATFORM_DEVID_AUTO;
+	pinfo.fwnode = of_fwnode_handle(pdev->dev.of_node);
+	pinfo.of_node_reused = true;
+	pinfo.data = &an7581_scu_ssr_data;
+	pinfo.size_data = sizeof(an7581_scu_ssr_data);
+
+	ssr_pdev = platform_device_register_data(&pdev->dev, "airoha-scu-ssr",
+						 PLATFORM_DEVID_AUTO,
+						 &an7581_scu_ssr_data,
+						 sizeof(an7581_scu_ssr_data));
+	if (IS_ERR(ssr_pdev))
+		dev_err_probe(&pdev->dev, PTR_ERR(ssr_pdev), "failed to register SCU SSR driver.\n");
+
+	priv->ssr_pdev = ssr_pdev;
+}
+
 static int en7581_clk_hw_init(struct platform_device *pdev,
 			      const struct en_clk_soc_data *soc_data,
+			      struct en_clk_priv *priv,
 			      struct clk_hw_onecell_data *clk_data)
 {
 	struct device *dev = &pdev->dev;
@@ -1132,12 +1207,15 @@ static int en7581_clk_hw_init(struct pla
 	regmap_update_bits(clk_map, REG_NP_SCU_PCIC, REG_PCIE_CTRL,
 			   FIELD_PREP(REG_PCIE_CTRL, 3));
 
+	en7581_clk_register_ssr(pdev, priv);
+
 	return en7581_reset_register(&pdev->dev, clk_map, en7581_rst_map,
 				     ARRAY_SIZE(en7581_rst_map));
 }
 
 static int an7583_clk_hw_init(struct platform_device *pdev,
 			      const struct en_clk_soc_data *soc_data,
+			      struct en_clk_priv *priv,
 			      struct clk_hw_onecell_data *clk_data)
 {
 	struct device *dev = &pdev->dev;
@@ -1175,10 +1253,15 @@ static int en7523_clk_probe(struct platf
 	const struct en_clk_soc_data *soc_data;
 	struct clk_hw_onecell_data *clk_data;
 	struct device *dev = &pdev->dev;
+	struct en_clk_priv *priv;
 	int err;
 
 	soc_data = device_get_match_data(dev);
 
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
 	clk_data = devm_kzalloc(dev,
 				struct_size(clk_data, hws,
 					    soc_data->num_clocks),
@@ -1187,7 +1270,7 @@ static int en7523_clk_probe(struct platf
 		return -ENOMEM;
 
 	clk_data->num = soc_data->num_clocks;
-	err = soc_data->hw_init(pdev, soc_data, clk_data);
+	err = soc_data->hw_init(pdev, soc_data, priv, clk_data);
 	if (err)
 		return err;
 
@@ -1203,6 +1286,8 @@ static int en7523_clk_probe(struct platf
 			return err;
 	}
 
+	platform_set_drvdata(pdev, priv);
+
 	return 0;
 }
 
--- /dev/null
+++ b/include/linux/clk/clk-en7523.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef __LINUX_CLK_EN7523_H_
+#define __LINUX_CLK_EN7523_H_
+
+struct en_clk_priv {
+	struct platform_device *ssr_pdev;
+};
+
+#endif
