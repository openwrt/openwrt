From 843e2892f2d9353bf039e0dfb5442a600e75009e Mon Sep 17 00:00:00 2001
From: Mikhail Kshevetskiy <mikhail.kshevetskiy@iopsys.eu>
Date: Thu, 9 Oct 2025 23:46:08 +0300
Subject: [PATCH] net: airoha: disable external phy code if PCS_AIROHA is not
 enabled

External phy code breaks building for EN7523, so disable it if
PCS_AIROHA is not selected.

Signed-off-by: Mikhail Kshevetskiy <mikhail.kshevetskiy@iopsys.eu>
---
 drivers/net/ethernet/airoha/airoha_eth.c | 16 ++++++++++++++++
 drivers/net/ethernet/airoha/airoha_eth.h |  2 ++
 2 files changed, 18 insertions(+)

--- a/drivers/net/ethernet/airoha/airoha_eth.c
+++ b/drivers/net/ethernet/airoha/airoha_eth.c
@@ -72,10 +72,12 @@ static void airoha_qdma_irq_disable(stru
 	airoha_qdma_set_irqmask(irq_bank, index, mask, 0);
 }
 
+#if defined(CONFIG_PCS_AIROHA)
 static bool airhoa_is_phy_external(struct airoha_gdm_port *port)
 {
 	return port->id != 1;
 }
+#endif
 
 static void airoha_set_macaddr(struct airoha_gdm_port *port, const u8 *addr)
 {
@@ -1636,6 +1638,7 @@ static int airoha_dev_open(struct net_de
 	struct airoha_gdm_port *port = netdev_priv(dev);
 	struct airoha_qdma *qdma = port->qdma;
 
+#if defined(CONFIG_PCS_AIROHA)
 	if (airhoa_is_phy_external(port)) {
 		err = phylink_of_phy_connect(port->phylink, dev->dev.of_node, 0);
 		if (err) {
@@ -1646,6 +1649,7 @@ static int airoha_dev_open(struct net_de
 
 		phylink_start(port->phylink);
 	}
+#endif
 
 	netif_tx_start_all_queues(dev);
 	err = airoha_set_vip_for_gdm_port(port, true);
@@ -1700,10 +1704,12 @@ static int airoha_dev_stop(struct net_de
 		}
 	}
 
+#if defined(CONFIG_PCS_AIROHA)
 	if (airhoa_is_phy_external(port)) {
 		phylink_stop(port->phylink);
 		phylink_disconnect_phy(port->phylink);
 	}
+#endif
 
 	return 0;
 }
@@ -2853,6 +2859,7 @@ static const struct ethtool_ops airoha_e
 	.get_link		= ethtool_op_get_link,
 };
 
+#if defined(CONFIG_PCS_AIROHA)
 static struct phylink_pcs *airoha_phylink_mac_select_pcs(struct phylink_config *config,
 							 phy_interface_t interface)
 {
@@ -2866,6 +2873,7 @@ static void airoha_mac_config(struct phy
 			      const struct phylink_link_state *state)
 {
 }
+#endif
 
 static int airoha_metadata_dst_alloc(struct airoha_gdm_port *port)
 {
@@ -2911,6 +2919,7 @@ bool airoha_is_valid_gdm_port(struct air
 	return false;
 }
 
+#if defined(CONFIG_PCS_AIROHA)
 static void airoha_mac_link_up(struct phylink_config *config, struct phy_device *phy,
 			       unsigned int mode, phy_interface_t interface,
 			       int speed, int duplex, bool tx_pause, bool rx_pause)
@@ -3003,6 +3012,7 @@ static int airoha_setup_phylink(struct n
 
 	return 0;
 }
+#endif
 
 static int airoha_alloc_gdm_port(struct airoha_eth *eth,
 				 struct device_node *np, int index)
@@ -3082,11 +3092,13 @@ static int airoha_alloc_gdm_port(struct
 	if (err)
 		return err;
 
+#if defined(CONFIG_PCS_AIROHA)
 	if (airhoa_is_phy_external(port)) {
 		err = airoha_setup_phylink(dev);
 		if (err)
 			goto free_metadata_dst;
 	}
+#endif
 
 	err = register_netdev(dev);
 	if (err)
@@ -3202,10 +3214,12 @@ error_hw_cleanup:
 		if (port && port->dev->reg_state == NETREG_REGISTERED) {
 			unregister_netdev(port->dev);
 			airoha_metadata_dst_free(port);
+#if defined(CONFIG_PCS_AIROHA)
 			if (airhoa_is_phy_external(port)) {
 				phylink_destroy(port->phylink);
 				airoha_pcs_destroy(port->pcs);
 			}
+#endif
 		}
 	}
 	free_netdev(eth->napi_dev);
@@ -3233,10 +3247,12 @@ static void airoha_remove(struct platfor
 		airoha_dev_stop(port->dev);
 		unregister_netdev(port->dev);
 		airoha_metadata_dst_free(port);
+#if defined(CONFIG_PCS_AIROHA)
 		if (airhoa_is_phy_external(port)) {
 			phylink_destroy(port->phylink);
 			airoha_pcs_destroy(port->pcs);
 		}
+#endif
 	}
 	free_netdev(eth->napi_dev);
 
--- a/drivers/net/ethernet/airoha/airoha_eth.h
+++ b/drivers/net/ethernet/airoha/airoha_eth.h
@@ -531,9 +531,11 @@ struct airoha_gdm_port {
 	struct net_device *dev;
 	int id;
 
+#if defined(CONFIG_PCS_AIROHA)
 	struct phylink *phylink;
 	struct phylink_config phylink_config;
 	struct phylink_pcs *pcs;
+#endif
 
 	struct airoha_hw_stats stats;
 
