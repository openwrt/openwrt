diff -urN linux.old/drivers/mtd/devices/Kconfig linux.dev/drivers/mtd/devices/Kconfig
--- linux.old/drivers/mtd/devices/Kconfig	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/drivers/mtd/devices/Kconfig	2006-12-15 00:03:11.000000000 +0100
@@ -68,6 +68,10 @@
 	  used for program and data storage.  Set up your spi devices
 	  with the right board-specific platform data.
 
+config MTD_SPIFLASH
+	tristate "Atheros AR2315/6/7 SPI Flash support"
+	depends on MTD && AR531X_COBRA
+
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	depends on MTD
diff -urN linux.old/drivers/mtd/devices/Makefile linux.dev/drivers/mtd/devices/Makefile
--- linux.old/drivers/mtd/devices/Makefile	2006-11-29 22:57:37.000000000 +0100
+++ linux.dev/drivers/mtd/devices/Makefile	2006-12-15 00:03:11.000000000 +0100
@@ -17,3 +17,4 @@
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_SPIFLASH)	+= spiflash.o
diff -urN linux.old/drivers/mtd/devices/spiflash.c linux.dev/drivers/mtd/devices/spiflash.c
--- linux.old/drivers/mtd/devices/spiflash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/mtd/devices/spiflash.c	2006-12-15 08:26:11.000000000 +0100
@@ -0,0 +1,595 @@
+
+/*
+ * MTD driver for the SPI Flash Memory support.
+ *
+ * Copyright (c) 2005-2006 Atheros Communications Inc.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (C) 2006 Felix Fietkau <nbd@openwrt.org>
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*===========================================================================
+** !!!!  VERY IMPORTANT NOTICE !!!!  FLASH DATA STORED IN LITTLE ENDIAN FORMAT
+**
+** This module contains the Serial Flash access routines for the Atheros SOC.
+** The Atheros SOC integrates a SPI flash controller that is used to access
+** serial flash parts. The SPI flash controller executes in "Little Endian"
+** mode. THEREFORE, all WRITES and READS from the MIPS CPU must be
+** BYTESWAPPED! The SPI Flash controller hardware by default performs READ
+** ONLY byteswapping when accessed via the SPI Flash Alias memory region
+** (Physical Address 0x0800_0000 - 0x0fff_ffff). The data stored in the
+** flash sectors is stored in "Little Endian" format.
+**
+** The spiflash_write() routine performs byteswapping on all write
+** operations.
+**===========================================================================*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/squashfs_fs.h>
+#include <linux/root_dev.h>
+#include <asm/delay.h>
+#include <asm/io.h>
+#include "spiflash.h"
+
+/* debugging */
+/* #define SPIFLASH_DEBUG */
+
+#ifndef __BIG_ENDIAN
+#error This driver currently only works with big endian CPU.
+#endif
+
+#define MAX_PARTS 32
+
+static char module_name[] = "spiflash";
+
+#define MIN(a,b)        ((a) < (b) ? (a) : (b))
+#define FALSE 	0
+#define TRUE 	1
+
+#define ROOTFS_NAME	"rootfs"
+
+static __u32 spiflash_regread32(int reg);
+static void spiflash_regwrite32(int reg, __u32 data);
+static __u32 spiflash_sendcmd (int op);
+
+static void __init spidata_init(void);
+int __init spiflash_init (void);
+void __exit spiflash_exit (void);
+static int spiflash_probe (void);
+static int spiflash_erase (struct mtd_info *mtd,struct erase_info *instr);
+static int spiflash_read (struct mtd_info *mtd, loff_t from,size_t len,size_t *retlen,u_char *buf);
+static int spiflash_write (struct mtd_info *mtd,loff_t to,size_t len,size_t *retlen,const u_char *buf);
+
+/* Flash configuration table */
+struct flashconfig {
+    __u32 byte_cnt;
+    __u32 sector_cnt;
+    __u32 sector_size;
+    __u32 cs_addrmask;
+} flashconfig_tbl[MAX_FLASH] =
+    {
+        { 0, 0, 0, 0},
+        { STM_1MB_BYTE_COUNT, STM_1MB_SECTOR_COUNT, STM_1MB_SECTOR_SIZE, 0x0},
+        { STM_2MB_BYTE_COUNT, STM_2MB_SECTOR_COUNT, STM_2MB_SECTOR_SIZE, 0x0},
+        { STM_4MB_BYTE_COUNT, STM_4MB_SECTOR_COUNT, STM_4MB_SECTOR_SIZE, 0x0},
+        { STM_8MB_BYTE_COUNT, STM_8MB_SECTOR_COUNT, STM_8MB_SECTOR_SIZE, 0x0}
+    };
+
+/* Mapping of generic opcodes to STM serial flash opcodes */
+struct opcodes {
+    __u16 code;
+    __s8 tx_cnt;
+    __s8 rx_cnt;
+} stm_opcodes[] = {
+        {STM_OP_WR_ENABLE, 1, 0},
+        {STM_OP_WR_DISABLE, 1, 0},
+        {STM_OP_RD_STATUS, 1, 1},
+        {STM_OP_WR_STATUS, 1, 0},
+        {STM_OP_RD_DATA, 4, 4},
+        {STM_OP_FAST_RD_DATA, 1, 0},
+        {STM_OP_PAGE_PGRM, 8, 0},
+        {STM_OP_SECTOR_ERASE, 4, 0},
+        {STM_OP_BULK_ERASE, 1, 0},
+        {STM_OP_DEEP_PWRDOWN, 1, 0},
+        {STM_OP_RD_SIG, 4, 1}
+};
+
+/* Driver private data structure */
+struct spiflash_data {
+	struct 	mtd_info       *mtd;	
+	struct 	mtd_partition  *parsed_parts;     /* parsed partitions */
+	void 	*spiflash_readaddr; /* memory mapped data for read  */
+	void 	*spiflash_mmraddr;  /* memory mapped register space */
+	spinlock_t mutex;
+};
+
+static struct spiflash_data *spidata;
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+/***************************************************************************************************/
+
+static __u32
+spiflash_regread32(int reg)
+{
+	volatile __u32 *data = (__u32 *)(spidata->spiflash_mmraddr + reg);
+
+	return (*data);
+}
+
+static void 
+spiflash_regwrite32(int reg, __u32 data)
+{
+	volatile __u32 *addr = (__u32 *)(spidata->spiflash_mmraddr + reg);
+
+	*addr = data;
+	return;
+}
+
+static __u32 
+spiflash_sendcmd (int op)
+{
+	 __u32 reg;
+	 __u32 mask;
+	struct opcodes *ptr_opcode;
+
+	ptr_opcode = &stm_opcodes[op];
+
+	do {
+		reg = spiflash_regread32(SPI_FLASH_CTL);
+	} while (reg & SPI_CTL_BUSY);
+
+	spiflash_regwrite32(SPI_FLASH_OPCODE, ptr_opcode->code);
+
+	reg = (reg & ~SPI_CTL_TX_RX_CNT_MASK) | ptr_opcode->tx_cnt |
+        	(ptr_opcode->rx_cnt << 4) | SPI_CTL_START;
+
+	spiflash_regwrite32(SPI_FLASH_CTL, reg);
+ 
+	if (ptr_opcode->rx_cnt > 0) {
+        	do {
+          		reg = spiflash_regread32(SPI_FLASH_CTL);
+        	} while (reg & SPI_CTL_BUSY);
+
+        	reg = (__u32) spiflash_regread32(SPI_FLASH_DATA);
+
+        	switch (ptr_opcode->rx_cnt) {
+        	case 1:
+            		mask = 0x000000ff;
+            		break;
+        	case 2:
+            		mask = 0x0000ffff;
+            		break;
+        	case 3:
+            		mask = 0x00ffffff;
+            		break;
+        	default:
+            		mask = 0xffffffff;
+            		break;
+        	}
+
+        	reg &= mask;
+   	}
+	else {
+       		reg = 0;
+    	}
+
+	return reg;
+}
+
+/* Probe SPI flash device
+ * Function returns 0 for failure.
+ * and flashconfig_tbl array index for success.
+ */
+static int 
+spiflash_probe (void)
+{
+	__u32 sig;
+   	int flash_size;
+
+	if (!spidata)
+		spidata_init();
+	
+	if (!spidata) /* init failed */
+		return 0;
+
+   	/* Read the signature on the flash device */
+   	sig = spiflash_sendcmd(SPI_RD_SIG);
+
+   	switch (sig) {
+   	case STM_8MBIT_SIGNATURE:
+            	flash_size = FLASH_1MB;
+        	break;
+        case STM_16MBIT_SIGNATURE:
+            	flash_size = FLASH_2MB;
+            	break;
+        case STM_32MBIT_SIGNATURE:
+            	flash_size = FLASH_4MB;
+            	break;
+        case STM_64MBIT_SIGNATURE:
+            	flash_size = FLASH_8MB;
+            	break;
+        default:
+	    	printk (KERN_WARNING "%s: Read of flash device signature failed!\n", module_name);
+            	return (0);
+   	}
+
+   	return (flash_size);
+}
+
+
+static int 
+spiflash_erase (struct mtd_info *mtd,struct erase_info *instr)
+{
+	struct opcodes *ptr_opcode;
+	__u32 temp, reg;
+	int finished = FALSE;
+
+#ifdef SPIFLASH_DEBUG
+   	printk (KERN_DEBUG "%s(addr = 0x%.8x, len = %d)\n",__FUNCTION__,instr->addr,instr->len);
+#endif
+
+   	/* sanity checks */
+   	if (instr->addr + instr->len > mtd->size) return (-EINVAL);
+
+	ptr_opcode = &stm_opcodes[SPI_SECTOR_ERASE];
+
+	temp = ((__u32)instr->addr << 8) | (__u32)(ptr_opcode->code);
+	spin_lock(&spidata->mutex);
+	spiflash_sendcmd(SPI_WRITE_ENABLE);
+	do {
+		schedule();
+		reg = spiflash_regread32(SPI_FLASH_CTL);
+	} while (reg & SPI_CTL_BUSY);
+
+	spiflash_regwrite32(SPI_FLASH_OPCODE, temp);
+
+	reg = (reg & ~SPI_CTL_TX_RX_CNT_MASK) | ptr_opcode->tx_cnt | SPI_CTL_START;
+	spiflash_regwrite32(SPI_FLASH_CTL, reg);
+
+	do {
+		schedule();
+		reg = spiflash_sendcmd(SPI_RD_STATUS);
+		if (!(reg & SPI_STATUS_WIP)) {
+			finished = TRUE;
+		}
+	} while (!finished);
+	spin_unlock(&spidata->mutex);
+
+   	instr->state = MTD_ERASE_DONE;
+   	if (instr->callback) instr->callback (instr);
+
+#ifdef SPIFLASH_DEBUG
+   	printk (KERN_DEBUG "%s return\n",__FUNCTION__);
+#endif
+   	return (0);
+}
+
+static int 
+spiflash_read (struct mtd_info *mtd, loff_t from,size_t len,size_t *retlen,u_char *buf)
+{
+	u_char	*read_addr;
+
+#ifdef SPIFLASH_DEBUG
+   	printk (KERN_DEBUG "%s(from = 0x%.8x, len = %d)\n",__FUNCTION__,(__u32) from,(int)len);  
+#endif
+
+   	/* sanity checks */
+   	if (!len) return (0);
+   	if (from + len > mtd->size) return (-EINVAL);
+	
+
+   	/* we always read len bytes */
+   	*retlen = len;
+
+	read_addr = (u_char *)(spidata->spiflash_readaddr + from);
+	spin_lock(&spidata->mutex);
+	memcpy(buf, read_addr, len);
+	spin_unlock(&spidata->mutex);
+
+   	return (0);
+}
+
+static int 
+spiflash_write (struct mtd_info *mtd,loff_t to,size_t len,size_t *retlen,const u_char *buf)
+{
+	int done = FALSE, page_offset, bytes_left, finished;
+	__u32 xact_len, spi_data = 0, opcode, reg;
+
+#ifdef SPIFLASH_DEBUG
+   	printk (KERN_DEBUG "%s(to = 0x%.8x, len = %d)\n",__FUNCTION__,(__u32) to,len); 
+#endif
+
+   	*retlen = 0;
+	
+   	/* sanity checks */
+   	if (!len) return (0);
+   	if (to + len > mtd->size) return (-EINVAL);
+	
+	opcode = stm_opcodes[SPI_PAGE_PROGRAM].code;
+	bytes_left = len;
+	
+	while (done == FALSE) {
+		xact_len = MIN(bytes_left, sizeof(__u32));
+
+		/* 32-bit writes cannot span across a page boundary
+		 * (256 bytes). This types of writes require two page
+		 * program operations to handle it correctly. The STM part
+		 * will write the overflow data to the beginning of the
+		 * current page as opposed to the subsequent page.
+		 */
+		page_offset = (to & (STM_PAGE_SIZE - 1)) + xact_len;
+
+		if (page_offset > STM_PAGE_SIZE) {
+			xact_len -= (page_offset - STM_PAGE_SIZE);
+		}
+
+		spin_lock(&spidata->mutex);
+		spiflash_sendcmd(SPI_WRITE_ENABLE);
+
+		do {
+			schedule();
+			reg = spiflash_regread32(SPI_FLASH_CTL);
+		} while (reg & SPI_CTL_BUSY);
+	
+		switch (xact_len) {
+			case 1:
+			 	spi_data = (u32) ((u8) *buf);
+				break;
+			case 2:
+				spi_data = (buf[1] << 8) | buf[0];
+				break;
+			case 3:
+				spi_data = (buf[2] << 16) | (buf[1] << 8) | buf[0];
+				break;
+			case 4:
+				spi_data = (buf[3] << 24) | (buf[2] << 16) | 
+							(buf[1] << 8) | buf[0];
+				break;
+			default:
+				printk("spiflash_write: default case\n");
+				break;
+		}
+
+		spiflash_regwrite32(SPI_FLASH_DATA, spi_data);
+		opcode = (opcode & SPI_OPCODE_MASK) | ((__u32)to << 8);
+		spiflash_regwrite32(SPI_FLASH_OPCODE, opcode);
+
+		reg = (reg & ~SPI_CTL_TX_RX_CNT_MASK) | (xact_len + 4) | SPI_CTL_START;
+		spiflash_regwrite32(SPI_FLASH_CTL, reg);
+		finished = FALSE;
+		
+		do {
+			schedule();
+			reg = spiflash_sendcmd(SPI_RD_STATUS);
+			if (!(reg & SPI_STATUS_WIP)) {
+				finished = TRUE;
+			}
+		} while (!finished);
+		spin_unlock(&spidata->mutex);
+
+		bytes_left -= xact_len;
+		to += xact_len;
+		buf += xact_len;
+
+   		*retlen += xact_len;
+
+		if (bytes_left == 0) {
+			done = TRUE;
+		}
+	}
+
+   	return (0);
+}
+
+static void __init spidata_init(void)
+{
+	if (spidata)
+		return;
+			
+   	spidata = kmalloc(sizeof(struct spiflash_data), GFP_KERNEL);
+	spin_lock_init(&spidata->mutex);
+
+  	if (!spidata)
+		return;
+
+	spidata->spiflash_mmraddr = ioremap_nocache(SPI_FLASH_MMR, SPI_FLASH_MMR_SIZE);
+	
+	if (!spidata->spiflash_mmraddr) {
+  		printk (KERN_WARNING "%s: Failed to map flash device\n", module_name);
+		kfree(spidata);
+		spidata = NULL;
+	}
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", NULL };
+#endif
+
+int __init 
+spiflash_init (void)
+{
+   	int result = -1, i, j;
+	u32 len;
+   	int index, num_parts;
+	struct mtd_info *mtd;
+	struct  mtd_partition  *mtd_parts;
+	char *buf;
+	struct mtd_partition *part;
+	struct squashfs_super_block *sb;
+	u32 config_start;
+
+	spidata_init();
+
+  	if (!spidata)
+		return (-ENXIO);
+	
+   	mtd = kzalloc(sizeof(struct mtd_info), GFP_KERNEL);
+   	if (!mtd) {
+		kfree(spidata);
+		return (-ENXIO);
+	}
+	
+   	printk ("MTD driver for SPI flash.\n");
+   	printk ("%s: Probing for Serial flash ...\n", module_name);
+   	if (!(index = spiflash_probe ())) {
+    	printk (KERN_WARNING "%s: Found no serial flash device\n", module_name);
+		kfree(mtd);
+		kfree(spidata);
+    	return (-ENXIO);
+   	}
+
+   	printk ("%s: Found SPI serial Flash.\n", module_name);
+
+	spidata->spiflash_readaddr = ioremap_nocache(SPI_FLASH_READ, flashconfig_tbl[index].byte_cnt);
+	if (!spidata->spiflash_readaddr) {
+       		printk (KERN_WARNING "%s: Failed to map flash device\n", module_name);
+		kfree(mtd);
+		kfree(spidata);
+       		return (-ENXIO);
+	}
+
+   	mtd->name = module_name;
+   	mtd->type = MTD_NORFLASH;
+   	mtd->flags = (MTD_CAP_NORFLASH|MTD_WRITEABLE);
+   	mtd->size = flashconfig_tbl[index].byte_cnt;
+   	mtd->erasesize = flashconfig_tbl[index].sector_size;
+	mtd->writesize = 1;
+   	mtd->numeraseregions = 0;
+   	mtd->eraseregions = NULL;
+   	mtd->erase = spiflash_erase;
+   	mtd->read = spiflash_read;
+   	mtd->write = spiflash_write;
+	mtd->owner = THIS_MODULE;
+
+#ifdef SPIFLASH_DEBUG
+	printk (KERN_DEBUG
+		   "mtd->name = %s\n"
+		   "mtd->size = 0x%.8x (%uM)\n"
+		   "mtd->erasesize = 0x%.8x (%uK)\n"
+		   "mtd->numeraseregions = %d\n",
+		   mtd->name,
+		   mtd->size, mtd->size / (1024*1024),
+		   mtd->erasesize, mtd->erasesize / 1024,
+		   mtd->numeraseregions);
+
+   	if (mtd->numeraseregions) {
+	 	for (result = 0; result < mtd->numeraseregions; result++) {
+	   		printk (KERN_DEBUG
+			   "\n\n"
+			   "mtd->eraseregions[%d].offset = 0x%.8x\n"
+			   "mtd->eraseregions[%d].erasesize = 0x%.8x (%uK)\n"
+			   "mtd->eraseregions[%d].numblocks = %d\n",
+			   result,mtd->eraseregions[result].offset,
+			   result,mtd->eraseregions[result].erasesize,mtd->eraseregions[result].erasesize / 1024,
+			   result,mtd->eraseregions[result].numblocks);
+         	}
+    	}
+#endif
+
+   	/* parse redboot partitions */
+	num_parts = parse_mtd_partitions(mtd, part_probe_types, &spidata->parsed_parts, 0);
+
+	mtd_parts = kzalloc(sizeof(struct mtd_partition) * MAX_PARTS, GFP_KERNEL);
+	buf = kmalloc(mtd->erasesize, GFP_KERNEL);
+	sb = (struct squashfs_super_block *) buf;
+	for (i = j = 0; i < num_parts; i++, j++) {
+		part = &mtd_parts[j];
+		memcpy(part, &spidata->parsed_parts[i], sizeof(struct mtd_partition));
+		
+		if (!strcmp(part->name, ROOTFS_NAME)) {
+			/* create the root device */
+			ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, i);
+
+			part->size -= mtd->erasesize;
+			config_start = part->offset + part->size;
+
+			while ((mtd->read(mtd, part->offset, mtd->erasesize, &len, buf) == 0) &&
+					(len == mtd->erasesize) &&
+					(*((u32 *) buf) == SQUASHFS_MAGIC) &&
+					(sb->bytes_used > 0)) {
+					
+				/* this is squashfs, allocate another partition starting from the end of filesystem data */
+				memcpy(&mtd_parts[j + 1], part, sizeof(struct mtd_partition));
+			
+				len = (u32) sb->bytes_used;
+				len += (part->offset & 0x000fffff);
+				len +=  (mtd->erasesize - 1);
+				len &= ~(mtd->erasesize - 1);
+				len -= (part->offset & 0x000fffff);
+
+				if (len + mtd->erasesize > part->size)
+					break;
+
+				part = &mtd_parts[++j];
+				
+				part->offset += len;
+				part->size -= len;
+
+				part->name = kmalloc(10, GFP_KERNEL);
+				sprintf(part->name, "rootfs%d", j - i);
+			}
+		}
+		if (!strcmp(part->name, "RedBoot config")) {
+			/* add anoterh partition for the board config data */
+			memcpy(&mtd_parts[j + 1], part, sizeof(struct mtd_partition));
+			j++;
+			part = &mtd_parts[j];
+			part->offset += part->size;
+			part->size = mtd->erasesize;
+			
+			part->name = kmalloc(16, GFP_KERNEL);
+			sprintf(part->name, "board_config");
+		}
+	}
+	num_parts += j - i;
+	kfree(buf);
+
+#ifdef SPIFLASH_DEBUG
+   	printk (KERN_DEBUG "Found %d redboot partitions\n", num_parts);
+#endif
+	if (num_parts) {
+   		result = add_mtd_partitions(mtd, mtd_parts, num_parts);
+	} else {
+#ifdef SPIFLASH_DEBUG
+		printk (KERN_DEBUG "Did not find any redboot partitions\n");
+#endif
+		kfree(mtd);
+		kfree(spidata);
+       		return (-ENXIO);
+	}
+
+	spidata->mtd = mtd;
+
+   	return (result);
+}
+
+void __exit 
+spiflash_exit (void)
+{
+    	if (spidata && spidata->parsed_parts) {
+        	del_mtd_partitions (spidata->mtd);
+		kfree(spidata->mtd);
+		kfree(spidata);
+    	}
+}
+
+module_init (spiflash_init);
+module_exit (spiflash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Atheros Communications Inc");
+MODULE_DESCRIPTION("MTD driver for SPI Flash on Atheros SOC");
+
diff -urN linux.old/drivers/mtd/devices/spiflash.h linux.dev/drivers/mtd/devices/spiflash.h
--- linux.old/drivers/mtd/devices/spiflash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/mtd/devices/spiflash.h	2006-12-15 06:59:43.000000000 +0100
@@ -0,0 +1,124 @@
+/*
+ * SPI Flash Memory support header file.
+ *
+ * $Id: //depot/sw/releases/linuxsrc/src/kernels/mips-linux-2.4.25/drivers/mtd/devices/spiflash.h#3 $
+ *
+ *
+ * Copyright (c) 2005, Atheros Communications Inc.
+ * Copyright (C) 2006 FON Technology, SL.
+ * Copyright (C) 2006 Imre Kaloz <kaloz@openwrt.org>
+ *
+ * This code is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#define FLASH_1MB  1
+#define FLASH_2MB  2
+#define FLASH_4MB  3
+#define FLASH_8MB  4
+#define MAX_FLASH  5
+
+#define STM_PAGE_SIZE           256
+
+#define SPI_WRITE_ENABLE    0
+#define SPI_WRITE_DISABLE   1
+#define SPI_RD_STATUS       2
+#define SPI_WR_STATUS       3
+#define SPI_RD_DATA         4
+#define SPI_FAST_RD_DATA    5
+#define SPI_PAGE_PROGRAM    6
+#define SPI_SECTOR_ERASE    7
+#define SPI_BULK_ERASE      8
+#define SPI_DEEP_PWRDOWN    9
+#define SPI_RD_SIG          10
+#define SPI_MAX_OPCODES     11
+
+#define SFI_WRITE_BUFFER_SIZE   4
+#define SFI_FLASH_ADDR_MASK     0x00ffffff
+
+#define STM_8MBIT_SIGNATURE     0x13
+#define STM_M25P80_BYTE_COUNT   1048576
+#define STM_M25P80_SECTOR_COUNT 16
+#define STM_M25P80_SECTOR_SIZE  0x10000
+
+#define STM_16MBIT_SIGNATURE    0x14
+#define STM_M25P16_BYTE_COUNT   2097152
+#define STM_M25P16_SECTOR_COUNT 32
+#define STM_M25P16_SECTOR_SIZE  0x10000
+
+#define STM_32MBIT_SIGNATURE    0x15
+#define STM_M25P32_BYTE_COUNT   4194304
+#define STM_M25P32_SECTOR_COUNT 64
+#define STM_M25P32_SECTOR_SIZE  0x10000
+
+#define STM_64MBIT_SIGNATURE    0x16
+#define STM_M25P64_BYTE_COUNT   8388608
+#define STM_M25P64_SECTOR_COUNT 128
+#define STM_M25P64_SECTOR_SIZE  0x10000
+
+#define STM_1MB_BYTE_COUNT   STM_M25P80_BYTE_COUNT
+#define STM_1MB_SECTOR_COUNT STM_M25P80_SECTOR_COUNT
+#define STM_1MB_SECTOR_SIZE  STM_M25P80_SECTOR_SIZE
+#define STM_2MB_BYTE_COUNT   STM_M25P16_BYTE_COUNT
+#define STM_2MB_SECTOR_COUNT STM_M25P16_SECTOR_COUNT
+#define STM_2MB_SECTOR_SIZE  STM_M25P16_SECTOR_SIZE
+#define STM_4MB_BYTE_COUNT   STM_M25P32_BYTE_COUNT
+#define STM_4MB_SECTOR_COUNT STM_M25P32_SECTOR_COUNT
+#define STM_4MB_SECTOR_SIZE  STM_M25P32_SECTOR_SIZE
+#define STM_8MB_BYTE_COUNT   STM_M25P64_BYTE_COUNT
+#define STM_8MB_SECTOR_COUNT STM_M25P64_SECTOR_COUNT
+#define STM_8MB_SECTOR_SIZE  STM_M25P64_SECTOR_SIZE
+
+/*
+ * ST Microelectronics Opcodes for Serial Flash
+ */
+
+#define STM_OP_WR_ENABLE       0x06     /* Write Enable */
+#define STM_OP_WR_DISABLE      0x04     /* Write Disable */
+#define STM_OP_RD_STATUS       0x05     /* Read Status */
+#define STM_OP_WR_STATUS       0x01     /* Write Status */
+#define STM_OP_RD_DATA         0x03     /* Read Data */
+#define STM_OP_FAST_RD_DATA    0x0b     /* Fast Read Data */
+#define STM_OP_PAGE_PGRM       0x02     /* Page Program */
+#define STM_OP_SECTOR_ERASE    0xd8     /* Sector Erase */
+#define STM_OP_BULK_ERASE      0xc7     /* Bulk Erase */
+#define STM_OP_DEEP_PWRDOWN    0xb9     /* Deep Power-Down Mode */
+#define STM_OP_RD_SIG          0xab     /* Read Electronic Signature */
+
+#define STM_STATUS_WIP       0x01       /* Write-In-Progress */
+#define STM_STATUS_WEL       0x02       /* Write Enable Latch */
+#define STM_STATUS_BP0       0x04       /* Block Protect 0 */
+#define STM_STATUS_BP1       0x08       /* Block Protect 1 */
+#define STM_STATUS_BP2       0x10       /* Block Protect 2 */
+#define STM_STATUS_SRWD      0x80       /* Status Register Write Disable */
+
+/*
+ * SPI Flash Interface Registers
+ */
+#define AR531XPLUS_SPI_READ     0x08000000
+#define AR531XPLUS_SPI_MMR      0x11300000
+#define AR531XPLUS_SPI_MMR_SIZE 12
+
+#define AR531XPLUS_SPI_CTL      0x00
+#define AR531XPLUS_SPI_OPCODE   0x04
+#define AR531XPLUS_SPI_DATA     0x08
+
+#define SPI_FLASH_READ          AR531XPLUS_SPI_READ
+#define SPI_FLASH_MMR           AR531XPLUS_SPI_MMR
+#define SPI_FLASH_MMR_SIZE      AR531XPLUS_SPI_MMR_SIZE
+#define SPI_FLASH_CTL           AR531XPLUS_SPI_CTL
+#define SPI_FLASH_OPCODE        AR531XPLUS_SPI_OPCODE
+#define SPI_FLASH_DATA          AR531XPLUS_SPI_DATA
+
+#define SPI_CTL_START           0x00000100
+#define SPI_CTL_BUSY            0x00010000
+#define SPI_CTL_TXCNT_MASK      0x0000000f
+#define SPI_CTL_RXCNT_MASK      0x000000f0
+#define SPI_CTL_TX_RX_CNT_MASK  0x000000ff
+#define SPI_CTL_SIZE_MASK       0x00060000
+
+#define SPI_CTL_CLK_SEL_MASK    0x03000000
+#define SPI_OPCODE_MASK         0x000000ff
+
+#define SPI_STATUS_WIP		STM_STATUS_WIP

