From 6126701397fa6c884fd78453d995e49df91a566a Mon Sep 17 00:00:00 2001
From: Pavel Kubelun <be.dissent@gmail.com>
Date: Mon, 13 May 2019 11:25:05 +0300
Subject: [PATCH] ipq40xx: Add support for secondary cores bringup

Cherry-pick QSDK patches to enable proper ipq40xx
secondary cores bringup.

https://source.codeaurora.org/quic/qsdk/oss/kernel/linux-msm/commit/?h=eggplant&id=f810b63c356bd72d9b89fb9c0b7e27c250c3540f

Signed-off-by: Pavel Kubelun <be.dissent@gmail.com>
---
 Documentation/devicetree/bindings/arm/cpus.txt |  1 +
 arch/arm/boot/dts/qcom-ipq4019.dtsi            | 16 +++----
 arch/arm/mach-qcom/platsmp.c                   | 62 ++++++++++++++++++++++++++
 3 files changed, 71 insertions(+), 8 deletions(-)

--- a/Documentation/devicetree/bindings/arm/cpus.txt
+++ b/Documentation/devicetree/bindings/arm/cpus.txt
@@ -216,6 +216,7 @@ described below.
 			    "marvell,98dx3236-smp"
 			    "mediatek,mt6589-smp"
 			    "mediatek,mt81xx-tz-smp"
+			    "qcom,arm-cortex-a7acc"
 			    "qcom,gcc-msm8660"
 			    "qcom,kpss-acc-v1"
 			    "qcom,kpss-acc-v2"
--- a/arch/arm/boot/dts/qcom-ipq4019.dtsi
+++ b/arch/arm/boot/dts/qcom-ipq4019.dtsi
@@ -52,7 +52,7 @@
 		cpu@0 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a7";
-			enable-method = "qcom,kpss-acc-v2";
+			enable-method = "qcom,arm-cortex-a7acc";
 			next-level-cache = <&L2>;
 			qcom,acc = <&acc0>;
 			qcom,saw = <&saw0>;
@@ -66,7 +66,7 @@
 		cpu@1 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a7";
-			enable-method = "qcom,kpss-acc-v2";
+			enable-method = "qcom,arm-cortex-a7acc";
 			next-level-cache = <&L2>;
 			qcom,acc = <&acc1>;
 			qcom,saw = <&saw1>;
@@ -80,7 +80,7 @@
 		cpu@2 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a7";
-			enable-method = "qcom,kpss-acc-v2";
+			enable-method = "qcom,arm-cortex-a7acc";
 			next-level-cache = <&L2>;
 			qcom,acc = <&acc2>;
 			qcom,saw = <&saw2>;
@@ -94,7 +94,7 @@
 		cpu@3 {
 			device_type = "cpu";
 			compatible = "arm,cortex-a7";
-			enable-method = "qcom,kpss-acc-v2";
+			enable-method = "qcom,arm-cortex-a7acc";
 			next-level-cache = <&L2>;
 			qcom,acc = <&acc3>;
 			qcom,saw = <&saw3>;
@@ -306,22 +306,22 @@
 		};
 
                 acc0: clock-controller@b088000 {
-                        compatible = "qcom,kpss-acc-v2";
+                        compatible = "qcom,arm-cortex-a7acc";
                         reg = <0x0b088000 0x1000>, <0xb008000 0x1000>;
                 };
 
                 acc1: clock-controller@b098000 {
-                        compatible = "qcom,kpss-acc-v2";
+                        compatible = "qcom,arm-cortex-a7acc";
                         reg = <0x0b098000 0x1000>, <0xb008000 0x1000>;
                 };
 
                 acc2: clock-controller@b0a8000 {
-                        compatible = "qcom,kpss-acc-v2";
+                        compatible = "qcom,arm-cortex-a7acc";
                         reg = <0x0b0a8000 0x1000>, <0xb008000 0x1000>;
                 };
 
                 acc3: clock-controller@b0b8000 {
-                        compatible = "qcom,kpss-acc-v2";
+                        compatible = "qcom,arm-cortex-a7acc";
                         reg = <0x0b0b8000 0x1000>, <0xb008000 0x1000>;
                 };
 
--- a/arch/arm/mach-qcom/platsmp.c
+++ b/arch/arm/mach-qcom/platsmp.c
@@ -89,6 +89,53 @@ static int scss_release_secondary(unsign
 	return 0;
 }
 
+static int a7ss_release_secondary(unsigned int cpu)
+{
+	struct device_node *node;
+	void __iomem *base;
+	struct resource res;
+
+	node = of_find_compatible_node(NULL, NULL, "qcom,arm-cortex-a7acc");
+	if (!node) {
+		pr_err("%s: can't find node\n", __func__);
+		return -ENXIO;
+	}
+
+	if (of_address_to_resource(node, 0, &res)) {
+		of_node_put(node);
+		return -ENXIO;
+	}
+
+	res.start += cpu * 0x10000;
+
+	base = ioremap(res.start, 0x1000);
+	of_node_put(node);
+
+	if (!base)
+		return -ENOMEM;
+
+	/* Enable Clamp signal and assert core reset */
+	writel_relaxed(0x00000033, base + 0x04);
+	mb(); /* barrier */
+
+	/* Set GDHS and delay counter */
+	writel_relaxed(0x20000001, base + 0x14);
+	mb(); /* barrier */
+
+	udelay(2);
+
+	/* Enable Core memory HS */
+	writel_relaxed(0x00020008, base + 0x04);
+	mb(); /* barrier */
+
+	/* Report that the CPU is powered up */
+	writel_relaxed(0x00020088, base + 0x04);
+	mb(); /* barrier */
+
+	iounmap(base);
+	return 0;
+}
+
 static int kpssv1_release_secondary(unsigned int cpu)
 {
 	int ret = 0;
@@ -307,6 +354,11 @@ static int msm8660_boot_secondary(unsign
 	return qcom_boot_secondary(cpu, scss_release_secondary);
 }
 
+static int a7ss_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	return qcom_boot_secondary(cpu, a7ss_release_secondary);
+}
+
 static int kpssv1_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	return qcom_boot_secondary(cpu, kpssv1_release_secondary);
@@ -361,3 +413,13 @@ static const struct smp_operations qcom_
 #endif
 };
 CPU_METHOD_OF_DECLARE(qcom_smp_kpssv2, "qcom,kpss-acc-v2", &qcom_smp_kpssv2_ops);
+
+static struct smp_operations qcom_smp_a7ss_ops __initdata = {
+	.smp_prepare_cpus       = qcom_smp_prepare_cpus,
+	.smp_secondary_init     = qcom_secondary_init,
+	.smp_boot_secondary     = a7ss_boot_secondary,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_die                = qcom_cpu_die,
+#endif
+};
+CPU_METHOD_OF_DECLARE(qcom_smp_a7ss, "qcom,arm-cortex-a7acc", &qcom_smp_a7ss_ops);
