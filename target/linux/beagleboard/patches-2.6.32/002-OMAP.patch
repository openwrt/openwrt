diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 1c4119c..e861e32 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1508,6 +1508,10 @@ source "net/Kconfig"
 
 source "drivers/Kconfig"
 
+if ARCH_OMAP
+source "drivers/cbus/Kconfig"
+endif
+
 source "fs/Kconfig"
 
 source "arch/arm/Kconfig.debug"
diff --git a/arch/arm/configs/n8x0_defconfig b/arch/arm/configs/n8x0_defconfig
index 8da75de..264f52b 100644
--- a/arch/arm/configs/n8x0_defconfig
+++ b/arch/arm/configs/n8x0_defconfig
@@ -304,7 +304,7 @@ CONFIG_ALIGNMENT_TRAP=y
 CONFIG_ZBOOT_ROM_TEXT=0x10C08000
 CONFIG_ZBOOT_ROM_BSS=0x10200000
 # CONFIG_ZBOOT_ROM is not set
-CONFIG_CMDLINE="root=1f03 rootfstype=jffs2 console=ttyS0,115200n8"
+CONFIG_CMDLINE="root=1f03 rootfstype=jffs2 console=ttyS2,115200n8"
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
 
diff --git a/arch/arm/mach-omap1/board-fsample.c b/arch/arm/mach-omap1/board-fsample.c
index a7ead1b..74720e6 100644
--- a/arch/arm/mach-omap1/board-fsample.c
+++ b/arch/arm/mach-omap1/board-fsample.c
@@ -107,7 +107,7 @@ static struct resource smc91x_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= INT_730_MPU_EXT_NIRQ,
+		.start	= INT_7XX_MPU_EXT_NIRQ,
 		.end	= 0,
 		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
 	},
@@ -196,8 +196,8 @@ static struct platform_device smc91x_device = {
 
 static struct resource kp_resources[] = {
 	[0] = {
-		.start	= INT_730_MPUIO_KEYPAD,
-		.end	= INT_730_MPUIO_KEYPAD,
+		.start	= INT_7XX_MPUIO_KEYPAD,
+		.end	= INT_7XX_MPUIO_KEYPAD,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -309,7 +309,7 @@ static void __init omap_fsample_map_io(void)
 	/*
 	 * Hold GSM Reset until needed
 	 */
-	omap_writew(omap_readw(OMAP730_DSP_M_CTL) & ~1, OMAP730_DSP_M_CTL);
+	omap_writew(omap_readw(OMAP7XX_DSP_M_CTL) & ~1, OMAP7XX_DSP_M_CTL);
 
 	/*
 	 * UARTs -> done automagically by 8250 driver
@@ -320,21 +320,21 @@ static void __init omap_fsample_map_io(void)
 	 */
 
 	/* Flash: CS0 timings setup */
-	omap_writel(0x0000fff3, OMAP730_FLASH_CFG_0);
-	omap_writel(0x00000088, OMAP730_FLASH_ACFG_0);
+	omap_writel(0x0000fff3, OMAP7XX_FLASH_CFG_0);
+	omap_writel(0x00000088, OMAP7XX_FLASH_ACFG_0);
 
 	/*
 	 * Ethernet support through the debug board
 	 * CS1 timings setup
 	 */
-	omap_writel(0x0000fff3, OMAP730_FLASH_CFG_1);
-	omap_writel(0x00000000, OMAP730_FLASH_ACFG_1);
+	omap_writel(0x0000fff3, OMAP7XX_FLASH_CFG_1);
+	omap_writel(0x00000000, OMAP7XX_FLASH_ACFG_1);
 
 	/*
 	 * Configure MPU_EXT_NIRQ IO in IO_CONF9 register,
 	 * It is used as the Ethernet controller interrupt
 	 */
-	omap_writel(omap_readl(OMAP730_IO_CONF_9) & 0x1FFFFFFF, OMAP730_IO_CONF_9);
+	omap_writel(omap_readl(OMAP7XX_IO_CONF_9) & 0x1FFFFFFF, OMAP7XX_IO_CONF_9);
 }
 
 MACHINE_START(OMAP_FSAMPLE, "OMAP730 F-Sample")
diff --git a/arch/arm/mach-omap1/board-perseus2.c b/arch/arm/mach-omap1/board-perseus2.c
index 8340669..2f897cf 100644
--- a/arch/arm/mach-omap1/board-perseus2.c
+++ b/arch/arm/mach-omap1/board-perseus2.c
@@ -74,7 +74,7 @@ static struct resource smc91x_resources[] = {
 		.flags	= IORESOURCE_MEM,
 	},
 	[1] = {
-		.start	= INT_730_MPU_EXT_NIRQ,
+		.start	= INT_7XX_MPU_EXT_NIRQ,
 		.end	= 0,
 		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHEDGE,
 	},
@@ -163,8 +163,8 @@ static struct platform_device smc91x_device = {
 
 static struct resource kp_resources[] = {
 	[0] = {
-		.start	= INT_730_MPUIO_KEYPAD,
-		.end	= INT_730_MPUIO_KEYPAD,
+		.start	= INT_7XX_MPUIO_KEYPAD,
+		.end	= INT_7XX_MPUIO_KEYPAD,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
@@ -270,7 +270,7 @@ static void __init omap_perseus2_map_io(void)
 	/*
 	 * Hold GSM Reset until needed
 	 */
-	omap_writew(omap_readw(OMAP730_DSP_M_CTL) & ~1, OMAP730_DSP_M_CTL);
+	omap_writew(omap_readw(OMAP7XX_DSP_M_CTL) & ~1, OMAP7XX_DSP_M_CTL);
 
 	/*
 	 * UARTs -> done automagically by 8250 driver
@@ -281,21 +281,21 @@ static void __init omap_perseus2_map_io(void)
 	 */
 
 	/* Flash: CS0 timings setup */
-	omap_writel(0x0000fff3, OMAP730_FLASH_CFG_0);
-	omap_writel(0x00000088, OMAP730_FLASH_ACFG_0);
+	omap_writel(0x0000fff3, OMAP7XX_FLASH_CFG_0);
+	omap_writel(0x00000088, OMAP7XX_FLASH_ACFG_0);
 
 	/*
 	 * Ethernet support through the debug board
 	 * CS1 timings setup
 	 */
-	omap_writel(0x0000fff3, OMAP730_FLASH_CFG_1);
-	omap_writel(0x00000000, OMAP730_FLASH_ACFG_1);
+	omap_writel(0x0000fff3, OMAP7XX_FLASH_CFG_1);
+	omap_writel(0x00000000, OMAP7XX_FLASH_ACFG_1);
 
 	/*
 	 * Configure MPU_EXT_NIRQ IO in IO_CONF9 register,
 	 * It is used as the Ethernet controller interrupt
 	 */
-	omap_writel(omap_readl(OMAP730_IO_CONF_9) & 0x1FFFFFFF, OMAP730_IO_CONF_9);
+	omap_writel(omap_readl(OMAP7XX_IO_CONF_9) & 0x1FFFFFFF, OMAP7XX_IO_CONF_9);
 }
 
 MACHINE_START(OMAP_PERSEUS2, "OMAP730 Perseus2")
diff --git a/arch/arm/mach-omap1/clock.c b/arch/arm/mach-omap1/clock.c
index 436eed2..5f77b83 100644
--- a/arch/arm/mach-omap1/clock.c
+++ b/arch/arm/mach-omap1/clock.c
@@ -69,13 +69,13 @@ struct omap_clk {
 	}
 
 #define CK_310	(1 << 0)
-#define CK_730	(1 << 1)
+#define CK_7XX	(1 << 1)
 #define CK_1510	(1 << 2)
 #define CK_16XX	(1 << 3)
 
 static struct omap_clk omap_clks[] = {
 	/* non-ULPD clocks */
-	CLK(NULL,	"ck_ref",	&ck_ref,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"ck_ref",	&ck_ref,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK(NULL,	"ck_dpll1",	&ck_dpll1,	CK_16XX | CK_1510 | CK_310),
 	/* CK_GEN1 clocks */
 	CLK(NULL,	"ck_dpll1out",	&ck_dpll1out.clk, CK_16XX),
@@ -83,7 +83,7 @@ static struct omap_clk omap_clks[] = {
 	CLK(NULL,	"arm_ck",	&arm_ck,	CK_16XX | CK_1510 | CK_310),
 	CLK(NULL,	"armper_ck",	&armper_ck.clk,	CK_16XX | CK_1510 | CK_310),
 	CLK(NULL,	"arm_gpio_ck",	&arm_gpio_ck,	CK_1510 | CK_310),
-	CLK(NULL,	"armxor_ck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310),
+	CLK(NULL,	"armxor_ck",	&armxor_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK(NULL,	"armtim_ck",	&armtim_ck.clk,	CK_16XX | CK_1510 | CK_310),
 	CLK("omap_wdt",	"fck",		&armwdt_ck.clk,	CK_16XX | CK_1510 | CK_310),
 	CLK("omap_wdt",	"ick",		&armper_ck.clk,	CK_16XX),
@@ -97,7 +97,7 @@ static struct omap_clk omap_clks[] = {
 	CLK(NULL,	"dspxor_ck",	&dspxor_ck,	CK_16XX | CK_1510 | CK_310),
 	CLK(NULL,	"dsptim_ck",	&dsptim_ck,	CK_16XX | CK_1510 | CK_310),
 	/* CK_GEN3 clocks */
-	CLK(NULL,	"tc_ck",	&tc_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_730),
+	CLK(NULL,	"tc_ck",	&tc_ck.clk,	CK_16XX | CK_1510 | CK_310 | CK_7XX),
 	CLK(NULL,	"tipb_ck",	&tipb_ck,	CK_1510 | CK_310),
 	CLK(NULL,	"l3_ocpi_ck",	&l3_ocpi_ck,	CK_16XX),
 	CLK(NULL,	"tc1_ck",	&tc1_ck,	CK_16XX),
@@ -108,7 +108,7 @@ static struct omap_clk omap_clks[] = {
 	CLK(NULL,	"lb_ck",	&lb_ck.clk,	CK_1510 | CK_310),
 	CLK(NULL,	"rhea1_ck",	&rhea1_ck,	CK_16XX),
 	CLK(NULL,	"rhea2_ck",	&rhea2_ck,	CK_16XX),
-	CLK(NULL,	"lcd_ck",	&lcd_ck_16xx,	CK_16XX | CK_730),
+	CLK(NULL,	"lcd_ck",	&lcd_ck_16xx,	CK_16XX | CK_7XX),
 	CLK(NULL,	"lcd_ck",	&lcd_ck_1510.clk, CK_1510 | CK_310),
 	/* ULPD clocks */
 	CLK(NULL,	"uart1_ck",	&uart1_1510,	CK_1510 | CK_310),
@@ -398,7 +398,7 @@ static int omap1_select_table_rate(struct clk * clk, unsigned long rate)
 	 * Reprogramming the DPLL is tricky, it must be done from SRAM.
 	 * (on 730, bit 13 must always be 1)
 	 */
-	if (cpu_is_omap730())
+	if (cpu_is_omap7xx())
 		omap_sram_reprogram_clock(ptr->dpllctl_val, ptr->ckctl_val | 0x2000);
 	else
 		omap_sram_reprogram_clock(ptr->dpllctl_val, ptr->ckctl_val);
@@ -783,8 +783,8 @@ int __init omap1_clk_init(void)
 		cpu_mask |= CK_16XX;
 	if (cpu_is_omap1510())
 		cpu_mask |= CK_1510;
-	if (cpu_is_omap730())
-		cpu_mask |= CK_730;
+	if (cpu_is_omap7xx())
+		cpu_mask |= CK_7XX;
 	if (cpu_is_omap310())
 		cpu_mask |= CK_310;
 
@@ -800,7 +800,7 @@ int __init omap1_clk_init(void)
 			crystal_type = info->system_clock_type;
 	}
 
-#if defined(CONFIG_ARCH_OMAP730)
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
 	ck_ref.rate = 13000000;
 #elif defined(CONFIG_ARCH_OMAP16XX)
 	if (crystal_type == 2)
@@ -847,7 +847,7 @@ int __init omap1_clk_init(void)
 		printk(KERN_ERR "System frequencies not set. Check your config.\n");
 		/* Guess sane values (60MHz) */
 		omap_writew(0x2290, DPLL_CTL);
-		omap_writew(cpu_is_omap730() ? 0x3005 : 0x1005, ARM_CKCTL);
+		omap_writew(cpu_is_omap7xx() ? 0x3005 : 0x1005, ARM_CKCTL);
 		ck_dpll1.rate = 60000000;
 	}
 #endif
@@ -862,7 +862,7 @@ int __init omap1_clk_init(void)
 
 #if defined(CONFIG_MACH_OMAP_PERSEUS2) || defined(CONFIG_MACH_OMAP_FSAMPLE)
 	/* Select slicer output as OMAP input clock */
-	omap_writew(omap_readw(OMAP730_PCC_UPLD_CTRL) & ~0x1, OMAP730_PCC_UPLD_CTRL);
+	omap_writew(omap_readw(OMAP7XX_PCC_UPLD_CTRL) & ~0x1, OMAP7XX_PCC_UPLD_CTRL);
 #endif
 
 	/* Amstrad Delta wants BCLK high when inactive */
@@ -873,7 +873,7 @@ int __init omap1_clk_init(void)
 
 	/* Turn off DSP and ARM_TIMXO. Make sure ARM_INTHCK is not divided */
 	/* (on 730, bit 13 must not be cleared) */
-	if (cpu_is_omap730())
+	if (cpu_is_omap7xx())
 		omap_writew(omap_readw(ARM_CKCTL) & 0x2fff, ARM_CKCTL);
 	else
 		omap_writew(omap_readw(ARM_CKCTL) & 0x0fff, ARM_CKCTL);
diff --git a/arch/arm/mach-omap1/io.c b/arch/arm/mach-omap1/io.c
index 7030f92..a27df2c 100644
--- a/arch/arm/mach-omap1/io.c
+++ b/arch/arm/mach-omap1/io.c
@@ -36,33 +36,17 @@ static struct map_desc omap_io_desc[] __initdata = {
 	}
 };
 
-#ifdef CONFIG_ARCH_OMAP730
-static struct map_desc omap730_io_desc[] __initdata = {
+#if defined (CONFIG_ARCH_OMAP730) || defined (CONFIG_ARCH_OMAP850)
+static struct map_desc omap7xx_io_desc[] __initdata = {
 	{
-		.virtual	= OMAP730_DSP_BASE,
-		.pfn		= __phys_to_pfn(OMAP730_DSP_START),
-		.length		= OMAP730_DSP_SIZE,
+		.virtual	= OMAP7XX_DSP_BASE,
+		.pfn		= __phys_to_pfn(OMAP7XX_DSP_START),
+		.length		= OMAP7XX_DSP_SIZE,
 		.type		= MT_DEVICE
 	}, {
-		.virtual	= OMAP730_DSPREG_BASE,
-		.pfn		= __phys_to_pfn(OMAP730_DSPREG_START),
-		.length		= OMAP730_DSPREG_SIZE,
-		.type		= MT_DEVICE
-	}
-};
-#endif
-
-#ifdef CONFIG_ARCH_OMAP850
-static struct map_desc omap850_io_desc[] __initdata = {
-	{
-		.virtual	= OMAP850_DSP_BASE,
-		.pfn		= __phys_to_pfn(OMAP850_DSP_START),
-		.length		= OMAP850_DSP_SIZE,
-		.type		= MT_DEVICE
-	}, {
-		.virtual	= OMAP850_DSPREG_BASE,
-		.pfn		= __phys_to_pfn(OMAP850_DSPREG_START),
-		.length		= OMAP850_DSPREG_SIZE,
+		.virtual	= OMAP7XX_DSPREG_BASE,
+		.pfn		= __phys_to_pfn(OMAP7XX_DSPREG_START),
+		.length		= OMAP7XX_DSPREG_SIZE,
 		.type		= MT_DEVICE
 	}
 };
@@ -120,18 +104,11 @@ void __init omap1_map_common_io(void)
 	 */
 	omap_check_revision();
 
-#ifdef CONFIG_ARCH_OMAP730
-	if (cpu_is_omap730()) {
-		iotable_init(omap730_io_desc, ARRAY_SIZE(omap730_io_desc));
-	}
-#endif
-
-#ifdef CONFIG_ARCH_OMAP850
-	if (cpu_is_omap850()) {
-		iotable_init(omap850_io_desc, ARRAY_SIZE(omap850_io_desc));
+#if defined (CONFIG_ARCH_OMAP730) || defined (CONFIG_ARCH_OMAP850)
+	if (cpu_is_omap7xx()) {
+		iotable_init(omap7xx_io_desc, ARRAY_SIZE(omap7xx_io_desc));
 	}
 #endif
-
 #ifdef CONFIG_ARCH_OMAP15XX
 	if (cpu_is_omap15xx()) {
 		iotable_init(omap1510_io_desc, ARRAY_SIZE(omap1510_io_desc));
diff --git a/arch/arm/mach-omap1/irq.c b/arch/arm/mach-omap1/irq.c
index de03c84..8f98b58 100644
--- a/arch/arm/mach-omap1/irq.c
+++ b/arch/arm/mach-omap1/irq.c
@@ -137,16 +137,8 @@ static void omap_irq_set_cfg(int irq, int fiq, int priority, int trigger)
 	irq_bank_writel(val, bank, offset);
 }
 
-#ifdef CONFIG_ARCH_OMAP730
-static struct omap_irq_bank omap730_irq_banks[] = {
-	{ .base_reg = OMAP_IH1_BASE,		.trigger_map = 0xb3f8e22f },
-	{ .base_reg = OMAP_IH2_BASE,		.trigger_map = 0xfdb9c1f2 },
-	{ .base_reg = OMAP_IH2_BASE + 0x100,	.trigger_map = 0x800040f3 },
-};
-#endif
-
-#ifdef CONFIG_ARCH_OMAP850
-static struct omap_irq_bank omap850_irq_banks[] = {
+#if defined (CONFIG_ARCH_OMAP730) || defined (CONFIG_ARCH_OMAP850)
+static struct omap_irq_bank omap7xx_irq_banks[] = {
 	{ .base_reg = OMAP_IH1_BASE,		.trigger_map = 0xb3f8e22f },
 	{ .base_reg = OMAP_IH2_BASE,		.trigger_map = 0xfdb9c1f2 },
 	{ .base_reg = OMAP_IH2_BASE + 0x100,	.trigger_map = 0x800040f3 },
@@ -186,16 +178,10 @@ void __init omap_init_irq(void)
 {
 	int i, j;
 
-#ifdef CONFIG_ARCH_OMAP730
-	if (cpu_is_omap730()) {
-		irq_banks = omap730_irq_banks;
-		irq_bank_count = ARRAY_SIZE(omap730_irq_banks);
-	}
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	if (cpu_is_omap850()) {
-		irq_banks = omap850_irq_banks;
-		irq_bank_count = ARRAY_SIZE(omap850_irq_banks);
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	if (cpu_is_omap7xx()) {
+		irq_banks = omap7xx_irq_banks;
+		irq_bank_count = ARRAY_SIZE(omap7xx_irq_banks);
 	}
 #endif
 #ifdef CONFIG_ARCH_OMAP15XX
@@ -247,10 +233,8 @@ void __init omap_init_irq(void)
 
 	/* Unmask level 2 handler */
 
-	if (cpu_is_omap730())
-		omap_unmask_irq(INT_730_IH2_IRQ);
-	else if (cpu_is_omap850())
-		omap_unmask_irq(INT_850_IH2_IRQ);
+	if (cpu_is_omap7xx())
+		omap_unmask_irq(INT_7XX_IH2_IRQ);
 	else if (cpu_is_omap15xx())
 		omap_unmask_irq(INT_1510_IH2_IRQ);
 	else if (cpu_is_omap16xx())
diff --git a/arch/arm/mach-omap1/mcbsp.c b/arch/arm/mach-omap1/mcbsp.c
index 505d98c..3a51cb2 100644
--- a/arch/arm/mach-omap1/mcbsp.c
+++ b/arch/arm/mach-omap1/mcbsp.c
@@ -79,29 +79,29 @@ static struct omap_mcbsp_ops omap1_mcbsp_ops = {
 	.free		= omap1_mcbsp_free,
 };
 
-#ifdef CONFIG_ARCH_OMAP730
-static struct omap_mcbsp_platform_data omap730_mcbsp_pdata[] = {
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+static struct omap_mcbsp_platform_data omap7xx_mcbsp_pdata[] = {
 	{
-		.phys_base	= OMAP730_MCBSP1_BASE,
+		.phys_base	= OMAP7XX_MCBSP1_BASE,
 		.dma_rx_sync	= OMAP_DMA_MCBSP1_RX,
 		.dma_tx_sync	= OMAP_DMA_MCBSP1_TX,
-		.rx_irq		= INT_730_McBSP1RX,
-		.tx_irq		= INT_730_McBSP1TX,
+		.rx_irq		= INT_7XX_McBSP1RX,
+		.tx_irq		= INT_7XX_McBSP1TX,
 		.ops		= &omap1_mcbsp_ops,
 	},
 	{
-		.phys_base	= OMAP730_MCBSP2_BASE,
+		.phys_base	= OMAP7XX_MCBSP2_BASE,
 		.dma_rx_sync	= OMAP_DMA_MCBSP3_RX,
 		.dma_tx_sync	= OMAP_DMA_MCBSP3_TX,
-		.rx_irq		= INT_730_McBSP2RX,
-		.tx_irq		= INT_730_McBSP2TX,
+		.rx_irq		= INT_7XX_McBSP2RX,
+		.tx_irq		= INT_7XX_McBSP2TX,
 		.ops		= &omap1_mcbsp_ops,
 	},
 };
-#define OMAP730_MCBSP_PDATA_SZ		ARRAY_SIZE(omap730_mcbsp_pdata)
+#define OMAP7XX_MCBSP_PDATA_SZ		ARRAY_SIZE(omap7xx_mcbsp_pdata)
 #else
-#define omap730_mcbsp_pdata		NULL
-#define OMAP730_MCBSP_PDATA_SZ		0
+#define omap7xx_mcbsp_pdata		NULL
+#define OMAP7XX_MCBSP_PDATA_SZ		0
 #endif
 
 #ifdef CONFIG_ARCH_OMAP15XX
@@ -172,8 +172,8 @@ static struct omap_mcbsp_platform_data omap16xx_mcbsp_pdata[] = {
 
 int __init omap1_mcbsp_init(void)
 {
-	if (cpu_is_omap730())
-		omap_mcbsp_count = OMAP730_MCBSP_PDATA_SZ;
+	if (cpu_is_omap7xx())
+		omap_mcbsp_count = OMAP7XX_MCBSP_PDATA_SZ;
 	if (cpu_is_omap15xx())
 		omap_mcbsp_count = OMAP15XX_MCBSP_PDATA_SZ;
 	if (cpu_is_omap16xx())
@@ -184,9 +184,9 @@ int __init omap1_mcbsp_init(void)
 	if (!mcbsp_ptr)
 		return -ENOMEM;
 
-	if (cpu_is_omap730())
-		omap_mcbsp_register_board_cfg(omap730_mcbsp_pdata,
-						OMAP730_MCBSP_PDATA_SZ);
+	if (cpu_is_omap7xx())
+		omap_mcbsp_register_board_cfg(omap7xx_mcbsp_pdata,
+						OMAP7XX_MCBSP_PDATA_SZ);
 
 	if (cpu_is_omap15xx())
 		omap_mcbsp_register_board_cfg(omap15xx_mcbsp_pdata,
diff --git a/arch/arm/mach-omap1/mux.c b/arch/arm/mach-omap1/mux.c
index 721e0d9..d59899d 100644
--- a/arch/arm/mach-omap1/mux.c
+++ b/arch/arm/mach-omap1/mux.c
@@ -35,47 +35,28 @@
 
 static struct omap_mux_cfg arch_mux_cfg;
 
-#ifdef CONFIG_ARCH_OMAP730
-static struct pin_config __initdata_or_module omap730_pins[] = {
-MUX_CFG_730("E2_730_KBR0",        12,   21,    0,   20,   1, 0)
-MUX_CFG_730("J7_730_KBR1",        12,   25,    0,   24,   1, 0)
-MUX_CFG_730("E1_730_KBR2",        12,   29,    0,   28,   1, 0)
-MUX_CFG_730("F3_730_KBR3",        13,    1,    0,    0,   1, 0)
-MUX_CFG_730("D2_730_KBR4",        13,    5,    0,    4,   1, 0)
-MUX_CFG_730("C2_730_KBC0",        13,    9,    0,    8,   1, 0)
-MUX_CFG_730("D3_730_KBC1",        13,   13,    0,   12,   1, 0)
-MUX_CFG_730("E4_730_KBC2",        13,   17,    0,   16,   1, 0)
-MUX_CFG_730("F4_730_KBC3",        13,   21,    0,   20,   1, 0)
-MUX_CFG_730("E3_730_KBC4",        13,   25,    0,   24,   1, 0)
-
-MUX_CFG_730("AA17_730_USB_DM",     2,   21,    0,   20,   0, 0)
-MUX_CFG_730("W16_730_USB_PU_EN",   2,   25,    0,   24,   0, 0)
-MUX_CFG_730("W17_730_USB_VBUSI",   2,   29,    0,   28,   0, 0)
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+static struct pin_config __initdata_or_module omap7xx_pins[] = {
+MUX_CFG_7XX("E2_7XX_KBR0",        12,   21,    0,   20,   1, 0)
+MUX_CFG_7XX("J7_7XX_KBR1",        12,   25,    0,   24,   1, 0)
+MUX_CFG_7XX("E1_7XX_KBR2",        12,   29,    0,   28,   1, 0)
+MUX_CFG_7XX("F3_7XX_KBR3",        13,    1,    0,    0,   1, 0)
+MUX_CFG_7XX("D2_7XX_KBR4",        13,    5,    0,    4,   1, 0)
+MUX_CFG_7XX("C2_7XX_KBC0",        13,    9,    0,    8,   1, 0)
+MUX_CFG_7XX("D3_7XX_KBC1",        13,   13,    0,   12,   1, 0)
+MUX_CFG_7XX("E4_7XX_KBC2",        13,   17,    0,   16,   1, 0)
+MUX_CFG_7XX("F4_7XX_KBC3",        13,   21,    0,   20,   1, 0)
+MUX_CFG_7XX("E3_7XX_KBC4",        13,   25,    0,   24,   1, 0)
+
+MUX_CFG_7XX("AA17_7XX_USB_DM",     2,   21,    0,   20,   0, 0)
+MUX_CFG_7XX("W16_7XX_USB_PU_EN",   2,   25,    0,   24,   0, 0)
+MUX_CFG_7XX("W17_7XX_USB_VBUSI",   2,   29,    0,   28,   0, 0)
 };
-#define OMAP730_PINS_SZ		ARRAY_SIZE(omap730_pins)
+#define OMAP7XX_PINS_SZ		ARRAY_SIZE(omap7xx_pins)
 #else
-#define omap730_pins		NULL
-#define OMAP730_PINS_SZ		0
-#endif	/* CONFIG_ARCH_OMAP730 */
-
-#ifdef CONFIG_ARCH_OMAP850
-struct pin_config __initdata_or_module omap850_pins[] = {
-MUX_CFG_850("E2_850_KBR0",        12,   21,    0,   20,   1, 0)
-MUX_CFG_850("J7_850_KBR1",        12,   25,    0,   24,   1, 0)
-MUX_CFG_850("E1_850_KBR2",        12,   29,    0,   28,   1, 0)
-MUX_CFG_850("F3_850_KBR3",        13,    1,    0,    0,   1, 0)
-MUX_CFG_850("D2_850_KBR4",        13,    5,    0,    4,   1, 0)
-MUX_CFG_850("C2_850_KBC0",        13,    9,    0,    8,   1, 0)
-MUX_CFG_850("D3_850_KBC1",        13,   13,    0,   12,   1, 0)
-MUX_CFG_850("E4_850_KBC2",        13,   17,    0,   16,   1, 0)
-MUX_CFG_850("F4_850_KBC3",        13,   21,    0,   20,   1, 0)
-MUX_CFG_850("E3_850_KBC4",        13,   25,    0,   24,   1, 0)
-
-MUX_CFG_850("AA17_850_USB_DM",     2,   21,    0,   20,   0, 0)
-MUX_CFG_850("W16_850_USB_PU_EN",   2,   25,    0,   24,   0, 0)
-MUX_CFG_850("W17_850_USB_VBUSI",   2,   29,    0,   28,   0, 0)
-};
-#endif
+#define omap7xx_pins		NULL
+#define OMAP7XX_PINS_SZ		0
+#endif	/* CONFIG_ARCH_OMAP730 || CONFIG_ARCH_OMAP850 */
 
 #if defined(CONFIG_ARCH_OMAP15XX) || defined(CONFIG_ARCH_OMAP16XX)
 static struct pin_config __initdata_or_module omap1xxx_pins[] = {
@@ -438,11 +419,6 @@ int __init_or_module omap1_cfg_reg(const struct pin_config *cfg)
 			printk("      %s (0x%08x) = 0x%08x -> 0x%08x\n",
 			       cfg->pull_name, cfg->pull_reg, pull_orig, pull);
 	}
-
-#ifdef CONFIG_ARCH_OMAP850
-	omap_mux_register(omap850_pins, ARRAY_SIZE(omap850_pins));
-#endif
-
 #endif
 
 #ifdef CONFIG_OMAP_MUX_ERRORS
@@ -454,9 +430,9 @@ int __init_or_module omap1_cfg_reg(const struct pin_config *cfg)
 
 int __init omap1_mux_init(void)
 {
-	if (cpu_is_omap730()) {
-		arch_mux_cfg.pins	= omap730_pins;
-		arch_mux_cfg.size	= OMAP730_PINS_SZ;
+	if (cpu_is_omap7xx()) {
+		arch_mux_cfg.pins	= omap7xx_pins;
+		arch_mux_cfg.size	= OMAP7XX_PINS_SZ;
 		arch_mux_cfg.cfg_reg	= omap1_cfg_reg;
 	}
 
diff --git a/arch/arm/mach-omap1/pm.c b/arch/arm/mach-omap1/pm.c
index 5218943..10f4e4a 100644
--- a/arch/arm/mach-omap1/pm.c
+++ b/arch/arm/mach-omap1/pm.c
@@ -62,7 +62,7 @@
 static unsigned int arm_sleep_save[ARM_SLEEP_SAVE_SIZE];
 static unsigned short dsp_sleep_save[DSP_SLEEP_SAVE_SIZE];
 static unsigned short ulpd_sleep_save[ULPD_SLEEP_SAVE_SIZE];
-static unsigned int mpui730_sleep_save[MPUI730_SLEEP_SAVE_SIZE];
+static unsigned int mpui7xx_sleep_save[MPUI7XX_SLEEP_SAVE_SIZE];
 static unsigned int mpui1510_sleep_save[MPUI1510_SLEEP_SAVE_SIZE];
 static unsigned int mpui1610_sleep_save[MPUI1610_SLEEP_SAVE_SIZE];
 
@@ -183,9 +183,9 @@ static void omap_pm_wakeup_setup(void)
 	 * drivers must still separately call omap_set_gpio_wakeup() to
 	 * wake up to a GPIO interrupt.
 	 */
-	if (cpu_is_omap730())
-		level1_wake = OMAP_IRQ_BIT(INT_730_GPIO_BANK1) |
-			OMAP_IRQ_BIT(INT_730_IH2_IRQ);
+	if (cpu_is_omap7xx())
+		level1_wake = OMAP_IRQ_BIT(INT_7XX_GPIO_BANK1) |
+			OMAP_IRQ_BIT(INT_7XX_IH2_IRQ);
 	else if (cpu_is_omap15xx())
 		level1_wake = OMAP_IRQ_BIT(INT_GPIO_BANK1) |
 			OMAP_IRQ_BIT(INT_1510_IH2_IRQ);
@@ -195,10 +195,10 @@ static void omap_pm_wakeup_setup(void)
 
 	omap_writel(~level1_wake, OMAP_IH1_MIR);
 
-	if (cpu_is_omap730()) {
+	if (cpu_is_omap7xx()) {
 		omap_writel(~level2_wake, OMAP_IH2_0_MIR);
-		omap_writel(~(OMAP_IRQ_BIT(INT_730_WAKE_UP_REQ) |
-				OMAP_IRQ_BIT(INT_730_MPUIO_KEYPAD)),
+		omap_writel(~(OMAP_IRQ_BIT(INT_7XX_WAKE_UP_REQ) |
+				OMAP_IRQ_BIT(INT_7XX_MPUIO_KEYPAD)),
 				OMAP_IH2_1_MIR);
 	} else if (cpu_is_omap15xx()) {
 		level2_wake |= OMAP_IRQ_BIT(INT_KEYBOARD);
@@ -253,15 +253,15 @@ void omap1_pm_suspend(void)
 	 * Save interrupt, MPUI, ARM and UPLD control registers.
 	 */
 
-	if (cpu_is_omap730()) {
-		MPUI730_SAVE(OMAP_IH1_MIR);
-		MPUI730_SAVE(OMAP_IH2_0_MIR);
-		MPUI730_SAVE(OMAP_IH2_1_MIR);
-		MPUI730_SAVE(MPUI_CTRL);
-		MPUI730_SAVE(MPUI_DSP_BOOT_CONFIG);
-		MPUI730_SAVE(MPUI_DSP_API_CONFIG);
-		MPUI730_SAVE(EMIFS_CONFIG);
-		MPUI730_SAVE(EMIFF_SDRAM_CONFIG);
+	if (cpu_is_omap7xx()) {
+		MPUI7XX_SAVE(OMAP_IH1_MIR);
+		MPUI7XX_SAVE(OMAP_IH2_0_MIR);
+		MPUI7XX_SAVE(OMAP_IH2_1_MIR);
+		MPUI7XX_SAVE(MPUI_CTRL);
+		MPUI7XX_SAVE(MPUI_DSP_BOOT_CONFIG);
+		MPUI7XX_SAVE(MPUI_DSP_API_CONFIG);
+		MPUI7XX_SAVE(EMIFS_CONFIG);
+		MPUI7XX_SAVE(EMIFF_SDRAM_CONFIG);
 
 	} else if (cpu_is_omap15xx()) {
 		MPUI1510_SAVE(OMAP_IH1_MIR);
@@ -306,7 +306,7 @@ void omap1_pm_suspend(void)
 	omap_writew(omap_readw(ARM_RSTCT1) & ~(1 << DSP_EN), ARM_RSTCT1);
 
 		/* shut down dsp_ck */
-	if (!cpu_is_omap730())
+	if (!cpu_is_omap7xx())
 		omap_writew(omap_readw(ARM_CKCTL) & ~(1 << EN_DSPCK), ARM_CKCTL);
 
 	/* temporarily enabling api_ck to access DSP registers */
@@ -383,12 +383,12 @@ void omap1_pm_suspend(void)
 	ULPD_RESTORE(ULPD_CLOCK_CTRL);
 	ULPD_RESTORE(ULPD_STATUS_REQ);
 
-	if (cpu_is_omap730()) {
-		MPUI730_RESTORE(EMIFS_CONFIG);
-		MPUI730_RESTORE(EMIFF_SDRAM_CONFIG);
-		MPUI730_RESTORE(OMAP_IH1_MIR);
-		MPUI730_RESTORE(OMAP_IH2_0_MIR);
-		MPUI730_RESTORE(OMAP_IH2_1_MIR);
+	if (cpu_is_omap7xx()) {
+		MPUI7XX_RESTORE(EMIFS_CONFIG);
+		MPUI7XX_RESTORE(EMIFF_SDRAM_CONFIG);
+		MPUI7XX_RESTORE(OMAP_IH1_MIR);
+		MPUI7XX_RESTORE(OMAP_IH2_0_MIR);
+		MPUI7XX_RESTORE(OMAP_IH2_1_MIR);
 	} else if (cpu_is_omap15xx()) {
 		MPUI1510_RESTORE(MPUI_CTRL);
 		MPUI1510_RESTORE(MPUI_DSP_BOOT_CONFIG);
@@ -461,13 +461,13 @@ static int omap_pm_read_proc(
 	ULPD_SAVE(ULPD_DPLL_CTRL);
 	ULPD_SAVE(ULPD_POWER_CTRL);
 
-	if (cpu_is_omap730()) {
-		MPUI730_SAVE(MPUI_CTRL);
-		MPUI730_SAVE(MPUI_DSP_STATUS);
-		MPUI730_SAVE(MPUI_DSP_BOOT_CONFIG);
-		MPUI730_SAVE(MPUI_DSP_API_CONFIG);
-		MPUI730_SAVE(EMIFF_SDRAM_CONFIG);
-		MPUI730_SAVE(EMIFS_CONFIG);
+	if (cpu_is_omap7xx()) {
+		MPUI7XX_SAVE(MPUI_CTRL);
+		MPUI7XX_SAVE(MPUI_DSP_STATUS);
+		MPUI7XX_SAVE(MPUI_DSP_BOOT_CONFIG);
+		MPUI7XX_SAVE(MPUI_DSP_API_CONFIG);
+		MPUI7XX_SAVE(EMIFF_SDRAM_CONFIG);
+		MPUI7XX_SAVE(EMIFS_CONFIG);
 	} else if (cpu_is_omap15xx()) {
 		MPUI1510_SAVE(MPUI_CTRL);
 		MPUI1510_SAVE(MPUI_DSP_STATUS);
@@ -517,20 +517,20 @@ static int omap_pm_read_proc(
 		   ULPD_SHOW(ULPD_STATUS_REQ),
 		   ULPD_SHOW(ULPD_POWER_CTRL));
 
-		if (cpu_is_omap730()) {
+		if (cpu_is_omap7xx()) {
 			my_buffer_offset += sprintf(my_base + my_buffer_offset,
-			   "MPUI730_CTRL_REG	     0x%-8x \n"
-			   "MPUI730_DSP_STATUS_REG:      0x%-8x \n"
-			   "MPUI730_DSP_BOOT_CONFIG_REG: 0x%-8x \n"
-			   "MPUI730_DSP_API_CONFIG_REG:  0x%-8x \n"
-			   "MPUI730_SDRAM_CONFIG_REG:    0x%-8x \n"
-			   "MPUI730_EMIFS_CONFIG_REG:    0x%-8x \n",
-			   MPUI730_SHOW(MPUI_CTRL),
-			   MPUI730_SHOW(MPUI_DSP_STATUS),
-			   MPUI730_SHOW(MPUI_DSP_BOOT_CONFIG),
-			   MPUI730_SHOW(MPUI_DSP_API_CONFIG),
-			   MPUI730_SHOW(EMIFF_SDRAM_CONFIG),
-			   MPUI730_SHOW(EMIFS_CONFIG));
+			   "MPUI7XX_CTRL_REG	     0x%-8x \n"
+			   "MPUI7XX_DSP_STATUS_REG:      0x%-8x \n"
+			   "MPUI7XX_DSP_BOOT_CONFIG_REG: 0x%-8x \n"
+			   "MPUI7XX_DSP_API_CONFIG_REG:  0x%-8x \n"
+			   "MPUI7XX_SDRAM_CONFIG_REG:    0x%-8x \n"
+			   "MPUI7XX_EMIFS_CONFIG_REG:    0x%-8x \n",
+			   MPUI7XX_SHOW(MPUI_CTRL),
+			   MPUI7XX_SHOW(MPUI_DSP_STATUS),
+			   MPUI7XX_SHOW(MPUI_DSP_BOOT_CONFIG),
+			   MPUI7XX_SHOW(MPUI_DSP_API_CONFIG),
+			   MPUI7XX_SHOW(EMIFF_SDRAM_CONFIG),
+			   MPUI7XX_SHOW(EMIFS_CONFIG));
 		} else if (cpu_is_omap15xx()) {
 			my_buffer_offset += sprintf(my_base + my_buffer_offset,
 			   "MPUI1510_CTRL_REG             0x%-8x \n"
@@ -668,9 +668,9 @@ static int __init omap_pm_init(void)
 	 * These routines need to be in SRAM as that's the only
 	 * memory the MPU can see when it wakes up.
 	 */
-	if (cpu_is_omap730()) {
-		omap_sram_suspend = omap_sram_push(omap730_cpu_suspend,
-						   omap730_cpu_suspend_sz);
+	if (cpu_is_omap7xx()) {
+		omap_sram_suspend = omap_sram_push(omap7xx_cpu_suspend,
+						   omap7xx_cpu_suspend_sz);
 	} else if (cpu_is_omap15xx()) {
 		omap_sram_suspend = omap_sram_push(omap1510_cpu_suspend,
 						   omap1510_cpu_suspend_sz);
@@ -686,8 +686,8 @@ static int __init omap_pm_init(void)
 
 	pm_idle = omap1_pm_idle;
 
-	if (cpu_is_omap730())
-		setup_irq(INT_730_WAKE_UP_REQ, &omap_wakeup_irq);
+	if (cpu_is_omap7xx())
+		setup_irq(INT_7XX_WAKE_UP_REQ, &omap_wakeup_irq);
 	else if (cpu_is_omap16xx())
 		setup_irq(INT_1610_WAKE_UP_REQ, &omap_wakeup_irq);
 
@@ -700,8 +700,8 @@ static int __init omap_pm_init(void)
 	omap_writew(ULPD_POWER_CTRL_REG_VAL, ULPD_POWER_CTRL);
 
 	/* Configure IDLECT3 */
-	if (cpu_is_omap730())
-		omap_writel(OMAP730_IDLECT3_VAL, OMAP730_IDLECT3);
+	if (cpu_is_omap7xx())
+		omap_writel(OMAP7XX_IDLECT3_VAL, OMAP7XX_IDLECT3);
 	else if (cpu_is_omap16xx())
 		omap_writel(OMAP1610_IDLECT3_VAL, OMAP1610_IDLECT3);
 
diff --git a/arch/arm/mach-omap1/pm.h b/arch/arm/mach-omap1/pm.h
index c4f05bd..56a6479 100644
--- a/arch/arm/mach-omap1/pm.h
+++ b/arch/arm/mach-omap1/pm.h
@@ -98,13 +98,14 @@
 #define OMAP1610_IDLECT3		0xfffece24
 #define OMAP1610_IDLE_LOOP_REQUEST	0x0400
 
-#define OMAP730_IDLECT1_SLEEP_VAL	0x16c7
-#define OMAP730_IDLECT2_SLEEP_VAL	0x09c7
-#define OMAP730_IDLECT3_VAL		0x3f
-#define OMAP730_IDLECT3		0xfffece24
-#define OMAP730_IDLE_LOOP_REQUEST	0x0C00
+#define OMAP7XX_IDLECT1_SLEEP_VAL	0x16c7
+#define OMAP7XX_IDLECT2_SLEEP_VAL	0x09c7
+#define OMAP7XX_IDLECT3_VAL		0x3f
+#define OMAP7XX_IDLECT3		0xfffece24
+#define OMAP7XX_IDLE_LOOP_REQUEST	0x0C00
 
 #if     !defined(CONFIG_ARCH_OMAP730) && \
+	!defined(CONFIG_ARCH_OMAP850) && \
 	!defined(CONFIG_ARCH_OMAP15XX) && \
 	!defined(CONFIG_ARCH_OMAP16XX)
 #warning "Power management for this processor not implemented yet"
@@ -122,17 +123,17 @@ extern void allow_idle_sleep(void);
 extern void omap1_pm_idle(void);
 extern void omap1_pm_suspend(void);
 
-extern void omap730_cpu_suspend(unsigned short, unsigned short);
+extern void omap7xx_cpu_suspend(unsigned short, unsigned short);
 extern void omap1510_cpu_suspend(unsigned short, unsigned short);
 extern void omap1610_cpu_suspend(unsigned short, unsigned short);
-extern void omap730_idle_loop_suspend(void);
+extern void omap7xx_idle_loop_suspend(void);
 extern void omap1510_idle_loop_suspend(void);
 extern void omap1610_idle_loop_suspend(void);
 
-extern unsigned int omap730_cpu_suspend_sz;
+extern unsigned int omap7xx_cpu_suspend_sz;
 extern unsigned int omap1510_cpu_suspend_sz;
 extern unsigned int omap1610_cpu_suspend_sz;
-extern unsigned int omap730_idle_loop_suspend_sz;
+extern unsigned int omap7xx_idle_loop_suspend_sz;
 extern unsigned int omap1510_idle_loop_suspend_sz;
 extern unsigned int omap1610_idle_loop_suspend_sz;
 
@@ -155,9 +156,9 @@ extern void omap_serial_wake_trigger(int enable);
 #define ULPD_RESTORE(x) omap_writew((ulpd_sleep_save[ULPD_SLEEP_SAVE_##x]), (x))
 #define ULPD_SHOW(x) ulpd_sleep_save[ULPD_SLEEP_SAVE_##x]
 
-#define MPUI730_SAVE(x) mpui730_sleep_save[MPUI730_SLEEP_SAVE_##x] = omap_readl(x)
-#define MPUI730_RESTORE(x) omap_writel((mpui730_sleep_save[MPUI730_SLEEP_SAVE_##x]), (x))
-#define MPUI730_SHOW(x) mpui730_sleep_save[MPUI730_SLEEP_SAVE_##x]
+#define MPUI7XX_SAVE(x) mpui7xx_sleep_save[MPUI7XX_SLEEP_SAVE_##x] = omap_readl(x)
+#define MPUI7XX_RESTORE(x) omap_writel((mpui7xx_sleep_save[MPUI7XX_SLEEP_SAVE_##x]), (x))
+#define MPUI7XX_SHOW(x) mpui7xx_sleep_save[MPUI7XX_SLEEP_SAVE_##x]
 
 #define MPUI1510_SAVE(x) mpui1510_sleep_save[MPUI1510_SLEEP_SAVE_##x] = omap_readl(x)
 #define MPUI1510_RESTORE(x) omap_writel((mpui1510_sleep_save[MPUI1510_SLEEP_SAVE_##x]), (x))
@@ -232,24 +233,24 @@ enum mpui1510_save_state {
 #endif
 };
 
-enum mpui730_save_state {
-	MPUI730_SLEEP_SAVE_START = 0,
+enum mpui7xx_save_state {
+	MPUI7XX_SLEEP_SAVE_START = 0,
 	/*
 	 * MPUI registers 32 bits
 	 */
-	MPUI730_SLEEP_SAVE_MPUI_CTRL,
-	MPUI730_SLEEP_SAVE_MPUI_DSP_BOOT_CONFIG,
-	MPUI730_SLEEP_SAVE_MPUI_DSP_API_CONFIG,
-	MPUI730_SLEEP_SAVE_MPUI_DSP_STATUS,
-	MPUI730_SLEEP_SAVE_EMIFF_SDRAM_CONFIG,
-	MPUI730_SLEEP_SAVE_EMIFS_CONFIG,
-	MPUI730_SLEEP_SAVE_OMAP_IH1_MIR,
-	MPUI730_SLEEP_SAVE_OMAP_IH2_0_MIR,
-	MPUI730_SLEEP_SAVE_OMAP_IH2_1_MIR,
-#if defined(CONFIG_ARCH_OMAP730)
-	MPUI730_SLEEP_SAVE_SIZE
+	MPUI7XX_SLEEP_SAVE_MPUI_CTRL,
+	MPUI7XX_SLEEP_SAVE_MPUI_DSP_BOOT_CONFIG,
+	MPUI7XX_SLEEP_SAVE_MPUI_DSP_API_CONFIG,
+	MPUI7XX_SLEEP_SAVE_MPUI_DSP_STATUS,
+	MPUI7XX_SLEEP_SAVE_EMIFF_SDRAM_CONFIG,
+	MPUI7XX_SLEEP_SAVE_EMIFS_CONFIG,
+	MPUI7XX_SLEEP_SAVE_OMAP_IH1_MIR,
+	MPUI7XX_SLEEP_SAVE_OMAP_IH2_0_MIR,
+	MPUI7XX_SLEEP_SAVE_OMAP_IH2_1_MIR,
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	MPUI7XX_SLEEP_SAVE_SIZE
 #else
-	MPUI730_SLEEP_SAVE_SIZE = 0
+	MPUI7XX_SLEEP_SAVE_SIZE = 0
 #endif
 };
 
diff --git a/arch/arm/mach-omap1/serial.c b/arch/arm/mach-omap1/serial.c
index d496e50..332c516 100644
--- a/arch/arm/mach-omap1/serial.c
+++ b/arch/arm/mach-omap1/serial.c
@@ -64,7 +64,6 @@ static void __init omap_serial_reset(struct plat_serial8250_port *p)
 
 static struct plat_serial8250_port serial_platform_data[] = {
 	{
-		.membase	= OMAP1_IO_ADDRESS(OMAP_UART1_BASE),
 		.mapbase	= OMAP_UART1_BASE,
 		.irq		= INT_UART1,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -73,7 +72,6 @@ static struct plat_serial8250_port serial_platform_data[] = {
 		.uartclk	= OMAP16XX_BASE_BAUD * 16,
 	},
 	{
-		.membase	= OMAP1_IO_ADDRESS(OMAP_UART2_BASE),
 		.mapbase	= OMAP_UART2_BASE,
 		.irq		= INT_UART2,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -82,7 +80,6 @@ static struct plat_serial8250_port serial_platform_data[] = {
 		.uartclk	= OMAP16XX_BASE_BAUD * 16,
 	},
 	{
-		.membase	= OMAP1_IO_ADDRESS(OMAP_UART3_BASE),
 		.mapbase	= OMAP_UART3_BASE,
 		.irq		= INT_UART3,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -90,7 +87,6 @@ static struct plat_serial8250_port serial_platform_data[] = {
 		.regshift	= 2,
 		.uartclk	= OMAP16XX_BASE_BAUD * 16,
 	},
-	{ },
 };
 
 static struct platform_device serial_device = {
@@ -110,18 +106,11 @@ void __init omap_serial_init(void)
 {
 	int i;
 
-	if (cpu_is_omap730()) {
+	if (cpu_is_omap7xx()) {
 		serial_platform_data[0].regshift = 0;
 		serial_platform_data[1].regshift = 0;
-		serial_platform_data[0].irq = INT_730_UART_MODEM_1;
-		serial_platform_data[1].irq = INT_730_UART_MODEM_IRDA_2;
-	}
-
-	if (cpu_is_omap850()) {
-		serial_platform_data[0].regshift = 0;
-		serial_platform_data[1].regshift = 0;
-		serial_platform_data[0].irq = INT_850_UART_MODEM_1;
-		serial_platform_data[1].irq = INT_850_UART_MODEM_IRDA_2;
+		serial_platform_data[0].irq = INT_7XX_UART_MODEM_1;
+		serial_platform_data[1].irq = INT_7XX_UART_MODEM_IRDA_2;
 	}
 
 	if (cpu_is_omap15xx()) {
@@ -130,9 +119,17 @@ void __init omap_serial_init(void)
 		serial_platform_data[2].uartclk = OMAP1510_BASE_BAUD * 16;
 	}
 
-	for (i = 0; i < OMAP_MAX_NR_PORTS; i++) {
+	for (i = 0; i < ARRAY_SIZE(serial_platform_data); i++) {
 		unsigned char reg;
 
+		/* Static mapping, never released */
+		serial_platform_data[i].membase =
+			ioremap(serial_platform_data[i].mapbase, SZ_2K);
+		if (!serial_platform_data[i].membase) {
+			printk(KERN_ERR "Could not ioremap uart%i\n", i);
+			continue;
+		}
+
 		switch (i) {
 		case 0:
 			uart1_ck = clk_get(NULL, "uart1_ck");
diff --git a/arch/arm/mach-omap1/sleep.S b/arch/arm/mach-omap1/sleep.S
index 22e8568..ef771ce 100644
--- a/arch/arm/mach-omap1/sleep.S
+++ b/arch/arm/mach-omap1/sleep.S
@@ -1,7 +1,7 @@
 /*
  * linux/arch/arm/mach-omap1/sleep.S
  *
- * Low-level OMAP730/1510/1610 sleep/wakeUp support
+ * Low-level OMAP7XX/1510/1610 sleep/wakeUp support
  *
  * Initial SA1110 code:
  * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
@@ -57,8 +57,8 @@
  *
  */
 
-#if defined(CONFIG_ARCH_OMAP730)
-ENTRY(omap730_cpu_suspend)
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+ENTRY(omap7xx_cpu_suspend)
 
 	@ save registers on stack
 	stmfd	sp!, {r0 - r12, lr}
@@ -91,13 +91,13 @@ ENTRY(omap730_cpu_suspend)
 
 	@ turn off clock domains
 	@ do not disable PERCK (0x04)
-	mov	r5, #OMAP730_IDLECT2_SLEEP_VAL & 0xff
-	orr	r5, r5, #OMAP730_IDLECT2_SLEEP_VAL & 0xff00
+	mov	r5, #OMAP7XX_IDLECT2_SLEEP_VAL & 0xff
+	orr	r5, r5, #OMAP7XX_IDLECT2_SLEEP_VAL & 0xff00
 	strh	r5, [r4, #ARM_IDLECT2_ASM_OFFSET & 0xff]
 
 	@ request ARM idle
-	mov	r3, #OMAP730_IDLECT1_SLEEP_VAL & 0xff
-	orr	r3, r3, #OMAP730_IDLECT1_SLEEP_VAL & 0xff00
+	mov	r3, #OMAP7XX_IDLECT1_SLEEP_VAL & 0xff
+	orr	r3, r3, #OMAP7XX_IDLECT1_SLEEP_VAL & 0xff00
 	strh	r3, [r4, #ARM_IDLECT1_ASM_OFFSET & 0xff]
 
 	@ disable instruction cache
@@ -113,7 +113,7 @@ ENTRY(omap730_cpu_suspend)
 	mov	r2, #0
 	mcr	p15, 0, r2, c7, c0, 4		@ wait for interrupt
 /*
- * omap730_cpu_suspend()'s resume point.
+ * omap7xx_cpu_suspend()'s resume point.
  *
  * It will just start executing here, so we'll restore stuff from the
  * stack.
@@ -132,9 +132,9 @@ ENTRY(omap730_cpu_suspend)
 	@ restore regs and return
 	ldmfd	sp!, {r0 - r12, pc}
 
-ENTRY(omap730_cpu_suspend_sz)
-	.word	. - omap730_cpu_suspend
-#endif /* CONFIG_ARCH_OMAP730 */
+ENTRY(omap7xx_cpu_suspend_sz)
+	.word	. - omap7xx_cpu_suspend
+#endif /* CONFIG_ARCH_OMAP730 || CONFIG_ARCH_OMAP850 */
 
 #ifdef CONFIG_ARCH_OMAP15XX
 ENTRY(omap1510_cpu_suspend)
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 8cb1677..6b7702f 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -80,6 +80,7 @@ obj-$(CONFIG_MACH_OMAP_4430SDP)		+= board-4430sdp.o
 # Platform specific device init code
 obj-y					+= usb-musb.o
 obj-$(CONFIG_MACH_OMAP2_TUSB6010)	+= usb-tusb6010.o
+obj-y					+= usb-ehci.o
 
 onenand-$(CONFIG_MTD_ONENAND_OMAP2)	:= gpmc-onenand.o
 obj-y					+= $(onenand-m) $(onenand-y)
diff --git a/arch/arm/mach-omap2/board-2430sdp.c b/arch/arm/mach-omap2/board-2430sdp.c
index 42217b3..e032a33 100644
--- a/arch/arm/mach-omap2/board-2430sdp.c
+++ b/arch/arm/mach-omap2/board-2430sdp.c
@@ -221,7 +221,7 @@ static void __init omap_2430sdp_map_io(void)
 MACHINE_START(OMAP_2430SDP, "OMAP2430 sdp2430 board")
 	/* Maintainer: Syed Khasim - Texas Instruments Inc */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_2430sdp_map_io,
 	.init_irq	= omap_2430sdp_init_irq,
diff --git a/arch/arm/mach-omap2/board-3430sdp.c b/arch/arm/mach-omap2/board-3430sdp.c
index efaf053..81aabac 100644
--- a/arch/arm/mach-omap2/board-3430sdp.c
+++ b/arch/arm/mach-omap2/board-3430sdp.c
@@ -484,6 +484,18 @@ static void enable_board_wakeup_source(void)
 	omap_cfg_reg(AF26_34XX_SYS_NIRQ); /* T2 interrupt line (keypad) */
 }
 
+static struct ehci_hcd_omap_platform_data ehci_pdata __initconst = {
+
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = 57,
+	.reset_gpio_port[1]  = 61,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
 static void __init omap_3430sdp_init(void)
 {
 	omap3430_i2c_init();
@@ -500,6 +512,7 @@ static void __init omap_3430sdp_init(void)
 	usb_musb_init();
 	board_smc91x_init();
 	enable_board_wakeup_source();
+	usb_ehci_init(&ehci_pdata);
 }
 
 static void __init omap_3430sdp_map_io(void)
@@ -511,7 +524,7 @@ static void __init omap_3430sdp_map_io(void)
 MACHINE_START(OMAP_3430SDP, "OMAP3430 3430SDP board")
 	/* Maintainer: Syed Khasim - Texas Instruments Inc */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_3430sdp_map_io,
 	.init_irq	= omap_3430sdp_init_irq,
diff --git a/arch/arm/mach-omap2/board-4430sdp.c b/arch/arm/mach-omap2/board-4430sdp.c
index eb37c40..50a62f2 100644
--- a/arch/arm/mach-omap2/board-4430sdp.c
+++ b/arch/arm/mach-omap2/board-4430sdp.c
@@ -52,8 +52,17 @@ static struct omap_board_config_kernel sdp4430_config[] __initdata = {
 
 static void __init gic_init_irq(void)
 {
-	gic_dist_init(0, OMAP2_IO_ADDRESS(OMAP44XX_GIC_DIST_BASE), 29);
-	gic_cpu_init(0, OMAP2_IO_ADDRESS(OMAP44XX_GIC_CPU_BASE));
+	void __iomem *base;
+
+	/* Static mapping, never released */
+	base = ioremap(OMAP44XX_GIC_DIST_BASE, SZ_4K);
+	BUG_ON(!base);
+	gic_dist_init(0, base, 29);
+
+	/* Static mapping, never released */
+	base = ioremap(OMAP44XX_GIC_CPU_BASE, SZ_256);
+	BUG_ON(!base);
+	gic_cpu_init(0, OMAP44XX_GIC_CPU_BASE);
 }
 
 static void __init omap_4430sdp_init_irq(void)
@@ -84,7 +93,7 @@ static void __init omap_4430sdp_map_io(void)
 MACHINE_START(OMAP_4430SDP, "OMAP4430 4430SDP board")
 	/* Maintainer: Santosh Shilimkar - Texas Instruments Inc */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_4430sdp_map_io,
 	.init_irq	= omap_4430sdp_init_irq,
diff --git a/arch/arm/mach-omap2/board-apollon.c b/arch/arm/mach-omap2/board-apollon.c
index a113228..e8a0e56 100644
--- a/arch/arm/mach-omap2/board-apollon.c
+++ b/arch/arm/mach-omap2/board-apollon.c
@@ -333,7 +333,7 @@ static void __init omap_apollon_map_io(void)
 MACHINE_START(OMAP_APOLLON, "OMAP24xx Apollon")
 	/* Maintainer: Kyungmin Park <kyungmin.park@samsung.com> */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_apollon_map_io,
 	.init_irq	= omap_apollon_init_irq,
diff --git a/arch/arm/mach-omap2/board-generic.c b/arch/arm/mach-omap2/board-generic.c
index 2e09a1c..1a139c0 100644
--- a/arch/arm/mach-omap2/board-generic.c
+++ b/arch/arm/mach-omap2/board-generic.c
@@ -56,7 +56,7 @@ static void __init omap_generic_map_io(void)
 MACHINE_START(OMAP_GENERIC, "Generic OMAP24xx")
 	/* Maintainer: Paul Mundt <paul.mundt@nokia.com> */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_generic_map_io,
 	.init_irq	= omap_generic_init_irq,
diff --git a/arch/arm/mach-omap2/board-h4.c b/arch/arm/mach-omap2/board-h4.c
index eaa02d0..86f78f3 100644
--- a/arch/arm/mach-omap2/board-h4.c
+++ b/arch/arm/mach-omap2/board-h4.c
@@ -376,7 +376,7 @@ static void __init omap_h4_map_io(void)
 MACHINE_START(OMAP_H4, "OMAP2420 H4 board")
 	/* Maintainer: Paul Mundt <paul.mundt@nokia.com> */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_h4_map_io,
 	.init_irq	= omap_h4_init_irq,
diff --git a/arch/arm/mach-omap2/board-ldp.c b/arch/arm/mach-omap2/board-ldp.c
index d110a7f..4ccc01a 100644
--- a/arch/arm/mach-omap2/board-ldp.c
+++ b/arch/arm/mach-omap2/board-ldp.c
@@ -399,7 +399,7 @@ static void __init omap_ldp_map_io(void)
 
 MACHINE_START(OMAP_LDP, "OMAP LDP board")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_ldp_map_io,
 	.init_irq	= omap_ldp_init_irq,
diff --git a/arch/arm/mach-omap2/board-n8x0.c b/arch/arm/mach-omap2/board-n8x0.c
index 8341632..2f6ccba 100644
--- a/arch/arm/mach-omap2/board-n8x0.c
+++ b/arch/arm/mach-omap2/board-n8x0.c
@@ -121,7 +121,7 @@ static void __init n8x0_init_machine(void)
 
 MACHINE_START(NOKIA_N800, "Nokia N800")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= n8x0_map_io,
 	.init_irq	= n8x0_init_irq,
@@ -131,7 +131,7 @@ MACHINE_END
 
 MACHINE_START(NOKIA_N810, "Nokia N810")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= n8x0_map_io,
 	.init_irq	= n8x0_init_irq,
@@ -141,7 +141,7 @@ MACHINE_END
 
 MACHINE_START(NOKIA_N810_WIMAX, "Nokia N810 WiMAX")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= n8x0_map_io,
 	.init_irq	= n8x0_init_irq,
diff --git a/arch/arm/mach-omap2/board-omap3beagle.c b/arch/arm/mach-omap2/board-omap3beagle.c
index 70df6b4..9824073 100644
--- a/arch/arm/mach-omap2/board-omap3beagle.c
+++ b/arch/arm/mach-omap2/board-omap3beagle.c
@@ -400,6 +400,18 @@ static void __init omap3beagle_flash_init(void)
 	}
 }
 
+static struct ehci_hcd_omap_platform_data ehci_pdata __initconst = {
+
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = -EINVAL,
+	.reset_gpio_port[1]  = 147,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
 static void __init omap3_beagle_init(void)
 {
 	omap3_beagle_i2c_init();
@@ -413,6 +425,7 @@ static void __init omap3_beagle_init(void)
 	gpio_direction_output(170, true);
 
 	usb_musb_init();
+	usb_ehci_init(&ehci_pdata);
 	omap3beagle_flash_init();
 
 	/* Ensure SDRC pins are mux'd for self-refresh */
@@ -429,7 +442,7 @@ static void __init omap3_beagle_map_io(void)
 MACHINE_START(OMAP3_BEAGLE, "OMAP3 Beagle Board")
 	/* Maintainer: Syed Mohammed Khasim - http://beagleboard.org */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap3_beagle_map_io,
 	.init_irq	= omap3_beagle_init_irq,
diff --git a/arch/arm/mach-omap2/board-omap3evm.c b/arch/arm/mach-omap2/board-omap3evm.c
index e4ec0c5..9e0b6e6 100644
--- a/arch/arm/mach-omap2/board-omap3evm.c
+++ b/arch/arm/mach-omap2/board-omap3evm.c
@@ -297,6 +297,18 @@ static struct platform_device *omap3_evm_devices[] __initdata = {
 	&omap3evm_smc911x_device,
 };
 
+static struct ehci_hcd_omap_platform_data ehci_pdata __initconst = {
+
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = -EINVAL,
+	.reset_gpio_port[1]  = 135,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
 static void __init omap3_evm_init(void)
 {
 	omap3_evm_i2c_init();
@@ -312,6 +324,9 @@ static void __init omap3_evm_init(void)
 	usb_nop_xceiv_register();
 #endif
 	usb_musb_init();
+	/* Setup EHCI phy reset padconfig */
+	omap_cfg_reg(AF4_34XX_GPIO135_OUT);
+	usb_ehci_init(&ehci_pdata);
 	ads7846_dev_init();
 }
 
@@ -324,7 +339,7 @@ static void __init omap3_evm_map_io(void)
 MACHINE_START(OMAP3EVM, "OMAP3 EVM")
 	/* Maintainer: Syed Mohammed Khasim - Texas Instruments */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap3_evm_map_io,
 	.init_irq	= omap3_evm_init_irq,
diff --git a/arch/arm/mach-omap2/board-omap3pandora.c b/arch/arm/mach-omap2/board-omap3pandora.c
index 7f6bf87..82b2486 100644
--- a/arch/arm/mach-omap2/board-omap3pandora.c
+++ b/arch/arm/mach-omap2/board-omap3pandora.c
@@ -387,6 +387,18 @@ static struct platform_device *omap3pandora_devices[] __initdata = {
 	&pandora_keys_gpio,
 };
 
+static struct ehci_hcd_omap_platform_data ehci_pdata __initconst = {
+
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = 16,
+	.reset_gpio_port[1]  = -EINVAL,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
 static void __init omap3pandora_init(void)
 {
 	omap3pandora_i2c_init();
@@ -396,6 +408,7 @@ static void __init omap3pandora_init(void)
 	spi_register_board_info(omap3pandora_spi_board_info,
 			ARRAY_SIZE(omap3pandora_spi_board_info));
 	omap3pandora_ads7846_init();
+	usb_ehci_init(&ehci_pdata);
 	pandora_keys_gpio_init();
 	usb_musb_init();
 
@@ -412,7 +425,7 @@ static void __init omap3pandora_map_io(void)
 
 MACHINE_START(OMAP3_PANDORA, "Pandora Handheld Console")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap3pandora_map_io,
 	.init_irq	= omap3pandora_init_irq,
diff --git a/arch/arm/mach-omap2/board-overo.c b/arch/arm/mach-omap2/board-overo.c
index 9917d2f..d50a3f0 100644
--- a/arch/arm/mach-omap2/board-overo.c
+++ b/arch/arm/mach-omap2/board-overo.c
@@ -384,6 +384,18 @@ static struct platform_device *overo_devices[] __initdata = {
 	&overo_lcd_device,
 };
 
+static struct ehci_hcd_omap_platform_data ehci_pdata __initconst = {
+	.port_mode[0] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+	.port_mode[1] = EHCI_HCD_OMAP_MODE_PHY,
+	.port_mode[2] = EHCI_HCD_OMAP_MODE_UNKNOWN,
+
+	.phy_reset  = true,
+	.reset_gpio_port[0]  = -EINVAL,
+	.reset_gpio_port[1]  = OVERO_GPIO_USBH_NRESET,
+	.reset_gpio_port[2]  = -EINVAL
+};
+
+
 static void __init overo_init(void)
 {
 	overo_i2c_init();
@@ -391,6 +403,7 @@ static void __init overo_init(void)
 	omap_serial_init();
 	overo_flash_init();
 	usb_musb_init();
+	usb_ehci_init(&ehci_pdata);
 	overo_ads7846_init();
 	overo_init_smsc911x();
 
@@ -433,14 +446,6 @@ static void __init overo_init(void)
 	else
 		printk(KERN_ERR "could not obtain gpio for "
 					"OVERO_GPIO_USBH_CPEN\n");
-
-	if ((gpio_request(OVERO_GPIO_USBH_NRESET,
-			  "OVERO_GPIO_USBH_NRESET") == 0) &&
-	    (gpio_direction_output(OVERO_GPIO_USBH_NRESET, 1) == 0))
-		gpio_export(OVERO_GPIO_USBH_NRESET, 0);
-	else
-		printk(KERN_ERR "could not obtain gpio for "
-					"OVERO_GPIO_USBH_NRESET\n");
 }
 
 static void __init overo_map_io(void)
@@ -451,7 +456,7 @@ static void __init overo_map_io(void)
 
 MACHINE_START(OVERO, "Gumstix Overo")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= overo_map_io,
 	.init_irq	= overo_init_irq,
diff --git a/arch/arm/mach-omap2/board-rx51.c b/arch/arm/mach-omap2/board-rx51.c
index f9196c3..c973812 100644
--- a/arch/arm/mach-omap2/board-rx51.c
+++ b/arch/arm/mach-omap2/board-rx51.c
@@ -85,7 +85,7 @@ static void __init rx51_map_io(void)
 MACHINE_START(NOKIA_RX51, "Nokia RX-51 board")
 	/* Maintainer: Lauri Leukkunen <lauri.leukkunen@nokia.com> */
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= rx51_map_io,
 	.init_irq	= rx51_init_irq,
diff --git a/arch/arm/mach-omap2/board-zoom2.c b/arch/arm/mach-omap2/board-zoom2.c
index fd3369d..48bd2af 100644
--- a/arch/arm/mach-omap2/board-zoom2.c
+++ b/arch/arm/mach-omap2/board-zoom2.c
@@ -283,7 +283,7 @@ static void __init omap_zoom2_map_io(void)
 
 MACHINE_START(OMAP_ZOOM2, "OMAP Zoom2 board")
 	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= omap_zoom2_map_io,
 	.init_irq	= omap_zoom2_init_irq,
diff --git a/arch/arm/mach-omap2/cm.h b/arch/arm/mach-omap2/cm.h
index cfd0b72..a2fcfcc 100644
--- a/arch/arm/mach-omap2/cm.h
+++ b/arch/arm/mach-omap2/cm.h
@@ -17,11 +17,11 @@
 #include "prcm-common.h"
 
 #define OMAP2420_CM_REGADDR(module, reg)				\
-			OMAP2_IO_ADDRESS(OMAP2420_CM_BASE + (module) + (reg))
+			OMAP2_L4_IO_ADDRESS(OMAP2420_CM_BASE + (module) + (reg))
 #define OMAP2430_CM_REGADDR(module, reg)				\
-			OMAP2_IO_ADDRESS(OMAP2430_CM_BASE + (module) + (reg))
+			OMAP2_L4_IO_ADDRESS(OMAP2430_CM_BASE + (module) + (reg))
 #define OMAP34XX_CM_REGADDR(module, reg)				\
-			OMAP2_IO_ADDRESS(OMAP3430_CM_BASE + (module) + (reg))
+			OMAP2_L4_IO_ADDRESS(OMAP3430_CM_BASE + (module) + (reg))
 
 /*
  * Architecture-specific global CM registers
diff --git a/arch/arm/mach-omap2/id.c b/arch/arm/mach-omap2/id.c
index a98201c..71d5568 100644
--- a/arch/arm/mach-omap2/id.c
+++ b/arch/arm/mach-omap2/id.c
@@ -28,6 +28,7 @@
 static struct omap_chip_id omap_chip;
 static unsigned int omap_revision;
 
+u32 omap3_features;
 
 unsigned int omap_rev(void)
 {
@@ -155,12 +156,37 @@ void __init omap24xx_check_revision(void)
 	pr_info("\n");
 }
 
-void __init omap34xx_check_revision(void)
+#define OMAP3_CHECK_FEATURE(status,feat)				\
+	if (((status & OMAP3_ ##feat## _MASK) 				\
+		>> OMAP3_ ##feat## _SHIFT) != FEAT_ ##feat## _NONE) { 	\
+		omap3_features |= OMAP3_HAS_ ##feat;			\
+	}
+
+void __init omap3_check_features(void)
+{
+	u32 status;
+
+	omap3_features = 0;
+
+	status = omap_ctrl_readl(OMAP3_CONTROL_OMAP_STATUS);
+
+	OMAP3_CHECK_FEATURE(status, L2CACHE);
+	OMAP3_CHECK_FEATURE(status, IVA);
+	OMAP3_CHECK_FEATURE(status, SGX);
+	OMAP3_CHECK_FEATURE(status, NEON);
+	OMAP3_CHECK_FEATURE(status, ISP);
+
+	/*
+	 * TODO: Get additional info (where applicable)
+	 *       e.g. Size of L2 cache.
+	 */
+}
+
+void __init omap3_check_revision(void)
 {
 	u32 cpuid, idcode;
 	u16 hawkeye;
 	u8 rev;
-	char *rev_name = "ES1.0";
 
 	/*
 	 * We cannot access revision registers on ES1.0.
@@ -170,7 +196,7 @@ void __init omap34xx_check_revision(void)
 	cpuid = read_cpuid(CPUID_ID);
 	if ((((cpuid >> 4) & 0xfff) == 0xc08) && ((cpuid & 0xf) == 0x0)) {
 		omap_revision = OMAP3430_REV_ES1_0;
-		goto out;
+		return;
 	}
 
 	/*
@@ -183,33 +209,111 @@ void __init omap34xx_check_revision(void)
 	hawkeye = (idcode >> 12) & 0xffff;
 	rev = (idcode >> 28) & 0xff;
 
-	if (hawkeye == 0xb7ae) {
+	switch (hawkeye) {
+	case 0xb7ae:
+		/* Handle 34xx/35xx devices */
 		switch (rev) {
-		case 0:
+		case 0: /* Take care of early samples */
+		case 1:
 			omap_revision = OMAP3430_REV_ES2_0;
-			rev_name = "ES2.0";
 			break;
 		case 2:
 			omap_revision = OMAP3430_REV_ES2_1;
-			rev_name = "ES2.1";
 			break;
 		case 3:
 			omap_revision = OMAP3430_REV_ES3_0;
-			rev_name = "ES3.0";
 			break;
 		case 4:
 			omap_revision = OMAP3430_REV_ES3_1;
-			rev_name = "ES3.1";
 			break;
 		default:
 			/* Use the latest known revision as default */
 			omap_revision = OMAP3430_REV_ES3_1;
-			rev_name = "Unknown revision\n";
 		}
+		break;
+	case 0xb891:
+		/* Handle 36xx devices */
+		switch (rev) {
+		case 0:
+			omap_revision = OMAP3630_REV_ES1_0;
+			break;
+		default:
+			/* Use the latest known revision as default */
+			omap_revision = OMAP3630_REV_ES1_0;
+		}
+		break;
+	default:
+		/* Unknown default to latest silicon rev as default*/
+		omap_revision = OMAP3630_REV_ES1_0;
 	}
+}
 
-out:
-	pr_info("OMAP%04x %s\n", omap_rev() >> 16, rev_name);
+#define OMAP3_SHOW_FEATURE(feat)		\
+	if (omap3_has_ ##feat()) {		\
+		pr_info (" - "#feat" : Y");	\
+	} else {				\
+		pr_info (" - "#feat" : N");	\
+	}
+
+void __init omap3_cpuinfo(void)
+{
+	u8 rev = GET_OMAP_REVISION();
+	char cpu_name[16], cpu_rev[16];
+
+	/* OMAP3430 and OMAP3530 are assumed to be same.
+	 *
+	 * OMAP3525, OMAP3515 and OMAP3503 can be detected only based
+	 * on available features. Upon detection, update the CPU id
+	 * and CPU class bits.
+	 */
+	if (cpu_is_omap3630())
+		strcpy(cpu_name, "3630");
+	else if (omap3_has_iva() && omap3_has_sgx())
+		strcpy(cpu_name, "3430/3530");
+	else if (omap3_has_sgx()) {
+		omap_revision = OMAP3525_REV(rev);
+		strcpy(cpu_name, "3525");
+	}
+	else if (omap3_has_iva()) {
+		omap_revision = OMAP3515_REV(rev);
+		strcpy(cpu_name, "3515");
+	}
+	else {
+		omap_revision = OMAP3503_REV(rev);
+		strcpy(cpu_name, "3503");
+	}
+
+	switch (rev) {
+	case OMAP_REVBITS_00:
+		strcpy(cpu_rev, "1.0");
+		break;
+	case OMAP_REVBITS_10:
+		strcpy(cpu_rev, "2.0");
+		break;
+	case OMAP_REVBITS_20:
+		strcpy(cpu_rev, "2.1");
+		break;
+	case OMAP_REVBITS_30:
+		strcpy(cpu_rev, "3.0");
+		break;
+	case OMAP_REVBITS_40:
+		strcpy(cpu_rev, "3.1");
+		break;
+	default:
+		/* Use the latest known revision as default */
+		strcpy(cpu_rev, "3.1");
+	}
+
+	/*
+	 * Print verbose information
+	 */
+	pr_info("OMAP%s ES%s\n", cpu_name, cpu_rev);
+
+	OMAP3_SHOW_FEATURE(l2cache);
+	OMAP3_SHOW_FEATURE(iva);
+	OMAP3_SHOW_FEATURE(sgx);
+	OMAP3_SHOW_FEATURE(neon);
+	OMAP3_SHOW_FEATURE(isp);
 }
 
 /*
@@ -223,8 +327,11 @@ void __init omap2_check_revision(void)
 	 */
 	if (cpu_is_omap24xx())
 		omap24xx_check_revision();
-	else if (cpu_is_omap34xx())
-		omap34xx_check_revision();
+	else if (cpu_is_omap34xx()) {
+		omap3_check_features();
+		omap3_check_revision();
+		omap3_cpuinfo();
+	}
 	else if (cpu_is_omap44xx()) {
 		printk(KERN_INFO "FIXME: CPU revision = OMAP4430\n");
 		return;
diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index e3a3bad..fc62953 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -203,6 +203,24 @@ static struct map_desc omap44xx_io_desc[] __initdata = {
 		.type		= MT_DEVICE,
 	},
 	{
+		.virtual	= OMAP44XX_EMIF1_VIRT,
+		.pfn		= __phys_to_pfn(OMAP44XX_EMIF1_PHYS),
+		.length		= OMAP44XX_EMIF1_SIZE,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= OMAP44XX_EMIF2_VIRT,
+		.pfn		= __phys_to_pfn(OMAP44XX_EMIF2_PHYS),
+		.length		= OMAP44XX_EMIF2_SIZE,
+		.type		= MT_DEVICE,
+	},
+	{
+		.virtual	= OMAP44XX_DMM_VIRT,
+		.pfn		= __phys_to_pfn(OMAP44XX_DMM_PHYS),
+		.length		= OMAP44XX_DMM_SIZE,
+		.type		= MT_DEVICE,
+	},
+	{
 		.virtual	= L4_PER_44XX_VIRT,
 		.pfn		= __phys_to_pfn(L4_PER_44XX_PHYS),
 		.length		= L4_PER_44XX_SIZE,
diff --git a/arch/arm/mach-omap2/irq.c b/arch/arm/mach-omap2/irq.c
index b828638..1db121f 100644
--- a/arch/arm/mach-omap2/irq.c
+++ b/arch/arm/mach-omap2/irq.c
@@ -178,12 +178,20 @@ void __init omap_init_irq(void)
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(irq_banks); i++) {
+		unsigned long base;
 		struct omap_irq_bank *bank = irq_banks + i;
 
 		if (cpu_is_omap24xx())
-			bank->base_reg = OMAP2_IO_ADDRESS(OMAP24XX_IC_BASE);
+			base = OMAP24XX_IC_BASE;
 		else if (cpu_is_omap34xx())
-			bank->base_reg = OMAP2_IO_ADDRESS(OMAP34XX_IC_BASE);
+			base = OMAP34XX_IC_BASE;
+
+		/* Static mapping, never released */
+		bank->base_reg = ioremap(base, SZ_4K);
+		if (!bank->base_reg) {
+			printk(KERN_ERR "Could not ioremap irq bank%i\n", i);
+			continue;
+		}
 
 		omap_irq_bank_init_one(bank);
 
diff --git a/arch/arm/mach-omap2/omap-smp.c b/arch/arm/mach-omap2/omap-smp.c
index 48ee295..a1b618c 100644
--- a/arch/arm/mach-omap2/omap-smp.c
+++ b/arch/arm/mach-omap2/omap-smp.c
@@ -26,11 +26,11 @@
 #include <mach/hardware.h>
 
 /* Registers used for communicating startup information */
-#define OMAP4_AUXCOREBOOT_REG0		(OMAP44XX_VA_WKUPGEN_BASE + 0x800)
-#define OMAP4_AUXCOREBOOT_REG1		(OMAP44XX_VA_WKUPGEN_BASE + 0x804)
+static void __iomem *omap4_auxcoreboot_reg0;
+static void __iomem *omap4_auxcoreboot_reg1;
 
 /* SCU base address */
-static void __iomem *scu_base = OMAP44XX_VA_SCU_BASE;
+static void __iomem *scu_base;
 
 /*
  * Use SCU config register to count number of cores
@@ -46,6 +46,8 @@ static DEFINE_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
+	void __iomem *gic_cpu_base;
+
 	trace_hardirqs_off();
 
 	/*
@@ -54,7 +56,10 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	 * for us: do so
 	 */
 
-	gic_cpu_init(0, OMAP2_IO_ADDRESS(OMAP44XX_GIC_CPU_BASE));
+	/* Static mapping, never released */
+	gic_cpu_base = ioremap(OMAP44XX_GIC_CPU_BASE, SZ_256);
+	BUG_ON(!gic_cpu_base);
+	gic_cpu_init(0, gic_cpu_base);
 
 	/*
 	 * Synchronise with the boot thread.
@@ -79,7 +84,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * the AuxCoreBoot1 register is updated with cpu state
 	 * A barrier is added to ensure that write buffer is drained
 	 */
-	__raw_writel(cpu, OMAP4_AUXCOREBOOT_REG1);
+	__raw_writel(cpu, omap4_auxcoreboot_reg1);
 	smp_wmb();
 
 	timeout = jiffies + (1 * HZ);
@@ -104,7 +109,7 @@ static void __init wakeup_secondary(void)
 	 * A barrier is added to ensure that write buffer is drained
 	 */
 	__raw_writel(virt_to_phys(omap_secondary_startup),	   \
-					OMAP4_AUXCOREBOOT_REG0);
+					omap4_auxcoreboot_reg0);
 	smp_wmb();
 
 	/*
@@ -130,6 +135,7 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 {
 	unsigned int ncores = get_core_count();
 	unsigned int cpu = smp_processor_id();
+	void __iomem *omap4_wkupgen_base;
 	int i;
 
 	/* sanity check */
@@ -161,6 +167,16 @@ void __init smp_prepare_cpus(unsigned int max_cpus)
 	for (i = 0; i < max_cpus; i++)
 		set_cpu_present(i, true);
 
+	/* Never released */
+	omap4_wkupgen_base = ioremap(OMAP44XX_WKUPGEN_BASE, SZ_4K);
+	BUG_ON(!omap4_wkupgen_base);
+	omap4_auxcoreboot_reg0 = omap4_wkupgen_base + 0x800;
+	omap4_auxcoreboot_reg0 = omap4_wkupgen_base + 0x804;
+
+	/* Never released */
+	scu_base = ioremap(OMAP44XX_GIC_CPU_BASE, SZ_256);
+	BUG_ON(!scu_base);
+
 	if (max_cpus > 1) {
 		/*
 		 * Enable the local timer or broadcast device for the
diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index d2e0f1c..8ac8798 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -496,6 +496,7 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 	struct omap_hwmod_addr_space *mem;
 	int i;
 	int found = 0;
+	void __iomem *va_start;
 
 	if (!oh || oh->slaves_cnt == 0)
 		return NULL;
@@ -509,16 +510,20 @@ static void __iomem *_find_mpu_rt_base(struct omap_hwmod *oh, u8 index)
 		}
 	}
 
-	/* XXX use ioremap() instead? */
-
-	if (found)
+	if (found) {
+		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
+		if (!va_start) {
+			pr_err("omap_hwmod: %s: Could not ioremap\n", oh->name);
+			return NULL;
+		}
 		pr_debug("omap_hwmod: %s: MPU register target at va %p\n",
-			 oh->name, OMAP2_IO_ADDRESS(mem->pa_start));
-	else
+			 oh->name, va_start);
+	} else {
 		pr_debug("omap_hwmod: %s: no MPU register target found\n",
 			 oh->name);
+	}
 
-	return (found) ? OMAP2_IO_ADDRESS(mem->pa_start) : NULL;
+	return (found) ? va_start : NULL;
 }
 
 /**
@@ -1148,6 +1153,7 @@ int omap_hwmod_unregister(struct omap_hwmod *oh)
 	pr_debug("omap_hwmod: %s: unregistering\n", oh->name);
 
 	mutex_lock(&omap_hwmod_mutex);
+	iounmap(oh->_rt_va);
 	list_del(&oh->node);
 	mutex_unlock(&omap_hwmod_mutex);
 
diff --git a/arch/arm/mach-omap2/pm-debug.c b/arch/arm/mach-omap2/pm-debug.c
index 2fc4d6a..deed1dd 100644
--- a/arch/arm/mach-omap2/pm-debug.c
+++ b/arch/arm/mach-omap2/pm-debug.c
@@ -51,7 +51,8 @@ int omap2_pm_debug;
 	regs[reg_count++].val = __raw_readl(reg)
 #define DUMP_INTC_REG(reg, off) \
 	regs[reg_count].name = #reg; \
-	regs[reg_count++].val = __raw_readl(OMAP2_IO_ADDRESS(0x480fe000 + (off)))
+	regs[reg_count++].val = \
+			 __raw_readl(OMAP2_L4_IO_ADDRESS(0x480fe000 + (off)))
 
 static int __init pm_dbg_init(void);
 
diff --git a/arch/arm/mach-omap2/prm.h b/arch/arm/mach-omap2/prm.h
index 03c467c..a117f85 100644
--- a/arch/arm/mach-omap2/prm.h
+++ b/arch/arm/mach-omap2/prm.h
@@ -17,11 +17,11 @@
 #include "prcm-common.h"
 
 #define OMAP2420_PRM_REGADDR(module, reg)				\
-			OMAP2_IO_ADDRESS(OMAP2420_PRM_BASE + (module) + (reg))
+		OMAP2_L4_IO_ADDRESS(OMAP2420_PRM_BASE + (module) + (reg))
 #define OMAP2430_PRM_REGADDR(module, reg)				\
-			OMAP2_IO_ADDRESS(OMAP2430_PRM_BASE + (module) + (reg))
+		OMAP2_L4_IO_ADDRESS(OMAP2430_PRM_BASE + (module) + (reg))
 #define OMAP34XX_PRM_REGADDR(module, reg)				\
-			OMAP2_IO_ADDRESS(OMAP3430_PRM_BASE + (module) + (reg))
+		OMAP2_L4_IO_ADDRESS(OMAP3430_PRM_BASE + (module) + (reg))
 
 /*
  * Architecture-specific global PRM registers
diff --git a/arch/arm/mach-omap2/sdrc.h b/arch/arm/mach-omap2/sdrc.h
index 0837eda..345183d 100644
--- a/arch/arm/mach-omap2/sdrc.h
+++ b/arch/arm/mach-omap2/sdrc.h
@@ -48,9 +48,12 @@ static inline u32 sms_read_reg(u16 reg)
 	return __raw_readl(OMAP_SMS_REGADDR(reg));
 }
 #else
-#define OMAP242X_SDRC_REGADDR(reg)	OMAP2_IO_ADDRESS(OMAP2420_SDRC_BASE + (reg))
-#define OMAP243X_SDRC_REGADDR(reg)	OMAP2_IO_ADDRESS(OMAP243X_SDRC_BASE + (reg))
-#define OMAP34XX_SDRC_REGADDR(reg)	OMAP2_IO_ADDRESS(OMAP343X_SDRC_BASE + (reg))
+#define OMAP242X_SDRC_REGADDR(reg)					\
+			OMAP2_L3_IO_ADDRESS(OMAP2420_SDRC_BASE + (reg))
+#define OMAP243X_SDRC_REGADDR(reg)					\
+			OMAP2_L3_IO_ADDRESS(OMAP243X_SDRC_BASE + (reg))
+#define OMAP34XX_SDRC_REGADDR(reg)					\
+			OMAP2_L3_IO_ADDRESS(OMAP343X_SDRC_BASE + (reg))
 #endif	/* __ASSEMBLER__ */
 
 #endif
diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
index ae21868..7f722a7 100644
--- a/arch/arm/mach-omap2/serial.c
+++ b/arch/arm/mach-omap2/serial.c
@@ -73,7 +73,6 @@ static LIST_HEAD(uart_list);
 
 static struct plat_serial8250_port serial_platform_data0[] = {
 	{
-		.membase	= OMAP2_IO_ADDRESS(OMAP_UART1_BASE),
 		.mapbase	= OMAP_UART1_BASE,
 		.irq		= 72,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -87,7 +86,6 @@ static struct plat_serial8250_port serial_platform_data0[] = {
 
 static struct plat_serial8250_port serial_platform_data1[] = {
 	{
-		.membase	= OMAP2_IO_ADDRESS(OMAP_UART2_BASE),
 		.mapbase	= OMAP_UART2_BASE,
 		.irq		= 73,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -101,7 +99,6 @@ static struct plat_serial8250_port serial_platform_data1[] = {
 
 static struct plat_serial8250_port serial_platform_data2[] = {
 	{
-		.membase	= OMAP2_IO_ADDRESS(OMAP_UART3_BASE),
 		.mapbase	= OMAP_UART3_BASE,
 		.irq		= 74,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -110,7 +107,6 @@ static struct plat_serial8250_port serial_platform_data2[] = {
 		.uartclk	= OMAP24XX_BASE_BAUD * 16,
 	}, {
 #ifdef CONFIG_ARCH_OMAP4
-		.membase	= OMAP2_IO_ADDRESS(OMAP_UART4_BASE),
 		.mapbase	= OMAP_UART4_BASE,
 		.irq		= 70,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -126,7 +122,6 @@ static struct plat_serial8250_port serial_platform_data2[] = {
 #ifdef CONFIG_ARCH_OMAP4
 static struct plat_serial8250_port serial_platform_data3[] = {
 	{
-		.membase	= OMAP2_IO_ADDRESS(OMAP_UART4_BASE),
 		.mapbase	= OMAP_UART4_BASE,
 		.irq		= 70,
 		.flags		= UPF_BOOT_AUTOCONF,
@@ -549,7 +544,7 @@ static inline void omap_uart_idle_init(struct omap_uart_state *uart) {}
 #define DEV_CREATE_FILE(dev, attr)
 #endif /* CONFIG_PM */
 
-static struct omap_uart_state omap_uart[OMAP_MAX_NR_PORTS] = {
+static struct omap_uart_state omap_uart[] = {
 	{
 		.pdev = {
 			.name			= "serial8250",
@@ -599,12 +594,22 @@ void __init omap_serial_early_init(void)
 	 * if not needed.
 	 */
 
-	for (i = 0; i < OMAP_MAX_NR_PORTS; i++) {
+	for (i = 0; i < ARRAY_SIZE(omap_uart); i++) {
 		struct omap_uart_state *uart = &omap_uart[i];
 		struct platform_device *pdev = &uart->pdev;
 		struct device *dev = &pdev->dev;
 		struct plat_serial8250_port *p = dev->platform_data;
 
+		/*
+		 * Module 4KB + L4 interconnect 4KB
+		 * Static mapping, never released
+		 */
+		p->membase = ioremap(p->mapbase, SZ_8K);
+		if (!p->membase) {
+			printk(KERN_ERR "ioremap failed for uart%i\n", i + 1);
+			continue;
+		}
+
 		sprintf(name, "uart%d_ick", i+1);
 		uart->ick = clk_get(NULL, name);
 		if (IS_ERR(uart->ick)) {
@@ -641,7 +646,7 @@ void __init omap_serial_init(void)
 {
 	int i;
 
-	for (i = 0; i < OMAP_MAX_NR_PORTS; i++) {
+	for (i = 0; i < ARRAY_SIZE(omap_uart); i++) {
 		struct omap_uart_state *uart = &omap_uart[i];
 		struct platform_device *pdev = &uart->pdev;
 		struct device *dev = &pdev->dev;
diff --git a/arch/arm/mach-omap2/sram242x.S b/arch/arm/mach-omap2/sram242x.S
index 9b62208..92e6e1a 100644
--- a/arch/arm/mach-omap2/sram242x.S
+++ b/arch/arm/mach-omap2/sram242x.S
@@ -128,7 +128,7 @@ omap242x_sdi_prcm_voltctrl:
 prcm_mask_val:
 	.word 0xFFFF3FFC
 omap242x_sdi_timer_32ksynct_cr:
-	.word OMAP2_IO_ADDRESS(OMAP2420_32KSYNCT_BASE + 0x010)
+	.word OMAP2_L4_IO_ADDRESS(OMAP2420_32KSYNCT_BASE + 0x010)
 ENTRY(omap242x_sram_ddr_init_sz)
 	.word	. - omap242x_sram_ddr_init
 
@@ -224,7 +224,7 @@ omap242x_srs_prcm_voltctrl:
 ddr_prcm_mask_val:
 	.word 0xFFFF3FFC
 omap242x_srs_timer_32ksynct:
-	.word OMAP2_IO_ADDRESS(OMAP2420_32KSYNCT_BASE + 0x010)
+	.word OMAP2_L4_IO_ADDRESS(OMAP2420_32KSYNCT_BASE + 0x010)
 
 ENTRY(omap242x_sram_reprogram_sdrc_sz)
 	.word	. - omap242x_sram_reprogram_sdrc
diff --git a/arch/arm/mach-omap2/sram243x.S b/arch/arm/mach-omap2/sram243x.S
index df2cd92..ab49736 100644
--- a/arch/arm/mach-omap2/sram243x.S
+++ b/arch/arm/mach-omap2/sram243x.S
@@ -128,7 +128,7 @@ omap243x_sdi_prcm_voltctrl:
 prcm_mask_val:
 	.word 0xFFFF3FFC
 omap243x_sdi_timer_32ksynct_cr:
-	.word OMAP2_IO_ADDRESS(OMAP2430_32KSYNCT_BASE + 0x010)
+	.word OMAP2_L4_IO_ADDRESS(OMAP2430_32KSYNCT_BASE + 0x010)
 ENTRY(omap243x_sram_ddr_init_sz)
 	.word	. - omap243x_sram_ddr_init
 
@@ -224,7 +224,7 @@ omap243x_srs_prcm_voltctrl:
 ddr_prcm_mask_val:
 	.word 0xFFFF3FFC
 omap243x_srs_timer_32ksynct:
-	.word OMAP2_IO_ADDRESS(OMAP2430_32KSYNCT_BASE + 0x010)
+	.word OMAP2_L4_IO_ADDRESS(OMAP2430_32KSYNCT_BASE + 0x010)
 
 ENTRY(omap243x_sram_reprogram_sdrc_sz)
 	.word	. - omap243x_sram_reprogram_sdrc
diff --git a/arch/arm/mach-omap2/timer-gp.c b/arch/arm/mach-omap2/timer-gp.c
index e2338c0..cd72970 100644
--- a/arch/arm/mach-omap2/timer-gp.c
+++ b/arch/arm/mach-omap2/timer-gp.c
@@ -231,7 +231,8 @@ static void __init omap2_gp_clocksource_init(void)
 static void __init omap2_gp_timer_init(void)
 {
 #ifdef CONFIG_LOCAL_TIMERS
-	twd_base = OMAP2_IO_ADDRESS(OMAP44XX_LOCAL_TWD_BASE);
+	twd_base = ioremap(OMAP44XX_LOCAL_TWD_BASE, SZ_256);
+	BUG_ON(!twd_base);
 #endif
 	omap_dm_timer_init();
 
diff --git a/arch/arm/mach-omap2/usb-ehci.c b/arch/arm/mach-omap2/usb-ehci.c
new file mode 100644
index 0000000..a29c8ca
--- /dev/null
+++ b/arch/arm/mach-omap2/usb-ehci.c
@@ -0,0 +1,192 @@
+/*
+ * linux/arch/arm/mach-omap2/usb-ehci.c
+ *
+ * This file will contain the board specific details for the
+ * Synopsys EHCI host controller on OMAP3430
+ *
+ * Copyright (C) 2007 Texas Instruments
+ * Author: Vikram Pandita <vikram.pandita@ti.com>
+ *
+ * Generalization by:
+ * Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <mach/mux.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/usb.h>
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+
+static struct resource ehci_resources[] = {
+	{
+		.start	= OMAP34XX_EHCI_BASE,
+		.end	= OMAP34XX_EHCI_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= OMAP34XX_UHH_CONFIG_BASE,
+		.end	= OMAP34XX_UHH_CONFIG_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= OMAP34XX_USBTLL_BASE,
+		.end	= OMAP34XX_USBTLL_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{         /* general IRQ */
+		.start   = INT_34XX_EHCI_IRQ,
+		.flags   = IORESOURCE_IRQ,
+	}
+};
+
+static u64 ehci_dmamask = ~(u32)0;
+static struct platform_device ehci_device = {
+	.name           = "ehci-omap",
+	.id             = 0,
+	.dev = {
+		.dma_mask               = &ehci_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+		.platform_data          = NULL,
+	},
+	.num_resources  = ARRAY_SIZE(ehci_resources),
+	.resource       = ehci_resources,
+};
+
+/* MUX settings for EHCI pins */
+/*
+ * setup_ehci_io_mux - initialize IO pad mux for USBHOST
+ */
+static void setup_ehci_io_mux(enum ehci_hcd_omap_mode *port_mode)
+{
+	switch (port_mode[0]) {
+	case EHCI_HCD_OMAP_MODE_PHY:
+		omap_cfg_reg(Y9_3430_USB1HS_PHY_STP);
+		omap_cfg_reg(Y8_3430_USB1HS_PHY_CLK);
+		omap_cfg_reg(AA14_3430_USB1HS_PHY_DIR);
+		omap_cfg_reg(AA11_3430_USB1HS_PHY_NXT);
+		omap_cfg_reg(W13_3430_USB1HS_PHY_DATA0);
+		omap_cfg_reg(W12_3430_USB1HS_PHY_DATA1);
+		omap_cfg_reg(W11_3430_USB1HS_PHY_DATA2);
+		omap_cfg_reg(Y11_3430_USB1HS_PHY_DATA3);
+		omap_cfg_reg(W9_3430_USB1HS_PHY_DATA4);
+		omap_cfg_reg(Y12_3430_USB1HS_PHY_DATA5);
+		omap_cfg_reg(W8_3430_USB1HS_PHY_DATA6);
+		omap_cfg_reg(Y13_3430_USB1HS_PHY_DATA7);
+		break;
+	case EHCI_HCD_OMAP_MODE_TLL:
+		omap_cfg_reg(Y9_3430_USB1HS_TLL_STP);
+		omap_cfg_reg(Y8_3430_USB1HS_TLL_CLK);
+		omap_cfg_reg(AA14_3430_USB1HS_TLL_DIR);
+		omap_cfg_reg(AA11_3430_USB1HS_TLL_NXT);
+		omap_cfg_reg(W13_3430_USB1HS_TLL_DATA0);
+		omap_cfg_reg(W12_3430_USB1HS_TLL_DATA1);
+		omap_cfg_reg(W11_3430_USB1HS_TLL_DATA2);
+		omap_cfg_reg(Y11_3430_USB1HS_TLL_DATA3);
+		omap_cfg_reg(W9_3430_USB1HS_TLL_DATA4);
+		omap_cfg_reg(Y12_3430_USB1HS_TLL_DATA5);
+		omap_cfg_reg(W8_3430_USB1HS_TLL_DATA6);
+		omap_cfg_reg(Y13_3430_USB1HS_TLL_DATA7);
+		break;
+	case EHCI_HCD_OMAP_MODE_UNKNOWN:
+		/* FALLTHROUGH */
+	default:
+		break;
+	}
+
+	switch (port_mode[1]) {
+	case EHCI_HCD_OMAP_MODE_PHY:
+		omap_cfg_reg(AA10_3430_USB2HS_PHY_STP);
+		omap_cfg_reg(AA8_3430_USB2HS_PHY_CLK);
+		omap_cfg_reg(AA9_3430_USB2HS_PHY_DIR);
+		omap_cfg_reg(AB11_3430_USB2HS_PHY_NXT);
+		omap_cfg_reg(AB10_3430_USB2HS_PHY_DATA0);
+		omap_cfg_reg(AB9_3430_USB2HS_PHY_DATA1);
+		omap_cfg_reg(W3_3430_USB2HS_PHY_DATA2);
+		omap_cfg_reg(T4_3430_USB2HS_PHY_DATA3);
+		omap_cfg_reg(T3_3430_USB2HS_PHY_DATA4);
+		omap_cfg_reg(R3_3430_USB2HS_PHY_DATA5);
+		omap_cfg_reg(R4_3430_USB2HS_PHY_DATA6);
+		omap_cfg_reg(T2_3430_USB2HS_PHY_DATA7);
+		break;
+	case EHCI_HCD_OMAP_MODE_TLL:
+		omap_cfg_reg(AA10_3430_USB2HS_TLL_STP);
+		omap_cfg_reg(AA8_3430_USB2HS_TLL_CLK);
+		omap_cfg_reg(AA9_3430_USB2HS_TLL_DIR);
+		omap_cfg_reg(AB11_3430_USB2HS_TLL_NXT);
+		omap_cfg_reg(AB10_3430_USB2HS_TLL_DATA0);
+		omap_cfg_reg(AB9_3430_USB2HS_TLL_DATA1);
+		omap_cfg_reg(W3_3430_USB2HS_TLL_DATA2);
+		omap_cfg_reg(T4_3430_USB2HS_TLL_DATA3);
+		omap_cfg_reg(T3_3430_USB2HS_TLL_DATA4);
+		omap_cfg_reg(R3_3430_USB2HS_TLL_DATA5);
+		omap_cfg_reg(R4_3430_USB2HS_TLL_DATA6);
+		omap_cfg_reg(T2_3430_USB2HS_TLL_DATA7);
+		break;
+	case EHCI_HCD_OMAP_MODE_UNKNOWN:
+		/* FALLTHROUGH */
+	default:
+		break;
+	}
+
+	switch (port_mode[2]) {
+	case EHCI_HCD_OMAP_MODE_PHY:
+		printk(KERN_WARNING "Port3 can't be used in PHY mode\n");
+		break;
+	case EHCI_HCD_OMAP_MODE_TLL:
+		omap_cfg_reg(AB3_3430_USB3HS_TLL_STP);
+		omap_cfg_reg(AA6_3430_USB3HS_TLL_CLK);
+		omap_cfg_reg(AA3_3430_USB3HS_TLL_DIR);
+		omap_cfg_reg(Y3_3430_USB3HS_TLL_NXT);
+		omap_cfg_reg(AA5_3430_USB3HS_TLL_DATA0);
+		omap_cfg_reg(Y4_3430_USB3HS_TLL_DATA1);
+		omap_cfg_reg(Y5_3430_USB3HS_TLL_DATA2);
+		omap_cfg_reg(W5_3430_USB3HS_TLL_DATA3);
+		omap_cfg_reg(AB12_3430_USB3HS_TLL_DATA4);
+		omap_cfg_reg(AB13_3430_USB3HS_TLL_DATA5);
+		omap_cfg_reg(AA13_3430_USB3HS_TLL_DATA6);
+		omap_cfg_reg(AA12_3430_USB3HS_TLL_DATA7);
+		break;
+	case EHCI_HCD_OMAP_MODE_UNKNOWN:
+		/* FALLTHROUGH */
+	default:
+		break;
+	}
+
+	return;
+}
+
+void __init usb_ehci_init(struct ehci_hcd_omap_platform_data *pdata)
+{
+	platform_device_add_data(&ehci_device, pdata, sizeof(*pdata));
+
+	/* Setup Pin IO MUX for EHCI */
+	if (cpu_is_omap34xx())
+		setup_ehci_io_mux(pdata->port_mode);
+
+	if (platform_device_register(&ehci_device) < 0) {
+		printk(KERN_ERR "Unable to register HS-USB (EHCI) device\n");
+		return;
+	}
+}
+
+#else
+
+void __init usb_ehci_init(struct ehci_hcd_omap_platform_data *pdata)
+
+{
+}
+
+#endif /* CONFIG_USB_EHCI_HCD */
+
diff --git a/arch/arm/plat-omap/common.c b/arch/arm/plat-omap/common.c
index 3a4768d..1aa58d2 100644
--- a/arch/arm/plat-omap/common.c
+++ b/arch/arm/plat-omap/common.c
@@ -224,12 +224,12 @@ static void __init __omap2_set_globals(struct omap_globals *omap2_globals)
 
 static struct omap_globals omap242x_globals = {
 	.class	= OMAP242X_CLASS,
-	.tap	= OMAP2_IO_ADDRESS(0x48014000),
-	.sdrc	= OMAP2_IO_ADDRESS(OMAP2420_SDRC_BASE),
-	.sms	= OMAP2_IO_ADDRESS(OMAP2420_SMS_BASE),
-	.ctrl	= OMAP2_IO_ADDRESS(OMAP2420_CTRL_BASE),
-	.prm	= OMAP2_IO_ADDRESS(OMAP2420_PRM_BASE),
-	.cm	= OMAP2_IO_ADDRESS(OMAP2420_CM_BASE),
+	.tap	= OMAP2_L4_IO_ADDRESS(0x48014000),
+	.sdrc	= OMAP2_L3_IO_ADDRESS(OMAP2420_SDRC_BASE),
+	.sms	= OMAP2_L3_IO_ADDRESS(OMAP2420_SMS_BASE),
+	.ctrl	= OMAP2_L4_IO_ADDRESS(OMAP2420_CTRL_BASE),
+	.prm	= OMAP2_L4_IO_ADDRESS(OMAP2420_PRM_BASE),
+	.cm	= OMAP2_L4_IO_ADDRESS(OMAP2420_CM_BASE),
 };
 
 void __init omap2_set_globals_242x(void)
@@ -242,12 +242,12 @@ void __init omap2_set_globals_242x(void)
 
 static struct omap_globals omap243x_globals = {
 	.class	= OMAP243X_CLASS,
-	.tap	= OMAP2_IO_ADDRESS(0x4900a000),
-	.sdrc	= OMAP2_IO_ADDRESS(OMAP243X_SDRC_BASE),
-	.sms	= OMAP2_IO_ADDRESS(OMAP243X_SMS_BASE),
-	.ctrl	= OMAP2_IO_ADDRESS(OMAP243X_CTRL_BASE),
-	.prm	= OMAP2_IO_ADDRESS(OMAP2430_PRM_BASE),
-	.cm	= OMAP2_IO_ADDRESS(OMAP2430_CM_BASE),
+	.tap	= OMAP2_L4_IO_ADDRESS(0x4900a000),
+	.sdrc	= OMAP2_L3_IO_ADDRESS(OMAP243X_SDRC_BASE),
+	.sms	= OMAP2_L3_IO_ADDRESS(OMAP243X_SMS_BASE),
+	.ctrl	= OMAP2_L4_IO_ADDRESS(OMAP243X_CTRL_BASE),
+	.prm	= OMAP2_L4_IO_ADDRESS(OMAP2430_PRM_BASE),
+	.cm	= OMAP2_L4_IO_ADDRESS(OMAP2430_CM_BASE),
 };
 
 void __init omap2_set_globals_243x(void)
@@ -260,12 +260,12 @@ void __init omap2_set_globals_243x(void)
 
 static struct omap_globals omap343x_globals = {
 	.class	= OMAP343X_CLASS,
-	.tap	= OMAP2_IO_ADDRESS(0x4830A000),
-	.sdrc	= OMAP2_IO_ADDRESS(OMAP343X_SDRC_BASE),
-	.sms	= OMAP2_IO_ADDRESS(OMAP343X_SMS_BASE),
-	.ctrl	= OMAP2_IO_ADDRESS(OMAP343X_CTRL_BASE),
-	.prm	= OMAP2_IO_ADDRESS(OMAP3430_PRM_BASE),
-	.cm	= OMAP2_IO_ADDRESS(OMAP3430_CM_BASE),
+	.tap	= OMAP2_L4_IO_ADDRESS(0x4830A000),
+	.sdrc	= OMAP2_L3_IO_ADDRESS(OMAP343X_SDRC_BASE),
+	.sms	= OMAP2_L3_IO_ADDRESS(OMAP343X_SMS_BASE),
+	.ctrl	= OMAP2_L4_IO_ADDRESS(OMAP343X_CTRL_BASE),
+	.prm	= OMAP2_L4_IO_ADDRESS(OMAP3430_PRM_BASE),
+	.cm	= OMAP2_L4_IO_ADDRESS(OMAP3430_CM_BASE),
 };
 
 void __init omap2_set_globals_343x(void)
@@ -277,10 +277,10 @@ void __init omap2_set_globals_343x(void)
 #if defined(CONFIG_ARCH_OMAP4)
 static struct omap_globals omap4_globals = {
 	.class	= OMAP443X_CLASS,
-	.tap	= OMAP2_IO_ADDRESS(0x4830a000),
-	.ctrl	= OMAP2_IO_ADDRESS(OMAP443X_CTRL_BASE),
-	.prm	= OMAP2_IO_ADDRESS(OMAP4430_PRM_BASE),
-	.cm	= OMAP2_IO_ADDRESS(OMAP4430_CM_BASE),
+	.tap	= OMAP2_L4_IO_ADDRESS(0x4830a000),
+	.ctrl	= OMAP2_L4_IO_ADDRESS(OMAP443X_CTRL_BASE),
+	.prm	= OMAP2_L4_IO_ADDRESS(OMAP4430_PRM_BASE),
+	.cm	= OMAP2_L4_IO_ADDRESS(OMAP4430_CM_BASE),
 };
 
 void __init omap2_set_globals_443x(void)
diff --git a/arch/arm/plat-omap/devices.c b/arch/arm/plat-omap/devices.c
index a64b692..d2f5475 100644
--- a/arch/arm/plat-omap/devices.c
+++ b/arch/arm/plat-omap/devices.c
@@ -113,17 +113,17 @@ static void omap_init_kp(void)
 		omap_cfg_reg(E19_1610_KBR4);
 		omap_cfg_reg(N19_1610_KBR5);
 	} else if (machine_is_omap_perseus2() || machine_is_omap_fsample()) {
-		omap_cfg_reg(E2_730_KBR0);
-		omap_cfg_reg(J7_730_KBR1);
-		omap_cfg_reg(E1_730_KBR2);
-		omap_cfg_reg(F3_730_KBR3);
-		omap_cfg_reg(D2_730_KBR4);
-
-		omap_cfg_reg(C2_730_KBC0);
-		omap_cfg_reg(D3_730_KBC1);
-		omap_cfg_reg(E4_730_KBC2);
-		omap_cfg_reg(F4_730_KBC3);
-		omap_cfg_reg(E3_730_KBC4);
+		omap_cfg_reg(E2_7XX_KBR0);
+		omap_cfg_reg(J7_7XX_KBR1);
+		omap_cfg_reg(E1_7XX_KBR2);
+		omap_cfg_reg(F3_7XX_KBR3);
+		omap_cfg_reg(D2_7XX_KBR4);
+
+		omap_cfg_reg(C2_7XX_KBC0);
+		omap_cfg_reg(D3_7XX_KBC1);
+		omap_cfg_reg(E4_7XX_KBC2);
+		omap_cfg_reg(F4_7XX_KBC3);
+		omap_cfg_reg(E3_7XX_KBC4);
 	} else if (machine_is_omap_h4()) {
 		omap_cfg_reg(T19_24XX_KBR0);
 		omap_cfg_reg(R19_24XX_KBR1);
diff --git a/arch/arm/plat-omap/dma.c b/arch/arm/plat-omap/dma.c
index 0eb676d..034686d 100644
--- a/arch/arm/plat-omap/dma.c
+++ b/arch/arm/plat-omap/dma.c
@@ -2347,40 +2347,46 @@ EXPORT_SYMBOL(omap_stop_lcd_dma);
 
 static int __init omap_init_dma(void)
 {
+	unsigned long base;
 	int ch, r;
 
 	if (cpu_class_is_omap1()) {
-		omap_dma_base = OMAP1_IO_ADDRESS(OMAP1_DMA_BASE);
+		base = OMAP1_DMA_BASE;
 		dma_lch_count = OMAP1_LOGICAL_DMA_CH_COUNT;
 	} else if (cpu_is_omap24xx()) {
-		omap_dma_base = OMAP2_IO_ADDRESS(OMAP24XX_DMA4_BASE);
+		base = OMAP24XX_DMA4_BASE;
 		dma_lch_count = OMAP_DMA4_LOGICAL_DMA_CH_COUNT;
 	} else if (cpu_is_omap34xx()) {
-		omap_dma_base = OMAP2_IO_ADDRESS(OMAP34XX_DMA4_BASE);
+		base = OMAP34XX_DMA4_BASE;
 		dma_lch_count = OMAP_DMA4_LOGICAL_DMA_CH_COUNT;
 	} else if (cpu_is_omap44xx()) {
-		omap_dma_base = OMAP2_IO_ADDRESS(OMAP44XX_DMA4_BASE);
+		base = OMAP44XX_DMA4_BASE;
 		dma_lch_count = OMAP_DMA4_LOGICAL_DMA_CH_COUNT;
 	} else {
 		pr_err("DMA init failed for unsupported omap\n");
 		return -ENODEV;
 	}
 
+	omap_dma_base = ioremap(base, SZ_4K);
+	BUG_ON(!omap_dma_base);
+
 	if (cpu_class_is_omap2() && omap_dma_reserve_channels
 			&& (omap_dma_reserve_channels <= dma_lch_count))
 		dma_lch_count = omap_dma_reserve_channels;
 
 	dma_chan = kzalloc(sizeof(struct omap_dma_lch) * dma_lch_count,
 				GFP_KERNEL);
-	if (!dma_chan)
-		return -ENOMEM;
+	if (!dma_chan) {
+		r = -ENOMEM;
+		goto out_unmap;
+	}
 
 	if (cpu_class_is_omap2()) {
 		dma_linked_lch = kzalloc(sizeof(struct dma_link_info) *
 						dma_lch_count, GFP_KERNEL);
 		if (!dma_linked_lch) {
-			kfree(dma_chan);
-			return -ENOMEM;
+			r = -ENOMEM;
+			goto out_free;
 		}
 	}
 
@@ -2454,7 +2460,7 @@ static int __init omap_init_dma(void)
 				for (i = 0; i < ch; i++)
 					free_irq(omap1_dma_irq[i],
 						 (void *) (i + 1));
-				return r;
+				goto out_free;
 			}
 		}
 	}
@@ -2496,11 +2502,19 @@ static int __init omap_init_dma(void)
 			       "(error %d)\n", r);
 			for (i = 0; i < dma_chan_count; i++)
 				free_irq(omap1_dma_irq[i], (void *) (i + 1));
-			return r;
+			goto out_free;
 		}
 	}
 
 	return 0;
+
+out_free:
+	kfree(dma_chan);
+
+out_unmap:
+	iounmap(omap_dma_base);
+
+	return r;
 }
 
 arch_initcall(omap_init_dma);
diff --git a/arch/arm/plat-omap/dmtimer.c b/arch/arm/plat-omap/dmtimer.c
index d325b54..e4e848e 100644
--- a/arch/arm/plat-omap/dmtimer.c
+++ b/arch/arm/plat-omap/dmtimer.c
@@ -742,16 +742,17 @@ EXPORT_SYMBOL_GPL(omap_dm_timers_active);
 int __init omap_dm_timer_init(void)
 {
 	struct omap_dm_timer *timer;
-	int i;
+	int i, map_size = SZ_8K;	/* Module 4KB + L4 4KB except on omap1 */
 
 	if (!(cpu_is_omap16xx() || cpu_class_is_omap2()))
 		return -ENODEV;
 
 	spin_lock_init(&dm_timer_lock);
 
-	if (cpu_class_is_omap1())
+	if (cpu_class_is_omap1()) {
 		dm_timers = omap1_dm_timers;
-	else if (cpu_is_omap24xx()) {
+		map_size = SZ_2K;
+	} else if (cpu_is_omap24xx()) {
 		dm_timers = omap2_dm_timers;
 		dm_source_names = omap2_dm_source_names;
 		dm_source_clocks = omap2_dm_source_clocks;
@@ -774,10 +775,11 @@ int __init omap_dm_timer_init(void)
 
 	for (i = 0; i < dm_timer_count; i++) {
 		timer = &dm_timers[i];
-		if (cpu_class_is_omap1())
-			timer->io_base = OMAP1_IO_ADDRESS(timer->phys_base);
-		else
-			timer->io_base = OMAP2_IO_ADDRESS(timer->phys_base);
+
+		/* Static mapping, never released */
+		timer->io_base = ioremap(timer->phys_base, map_size);
+		BUG_ON(!timer->io_base);
+
 #if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3) || \
 					defined(CONFIG_ARCH_OMAP4)
 		if (cpu_class_is_omap2()) {
diff --git a/arch/arm/plat-omap/gpio.c b/arch/arm/plat-omap/gpio.c
index 71ebd7f..14c3506 100644
--- a/arch/arm/plat-omap/gpio.c
+++ b/arch/arm/plat-omap/gpio.c
@@ -31,7 +31,7 @@
 /*
  * OMAP1510 GPIO registers
  */
-#define OMAP1510_GPIO_BASE		OMAP1_IO_ADDRESS(0xfffce000)
+#define OMAP1510_GPIO_BASE		0xfffce000
 #define OMAP1510_GPIO_DATA_INPUT	0x00
 #define OMAP1510_GPIO_DATA_OUTPUT	0x04
 #define OMAP1510_GPIO_DIR_CONTROL	0x08
@@ -45,10 +45,10 @@
 /*
  * OMAP1610 specific GPIO registers
  */
-#define OMAP1610_GPIO1_BASE		OMAP1_IO_ADDRESS(0xfffbe400)
-#define OMAP1610_GPIO2_BASE		OMAP1_IO_ADDRESS(0xfffbec00)
-#define OMAP1610_GPIO3_BASE		OMAP1_IO_ADDRESS(0xfffbb400)
-#define OMAP1610_GPIO4_BASE		OMAP1_IO_ADDRESS(0xfffbbc00)
+#define OMAP1610_GPIO1_BASE		0xfffbe400
+#define OMAP1610_GPIO2_BASE		0xfffbec00
+#define OMAP1610_GPIO3_BASE		0xfffbb400
+#define OMAP1610_GPIO4_BASE		0xfffbbc00
 #define OMAP1610_GPIO_REVISION		0x0000
 #define OMAP1610_GPIO_SYSCONFIG		0x0010
 #define OMAP1610_GPIO_SYSSTATUS		0x0014
@@ -68,52 +68,36 @@
 #define OMAP1610_GPIO_SET_DATAOUT	0x00f0
 
 /*
- * OMAP730 specific GPIO registers
+ * OMAP7XX specific GPIO registers
  */
-#define OMAP730_GPIO1_BASE		OMAP1_IO_ADDRESS(0xfffbc000)
-#define OMAP730_GPIO2_BASE		OMAP1_IO_ADDRESS(0xfffbc800)
-#define OMAP730_GPIO3_BASE		OMAP1_IO_ADDRESS(0xfffbd000)
-#define OMAP730_GPIO4_BASE		OMAP1_IO_ADDRESS(0xfffbd800)
-#define OMAP730_GPIO5_BASE		OMAP1_IO_ADDRESS(0xfffbe000)
-#define OMAP730_GPIO6_BASE		OMAP1_IO_ADDRESS(0xfffbe800)
-#define OMAP730_GPIO_DATA_INPUT		0x00
-#define OMAP730_GPIO_DATA_OUTPUT	0x04
-#define OMAP730_GPIO_DIR_CONTROL	0x08
-#define OMAP730_GPIO_INT_CONTROL	0x0c
-#define OMAP730_GPIO_INT_MASK		0x10
-#define OMAP730_GPIO_INT_STATUS		0x14
-
-/*
- * OMAP850 specific GPIO registers
- */
-#define OMAP850_GPIO1_BASE		OMAP1_IO_ADDRESS(0xfffbc000)
-#define OMAP850_GPIO2_BASE		OMAP1_IO_ADDRESS(0xfffbc800)
-#define OMAP850_GPIO3_BASE		OMAP1_IO_ADDRESS(0xfffbd000)
-#define OMAP850_GPIO4_BASE		OMAP1_IO_ADDRESS(0xfffbd800)
-#define OMAP850_GPIO5_BASE		OMAP1_IO_ADDRESS(0xfffbe000)
-#define OMAP850_GPIO6_BASE		OMAP1_IO_ADDRESS(0xfffbe800)
-#define OMAP850_GPIO_DATA_INPUT		0x00
-#define OMAP850_GPIO_DATA_OUTPUT	0x04
-#define OMAP850_GPIO_DIR_CONTROL	0x08
-#define OMAP850_GPIO_INT_CONTROL	0x0c
-#define OMAP850_GPIO_INT_MASK		0x10
-#define OMAP850_GPIO_INT_STATUS		0x14
-
-#define OMAP1_MPUIO_VBASE		OMAP1_IO_ADDRESS(OMAP1_MPUIO_BASE)
+#define OMAP7XX_GPIO1_BASE		0xfffbc000
+#define OMAP7XX_GPIO2_BASE		0xfffbc800
+#define OMAP7XX_GPIO3_BASE		0xfffbd000
+#define OMAP7XX_GPIO4_BASE		0xfffbd800
+#define OMAP7XX_GPIO5_BASE		0xfffbe000
+#define OMAP7XX_GPIO6_BASE		0xfffbe800
+#define OMAP7XX_GPIO_DATA_INPUT		0x00
+#define OMAP7XX_GPIO_DATA_OUTPUT	0x04
+#define OMAP7XX_GPIO_DIR_CONTROL	0x08
+#define OMAP7XX_GPIO_INT_CONTROL	0x0c
+#define OMAP7XX_GPIO_INT_MASK		0x10
+#define OMAP7XX_GPIO_INT_STATUS		0x14
+
+#define OMAP1_MPUIO_VBASE		OMAP1_MPUIO_BASE
 
 /*
  * omap24xx specific GPIO registers
  */
-#define OMAP242X_GPIO1_BASE		OMAP2_IO_ADDRESS(0x48018000)
-#define OMAP242X_GPIO2_BASE		OMAP2_IO_ADDRESS(0x4801a000)
-#define OMAP242X_GPIO3_BASE		OMAP2_IO_ADDRESS(0x4801c000)
-#define OMAP242X_GPIO4_BASE		OMAP2_IO_ADDRESS(0x4801e000)
+#define OMAP242X_GPIO1_BASE		0x48018000
+#define OMAP242X_GPIO2_BASE		0x4801a000
+#define OMAP242X_GPIO3_BASE		0x4801c000
+#define OMAP242X_GPIO4_BASE		0x4801e000
 
-#define OMAP243X_GPIO1_BASE		OMAP2_IO_ADDRESS(0x4900C000)
-#define OMAP243X_GPIO2_BASE		OMAP2_IO_ADDRESS(0x4900E000)
-#define OMAP243X_GPIO3_BASE		OMAP2_IO_ADDRESS(0x49010000)
-#define OMAP243X_GPIO4_BASE		OMAP2_IO_ADDRESS(0x49012000)
-#define OMAP243X_GPIO5_BASE		OMAP2_IO_ADDRESS(0x480B6000)
+#define OMAP243X_GPIO1_BASE		0x4900C000
+#define OMAP243X_GPIO2_BASE		0x4900E000
+#define OMAP243X_GPIO3_BASE		0x49010000
+#define OMAP243X_GPIO4_BASE		0x49012000
+#define OMAP243X_GPIO5_BASE		0x480B6000
 
 #define OMAP24XX_GPIO_REVISION		0x0000
 #define OMAP24XX_GPIO_SYSCONFIG		0x0010
@@ -170,24 +154,25 @@
  * omap34xx specific GPIO registers
  */
 
-#define OMAP34XX_GPIO1_BASE		OMAP2_IO_ADDRESS(0x48310000)
-#define OMAP34XX_GPIO2_BASE		OMAP2_IO_ADDRESS(0x49050000)
-#define OMAP34XX_GPIO3_BASE		OMAP2_IO_ADDRESS(0x49052000)
-#define OMAP34XX_GPIO4_BASE		OMAP2_IO_ADDRESS(0x49054000)
-#define OMAP34XX_GPIO5_BASE		OMAP2_IO_ADDRESS(0x49056000)
-#define OMAP34XX_GPIO6_BASE		OMAP2_IO_ADDRESS(0x49058000)
+#define OMAP34XX_GPIO1_BASE		0x48310000
+#define OMAP34XX_GPIO2_BASE		0x49050000
+#define OMAP34XX_GPIO3_BASE		0x49052000
+#define OMAP34XX_GPIO4_BASE		0x49054000
+#define OMAP34XX_GPIO5_BASE		0x49056000
+#define OMAP34XX_GPIO6_BASE		0x49058000
 
 /*
  * OMAP44XX  specific GPIO registers
  */
-#define OMAP44XX_GPIO1_BASE             OMAP2_IO_ADDRESS(0x4a310000)
-#define OMAP44XX_GPIO2_BASE             OMAP2_IO_ADDRESS(0x48055000)
-#define OMAP44XX_GPIO3_BASE             OMAP2_IO_ADDRESS(0x48057000)
-#define OMAP44XX_GPIO4_BASE             OMAP2_IO_ADDRESS(0x48059000)
-#define OMAP44XX_GPIO5_BASE             OMAP2_IO_ADDRESS(0x4805B000)
-#define OMAP44XX_GPIO6_BASE             OMAP2_IO_ADDRESS(0x4805D000)
+#define OMAP44XX_GPIO1_BASE             0x4a310000
+#define OMAP44XX_GPIO2_BASE             0x48055000
+#define OMAP44XX_GPIO3_BASE             0x48057000
+#define OMAP44XX_GPIO4_BASE             0x48059000
+#define OMAP44XX_GPIO5_BASE             0x4805B000
+#define OMAP44XX_GPIO6_BASE             0x4805D000
 
 struct gpio_bank {
+	unsigned long pbase;
 	void __iomem *base;
 	u16 irq;
 	u16 virtual_irq_start;
@@ -215,96 +200,111 @@ struct gpio_bank {
 #define METHOD_MPUIO		0
 #define METHOD_GPIO_1510	1
 #define METHOD_GPIO_1610	2
-#define METHOD_GPIO_730		3
-#define METHOD_GPIO_850		4
+#define METHOD_GPIO_7XX		3
 #define METHOD_GPIO_24XX	5
 
 #ifdef CONFIG_ARCH_OMAP16XX
 static struct gpio_bank gpio_bank_1610[5] = {
-	{ OMAP1_MPUIO_VBASE,    INT_MPUIO,	    IH_MPUIO_BASE,     METHOD_MPUIO},
-	{ OMAP1610_GPIO1_BASE, INT_GPIO_BANK1,	    IH_GPIO_BASE,      METHOD_GPIO_1610 },
-	{ OMAP1610_GPIO2_BASE, INT_1610_GPIO_BANK2, IH_GPIO_BASE + 16, METHOD_GPIO_1610 },
-	{ OMAP1610_GPIO3_BASE, INT_1610_GPIO_BANK3, IH_GPIO_BASE + 32, METHOD_GPIO_1610 },
-	{ OMAP1610_GPIO4_BASE, INT_1610_GPIO_BANK4, IH_GPIO_BASE + 48, METHOD_GPIO_1610 },
+	{ OMAP1_MPUIO_VBASE, 0, INT_MPUIO, IH_MPUIO_BASE,
+		METHOD_MPUIO },
+	{ OMAP1610_GPIO1_BASE, 0, INT_GPIO_BANK1, IH_GPIO_BASE,
+		METHOD_GPIO_1610 },
+	{ OMAP1610_GPIO2_BASE, 0, INT_1610_GPIO_BANK2, IH_GPIO_BASE + 16,
+		METHOD_GPIO_1610 },
+	{ OMAP1610_GPIO3_BASE, 0, INT_1610_GPIO_BANK3, IH_GPIO_BASE + 32,
+		METHOD_GPIO_1610 },
+	{ OMAP1610_GPIO4_BASE, 0, INT_1610_GPIO_BANK4, IH_GPIO_BASE + 48,
+		METHOD_GPIO_1610 },
 };
 #endif
 
 #ifdef CONFIG_ARCH_OMAP15XX
 static struct gpio_bank gpio_bank_1510[2] = {
-	{ OMAP1_MPUIO_VBASE,   INT_MPUIO,      IH_MPUIO_BASE, METHOD_MPUIO },
-	{ OMAP1510_GPIO_BASE, INT_GPIO_BANK1, IH_GPIO_BASE,  METHOD_GPIO_1510 }
-};
-#endif
-
-#ifdef CONFIG_ARCH_OMAP730
-static struct gpio_bank gpio_bank_730[7] = {
-	{ OMAP1_MPUIO_VBASE,    INT_730_MPUIO,	    IH_MPUIO_BASE,	METHOD_MPUIO },
-	{ OMAP730_GPIO1_BASE,  INT_730_GPIO_BANK1,  IH_GPIO_BASE,	METHOD_GPIO_730 },
-	{ OMAP730_GPIO2_BASE,  INT_730_GPIO_BANK2,  IH_GPIO_BASE + 32,	METHOD_GPIO_730 },
-	{ OMAP730_GPIO3_BASE,  INT_730_GPIO_BANK3,  IH_GPIO_BASE + 64,	METHOD_GPIO_730 },
-	{ OMAP730_GPIO4_BASE,  INT_730_GPIO_BANK4,  IH_GPIO_BASE + 96,	METHOD_GPIO_730 },
-	{ OMAP730_GPIO5_BASE,  INT_730_GPIO_BANK5,  IH_GPIO_BASE + 128, METHOD_GPIO_730 },
-	{ OMAP730_GPIO6_BASE,  INT_730_GPIO_BANK6,  IH_GPIO_BASE + 160, METHOD_GPIO_730 },
+	{ OMAP1_MPUIO_VBASE, 0, INT_MPUIO, IH_MPUIO_BASE,
+		METHOD_MPUIO },
+	{ OMAP1510_GPIO_BASE, 0, INT_GPIO_BANK1, IH_GPIO_BASE,
+		METHOD_GPIO_1510 }
 };
 #endif
 
-#ifdef CONFIG_ARCH_OMAP850
-static struct gpio_bank gpio_bank_850[7] = {
-	{ OMAP1_MPUIO_VBASE,     INT_850_MPUIO,	    IH_MPUIO_BASE,	METHOD_MPUIO },
-	{ OMAP850_GPIO1_BASE,  INT_850_GPIO_BANK1,  IH_GPIO_BASE,	METHOD_GPIO_850 },
-	{ OMAP850_GPIO2_BASE,  INT_850_GPIO_BANK2,  IH_GPIO_BASE + 32,	METHOD_GPIO_850 },
-	{ OMAP850_GPIO3_BASE,  INT_850_GPIO_BANK3,  IH_GPIO_BASE + 64,	METHOD_GPIO_850 },
-	{ OMAP850_GPIO4_BASE,  INT_850_GPIO_BANK4,  IH_GPIO_BASE + 96,	METHOD_GPIO_850 },
-	{ OMAP850_GPIO5_BASE,  INT_850_GPIO_BANK5,  IH_GPIO_BASE + 128, METHOD_GPIO_850 },
-	{ OMAP850_GPIO6_BASE,  INT_850_GPIO_BANK6,  IH_GPIO_BASE + 160, METHOD_GPIO_850 },
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+static struct gpio_bank gpio_bank_7xx[7] = {
+	{ OMAP1_MPUIO_VBASE, 0, INT_7XX_MPUIO, IH_MPUIO_BASE,
+		METHOD_MPUIO },
+	{ OMAP7XX_GPIO1_BASE, 0, INT_7XX_GPIO_BANK1, IH_GPIO_BASE,
+		METHOD_GPIO_7XX },
+	{ OMAP7XX_GPIO2_BASE, 0, INT_7XX_GPIO_BANK2, IH_GPIO_BASE + 32,
+		METHOD_GPIO_7XX },
+	{ OMAP7XX_GPIO3_BASE, 0, INT_7XX_GPIO_BANK3, IH_GPIO_BASE + 64,
+		METHOD_GPIO_7XX },
+	{ OMAP7XX_GPIO4_BASE, 0, INT_7XX_GPIO_BANK4,  IH_GPIO_BASE + 96,
+		METHOD_GPIO_7XX },
+	{ OMAP7XX_GPIO5_BASE, 0, INT_7XX_GPIO_BANK5,  IH_GPIO_BASE + 128,
+		METHOD_GPIO_7XX },
+	{ OMAP7XX_GPIO6_BASE, 0, INT_7XX_GPIO_BANK6,  IH_GPIO_BASE + 160,
+		METHOD_GPIO_7XX },
 };
 #endif
 
-
 #ifdef CONFIG_ARCH_OMAP24XX
 
 static struct gpio_bank gpio_bank_242x[4] = {
-	{ OMAP242X_GPIO1_BASE, INT_24XX_GPIO_BANK1, IH_GPIO_BASE,	METHOD_GPIO_24XX },
-	{ OMAP242X_GPIO2_BASE, INT_24XX_GPIO_BANK2, IH_GPIO_BASE + 32,	METHOD_GPIO_24XX },
-	{ OMAP242X_GPIO3_BASE, INT_24XX_GPIO_BANK3, IH_GPIO_BASE + 64,	METHOD_GPIO_24XX },
-	{ OMAP242X_GPIO4_BASE, INT_24XX_GPIO_BANK4, IH_GPIO_BASE + 96,	METHOD_GPIO_24XX },
+	{ OMAP242X_GPIO1_BASE, 0, INT_24XX_GPIO_BANK1, IH_GPIO_BASE,
+		METHOD_GPIO_24XX },
+	{ OMAP242X_GPIO2_BASE, 0, INT_24XX_GPIO_BANK2, IH_GPIO_BASE + 32,
+		METHOD_GPIO_24XX },
+	{ OMAP242X_GPIO3_BASE, 0, INT_24XX_GPIO_BANK3, IH_GPIO_BASE + 64,
+		METHOD_GPIO_24XX },
+	{ OMAP242X_GPIO4_BASE, 0, INT_24XX_GPIO_BANK4, IH_GPIO_BASE + 96,
+		METHOD_GPIO_24XX },
 };
 
 static struct gpio_bank gpio_bank_243x[5] = {
-	{ OMAP243X_GPIO1_BASE, INT_24XX_GPIO_BANK1, IH_GPIO_BASE,	METHOD_GPIO_24XX },
-	{ OMAP243X_GPIO2_BASE, INT_24XX_GPIO_BANK2, IH_GPIO_BASE + 32,	METHOD_GPIO_24XX },
-	{ OMAP243X_GPIO3_BASE, INT_24XX_GPIO_BANK3, IH_GPIO_BASE + 64,	METHOD_GPIO_24XX },
-	{ OMAP243X_GPIO4_BASE, INT_24XX_GPIO_BANK4, IH_GPIO_BASE + 96,	METHOD_GPIO_24XX },
-	{ OMAP243X_GPIO5_BASE, INT_24XX_GPIO_BANK5, IH_GPIO_BASE + 128, METHOD_GPIO_24XX },
+	{ OMAP243X_GPIO1_BASE, 0, INT_24XX_GPIO_BANK1, IH_GPIO_BASE,
+		METHOD_GPIO_24XX },
+	{ OMAP243X_GPIO2_BASE, 0, INT_24XX_GPIO_BANK2, IH_GPIO_BASE + 32,
+		METHOD_GPIO_24XX },
+	{ OMAP243X_GPIO3_BASE, 0, INT_24XX_GPIO_BANK3, IH_GPIO_BASE + 64,
+		METHOD_GPIO_24XX },
+	{ OMAP243X_GPIO4_BASE, 0, INT_24XX_GPIO_BANK4, IH_GPIO_BASE + 96,
+		METHOD_GPIO_24XX },
+	{ OMAP243X_GPIO5_BASE, 0, INT_24XX_GPIO_BANK5, IH_GPIO_BASE + 128,
+		METHOD_GPIO_24XX },
 };
 
 #endif
 
 #ifdef CONFIG_ARCH_OMAP34XX
 static struct gpio_bank gpio_bank_34xx[6] = {
-	{ OMAP34XX_GPIO1_BASE, INT_34XX_GPIO_BANK1, IH_GPIO_BASE,	METHOD_GPIO_24XX },
-	{ OMAP34XX_GPIO2_BASE, INT_34XX_GPIO_BANK2, IH_GPIO_BASE + 32,	METHOD_GPIO_24XX },
-	{ OMAP34XX_GPIO3_BASE, INT_34XX_GPIO_BANK3, IH_GPIO_BASE + 64,	METHOD_GPIO_24XX },
-	{ OMAP34XX_GPIO4_BASE, INT_34XX_GPIO_BANK4, IH_GPIO_BASE + 96,	METHOD_GPIO_24XX },
-	{ OMAP34XX_GPIO5_BASE, INT_34XX_GPIO_BANK5, IH_GPIO_BASE + 128, METHOD_GPIO_24XX },
-	{ OMAP34XX_GPIO6_BASE, INT_34XX_GPIO_BANK6, IH_GPIO_BASE + 160, METHOD_GPIO_24XX },
+	{ OMAP34XX_GPIO1_BASE, 0, INT_34XX_GPIO_BANK1, IH_GPIO_BASE,
+		METHOD_GPIO_24XX },
+	{ OMAP34XX_GPIO2_BASE, 0, INT_34XX_GPIO_BANK2, IH_GPIO_BASE + 32,
+		METHOD_GPIO_24XX },
+	{ OMAP34XX_GPIO3_BASE, 0, INT_34XX_GPIO_BANK3, IH_GPIO_BASE + 64,
+		METHOD_GPIO_24XX },
+	{ OMAP34XX_GPIO4_BASE, 0, INT_34XX_GPIO_BANK4, IH_GPIO_BASE + 96,
+		METHOD_GPIO_24XX },
+	{ OMAP34XX_GPIO5_BASE, 0, INT_34XX_GPIO_BANK5, IH_GPIO_BASE + 128,
+		METHOD_GPIO_24XX },
+	{ OMAP34XX_GPIO6_BASE, 0, INT_34XX_GPIO_BANK6, IH_GPIO_BASE + 160,
+		METHOD_GPIO_24XX },
 };
 
 #endif
 
 #ifdef CONFIG_ARCH_OMAP4
 static struct gpio_bank gpio_bank_44xx[6] = {
-	{ OMAP44XX_GPIO1_BASE, INT_44XX_GPIO_BANK1, IH_GPIO_BASE,	\
+	{ OMAP44XX_GPIO1_BASE, 0, INT_44XX_GPIO_BANK1, IH_GPIO_BASE,
 		METHOD_GPIO_24XX },
-	{ OMAP44XX_GPIO2_BASE, INT_44XX_GPIO_BANK2, IH_GPIO_BASE + 32,	\
+	{ OMAP44XX_GPIO2_BASE, 0, INT_44XX_GPIO_BANK2, IH_GPIO_BASE + 32,
 		METHOD_GPIO_24XX },
-	{ OMAP44XX_GPIO3_BASE, INT_44XX_GPIO_BANK3, IH_GPIO_BASE + 64,	\
+	{ OMAP44XX_GPIO3_BASE, 0, INT_44XX_GPIO_BANK3, IH_GPIO_BASE + 64,
 		METHOD_GPIO_24XX },
-	{ OMAP44XX_GPIO4_BASE, INT_44XX_GPIO_BANK4, IH_GPIO_BASE + 96,	\
+	{ OMAP44XX_GPIO4_BASE, 0, INT_44XX_GPIO_BANK4, IH_GPIO_BASE + 96,
 		METHOD_GPIO_24XX },
-	{ OMAP44XX_GPIO5_BASE, INT_44XX_GPIO_BANK5, IH_GPIO_BASE + 128, \
+	{ OMAP44XX_GPIO5_BASE, 0, INT_44XX_GPIO_BANK5, IH_GPIO_BASE + 128,
 		METHOD_GPIO_24XX },
-	{ OMAP44XX_GPIO6_BASE, INT_44XX_GPIO_BANK6, IH_GPIO_BASE + 160, \
+	{ OMAP44XX_GPIO6_BASE, 0, INT_44XX_GPIO_BANK6, IH_GPIO_BASE + 160,
 		METHOD_GPIO_24XX },
 };
 
@@ -373,7 +373,7 @@ static inline int gpio_valid(int gpio)
 
 static int check_gpio(int gpio)
 {
-	if (unlikely(gpio_valid(gpio)) < 0) {
+	if (unlikely(gpio_valid(gpio) < 0)) {
 		printk(KERN_ERR "omap-gpio: invalid GPIO %d\n", gpio);
 		dump_stack();
 		return -1;
@@ -402,14 +402,9 @@ static void _set_gpio_direction(struct gpio_bank *bank, int gpio, int is_input)
 		reg += OMAP1610_GPIO_DIRECTION;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_DIR_CONTROL;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_DIR_CONTROL;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_DIR_CONTROL;
 		break;
 #endif
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
@@ -469,19 +464,9 @@ static void _set_gpio_dataout(struct gpio_bank *bank, int gpio, int enable)
 		l = 1 << gpio;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_DATA_OUTPUT;
-		l = __raw_readl(reg);
-		if (enable)
-			l |= 1 << gpio;
-		else
-			l &= ~(1 << gpio);
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_DATA_OUTPUT;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_DATA_OUTPUT;
 		l = __raw_readl(reg);
 		if (enable)
 			l |= 1 << gpio;
@@ -537,14 +522,9 @@ static int _get_gpio_datain(struct gpio_bank *bank, int gpio)
 		reg += OMAP1610_GPIO_DATAIN;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_DATA_INPUT;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_DATA_INPUT;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_DATA_INPUT;
 		break;
 #endif
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
@@ -588,14 +568,9 @@ static int _get_gpio_dataout(struct gpio_bank *bank, int gpio)
 		reg += OMAP1610_GPIO_DATAOUT;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_DATA_OUTPUT;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_DATA_OUTPUT;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_DATA_OUTPUT;
 		break;
 #endif
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX) || \
@@ -797,21 +772,9 @@ static int _set_gpio_triggering(struct gpio_bank *bank, int gpio, int trigger)
 			__raw_writel(1 << gpio, bank->base + OMAP1610_GPIO_CLEAR_WAKEUPENA);
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_INT_CONTROL;
-		l = __raw_readl(reg);
-		if (trigger & IRQ_TYPE_EDGE_RISING)
-			l |= 1 << gpio;
-		else if (trigger & IRQ_TYPE_EDGE_FALLING)
-			l &= ~(1 << gpio);
-		else
-			goto bad;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_INT_CONTROL;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_INT_CONTROL;
 		l = __raw_readl(reg);
 		if (trigger & IRQ_TYPE_EDGE_RISING)
 			l |= 1 << gpio;
@@ -897,14 +860,9 @@ static void _clear_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)
 		reg += OMAP1610_GPIO_IRQSTATUS1;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_INT_STATUS;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_INT_STATUS;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_INT_STATUS;
 		break;
 #endif
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
@@ -971,16 +929,9 @@ static u32 _get_gpio_irqbank_mask(struct gpio_bank *bank)
 		mask = 0xffff;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_INT_MASK;
-		mask = 0xffffffff;
-		inv = 1;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_INT_MASK;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_INT_MASK;
 		mask = 0xffffffff;
 		inv = 1;
 		break;
@@ -1044,19 +995,9 @@ static void _enable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask, int enab
 		l = gpio_mask;
 		break;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_INT_MASK;
-		l = __raw_readl(reg);
-		if (enable)
-			l &= ~(gpio_mask);
-		else
-			l |= gpio_mask;
-		break;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_INT_MASK;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_INT_MASK;
 		l = __raw_readl(reg);
 		if (enable)
 			l &= ~(gpio_mask);
@@ -1249,13 +1190,9 @@ static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
 	if (bank->method == METHOD_GPIO_1610)
 		isr_reg = bank->base + OMAP1610_GPIO_IRQSTATUS1;
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	if (bank->method == METHOD_GPIO_730)
-		isr_reg = bank->base + OMAP730_GPIO_INT_STATUS;
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	if (bank->method == METHOD_GPIO_850)
-		isr_reg = bank->base + OMAP850_GPIO_INT_STATUS;
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	if (bank->method == METHOD_GPIO_7XX)
+		isr_reg = bank->base + OMAP7XX_GPIO_INT_STATUS;
 #endif
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
 	if (bank->method == METHOD_GPIO_24XX)
@@ -1524,11 +1461,8 @@ static int gpio_is_input(struct gpio_bank *bank, int mask)
 	case METHOD_GPIO_1610:
 		reg += OMAP1610_GPIO_DIRECTION;
 		break;
-	case METHOD_GPIO_730:
-		reg += OMAP730_GPIO_DIR_CONTROL;
-		break;
-	case METHOD_GPIO_850:
-		reg += OMAP850_GPIO_DIR_CONTROL;
+	case METHOD_GPIO_7XX:
+		reg += OMAP7XX_GPIO_DIR_CONTROL;
 		break;
 	case METHOD_GPIO_24XX:
 		reg += OMAP24XX_GPIO_OE;
@@ -1607,6 +1541,23 @@ static struct clk * gpio5_fck;
 static struct clk *gpio_iclks[OMAP34XX_NR_GPIOS];
 #endif
 
+static void __init omap_gpio_show_rev(void)
+{
+	u32 rev;
+
+	if (cpu_is_omap16xx())
+		rev = __raw_readw(gpio_bank[1].base + OMAP1610_GPIO_REVISION);
+	else if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		rev = __raw_readl(gpio_bank[0].base + OMAP24XX_GPIO_REVISION);
+	else if (cpu_is_omap44xx())
+		rev = __raw_readl(gpio_bank[0].base + OMAP4_GPIO_REVISION);
+	else
+		return;
+
+	printk(KERN_INFO "OMAP GPIO hardware version %d.%d\n",
+		(rev >> 4) & 0x0f, rev & 0x0f);
+}
+
 /* This lock class tells lockdep that GPIO irqs are in a different
  * category than their parents, so it won't report false recursion.
  */
@@ -1617,6 +1568,7 @@ static int __init _omap_gpio_init(void)
 	int i;
 	int gpio = 0;
 	struct gpio_bank *bank;
+	int bank_size = SZ_8K;	/* Module 4KB + L4 4KB except on omap1 */
 	char clk_name[11];
 
 	initialized = 1;
@@ -1679,77 +1631,45 @@ static int __init _omap_gpio_init(void)
 
 #ifdef CONFIG_ARCH_OMAP15XX
 	if (cpu_is_omap15xx()) {
-		printk(KERN_INFO "OMAP1510 GPIO hardware\n");
 		gpio_bank_count = 2;
 		gpio_bank = gpio_bank_1510;
+		bank_size = SZ_2K;
 	}
 #endif
 #if defined(CONFIG_ARCH_OMAP16XX)
 	if (cpu_is_omap16xx()) {
-		u32 rev;
-
 		gpio_bank_count = 5;
 		gpio_bank = gpio_bank_1610;
-		rev = __raw_readw(gpio_bank[1].base + OMAP1610_GPIO_REVISION);
-		printk(KERN_INFO "OMAP GPIO hardware version %d.%d\n",
-		       (rev >> 4) & 0x0f, rev & 0x0f);
+		bank_size = SZ_2K;
 	}
 #endif
-#ifdef CONFIG_ARCH_OMAP730
-	if (cpu_is_omap730()) {
-		printk(KERN_INFO "OMAP730 GPIO hardware\n");
-		gpio_bank_count = 7;
-		gpio_bank = gpio_bank_730;
-	}
-#endif
-#ifdef CONFIG_ARCH_OMAP850
-	if (cpu_is_omap850()) {
-		printk(KERN_INFO "OMAP850 GPIO hardware\n");
+#if defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+	if (cpu_is_omap7xx()) {
 		gpio_bank_count = 7;
-		gpio_bank = gpio_bank_850;
+		gpio_bank = gpio_bank_7xx;
+		bank_size = SZ_2K;
 	}
 #endif
-
 #ifdef CONFIG_ARCH_OMAP24XX
 	if (cpu_is_omap242x()) {
-		int rev;
-
 		gpio_bank_count = 4;
 		gpio_bank = gpio_bank_242x;
-		rev = __raw_readl(gpio_bank[0].base + OMAP24XX_GPIO_REVISION);
-		printk(KERN_INFO "OMAP242x GPIO hardware version %d.%d\n",
-			(rev >> 4) & 0x0f, rev & 0x0f);
 	}
 	if (cpu_is_omap243x()) {
-		int rev;
-
 		gpio_bank_count = 5;
 		gpio_bank = gpio_bank_243x;
-		rev = __raw_readl(gpio_bank[0].base + OMAP24XX_GPIO_REVISION);
-		printk(KERN_INFO "OMAP243x GPIO hardware version %d.%d\n",
-			(rev >> 4) & 0x0f, rev & 0x0f);
 	}
 #endif
 #ifdef CONFIG_ARCH_OMAP34XX
 	if (cpu_is_omap34xx()) {
-		int rev;
-
 		gpio_bank_count = OMAP34XX_NR_GPIOS;
 		gpio_bank = gpio_bank_34xx;
-		rev = __raw_readl(gpio_bank[0].base + OMAP24XX_GPIO_REVISION);
-		printk(KERN_INFO "OMAP34xx GPIO hardware version %d.%d\n",
-			(rev >> 4) & 0x0f, rev & 0x0f);
 	}
 #endif
 #ifdef CONFIG_ARCH_OMAP4
 	if (cpu_is_omap44xx()) {
-		int rev;
-
 		gpio_bank_count = OMAP34XX_NR_GPIOS;
 		gpio_bank = gpio_bank_44xx;
-		rev = __raw_readl(gpio_bank[0].base + OMAP4_GPIO_REVISION);
-		printk(KERN_INFO "OMAP44xx GPIO hardware version %d.%d\n",
-			(rev >> 4) & 0x0f, rev & 0x0f);
 	}
 #endif
 	for (i = 0; i < gpio_bank_count; i++) {
@@ -1757,6 +1677,14 @@ static int __init _omap_gpio_init(void)
 
 		bank = &gpio_bank[i];
 		spin_lock_init(&bank->lock);
+
+		/* Static mapping, never released */
+		bank->base = ioremap(bank->pbase, bank_size);
+		if (!bank->base) {
+			printk(KERN_ERR "Could not ioremap gpio bank%i\n", i);
+			continue;
+		}
+
 		if (bank_is_mpuio(bank))
 			__raw_writew(0xffff, bank->base + OMAP_MPUIO_GPIO_MASKIT);
 		if (cpu_is_omap15xx() && bank->method == METHOD_GPIO_1510) {
@@ -1768,11 +1696,11 @@ static int __init _omap_gpio_init(void)
 			__raw_writew(0xffff, bank->base + OMAP1610_GPIO_IRQSTATUS1);
 			__raw_writew(0x0014, bank->base + OMAP1610_GPIO_SYSCONFIG);
 		}
-		if (cpu_is_omap7xx() && bank->method == METHOD_GPIO_730) {
-			__raw_writel(0xffffffff, bank->base + OMAP730_GPIO_INT_MASK);
-			__raw_writel(0x00000000, bank->base + OMAP730_GPIO_INT_STATUS);
+		if (cpu_is_omap7xx() && bank->method == METHOD_GPIO_7XX) {
+			__raw_writel(0xffffffff, bank->base + OMAP7XX_GPIO_INT_MASK);
+			__raw_writel(0x00000000, bank->base + OMAP7XX_GPIO_INT_STATUS);
 
-			gpio_count = 32; /* 730 has 32-bit GPIOs */
+			gpio_count = 32; /* 7xx has 32-bit GPIOs */
 		}
 
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX) || \
@@ -1862,6 +1790,8 @@ static int __init _omap_gpio_init(void)
 	if (cpu_is_omap34xx())
 		omap_writel(1 << 0, 0x48306814);
 
+	omap_gpio_show_rev();
+
 	return 0;
 }
 
@@ -2160,8 +2090,7 @@ static int dbg_gpio_show(struct seq_file *s, void *unused)
 
 		if (bank_is_mpuio(bank))
 			gpio = OMAP_MPUIO(0);
-		else if (cpu_class_is_omap2() || cpu_is_omap730() ||
-				cpu_is_omap850())
+		else if (cpu_class_is_omap2() || cpu_is_omap7xx())
 			bankwidth = 32;
 
 		for (j = 0; j < bankwidth; j++, gpio++, mask <<= 1) {
diff --git a/arch/arm/plat-omap/include/mach/control.h b/arch/arm/plat-omap/include/mach/control.h
index 826d317..fdb6300 100644
--- a/arch/arm/plat-omap/include/mach/control.h
+++ b/arch/arm/plat-omap/include/mach/control.h
@@ -20,15 +20,18 @@
 
 #ifndef __ASSEMBLY__
 #define OMAP242X_CTRL_REGADDR(reg)					\
-	OMAP2_IO_ADDRESS(OMAP242X_CTRL_BASE + (reg))
+		OMAP2_L4_IO_ADDRESS(OMAP242X_CTRL_BASE + (reg))
 #define OMAP243X_CTRL_REGADDR(reg)					\
-	OMAP2_IO_ADDRESS(OMAP243X_CTRL_BASE + (reg))
+		OMAP2_L4_IO_ADDRESS(OMAP243X_CTRL_BASE + (reg))
 #define OMAP343X_CTRL_REGADDR(reg)					\
-	OMAP2_IO_ADDRESS(OMAP343X_CTRL_BASE + (reg))
+		OMAP2_L4_IO_ADDRESS(OMAP343X_CTRL_BASE + (reg))
 #else
-#define OMAP242X_CTRL_REGADDR(reg)	OMAP2_IO_ADDRESS(OMAP242X_CTRL_BASE + (reg))
-#define OMAP243X_CTRL_REGADDR(reg)	OMAP2_IO_ADDRESS(OMAP243X_CTRL_BASE + (reg))
-#define OMAP343X_CTRL_REGADDR(reg)	OMAP2_IO_ADDRESS(OMAP343X_CTRL_BASE + (reg))
+#define OMAP242X_CTRL_REGADDR(reg)					\
+		OMAP2_L4_IO_ADDRESS(OMAP242X_CTRL_BASE + (reg))
+#define OMAP243X_CTRL_REGADDR(reg)					\
+		OMAP2_L4_IO_ADDRESS(OMAP243X_CTRL_BASE + (reg))
+#define OMAP343X_CTRL_REGADDR(reg)					\
+		OMAP2_L4_IO_ADDRESS(OMAP343X_CTRL_BASE + (reg))
 #endif /* __ASSEMBLY__ */
 
 /*
@@ -202,6 +205,40 @@
 #define OMAP3_PADCONF_WAKEUPEVENT0	(1 << 15)
 #define OMAP3_PADCONF_WAKEUPENABLE0	(1 << 14)
 
+/*
+ * CONTROL OMAP STATUS register to identify OMAP3 features
+ */
+#define OMAP3_CONTROL_OMAP_STATUS	0x044c
+
+#define OMAP3_SGX_SHIFT			13
+#define OMAP3_SGX_MASK			(3 << OMAP3_SGX_SHIFT)
+#define		FEAT_SGX_FULL		0
+#define		FEAT_SGX_HALF		1
+#define		FEAT_SGX_NONE		2
+
+#define OMAP3_IVA_SHIFT			12
+#define OMAP3_IVA_MASK			(1 << OMAP3_SGX_SHIFT)
+#define		FEAT_IVA		0
+#define		FEAT_IVA_NONE		1
+
+#define OMAP3_L2CACHE_SHIFT		10
+#define OMAP3_L2CACHE_MASK		(3 << OMAP3_L2CACHE_SHIFT)
+#define		FEAT_L2CACHE_NONE	0
+#define		FEAT_L2CACHE_64KB	1
+#define		FEAT_L2CACHE_128KB	2
+#define		FEAT_L2CACHE_256KB	3
+
+#define OMAP3_ISP_SHIFT			5
+#define OMAP3_ISP_MASK			(1<< OMAP3_ISP_SHIFT)
+#define		FEAT_ISP		0
+#define		FEAT_ISP_NONE		1
+
+#define OMAP3_NEON_SHIFT		4
+#define OMAP3_NEON_MASK			(1<< OMAP3_NEON_SHIFT)
+#define		FEAT_NEON		0
+#define		FEAT_NEON_NONE		1
+
+
 #ifndef __ASSEMBLY__
 #if defined(CONFIG_ARCH_OMAP2) || defined(CONFIG_ARCH_OMAP3) || \
 		defined(CONFIG_ARCH_OMAP4)
diff --git a/arch/arm/plat-omap/include/mach/cpu.h b/arch/arm/plat-omap/include/mach/cpu.h
index f129efb..7cb0556 100644
--- a/arch/arm/plat-omap/include/mach/cpu.h
+++ b/arch/arm/plat-omap/include/mach/cpu.h
@@ -30,6 +30,8 @@
 #ifndef __ASM_ARCH_OMAP_CPU_H
 #define __ASM_ARCH_OMAP_CPU_H
 
+#include <linux/bitops.h>
+
 /*
  * Omap device type i.e. EMU/HS/TST/GP/BAD
  */
@@ -57,6 +59,23 @@ struct omap_chip_id {
 unsigned int omap_rev(void);
 
 /*
+ * Define CPU revision bits
+ *
+ * Verbose meaning of the revision bits may be different for a silicon
+ * family. This difference can be handled separately.
+ */
+#define OMAP_REVBITS_00		0x00
+#define OMAP_REVBITS_10		0x10
+#define OMAP_REVBITS_20		0x20
+#define OMAP_REVBITS_30		0x30
+#define OMAP_REVBITS_40		0x40
+
+/*
+ * Get the CPU revision for OMAP devices
+ */
+#define GET_OMAP_REVISION()	((omap_rev() >> 8) & 0xff)
+
+/*
  * Test if multicore OMAP support is needed
  */
 #undef MULTI_OMAP1
@@ -161,6 +180,7 @@ IS_OMAP_CLASS(34xx, 0x34)
 IS_OMAP_SUBCLASS(242x, 0x242)
 IS_OMAP_SUBCLASS(243x, 0x243)
 IS_OMAP_SUBCLASS(343x, 0x343)
+IS_OMAP_SUBCLASS(363x, 0x363)
 
 #define cpu_is_omap7xx()		0
 #define cpu_is_omap15xx()		0
@@ -301,7 +321,12 @@ IS_OMAP_TYPE(3430, 0x3430)
 #define cpu_is_omap2422()		0
 #define cpu_is_omap2423()		0
 #define cpu_is_omap2430()		0
+#define cpu_is_omap3503()		0
+#define cpu_is_omap3515()		0
+#define cpu_is_omap3525()		0
+#define cpu_is_omap3530()		0
 #define cpu_is_omap3430()		0
+#define cpu_is_omap3630()		0
 
 /*
  * Whether we have MULTI_OMAP1 or not, we still need to distinguish
@@ -351,7 +376,23 @@ IS_OMAP_TYPE(3430, 0x3430)
 
 #if defined(CONFIG_ARCH_OMAP34XX)
 # undef cpu_is_omap3430
+# undef cpu_is_omap3503
+# undef cpu_is_omap3515
+# undef cpu_is_omap3525
+# undef cpu_is_omap3530
 # define cpu_is_omap3430()		is_omap3430()
+# define cpu_is_omap3503		(cpu_is_omap3430() &&		\
+						(!omap3_has_iva()) &&	\
+						(!omap3_has_sgx()))
+# define cpu_is_omap3515		(cpu_is_omap3430() &&		\
+						(omap3_has_iva()) &&	\
+						(!omap3_has_sgx()))
+# define cpu_is_omap3525		(cpu_is_omap3430() &&		\
+						(omap3_has_sgx()) &&	\
+						(!omap3_has_iva()))
+# define cpu_is_omap3530		(cpu_is_omap3430())
+# undef cpu_is_omap3630
+# define cpu_is_omap3630()		is_omap363x()
 #endif
 
 # if defined(CONFIG_ARCH_OMAP4)
@@ -382,6 +423,14 @@ IS_OMAP_TYPE(3430, 0x3430)
 #define OMAP3430_REV_ES3_0	0x34303034
 #define OMAP3430_REV_ES3_1	0x34304034
 
+#define OMAP3630_REV_ES1_0	0x36300034
+
+#define OMAP35XX_CLASS		0x35000034
+#define OMAP3503_REV(v)		(OMAP35XX_CLASS | (0x3503 << 16) | (v << 12))
+#define OMAP3515_REV(v)		(OMAP35XX_CLASS | (0x3515 << 16) | (v << 12))
+#define OMAP3525_REV(v)		(OMAP35XX_CLASS | (0x3525 << 16) | (v << 12))
+#define OMAP3530_REV(v)		(OMAP35XX_CLASS | (0x3530 << 16) | (v << 12))
+
 #define OMAP443X_CLASS		0x44300034
 
 /*
@@ -423,4 +472,27 @@ IS_OMAP_TYPE(3430, 0x3430)
 int omap_chip_is(struct omap_chip_id oci);
 void omap2_check_revision(void);
 
+/*
+ * Runtime detection of OMAP3 features
+ */
+extern u32 omap3_features;
+
+#define OMAP3_HAS_L2CACHE		BIT(0)
+#define OMAP3_HAS_IVA			BIT(1)
+#define OMAP3_HAS_SGX			BIT(2)
+#define OMAP3_HAS_NEON			BIT(3)
+#define OMAP3_HAS_ISP			BIT(4)
+
+#define OMAP3_HAS_FEATURE(feat,flag)			\
+static inline unsigned int omap3_has_ ##feat(void)	\
+{							\
+	return (omap3_features & OMAP3_HAS_ ##flag);	\
+}							\
+
+OMAP3_HAS_FEATURE(l2cache, L2CACHE)
+OMAP3_HAS_FEATURE(sgx, SGX)
+OMAP3_HAS_FEATURE(iva, IVA)
+OMAP3_HAS_FEATURE(neon, NEON)
+OMAP3_HAS_FEATURE(isp, ISP)
+
 #endif
diff --git a/arch/arm/plat-omap/include/mach/debug-macro.S b/arch/arm/plat-omap/include/mach/debug-macro.S
index ac24050..63bb06d 100644
--- a/arch/arm/plat-omap/include/mach/debug-macro.S
+++ b/arch/arm/plat-omap/include/mach/debug-macro.S
@@ -27,7 +27,7 @@
 
 #elif  CONFIG_ARCH_OMAP2
 		moveq	\rx, #0x48000000	@ physical base address
-		movne	\rx, #0xd8000000	@ virtual base
+		movne	\rx, #0xfa000000	@ virtual base
 		orr	\rx, \rx, #0x0006a000
 #ifdef CONFIG_OMAP_LL_DEBUG_UART2
 		add	\rx, \rx, #0x00002000	@ UART 2
@@ -38,7 +38,7 @@
 
 #elif defined(CONFIG_ARCH_OMAP3) || defined(CONFIG_ARCH_OMAP4)
 		moveq	\rx, #0x48000000	@ physical base address
-		movne	\rx, #0xd8000000	@ virtual base
+		movne	\rx, #0xfa000000	@ virtual base
 		orr	\rx, \rx, #0x0006a000
 #ifdef CONFIG_OMAP_LL_DEBUG_UART2
 		add	\rx, \rx, #0x00002000	@ UART 2
diff --git a/arch/arm/plat-omap/include/mach/entry-macro.S b/arch/arm/plat-omap/include/mach/entry-macro.S
index a559299..2aea566 100644
--- a/arch/arm/plat-omap/include/mach/entry-macro.S
+++ b/arch/arm/plat-omap/include/mach/entry-macro.S
@@ -17,11 +17,11 @@
 
 #if defined(CONFIG_ARCH_OMAP1)
 
-#if defined(CONFIG_ARCH_OMAP730) && \
+#if (defined(CONFIG_ARCH_OMAP730)||defined(CONFIG_ARCH_OMAP850)) && \
 	(defined(CONFIG_ARCH_OMAP15XX) || defined(CONFIG_ARCH_OMAP16XX))
-#error "FIXME: OMAP730 doesn't support multiple-OMAP"
-#elif defined(CONFIG_ARCH_OMAP730)
-#define INT_IH2_IRQ		INT_730_IH2_IRQ
+#error "FIXME: OMAP7XX doesn't support multiple-OMAP"
+#elif defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
+#define INT_IH2_IRQ		INT_7XX_IH2_IRQ
 #elif defined(CONFIG_ARCH_OMAP15XX)
 #define INT_IH2_IRQ		INT_1510_IH2_IRQ
 #elif defined(CONFIG_ARCH_OMAP16XX)
@@ -68,9 +68,9 @@
 
 /* REVISIT: This should be set dynamically if CONFIG_MULTI_OMAP2 is selected */
 #if defined(CONFIG_ARCH_OMAP2420) || defined(CONFIG_ARCH_OMAP2430)
-#define OMAP2_VA_IC_BASE		OMAP2_IO_ADDRESS(OMAP24XX_IC_BASE)
+#define OMAP2_VA_IC_BASE		OMAP2_L4_IO_ADDRESS(OMAP24XX_IC_BASE)
 #elif defined(CONFIG_ARCH_OMAP34XX)
-#define OMAP2_VA_IC_BASE		OMAP2_IO_ADDRESS(OMAP34XX_IC_BASE)
+#define OMAP2_VA_IC_BASE		OMAP2_L4_IO_ADDRESS(OMAP34XX_IC_BASE)
 #endif
 #if defined(CONFIG_ARCH_OMAP4)
 #include <mach/omap44xx.h>
@@ -104,6 +104,8 @@
 
 		.endm
 #else
+#define OMAP44XX_VA_GIC_CPU_BASE	OMAP2_L4_IO_ADDRESS(OMAP44XX_GIC_CPU_BASE)
+
 		/*
 		 * The interrupt numbering scheme is defined in the
 		 * interrupt controller spec.  To wit:
diff --git a/arch/arm/plat-omap/include/mach/hardware.h b/arch/arm/plat-omap/include/mach/hardware.h
index 26c1fbf..99c4241 100644
--- a/arch/arm/plat-omap/include/mach/hardware.h
+++ b/arch/arm/plat-omap/include/mach/hardware.h
@@ -280,7 +280,7 @@
  * ---------------------------------------------------------------------------
  */
 
-#include "omap730.h"
+#include "omap7xx.h"
 #include "omap1510.h"
 #include "omap16xx.h"
 #include "omap24xx.h"
diff --git a/arch/arm/plat-omap/include/mach/io.h b/arch/arm/plat-omap/include/mach/io.h
index 8d32df3..7e5319f 100644
--- a/arch/arm/plat-omap/include/mach/io.h
+++ b/arch/arm/plat-omap/include/mach/io.h
@@ -63,8 +63,24 @@
 #define OMAP1_IO_OFFSET		0x01000000	/* Virtual IO = 0xfefb0000 */
 #define OMAP1_IO_ADDRESS(pa)	IOMEM((pa) - OMAP1_IO_OFFSET)
 
-#define OMAP2_IO_OFFSET		0x90000000
-#define OMAP2_IO_ADDRESS(pa)	IOMEM((pa) + OMAP2_IO_OFFSET) /* L3 and L4 */
+#define OMAP2_L3_IO_OFFSET	0x90000000
+#define OMAP2_L3_IO_ADDRESS(pa)	IOMEM((pa) + OMAP2_L3_IO_OFFSET) /* L3 */
+
+
+#define OMAP2_L4_IO_OFFSET	0xb2000000
+#define OMAP2_L4_IO_ADDRESS(pa)	IOMEM((pa) + OMAP2_L4_IO_OFFSET) /* L4 */
+
+#define OMAP4_L3_IO_OFFSET	0xb4000000
+#define OMAP4_L3_IO_ADDRESS(pa)	IOMEM((pa) + OMAP4_L3_IO_OFFSET) /* L3 */
+
+#define OMAP4_L3_PER_IO_OFFSET	0xb1100000
+#define OMAP4_L3_PER_IO_ADDRESS(pa)	IOMEM((pa) + OMAP4_L3_PER_IO_OFFSET)
+
+#define OMAP4_GPMC_IO_OFFSET		0xa9000000
+#define OMAP4_GPMC_IO_ADDRESS(pa)	IOMEM((pa) + OMAP4_GPMC_IO_OFFSET)
+
+#define OMAP2_EMU_IO_OFFSET		0xaa800000	/* Emulation */
+#define OMAP2_EMU_IO_ADDRESS(pa)	IOMEM((pa) + OMAP2_EMU_IO_OFFSET)
 
 /*
  * ----------------------------------------------------------------------------
@@ -83,24 +99,27 @@
  */
 
 /* We map both L3 and L4 on OMAP2 */
-#define L3_24XX_PHYS	L3_24XX_BASE	/* 0x68000000 */
-#define L3_24XX_VIRT	0xf8000000
+#define L3_24XX_PHYS	L3_24XX_BASE	/* 0x68000000 --> 0xf8000000*/
+#define L3_24XX_VIRT	(L3_24XX_PHYS + OMAP2_L3_IO_OFFSET)
 #define L3_24XX_SIZE	SZ_1M		/* 44kB of 128MB used, want 1MB sect */
-#define L4_24XX_PHYS	L4_24XX_BASE	/* 0x48000000 */
-#define L4_24XX_VIRT	0xd8000000
+#define L4_24XX_PHYS	L4_24XX_BASE	/* 0x48000000 --> 0xfa000000 */
+#define L4_24XX_VIRT	(L4_24XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_24XX_SIZE	SZ_1M		/* 1MB of 128MB used, want 1MB sect */
 
-#define L4_WK_243X_PHYS		L4_WK_243X_BASE		/* 0x49000000 */
-#define L4_WK_243X_VIRT		0xd9000000
+#define L4_WK_243X_PHYS		L4_WK_243X_BASE	/* 0x49000000 --> 0xfb000000 */
+#define L4_WK_243X_VIRT		(L4_WK_243X_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_WK_243X_SIZE		SZ_1M
-#define OMAP243X_GPMC_PHYS	OMAP243X_GPMC_BASE	/* 0x49000000 */
-#define OMAP243X_GPMC_VIRT	0xFE000000
+#define OMAP243X_GPMC_PHYS	OMAP243X_GPMC_BASE
+#define OMAP243X_GPMC_VIRT	(OMAP243X_GPMC_PHYS + OMAP2_L3_IO_OFFSET)
+						/* 0x6e000000 --> 0xfe000000 */
 #define OMAP243X_GPMC_SIZE	SZ_1M
 #define OMAP243X_SDRC_PHYS	OMAP243X_SDRC_BASE
-#define OMAP243X_SDRC_VIRT	0xFD000000
+						/* 0x6D000000 --> 0xfd000000 */
+#define OMAP243X_SDRC_VIRT	(OMAP243X_SDRC_PHYS + OMAP2_L3_IO_OFFSET)
 #define OMAP243X_SDRC_SIZE	SZ_1M
 #define OMAP243X_SMS_PHYS	OMAP243X_SMS_BASE
-#define OMAP243X_SMS_VIRT	0xFC000000
+						/* 0x6c000000 --> 0xfc000000 */
+#define OMAP243X_SMS_VIRT	(OMAP243X_SMS_PHYS + OMAP2_L3_IO_OFFSET)
 #define OMAP243X_SMS_SIZE	SZ_1M
 
 /* DSP */
@@ -121,12 +140,12 @@
  */
 
 /* We map both L3 and L4 on OMAP3 */
-#define L3_34XX_PHYS		L3_34XX_BASE	/* 0x68000000 */
-#define L3_34XX_VIRT		0xf8000000
+#define L3_34XX_PHYS		L3_34XX_BASE	/* 0x68000000 --> 0xf8000000 */
+#define L3_34XX_VIRT		(L3_34XX_PHYS + OMAP2_L3_IO_OFFSET)
 #define L3_34XX_SIZE		SZ_1M   /* 44kB of 128MB used, want 1MB sect */
 
-#define L4_34XX_PHYS		L4_34XX_BASE	/* 0x48000000 */
-#define L4_34XX_VIRT		0xd8000000
+#define L4_34XX_PHYS		L4_34XX_BASE	/* 0x48000000 --> 0xfa000000 */
+#define L4_34XX_VIRT		(L4_34XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_34XX_SIZE		SZ_4M   /* 1MB of 128MB used, want 1MB sect */
 
 /*
@@ -134,28 +153,33 @@
  * VPOM3430 was not working for Int controller
  */
 
-#define L4_WK_34XX_PHYS		L4_WK_34XX_BASE /* 0x48300000 */
-#define L4_WK_34XX_VIRT		0xd8300000
+#define L4_WK_34XX_PHYS		L4_WK_34XX_BASE	/* 0x48300000 --> 0xfa300000 */
+#define L4_WK_34XX_VIRT		(L4_WK_34XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_WK_34XX_SIZE		SZ_1M
 
-#define L4_PER_34XX_PHYS	L4_PER_34XX_BASE /* 0x49000000 */
-#define L4_PER_34XX_VIRT	0xd9000000
+#define L4_PER_34XX_PHYS	L4_PER_34XX_BASE
+						/* 0x49000000 --> 0xfb000000 */
+#define L4_PER_34XX_VIRT	(L4_PER_34XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_PER_34XX_SIZE	SZ_1M
 
-#define L4_EMU_34XX_PHYS	L4_EMU_34XX_BASE /* 0x54000000 */
-#define L4_EMU_34XX_VIRT	0xe4000000
-#define L4_EMU_34XX_SIZE	SZ_64M
+#define L4_EMU_34XX_PHYS	L4_EMU_34XX_BASE
+						/* 0x54000000 --> 0xfe800000 */
+#define L4_EMU_34XX_VIRT	(L4_EMU_34XX_PHYS + OMAP2_EMU_IO_OFFSET)
+#define L4_EMU_34XX_SIZE	SZ_8M
 
-#define OMAP34XX_GPMC_PHYS	OMAP34XX_GPMC_BASE /* 0x6E000000 */
-#define OMAP34XX_GPMC_VIRT	0xFE000000
+#define OMAP34XX_GPMC_PHYS	OMAP34XX_GPMC_BASE
+						/* 0x6e000000 --> 0xfe000000 */
+#define OMAP34XX_GPMC_VIRT	(OMAP34XX_GPMC_PHYS + OMAP2_L3_IO_OFFSET)
 #define OMAP34XX_GPMC_SIZE	SZ_1M
 
-#define OMAP343X_SMS_PHYS	OMAP343X_SMS_BASE /* 0x6C000000 */
-#define OMAP343X_SMS_VIRT	0xFC000000
+#define OMAP343X_SMS_PHYS	OMAP343X_SMS_BASE
+						/* 0x6c000000 --> 0xfc000000 */
+#define OMAP343X_SMS_VIRT	(OMAP343X_SMS_PHYS + OMAP2_L3_IO_OFFSET)
 #define OMAP343X_SMS_SIZE	SZ_1M
 
-#define OMAP343X_SDRC_PHYS	OMAP343X_SDRC_BASE /* 0x6D000000 */
-#define OMAP343X_SDRC_VIRT	0xFD000000
+#define OMAP343X_SDRC_PHYS	OMAP343X_SDRC_BASE
+						/* 0x6D000000 --> 0xfd000000 */
+#define OMAP343X_SDRC_VIRT	(OMAP343X_SDRC_PHYS + OMAP2_L3_IO_OFFSET)
 #define OMAP343X_SDRC_SIZE	SZ_1M
 
 /* DSP */
@@ -176,32 +200,54 @@
  */
 
 /* We map both L3 and L4 on OMAP4 */
-#define L3_44XX_PHYS		L3_44XX_BASE
-#define L3_44XX_VIRT		0xd4000000
+#define L3_44XX_PHYS		L3_44XX_BASE	/* 0x44000000 --> 0xf8000000 */
+#define L3_44XX_VIRT		(L3_44XX_PHYS + OMAP4_L3_IO_OFFSET)
 #define L3_44XX_SIZE		SZ_1M
 
-#define L4_44XX_PHYS		L4_44XX_BASE
-#define L4_44XX_VIRT		0xda000000
+#define L4_44XX_PHYS		L4_44XX_BASE	/* 0x4a000000 --> 0xfc000000 */
+#define L4_44XX_VIRT		(L4_44XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_44XX_SIZE		SZ_4M
 
 
-#define L4_WK_44XX_PHYS		L4_WK_44XX_BASE
-#define L4_WK_44XX_VIRT		0xda300000
+#define L4_WK_44XX_PHYS		L4_WK_44XX_BASE	/* 0x4a300000 --> 0xfc300000 */
+#define L4_WK_44XX_VIRT		(L4_WK_44XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_WK_44XX_SIZE		SZ_1M
 
 #define L4_PER_44XX_PHYS	L4_PER_44XX_BASE
-#define L4_PER_44XX_VIRT	0xd8000000
+						/* 0x48000000 --> 0xfa000000 */
+#define L4_PER_44XX_VIRT	(L4_PER_44XX_PHYS + OMAP2_L4_IO_OFFSET)
 #define L4_PER_44XX_SIZE	SZ_4M
 
+#define L4_ABE_44XX_PHYS	L4_ABE_44XX_BASE
+						/* 0x49000000 --> 0xfb000000 */
+#define L4_ABE_44XX_VIRT	(L4_ABE_44XX_PHYS + OMAP2_L4_IO_OFFSET)
+#define L4_ABE_44XX_SIZE	SZ_1M
+
 #define L4_EMU_44XX_PHYS	L4_EMU_44XX_BASE
-#define L4_EMU_44XX_VIRT	0xe4000000
-#define L4_EMU_44XX_SIZE	SZ_64M
+						/* 0x54000000 --> 0xfe800000 */
+#define L4_EMU_44XX_VIRT	(L4_EMU_44XX_PHYS + OMAP2_EMU_IO_OFFSET)
+#define L4_EMU_44XX_SIZE	SZ_8M
 
 #define OMAP44XX_GPMC_PHYS	OMAP44XX_GPMC_BASE
-#define OMAP44XX_GPMC_VIRT	0xe0000000
+						/* 0x50000000 --> 0xf9000000 */
+#define OMAP44XX_GPMC_VIRT	(OMAP44XX_GPMC_PHYS + OMAP4_GPMC_IO_OFFSET)
 #define OMAP44XX_GPMC_SIZE	SZ_1M
 
 
+#define OMAP44XX_EMIF1_PHYS	OMAP44XX_EMIF1_BASE
+						/* 0x4c000000 --> 0xfd100000 */
+#define OMAP44XX_EMIF1_VIRT	(OMAP44XX_EMIF1_PHYS + OMAP4_L3_PER_IO_OFFSET)
+#define OMAP44XX_EMIF1_SIZE	SZ_1M
+
+#define OMAP44XX_EMIF2_PHYS	OMAP44XX_EMIF2_BASE
+						/* 0x4d000000 --> 0xfd200000 */
+#define OMAP44XX_EMIF2_VIRT	(OMAP44XX_EMIF2_PHYS + OMAP4_L3_PER_IO_OFFSET)
+#define OMAP44XX_EMIF2_SIZE	SZ_1M
+
+#define OMAP44XX_DMM_PHYS	OMAP44XX_DMM_BASE
+						/* 0x4e000000 --> 0xfd300000 */
+#define OMAP44XX_DMM_VIRT	(OMAP44XX_DMM_PHYS + OMAP4_L3_PER_IO_OFFSET)
+#define OMAP44XX_DMM_SIZE	SZ_1M
 /*
  * ----------------------------------------------------------------------------
  * Omap specific register access
diff --git a/arch/arm/plat-omap/include/mach/irqs.h b/arch/arm/plat-omap/include/mach/irqs.h
index 28a1650..6a6d028 100644
--- a/arch/arm/plat-omap/include/mach/irqs.h
+++ b/arch/arm/plat-omap/include/mach/irqs.h
@@ -86,49 +86,26 @@
 #define INT_1610_SSR_FIFO_0	29
 
 /*
- * OMAP-730 specific IRQ numbers for interrupt handler 1
+ * OMAP-7xx specific IRQ numbers for interrupt handler 1
  */
-#define INT_730_IH2_FIQ		0
-#define INT_730_IH2_IRQ		1
-#define INT_730_USB_NON_ISO	2
-#define INT_730_USB_ISO		3
-#define INT_730_ICR		4
-#define INT_730_EAC		5
-#define INT_730_GPIO_BANK1	6
-#define INT_730_GPIO_BANK2	7
-#define INT_730_GPIO_BANK3	8
-#define INT_730_McBSP2TX	10
-#define INT_730_McBSP2RX	11
-#define INT_730_McBSP2RX_OVF	12
-#define INT_730_LCD_LINE	14
-#define INT_730_GSM_PROTECT	15
-#define INT_730_TIMER3		16
-#define INT_730_GPIO_BANK5	17
-#define INT_730_GPIO_BANK6	18
-#define INT_730_SPGIO_WR	29
-
-/*
- * OMAP-850 specific IRQ numbers for interrupt handler 1
- */
-#define INT_850_IH2_FIQ		0
-#define INT_850_IH2_IRQ		1
-#define INT_850_USB_NON_ISO	2
-#define INT_850_USB_ISO		3
-#define INT_850_ICR		4
-#define INT_850_EAC		5
-#define INT_850_GPIO_BANK1	6
-#define INT_850_GPIO_BANK2	7
-#define INT_850_GPIO_BANK3	8
-#define INT_850_McBSP2TX	10
-#define INT_850_McBSP2RX	11
-#define INT_850_McBSP2RX_OVF	12
-#define INT_850_LCD_LINE	14
-#define INT_850_GSM_PROTECT	15
-#define INT_850_TIMER3		16
-#define INT_850_GPIO_BANK5	17
-#define INT_850_GPIO_BANK6	18
-#define INT_850_SPGIO_WR	29
-
+#define INT_7XX_IH2_FIQ		0
+#define INT_7XX_IH2_IRQ		1
+#define INT_7XX_USB_NON_ISO	2
+#define INT_7XX_USB_ISO		3
+#define INT_7XX_ICR		4
+#define INT_7XX_EAC		5
+#define INT_7XX_GPIO_BANK1	6
+#define INT_7XX_GPIO_BANK2	7
+#define INT_7XX_GPIO_BANK3	8
+#define INT_7XX_McBSP2TX	10
+#define INT_7XX_McBSP2RX	11
+#define INT_7XX_McBSP2RX_OVF	12
+#define INT_7XX_LCD_LINE	14
+#define INT_7XX_GSM_PROTECT	15
+#define INT_7XX_TIMER3		16
+#define INT_7XX_GPIO_BANK5	17
+#define INT_7XX_GPIO_BANK6	18
+#define INT_7XX_SPGIO_WR	29
 
 /*
  * IRQ numbers for interrupt handler 2
@@ -206,120 +183,62 @@
 #define INT_1610_SHA1MD5	(91 + IH2_BASE)
 
 /*
- * OMAP-730 specific IRQ numbers for interrupt handler 2
- */
-#define INT_730_HW_ERRORS	(0 + IH2_BASE)
-#define INT_730_NFIQ_PWR_FAIL	(1 + IH2_BASE)
-#define INT_730_CFCD		(2 + IH2_BASE)
-#define INT_730_CFIREQ		(3 + IH2_BASE)
-#define INT_730_I2C		(4 + IH2_BASE)
-#define INT_730_PCC		(5 + IH2_BASE)
-#define INT_730_MPU_EXT_NIRQ	(6 + IH2_BASE)
-#define INT_730_SPI_100K_1	(7 + IH2_BASE)
-#define INT_730_SYREN_SPI	(8 + IH2_BASE)
-#define INT_730_VLYNQ		(9 + IH2_BASE)
-#define INT_730_GPIO_BANK4	(10 + IH2_BASE)
-#define INT_730_McBSP1TX	(11 + IH2_BASE)
-#define INT_730_McBSP1RX	(12 + IH2_BASE)
-#define INT_730_McBSP1RX_OF	(13 + IH2_BASE)
-#define INT_730_UART_MODEM_IRDA_2 (14 + IH2_BASE)
-#define INT_730_UART_MODEM_1	(15 + IH2_BASE)
-#define INT_730_MCSI		(16 + IH2_BASE)
-#define INT_730_uWireTX		(17 + IH2_BASE)
-#define INT_730_uWireRX		(18 + IH2_BASE)
-#define INT_730_SMC_CD		(19 + IH2_BASE)
-#define INT_730_SMC_IREQ	(20 + IH2_BASE)
-#define INT_730_HDQ_1WIRE	(21 + IH2_BASE)
-#define INT_730_TIMER32K	(22 + IH2_BASE)
-#define INT_730_MMC_SDIO	(23 + IH2_BASE)
-#define INT_730_UPLD		(24 + IH2_BASE)
-#define INT_730_USB_HHC_1	(27 + IH2_BASE)
-#define INT_730_USB_HHC_2	(28 + IH2_BASE)
-#define INT_730_USB_GENI	(29 + IH2_BASE)
-#define INT_730_USB_OTG		(30 + IH2_BASE)
-#define INT_730_CAMERA_IF	(31 + IH2_BASE)
-#define INT_730_RNG		(32 + IH2_BASE)
-#define INT_730_DUAL_MODE_TIMER (33 + IH2_BASE)
-#define INT_730_DBB_RF_EN	(34 + IH2_BASE)
-#define INT_730_MPUIO_KEYPAD	(35 + IH2_BASE)
-#define INT_730_SHA1_MD5	(36 + IH2_BASE)
-#define INT_730_SPI_100K_2	(37 + IH2_BASE)
-#define INT_730_RNG_IDLE	(38 + IH2_BASE)
-#define INT_730_MPUIO		(39 + IH2_BASE)
-#define INT_730_LLPC_LCD_CTRL_CAN_BE_OFF	(40 + IH2_BASE)
-#define INT_730_LLPC_OE_FALLING (41 + IH2_BASE)
-#define INT_730_LLPC_OE_RISING	(42 + IH2_BASE)
-#define INT_730_LLPC_VSYNC	(43 + IH2_BASE)
-#define INT_730_WAKE_UP_REQ	(46 + IH2_BASE)
-#define INT_730_DMA_CH6		(53 + IH2_BASE)
-#define INT_730_DMA_CH7		(54 + IH2_BASE)
-#define INT_730_DMA_CH8		(55 + IH2_BASE)
-#define INT_730_DMA_CH9		(56 + IH2_BASE)
-#define INT_730_DMA_CH10	(57 + IH2_BASE)
-#define INT_730_DMA_CH11	(58 + IH2_BASE)
-#define INT_730_DMA_CH12	(59 + IH2_BASE)
-#define INT_730_DMA_CH13	(60 + IH2_BASE)
-#define INT_730_DMA_CH14	(61 + IH2_BASE)
-#define INT_730_DMA_CH15	(62 + IH2_BASE)
-#define INT_730_NAND		(63 + IH2_BASE)
-
-/*
- * OMAP-850 specific IRQ numbers for interrupt handler 2
+ * OMAP-7xx specific IRQ numbers for interrupt handler 2
  */
-#define INT_850_HW_ERRORS	(0 + IH2_BASE)
-#define INT_850_NFIQ_PWR_FAIL	(1 + IH2_BASE)
-#define INT_850_CFCD		(2 + IH2_BASE)
-#define INT_850_CFIREQ		(3 + IH2_BASE)
-#define INT_850_I2C		(4 + IH2_BASE)
-#define INT_850_PCC		(5 + IH2_BASE)
-#define INT_850_MPU_EXT_NIRQ	(6 + IH2_BASE)
-#define INT_850_SPI_100K_1	(7 + IH2_BASE)
-#define INT_850_SYREN_SPI	(8 + IH2_BASE)
-#define INT_850_VLYNQ		(9 + IH2_BASE)
-#define INT_850_GPIO_BANK4	(10 + IH2_BASE)
-#define INT_850_McBSP1TX	(11 + IH2_BASE)
-#define INT_850_McBSP1RX	(12 + IH2_BASE)
-#define INT_850_McBSP1RX_OF	(13 + IH2_BASE)
-#define INT_850_UART_MODEM_IRDA_2 (14 + IH2_BASE)
-#define INT_850_UART_MODEM_1	(15 + IH2_BASE)
-#define INT_850_MCSI		(16 + IH2_BASE)
-#define INT_850_uWireTX		(17 + IH2_BASE)
-#define INT_850_uWireRX		(18 + IH2_BASE)
-#define INT_850_SMC_CD		(19 + IH2_BASE)
-#define INT_850_SMC_IREQ	(20 + IH2_BASE)
-#define INT_850_HDQ_1WIRE	(21 + IH2_BASE)
-#define INT_850_TIMER32K	(22 + IH2_BASE)
-#define INT_850_MMC_SDIO	(23 + IH2_BASE)
-#define INT_850_UPLD		(24 + IH2_BASE)
-#define INT_850_USB_HHC_1	(27 + IH2_BASE)
-#define INT_850_USB_HHC_2	(28 + IH2_BASE)
-#define INT_850_USB_GENI	(29 + IH2_BASE)
-#define INT_850_USB_OTG		(30 + IH2_BASE)
-#define INT_850_CAMERA_IF	(31 + IH2_BASE)
-#define INT_850_RNG		(32 + IH2_BASE)
-#define INT_850_DUAL_MODE_TIMER (33 + IH2_BASE)
-#define INT_850_DBB_RF_EN	(34 + IH2_BASE)
-#define INT_850_MPUIO_KEYPAD	(35 + IH2_BASE)
-#define INT_850_SHA1_MD5	(36 + IH2_BASE)
-#define INT_850_SPI_100K_2	(37 + IH2_BASE)
-#define INT_850_RNG_IDLE	(38 + IH2_BASE)
-#define INT_850_MPUIO		(39 + IH2_BASE)
-#define INT_850_LLPC_LCD_CTRL_CAN_BE_OFF	(40 + IH2_BASE)
-#define INT_850_LLPC_OE_FALLING (41 + IH2_BASE)
-#define INT_850_LLPC_OE_RISING	(42 + IH2_BASE)
-#define INT_850_LLPC_VSYNC	(43 + IH2_BASE)
-#define INT_850_WAKE_UP_REQ	(46 + IH2_BASE)
-#define INT_850_DMA_CH6		(53 + IH2_BASE)
-#define INT_850_DMA_CH7		(54 + IH2_BASE)
-#define INT_850_DMA_CH8		(55 + IH2_BASE)
-#define INT_850_DMA_CH9		(56 + IH2_BASE)
-#define INT_850_DMA_CH10	(57 + IH2_BASE)
-#define INT_850_DMA_CH11	(58 + IH2_BASE)
-#define INT_850_DMA_CH12	(59 + IH2_BASE)
-#define INT_850_DMA_CH13	(60 + IH2_BASE)
-#define INT_850_DMA_CH14	(61 + IH2_BASE)
-#define INT_850_DMA_CH15	(62 + IH2_BASE)
-#define INT_850_NAND		(63 + IH2_BASE)
+#define INT_7XX_HW_ERRORS	(0 + IH2_BASE)
+#define INT_7XX_NFIQ_PWR_FAIL	(1 + IH2_BASE)
+#define INT_7XX_CFCD		(2 + IH2_BASE)
+#define INT_7XX_CFIREQ		(3 + IH2_BASE)
+#define INT_7XX_I2C		(4 + IH2_BASE)
+#define INT_7XX_PCC		(5 + IH2_BASE)
+#define INT_7XX_MPU_EXT_NIRQ	(6 + IH2_BASE)
+#define INT_7XX_SPI_100K_1	(7 + IH2_BASE)
+#define INT_7XX_SYREN_SPI	(8 + IH2_BASE)
+#define INT_7XX_VLYNQ		(9 + IH2_BASE)
+#define INT_7XX_GPIO_BANK4	(10 + IH2_BASE)
+#define INT_7XX_McBSP1TX	(11 + IH2_BASE)
+#define INT_7XX_McBSP1RX	(12 + IH2_BASE)
+#define INT_7XX_McBSP1RX_OF	(13 + IH2_BASE)
+#define INT_7XX_UART_MODEM_IRDA_2 (14 + IH2_BASE)
+#define INT_7XX_UART_MODEM_1	(15 + IH2_BASE)
+#define INT_7XX_MCSI		(16 + IH2_BASE)
+#define INT_7XX_uWireTX		(17 + IH2_BASE)
+#define INT_7XX_uWireRX		(18 + IH2_BASE)
+#define INT_7XX_SMC_CD		(19 + IH2_BASE)
+#define INT_7XX_SMC_IREQ	(20 + IH2_BASE)
+#define INT_7XX_HDQ_1WIRE	(21 + IH2_BASE)
+#define INT_7XX_TIMER32K	(22 + IH2_BASE)
+#define INT_7XX_MMC_SDIO	(23 + IH2_BASE)
+#define INT_7XX_UPLD		(24 + IH2_BASE)
+#define INT_7XX_USB_HHC_1	(27 + IH2_BASE)
+#define INT_7XX_USB_HHC_2	(28 + IH2_BASE)
+#define INT_7XX_USB_GENI	(29 + IH2_BASE)
+#define INT_7XX_USB_OTG		(30 + IH2_BASE)
+#define INT_7XX_CAMERA_IF	(31 + IH2_BASE)
+#define INT_7XX_RNG		(32 + IH2_BASE)
+#define INT_7XX_DUAL_MODE_TIMER (33 + IH2_BASE)
+#define INT_7XX_DBB_RF_EN	(34 + IH2_BASE)
+#define INT_7XX_MPUIO_KEYPAD	(35 + IH2_BASE)
+#define INT_7XX_SHA1_MD5	(36 + IH2_BASE)
+#define INT_7XX_SPI_100K_2	(37 + IH2_BASE)
+#define INT_7XX_RNG_IDLE	(38 + IH2_BASE)
+#define INT_7XX_MPUIO		(39 + IH2_BASE)
+#define INT_7XX_LLPC_LCD_CTRL_CAN_BE_OFF	(40 + IH2_BASE)
+#define INT_7XX_LLPC_OE_FALLING (41 + IH2_BASE)
+#define INT_7XX_LLPC_OE_RISING	(42 + IH2_BASE)
+#define INT_7XX_LLPC_VSYNC	(43 + IH2_BASE)
+#define INT_7XX_WAKE_UP_REQ	(46 + IH2_BASE)
+#define INT_7XX_DMA_CH6		(53 + IH2_BASE)
+#define INT_7XX_DMA_CH7		(54 + IH2_BASE)
+#define INT_7XX_DMA_CH8		(55 + IH2_BASE)
+#define INT_7XX_DMA_CH9		(56 + IH2_BASE)
+#define INT_7XX_DMA_CH10	(57 + IH2_BASE)
+#define INT_7XX_DMA_CH11	(58 + IH2_BASE)
+#define INT_7XX_DMA_CH12	(59 + IH2_BASE)
+#define INT_7XX_DMA_CH13	(60 + IH2_BASE)
+#define INT_7XX_DMA_CH14	(61 + IH2_BASE)
+#define INT_7XX_DMA_CH15	(62 + IH2_BASE)
+#define INT_7XX_NAND		(63 + IH2_BASE)
 
 #define INT_24XX_SYS_NIRQ	7
 #define INT_24XX_SDMA_IRQ0	12
diff --git a/arch/arm/plat-omap/include/mach/mcbsp.h b/arch/arm/plat-omap/include/mach/mcbsp.h
index e0d6eca..7e9cae3 100644
--- a/arch/arm/plat-omap/include/mach/mcbsp.h
+++ b/arch/arm/plat-omap/include/mach/mcbsp.h
@@ -30,8 +30,8 @@
 #include <mach/hardware.h>
 #include <mach/clock.h>
 
-#define OMAP730_MCBSP1_BASE	0xfffb1000
-#define OMAP730_MCBSP2_BASE	0xfffb1800
+#define OMAP7XX_MCBSP1_BASE	0xfffb1000
+#define OMAP7XX_MCBSP2_BASE	0xfffb1800
 
 #define OMAP1510_MCBSP1_BASE	0xe1011800
 #define OMAP1510_MCBSP2_BASE	0xfffb1000
@@ -58,7 +58,7 @@
 #define OMAP44XX_MCBSP3_BASE	0x49026000
 #define OMAP44XX_MCBSP4_BASE	0x48074000
 
-#if defined(CONFIG_ARCH_OMAP15XX) || defined(CONFIG_ARCH_OMAP16XX) || defined(CONFIG_ARCH_OMAP730)
+#if defined(CONFIG_ARCH_OMAP15XX) || defined(CONFIG_ARCH_OMAP16XX) || defined(CONFIG_ARCH_OMAP730) || defined(CONFIG_ARCH_OMAP850)
 
 #define OMAP_MCBSP_REG_DRR2	0x00
 #define OMAP_MCBSP_REG_DRR1	0x02
diff --git a/arch/arm/plat-omap/include/mach/mux.h b/arch/arm/plat-omap/include/mach/mux.h
index 0f49d2d..f3c1d8a 100644
--- a/arch/arm/plat-omap/include/mach/mux.h
+++ b/arch/arm/plat-omap/include/mach/mux.h
@@ -51,23 +51,13 @@
 					.pu_pd_reg = PU_PD_SEL_##reg, \
 					.pu_pd_val = status,
 
-#define MUX_REG_730(reg, mode_offset, mode) .mux_reg_name = "OMAP730_IO_CONF_"#reg, \
-					.mux_reg = OMAP730_IO_CONF_##reg, \
+#define MUX_REG_7XX(reg, mode_offset, mode) .mux_reg_name = "OMAP7XX_IO_CONF_"#reg, \
+					.mux_reg = OMAP7XX_IO_CONF_##reg, \
 					.mask_offset = mode_offset, \
 					.mask = mode,
 
-#define PULL_REG_730(reg, bit, status)	.pull_name = "OMAP730_IO_CONF_"#reg, \
-					.pull_reg = OMAP730_IO_CONF_##reg, \
-					.pull_bit = bit, \
-					.pull_val = status,
-
-#define MUX_REG_850(reg, mode_offset, mode) .mux_reg_name = "OMAP850_IO_CONF_"#reg, \
-					.mux_reg = OMAP850_IO_CONF_##reg, \
-					.mask_offset = mode_offset, \
-					.mask = mode,
-
-#define PULL_REG_850(reg, bit, status)	.pull_name = "OMAP850_IO_CONF_"#reg, \
-					.pull_reg = OMAP850_IO_CONF_##reg, \
+#define PULL_REG_7XX(reg, bit, status)	.pull_name = "OMAP7XX_IO_CONF_"#reg, \
+					.pull_reg = OMAP7XX_IO_CONF_##reg, \
 					.pull_bit = bit, \
 					.pull_val = status,
 
@@ -84,21 +74,12 @@
 #define PU_PD_REG(reg, status)		.pu_pd_reg = PU_PD_SEL_##reg, \
 					.pu_pd_val = status,
 
-#define MUX_REG_730(reg, mode_offset, mode) \
-					.mux_reg = OMAP730_IO_CONF_##reg, \
+#define MUX_REG_7XX(reg, mode_offset, mode) \
+					.mux_reg = OMAP7XX_IO_CONF_##reg, \
 					.mask_offset = mode_offset, \
 					.mask = mode,
 
-#define PULL_REG_730(reg, bit, status)	.pull_reg = OMAP730_IO_CONF_##reg, \
-					.pull_bit = bit, \
-					.pull_val = status,
-
-#define MUX_REG_850(reg, mode_offset, mode) \
-					.mux_reg = OMAP850_IO_CONF_##reg, \
-					.mask_offset = mode_offset, \
-					.mask = mode,
-
-#define PULL_REG_850(reg, bit, status)	.pull_reg = OMAP850_IO_CONF_##reg, \
+#define PULL_REG_7XX(reg, bit, status)	.pull_reg = OMAP7XX_IO_CONF_##reg, \
 					.pull_bit = bit, \
 					.pull_val = status,
 
@@ -118,32 +99,21 @@
 
 /*
  * OMAP730/850 has a slightly different config for the pin mux.
- * - config regs are the OMAP730_IO_CONF_x regs (see omap730.h) regs and
+ * - config regs are the OMAP7XX_IO_CONF_x regs (see omap730.h) regs and
  *   not the FUNC_MUX_CTRL_x regs from hardware.h
  * - for pull-up/down, only has one enable bit which is is in the same register
  *   as mux config
  */
-#define MUX_CFG_730(desc, mux_reg, mode_offset, mode,	\
+#define MUX_CFG_7XX(desc, mux_reg, mode_offset, mode,	\
 		   pull_bit, pull_status, debug_status)\
 {							\
 	.name =	 desc,					\
 	.debug = debug_status,				\
-	MUX_REG_730(mux_reg, mode_offset, mode)		\
-	PULL_REG_730(mux_reg, pull_bit, pull_status)	\
+	MUX_REG_7XX(mux_reg, mode_offset, mode)		\
+	PULL_REG_7XX(mux_reg, pull_bit, pull_status)	\
 	PU_PD_REG(NA, 0)		\
 },
 
-#define MUX_CFG_850(desc, mux_reg, mode_offset, mode,	\
-		   pull_bit, pull_status, debug_status)\
-{							\
-	.name =	 desc,					\
-	.debug = debug_status,				\
-	MUX_REG_850(mux_reg, mode_offset, mode)		\
-	PULL_REG_850(mux_reg, pull_bit, pull_status)	\
-	PU_PD_REG(NA, 0)		\
-},
-
-
 #define MUX_CFG_24XX(desc, reg_offset, mode,			\
 				pull_en, pull_mode, dbg)	\
 {								\
@@ -232,45 +202,25 @@ struct pin_config {
 
 };
 
-enum omap730_index {
+enum omap7xx_index {
 	/* OMAP 730 keyboard */
-	E2_730_KBR0,
-	J7_730_KBR1,
-	E1_730_KBR2,
-	F3_730_KBR3,
-	D2_730_KBR4,
-	C2_730_KBC0,
-	D3_730_KBC1,
-	E4_730_KBC2,
-	F4_730_KBC3,
-	E3_730_KBC4,
-
-	/* USB */
-	AA17_730_USB_DM,
-	W16_730_USB_PU_EN,
-	W17_730_USB_VBUSI,
-};
-
-enum omap850_index {
-	/* OMAP 850 keyboard */
-	E2_850_KBR0,
-	J7_850_KBR1,
-	E1_850_KBR2,
-	F3_850_KBR3,
-	D2_850_KBR4,
-	C2_850_KBC0,
-	D3_850_KBC1,
-	E4_850_KBC2,
-	F4_850_KBC3,
-	E3_850_KBC4,
+	E2_7XX_KBR0,
+	J7_7XX_KBR1,
+	E1_7XX_KBR2,
+	F3_7XX_KBR3,
+	D2_7XX_KBR4,
+	C2_7XX_KBC0,
+	D3_7XX_KBC1,
+	E4_7XX_KBC2,
+	F4_7XX_KBC3,
+	E3_7XX_KBC4,
 
 	/* USB */
-	AA17_850_USB_DM,
-	W16_850_USB_PU_EN,
-	W17_850_USB_VBUSI,
+	AA17_7XX_USB_DM,
+	W16_7XX_USB_PU_EN,
+	W17_7XX_USB_VBUSI,
 };
 
-
 enum omap1xxx_index {
 	/* UART1 (BT_UART_GATING)*/
 	UART1_TX = 0,
diff --git a/arch/arm/plat-omap/include/mach/omap34xx.h b/arch/arm/plat-omap/include/mach/omap34xx.h
index f8d186a..4655707 100644
--- a/arch/arm/plat-omap/include/mach/omap34xx.h
+++ b/arch/arm/plat-omap/include/mach/omap34xx.h
@@ -74,8 +74,12 @@
 
 #define OMAP34XX_IVA_INTC_BASE	0x40000000
 #define OMAP34XX_HSUSB_OTG_BASE	(L4_34XX_BASE + 0xAB000)
-#define OMAP34XX_HSUSB_HOST_BASE	(L4_34XX_BASE + 0x64000)
 #define OMAP34XX_USBTLL_BASE	(L4_34XX_BASE + 0x62000)
+#define OMAP34XX_UHH_CONFIG_BASE	(L4_34XX_BASE + 0x64000)
+#define OMAP34XX_OHCI_BASE	(L4_34XX_BASE + 0x64400)
+#define OMAP34XX_EHCI_BASE	(L4_34XX_BASE + 0x64800)
+#define OMAP34XX_SR1_BASE	0x480C9000
+#define OMAP34XX_SR2_BASE	0x480CB000
 
 #define OMAP34XX_MAILBOX_BASE		(L4_34XX_BASE + 0x94000)
 
diff --git a/arch/arm/plat-omap/include/mach/omap44xx.h b/arch/arm/plat-omap/include/mach/omap44xx.h
index b3ba5ac..3361897 100644
--- a/arch/arm/plat-omap/include/mach/omap44xx.h
+++ b/arch/arm/plat-omap/include/mach/omap44xx.h
@@ -22,6 +22,9 @@
 #define L4_PER_44XX_BASE		0x48000000
 #define L4_EMU_44XX_BASE		0x54000000
 #define L3_44XX_BASE			0x44000000
+#define OMAP44XX_EMIF1_BASE		0x4c000000
+#define OMAP44XX_EMIF2_BASE		0x4d000000
+#define OMAP44XX_DMM_BASE		0x4e000000
 #define OMAP4430_32KSYNCT_BASE		0x4a304000
 #define OMAP4430_CM_BASE		0x4a004000
 #define OMAP4430_PRM_BASE		0x48306000
@@ -33,14 +36,9 @@
 #define IRQ_SIR_IRQ			0x0040
 #define OMAP44XX_GIC_DIST_BASE		0x48241000
 #define OMAP44XX_GIC_CPU_BASE		0x48240100
-#define OMAP44XX_VA_GIC_CPU_BASE	OMAP2_IO_ADDRESS(OMAP44XX_GIC_CPU_BASE)
 #define OMAP44XX_SCU_BASE		0x48240000
-#define OMAP44XX_VA_SCU_BASE		OMAP2_IO_ADDRESS(OMAP44XX_SCU_BASE)
 #define OMAP44XX_LOCAL_TWD_BASE		0x48240600
-#define OMAP44XX_VA_LOCAL_TWD_BASE	OMAP2_IO_ADDRESS(OMAP44XX_LOCAL_TWD_BASE)
-#define OMAP44XX_LOCAL_TWD_SIZE		0x00000100
 #define OMAP44XX_WKUPGEN_BASE		0x48281000
-#define OMAP44XX_VA_WKUPGEN_BASE	OMAP2_IO_ADDRESS(OMAP44XX_WKUPGEN_BASE)
 
 #endif /* __ASM_ARCH_OMAP44XX_H */
 
diff --git a/arch/arm/plat-omap/include/mach/omap7xx.h b/arch/arm/plat-omap/include/mach/omap7xx.h
new file mode 100644
index 0000000..53f5241
--- /dev/null
+++ b/arch/arm/plat-omap/include/mach/omap7xx.h
@@ -0,0 +1,104 @@
+/* arch/arm/plat-omap/include/mach/omap7xx.h
+ *
+ * Hardware definitions for TI OMAP7XX processor.
+ *
+ * Cleanup for Linux-2.6 by Dirk Behme <dirk.behme@de.bosch.com>
+ * Adapted for omap850 by Zebediah C. McClure <zmc@lurian.net>
+ * Adapted for omap7xx by Alistair Buxton <a.j.buxton@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __ASM_ARCH_OMAP7XX_H
+#define __ASM_ARCH_OMAP7XX_H
+
+/*
+ * ----------------------------------------------------------------------------
+ * Base addresses
+ * ----------------------------------------------------------------------------
+ */
+
+/* Syntax: XX_BASE = Virtual base address, XX_START = Physical base address */
+
+#define OMAP7XX_DSP_BASE	0xE0000000
+#define OMAP7XX_DSP_SIZE	0x50000
+#define OMAP7XX_DSP_START	0xE0000000
+
+#define OMAP7XX_DSPREG_BASE	0xE1000000
+#define OMAP7XX_DSPREG_SIZE	SZ_128K
+#define OMAP7XX_DSPREG_START	0xE1000000
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP7XX specific configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP7XX_CONFIG_BASE	0xfffe1000
+#define OMAP7XX_IO_CONF_0	0xfffe1070
+#define OMAP7XX_IO_CONF_1	0xfffe1074
+#define OMAP7XX_IO_CONF_2	0xfffe1078
+#define OMAP7XX_IO_CONF_3	0xfffe107c
+#define OMAP7XX_IO_CONF_4	0xfffe1080
+#define OMAP7XX_IO_CONF_5	0xfffe1084
+#define OMAP7XX_IO_CONF_6	0xfffe1088
+#define OMAP7XX_IO_CONF_7	0xfffe108c
+#define OMAP7XX_IO_CONF_8	0xfffe1090
+#define OMAP7XX_IO_CONF_9	0xfffe1094
+#define OMAP7XX_IO_CONF_10	0xfffe1098
+#define OMAP7XX_IO_CONF_11	0xfffe109c
+#define OMAP7XX_IO_CONF_12	0xfffe10a0
+#define OMAP7XX_IO_CONF_13	0xfffe10a4
+
+#define OMAP7XX_MODE_1		0xfffe1010
+#define OMAP7XX_MODE_2		0xfffe1014
+
+/* CSMI specials: in terms of base + offset */
+#define OMAP7XX_MODE2_OFFSET	0x14
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP7XX traffic controller configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP7XX_FLASH_CFG_0	0xfffecc10
+#define OMAP7XX_FLASH_ACFG_0	0xfffecc50
+#define OMAP7XX_FLASH_CFG_1	0xfffecc14
+#define OMAP7XX_FLASH_ACFG_1	0xfffecc54
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP7XX DSP control registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP7XX_ICR_BASE	0xfffbb800
+#define OMAP7XX_DSP_M_CTL	0xfffbb804
+#define OMAP7XX_DSP_MMU_BASE	0xfffed200
+
+/*
+ * ----------------------------------------------------------------------------
+ * OMAP7XX PCC_UPLD configuration registers
+ * ----------------------------------------------------------------------------
+ */
+#define OMAP7XX_PCC_UPLD_CTRL_BASE	(0xfffe0900)
+#define OMAP7XX_PCC_UPLD_CTRL		(OMAP7XX_PCC_UPLD_CTRL_BASE + 0x00)
+
+#endif /*  __ASM_ARCH_OMAP7XX_H */
+
diff --git a/arch/arm/plat-omap/include/mach/sdrc.h b/arch/arm/plat-omap/include/mach/sdrc.h
index 1c09c78..7b58a5f 100644
--- a/arch/arm/plat-omap/include/mach/sdrc.h
+++ b/arch/arm/plat-omap/include/mach/sdrc.h
@@ -80,11 +80,11 @@
  */
 
 #define OMAP242X_SMS_REGADDR(reg)					\
-			(void __iomem *)OMAP2_IO_ADDRESS(OMAP2420_SMS_BASE + reg)
+		(void __iomem *)OMAP2_L3_IO_ADDRESS(OMAP2420_SMS_BASE + reg)
 #define OMAP243X_SMS_REGADDR(reg)					\
-			(void __iomem *)OMAP2_IO_ADDRESS(OMAP243X_SMS_BASE + reg)
+		(void __iomem *)OMAP2_L3_IO_ADDRESS(OMAP243X_SMS_BASE + reg)
 #define OMAP343X_SMS_REGADDR(reg)					\
-			(void __iomem *)OMAP2_IO_ADDRESS(OMAP343X_SMS_BASE + reg)
+		(void __iomem *)OMAP2_L3_IO_ADDRESS(OMAP343X_SMS_BASE + reg)
 
 /* SMS register offsets - read/write with sms_{read,write}_reg() */
 
diff --git a/arch/arm/plat-omap/include/mach/serial.h b/arch/arm/plat-omap/include/mach/serial.h
index e249186..9951345 100644
--- a/arch/arm/plat-omap/include/mach/serial.h
+++ b/arch/arm/plat-omap/include/mach/serial.h
@@ -20,26 +20,22 @@
 #define OMAP_UART1_BASE		0xfffb0000
 #define OMAP_UART2_BASE		0xfffb0800
 #define OMAP_UART3_BASE		0xfffb9800
-#define OMAP_MAX_NR_PORTS	3
 #elif defined(CONFIG_ARCH_OMAP2)
 /* OMAP2 serial ports */
 #define OMAP_UART1_BASE		0x4806a000
 #define OMAP_UART2_BASE		0x4806c000
 #define OMAP_UART3_BASE		0x4806e000
-#define OMAP_MAX_NR_PORTS	3
 #elif defined(CONFIG_ARCH_OMAP3)
 /* OMAP3 serial ports */
 #define OMAP_UART1_BASE		0x4806a000
 #define OMAP_UART2_BASE		0x4806c000
 #define OMAP_UART3_BASE		0x49020000
-#define OMAP_MAX_NR_PORTS	3
 #elif defined(CONFIG_ARCH_OMAP4)
 /* OMAP4 serial ports */
 #define OMAP_UART1_BASE		0x4806a000
 #define OMAP_UART2_BASE		0x4806c000
 #define OMAP_UART3_BASE		0x48020000
 #define OMAP_UART4_BASE		0x4806e000
-#define OMAP_MAX_NR_PORTS	4
 #endif
 
 #define OMAP1510_BASE_BAUD	(12000000/16)
diff --git a/arch/arm/plat-omap/include/mach/uncompress.h b/arch/arm/plat-omap/include/mach/uncompress.h
index 0814c5f..ddf7b88 100644
--- a/arch/arm/plat-omap/include/mach/uncompress.h
+++ b/arch/arm/plat-omap/include/mach/uncompress.h
@@ -25,6 +25,7 @@ unsigned int system_rev;
 
 #define UART_OMAP_MDR1		0x08	/* mode definition register */
 #define OMAP_ID_730		0x355F
+#define OMAP_ID_850		0x362C
 #define ID_MASK			0x7fff
 #define check_port(base, shift) ((base[UART_OMAP_MDR1 << shift] & 7) == 0)
 #define omap_get_id() ((*(volatile unsigned int *)(0xfffed404)) >> 12) & ID_MASK
@@ -53,7 +54,7 @@ static void putc(int c)
 		/* MMU is not on, so cpu_is_omapXXXX() won't work here */
 		unsigned int omap_id = omap_get_id();
 
-		if (omap_id == OMAP_ID_730)
+		if (omap_id == OMAP_ID_730 || omap_id == OMAP_ID_850)
 			shift = 0;
 
 		if (check_port(uart, shift))
diff --git a/arch/arm/plat-omap/include/mach/usb.h b/arch/arm/plat-omap/include/mach/usb.h
index f337e17..a4068a4 100644
--- a/arch/arm/plat-omap/include/mach/usb.h
+++ b/arch/arm/plat-omap/include/mach/usb.h
@@ -5,6 +5,21 @@
 
 #include <mach/board.h>
 
+#define OMAP3_HS_USB_PORTS	3
+enum ehci_hcd_omap_mode {
+	EHCI_HCD_OMAP_MODE_UNKNOWN,
+	EHCI_HCD_OMAP_MODE_PHY,
+	EHCI_HCD_OMAP_MODE_TLL,
+};
+
+struct ehci_hcd_omap_platform_data {
+	enum ehci_hcd_omap_mode		port_mode[OMAP3_HS_USB_PORTS];
+	unsigned			phy_reset:1;
+
+	/* have to be valid if phy_reset is true and portx is in phy mode */
+	int	reset_gpio_port[OMAP3_HS_USB_PORTS];
+};
+
 /*-------------------------------------------------------------------------*/
 
 #define OMAP1_OTG_BASE			0xfffb0400
@@ -29,6 +44,8 @@
 
 extern void usb_musb_init(void);
 
+extern void usb_ehci_init(struct ehci_hcd_omap_platform_data *pdata);
+
 #endif
 
 void omap_usb_init(struct omap_usb_config *pdata);
diff --git a/arch/arm/plat-omap/include/mach/vmalloc.h b/arch/arm/plat-omap/include/mach/vmalloc.h
index b97dfaf..9eebf62 100644
--- a/arch/arm/plat-omap/include/mach/vmalloc.h
+++ b/arch/arm/plat-omap/include/mach/vmalloc.h
@@ -17,5 +17,5 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  */
-#define VMALLOC_END	  (PAGE_OFFSET + 0x18000000)
+#define VMALLOC_END	  (PAGE_OFFSET + 0x38000000)
 
diff --git a/arch/arm/plat-omap/io.c b/arch/arm/plat-omap/io.c
index b6defa2..93c1d53 100644
--- a/arch/arm/plat-omap/io.c
+++ b/arch/arm/plat-omap/io.c
@@ -13,7 +13,7 @@
 #include <linux/io.h>
 #include <linux/mm.h>
 
-#include <mach/omap730.h>
+#include <mach/omap7xx.h>
 #include <mach/omap1510.h>
 #include <mach/omap16xx.h>
 #include <mach/omap24xx.h>
@@ -33,13 +33,13 @@ void __iomem *omap_ioremap(unsigned long p, size_t size, unsigned int type)
 		if (BETWEEN(p, OMAP1_IO_PHYS, OMAP1_IO_SIZE))
 			return XLATE(p, OMAP1_IO_PHYS, OMAP1_IO_VIRT);
 	}
-	if (cpu_is_omap730()) {
-		if (BETWEEN(p, OMAP730_DSP_BASE, OMAP730_DSP_SIZE))
-			return XLATE(p, OMAP730_DSP_BASE, OMAP730_DSP_START);
+	if (cpu_is_omap7xx()) {
+		if (BETWEEN(p, OMAP7XX_DSP_BASE, OMAP7XX_DSP_SIZE))
+			return XLATE(p, OMAP7XX_DSP_BASE, OMAP7XX_DSP_START);
 
-		if (BETWEEN(p, OMAP730_DSPREG_BASE, OMAP730_DSPREG_SIZE))
-			return XLATE(p, OMAP730_DSPREG_BASE,
-					OMAP730_DSPREG_START);
+		if (BETWEEN(p, OMAP7XX_DSPREG_BASE, OMAP7XX_DSPREG_SIZE))
+			return XLATE(p, OMAP7XX_DSPREG_BASE,
+					OMAP7XX_DSPREG_START);
 	}
 	if (cpu_is_omap15xx()) {
 		if (BETWEEN(p, OMAP1510_DSP_BASE, OMAP1510_DSP_SIZE))
@@ -114,6 +114,14 @@ void __iomem *omap_ioremap(unsigned long p, size_t size, unsigned int type)
 			return XLATE(p, L4_WK_44XX_PHYS, L4_WK_44XX_VIRT);
 		if (BETWEEN(p, OMAP44XX_GPMC_PHYS, OMAP44XX_GPMC_SIZE))
 			return XLATE(p, OMAP44XX_GPMC_PHYS, OMAP44XX_GPMC_VIRT);
+		if (BETWEEN(p, OMAP44XX_EMIF1_PHYS, OMAP44XX_EMIF1_SIZE))
+			return XLATE(p, OMAP44XX_EMIF1_PHYS,		\
+							OMAP44XX_EMIF1_VIRT);
+		if (BETWEEN(p, OMAP44XX_EMIF2_PHYS, OMAP44XX_EMIF2_SIZE))
+			return XLATE(p, OMAP44XX_EMIF2_PHYS,		\
+							OMAP44XX_EMIF2_VIRT);
+		if (BETWEEN(p, OMAP44XX_DMM_PHYS, OMAP44XX_DMM_SIZE))
+			return XLATE(p, OMAP44XX_DMM_PHYS, OMAP44XX_DMM_VIRT);
 		if (BETWEEN(p, L4_PER_44XX_PHYS, L4_PER_44XX_SIZE))
 			return XLATE(p, L4_PER_44XX_PHYS, L4_PER_44XX_VIRT);
 		if (BETWEEN(p, L4_EMU_44XX_PHYS, L4_EMU_44XX_SIZE))
@@ -142,7 +150,7 @@ u8 omap_readb(u32 pa)
 	if (cpu_class_is_omap1())
 		return __raw_readb(OMAP1_IO_ADDRESS(pa));
 	else
-		return __raw_readb(OMAP2_IO_ADDRESS(pa));
+		return __raw_readb(OMAP2_L4_IO_ADDRESS(pa));
 }
 EXPORT_SYMBOL(omap_readb);
 
@@ -151,7 +159,7 @@ u16 omap_readw(u32 pa)
 	if (cpu_class_is_omap1())
 		return __raw_readw(OMAP1_IO_ADDRESS(pa));
 	else
-		return __raw_readw(OMAP2_IO_ADDRESS(pa));
+		return __raw_readw(OMAP2_L4_IO_ADDRESS(pa));
 }
 EXPORT_SYMBOL(omap_readw);
 
@@ -160,7 +168,7 @@ u32 omap_readl(u32 pa)
 	if (cpu_class_is_omap1())
 		return __raw_readl(OMAP1_IO_ADDRESS(pa));
 	else
-		return __raw_readl(OMAP2_IO_ADDRESS(pa));
+		return __raw_readl(OMAP2_L4_IO_ADDRESS(pa));
 }
 EXPORT_SYMBOL(omap_readl);
 
@@ -169,7 +177,7 @@ void omap_writeb(u8 v, u32 pa)
 	if (cpu_class_is_omap1())
 		__raw_writeb(v, OMAP1_IO_ADDRESS(pa));
 	else
-		__raw_writeb(v, OMAP2_IO_ADDRESS(pa));
+		__raw_writeb(v, OMAP2_L4_IO_ADDRESS(pa));
 }
 EXPORT_SYMBOL(omap_writeb);
 
@@ -178,7 +186,7 @@ void omap_writew(u16 v, u32 pa)
 	if (cpu_class_is_omap1())
 		__raw_writew(v, OMAP1_IO_ADDRESS(pa));
 	else
-		__raw_writew(v, OMAP2_IO_ADDRESS(pa));
+		__raw_writew(v, OMAP2_L4_IO_ADDRESS(pa));
 }
 EXPORT_SYMBOL(omap_writew);
 
@@ -187,6 +195,6 @@ void omap_writel(u32 v, u32 pa)
 	if (cpu_class_is_omap1())
 		__raw_writel(v, OMAP1_IO_ADDRESS(pa));
 	else
-		__raw_writel(v, OMAP2_IO_ADDRESS(pa));
+		__raw_writel(v, OMAP2_L4_IO_ADDRESS(pa));
 }
 EXPORT_SYMBOL(omap_writel);
diff --git a/arch/arm/plat-omap/omap_device.c b/arch/arm/plat-omap/omap_device.c
index 2c409fc..12513f4 100644
--- a/arch/arm/plat-omap/omap_device.c
+++ b/arch/arm/plat-omap/omap_device.c
@@ -103,21 +103,6 @@
 /* Private functions */
 
 /**
- * _read_32ksynct - read the OMAP 32K sync timer
- *
- * Returns the current value of the 32KiHz synchronization counter.
- * XXX this should be generalized to simply read the system clocksource.
- * XXX this should be moved to a separate synctimer32k.c file
- */
-static u32 _read_32ksynct(void)
-{
-	if (!cpu_class_is_omap2())
-		BUG();
-
-	return __raw_readl(OMAP2_IO_ADDRESS(OMAP_32KSYNCT_BASE + 0x010));
-}
-
-/**
  * _omap_device_activate - increase device readiness
  * @od: struct omap_device *
  * @ignore_lat: increase to latency target (0) or full readiness (1)?
@@ -133,13 +118,13 @@ static u32 _read_32ksynct(void)
  */
 static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)
 {
-	u32 a, b;
+	struct timespec a, b, c;
 
 	pr_debug("omap_device: %s: activating\n", od->pdev.name);
 
 	while (od->pm_lat_level > 0) {
 		struct omap_device_pm_latency *odpl;
-		int act_lat = 0;
+		unsigned long long act_lat = 0;
 
 		od->pm_lat_level--;
 
@@ -149,20 +134,22 @@ static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)
 		    (od->dev_wakeup_lat <= od->_dev_wakeup_lat_limit))
 			break;
 
-		a = _read_32ksynct();
+		getnstimeofday(&a);
 
 		/* XXX check return code */
 		odpl->activate_func(od);
 
-		b = _read_32ksynct();
+		getnstimeofday(&b);
 
-		act_lat = (b - a) >> 15; /* 32KiHz cycles to microseconds */
+		c = timespec_sub(b, a);
+		act_lat = timespec_to_ns(&c) * NSEC_PER_USEC;
 
 		pr_debug("omap_device: %s: pm_lat %d: activate: elapsed time "
-			 "%d usec\n", od->pdev.name, od->pm_lat_level, act_lat);
+			 "%llu usec\n", od->pdev.name, od->pm_lat_level,
+			 act_lat);
 
 		WARN(act_lat > odpl->activate_lat, "omap_device: %s.%d: "
-		     "activate step %d took longer than expected (%d > %d)\n",
+		     "activate step %d took longer than expected (%llu > %d)\n",
 		     od->pdev.name, od->pdev.id, od->pm_lat_level,
 		     act_lat, odpl->activate_lat);
 
@@ -188,13 +175,13 @@ static int _omap_device_activate(struct omap_device *od, u8 ignore_lat)
  */
 static int _omap_device_deactivate(struct omap_device *od, u8 ignore_lat)
 {
-	u32 a, b;
+	struct timespec a, b, c;
 
 	pr_debug("omap_device: %s: deactivating\n", od->pdev.name);
 
 	while (od->pm_lat_level < od->pm_lats_cnt) {
 		struct omap_device_pm_latency *odpl;
-		int deact_lat = 0;
+		unsigned long long deact_lat = 0;
 
 		odpl = od->pm_lats + od->pm_lat_level;
 
@@ -203,23 +190,24 @@ static int _omap_device_deactivate(struct omap_device *od, u8 ignore_lat)
 		     od->_dev_wakeup_lat_limit))
 			break;
 
-		a = _read_32ksynct();
+		getnstimeofday(&a);
 
 		/* XXX check return code */
 		odpl->deactivate_func(od);
 
-		b = _read_32ksynct();
+		getnstimeofday(&b);
 
-		deact_lat = (b - a) >> 15; /* 32KiHz cycles to microseconds */
+		c = timespec_sub(b, a);
+		deact_lat = timespec_to_ns(&c) * NSEC_PER_USEC;
 
 		pr_debug("omap_device: %s: pm_lat %d: deactivate: elapsed time "
-			 "%d usec\n", od->pdev.name, od->pm_lat_level,
+			 "%llu usec\n", od->pdev.name, od->pm_lat_level,
 			 deact_lat);
 
 		WARN(deact_lat > odpl->deactivate_lat, "omap_device: %s.%d: "
-		     "deactivate step %d took longer than expected (%d > %d)\n",
-		     od->pdev.name, od->pdev.id, od->pm_lat_level,
-		     deact_lat, odpl->deactivate_lat);
+		     "deactivate step %d took longer than expected "
+		     "(%llu > %d)\n", od->pdev.name, od->pdev.id,
+		     od->pm_lat_level, deact_lat, odpl->deactivate_lat);
 
 		od->dev_wakeup_lat += odpl->activate_lat;
 
diff --git a/arch/arm/plat-omap/sram.c b/arch/arm/plat-omap/sram.c
index 75d1f26..4144f81 100644
--- a/arch/arm/plat-omap/sram.c
+++ b/arch/arm/plat-omap/sram.c
@@ -41,14 +41,14 @@
 #define OMAP1_SRAM_VA		VMALLOC_END
 #define OMAP2_SRAM_PA		0x40200000
 #define OMAP2_SRAM_PUB_PA	0x4020f800
-#define OMAP2_SRAM_VA		0xe3000000
+#define OMAP2_SRAM_VA		0xfe400000
 #define OMAP2_SRAM_PUB_VA	(OMAP2_SRAM_VA + 0x800)
 #define OMAP3_SRAM_PA           0x40200000
-#define OMAP3_SRAM_VA           0xe3000000
+#define OMAP3_SRAM_VA           0xfe400000
 #define OMAP3_SRAM_PUB_PA       0x40208000
 #define OMAP3_SRAM_PUB_VA       (OMAP3_SRAM_VA + 0x8000)
 #define OMAP4_SRAM_PA		0x40200000		/*0x402f0000*/
-#define OMAP4_SRAM_VA		0xd7000000		/*0xd70f0000*/
+#define OMAP4_SRAM_VA		0xfe400000		/*0xfe4f0000*/
 
 #if defined(CONFIG_ARCH_OMAP24XX) || defined(CONFIG_ARCH_OMAP34XX)
 #define SRAM_BOOTLOADER_SZ	0x00
@@ -56,16 +56,16 @@
 #define SRAM_BOOTLOADER_SZ	0x80
 #endif
 
-#define OMAP24XX_VA_REQINFOPERM0	OMAP2_IO_ADDRESS(0x68005048)
-#define OMAP24XX_VA_READPERM0		OMAP2_IO_ADDRESS(0x68005050)
-#define OMAP24XX_VA_WRITEPERM0		OMAP2_IO_ADDRESS(0x68005058)
+#define OMAP24XX_VA_REQINFOPERM0	OMAP2_L3_IO_ADDRESS(0x68005048)
+#define OMAP24XX_VA_READPERM0		OMAP2_L3_IO_ADDRESS(0x68005050)
+#define OMAP24XX_VA_WRITEPERM0		OMAP2_L3_IO_ADDRESS(0x68005058)
 
-#define OMAP34XX_VA_REQINFOPERM0	OMAP2_IO_ADDRESS(0x68012848)
-#define OMAP34XX_VA_READPERM0		OMAP2_IO_ADDRESS(0x68012850)
-#define OMAP34XX_VA_WRITEPERM0		OMAP2_IO_ADDRESS(0x68012858)
-#define OMAP34XX_VA_ADDR_MATCH2		OMAP2_IO_ADDRESS(0x68012880)
-#define OMAP34XX_VA_SMS_RG_ATT0		OMAP2_IO_ADDRESS(0x6C000048)
-#define OMAP34XX_VA_CONTROL_STAT	OMAP2_IO_ADDRESS(0x480022F0)
+#define OMAP34XX_VA_REQINFOPERM0	OMAP2_L3_IO_ADDRESS(0x68012848)
+#define OMAP34XX_VA_READPERM0		OMAP2_L3_IO_ADDRESS(0x68012850)
+#define OMAP34XX_VA_WRITEPERM0		OMAP2_L3_IO_ADDRESS(0x68012858)
+#define OMAP34XX_VA_ADDR_MATCH2		OMAP2_L3_IO_ADDRESS(0x68012880)
+#define OMAP34XX_VA_SMS_RG_ATT0		OMAP2_L3_IO_ADDRESS(0x6C000048)
+#define OMAP34XX_VA_CONTROL_STAT	OMAP2_L4_IO_ADDRESS(0x480022F0)
 
 #define GP_DEVICE		0x300
 
diff --git a/arch/arm/plat-omap/usb.c b/arch/arm/plat-omap/usb.c
index 509f2ed..3c40b85 100644
--- a/arch/arm/plat-omap/usb.c
+++ b/arch/arm/plat-omap/usb.c
@@ -614,8 +614,8 @@ omap_otg_init(struct omap_usb_config *config)
 	if (config->otg || config->register_host) {
 		syscon &= ~HST_IDLE_EN;
 		ohci_device.dev.platform_data = config;
-		if (cpu_is_omap730())
-			ohci_resources[1].start = INT_730_USB_HHC_1;
+		if (cpu_is_omap7xx())
+			ohci_resources[1].start = INT_7XX_USB_HHC_1;
 		status = platform_device_register(&ohci_device);
 		if (status)
 			pr_debug("can't register OHCI device, %d\n", status);
@@ -626,8 +626,8 @@ omap_otg_init(struct omap_usb_config *config)
 	if (config->otg) {
 		syscon &= ~OTG_IDLE_EN;
 		otg_device.dev.platform_data = config;
-		if (cpu_is_omap730())
-			otg_resources[1].start = INT_730_USB_OTG;
+		if (cpu_is_omap7xx())
+			otg_resources[1].start = INT_7XX_USB_OTG;
 		status = platform_device_register(&otg_device);
 		if (status)
 			pr_debug("can't register OTG device, %d\n", status);
@@ -731,7 +731,7 @@ static inline void omap_1510_usb_init(struct omap_usb_config *config) {}
 
 void __init omap_usb_init(struct omap_usb_config *pdata)
 {
-	if (cpu_is_omap730() || cpu_is_omap16xx() || cpu_is_omap24xx())
+	if (cpu_is_omap7xx() || cpu_is_omap16xx() || cpu_is_omap24xx())
 		omap_otg_init(pdata);
 	else if (cpu_is_omap15xx())
 		omap_1510_usb_init(pdata);
diff --git a/drivers/Makefile b/drivers/Makefile
index 6ee53c7..086857c 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -72,7 +72,7 @@ obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
-obj-y				+= i2c/ media/
+obj-y				+= i2c/ media/ cbus/
 obj-$(CONFIG_PPS)		+= pps/
 obj-$(CONFIG_W1)		+= w1/
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
diff --git a/drivers/cbus/Kconfig b/drivers/cbus/Kconfig
new file mode 100644
index 0000000..25f8039
--- /dev/null
+++ b/drivers/cbus/Kconfig
@@ -0,0 +1,89 @@
+#
+# CBUS device configuration
+#
+
+menu "CBUS support"
+
+config CBUS
+	depends on ARCH_OMAP
+	bool "CBUS support on OMAP"
+	---help---
+	  CBUS is a proprietary serial protocol by Nokia.  It is mainly
+	  used for accessing Energy Management auxiliary chips.
+
+	  If you want CBUS support, you should say Y here.
+
+config CBUS_TAHVO
+	depends on CBUS
+	bool "Support for Tahvo"
+	---help---
+	  Tahvo is a mixed signal ASIC with some system features
+
+	  If you want Tahvo support, you should say Y here.
+
+config CBUS_TAHVO_USER
+	depends on CBUS_TAHVO
+	bool "Support for Tahvo user space functions"
+	---help---
+	  If you want support for Tahvo's user space read/write etc. functions,
+	  you should say Y here.
+
+config CBUS_TAHVO_USB
+	depends on CBUS_TAHVO && USB
+	tristate "Support for Tahvo USB transceiver"
+	---help---
+	  If you want Tahvo support for USB transceiver, say Y or M here.
+
+config CBUS_TAHVO_USB_HOST_BY_DEFAULT
+	depends on CBUS_TAHVO_USB && USB_OTG
+	boolean "Device in USB host mode by default"
+	---help---
+	  Say Y here, if you want the device to enter USB host mode
+	  by default on bootup.
+
+config CBUS_RETU
+	depends on CBUS
+	bool "Support for Retu"
+	---help---
+	  Retu is a mixed signal ASIC with some system features
+
+	  If you want Retu support, you should say Y here.
+
+config CBUS_RETU_USER
+	depends on CBUS_RETU
+	bool "Support for Retu user space functions"
+	---help---
+	  If you want support for Retu's user space read/write etc. functions,
+	  you should say Y here.
+
+config CBUS_RETU_POWERBUTTON
+	depends on CBUS_RETU
+	bool "Support for Retu power button"
+	---help---
+	  The power button on Nokia 770 is connected to the Retu ASIC.
+
+	  If you want support for the Retu power button, you should say Y here.
+
+config CBUS_RETU_RTC
+	depends on CBUS_RETU && SYSFS
+	tristate "Support for Retu pseudo-RTC"
+	---help---
+	  Say Y here if you want support for the device that alleges to be an
+	  RTC in Retu. This will expose a sysfs interface for it.
+
+config CBUS_RETU_WDT
+	depends on CBUS_RETU && SYSFS
+	tristate "Support for Retu watchdog timer"
+	---help---
+	  Say Y here if you want support for the watchdog in Retu. This will
+	  expose a sysfs interface to grok it.
+
+config CBUS_RETU_HEADSET
+	depends on CBUS_RETU && SYSFS
+	tristate "Support for headset detection with Retu/Vilma"
+	---help---
+	  Say Y here if you want support detecting a headset that's connected
+	  to Retu/Vilma. Detection state and events are exposed through
+	  sysfs.
+
+endmenu
diff --git a/drivers/cbus/Makefile b/drivers/cbus/Makefile
new file mode 100644
index 0000000..347c2a4
--- /dev/null
+++ b/drivers/cbus/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for CBUS.
+#
+
+obj-$(CONFIG_CBUS)		+= cbus.o
+obj-$(CONFIG_CBUS_TAHVO)	+= tahvo.o
+obj-$(CONFIG_CBUS_RETU)		+= retu.o
+obj-$(CONFIG_CBUS_TAHVO_USB)	+= tahvo-usb.o
+obj-$(CONFIG_CBUS_RETU_POWERBUTTON) += retu-pwrbutton.o
+obj-$(CONFIG_CBUS_RETU_RTC)	+= retu-rtc.o
+obj-$(CONFIG_CBUS_RETU_WDT)	+= retu-wdt.o
+obj-$(CONFIG_CBUS_TAHVO_USER)	+= tahvo-user.o
+obj-$(CONFIG_CBUS_RETU_USER)	+= retu-user.o
+obj-$(CONFIG_CBUS_RETU_HEADSET)	+= retu-headset.o
diff --git a/drivers/cbus/cbus.c b/drivers/cbus/cbus.c
new file mode 100644
index 0000000..774acce
--- /dev/null
+++ b/drivers/cbus/cbus.c
@@ -0,0 +1,293 @@
+/*
+ * drivers/cbus/cbus.c
+ *
+ * Support functions for CBUS serial protocol
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com>,
+ *	      David Weinehall <david.weinehall@nokia.com>, and
+ *	      Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+
+#include <mach/board.h>
+#include <mach/board-nokia.h>
+
+#include <asm/io.h>
+
+#include "cbus.h"
+
+struct cbus_host *cbus_host = NULL;
+
+#ifdef CONFIG_ARCH_OMAP1
+/* We use our own MPUIO functions to get closer to 1MHz bus speed */
+
+static inline void cbus_set_gpio_direction(u32 base, int mpuio, int is_input)
+{
+	u16 w;
+
+	mpuio &= 0x0f;
+	w = __raw_readw(base + OMAP_MPUIO_IO_CNTL);
+	if (is_input)
+		w |= 1 << mpuio;
+	else
+		w &= ~(1 << mpuio);
+	__raw_writew(w, base + OMAP_MPUIO_IO_CNTL);
+
+}
+
+static inline void cbus_set_gpio_dataout(u32 base, int mpuio, int enable)
+{
+	u16 w;
+
+	mpuio &= 0x0f;
+	w = __raw_readw(base + OMAP_MPUIO_OUTPUT);
+	if (enable)
+		w |= 1 << mpuio;
+	else
+		w &= ~(1 << mpuio);
+	__raw_writew(w, base + OMAP_MPUIO_OUTPUT);
+}
+
+static inline int cbus_get_gpio_datain(u32 base, int mpuio)
+{
+	mpuio &= 0x0f;
+
+	return (__raw_readw(base + OMAP_MPUIO_INPUT_LATCH) & (1 << mpuio)) != 0;
+}
+
+static void cbus_send_bit(struct cbus_host *host, u32 base, int bit,
+			  int set_to_input)
+{
+	cbus_set_gpio_dataout(base, host->dat_gpio, bit ? 1 : 0);
+	cbus_set_gpio_dataout(base, host->clk_gpio, 1);
+
+	/* The data bit is read on the rising edge of CLK */
+	if (set_to_input)
+		cbus_set_gpio_direction(base, host->dat_gpio, 1);
+
+	cbus_set_gpio_dataout(base, host->clk_gpio, 0);
+}
+
+static u8 cbus_receive_bit(struct cbus_host *host, u32 base)
+{
+	u8 ret;
+
+	cbus_set_gpio_dataout(base, host->clk_gpio, 1);
+	ret = cbus_get_gpio_datain(base, host->dat_gpio);
+	cbus_set_gpio_dataout(base, host->clk_gpio, 0);
+
+	return ret;
+}
+
+#define cbus_output(base, gpio, val)	cbus_set_gpio_direction(base, gpio, 0)
+
+#else
+
+#define cbus_output(base, gpio, val)	gpio_direction_output(gpio, val)
+#define cbus_set_gpio_dataout(base, gpio, enable) gpio_set_value(gpio, enable)
+#define cbus_get_gpio_datain(base, int, gpio) gpio_get_value(gpio)
+
+static void _cbus_send_bit(struct cbus_host *host, int bit, int set_to_input)
+{
+	gpio_set_value(host->dat_gpio, bit ? 1 : 0);
+	gpio_set_value(host->clk_gpio, 1);
+
+	/* The data bit is read on the rising edge of CLK */
+	if (set_to_input)
+		gpio_direction_input(host->dat_gpio);
+
+	gpio_set_value(host->clk_gpio, 0);
+}
+
+static u8 _cbus_receive_bit(struct cbus_host *host)
+{
+	u8 ret;
+
+	gpio_set_value(host->clk_gpio, 1);
+	ret = gpio_get_value(host->dat_gpio);
+	gpio_set_value(host->clk_gpio, 0);
+
+	return ret;
+}
+
+#define cbus_send_bit(host, base, bit, set_to_input) _cbus_send_bit(host, bit, set_to_input)
+#define cbus_receive_bit(host, base) _cbus_receive_bit(host)
+
+#endif
+
+static int cbus_transfer(struct cbus_host *host, int dev, int reg, int data)
+{
+	int i;
+	int is_read = 0;
+	unsigned long flags;
+	u32 base;
+
+#ifdef CONFIG_ARCH_OMAP1
+	base = OMAP1_IO_ADDRESS(OMAP_MPUIO_BASE);
+#else
+	base = 0;
+#endif
+
+	if (data < 0)
+		is_read = 1;
+
+	/* We don't want interrupts disturbing our transfer */
+	spin_lock_irqsave(&host->lock, flags);
+
+	/* Reset state and start of transfer, SEL stays down during transfer */
+	cbus_set_gpio_dataout(base, host->sel_gpio, 0);
+
+	/* Set the DAT pin to output */
+	cbus_output(base, host->dat_gpio, 1);
+
+	/* Send the device address */
+	for (i = 3; i > 0; i--)
+		cbus_send_bit(host, base, dev & (1 << (i - 1)), 0);
+
+	/* Send the rw flag */
+	cbus_send_bit(host, base, is_read, 0);
+
+	/* Send the register address */
+	for (i = 5; i > 0; i--) {
+		int set_to_input = 0;
+
+		if (is_read && i == 1)
+			set_to_input = 1;
+
+		cbus_send_bit(host, base, reg & (1 << (i - 1)), set_to_input);
+	}
+
+	if (!is_read) {
+		for (i = 16; i > 0; i--)
+			cbus_send_bit(host, base, data & (1 << (i - 1)), 0);
+	} else {
+		cbus_set_gpio_dataout(base, host->clk_gpio, 1);
+		data = 0;
+
+		for (i = 16; i > 0; i--) {
+			u8 bit = cbus_receive_bit(host, base);
+
+			if (bit)
+				data |= 1 << (i - 1);
+		}
+	}
+
+	/* Indicate end of transfer, SEL goes up until next transfer */
+	cbus_set_gpio_dataout(base, host->sel_gpio, 1);
+	cbus_set_gpio_dataout(base, host->clk_gpio, 1);
+	cbus_set_gpio_dataout(base, host->clk_gpio, 0);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	return is_read ? data : 0;
+}
+
+/*
+ * Read a given register from the device
+ */
+int cbus_read_reg(struct cbus_host *host, int dev, int reg)
+{
+	return cbus_host ? cbus_transfer(host, dev, reg, -1) : -ENODEV;
+}
+
+/*
+ * Write to a given register of the device
+ */
+int cbus_write_reg(struct cbus_host *host, int dev, int reg, u16 val)
+{
+	return cbus_host ? cbus_transfer(host, dev, reg, (int)val) : -ENODEV;
+}
+
+int __init cbus_bus_init(void)
+{
+	const struct omap_cbus_config * cbus_config;
+	struct cbus_host *chost;
+	int ret;
+
+	chost = kmalloc(sizeof (*chost), GFP_KERNEL);
+	if (chost == NULL)
+		return -ENOMEM;
+
+	memset(chost, 0, sizeof (*chost));
+
+	spin_lock_init(&chost->lock);
+
+	cbus_config = omap_get_config(OMAP_TAG_CBUS, struct omap_cbus_config);
+
+	if (cbus_config == NULL) {
+		printk(KERN_ERR "cbus: Unable to retrieve config data\n");
+		return -ENODATA;
+	}
+
+	chost->clk_gpio = cbus_config->clk_gpio;
+	chost->dat_gpio = cbus_config->dat_gpio;
+	chost->sel_gpio = cbus_config->sel_gpio;
+
+#ifdef CONFIG_ARCH_OMAP1
+	if (!OMAP_GPIO_IS_MPUIO(chost->clk_gpio) ||
+	    !OMAP_GPIO_IS_MPUIO(chost->dat_gpio) ||
+	    !OMAP_GPIO_IS_MPUIO(chost->sel_gpio)) {
+		printk(KERN_ERR "cbus: Only MPUIO pins supported\n");
+		ret = -ENODEV;
+		goto exit1;
+	}
+#endif
+
+	if ((ret = gpio_request(chost->clk_gpio, "CBUS clk")) < 0)
+		goto exit1;
+
+	if ((ret = gpio_request(chost->dat_gpio, "CBUS data")) < 0)
+		goto exit2;
+
+	if ((ret = gpio_request(chost->sel_gpio, "CBUS sel")) < 0)
+		goto exit3;
+
+	gpio_direction_output(chost->clk_gpio, 0);
+	gpio_direction_input(chost->dat_gpio);
+	gpio_direction_output(chost->sel_gpio, 1);
+
+	gpio_set_value(chost->clk_gpio, 1);
+	gpio_set_value(chost->clk_gpio, 0);
+
+	cbus_host = chost;
+
+	return 0;
+exit3:
+	gpio_free(chost->dat_gpio);
+exit2:
+	gpio_free(chost->clk_gpio);
+exit1:
+	kfree(chost);
+	return ret;
+}
+
+subsys_initcall(cbus_bus_init);
+
+EXPORT_SYMBOL(cbus_host);
+EXPORT_SYMBOL(cbus_read_reg);
+EXPORT_SYMBOL(cbus_write_reg);
+
+MODULE_DESCRIPTION("CBUS serial protocol");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Juha Yrjl, David Weinehall, and Mikko Ylinen");
diff --git a/drivers/cbus/cbus.h b/drivers/cbus/cbus.h
new file mode 100644
index 0000000..957224c
--- /dev/null
+++ b/drivers/cbus/cbus.h
@@ -0,0 +1,36 @@
+/*
+ * drivers/cbus/cbus.h
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com> and
+ *	      David Weinehall <david.weinehall@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DRIVERS_CBUS_CBUS_H
+#define __DRIVERS_CBUS_CBUS_H
+
+struct cbus_host {
+	int clk_gpio, dat_gpio, sel_gpio;
+        spinlock_t lock;
+};
+
+extern struct cbus_host *cbus_host;
+
+extern int cbus_read_reg(struct cbus_host *host, int dev, int reg);
+extern int cbus_write_reg(struct cbus_host *host, int dev, int reg, u16 val);
+
+#endif /* __DRIVERS_CBUS_CBUS_H */
diff --git a/drivers/cbus/retu-headset.c b/drivers/cbus/retu-headset.c
new file mode 100644
index 0000000..e798bc2
--- /dev/null
+++ b/drivers/cbus/retu-headset.c
@@ -0,0 +1,355 @@
+/**
+ * Retu/Vilma headset detection
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ *
+ * Written by Juha Yrjl
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+#include "retu.h"
+
+#define RETU_ADC_CHANNEL_HOOKDET	0x05
+
+#define RETU_HEADSET_KEY		KEY_PHONE
+
+struct retu_headset {
+	spinlock_t			lock;
+	struct mutex			mutex;
+	struct platform_device		*pdev;
+	struct input_dev		*idev;
+	unsigned			bias_enabled;
+	unsigned			detection_enabled;
+	unsigned			pressed;
+	struct timer_list		enable_timer;
+	struct timer_list		detect_timer;
+};
+
+static void retu_headset_set_bias(int enable)
+{
+	if (enable) {
+		retu_set_clear_reg_bits(RETU_REG_AUDTXR,
+					(1 << 0) | (1 << 1), 0);
+		msleep(2);
+		retu_set_clear_reg_bits(RETU_REG_AUDTXR, 1 << 3, 0);
+	} else {
+		retu_set_clear_reg_bits(RETU_REG_AUDTXR, 0,
+					(1 << 0) | (1 << 1) | (1 << 3));
+	}
+}
+
+static void retu_headset_enable(struct retu_headset *hs)
+{
+	mutex_lock(&hs->mutex);
+	if (!hs->bias_enabled) {
+		hs->bias_enabled = 1;
+		retu_headset_set_bias(1);
+	}
+	mutex_unlock(&hs->mutex);
+}
+
+static void retu_headset_disable(struct retu_headset *hs)
+{
+	mutex_lock(&hs->mutex);
+	if (hs->bias_enabled) {
+		hs->bias_enabled = 0;
+		retu_headset_set_bias(0);
+	}
+	mutex_unlock(&hs->mutex);
+}
+
+static void retu_headset_det_enable(struct retu_headset *hs)
+{
+	mutex_lock(&hs->mutex);
+	if (!hs->detection_enabled) {
+		hs->detection_enabled = 1;
+		retu_set_clear_reg_bits(RETU_REG_CC1, (1 << 10) | (1 << 8), 0);
+		retu_enable_irq(RETU_INT_HOOK);
+	}
+	mutex_unlock(&hs->mutex);
+}
+
+static void retu_headset_det_disable(struct retu_headset *hs)
+{
+	unsigned long flags;
+
+	mutex_lock(&hs->mutex);
+	if (hs->detection_enabled) {
+		hs->detection_enabled = 0;
+		retu_disable_irq(RETU_INT_HOOK);
+		del_timer_sync(&hs->enable_timer);
+		del_timer_sync(&hs->detect_timer);
+		spin_lock_irqsave(&hs->lock, flags);
+		if (hs->pressed)
+			input_report_key(hs->idev, RETU_HEADSET_KEY, 0);
+		spin_unlock_irqrestore(&hs->lock, flags);
+		retu_set_clear_reg_bits(RETU_REG_CC1, 0, (1 << 10) | (1 << 8));
+	}
+	mutex_unlock(&hs->mutex);
+}
+
+static ssize_t retu_headset_hookdet_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int val;
+
+	val = retu_read_adc(RETU_ADC_CHANNEL_HOOKDET);
+	return sprintf(buf, "%d\n", val);
+}
+
+static DEVICE_ATTR(hookdet, S_IRUGO, retu_headset_hookdet_show, NULL);
+
+static ssize_t retu_headset_enable_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct retu_headset *hs = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", hs->bias_enabled);
+}
+
+static ssize_t retu_headset_enable_store(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t count)
+{
+	struct retu_headset *hs = dev_get_drvdata(dev);
+	int enable;
+
+	if (sscanf(buf, "%u", &enable) != 1)
+		return -EINVAL;
+	if (enable)
+		retu_headset_enable(hs);
+	else
+	        retu_headset_disable(hs);
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR | S_IWGRP,
+		   retu_headset_enable_show, retu_headset_enable_store);
+
+static ssize_t retu_headset_enable_det_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct retu_headset *hs = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", hs->detection_enabled);
+}
+
+static ssize_t retu_headset_enable_det_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count)
+{
+	struct retu_headset *hs = dev_get_drvdata(dev);
+	int enable;
+
+	if (sscanf(buf, "%u", &enable) != 1)
+		return -EINVAL;
+	if (enable)
+		retu_headset_det_enable(hs);
+	else
+	        retu_headset_det_disable(hs);
+	return count;
+}
+
+static DEVICE_ATTR(enable_det, S_IRUGO | S_IWUSR | S_IWGRP,
+		   retu_headset_enable_det_show,
+		   retu_headset_enable_det_store);
+
+static void retu_headset_hook_interrupt(unsigned long arg)
+{
+	struct retu_headset *hs = (struct retu_headset *) arg;
+	unsigned long flags;
+
+	retu_ack_irq(RETU_INT_HOOK);
+	spin_lock_irqsave(&hs->lock, flags);
+	if (!hs->pressed) {
+		/* Headset button was just pressed down. */
+		hs->pressed = 1;
+		input_report_key(hs->idev, RETU_HEADSET_KEY, 1);
+	}
+	spin_unlock_irqrestore(&hs->lock, flags);
+	retu_set_clear_reg_bits(RETU_REG_CC1, 0, (1 << 10) | (1 << 8));
+	mod_timer(&hs->enable_timer, jiffies + msecs_to_jiffies(50));
+}
+
+static void retu_headset_enable_timer(unsigned long arg)
+{
+	struct retu_headset *hs = (struct retu_headset *) arg;
+
+	retu_set_clear_reg_bits(RETU_REG_CC1, (1 << 10) | (1 << 8), 0);
+	mod_timer(&hs->detect_timer, jiffies + msecs_to_jiffies(350));
+}
+
+static void retu_headset_detect_timer(unsigned long arg)
+{
+	struct retu_headset *hs = (struct retu_headset *) arg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hs->lock, flags);
+	if (hs->pressed) {
+		hs->pressed = 0;
+		input_report_key(hs->idev, RETU_HEADSET_KEY, 0);
+	}
+	spin_unlock_irqrestore(&hs->lock, flags);
+}
+
+static int __init retu_headset_probe(struct platform_device *pdev)
+{
+	struct retu_headset *hs;
+	int r;
+
+	hs = kzalloc(sizeof(*hs), GFP_KERNEL);
+	if (hs == NULL)
+		return -ENOMEM;
+
+	hs->pdev = pdev;
+
+	hs->idev = input_allocate_device();
+	if (hs->idev == NULL) {
+		r = -ENOMEM;
+		goto err1;
+	}
+	hs->idev->name = "retu-headset";
+	hs->idev->dev.parent = &pdev->dev;
+	set_bit(EV_KEY, hs->idev->evbit);
+	set_bit(RETU_HEADSET_KEY, hs->idev->keybit);
+	r = input_register_device(hs->idev);
+	if (r < 0)
+		goto err2;
+
+	r = device_create_file(&pdev->dev, &dev_attr_hookdet);
+	if (r < 0)
+		goto err3;
+	r = device_create_file(&pdev->dev, &dev_attr_enable);
+	if (r < 0)
+		goto err4;
+	r = device_create_file(&pdev->dev, &dev_attr_enable_det);
+	if (r < 0)
+		goto err5;
+	platform_set_drvdata(pdev, hs);
+
+	spin_lock_init(&hs->lock);
+	mutex_init(&hs->mutex);
+	setup_timer(&hs->enable_timer, retu_headset_enable_timer,
+		    (unsigned long) hs);
+	setup_timer(&hs->detect_timer, retu_headset_detect_timer,
+		    (unsigned long) hs);
+
+	r = retu_request_irq(RETU_INT_HOOK, retu_headset_hook_interrupt,
+			     (unsigned long) hs, "hookdet");
+	if (r != 0) {
+		dev_err(&pdev->dev, "hookdet IRQ not available\n");
+		goto err6;
+	}
+	retu_disable_irq(RETU_INT_HOOK);
+	return 0;
+err6:
+	device_remove_file(&pdev->dev, &dev_attr_enable_det);
+err5:
+	device_remove_file(&pdev->dev, &dev_attr_enable);
+err4:
+	device_remove_file(&pdev->dev, &dev_attr_hookdet);
+err3:
+	input_unregister_device(hs->idev);
+err2:
+	input_free_device(hs->idev);
+err1:
+	kfree(hs);
+	return r;
+}
+
+static int retu_headset_remove(struct platform_device *pdev)
+{
+	struct retu_headset *hs = platform_get_drvdata(pdev);
+
+	device_remove_file(&pdev->dev, &dev_attr_hookdet);
+	device_remove_file(&pdev->dev, &dev_attr_enable);
+	device_remove_file(&pdev->dev, &dev_attr_enable_det);
+	retu_headset_disable(hs);
+	retu_headset_det_disable(hs);
+	retu_free_irq(RETU_INT_HOOK);
+	input_unregister_device(hs->idev);
+	input_free_device(hs->idev);
+	return 0;
+}
+
+static int retu_headset_suspend(struct platform_device *pdev,
+				pm_message_t mesg)
+{
+	struct retu_headset *hs = platform_get_drvdata(pdev);
+
+	mutex_lock(&hs->mutex);
+	if (hs->bias_enabled)
+		retu_headset_set_bias(0);
+	mutex_unlock(&hs->mutex);
+
+	return 0;
+}
+
+static int retu_headset_resume(struct platform_device *pdev)
+{
+	struct retu_headset *hs = platform_get_drvdata(pdev);
+
+	mutex_lock(&hs->mutex);
+	if (hs->bias_enabled)
+		retu_headset_set_bias(1);
+	mutex_unlock(&hs->mutex);
+
+	return 0;
+}
+
+static struct platform_driver retu_headset_driver = {
+	.probe		= retu_headset_probe,
+	.remove		= retu_headset_remove,
+	.suspend	= retu_headset_suspend,
+	.resume		= retu_headset_resume,
+	.driver		= {
+		.name	= "retu-headset",
+	},
+};
+
+static int __init retu_headset_init(void)
+{
+	int r;
+
+	printk(KERN_INFO "Retu/Vilma headset driver initializing\n");
+
+	r = platform_driver_register(&retu_headset_driver);
+	if (r < 0)
+		return r;
+
+	return 0;
+}
+
+static void __exit retu_headset_exit(void)
+{
+	platform_driver_unregister(&retu_headset_driver);
+}
+
+module_init(retu_headset_init);
+module_exit(retu_headset_exit);
+
+MODULE_DESCRIPTION("Retu/Vilma headset detection");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Juha Yrjl");
diff --git a/drivers/cbus/retu-pwrbutton.c b/drivers/cbus/retu-pwrbutton.c
new file mode 100644
index 0000000..38d7aa4
--- /dev/null
+++ b/drivers/cbus/retu-pwrbutton.c
@@ -0,0 +1,118 @@
+/**
+ * drivers/cbus/retu-pwrbutton.c
+ *
+ * Driver for sending retu power button event to input-layer
+ *
+ * Copyright (C) 2004 Nokia Corporation
+ *
+ * Written by Ari Saastamoinen <ari.saastamoinen@elektrobit.com>
+ *
+ * Contact Juha Yrjl <juha.yrjola@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/input.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/bitops.h>
+
+#include "retu.h"
+
+#define RETU_STATUS_PWRONX	(1 << 5)
+
+#define PWRBTN_DELAY		20
+#define PWRBTN_UP		0
+#define PWRBTN_PRESSED		1
+
+static int pwrbtn_state;
+static struct input_dev *pwrbtn_dev;
+static struct timer_list pwrbtn_timer;
+
+static void retubutton_timer_func(unsigned long arg)
+{
+	int state;
+
+	if (retu_read_reg(RETU_REG_STATUS) & RETU_STATUS_PWRONX)
+		state = PWRBTN_UP;
+	else
+		state = PWRBTN_PRESSED;
+
+	if (pwrbtn_state != state) {
+		input_report_key(pwrbtn_dev, KEY_POWER, state);
+		pwrbtn_state = state;
+	}
+}
+
+/**
+ * Interrupt function is called whenever power button key is pressed
+ * or released.
+ */
+static void retubutton_irq(unsigned long arg)
+{
+	retu_ack_irq(RETU_INT_PWR);
+	mod_timer(&pwrbtn_timer, jiffies + msecs_to_jiffies(PWRBTN_DELAY));
+}
+
+/**
+ * Init function.
+ * Allocates interrupt for power button and registers itself to input layer.
+ */
+static int __init retubutton_init(void)
+{
+	int irq;
+
+	printk(KERN_INFO "Retu power button driver initialized\n");
+	irq = RETU_INT_PWR;
+
+	init_timer(&pwrbtn_timer);
+	pwrbtn_timer.function = retubutton_timer_func;
+
+	if (retu_request_irq(irq, &retubutton_irq, 0, "PwrOnX") < 0) {
+		printk(KERN_ERR "%s@%s: Cannot allocate irq\n",
+		       __FUNCTION__, __FILE__);
+		return -EBUSY;
+	}
+
+	pwrbtn_dev = input_allocate_device();
+	if (!pwrbtn_dev)
+		return -ENOMEM;
+
+	pwrbtn_dev->evbit[0] = BIT_MASK(EV_KEY);
+	pwrbtn_dev->keybit[BIT_WORD(KEY_POWER)] = BIT_MASK(KEY_POWER);
+	pwrbtn_dev->name = "retu-pwrbutton";
+
+	return input_register_device(pwrbtn_dev);
+}
+
+/**
+ * Cleanup function which is called when driver is unloaded
+ */
+static void __exit retubutton_exit(void)
+{
+	retu_free_irq(RETU_INT_PWR);
+	del_timer_sync(&pwrbtn_timer);
+	input_unregister_device(pwrbtn_dev);
+}
+
+module_init(retubutton_init);
+module_exit(retubutton_exit);
+
+MODULE_DESCRIPTION("Retu Power Button");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ari Saastamoinen");
diff --git a/drivers/cbus/retu-rtc.c b/drivers/cbus/retu-rtc.c
new file mode 100644
index 0000000..1ebc33b
--- /dev/null
+++ b/drivers/cbus/retu-rtc.c
@@ -0,0 +1,477 @@
+/**
+ * drivers/cbus/retu-rtc.c
+ *
+ * Support for Retu RTC
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Paul Mundt <paul.mundt@nokia.com> and
+ *            Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * The Retu RTC is essentially a partial read-only RTC that gives us Retu's
+ * idea of what time actually is. It's left as a userspace excercise to map
+ * this back to time in the real world and ensure that calibration settings
+ * are sane to compensate for any horrible drift (on account of not being able
+ * to set the clock to anything).
+ *
+ * Days are semi-writeable. Namely, Retu will only track 255 days for us
+ * consecutively, after which the counter is explicitly stuck at 255 until
+ * someone comes along and clears it with a write. In the event that no one
+ * comes along and clears it, we no longer have any idea what day it is.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#include "cbus.h"
+#include "retu.h"
+
+static struct mutex retu_rtc_mutex;
+static u16 retu_rtc_alarm_expired;
+static u16 retu_rtc_reset_occurred;
+
+static DECLARE_COMPLETION(retu_rtc_exited);
+static DECLARE_COMPLETION(retu_rtc_sync);
+
+static void retu_rtc_barrier(void);
+
+static void retu_rtc_device_release(struct device *dev)
+{
+	complete(&retu_rtc_exited);
+}
+
+static ssize_t retu_rtc_time_show(struct device *dev, struct device_attribute *attr,
+				  char *buf)
+{
+	u16 dsr, hmr, dsr2;
+
+	mutex_lock(&retu_rtc_mutex);
+
+	do {
+		u16 dummy;
+
+		/*
+		 * Not being in_interrupt() for a retu rtc IRQ, we need to
+		 * read twice for consistency..
+		 */
+		dummy	= retu_read_reg(RETU_REG_RTCDSR);
+		dsr	= retu_read_reg(RETU_REG_RTCDSR);
+
+		dummy	= retu_read_reg(RETU_REG_RTCHMR);
+		hmr	= retu_read_reg(RETU_REG_RTCHMR);
+
+		dummy	= retu_read_reg(RETU_REG_RTCDSR);
+		dsr2	= retu_read_reg(RETU_REG_RTCDSR);
+	} while ((dsr != dsr2));
+
+	mutex_unlock(&retu_rtc_mutex);
+
+	/*
+	 * Format a 32-bit date-string for userspace
+	 *
+	 * days | hours | minutes | seconds
+	 *
+	 * 8 bits for each.
+	 *
+	 * This mostly sucks because days and seconds are tracked in RTCDSR
+	 * while hours and minutes are tracked in RTCHMR. And yes, there
+	 * really are no words that can describe an 8 bit day register (or
+	 * rather, none that will be reprinted here).
+	 */
+	return sprintf(buf, "0x%08x\n", (((dsr >> 8) & 0xff) << 24) |
+				        (((hmr >> 8) & 0x1f) << 16) |
+					 ((hmr & 0x3f) << 8) | (dsr & 0x3f));
+}
+
+static ssize_t retu_rtc_time_store(struct device *dev, struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	mutex_lock(&retu_rtc_mutex);
+	/*
+	 * Writing anything to the day counter forces it to 0
+	 * The seconds counter would be cleared by resetting the minutes counter,
+	 * however this won't happen, since we are using the hh:mm counters as
+	 * a set of free running counters and the day counter as a multiple
+	 * overflow holder.
+	 */
+
+	/* Reset day counter, but keep Temperature Shutdown state */
+	retu_write_reg(RETU_REG_RTCDSR,
+		       retu_read_reg(RETU_REG_RTCDSR) & (1 << 6));
+
+	mutex_unlock(&retu_rtc_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(time, S_IRUGO | S_IWUSR, retu_rtc_time_show,
+		   retu_rtc_time_store);
+
+
+static ssize_t retu_rtc_reset_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/*
+	 * Returns the status of the rtc
+	 *
+	 * 0: no reset has occurred or the status has been cleared
+	 * 1: a reset has occurred
+	 *
+	 * RTC needs to be reset only when both main battery
+	 * _AND_ backup battery are discharged
+	 */
+	return sprintf(buf, "%u\n", retu_rtc_reset_occurred);
+}
+
+static void retu_rtc_do_reset(void)
+{
+	u16 ccr1;
+
+	ccr1 = retu_read_reg(RETU_REG_CC1);
+	/* RTC in reset */
+	retu_write_reg(RETU_REG_CC1, ccr1 | 0x0001);
+	/* RTC in normal operating mode */
+	retu_write_reg(RETU_REG_CC1, ccr1 & ~0x0001);
+
+	retu_rtc_barrier();
+	/* Disable alarm and RTC WD */
+	retu_write_reg(RETU_REG_RTCHMAR, 0x7f3f);
+	/* Set Calibration register to default value */
+	retu_write_reg(RETU_REG_RTCCALR, 0x00c0);
+
+	retu_rtc_alarm_expired = 0;
+	retu_rtc_reset_occurred = 1;
+}
+
+static ssize_t retu_rtc_reset_store(struct device *dev, struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	unsigned choice;
+
+	if(sscanf(buf, "%u", &choice) != 1)
+		return count;
+	mutex_lock(&retu_rtc_mutex);
+	if (choice == 0)
+		retu_rtc_reset_occurred = 0;
+	else if (choice == 1)
+		retu_rtc_do_reset();
+	mutex_unlock(&retu_rtc_mutex);
+	return count;
+}
+
+static DEVICE_ATTR(reset, S_IRUGO | S_IWUSR, retu_rtc_reset_show,
+		   retu_rtc_reset_store);
+
+static ssize_t retu_rtc_alarm_show(struct device *dev, struct device_attribute *attr,
+				   char *buf)
+{
+	u16 chmar;
+	ssize_t retval;
+
+	mutex_lock(&retu_rtc_mutex);
+	/*
+	 * Format a 16-bit date-string for userspace
+	 *
+	 * hours | minutes
+	 * 8 bits for each.
+	 */
+	chmar = retu_read_reg(RETU_REG_RTCHMAR);
+	/* No shifting needed, only masking unrelated bits */
+	retval = sprintf(buf, "0x%04x\n", chmar & 0x1f3f);
+	mutex_unlock(&retu_rtc_mutex);
+
+	return retval;
+}
+
+static ssize_t retu_rtc_alarm_store(struct device *dev, struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	u16 chmar;
+	unsigned alrm;
+	unsigned hours;
+	unsigned minutes;
+
+	mutex_lock(&retu_rtc_mutex);
+
+	if(sscanf(buf, "%x", &alrm) != 1)
+		return count;
+	hours = (alrm >> 8) & 0x001f;
+	minutes = (alrm >> 0) & 0x003f;
+	if ((hours < 24 && minutes < 60) || (hours == 24 && minutes == 60)) {
+		/*
+		 * OK, the time format for the alarm is valid (including the
+		 * disabling values)
+		 */
+		/* Keeps the RTC watchdog status */
+		chmar = retu_read_reg(RETU_REG_RTCHMAR) & 0x6000;
+		chmar |= alrm & 0x1f3f;	/* Stores the requested alarm */
+		retu_rtc_barrier();
+		retu_write_reg(RETU_REG_RTCHMAR, chmar);
+		/* If the alarm is being disabled */
+		if (hours == 24 && minutes == 60) {
+			/* disable the interrupt */
+			retu_disable_irq(RETU_INT_RTCA);
+			retu_rtc_alarm_expired = 0;
+		} else
+			/* enable the interrupt */
+			retu_enable_irq(RETU_INT_RTCA);
+	}
+	mutex_unlock(&retu_rtc_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(alarm, S_IRUGO | S_IWUSR, retu_rtc_alarm_show,
+		   retu_rtc_alarm_store);
+
+static ssize_t retu_rtc_alarm_expired_show(struct device *dev, struct device_attribute *attr,
+					   char *buf)
+{
+	ssize_t retval;
+
+	retval = sprintf(buf, "%u\n", retu_rtc_alarm_expired);
+
+	return retval;
+}
+
+static ssize_t retu_rtc_alarm_expired_store(struct device *dev, struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	retu_rtc_alarm_expired = 0;
+
+	return count;
+}
+
+static DEVICE_ATTR(alarm_expired, S_IRUGO | S_IWUSR, retu_rtc_alarm_expired_show,
+		   retu_rtc_alarm_expired_store);
+
+
+static ssize_t retu_rtc_cal_show(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	u16 rtccalr1;
+
+	mutex_lock(&retu_rtc_mutex);
+	rtccalr1 = retu_read_reg(RETU_REG_RTCCALR);
+	mutex_unlock(&retu_rtc_mutex);
+
+	/*
+	 * Shows the status of the Calibration Register.
+	 *
+	 * Default, after power loss: 0x0000
+	 * Default, for R&D: 0x00C0
+	 * Default, for factory: 0x00??
+	 *
+	 */
+	return sprintf(buf, "0x%04x\n", rtccalr1 & 0x00ff);
+}
+
+static ssize_t retu_rtc_cal_store(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	unsigned calibration_value;
+
+	if (sscanf(buf, "%x", &calibration_value) != 1)
+		return count;
+
+	mutex_lock(&retu_rtc_mutex);
+	retu_rtc_barrier();
+	retu_write_reg(RETU_REG_RTCCALR, calibration_value & 0x00ff);
+	mutex_unlock(&retu_rtc_mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(cal, S_IRUGO | S_IWUSR, retu_rtc_cal_show,
+		   retu_rtc_cal_store);
+
+static struct platform_device retu_rtc_device;
+
+static void retu_rtca_disable(void)
+{
+	retu_disable_irq(RETU_INT_RTCA);
+	retu_rtc_alarm_expired = 1;
+	retu_rtc_barrier();
+	retu_write_reg(RETU_REG_RTCHMAR, (24 << 8) | 60);
+}
+
+static void retu_rtca_expired(struct work_struct *unused)
+{
+	retu_rtca_disable();
+	sysfs_notify(&retu_rtc_device.dev.kobj, NULL, "alarm_expired");
+}
+
+DECLARE_WORK(retu_rtca_work, retu_rtca_expired);
+
+/*
+ * RTCHMR RTCHMAR RTCCAL must be accessed within 0.9 s since the seconds
+ * interrupt has been signaled in the IDR register
+ */
+static void retu_rtcs_interrupt(unsigned long unused)
+{
+	retu_ack_irq(RETU_INT_RTCS);
+	complete_all(&retu_rtc_sync);
+}
+
+static void retu_rtca_interrupt(unsigned long unused)
+{
+	retu_ack_irq(RETU_INT_RTCA);
+	schedule_work(&retu_rtca_work);
+}
+
+static int retu_rtc_init_irq(void)
+{
+	int ret;
+
+	ret = retu_request_irq(RETU_INT_RTCS, retu_rtcs_interrupt, 0, "RTCS");
+	if (ret != 0)
+		return ret;
+	/*
+	 * We will take care of enabling and disabling the interrupt
+	 * elsewhere, so leave it off by default..
+	 */
+	retu_disable_irq(RETU_INT_RTCS);
+
+	ret = retu_request_irq(RETU_INT_RTCA, retu_rtca_interrupt, 0, "RTCA");
+	if (ret != 0) {
+		retu_free_irq(RETU_INT_RTCS);
+		return ret;
+	}
+	retu_disable_irq(RETU_INT_RTCA);
+
+	return 0;
+}
+
+
+static int __devinit retu_rtc_probe(struct device *dev)
+{
+	int r;
+
+	retu_rtc_alarm_expired = retu_read_reg(RETU_REG_IDR) &
+					       (0x1 << RETU_INT_RTCA);
+
+	if ((r = retu_rtc_init_irq()) != 0)
+		return r;
+
+	mutex_init(&retu_rtc_mutex);
+
+	/* If the calibration register is zero, we've probably lost
+	 * power */
+	if (retu_read_reg(RETU_REG_RTCCALR) & 0x00ff)
+		retu_rtc_reset_occurred = 0;
+	else
+		retu_rtc_do_reset();
+
+	if ((r = device_create_file(dev, &dev_attr_time)) != 0)
+		return r;
+	else if ((r = device_create_file(dev, &dev_attr_reset)) != 0)
+		goto err_unregister_time;
+	else if ((r = device_create_file(dev, &dev_attr_alarm)) != 0)
+		goto err_unregister_reset;
+	else if ((r = device_create_file(dev, &dev_attr_alarm_expired)) != 0)
+		goto err_unregister_alarm;
+	else if ((r = device_create_file(dev, &dev_attr_cal)) != 0)
+		goto err_unregister_alarm_expired;
+	else
+		return r;
+
+err_unregister_alarm_expired:
+	device_remove_file(dev, &dev_attr_alarm_expired);
+err_unregister_alarm:
+	device_remove_file(dev, &dev_attr_alarm);
+err_unregister_reset:
+	device_remove_file(dev, &dev_attr_reset);
+err_unregister_time:
+	device_remove_file(dev, &dev_attr_time);
+	return r;
+}
+
+static int __devexit retu_rtc_remove(struct device *dev)
+{
+	retu_disable_irq(RETU_INT_RTCS);
+	retu_free_irq(RETU_INT_RTCS);
+	retu_free_irq(RETU_INT_RTCA);
+	device_remove_file(dev, &dev_attr_cal);
+	device_remove_file(dev, &dev_attr_alarm_expired);
+	device_remove_file(dev, &dev_attr_alarm);
+	device_remove_file(dev, &dev_attr_reset);
+	device_remove_file(dev, &dev_attr_time);
+	return 0;
+}
+
+static struct device_driver retu_rtc_driver = {
+	.name		= "retu-rtc",
+	.bus		= &platform_bus_type,
+	.probe		= retu_rtc_probe,
+	.remove		= __devexit_p(retu_rtc_remove),
+};
+
+static struct platform_device retu_rtc_device = {
+	.name		= "retu-rtc",
+	.id		= -1,
+	.dev		= {
+		.release	= retu_rtc_device_release,
+	},
+};
+
+/* This function provides syncronization with the RTCS interrupt handler */
+static void retu_rtc_barrier(void)
+{
+	INIT_COMPLETION(retu_rtc_sync);
+	retu_ack_irq(RETU_INT_RTCS);
+	retu_enable_irq(RETU_INT_RTCS);
+	wait_for_completion(&retu_rtc_sync);
+	retu_disable_irq(RETU_INT_RTCS);
+}
+
+static int __init retu_rtc_init(void)
+{
+	int ret;
+
+	init_completion(&retu_rtc_exited);
+
+	if ((ret = driver_register(&retu_rtc_driver)) != 0)
+		return ret;
+
+	if ((ret = platform_device_register(&retu_rtc_device)) != 0)
+		goto err_unregister_driver;
+
+	return 0;
+
+err_unregister_driver:
+	driver_unregister(&retu_rtc_driver);
+	return ret;
+}
+
+static void __exit retu_rtc_exit(void)
+{
+	platform_device_unregister(&retu_rtc_device);
+	driver_unregister(&retu_rtc_driver);
+
+	wait_for_completion(&retu_rtc_exited);
+}
+
+module_init(retu_rtc_init);
+module_exit(retu_rtc_exit);
+
+MODULE_DESCRIPTION("Retu RTC");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Paul Mundt and Igor Stoppa");
diff --git a/drivers/cbus/retu-user.c b/drivers/cbus/retu-user.c
new file mode 100644
index 0000000..74a7d61
--- /dev/null
+++ b/drivers/cbus/retu-user.c
@@ -0,0 +1,423 @@
+/**
+ * drivers/cbus/retu-user.c
+ *
+ * Retu user space interface functions
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+
+#include <asm/uaccess.h>
+
+#include "retu.h"
+
+#include "user_retu_tahvo.h"
+
+/* Maximum size of IRQ node buffer/pool */
+#define RETU_MAX_IRQ_BUF_LEN	16
+
+#define PFX			"retu-user: "
+
+/* Bitmap for marking the interrupt sources as having the handlers */
+static u32 retu_irq_bits;
+
+/* For allowing only one user process to subscribe to the retu interrupts */
+static struct file *retu_irq_subscr = NULL;
+
+/* For poll and IRQ passing */
+struct retu_irq {
+	u32 id;
+	struct list_head node;
+};
+
+static spinlock_t retu_irqs_lock;
+static struct retu_irq *retu_irq_block;
+static LIST_HEAD(retu_irqs);
+static LIST_HEAD(retu_irqs_reserve);
+
+/* Wait queue - used when user wants to read the device */
+DECLARE_WAIT_QUEUE_HEAD(retu_user_waitqueue);
+
+/* Semaphore to protect irq subscription sequence */
+static struct mutex retu_mutex;
+
+/* This array specifies RETU register types (read/write/toggle) */
+static const u8 retu_access_bits[] = {
+	1,
+	4,
+	3,
+	3,
+	1,
+	3,
+	3,
+	0,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	4,
+	4,
+	3,
+	0,
+	0,
+	0,
+	0,
+	1,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3
+};
+
+/*
+ * The handler for all RETU interrupts.
+ *
+ * arg is the interrupt source in RETU.
+ */
+static void retu_user_irq_handler(unsigned long arg)
+{
+	struct retu_irq *irq;
+
+	retu_ack_irq(arg);
+
+	spin_lock(&retu_irqs_lock);
+	if (list_empty(&retu_irqs_reserve)) {
+		spin_unlock(&retu_irqs_lock);
+		return;
+	}
+	irq = list_entry((&retu_irqs_reserve)->next, struct retu_irq, node);
+	irq->id = arg;
+	list_move_tail(&irq->node, &retu_irqs);
+	spin_unlock(&retu_irqs_lock);
+
+	/* wake up waiting thread */
+	wake_up(&retu_user_waitqueue);
+}
+
+/*
+ * This routine sets up the interrupt handler and marks an interrupt source
+ * in RETU as a candidate for signal delivery to the user process.
+ */
+static int retu_user_subscribe_to_irq(int id, struct file *filp)
+{
+	int ret;
+
+	mutex_lock(&retu_mutex);
+	if ((retu_irq_subscr != NULL) && (retu_irq_subscr != filp)) {
+		mutex_unlock(&retu_mutex);
+		return -EBUSY;
+	}
+	/* Store the file pointer of the first user process registering IRQs */
+	retu_irq_subscr = filp;
+	mutex_unlock(&retu_mutex);
+
+	if (retu_irq_bits & (1 << id))
+		return 0;
+
+	ret = retu_request_irq(id, retu_user_irq_handler, id, "");
+	if (ret < 0)
+		return ret;
+
+	/* Mark that this interrupt has a handler */
+	retu_irq_bits |= 1 << id;
+
+	return 0;
+}
+
+/*
+ * Unregisters all RETU interrupt handlers.
+ */
+static void retu_unreg_irq_handlers(void)
+{
+	int id;
+
+	if (!retu_irq_bits)
+		return;
+
+	for (id = 0; id < MAX_RETU_IRQ_HANDLERS; id++)
+		if (retu_irq_bits & (1 << id))
+			retu_free_irq(id);
+
+	retu_irq_bits = 0;
+}
+
+/*
+ * Write to RETU register.
+ * Returns 0 upon success, a negative error value otherwise.
+ */
+static int retu_user_write_with_mask(u32 field, u16 value)
+{
+	u32 mask;
+	u32 reg;
+	u_short tmp;
+	unsigned long flags;
+
+	mask = MASK(field);
+	reg = REG(field);
+
+	/* Detect bad mask and reg */
+	if (mask == 0 || reg > RETU_REG_MAX ||
+	    retu_access_bits[reg] == READ_ONLY) {
+		printk(KERN_ERR PFX "invalid arguments (reg=%#x, mask=%#x)\n",
+		       reg, mask);
+		return -EINVAL;
+	}
+
+	/* Justify value according to mask */
+	while (!(mask & 1)) {
+		value = value << 1;
+		mask = mask >> 1;
+	}
+
+	spin_lock_irqsave(&retu_lock, flags);
+	if (retu_access_bits[reg] == TOGGLE) {
+		/* No need to detect previous content of register */
+		tmp = 0;
+	} else {
+		/* Read current value of register */
+		tmp = retu_read_reg(reg);
+	}
+
+	/* Generate new value */
+	tmp = (tmp & ~MASK(field)) | (value & MASK(field));
+	/* Write data to RETU */
+	retu_write_reg(reg, tmp);
+	spin_unlock_irqrestore(&retu_lock, flags);
+
+	return 0;
+}
+
+/*
+ * Read RETU register.
+ */
+static u32 retu_user_read_with_mask(u32 field)
+{
+	u_short value;
+	u32 mask, reg;
+
+	mask = MASK(field);
+	reg = REG(field);
+
+	/* Detect bad mask and reg */
+	if (mask == 0 || reg > RETU_REG_MAX) {
+		printk(KERN_ERR PFX "invalid arguments (reg=%#x, mask=%#x)\n",
+		       reg, mask);
+		return -EINVAL;
+	}
+
+	/* Read the register */
+	value = retu_read_reg(reg) & mask;
+
+	/* Right justify value */
+	while (!(mask & 1)) {
+		value = value >> 1;
+		mask = mask >> 1;
+	}
+
+	return value;
+}
+
+/*
+ * Close device
+ */
+static int retu_close(struct inode *inode, struct file *filp)
+{
+	/* Unregister all interrupts that have been registered */
+	if (retu_irq_subscr == filp) {
+		retu_unreg_irq_handlers();
+		retu_irq_subscr = NULL;
+	}
+
+	return 0;
+}
+
+/*
+ * Device control (ioctl)
+ */
+static int retu_ioctl(struct inode *inode, struct file *filp,
+		      unsigned int cmd, unsigned long arg)
+{
+	struct retu_tahvo_write_parms par;
+	int ret;
+
+	switch (cmd) {
+	case URT_IOCT_IRQ_SUBSCR:
+		return retu_user_subscribe_to_irq(arg, filp);
+	case RETU_IOCH_READ:
+		return retu_user_read_with_mask(arg);
+	case RETU_IOCX_WRITE:
+		ret = copy_from_user(&par, (void __user *) arg, sizeof(par));
+		if (ret)
+			printk(KERN_ERR "copy_from_user failed: %d\n", ret);
+		par.result = retu_user_write_with_mask(par.field, par.value);
+		ret = copy_to_user((void __user *) arg, &par, sizeof(par));
+		if (ret)
+			printk(KERN_ERR "copy_to_user failed: %d\n", ret);
+		break;
+	case RETU_IOCH_ADC_READ:
+		return retu_read_adc(arg);
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+/*
+ * Read from device
+ */
+static ssize_t retu_read(struct file *filp, char *buf, size_t count,
+			 loff_t * offp)
+{
+	struct retu_irq *irq;
+
+	u32 nr, i;
+
+	/* read not permitted if neither filp nor anyone has registered IRQs */
+	if (retu_irq_subscr != filp)
+		return -EPERM;
+
+	if ((count < sizeof(u32)) || ((count % sizeof(u32)) != 0))
+		return -EINVAL;
+
+	nr = count / sizeof(u32);
+
+	for (i = 0; i < nr; i++) {
+		unsigned long flags;
+		u32 irq_id;
+		int ret;
+
+		ret = wait_event_interruptible(retu_user_waitqueue,
+					       !list_empty(&retu_irqs));
+		if (ret < 0)
+			return ret;
+
+		spin_lock_irqsave(&retu_irqs_lock, flags);
+		irq = list_entry((&retu_irqs)->next, struct retu_irq, node);
+		irq_id = irq->id;
+		list_move(&irq->node, &retu_irqs_reserve);
+		spin_unlock_irqrestore(&retu_irqs_lock, flags);
+
+		ret = copy_to_user(buf + i * sizeof(irq_id), &irq_id,
+				   sizeof(irq_id));
+		if (ret)
+			printk(KERN_ERR "copy_to_user failed: %d\n", ret);
+	}
+
+	return count;
+}
+
+/*
+ * Poll method
+ */
+static unsigned retu_poll(struct file *filp, struct poll_table_struct *pt)
+{
+	if (!list_empty(&retu_irqs))
+		return POLLIN;
+
+	poll_wait(filp, &retu_user_waitqueue, pt);
+
+	if (!list_empty(&retu_irqs))
+		return POLLIN;
+	else
+		return 0;
+}
+
+static struct file_operations retu_user_fileops = {
+	.owner = THIS_MODULE,
+	.ioctl = retu_ioctl,
+	.read = retu_read,
+	.release = retu_close,
+	.poll = retu_poll
+};
+
+static struct miscdevice retu_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "retu",
+	.fops = &retu_user_fileops
+};
+
+/*
+ * Initialization
+ *
+ * @return 0 if successful, error value otherwise.
+ */
+int retu_user_init(void)
+{
+	struct retu_irq *irq;
+	int res, i;
+
+	irq = kmalloc(sizeof(*irq) * RETU_MAX_IRQ_BUF_LEN, GFP_KERNEL);
+	if (irq == NULL) {
+		printk(KERN_ERR PFX "kmalloc failed\n");
+		return -ENOMEM;
+	}
+	memset(irq, 0, sizeof(*irq) * RETU_MAX_IRQ_BUF_LEN);
+	for (i = 0; i < RETU_MAX_IRQ_BUF_LEN; i++)
+		list_add(&irq[i].node, &retu_irqs_reserve);
+
+	retu_irq_block = irq;
+
+	spin_lock_init(&retu_irqs_lock);
+	mutex_init(&retu_mutex);
+
+	/* Request a misc device */
+	res = misc_register(&retu_device);
+	if (res < 0) {
+		printk(KERN_ERR PFX "unable to register misc device for %s\n",
+		       retu_device.name);
+		kfree(irq);
+		return res;
+	}
+
+	return 0;
+}
+
+/*
+ * Cleanup.
+ */
+void retu_user_cleanup(void)
+{
+	/* Unregister our misc device */
+	misc_deregister(&retu_device);
+	/* Unregister and disable all RETU interrupts used by this module */
+	retu_unreg_irq_handlers();
+	kfree(retu_irq_block);
+}
+
+MODULE_DESCRIPTION("Retu ASIC user space functions");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mikko Ylinen");
diff --git a/drivers/cbus/retu-wdt.c b/drivers/cbus/retu-wdt.c
new file mode 100644
index 0000000..b7b20b7
--- /dev/null
+++ b/drivers/cbus/retu-wdt.c
@@ -0,0 +1,202 @@
+/**
+ * drivers/cbus/retu-wdt.c
+ *
+ * Driver for Retu watchdog
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Amit Kucheria <amit.kucheria@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/init.h>
+
+#include <linux/completion.h>
+#include <linux/errno.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+
+#include "cbus.h"
+#include "retu.h"
+
+/* Watchdog timeout in seconds */
+#define RETU_WDT_MIN_TIMER 0
+#define RETU_WDT_DEFAULT_TIMER 32
+#define RETU_WDT_MAX_TIMER 63
+
+static struct completion retu_wdt_completion;
+static DEFINE_MUTEX(retu_wdt_mutex);
+
+/* Current period of watchdog */
+static unsigned int period_val = RETU_WDT_DEFAULT_TIMER;
+static int counter_param = RETU_WDT_MAX_TIMER;
+
+static int retu_modify_counter(unsigned int new)
+{
+	int ret = 0;
+
+	if (new < RETU_WDT_MIN_TIMER || new > RETU_WDT_MAX_TIMER)
+		return -EINVAL;
+
+	mutex_lock(&retu_wdt_mutex);
+
+	period_val = new;
+	retu_write_reg(RETU_REG_WATCHDOG, (u16)period_val);
+
+	mutex_unlock(&retu_wdt_mutex);
+	return ret;
+}
+
+static ssize_t retu_wdt_period_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	/* Show current max counter */
+	return sprintf(buf, "%u\n", (u16)period_val);
+}
+
+static ssize_t retu_wdt_period_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	unsigned int new_period;
+	int ret;
+
+	if (sscanf(buf, "%u", &new_period) != 1) {
+		printk(KERN_ALERT "retu_wdt_period_store: Invalid input\n");
+		return -EINVAL;
+	}
+
+	ret = retu_modify_counter(new_period);
+	if (ret < 0)
+		return ret;
+
+	return strnlen(buf, count);
+}
+
+static ssize_t retu_wdt_counter_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	u16 counter;
+
+	/* Show current value in watchdog counter */
+	counter = retu_read_reg(RETU_REG_WATCHDOG);
+
+	/* Only the 5 LSB are important */
+	return snprintf(buf, PAGE_SIZE, "%u\n", (counter & 0x3F));
+}
+
+static DEVICE_ATTR(period, S_IRUGO | S_IWUSR, retu_wdt_period_show, \
+			retu_wdt_period_store);
+static DEVICE_ATTR(counter, S_IRUGO, retu_wdt_counter_show, NULL);
+
+static int __devinit retu_wdt_probe(struct device *dev)
+{
+	int ret;
+
+	ret = device_create_file(dev, &dev_attr_period);
+	if (ret) {
+		printk(KERN_ERR "retu_wdt_probe: Error creating "
+					"sys device file: period\n");
+		return ret;
+	}
+
+	ret = device_create_file(dev, &dev_attr_counter);
+	if (ret) {
+		device_remove_file(dev, &dev_attr_period);
+		printk(KERN_ERR "retu_wdt_probe: Error creating "
+					"sys device file: counter\n");
+	}
+
+	return ret;
+}
+
+static int __devexit retu_wdt_remove(struct device *dev)
+{
+	device_remove_file(dev, &dev_attr_period);
+	device_remove_file(dev, &dev_attr_counter);
+	return 0;
+}
+
+static void retu_wdt_device_release(struct device *dev)
+{
+	complete(&retu_wdt_completion);
+}
+
+static struct platform_device retu_wdt_device = {
+	.name = "retu-watchdog",
+	.id = -1,
+	.dev = {
+		.release = retu_wdt_device_release,
+	},
+};
+
+static struct device_driver retu_wdt_driver = {
+	.name = "retu-watchdog",
+	.bus = &platform_bus_type,
+	.probe = retu_wdt_probe,
+	.remove = __devexit_p(retu_wdt_remove),
+};
+
+static int __init retu_wdt_init(void)
+{
+	int ret;
+
+	init_completion(&retu_wdt_completion);
+
+	ret = driver_register(&retu_wdt_driver);
+	if (ret)
+		return ret;
+
+	ret = platform_device_register(&retu_wdt_device);
+	if (ret)
+		goto exit1;
+
+	/* passed as module parameter? */
+	ret = retu_modify_counter(counter_param);
+	if (ret == -EINVAL) {
+		ret = retu_modify_counter(RETU_WDT_DEFAULT_TIMER);
+		printk(KERN_INFO
+		       "retu_wdt_init: Intializing to default value\n");
+	}
+
+	printk(KERN_INFO "Retu watchdog driver initialized\n");
+	return ret;
+
+exit1:
+	driver_unregister(&retu_wdt_driver);
+	wait_for_completion(&retu_wdt_completion);
+
+	return ret;
+}
+
+static void __exit retu_wdt_exit(void)
+{
+	platform_device_unregister(&retu_wdt_device);
+	driver_unregister(&retu_wdt_driver);
+
+	wait_for_completion(&retu_wdt_completion);
+}
+
+module_init(retu_wdt_init);
+module_exit(retu_wdt_exit);
+module_param(counter_param, int, 0);
+
+MODULE_DESCRIPTION("Retu WatchDog");
+MODULE_AUTHOR("Amit Kucheria");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/cbus/retu.c b/drivers/cbus/retu.c
new file mode 100644
index 0000000..84d7840
--- /dev/null
+++ b/drivers/cbus/retu.c
@@ -0,0 +1,467 @@
+/**
+ * drivers/cbus/retu.c
+ *
+ * Support functions for Retu ASIC
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com>,
+ *	      David Weinehall <david.weinehall@nokia.com>, and
+ *	      Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/uaccess.h>
+
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/board-nokia.h>
+
+#include "cbus.h"
+#include "retu.h"
+
+#define RETU_ID			0x01
+#define PFX			"retu: "
+
+static int retu_initialized;
+static int retu_irq_pin;
+static int retu_is_vilma;
+
+static struct tasklet_struct retu_tasklet;
+spinlock_t retu_lock = SPIN_LOCK_UNLOCKED;
+
+static struct completion device_release;
+
+struct retu_irq_handler_desc {
+	int (*func)(unsigned long);
+	unsigned long arg;
+	char name[8];
+};
+
+static struct retu_irq_handler_desc retu_irq_handlers[MAX_RETU_IRQ_HANDLERS];
+
+/**
+ * retu_read_reg - Read a value from a register in Retu
+ * @reg: the register to read from
+ *
+ * This function returns the contents of the specified register
+ */
+int retu_read_reg(int reg)
+{
+	BUG_ON(!retu_initialized);
+	return cbus_read_reg(cbus_host, RETU_ID, reg);
+}
+
+/**
+ * retu_write_reg - Write a value to a register in Retu
+ * @reg: the register to write to
+ * @reg: the value to write to the register
+ *
+ * This function writes a value to the specified register
+ */
+void retu_write_reg(int reg, u16 val)
+{
+	BUG_ON(!retu_initialized);
+	cbus_write_reg(cbus_host, RETU_ID, reg, val);
+}
+
+void retu_set_clear_reg_bits(int reg, u16 set, u16 clear)
+{
+	unsigned long flags;
+	u16 w;
+
+	spin_lock_irqsave(&retu_lock, flags);
+	w = retu_read_reg(reg);
+	w &= ~clear;
+	w |= set;
+	retu_write_reg(reg, w);
+	spin_unlock_irqrestore(&retu_lock, flags);
+}
+
+#define ADC_MAX_CHAN_NUMBER	13
+
+int retu_read_adc(int channel)
+{
+	unsigned long flags;
+	int res;
+
+	if (channel < 0 || channel > ADC_MAX_CHAN_NUMBER)
+		return -EINVAL;
+
+	spin_lock_irqsave(&retu_lock, flags);
+
+	if ((channel == 8) && retu_is_vilma) {
+		int scr = retu_read_reg(RETU_REG_ADCSCR);
+		int ch = (retu_read_reg(RETU_REG_ADCR) >> 10) & 0xf;
+		if (((scr & 0xff) != 0) && (ch != 8))
+			retu_write_reg (RETU_REG_ADCSCR, (scr & ~0xff));
+	}
+
+	/* Select the channel and read result */
+	retu_write_reg(RETU_REG_ADCR, channel << 10);
+	res = retu_read_reg(RETU_REG_ADCR) & 0x3ff;
+
+	if (retu_is_vilma)
+		retu_write_reg(RETU_REG_ADCR, (1 << 13));
+
+	/* Unlock retu */
+	spin_unlock_irqrestore(&retu_lock, flags);
+
+	return res;
+}
+
+
+static u16 retu_disable_bogus_irqs(u16 mask)
+{
+       int i;
+
+       for (i = 0; i < MAX_RETU_IRQ_HANDLERS; i++) {
+               if (mask & (1 << i))
+                       continue;
+               if (retu_irq_handlers[i].func != NULL)
+                       continue;
+               /* an IRQ was enabled but we don't have a handler for it */
+               printk(KERN_INFO PFX "disabling bogus IRQ %d\n", i);
+               mask |= (1 << i);
+       }
+       return mask;
+}
+
+/*
+ * Disable given RETU interrupt
+ */
+void retu_disable_irq(int id)
+{
+	unsigned long flags;
+	u16 mask;
+
+	spin_lock_irqsave(&retu_lock, flags);
+	mask = retu_read_reg(RETU_REG_IMR);
+	mask |= 1 << id;
+	mask = retu_disable_bogus_irqs(mask);
+	retu_write_reg(RETU_REG_IMR, mask);
+	spin_unlock_irqrestore(&retu_lock, flags);
+}
+
+/*
+ * Enable given RETU interrupt
+ */
+void retu_enable_irq(int id)
+{
+	unsigned long flags;
+	u16 mask;
+
+	if (id == 3) {
+		printk("Enabling Retu IRQ %d\n", id);
+		dump_stack();
+	}
+	spin_lock_irqsave(&retu_lock, flags);
+	mask = retu_read_reg(RETU_REG_IMR);
+	mask &= ~(1 << id);
+	mask = retu_disable_bogus_irqs(mask);
+	retu_write_reg(RETU_REG_IMR, mask);
+	spin_unlock_irqrestore(&retu_lock, flags);
+}
+
+/*
+ * Acknowledge given RETU interrupt
+ */
+void retu_ack_irq(int id)
+{
+	retu_write_reg(RETU_REG_IDR, 1 << id);
+}
+
+/*
+ * RETU interrupt handler. Only schedules the tasklet.
+ */
+static irqreturn_t retu_irq_handler(int irq, void *dev_id)
+{
+	tasklet_schedule(&retu_tasklet);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Tasklet handler
+ */
+static void retu_tasklet_handler(unsigned long data)
+{
+	struct retu_irq_handler_desc *hnd;
+	u16 id;
+	u16 im;
+	int i;
+
+	for (;;) {
+		id = retu_read_reg(RETU_REG_IDR);
+		im = ~retu_read_reg(RETU_REG_IMR);
+		id &= im;
+
+		if (!id)
+			break;
+
+		for (i = 0; id != 0; i++, id >>= 1) {
+			if (!(id & 1))
+				continue;
+			hnd = &retu_irq_handlers[i];
+			if (hnd->func == NULL) {
+                               /* Spurious retu interrupt - disable and ack it */
+				printk(KERN_INFO "Spurious Retu interrupt "
+						 "(id %d)\n", i);
+				retu_disable_irq(i);
+				retu_ack_irq(i);
+				continue;
+			}
+			hnd->func(hnd->arg);
+			/*
+			 * Don't acknowledge the interrupt here
+			 * It must be done explicitly
+			 */
+		}
+	}
+}
+
+/*
+ * Register the handler for a given RETU interrupt source.
+ */
+int retu_request_irq(int id, void *irq_handler, unsigned long arg, char *name)
+{
+	struct retu_irq_handler_desc *hnd;
+
+	if (irq_handler == NULL || id >= MAX_RETU_IRQ_HANDLERS ||
+	    name == NULL) {
+		printk(KERN_ERR PFX "Invalid arguments to %s\n",
+		       __FUNCTION__);
+		return -EINVAL;
+	}
+	hnd = &retu_irq_handlers[id];
+	if (hnd->func != NULL) {
+		printk(KERN_ERR PFX "IRQ %d already reserved\n", id);
+		return -EBUSY;
+	}
+	printk(KERN_INFO PFX "Registering interrupt %d for device %s\n",
+	       id, name);
+	hnd->func = irq_handler;
+	hnd->arg = arg;
+	strlcpy(hnd->name, name, sizeof(hnd->name));
+
+	retu_ack_irq(id);
+	retu_enable_irq(id);
+
+	return 0;
+}
+
+/*
+ * Unregister the handler for a given RETU interrupt source.
+ */
+void retu_free_irq(int id)
+{
+	struct retu_irq_handler_desc *hnd;
+
+	if (id >= MAX_RETU_IRQ_HANDLERS) {
+		printk(KERN_ERR PFX "Invalid argument to %s\n",
+		       __FUNCTION__);
+		return;
+	}
+	hnd = &retu_irq_handlers[id];
+	if (hnd->func == NULL) {
+		printk(KERN_ERR PFX "IRQ %d already freed\n", id);
+		return;
+	}
+
+	retu_disable_irq(id);
+	hnd->func = NULL;
+}
+
+/**
+ * retu_power_off - Shut down power to system
+ *
+ * This function puts the system in power off state
+ */
+static void retu_power_off(void)
+{
+	/* Ignore power button state */
+	retu_write_reg(RETU_REG_CC1, retu_read_reg(RETU_REG_CC1) | 2);
+	/* Expire watchdog immediately */
+	retu_write_reg(RETU_REG_WATCHDOG, 0);
+	/* Wait for poweroff*/
+	for (;;);
+}
+
+/**
+ * retu_probe - Probe for Retu ASIC
+ * @dev: the Retu device
+ *
+ * Probe for the Retu ASIC and allocate memory
+ * for its device-struct if found
+ */
+static int __devinit retu_probe(struct device *dev)
+{
+	const struct omap_em_asic_bb5_config * em_asic_config;
+	int rev, ret;
+
+	/* Prepare tasklet */
+	tasklet_init(&retu_tasklet, retu_tasklet_handler, 0);
+
+	em_asic_config = omap_get_config(OMAP_TAG_EM_ASIC_BB5,
+					 struct omap_em_asic_bb5_config);
+	if (em_asic_config == NULL) {
+		printk(KERN_ERR PFX "Unable to retrieve config data\n");
+		return -ENODATA;
+	}
+
+	retu_irq_pin = em_asic_config->retu_irq_gpio;
+
+	if ((ret = gpio_request(retu_irq_pin, "RETU irq")) < 0) {
+		printk(KERN_ERR PFX "Unable to reserve IRQ GPIO\n");
+		return ret;
+	}
+
+	/* Set the pin as input */
+	gpio_direction_input(retu_irq_pin);
+
+	/* Rising edge triggers the IRQ */
+	set_irq_type(gpio_to_irq(retu_irq_pin), IRQ_TYPE_EDGE_RISING);
+
+	retu_initialized = 1;
+
+	rev = retu_read_reg(RETU_REG_ASICR) & 0xff;
+	if (rev & (1 << 7))
+		retu_is_vilma = 1;
+
+	printk(KERN_INFO "%s v%d.%d found\n", retu_is_vilma ? "Vilma" : "Retu",
+	       (rev >> 4) & 0x07, rev & 0x0f);
+
+	/* Mask all RETU interrupts */
+	retu_write_reg(RETU_REG_IMR, 0xffff);
+
+	ret = request_irq(gpio_to_irq(retu_irq_pin), retu_irq_handler, 0,
+			  "retu", 0);
+	if (ret < 0) {
+		printk(KERN_ERR PFX "Unable to register IRQ handler\n");
+		gpio_free(retu_irq_pin);
+		return ret;
+	}
+	set_irq_wake(gpio_to_irq(retu_irq_pin), 1);
+
+	/* Register power off function */
+	pm_power_off = retu_power_off;
+
+#ifdef CONFIG_CBUS_RETU_USER
+	/* Initialize user-space interface */
+	if (retu_user_init() < 0) {
+		printk(KERN_ERR "Unable to initialize driver\n");
+		free_irq(gpio_to_irq(retu_irq_pin), 0);
+		gpio_free(retu_irq_pin);
+		return ret;
+	}
+#endif
+
+	return 0;
+}
+
+static int retu_remove(struct device *dev)
+{
+#ifdef CONFIG_CBUS_RETU_USER
+	retu_user_cleanup();
+#endif
+	/* Mask all RETU interrupts */
+	retu_write_reg(RETU_REG_IMR, 0xffff);
+	free_irq(gpio_to_irq(retu_irq_pin), 0);
+	gpio_free(retu_irq_pin);
+	tasklet_kill(&retu_tasklet);
+
+	return 0;
+}
+
+static void retu_device_release(struct device *dev)
+{
+	complete(&device_release);
+}
+
+static struct device_driver retu_driver = {
+	.name		= "retu",
+	.bus		= &platform_bus_type,
+	.probe		= retu_probe,
+	.remove		= retu_remove,
+};
+
+static struct platform_device retu_device = {
+	.name		= "retu",
+	.id		= -1,
+	.dev = {
+		.release = retu_device_release,
+	}
+};
+
+/**
+ * retu_init - initialise Retu driver
+ *
+ * Initialise the Retu driver and return 0 if everything worked ok
+ */
+static int __init retu_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Retu/Vilma driver initialising\n");
+
+	init_completion(&device_release);
+
+	if ((ret = driver_register(&retu_driver)) < 0)
+		return ret;
+
+	if ((ret = platform_device_register(&retu_device)) < 0) {
+		driver_unregister(&retu_driver);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * Cleanup
+ */
+static void __exit retu_exit(void)
+{
+	platform_device_unregister(&retu_device);
+	driver_unregister(&retu_driver);
+	wait_for_completion(&device_release);
+}
+
+EXPORT_SYMBOL(retu_request_irq);
+EXPORT_SYMBOL(retu_free_irq);
+EXPORT_SYMBOL(retu_enable_irq);
+EXPORT_SYMBOL(retu_disable_irq);
+EXPORT_SYMBOL(retu_ack_irq);
+EXPORT_SYMBOL(retu_read_reg);
+EXPORT_SYMBOL(retu_write_reg);
+
+subsys_initcall(retu_init);
+module_exit(retu_exit);
+
+MODULE_DESCRIPTION("Retu ASIC control");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Juha Yrjl, David Weinehall, and Mikko Ylinen");
diff --git a/drivers/cbus/retu.h b/drivers/cbus/retu.h
new file mode 100644
index 0000000..c9e044c
--- /dev/null
+++ b/drivers/cbus/retu.h
@@ -0,0 +1,77 @@
+/**
+ * drivers/cbus/retu.h
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com> and
+ *	      David Weinehall <david.weinehall@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DRIVERS_CBUS_RETU_H
+#define __DRIVERS_CBUS_RETU_H
+
+#include <linux/types.h>
+
+/* Registers */
+#define RETU_REG_ASICR		0x00	/* ASIC ID & revision */
+#define RETU_REG_IDR		0x01	/* Interrupt ID */
+#define RETU_REG_IMR		0x02	/* Interrupt mask */
+#define RETU_REG_RTCDSR		0x03	/* RTC seconds register */
+#define RETU_REG_RTCHMR		0x04	/* RTC hours and minutes register */
+#define RETU_REG_RTCHMAR	0x05	/* RTC hours and minutes alarm and time set register */
+#define RETU_REG_RTCCALR	0x06	/* RTC calibration register */
+#define RETU_REG_ADCR		0x08	/* ADC result */
+#define RETU_REG_ADCSCR		0x09	/* ADC sample ctrl */
+#define RETU_REG_CC1		0x0d	/* Common control register 1 */
+#define RETU_REG_CC2		0x0e	/* Common control register 2 */
+#define RETU_REG_CTRL_CLR	0x0f	/* Regulator clear register */
+#define RETU_REG_CTRL_SET	0x10	/* Regulator set register */
+#define RETU_REG_STATUS		0x16	/* Status register */
+#define RETU_REG_WATCHDOG	0x17	/* Watchdog register */
+#define RETU_REG_AUDTXR		0x18	/* Audio Codec Tx register */
+#define RETU_REG_MAX		0x1f
+
+/* Interrupt sources */
+#define RETU_INT_PWR		0
+#define RETU_INT_CHAR		1
+#define RETU_INT_RTCS		2
+#define RETU_INT_RTCM		3
+#define RETU_INT_RTCD		4
+#define RETU_INT_RTCA		5
+#define RETU_INT_HOOK		6
+#define RETU_INT_HEAD		7
+#define RETU_INT_ADCS		8
+
+#define	MAX_RETU_IRQ_HANDLERS	16
+
+int retu_read_reg(int reg);
+void retu_write_reg(int reg, u16 val);
+void retu_set_clear_reg_bits(int reg, u16 set, u16 clear);
+int retu_read_adc(int channel);
+int retu_request_irq(int id, void *irq_handler, unsigned long arg, char *name);
+void retu_free_irq(int id);
+void retu_enable_irq(int id);
+void retu_disable_irq(int id);
+void retu_ack_irq(int id);
+
+#ifdef CONFIG_CBUS_RETU_USER
+int retu_user_init(void);
+void retu_user_cleanup(void);
+#endif
+
+extern spinlock_t retu_lock;
+
+#endif /* __DRIVERS_CBUS_RETU_H */
diff --git a/drivers/cbus/tahvo-usb.c b/drivers/cbus/tahvo-usb.c
new file mode 100644
index 0000000..d8ad836
--- /dev/null
+++ b/drivers/cbus/tahvo-usb.c
@@ -0,0 +1,777 @@
+/**
+ * drivers/cbus/tahvo-usb.c
+ *
+ * Tahvo USB transeiver
+ *
+ * Copyright (C) 2005-2006 Nokia Corporation
+ *
+ * Parts copied from drivers/i2c/chips/isp1301_omap.c
+ * Copyright (C) 2004 Texas Instruments
+ * Copyright (C) 2004 David Brownell
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com>,
+ *	      Tony Lindgren <tony@atomide.com>, and
+ *	      Timo Ters <timo.teras@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/kobject.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <asm/irq.h>
+#include <mach/usb.h>
+
+#include "cbus.h"
+#include "tahvo.h"
+
+#define DRIVER_NAME     "tahvo-usb"
+
+#define USBR_SLAVE_CONTROL	(1 << 8)
+#define USBR_VPPVIO_SW		(1 << 7)
+#define USBR_SPEED		(1 << 6)
+#define USBR_REGOUT		(1 << 5)
+#define USBR_MASTER_SW2		(1 << 4)
+#define USBR_MASTER_SW1		(1 << 3)
+#define USBR_SLAVE_SW		(1 << 2)
+#define USBR_NSUSPEND		(1 << 1)
+#define USBR_SEMODE		(1 << 0)
+
+/* bits in OTG_CTRL */
+
+/* Bits that are controlled by OMAP OTG and are read-only */
+#define OTG_CTRL_OMAP_MASK	(OTG_PULLDOWN|OTG_PULLUP|OTG_DRV_VBUS|\
+				OTG_PD_VBUS|OTG_PU_VBUS|OTG_PU_ID)
+/* Bits that are controlled by transceiver */
+#define OTG_CTRL_XCVR_MASK	(OTG_ASESSVLD|OTG_BSESSEND|\
+				OTG_BSESSVLD|OTG_VBUSVLD|OTG_ID)
+/* Bits that are controlled by system */
+#define OTG_CTRL_SYS_MASK	(OTG_A_BUSREQ|OTG_A_SETB_HNPEN|OTG_B_BUSREQ|\
+				OTG_B_HNPEN|OTG_BUSDROP)
+
+#if defined(CONFIG_USB_OHCI_HCD) && !defined(CONFIG_USB_OTG)
+#error tahvo-otg.c does not work with OCHI yet!
+#endif
+
+#define TAHVO_MODE_HOST		0
+#define TAHVO_MODE_PERIPHERAL	1
+
+#ifdef CONFIG_USB_OTG
+#define TAHVO_MODE(tu)		(tu)->tahvo_mode
+#elif defined(CONFIG_USB_GADGET_OMAP)
+#define TAHVO_MODE(tu)		TAHVO_MODE_PERIPHERAL
+#else
+#define TAHVO_MODE(tu)		TAHVO_MODE_HOST
+#endif
+
+struct tahvo_usb {
+	struct platform_device *pt_dev;
+	struct otg_transceiver otg;
+	int vbus_state;
+	struct work_struct irq_work;
+	struct mutex serialize;
+#ifdef CONFIG_USB_OTG
+	int tahvo_mode;
+#endif
+};
+static struct platform_device tahvo_usb_device;
+
+/*
+ * ---------------------------------------------------------------------------
+ * OTG related functions
+ *
+ * These shoud be separated into omap-otg.c driver module, as they are used
+ * by various transceivers. These functions are needed in the UDC-only case
+ * as well. These functions are copied from GPL isp1301_omap.c
+ * ---------------------------------------------------------------------------
+ */
+static struct platform_device *tahvo_otg_dev;
+
+static irqreturn_t omap_otg_irq(int irq, void *arg)
+{
+	struct platform_device *otg_dev = (struct platform_device *) arg;
+	struct tahvo_usb *tu = (struct tahvo_usb *) otg_dev->dev.driver_data;
+	u16 otg_irq;
+
+	otg_irq = omap_readw(OTG_IRQ_SRC);
+	if (otg_irq & OPRT_CHG) {
+		omap_writew(OPRT_CHG, OTG_IRQ_SRC);
+	} else if (otg_irq & B_SRP_TMROUT) {
+		omap_writew(B_SRP_TMROUT, OTG_IRQ_SRC);
+	} else if (otg_irq & B_HNP_FAIL) {
+		omap_writew(B_HNP_FAIL, OTG_IRQ_SRC);
+	} else if (otg_irq & A_SRP_DETECT) {
+		omap_writew(A_SRP_DETECT, OTG_IRQ_SRC);
+	} else if (otg_irq & A_REQ_TMROUT) {
+		omap_writew(A_REQ_TMROUT, OTG_IRQ_SRC);
+	} else if (otg_irq & A_VBUS_ERR) {
+		omap_writew(A_VBUS_ERR, OTG_IRQ_SRC);
+	} else if (otg_irq & DRIVER_SWITCH) {
+		if ((!(omap_readl(OTG_CTRL) & OTG_DRIVER_SEL)) &&
+		   tu->otg.host && tu->otg.state == OTG_STATE_A_HOST) {
+			/* role is host */
+			usb_bus_start_enum(tu->otg.host,
+					   tu->otg.host->otg_port);
+		}
+		omap_writew(DRIVER_SWITCH, OTG_IRQ_SRC);
+	} else
+		return IRQ_NONE;
+
+	return IRQ_HANDLED;
+
+}
+
+static int omap_otg_init(void)
+{
+	u32 l;
+
+#ifdef CONFIG_USB_OTG
+	if (!tahvo_otg_dev) {
+		printk("tahvo-usb: no tahvo_otg_dev\n");
+		return -ENODEV;
+	}
+#endif
+
+	l = omap_readl(OTG_SYSCON_1);
+	l &= ~OTG_IDLE_EN;
+	omap_writel(l, OTG_SYSCON_1);
+	udelay(100);
+
+	/* some of these values are board-specific... */
+	l = omap_readl(OTG_SYSCON_2);
+	l |= OTG_EN
+		/* for B-device: */
+		| SRP_GPDATA		/* 9msec Bdev D+ pulse */
+		| SRP_GPDVBUS		/* discharge after VBUS pulse */
+		// | (3 << 24)		/* 2msec VBUS pulse */
+		/* for A-device: */
+		| (0 << 20)		/* 200ms nominal A_WAIT_VRISE timer */
+		| SRP_DPW		/* detect 167+ns SRP pulses */
+		| SRP_DATA | SRP_VBUS;	/* accept both kinds of SRP pulse */
+	omap_writel(l, OTG_SYSCON_2);
+
+	omap_writew(DRIVER_SWITCH | OPRT_CHG
+			| B_SRP_TMROUT | B_HNP_FAIL
+				  | A_VBUS_ERR | A_SRP_DETECT | A_REQ_TMROUT,
+					OTG_IRQ_EN);
+	l = omap_readl(OTG_SYSCON_2);
+	l |= OTG_EN;
+	omap_writel(l, OTG_SYSCON_2);
+
+	return 0;
+}
+
+static int omap_otg_probe(struct device *dev)
+{
+	int ret;
+
+	tahvo_otg_dev = to_platform_device(dev);
+	ret = omap_otg_init();
+	if (ret != 0) {
+		printk(KERN_ERR "tahvo-usb: omap_otg_init failed\n");
+		return ret;
+	}
+
+	return request_irq(tahvo_otg_dev->resource[1].start,
+			   omap_otg_irq, IRQF_DISABLED, DRIVER_NAME,
+			   &tahvo_usb_device);
+}
+
+static int omap_otg_remove(struct device *dev)
+{
+	free_irq(tahvo_otg_dev->resource[1].start, &tahvo_usb_device);
+	tahvo_otg_dev = NULL;
+
+	return 0;
+}
+
+struct device_driver omap_otg_driver = {
+	.name		= "omap_otg",
+	.bus		= &platform_bus_type,
+	.probe		= omap_otg_probe,
+	.remove		= omap_otg_remove,
+};
+
+/*
+ * ---------------------------------------------------------------------------
+ * Tahvo related functions
+ * These are Nokia proprietary code, except for the OTG register settings,
+ * which are copied from isp1301.c
+ * ---------------------------------------------------------------------------
+ */
+static ssize_t vbus_state_show(struct device *device,
+			       struct device_attribute *attr, char *buf)
+{
+	struct tahvo_usb *tu = (struct tahvo_usb*) device->driver_data;
+	return sprintf(buf, "%d\n", tu->vbus_state);
+}
+static DEVICE_ATTR(vbus_state, 0444, vbus_state_show, NULL);
+
+int vbus_active = 0;
+
+#if 0
+
+static int host_suspend(struct tahvo_usb *tu)
+{
+	struct device	*dev;
+
+	if (!tu->otg.host)
+		return -ENODEV;
+
+	/* Currently ASSUMES only the OTG port matters;
+	 * other ports could be active...
+	 */
+	dev = tu->otg.host->controller;
+	return dev->driver->suspend(dev, PMSG_SUSPEND);
+}
+
+static int host_resume(struct tahvo_usb *tu)
+{
+	struct device	*dev;
+
+	if (!tu->otg.host)
+		return -ENODEV;
+
+	dev = tu->otg.host->controller;
+	return dev->driver->resume(dev);
+}
+
+#else
+
+static int host_suspend(struct tahvo_usb *tu)
+{
+	return 0;
+}
+
+static int host_resume(struct tahvo_usb *tu)
+{
+	return 0;
+}
+
+#endif
+
+static void check_vbus_state(struct tahvo_usb *tu)
+{
+	int reg, prev_state;
+
+	reg = tahvo_read_reg(TAHVO_REG_IDSR);
+	if (reg & 0x01) {
+		u32 l;
+
+		vbus_active = 1;
+		switch (tu->otg.state) {
+		case OTG_STATE_B_IDLE:
+			/* Enable the gadget driver */
+			if (tu->otg.gadget)
+				usb_gadget_vbus_connect(tu->otg.gadget);
+			/* Set B-session valid and not B-sessio ended to indicate
+			 * Vbus to be ok. */
+			l = omap_readl(OTG_CTRL);
+			l &= ~OTG_BSESSEND;
+			l |= OTG_BSESSVLD;
+			omap_writel(l, OTG_CTRL);
+
+			tu->otg.state = OTG_STATE_B_PERIPHERAL;
+			break;
+		case OTG_STATE_A_IDLE:
+			/* Session is now valid assuming the USB hub is driving Vbus */
+			tu->otg.state = OTG_STATE_A_HOST;
+			host_resume(tu);
+			break;
+		default:
+			break;
+		}
+		printk("USB cable connected\n");
+	} else {
+		switch (tu->otg.state) {
+		case OTG_STATE_B_PERIPHERAL:
+			if (tu->otg.gadget)
+				usb_gadget_vbus_disconnect(tu->otg.gadget);
+			tu->otg.state = OTG_STATE_B_IDLE;
+			break;
+		case OTG_STATE_A_HOST:
+			tu->otg.state = OTG_STATE_A_IDLE;
+			break;
+		default:
+			break;
+		}
+		printk("USB cable disconnected\n");
+		vbus_active = 0;
+	}
+
+	prev_state = tu->vbus_state;
+	tu->vbus_state = reg & 0x01;
+	if (prev_state != tu->vbus_state)
+		sysfs_notify(&tu->pt_dev->dev.kobj, NULL, "vbus_state");
+}
+
+static void tahvo_usb_become_host(struct tahvo_usb *tu)
+{
+	u32 l;
+
+	/* Clear system and transceiver controlled bits
+	 * also mark the A-session is always valid */
+	omap_otg_init();
+
+	l = omap_readl(OTG_CTRL);
+	l &= ~(OTG_CTRL_XCVR_MASK | OTG_CTRL_SYS_MASK);
+	l |= OTG_ASESSVLD;
+	omap_writel(l, OTG_CTRL);
+
+	/* Power up the transceiver in USB host mode */
+	tahvo_write_reg(TAHVO_REG_USBR, USBR_REGOUT | USBR_NSUSPEND |
+			USBR_MASTER_SW2 | USBR_MASTER_SW1);
+	tu->otg.state = OTG_STATE_A_IDLE;
+
+	check_vbus_state(tu);
+}
+
+static void tahvo_usb_stop_host(struct tahvo_usb *tu)
+{
+	host_suspend(tu);
+	tu->otg.state = OTG_STATE_A_IDLE;
+}
+
+static void tahvo_usb_become_peripheral(struct tahvo_usb *tu)
+{
+	u32 l;
+
+	/* Clear system and transceiver controlled bits
+	 * and enable ID to mark peripheral mode and
+	 * BSESSEND to mark no Vbus */
+	omap_otg_init();
+	l = omap_readl(OTG_CTRL);
+	l &= ~(OTG_CTRL_XCVR_MASK | OTG_CTRL_SYS_MASK | OTG_BSESSVLD);
+	l |= OTG_ID | OTG_BSESSEND;
+	omap_writel(l, OTG_CTRL);
+
+	/* Power up transceiver and set it in USB perhiperal mode */
+	tahvo_write_reg(TAHVO_REG_USBR, USBR_SLAVE_CONTROL | USBR_REGOUT | USBR_NSUSPEND | USBR_SLAVE_SW);
+	tu->otg.state = OTG_STATE_B_IDLE;
+
+	check_vbus_state(tu);
+}
+
+static void tahvo_usb_stop_peripheral(struct tahvo_usb *tu)
+{
+	u32 l;
+
+	l = omap_readl(OTG_CTRL);
+	l &= ~OTG_BSESSVLD;
+	l |= OTG_BSESSEND;
+	omap_writel(l, OTG_CTRL);
+
+	if (tu->otg.gadget)
+		usb_gadget_vbus_disconnect(tu->otg.gadget);
+	tu->otg.state = OTG_STATE_B_IDLE;
+
+}
+
+static void tahvo_usb_power_off(struct tahvo_usb *tu)
+{
+	u32 l;
+	int id;
+
+	/* Disable gadget controller if any */
+	if (tu->otg.gadget)
+		usb_gadget_vbus_disconnect(tu->otg.gadget);
+
+	host_suspend(tu);
+
+	/* Disable OTG and interrupts */
+	if (TAHVO_MODE(tu) == TAHVO_MODE_PERIPHERAL)
+		id = OTG_ID;
+	else
+		id = 0;
+	l = omap_readl(OTG_CTRL);
+	l &= ~(OTG_CTRL_XCVR_MASK | OTG_CTRL_SYS_MASK | OTG_BSESSVLD);
+	l |= id | OTG_BSESSEND;
+	omap_writel(l, OTG_CTRL);
+	omap_writew(0, OTG_IRQ_EN);
+
+	l = omap_readl(OTG_SYSCON_2);
+	l &= ~OTG_EN;
+	omap_writel(l, OTG_SYSCON_2);
+
+	l = omap_readl(OTG_SYSCON_1);
+	l |= OTG_IDLE_EN;
+	omap_writel(l, OTG_SYSCON_1);
+
+	/* Power off transceiver */
+	tahvo_write_reg(TAHVO_REG_USBR, 0);
+	tu->otg.state = OTG_STATE_UNDEFINED;
+}
+
+
+static int tahvo_usb_set_power(struct otg_transceiver *dev, unsigned mA)
+{
+	struct tahvo_usb *tu = container_of(dev, struct tahvo_usb, otg);
+
+	dev_dbg(&tu->pt_dev->dev, "set_power %d mA\n", mA);
+
+	if (dev->state == OTG_STATE_B_PERIPHERAL) {
+		/* REVISIT: Can Tahvo charge battery from VBUS? */
+	}
+	return 0;
+}
+
+static int tahvo_usb_set_suspend(struct otg_transceiver *dev, int suspend)
+{
+	struct tahvo_usb *tu = container_of(dev, struct tahvo_usb, otg);
+	u16 w;
+
+	dev_dbg(&tu->pt_dev->dev, "set_suspend\n");
+
+	w = tahvo_read_reg(TAHVO_REG_USBR);
+	if (suspend)
+		w &= ~USBR_NSUSPEND;
+	else
+		w |= USBR_NSUSPEND;
+	tahvo_write_reg(TAHVO_REG_USBR, w);
+
+	return 0;
+}
+
+static int tahvo_usb_start_srp(struct otg_transceiver *dev)
+{
+	struct tahvo_usb *tu = container_of(dev, struct tahvo_usb, otg);
+	u32 otg_ctrl;
+
+	dev_dbg(&tu->pt_dev->dev, "start_srp\n");
+
+	if (!dev || tu->otg.state != OTG_STATE_B_IDLE)
+		return -ENODEV;
+
+	otg_ctrl = omap_readl(OTG_CTRL);
+	if (!(otg_ctrl & OTG_BSESSEND))
+		return -EINVAL;
+
+	otg_ctrl |= OTG_B_BUSREQ;
+	otg_ctrl &= ~OTG_A_BUSREQ & OTG_CTRL_SYS_MASK;
+	omap_writel(otg_ctrl, OTG_CTRL);
+	tu->otg.state = OTG_STATE_B_SRP_INIT;
+
+	return 0;
+}
+
+static int tahvo_usb_start_hnp(struct otg_transceiver *otg)
+{
+	struct tahvo_usb *tu = container_of(otg, struct tahvo_usb, otg);
+
+	dev_dbg(&tu->pt_dev->dev, "start_hnp\n");
+#ifdef CONFIG_USB_OTG
+	/* REVISIT: Add this for OTG */
+#endif
+	return -EINVAL;
+}
+
+static int tahvo_usb_set_host(struct otg_transceiver *otg, struct usb_bus *host)
+{
+	struct tahvo_usb *tu = container_of(otg, struct tahvo_usb, otg);
+	u32 l;
+
+	dev_dbg(&tu->pt_dev->dev, "set_host %p\n", host);
+
+	if (otg == NULL)
+		return -ENODEV;
+
+#if defined(CONFIG_USB_OTG) || !defined(CONFIG_USB_GADGET_OMAP)
+
+	mutex_lock(&tu->serialize);
+
+	if (host == NULL) {
+		if (TAHVO_MODE(tu) == TAHVO_MODE_HOST)
+			tahvo_usb_power_off(tu);
+		tu->otg.host = NULL;
+		mutex_unlock(&tu->serialize);
+		return 0;
+	}
+
+	l = omap_readl(OTG_SYSCON_1);
+	l &= ~(OTG_IDLE_EN | HST_IDLE_EN | DEV_IDLE_EN);
+	omap_writel(l, OTG_SYSCON_1);
+
+	if (TAHVO_MODE(tu) == TAHVO_MODE_HOST) {
+		tu->otg.host = NULL;
+		tahvo_usb_become_host(tu);
+	} else
+		host_suspend(tu);
+
+	tu->otg.host = host;
+
+	mutex_unlock(&tu->serialize);
+#else
+	/* No host mode configured, so do not allow host controlled to be set */
+	return -EINVAL;
+#endif
+
+	return 0;
+}
+
+static int tahvo_usb_set_peripheral(struct otg_transceiver *otg, struct usb_gadget *gadget)
+{
+	struct tahvo_usb *tu = container_of(otg, struct tahvo_usb, otg);
+
+	dev_dbg(&tu->pt_dev->dev, "set_peripheral %p\n", gadget);
+
+	if (!otg)
+		return -ENODEV;
+
+#if defined(CONFIG_USB_OTG) || defined(CONFIG_USB_GADGET_OMAP)
+
+	mutex_lock(&tu->serialize);
+
+	if (!gadget) {
+		if (TAHVO_MODE(tu) == TAHVO_MODE_PERIPHERAL)
+			tahvo_usb_power_off(tu);
+		tu->otg.gadget = NULL;
+		mutex_unlock(&tu->serialize);
+		return 0;
+	}
+
+	tu->otg.gadget = gadget;
+	if (TAHVO_MODE(tu) == TAHVO_MODE_PERIPHERAL)
+		tahvo_usb_become_peripheral(tu);
+
+	mutex_unlock(&tu->serialize);
+#else
+	/* No gadget mode configured, so do not allow host controlled to be set */
+	return -EINVAL;
+#endif
+
+	return 0;
+}
+
+static void tahvo_usb_irq_work(struct work_struct *work)
+{
+	struct tahvo_usb *tu = container_of(work, struct tahvo_usb, irq_work);
+
+	mutex_lock(&tu->serialize);
+	check_vbus_state(tu);
+	mutex_unlock(&tu->serialize);
+}
+
+static void tahvo_usb_vbus_interrupt(unsigned long arg)
+{
+	struct tahvo_usb *tu = (struct tahvo_usb *) arg;
+
+	tahvo_ack_irq(TAHVO_INT_VBUSON);
+	/* Seems we need this to acknowledge the interrupt */
+	tahvo_read_reg(TAHVO_REG_IDSR);
+	schedule_work(&tu->irq_work);
+}
+
+#ifdef CONFIG_USB_OTG
+static ssize_t otg_mode_show(struct device *device,
+			     struct device_attribute *attr, char *buf)
+{
+	struct tahvo_usb *tu = (struct tahvo_usb*) device->driver_data;
+	switch (tu->tahvo_mode) {
+	case TAHVO_MODE_HOST:
+		return sprintf(buf, "host\n");
+	case TAHVO_MODE_PERIPHERAL:
+		return sprintf(buf, "peripheral\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t otg_mode_store(struct device *device,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct tahvo_usb *tu = (struct tahvo_usb*) device->driver_data;
+	int r;
+
+	r = strlen(buf);
+	mutex_lock(&tu->serialize);
+	if (strncmp(buf, "host", 4) == 0) {
+		if (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)
+			tahvo_usb_stop_peripheral(tu);
+		tu->tahvo_mode = TAHVO_MODE_HOST;
+		if (tu->otg.host) {
+			printk(KERN_INFO "Selected HOST mode: host controller present.\n");
+			tahvo_usb_become_host(tu);
+		} else {
+			printk(KERN_INFO "Selected HOST mode: no host controller, powering off.\n");
+			tahvo_usb_power_off(tu);
+		}
+	} else if (strncmp(buf, "peripheral", 10) == 0) {
+		if (tu->tahvo_mode == TAHVO_MODE_HOST)
+			tahvo_usb_stop_host(tu);
+		tu->tahvo_mode = TAHVO_MODE_PERIPHERAL;
+		if (tu->otg.gadget) {
+			printk(KERN_INFO "Selected PERIPHERAL mode: gadget driver present.\n");
+			tahvo_usb_become_peripheral(tu);
+		} else {
+			printk(KERN_INFO "Selected PERIPHERAL mode: no gadget driver, powering off.\n");
+			tahvo_usb_power_off(tu);
+		}
+	} else
+		r = -EINVAL;
+
+	mutex_unlock(&tu->serialize);
+	return r;
+}
+
+static DEVICE_ATTR(otg_mode, 0644, otg_mode_show, otg_mode_store);
+#endif
+
+static int tahvo_usb_probe(struct device *dev)
+{
+	struct tahvo_usb *tu;
+	int ret;
+
+	dev_dbg(dev, "probe\n");
+
+	/* Create driver data */
+	tu = kmalloc(sizeof(*tu), GFP_KERNEL);
+	if (!tu)
+		return -ENOMEM;
+	memset(tu, 0, sizeof(*tu));
+	tu->pt_dev = container_of(dev, struct platform_device, dev);
+#ifdef CONFIG_USB_OTG
+	/* Default mode */
+#ifdef CONFIG_CBUS_TAHVO_USB_HOST_BY_DEFAULT
+	tu->tahvo_mode = TAHVO_MODE_HOST;
+#else
+	tu->tahvo_mode = TAHVO_MODE_PERIPHERAL;
+#endif
+#endif
+
+	INIT_WORK(&tu->irq_work, tahvo_usb_irq_work);
+	mutex_init(&tu->serialize);
+
+	/* Set initial state, so that we generate kevents only on
+	 * state changes */
+	tu->vbus_state = tahvo_read_reg(TAHVO_REG_IDSR) & 0x01;
+
+	/* We cannot enable interrupt until omap_udc is initialized */
+	ret = tahvo_request_irq(TAHVO_INT_VBUSON, tahvo_usb_vbus_interrupt,
+				(unsigned long) tu, "vbus_interrupt");
+	if (ret != 0) {
+		kfree(tu);
+		printk(KERN_ERR "Could not register Tahvo interrupt for VBUS\n");
+		return ret;
+	}
+
+	/* Attributes */
+	ret = device_create_file(dev, &dev_attr_vbus_state);
+#ifdef CONFIG_USB_OTG
+	ret |= device_create_file(dev, &dev_attr_otg_mode);
+#endif
+	if (ret)
+		printk(KERN_ERR "attribute creation failed: %d\n", ret);
+
+	/* Create OTG interface */
+	tahvo_usb_power_off(tu);
+	tu->otg.state = OTG_STATE_UNDEFINED;
+	tu->otg.label = DRIVER_NAME;
+	tu->otg.set_host = tahvo_usb_set_host;
+	tu->otg.set_peripheral = tahvo_usb_set_peripheral;
+	tu->otg.set_power = tahvo_usb_set_power;
+	tu->otg.set_suspend = tahvo_usb_set_suspend;
+	tu->otg.start_srp = tahvo_usb_start_srp;
+	tu->otg.start_hnp = tahvo_usb_start_hnp;
+
+	ret = otg_set_transceiver(&tu->otg);
+	if (ret < 0) {
+		printk(KERN_ERR "Cannot register USB transceiver\n");
+		kfree(tu);
+		tahvo_free_irq(TAHVO_INT_VBUSON);
+		return ret;
+	}
+
+	dev->driver_data = tu;
+
+	/* Act upon current vbus state once at startup. A vbus state irq may or
+	 * may not be generated in addition to this. */
+	schedule_work(&tu->irq_work);
+	return 0;
+}
+
+static int tahvo_usb_remove(struct device *dev)
+{
+	dev_dbg(dev, "remove\n");
+
+	tahvo_free_irq(TAHVO_INT_VBUSON);
+	flush_scheduled_work();
+	otg_set_transceiver(0);
+	device_remove_file(dev, &dev_attr_vbus_state);
+#ifdef CONFIG_USB_OTG
+	device_remove_file(dev, &dev_attr_otg_mode);
+#endif
+	return 0;
+}
+
+static struct device_driver tahvo_usb_driver = {
+	.name		= "tahvo-usb",
+	.bus		= &platform_bus_type,
+	.probe		= tahvo_usb_probe,
+	.remove		= tahvo_usb_remove,
+};
+
+static struct platform_device tahvo_usb_device = {
+	.name		= "tahvo-usb",
+	.id		= -1,
+};
+
+static int __init tahvo_usb_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Tahvo USB transceiver driver initializing\n");
+	ret = driver_register(&tahvo_usb_driver);
+	if (ret)
+		return ret;
+	ret = platform_device_register(&tahvo_usb_device);
+	if (ret < 0) {
+		driver_unregister(&tahvo_usb_driver);
+		return ret;
+	}
+	ret = driver_register(&omap_otg_driver);
+	if (ret) {
+		platform_device_unregister(&tahvo_usb_device);
+		driver_unregister(&tahvo_usb_driver);
+		return ret;
+	}
+	return 0;
+}
+
+subsys_initcall(tahvo_usb_init);
+
+static void __exit tahvo_usb_exit(void)
+{
+	driver_unregister(&omap_otg_driver);
+	platform_device_unregister(&tahvo_usb_device);
+	driver_unregister(&tahvo_usb_driver);
+}
+module_exit(tahvo_usb_exit);
+
+MODULE_DESCRIPTION("Tahvo USB OTG Transceiver Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Juha Yrjl, Tony Lindgren, and Timo Ters");
diff --git a/drivers/cbus/tahvo-user.c b/drivers/cbus/tahvo-user.c
new file mode 100644
index 0000000..873d648
--- /dev/null
+++ b/drivers/cbus/tahvo-user.c
@@ -0,0 +1,405 @@
+/**
+ * drivers/cbus/tahvo-user.c
+ *
+ * Tahvo user space interface functions
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+
+#include <asm/uaccess.h>
+
+#include "tahvo.h"
+
+#include "user_retu_tahvo.h"
+
+/* Maximum size of IRQ node buffer/pool */
+#define TAHVO_MAX_IRQ_BUF_LEN	16
+
+#define PFX			"tahvo-user: "
+
+/* Bitmap for marking the interrupt sources as having the handlers */
+static u32 tahvo_irq_bits;
+
+/* For allowing only one user process to subscribe to the tahvo interrupts */
+static struct file *tahvo_irq_subscr = NULL;
+
+/* For poll and IRQ passing */
+struct tahvo_irq {
+	u32 id;
+	struct list_head node;
+};
+
+static spinlock_t tahvo_irqs_lock;
+static struct tahvo_irq *tahvo_irq_block;
+static LIST_HEAD(tahvo_irqs);
+static LIST_HEAD(tahvo_irqs_reserve);
+
+/* Wait queue - used when user wants to read the device */
+DECLARE_WAIT_QUEUE_HEAD(tahvo_user_waitqueue);
+
+/* Semaphore to protect irq subscription sequence */
+static struct mutex tahvo_mutex;
+
+/* This array specifies TAHVO register types (read/write/toggle) */
+static const u8 tahvo_access_bits[] = {
+	1,
+	4,
+	1,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	3,
+	1
+};
+
+/*
+ * The handler for all TAHVO interrupts.
+ *
+ * arg is the interrupt source in TAHVO.
+ */
+static void tahvo_user_irq_handler(unsigned long arg)
+{
+	struct tahvo_irq *irq;
+
+	/* user has to re-enable the interrupt once ready
+	 * for receiving them again */
+	tahvo_disable_irq(arg);
+	tahvo_ack_irq(arg);
+
+	spin_lock(&tahvo_irqs_lock);
+	if (list_empty(&tahvo_irqs_reserve)) {
+		spin_unlock(&tahvo_irqs_lock);
+		return;
+	}
+	irq = list_entry((&tahvo_irqs_reserve)->next, struct tahvo_irq, node);
+	irq->id = arg;
+	list_move_tail(&irq->node, &tahvo_irqs);
+	spin_unlock(&tahvo_irqs_lock);
+
+	/* wake up waiting thread */
+	wake_up(&tahvo_user_waitqueue);
+}
+
+/*
+ * This routine sets up the interrupt handler and marks an interrupt source
+ * in TAHVO as a candidate for signal delivery to the user process.
+ */
+static int tahvo_user_subscribe_to_irq(int id, struct file *filp)
+{
+	int ret;
+
+	mutex_lock(&tahvo_mutex);
+	if ((tahvo_irq_subscr != NULL) && (tahvo_irq_subscr != filp)) {
+		mutex_unlock(&tahvo_mutex);
+		return -EBUSY;
+	}
+	/* Store the file pointer of the first user process registering IRQs */
+	tahvo_irq_subscr = filp;
+	mutex_unlock(&tahvo_mutex);
+
+	if (tahvo_irq_bits & (1 << id))
+		return 0;
+
+	ret = tahvo_request_irq(id, tahvo_user_irq_handler, id, "");
+	if (ret < 0)
+		return ret;
+
+	/* Mark that this interrupt has a handler */
+	tahvo_irq_bits |= 1 << id;
+
+	return 0;
+}
+
+/*
+ * Unregister all TAHVO interrupt handlers
+ */
+static void tahvo_unreg_irq_handlers(void)
+{
+	int id;
+
+	if (!tahvo_irq_bits)
+		return;
+
+	for (id = 0; id < MAX_TAHVO_IRQ_HANDLERS; id++)
+		if (tahvo_irq_bits & (1 << id))
+			tahvo_free_irq(id);
+
+	tahvo_irq_bits = 0;
+}
+
+/*
+ * Write to TAHVO register.
+ * Returns 0 upon success, a negative error value otherwise.
+ */
+static int tahvo_user_write_with_mask(u32 field, u16 value)
+{
+	u32 mask;
+	u32 reg;
+	u_short tmp;
+	unsigned long flags;
+
+	mask = MASK(field);
+	reg = REG(field);
+
+	/* Detect bad mask and reg */
+	if (mask == 0 || reg > TAHVO_REG_MAX ||
+	    tahvo_access_bits[reg] == READ_ONLY) {
+		printk(KERN_ERR PFX "invalid arguments (reg=%#x, mask=%#x)\n",
+		       reg, mask);
+		return -EINVAL;
+	}
+
+	/* Justify value according to mask */
+	while (!(mask & 1)) {
+		value = value << 1;
+		mask = mask >> 1;
+	}
+
+	spin_lock_irqsave(&tahvo_lock, flags);
+	if (tahvo_access_bits[reg] == TOGGLE) {
+		/* No need to detect previous content of register */
+		tmp = 0;
+	} else {
+		/* Read current value of register */
+		tmp = tahvo_read_reg(reg);
+	}
+	/* Generate a new value */
+	tmp = (tmp & ~MASK(field)) | (value & MASK(field));
+	/* Write data to TAHVO */
+	tahvo_write_reg(reg, tmp);
+	spin_unlock_irqrestore(&tahvo_lock, flags);
+
+	return 0;
+}
+
+/*
+ * Read TAHVO register.
+ */
+static u32 tahvo_user_read_with_mask(u32 field)
+{
+	u_short value;
+	u32 mask, reg;
+
+	mask = MASK(field);
+	reg = REG(field);
+
+	/* Detect bad mask and reg */
+	if (mask == 0 || reg > TAHVO_REG_MAX) {
+		printk(KERN_ERR PFX "invalid arguments (reg=%#x, mask=%#x)\n",
+		       reg, mask);
+		return -EINVAL;
+	}
+
+	/* Read the register */
+	value = tahvo_read_reg(reg) & mask;
+
+	/* Right justify value */
+	while (!(mask & 1)) {
+		value = value >> 1;
+		mask = mask >> 1;
+	}
+
+	return value;
+}
+
+/*
+ * Close device
+ */
+static int tahvo_close(struct inode *inode, struct file *filp)
+{
+	/* Unregister all interrupts that have been registered */
+	if (tahvo_irq_subscr == filp) {
+		tahvo_unreg_irq_handlers();
+		tahvo_irq_subscr = NULL;
+	}
+
+	return 0;
+}
+
+/*
+ * Device control (ioctl)
+ */
+static int tahvo_ioctl(struct inode *inode, struct file *filp,
+		       unsigned int cmd, unsigned long arg)
+{
+	struct retu_tahvo_write_parms par;
+	int ret;
+
+	switch (cmd) {
+	case URT_IOCT_IRQ_SUBSCR:
+		return tahvo_user_subscribe_to_irq(arg, filp);
+	case TAHVO_IOCH_READ:
+		return tahvo_user_read_with_mask(arg);
+	case TAHVO_IOCX_WRITE:
+		ret = copy_from_user(&par, (void __user *) arg, sizeof(par));
+		if (ret)
+			printk(KERN_ERR "copy_from_user failed: %d\n", ret);
+		par.result = tahvo_user_write_with_mask(par.field, par.value);
+		ret = copy_to_user((void __user *) arg, &par, sizeof(par));
+		if (ret)
+			printk(KERN_ERR "copy_to_user failed: %d\n", ret);
+		break;
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+/*
+ * Read from device
+ */
+static ssize_t tahvo_read(struct file *filp, char *buf, size_t count,
+			  loff_t * offp)
+{
+	struct tahvo_irq *irq;
+
+	u32 nr, i;
+
+	/* read not permitted if neither filp nor anyone has registered IRQs */
+	if (tahvo_irq_subscr != filp)
+		return -EPERM;
+
+	if ((count < sizeof(u32)) || ((count % sizeof(u32)) != 0))
+		return -EINVAL;
+
+	nr = count / sizeof(u32);
+
+	for (i = 0; i < nr; i++) {
+		unsigned long flags;
+		u32 irq_id;
+		int ret;
+
+		ret = wait_event_interruptible(tahvo_user_waitqueue,
+					       !list_empty(&tahvo_irqs));
+		if (ret < 0)
+			return ret;
+
+		spin_lock_irqsave(&tahvo_irqs_lock, flags);
+		irq = list_entry((&tahvo_irqs)->next, struct tahvo_irq, node);
+		irq_id = irq->id;
+		list_move(&irq->node, &tahvo_irqs_reserve);
+		spin_unlock_irqrestore(&tahvo_irqs_lock, flags);
+
+		ret = copy_to_user(buf + i * sizeof(irq_id), &irq_id,
+                                  sizeof(irq_id));
+		if (ret)
+			printk(KERN_ERR "copy_to_user failed: %d\n", ret);
+	}
+
+	return count;
+}
+
+/*
+ * Poll method
+ */
+static unsigned tahvo_poll(struct file *filp, struct poll_table_struct *pt)
+{
+	if (!list_empty(&tahvo_irqs))
+		return POLLIN;
+
+	poll_wait(filp, &tahvo_user_waitqueue, pt);
+
+	if (!list_empty(&tahvo_irqs))
+		return POLLIN;
+	else
+		return 0;
+}
+
+static struct file_operations tahvo_user_fileops = {
+	.owner = THIS_MODULE,
+	.ioctl = tahvo_ioctl,
+	.read = tahvo_read,
+	.release = tahvo_close,
+	.poll = tahvo_poll
+};
+
+static struct miscdevice tahvo_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "tahvo",
+	.fops = &tahvo_user_fileops
+};
+
+/*
+ * Initialization
+ *
+ * @return 0 if successful, error value otherwise.
+ */
+int tahvo_user_init(void)
+{
+	struct tahvo_irq *irq;
+	int res, i;
+
+	irq = kmalloc(sizeof(*irq) * TAHVO_MAX_IRQ_BUF_LEN, GFP_KERNEL);
+	if (irq == NULL) {
+		printk(KERN_ERR PFX "kmalloc failed\n");
+		return -ENOMEM;
+	}
+	memset(irq, 0, sizeof(*irq) * TAHVO_MAX_IRQ_BUF_LEN);
+	for (i = 0; i < TAHVO_MAX_IRQ_BUF_LEN; i++)
+		list_add(&irq[i].node, &tahvo_irqs_reserve);
+
+	tahvo_irq_block = irq;
+
+	spin_lock_init(&tahvo_irqs_lock);
+	mutex_init(&tahvo_mutex);
+
+	/* Request a misc device */
+	res = misc_register(&tahvo_device);
+	if (res < 0) {
+		printk(KERN_ERR PFX "unable to register misc device for %s\n",
+		       tahvo_device.name);
+		kfree(irq);
+		return res;
+	}
+
+	return 0;
+}
+
+/*
+ * Cleanup.
+ */
+void tahvo_user_cleanup(void)
+{
+	/* Unregister our misc device */
+	misc_deregister(&tahvo_device);
+	/* Unregister and disable all TAHVO interrupts */
+	tahvo_unreg_irq_handlers();
+	kfree(tahvo_irq_block);
+}
+
+MODULE_DESCRIPTION("Tahvo ASIC user space functions");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Mikko Ylinen");
diff --git a/drivers/cbus/tahvo.c b/drivers/cbus/tahvo.c
new file mode 100644
index 0000000..e734c4c
--- /dev/null
+++ b/drivers/cbus/tahvo.c
@@ -0,0 +1,442 @@
+/**
+ * drivers/cbus/tahvo.c
+ *
+ * Support functions for Tahvo ASIC
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com>,
+ *	      David Weinehall <david.weinehall@nokia.com>, and
+ *	      Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/uaccess.h>
+
+#include <mach/mux.h>
+#include <mach/board.h>
+#include <mach/board-nokia.h>
+
+#include "cbus.h"
+#include "tahvo.h"
+
+#define TAHVO_ID		0x02
+#define PFX			"tahvo: "
+
+static int tahvo_initialized;
+static int tahvo_irq_pin;
+static int tahvo_is_betty;
+
+static struct tasklet_struct tahvo_tasklet;
+spinlock_t tahvo_lock = SPIN_LOCK_UNLOCKED;
+
+static struct completion device_release;
+
+struct tahvo_irq_handler_desc {
+	int (*func)(unsigned long);
+	unsigned long arg;
+	char name[8];
+};
+
+static struct tahvo_irq_handler_desc tahvo_irq_handlers[MAX_TAHVO_IRQ_HANDLERS];
+
+/**
+ * tahvo_read_reg - Read a value from a register in Tahvo
+ * @reg: the register to read from
+ *
+ * This function returns the contents of the specified register
+ */
+int tahvo_read_reg(int reg)
+{
+	BUG_ON(!tahvo_initialized);
+	return cbus_read_reg(cbus_host, TAHVO_ID, reg);
+}
+
+/**
+ * tahvo_write_reg - Write a value to a register in Tahvo
+ * @reg: the register to write to
+ * @reg: the value to write to the register
+ *
+ * This function writes a value to the specified register
+ */
+void tahvo_write_reg(int reg, u16 val)
+{
+	BUG_ON(!tahvo_initialized);
+	cbus_write_reg(cbus_host, TAHVO_ID, reg, val);
+}
+
+/**
+ * tahvo_set_clear_reg_bits - set and clear register bits atomically
+ * @reg: the register to write to
+ * @bits: the bits to set
+ *
+ * This function sets and clears the specified Tahvo register bits atomically
+ */
+void tahvo_set_clear_reg_bits(int reg, u16 set, u16 clear)
+{
+	unsigned long flags;
+	u16 w;
+
+	spin_lock_irqsave(&tahvo_lock, flags);
+	w = tahvo_read_reg(reg);
+	w &= ~clear;
+	w |= set;
+	tahvo_write_reg(reg, w);
+	spin_unlock_irqrestore(&tahvo_lock, flags);
+}
+
+/*
+ * Disable given TAHVO interrupt
+ */
+void tahvo_disable_irq(int id)
+{
+	unsigned long flags;
+	u16 mask;
+
+	spin_lock_irqsave(&tahvo_lock, flags);
+	mask = tahvo_read_reg(TAHVO_REG_IMR);
+	mask |= 1 << id;
+	tahvo_write_reg(TAHVO_REG_IMR, mask);
+	spin_unlock_irqrestore(&tahvo_lock, flags);
+}
+
+/*
+ * Enable given TAHVO interrupt
+ */
+void tahvo_enable_irq(int id)
+{
+	unsigned long flags;
+	u16 mask;
+
+	spin_lock_irqsave(&tahvo_lock, flags);
+	mask = tahvo_read_reg(TAHVO_REG_IMR);
+	mask &= ~(1 << id);
+	tahvo_write_reg(TAHVO_REG_IMR, mask);
+	spin_unlock_irqrestore(&tahvo_lock, flags);
+}
+
+/*
+ * Acknowledge given TAHVO interrupt
+ */
+void tahvo_ack_irq(int id)
+{
+	tahvo_write_reg(TAHVO_REG_IDR, 1 << id);
+}
+
+static int tahvo_7bit_backlight;
+
+int tahvo_get_backlight_level(void)
+{
+	int mask;
+
+	if (tahvo_7bit_backlight)
+		mask = 0x7f;
+	else
+		mask = 0x0f;
+	return tahvo_read_reg(TAHVO_REG_LEDPWMR) & mask;
+}
+
+int tahvo_get_max_backlight_level(void)
+{
+	if (tahvo_7bit_backlight)
+		return 0x7f;
+	else
+		return 0x0f;
+}
+
+void tahvo_set_backlight_level(int level)
+{
+	int max_level;
+
+	max_level = tahvo_get_max_backlight_level();
+	if (level > max_level)
+		level = max_level;
+	tahvo_write_reg(TAHVO_REG_LEDPWMR, level);
+}
+
+/*
+ * TAHVO interrupt handler. Only schedules the tasklet.
+ */
+static irqreturn_t tahvo_irq_handler(int irq, void *dev_id)
+{
+	tasklet_schedule(&tahvo_tasklet);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Tasklet handler
+ */
+static void tahvo_tasklet_handler(unsigned long data)
+{
+	struct tahvo_irq_handler_desc *hnd;
+	u16 id;
+	u16 im;
+	int i;
+
+	for (;;) {
+		id = tahvo_read_reg(TAHVO_REG_IDR);
+		im = ~tahvo_read_reg(TAHVO_REG_IMR);
+		id &= im;
+
+		if (!id)
+			break;
+
+		for (i = 0; id != 0; i++, id >>= 1) {
+			if (!(id & 1))
+				continue;
+			hnd = &tahvo_irq_handlers[i];
+			if (hnd->func == NULL) {
+				/* Spurious tahvo interrupt - just ack it */
+				printk(KERN_INFO "Spurious Tahvo interrupt "
+						 "(id %d)\n", i);
+				tahvo_disable_irq(i);
+				tahvo_ack_irq(i);
+				continue;
+			}
+			hnd->func(hnd->arg);
+			/*
+			 * Don't acknowledge the interrupt here
+			 * It must be done explicitly
+			 */
+		}
+	}
+}
+
+/*
+ * Register the handler for a given TAHVO interrupt source.
+ */
+int tahvo_request_irq(int id, void *irq_handler, unsigned long arg, char *name)
+{
+	struct tahvo_irq_handler_desc *hnd;
+
+	if (irq_handler == NULL || id >= MAX_TAHVO_IRQ_HANDLERS ||
+	    name == NULL) {
+		printk(KERN_ERR PFX "Invalid arguments to %s\n",
+		       __FUNCTION__);
+		return -EINVAL;
+	}
+	hnd = &tahvo_irq_handlers[id];
+	if (hnd->func != NULL) {
+		printk(KERN_ERR PFX "IRQ %d already reserved\n", id);
+		return -EBUSY;
+	}
+	printk(KERN_INFO PFX "Registering interrupt %d for device %s\n",
+	       id, name);
+	hnd->func = irq_handler;
+	hnd->arg = arg;
+	strlcpy(hnd->name, name, sizeof(hnd->name));
+
+	tahvo_ack_irq(id);
+	tahvo_enable_irq(id);
+
+	return 0;
+}
+
+/*
+ * Unregister the handler for a given TAHVO interrupt source.
+ */
+void tahvo_free_irq(int id)
+{
+	struct tahvo_irq_handler_desc *hnd;
+
+	if (id >= MAX_TAHVO_IRQ_HANDLERS) {
+		printk(KERN_ERR PFX "Invalid argument to %s\n",
+		       __FUNCTION__);
+		return;
+	}
+	hnd = &tahvo_irq_handlers[id];
+	if (hnd->func == NULL) {
+		printk(KERN_ERR PFX "IRQ %d already freed\n", id);
+		return;
+	}
+
+	tahvo_disable_irq(id);
+	hnd->func = NULL;
+}
+
+/**
+ * tahvo_probe - Probe for Tahvo ASIC
+ * @dev: the Tahvo device
+ *
+ * Probe for the Tahvo ASIC and allocate memory
+ * for its device-struct if found
+ */
+static int __devinit tahvo_probe(struct device *dev)
+{
+	const struct omap_em_asic_bb5_config * em_asic_config;
+	int rev, id, ret;
+
+	/* Prepare tasklet */
+	tasklet_init(&tahvo_tasklet, tahvo_tasklet_handler, 0);
+
+	em_asic_config = omap_get_config(OMAP_TAG_EM_ASIC_BB5,
+					 struct omap_em_asic_bb5_config);
+	if (em_asic_config == NULL) {
+		printk(KERN_ERR PFX "Unable to retrieve config data\n");
+		return -ENODATA;
+	}
+
+	tahvo_initialized = 1;
+
+	rev = tahvo_read_reg(TAHVO_REG_ASICR);
+
+	id = (rev >> 8) & 0xff;
+	if (id == 0x03) {
+		if ((rev & 0xff) >= 0x50)
+			tahvo_7bit_backlight = 1;
+	} else if (id == 0x0b) {
+		tahvo_is_betty = 1;
+		tahvo_7bit_backlight = 1;
+	} else {
+		printk(KERN_ERR "Tahvo/Betty chip not found");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "%s v%d.%d found\n", tahvo_is_betty ? "Betty" : "Tahvo",
+	       (rev >> 4) & 0x0f, rev & 0x0f);
+
+	tahvo_irq_pin = em_asic_config->tahvo_irq_gpio;
+
+	if ((ret = gpio_request(tahvo_irq_pin, "TAHVO irq")) < 0) {
+		printk(KERN_ERR PFX "Unable to reserve IRQ GPIO\n");
+		return ret;
+	}
+
+	/* Set the pin as input */
+	gpio_direction_input(tahvo_irq_pin);
+
+	/* Rising edge triggers the IRQ */
+	set_irq_type(gpio_to_irq(tahvo_irq_pin), IRQ_TYPE_EDGE_RISING);
+
+	/* Mask all TAHVO interrupts */
+	tahvo_write_reg(TAHVO_REG_IMR, 0xffff);
+
+	ret = request_irq(gpio_to_irq(tahvo_irq_pin), tahvo_irq_handler, 0,
+			  "tahvo", 0);
+	if (ret < 0) {
+		printk(KERN_ERR PFX "Unable to register IRQ handler\n");
+		gpio_free(tahvo_irq_pin);
+		return ret;
+	}
+#ifdef CONFIG_CBUS_TAHVO_USER
+	/* Initialize user-space interface */
+	if (tahvo_user_init() < 0) {
+		printk(KERN_ERR "Unable to initialize driver\n");
+		free_irq(gpio_to_irq(tahvo_irq_pin), 0);
+		gpio_free(tahvo_irq_pin);
+		return ret;
+	}
+#endif
+	return 0;
+}
+
+static int tahvo_remove(struct device *dev)
+{
+#ifdef CONFIG_CBUS_TAHVO_USER
+	tahvo_user_cleanup();
+#endif
+	/* Mask all TAHVO interrupts */
+	tahvo_write_reg(TAHVO_REG_IMR, 0xffff);
+	free_irq(gpio_to_irq(tahvo_irq_pin), 0);
+	gpio_free(tahvo_irq_pin);
+	tasklet_kill(&tahvo_tasklet);
+
+	return 0;
+}
+
+static void tahvo_device_release(struct device *dev)
+{
+	complete(&device_release);
+}
+
+static struct device_driver tahvo_driver = {
+	.name		= "tahvo",
+	.bus		= &platform_bus_type,
+	.probe		= tahvo_probe,
+	.remove		= tahvo_remove,
+};
+
+static struct platform_device tahvo_device = {
+	.name		= "tahvo",
+	.id		= -1,
+	.dev = {
+		.release = tahvo_device_release,
+	}
+};
+
+/**
+ * tahvo_init - initialise Tahvo driver
+ *
+ * Initialise the Tahvo driver and return 0 if everything worked ok
+ */
+static int __init tahvo_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Tahvo/Betty driver initialising\n");
+
+	init_completion(&device_release);
+
+	if ((ret = driver_register(&tahvo_driver)) < 0)
+		return ret;
+
+	if ((ret = platform_device_register(&tahvo_device)) < 0) {
+		driver_unregister(&tahvo_driver);
+		return ret;
+	}
+	return 0;
+}
+
+/*
+ * Cleanup
+ */
+static void __exit tahvo_exit(void)
+{
+	platform_device_unregister(&tahvo_device);
+	driver_unregister(&tahvo_driver);
+	wait_for_completion(&device_release);
+}
+
+EXPORT_SYMBOL(tahvo_request_irq);
+EXPORT_SYMBOL(tahvo_free_irq);
+EXPORT_SYMBOL(tahvo_enable_irq);
+EXPORT_SYMBOL(tahvo_disable_irq);
+EXPORT_SYMBOL(tahvo_ack_irq);
+EXPORT_SYMBOL(tahvo_read_reg);
+EXPORT_SYMBOL(tahvo_write_reg);
+EXPORT_SYMBOL(tahvo_get_backlight_level);
+EXPORT_SYMBOL(tahvo_get_max_backlight_level);
+EXPORT_SYMBOL(tahvo_set_backlight_level);
+
+subsys_initcall(tahvo_init);
+module_exit(tahvo_exit);
+
+MODULE_DESCRIPTION("Tahvo ASIC control");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Juha Yrjl, David Weinehall, and Mikko Ylinen");
diff --git a/drivers/cbus/tahvo.h b/drivers/cbus/tahvo.h
new file mode 100644
index 0000000..b7a8ee1
--- /dev/null
+++ b/drivers/cbus/tahvo.h
@@ -0,0 +1,61 @@
+/*
+ * drivers/cbus/tahvo.h
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Juha Yrjl <juha.yrjola@nokia.com> and
+ *	      David Weinehall <david.weinehall@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DRIVERS_CBUS_TAHVO_H
+#define __DRIVERS_CBUS_TAHVO_H
+
+#include <linux/types.h>
+
+/* Registers */
+#define TAHVO_REG_ASICR		0x00	/* ASIC ID & revision */
+#define TAHVO_REG_IDR		0x01	/* Interrupt ID */
+#define TAHVO_REG_IDSR		0x02	/* Interrupt status */
+#define TAHVO_REG_IMR		0x03	/* Interrupt mask */
+#define TAHVO_REG_LEDPWMR	0x05	/* LED PWM */
+#define TAHVO_REG_USBR		0x06	/* USB control */
+#define TAHVO_REG_MAX		0x0d
+
+/* Interrupt sources */
+#define TAHVO_INT_VBUSON	0
+
+#define MAX_TAHVO_IRQ_HANDLERS	8
+
+int tahvo_read_reg(int reg);
+void tahvo_write_reg(int reg, u16 val);
+void tahvo_set_clear_reg_bits(int reg, u16 set, u16 clear);
+int tahvo_request_irq(int id, void *irq_handler, unsigned long arg, char *name);
+void tahvo_free_irq(int id);
+void tahvo_enable_irq(int id);
+void tahvo_disable_irq(int id);
+void tahvo_ack_irq(int id);
+int tahvo_get_backlight_level(void);
+int tahvo_get_max_backlight_level(void);
+void tahvo_set_backlight_level(int level);
+
+#ifdef CONFIG_CBUS_TAHVO_USER
+int tahvo_user_init(void);
+void tahvo_user_cleanup(void);
+#endif
+
+extern spinlock_t tahvo_lock;
+
+#endif /* __DRIVERS_CBUS_TAHVO_H */
diff --git a/drivers/cbus/user_retu_tahvo.h b/drivers/cbus/user_retu_tahvo.h
new file mode 100644
index 0000000..a5c2190
--- /dev/null
+++ b/drivers/cbus/user_retu_tahvo.h
@@ -0,0 +1,75 @@
+/**
+ * drivers/cbus/user_retu_tahvo.h
+ *
+ * Copyright (C) 2004, 2005 Nokia Corporation
+ *
+ * Written by Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * Definitions and types used by both retu-user and tahvo-user.
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _USER_RETU_TAHVO_H
+#define _USER_RETU_TAHVO_H
+
+/* Chip IDs */
+#define CHIP_RETU	1
+#define CHIP_TAHVO	2
+
+/* Register access type bits */
+#define READ_ONLY		1
+#define WRITE_ONLY		2
+#define READ_WRITE		3
+#define TOGGLE			4
+
+#define MASK(field)		((u16)(field & 0xFFFF))
+#define REG(field)		((u16)((field >> 16) & 0x3F))
+
+/*** IOCTL definitions. These should be kept in sync with user space **********/
+
+#define URT_IOC_MAGIC '`'
+
+/*
+ * IOCTL function naming conventions:
+ * ==================================
+ *  0 -- No argument and return value
+ *  S -- Set through a pointer
+ *  T -- Tell directly with the argument value
+ *  G -- Reply by setting through a pointer
+ *  Q -- response is on the return value
+ *  X -- S and G atomically
+ *  H -- T and Q atomically
+ */
+
+/* General */
+#define URT_IOCT_IRQ_SUBSCR		_IO(URT_IOC_MAGIC, 0)
+
+/* RETU */
+#define RETU_IOCH_READ			_IO(URT_IOC_MAGIC, 1)
+#define RETU_IOCX_WRITE			_IO(URT_IOC_MAGIC, 2)
+#define RETU_IOCH_ADC_READ		_IO(URT_IOC_MAGIC, 3)
+
+/* TAHVO */
+#define TAHVO_IOCH_READ			_IO(URT_IOC_MAGIC, 4)
+#define TAHVO_IOCX_WRITE		_IO(URT_IOC_MAGIC, 5)
+
+/* This structure is used for writing RETU/TAHVO registers */
+struct retu_tahvo_write_parms {
+    u32	field;
+    u16	value;
+    u8	result;
+};
+
+#endif
diff --git a/drivers/mmc/host/omap_hsmmc.c b/drivers/mmc/host/omap_hsmmc.c
index 4487cc0..0aecaae 100644
--- a/drivers/mmc/host/omap_hsmmc.c
+++ b/drivers/mmc/host/omap_hsmmc.c
@@ -2013,7 +2013,7 @@ static struct platform_driver omap_hsmmc_driver = {
 static int __init omap_hsmmc_init(void)
 {
 	/* Register the MMC driver */
-	return platform_driver_register(&omap_hsmmc_driver);
+	return platform_driver_probe(&omap_hsmmc_driver, omap_hsmmc_probe);
 }
 
 static void __exit omap_hsmmc_cleanup(void)
diff --git a/drivers/spi/omap_uwire.c b/drivers/spi/omap_uwire.c
index e75ba9b..7bcf409 100644
--- a/drivers/spi/omap_uwire.c
+++ b/drivers/spi/omap_uwire.c
@@ -52,7 +52,7 @@
 #include <asm/mach-types.h>
 
 #include <mach/mux.h>
-#include <mach/omap730.h>	/* OMAP730_IO_CONF registers */
+#include <mach/omap7xx.h>	/* OMAP7XX_IO_CONF registers */
 
 
 /* FIXME address is now a platform device resource,
@@ -504,7 +504,7 @@ static int __init uwire_probe(struct platform_device *pdev)
 	}
 	clk_enable(uwire->ck);
 
-	if (cpu_is_omap730())
+	if (cpu_is_omap7xx())
 		uwire_idx_shift = 1;
 	else
 		uwire_idx_shift = 2;
@@ -573,8 +573,8 @@ static int __init omap_uwire_init(void)
 	}
 	if (machine_is_omap_perseus2()) {
 		/* configure pins: MPU_UW_nSCS1, MPU_UW_SDO, MPU_UW_SCLK */
-		int val = omap_readl(OMAP730_IO_CONF_9) & ~0x00EEE000;
-		omap_writel(val | 0x00AAA000, OMAP730_IO_CONF_9);
+		int val = omap_readl(OMAP7XX_IO_CONF_9) & ~0x00EEE000;
+		omap_writel(val | 0x00AAA000, OMAP7XX_IO_CONF_9);
 	}
 
 	return platform_driver_probe(&uwire_driver, uwire_probe);
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 2407508..5620e92 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -60,6 +60,7 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_IXP4XX
 	default y if ARCH_W90X900
 	default y if ARCH_AT91SAM9G45
+	default y if ARCH_OMAP34XX
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9835e07..44c208c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1108,6 +1108,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
 #endif
 
+#ifdef CONFIG_ARCH_OMAP34XX
+#include "ehci-omap.c"
+#define	PLATFORM_DRIVER		ehci_hcd_omap_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
diff --git a/drivers/usb/host/ehci-omap.c b/drivers/usb/host/ehci-omap.c
new file mode 100644
index 0000000..7ba8df3
--- /dev/null
+++ b/drivers/usb/host/ehci-omap.c
@@ -0,0 +1,755 @@
+/*
+ * ehci-omap.c - driver for USBHOST on OMAP 34xx processor
+ *
+ * Bus Glue for OMAP34xx USBHOST 3 port EHCI controller
+ * Tested on OMAP3430 ES2.0 SDP
+ *
+ * Copyright (C) 2007-2008 Texas Instruments, Inc.
+ *	Author: Vikram Pandita <vikram.pandita@ti.com>
+ *
+ * Copyright (C) 2009 Nokia Corporation
+ *	Contact: Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * Based on "ehci-fsl.c" and "ehci-au1xxx.c" ehci glue layers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * TODO (last updated Feb 23rd, 2009):
+ *	- add kernel-doc
+ *	- enable AUTOIDLE
+ *	- move DPLL5 programming to clock fw
+ *	- add suspend/resume
+ *	- move workarounds to board-files
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <mach/usb.h>
+
+/*
+ * OMAP USBHOST Register addresses: VIRTUAL ADDRESSES
+ *	Use ehci_omap_readl()/ehci_omap_writel() functions
+ */
+
+/* TLL Register Set */
+#define	OMAP_USBTLL_REVISION				(0x00)
+#define	OMAP_USBTLL_SYSCONFIG				(0x10)
+#define	OMAP_USBTLL_SYSCONFIG_CACTIVITY			(1 << 8)
+#define	OMAP_USBTLL_SYSCONFIG_SIDLEMODE			(1 << 3)
+#define	OMAP_USBTLL_SYSCONFIG_ENAWAKEUP			(1 << 2)
+#define	OMAP_USBTLL_SYSCONFIG_SOFTRESET			(1 << 1)
+#define	OMAP_USBTLL_SYSCONFIG_AUTOIDLE			(1 << 0)
+
+#define	OMAP_USBTLL_SYSSTATUS				(0x14)
+#define	OMAP_USBTLL_SYSSTATUS_RESETDONE			(1 << 0)
+
+#define	OMAP_USBTLL_IRQSTATUS				(0x18)
+#define	OMAP_USBTLL_IRQENABLE				(0x1C)
+
+#define	OMAP_TLL_SHARED_CONF				(0x30)
+#define	OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN		(1 << 6)
+#define	OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN		(1 << 5)
+#define	OMAP_TLL_SHARED_CONF_USB_DIVRATION		(1 << 2)
+#define	OMAP_TLL_SHARED_CONF_FCLK_REQ			(1 << 1)
+#define	OMAP_TLL_SHARED_CONF_FCLK_IS_ON			(1 << 0)
+
+#define	OMAP_TLL_CHANNEL_CONF(num)			(0x040 + 0x004 * num)
+#define	OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF		(1 << 11)
+#define	OMAP_TLL_CHANNEL_CONF_ULPI_ULPIAUTOIDLE		(1 << 10)
+#define	OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE		(1 << 9)
+#define	OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE		(1 << 8)
+#define	OMAP_TLL_CHANNEL_CONF_CHANEN			(1 << 0)
+
+#define	OMAP_TLL_ULPI_FUNCTION_CTRL(num)		(0x804 + 0x100 * num)
+#define	OMAP_TLL_ULPI_INTERFACE_CTRL(num)		(0x807 + 0x100 * num)
+#define	OMAP_TLL_ULPI_OTG_CTRL(num)			(0x80A + 0x100 * num)
+#define	OMAP_TLL_ULPI_INT_EN_RISE(num)			(0x80D + 0x100 * num)
+#define	OMAP_TLL_ULPI_INT_EN_FALL(num)			(0x810 + 0x100 * num)
+#define	OMAP_TLL_ULPI_INT_STATUS(num)			(0x813 + 0x100 * num)
+#define	OMAP_TLL_ULPI_INT_LATCH(num)			(0x814 + 0x100 * num)
+#define	OMAP_TLL_ULPI_DEBUG(num)			(0x815 + 0x100 * num)
+#define	OMAP_TLL_ULPI_SCRATCH_REGISTER(num)		(0x816 + 0x100 * num)
+
+#define OMAP_TLL_CHANNEL_COUNT				3
+#define OMAP_TLL_CHANNEL_1_EN_MASK			(1 << 1)
+#define OMAP_TLL_CHANNEL_2_EN_MASK			(1 << 2)
+#define OMAP_TLL_CHANNEL_3_EN_MASK			(1 << 4)
+
+/* UHH Register Set */
+#define	OMAP_UHH_REVISION				(0x00)
+#define	OMAP_UHH_SYSCONFIG				(0x10)
+#define	OMAP_UHH_SYSCONFIG_MIDLEMODE			(1 << 12)
+#define	OMAP_UHH_SYSCONFIG_CACTIVITY			(1 << 8)
+#define	OMAP_UHH_SYSCONFIG_SIDLEMODE			(1 << 3)
+#define	OMAP_UHH_SYSCONFIG_ENAWAKEUP			(1 << 2)
+#define	OMAP_UHH_SYSCONFIG_SOFTRESET			(1 << 1)
+#define	OMAP_UHH_SYSCONFIG_AUTOIDLE			(1 << 0)
+
+#define	OMAP_UHH_SYSSTATUS				(0x14)
+#define	OMAP_UHH_HOSTCONFIG				(0x40)
+#define	OMAP_UHH_HOSTCONFIG_ULPI_BYPASS			(1 << 0)
+#define	OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS		(1 << 0)
+#define	OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS		(1 << 11)
+#define	OMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS		(1 << 12)
+#define OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN		(1 << 2)
+#define OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN		(1 << 3)
+#define OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN		(1 << 4)
+#define OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN		(1 << 5)
+#define OMAP_UHH_HOSTCONFIG_P1_CONNECT_STATUS		(1 << 8)
+#define OMAP_UHH_HOSTCONFIG_P2_CONNECT_STATUS		(1 << 9)
+#define OMAP_UHH_HOSTCONFIG_P3_CONNECT_STATUS		(1 << 10)
+
+#define	OMAP_UHH_DEBUG_CSR				(0x44)
+
+/* EHCI Register Set */
+#define	EHCI_INSNREG05_ULPI				(0xA4)
+#define	EHCI_INSNREG05_ULPI_CONTROL_SHIFT		31
+#define	EHCI_INSNREG05_ULPI_PORTSEL_SHIFT		24
+#define	EHCI_INSNREG05_ULPI_OPSEL_SHIFT			22
+#define	EHCI_INSNREG05_ULPI_REGADD_SHIFT		16
+#define	EHCI_INSNREG05_ULPI_EXTREGADD_SHIFT		8
+#define	EHCI_INSNREG05_ULPI_WRDATA_SHIFT		0
+
+/*-------------------------------------------------------------------------*/
+
+static inline void ehci_omap_writel(void __iomem *base, u32 reg, u32 val)
+{
+	__raw_writel(val, base + reg);
+}
+
+static inline u32 ehci_omap_readl(void __iomem *base, u32 reg)
+{
+	return __raw_readl(base + reg);
+}
+
+static inline void ehci_omap_writeb(void __iomem *base, u8 reg, u8 val)
+{
+	__raw_writeb(val, base + reg);
+}
+
+static inline u8 ehci_omap_readb(void __iomem *base, u8 reg)
+{
+	return __raw_readb(base + reg);
+}
+
+/*-------------------------------------------------------------------------*/
+
+struct ehci_hcd_omap {
+	struct ehci_hcd		*ehci;
+	struct device		*dev;
+
+	struct clk		*usbhost_ick;
+	struct clk		*usbhost2_120m_fck;
+	struct clk		*usbhost1_48m_fck;
+	struct clk		*usbtll_fck;
+	struct clk		*usbtll_ick;
+
+	/* FIXME the following two workarounds are
+	 * board specific not silicon-specific so these
+	 * should be moved to board-file instead.
+	 *
+	 * Maybe someone from TI will know better which
+	 * board is affected and needs the workarounds
+	 * to be applied
+	 */
+
+	/* gpio for resetting phy */
+	int			reset_gpio_port[OMAP3_HS_USB_PORTS];
+
+	/* phy reset workaround */
+	int			phy_reset;
+
+	/* desired phy_mode: TLL, PHY */
+	enum ehci_hcd_omap_mode	port_mode[OMAP3_HS_USB_PORTS];
+
+	void __iomem		*uhh_base;
+	void __iomem		*tll_base;
+	void __iomem		*ehci_base;
+};
+
+/*-------------------------------------------------------------------------*/
+
+static void omap_usb_utmi_init(struct ehci_hcd_omap *omap, u8 tll_channel_mask)
+{
+	unsigned reg;
+	int i;
+
+	/* Program the 3 TLL channels upfront */
+	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
+		reg = ehci_omap_readl(omap->tll_base, OMAP_TLL_CHANNEL_CONF(i));
+
+		/* Disable AutoIdle, BitStuffing and use SDR Mode */
+		reg &= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
+				| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF
+				| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
+		ehci_omap_writel(omap->tll_base, OMAP_TLL_CHANNEL_CONF(i), reg);
+	}
+
+	/* Program Common TLL register */
+	reg = ehci_omap_readl(omap->tll_base, OMAP_TLL_SHARED_CONF);
+	reg |= (OMAP_TLL_SHARED_CONF_FCLK_IS_ON
+			| OMAP_TLL_SHARED_CONF_USB_DIVRATION
+			| OMAP_TLL_SHARED_CONF_USB_180D_SDR_EN);
+	reg &= ~OMAP_TLL_SHARED_CONF_USB_90D_DDR_EN;
+
+	ehci_omap_writel(omap->tll_base, OMAP_TLL_SHARED_CONF, reg);
+
+	/* Enable channels now */
+	for (i = 0; i < OMAP_TLL_CHANNEL_COUNT; i++) {
+		reg = ehci_omap_readl(omap->tll_base, OMAP_TLL_CHANNEL_CONF(i));
+
+		/* Enable only the reg that is needed */
+		if (!(tll_channel_mask & 1<<i))
+			continue;
+
+		reg |= OMAP_TLL_CHANNEL_CONF_CHANEN;
+		ehci_omap_writel(omap->tll_base, OMAP_TLL_CHANNEL_CONF(i), reg);
+
+		ehci_omap_writeb(omap->tll_base,
+				OMAP_TLL_ULPI_SCRATCH_REGISTER(i), 0xbe);
+		dev_dbg(omap->dev, "ULPI_SCRATCH_REG[ch=%d]= 0x%02x\n",
+				i+1, ehci_omap_readb(omap->tll_base,
+				OMAP_TLL_ULPI_SCRATCH_REGISTER(i)));
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* omap_start_ehc
+ *	- Start the TI USBHOST controller
+ */
+static int omap_start_ehc(struct ehci_hcd_omap *omap, struct usb_hcd *hcd)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(1000);
+	u8 tll_ch_mask = 0;
+	unsigned reg = 0;
+	int ret = 0;
+
+	dev_dbg(omap->dev, "starting TI EHCI USB Controller\n");
+
+	/* Enable Clocks for USBHOST */
+	omap->usbhost_ick = clk_get(omap->dev, "usbhost_ick");
+	if (IS_ERR(omap->usbhost_ick)) {
+		ret =  PTR_ERR(omap->usbhost_ick);
+		goto err_host_ick;
+	}
+	clk_enable(omap->usbhost_ick);
+
+	omap->usbhost2_120m_fck = clk_get(omap->dev, "usbhost_120m_fck");
+	if (IS_ERR(omap->usbhost2_120m_fck)) {
+		ret = PTR_ERR(omap->usbhost2_120m_fck);
+		goto err_host_120m_fck;
+	}
+	clk_enable(omap->usbhost2_120m_fck);
+
+	omap->usbhost1_48m_fck = clk_get(omap->dev, "usbhost_48m_fck");
+	if (IS_ERR(omap->usbhost1_48m_fck)) {
+		ret = PTR_ERR(omap->usbhost1_48m_fck);
+		goto err_host_48m_fck;
+	}
+	clk_enable(omap->usbhost1_48m_fck);
+
+	if (omap->phy_reset) {
+		/* Refer: ISSUE1 */
+		if (gpio_is_valid(omap->reset_gpio_port[0])) {
+			gpio_request(omap->reset_gpio_port[0],
+						"USB1 PHY reset");
+			gpio_direction_output(omap->reset_gpio_port[0], 0);
+		}
+
+		if (gpio_is_valid(omap->reset_gpio_port[1])) {
+			gpio_request(omap->reset_gpio_port[1],
+						"USB2 PHY reset");
+			gpio_direction_output(omap->reset_gpio_port[1], 0);
+		}
+
+		/* Hold the PHY in RESET for enough time till DIR is high */
+		udelay(10);
+	}
+
+	/* Configure TLL for 60Mhz clk for ULPI */
+	omap->usbtll_fck = clk_get(omap->dev, "usbtll_fck");
+	if (IS_ERR(omap->usbtll_fck)) {
+		ret = PTR_ERR(omap->usbtll_fck);
+		goto err_tll_fck;
+	}
+	clk_enable(omap->usbtll_fck);
+
+	omap->usbtll_ick = clk_get(omap->dev, "usbtll_ick");
+	if (IS_ERR(omap->usbtll_ick)) {
+		ret = PTR_ERR(omap->usbtll_ick);
+		goto err_tll_ick;
+	}
+	clk_enable(omap->usbtll_ick);
+
+	/* perform TLL soft reset, and wait until reset is complete */
+	ehci_omap_writel(omap->tll_base, OMAP_USBTLL_SYSCONFIG,
+			OMAP_USBTLL_SYSCONFIG_SOFTRESET);
+
+	/* Wait for TLL reset to complete */
+	while (!(ehci_omap_readl(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+			& OMAP_USBTLL_SYSSTATUS_RESETDONE)) {
+		cpu_relax();
+
+		if (time_after(jiffies, timeout)) {
+			dev_dbg(omap->dev, "operation timed out\n");
+			ret = -EINVAL;
+			goto err_sys_status;
+		}
+	}
+
+	dev_dbg(omap->dev, "TLL RESET DONE\n");
+
+	/* (1<<3) = no idle mode only for initial debugging */
+	ehci_omap_writel(omap->tll_base, OMAP_USBTLL_SYSCONFIG,
+			OMAP_USBTLL_SYSCONFIG_ENAWAKEUP |
+			OMAP_USBTLL_SYSCONFIG_SIDLEMODE |
+			OMAP_USBTLL_SYSCONFIG_CACTIVITY);
+
+
+	/* Put UHH in NoIdle/NoStandby mode */
+	reg = ehci_omap_readl(omap->uhh_base, OMAP_UHH_SYSCONFIG);
+	reg |= (OMAP_UHH_SYSCONFIG_ENAWAKEUP
+			| OMAP_UHH_SYSCONFIG_SIDLEMODE
+			| OMAP_UHH_SYSCONFIG_CACTIVITY
+			| OMAP_UHH_SYSCONFIG_MIDLEMODE);
+	reg &= ~OMAP_UHH_SYSCONFIG_AUTOIDLE;
+
+	ehci_omap_writel(omap->uhh_base, OMAP_UHH_SYSCONFIG, reg);
+
+	reg = ehci_omap_readl(omap->uhh_base, OMAP_UHH_HOSTCONFIG);
+
+	/* setup ULPI bypass and burst configurations */
+	reg |= (OMAP_UHH_HOSTCONFIG_INCR4_BURST_EN
+			| OMAP_UHH_HOSTCONFIG_INCR8_BURST_EN
+			| OMAP_UHH_HOSTCONFIG_INCR16_BURST_EN);
+	reg &= ~OMAP_UHH_HOSTCONFIG_INCRX_ALIGN_EN;
+
+	if (omap->port_mode[0] == EHCI_HCD_OMAP_MODE_UNKNOWN)
+		reg &= ~OMAP_UHH_HOSTCONFIG_P1_CONNECT_STATUS;
+	if (omap->port_mode[1] == EHCI_HCD_OMAP_MODE_UNKNOWN)
+		reg &= ~OMAP_UHH_HOSTCONFIG_P2_CONNECT_STATUS;
+	if (omap->port_mode[2] == EHCI_HCD_OMAP_MODE_UNKNOWN)
+		reg &= ~OMAP_UHH_HOSTCONFIG_P3_CONNECT_STATUS;
+
+	/* Bypass the TLL module for PHY mode operation */
+	 if (omap_rev() <= OMAP3430_REV_ES2_1) {
+		dev_dbg(omap->dev, "OMAP3 ES version <= ES2.1 \n");
+		if ((omap->port_mode[0] == EHCI_HCD_OMAP_MODE_PHY) ||
+			(omap->port_mode[1] == EHCI_HCD_OMAP_MODE_PHY) ||
+				(omap->port_mode[2] == EHCI_HCD_OMAP_MODE_PHY))
+			reg &= ~OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;
+		else
+			reg |= OMAP_UHH_HOSTCONFIG_ULPI_BYPASS;
+	} else {
+		dev_dbg(omap->dev, "OMAP3 ES version > ES2.1\n");
+		if (omap->port_mode[0] == EHCI_HCD_OMAP_MODE_PHY)
+			reg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;
+		else if (omap->port_mode[0] == EHCI_HCD_OMAP_MODE_TLL)
+			reg |= OMAP_UHH_HOSTCONFIG_ULPI_P1_BYPASS;
+
+		if (omap->port_mode[1] == EHCI_HCD_OMAP_MODE_PHY)
+			reg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS;
+		else if (omap->port_mode[1] == EHCI_HCD_OMAP_MODE_TLL)
+			reg |= OMAP_UHH_HOSTCONFIG_ULPI_P2_BYPASS;
+
+		if (omap->port_mode[2] == EHCI_HCD_OMAP_MODE_PHY)
+			reg &= ~OMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS;
+		else if (omap->port_mode[2] == EHCI_HCD_OMAP_MODE_TLL)
+			reg |= OMAP_UHH_HOSTCONFIG_ULPI_P3_BYPASS;
+
+	}
+	ehci_omap_writel(omap->uhh_base, OMAP_UHH_HOSTCONFIG, reg);
+	dev_dbg(omap->dev, "UHH setup done, uhh_hostconfig=%x\n", reg);
+
+
+	if ((omap->port_mode[0] == EHCI_HCD_OMAP_MODE_TLL) ||
+		(omap->port_mode[1] == EHCI_HCD_OMAP_MODE_TLL) ||
+			(omap->port_mode[2] == EHCI_HCD_OMAP_MODE_TLL)) {
+
+		if (omap->port_mode[0] == EHCI_HCD_OMAP_MODE_TLL)
+			tll_ch_mask |= OMAP_TLL_CHANNEL_1_EN_MASK;
+		if (omap->port_mode[1] == EHCI_HCD_OMAP_MODE_TLL)
+			tll_ch_mask |= OMAP_TLL_CHANNEL_2_EN_MASK;
+		if (omap->port_mode[2] == EHCI_HCD_OMAP_MODE_TLL)
+			tll_ch_mask |= OMAP_TLL_CHANNEL_3_EN_MASK;
+
+		/* Enable UTMI mode for required TLL channels */
+		omap_usb_utmi_init(omap, tll_ch_mask);
+	}
+
+	if (omap->phy_reset) {
+		/* Refer ISSUE1:
+		 * Hold the PHY in RESET for enough time till
+		 * PHY is settled and ready
+		 */
+		udelay(10);
+
+		if (gpio_is_valid(omap->reset_gpio_port[0]))
+			gpio_set_value(omap->reset_gpio_port[0], 1);
+
+		if (gpio_is_valid(omap->reset_gpio_port[1]))
+			gpio_set_value(omap->reset_gpio_port[1], 1);
+	}
+
+	return 0;
+
+err_sys_status:
+	clk_disable(omap->usbtll_ick);
+	clk_put(omap->usbtll_ick);
+
+err_tll_ick:
+	clk_disable(omap->usbtll_fck);
+	clk_put(omap->usbtll_fck);
+
+err_tll_fck:
+	clk_disable(omap->usbhost1_48m_fck);
+	clk_put(omap->usbhost1_48m_fck);
+
+	if (omap->phy_reset) {
+		if (gpio_is_valid(omap->reset_gpio_port[0]))
+			gpio_free(omap->reset_gpio_port[0]);
+
+		if (gpio_is_valid(omap->reset_gpio_port[1]))
+			gpio_free(omap->reset_gpio_port[1]);
+	}
+
+err_host_48m_fck:
+	clk_disable(omap->usbhost2_120m_fck);
+	clk_put(omap->usbhost2_120m_fck);
+
+err_host_120m_fck:
+	clk_disable(omap->usbhost_ick);
+	clk_put(omap->usbhost_ick);
+
+err_host_ick:
+	return ret;
+}
+
+static void omap_stop_ehc(struct ehci_hcd_omap *omap, struct usb_hcd *hcd)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(100);
+
+	dev_dbg(omap->dev, "stopping TI EHCI USB Controller\n");
+
+	/* Reset OMAP modules for insmod/rmmod to work */
+	ehci_omap_writel(omap->uhh_base, OMAP_UHH_SYSCONFIG,
+			OMAP_UHH_SYSCONFIG_SOFTRESET);
+	while (!(ehci_omap_readl(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+				& (1 << 0))) {
+		cpu_relax();
+
+		if (time_after(jiffies, timeout))
+			dev_dbg(omap->dev, "operation timed out\n");
+	}
+
+	while (!(ehci_omap_readl(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+				& (1 << 1))) {
+		cpu_relax();
+
+		if (time_after(jiffies, timeout))
+			dev_dbg(omap->dev, "operation timed out\n");
+	}
+
+	while (!(ehci_omap_readl(omap->uhh_base, OMAP_UHH_SYSSTATUS)
+				& (1 << 2))) {
+		cpu_relax();
+
+		if (time_after(jiffies, timeout))
+			dev_dbg(omap->dev, "operation timed out\n");
+	}
+
+	ehci_omap_writel(omap->tll_base, OMAP_USBTLL_SYSCONFIG, (1 << 1));
+
+	while (!(ehci_omap_readl(omap->tll_base, OMAP_USBTLL_SYSSTATUS)
+				& (1 << 0))) {
+		cpu_relax();
+
+		if (time_after(jiffies, timeout))
+			dev_dbg(omap->dev, "operation timed out\n");
+	}
+
+	if (omap->usbtll_fck != NULL) {
+		clk_disable(omap->usbtll_fck);
+		clk_put(omap->usbtll_fck);
+		omap->usbtll_fck = NULL;
+	}
+
+	if (omap->usbhost_ick != NULL) {
+		clk_disable(omap->usbhost_ick);
+		clk_put(omap->usbhost_ick);
+		omap->usbhost_ick = NULL;
+	}
+
+	if (omap->usbhost1_48m_fck != NULL) {
+		clk_disable(omap->usbhost1_48m_fck);
+		clk_put(omap->usbhost1_48m_fck);
+		omap->usbhost1_48m_fck = NULL;
+	}
+
+	if (omap->usbhost2_120m_fck != NULL) {
+		clk_disable(omap->usbhost2_120m_fck);
+		clk_put(omap->usbhost2_120m_fck);
+		omap->usbhost2_120m_fck = NULL;
+	}
+
+	if (omap->usbtll_ick != NULL) {
+		clk_disable(omap->usbtll_ick);
+		clk_put(omap->usbtll_ick);
+		omap->usbtll_ick = NULL;
+	}
+
+	if (omap->phy_reset) {
+		if (gpio_is_valid(omap->reset_gpio_port[0]))
+			gpio_free(omap->reset_gpio_port[0]);
+
+		if (gpio_is_valid(omap->reset_gpio_port[1]))
+			gpio_free(omap->reset_gpio_port[1]);
+	}
+
+	dev_dbg(omap->dev, "Clock to USB host has been disabled\n");
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_omap_hc_driver;
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * ehci_hcd_omap_probe - initialize TI-based HCDs
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ */
+static int ehci_hcd_omap_probe(struct platform_device *pdev)
+{
+	struct ehci_hcd_omap_platform_data *pdata = pdev->dev.platform_data;
+	struct ehci_hcd_omap *omap;
+	struct resource *res;
+	struct usb_hcd *hcd;
+
+	int irq = platform_get_irq(pdev, 0);
+	int ret = -ENODEV;
+
+	if (!pdata) {
+		dev_dbg(&pdev->dev, "missing platform_data\n");
+		goto err_pdata;
+	}
+
+	if (usb_disabled())
+		goto err_disabled;
+
+	omap = kzalloc(sizeof(*omap), GFP_KERNEL);
+	if (!omap) {
+		ret = -ENOMEM;
+		goto err_create_hcd;
+	}
+
+	hcd = usb_create_hcd(&ehci_omap_hc_driver, &pdev->dev,
+			dev_name(&pdev->dev));
+	if (!hcd) {
+		dev_dbg(&pdev->dev, "failed to create hcd with err %d\n", ret);
+		ret = -ENOMEM;
+		goto err_create_hcd;
+	}
+
+	platform_set_drvdata(pdev, omap);
+	omap->dev		= &pdev->dev;
+	omap->phy_reset		= pdata->phy_reset;
+	omap->reset_gpio_port[0]	= pdata->reset_gpio_port[0];
+	omap->reset_gpio_port[1]	= pdata->reset_gpio_port[1];
+	omap->reset_gpio_port[2]	= pdata->reset_gpio_port[2];
+	omap->port_mode[0]		= pdata->port_mode[0];
+	omap->port_mode[1]		= pdata->port_mode[1];
+	omap->port_mode[2]		= pdata->port_mode[2];
+	omap->ehci		= hcd_to_ehci(hcd);
+	omap->ehci->sbrn	= 0x20;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(&pdev->dev, "EHCI ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	/* we know this is the memory we want, no need to ioremap again */
+	omap->ehci->caps = hcd->regs;
+	omap->ehci_base = hcd->regs;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	omap->uhh_base = ioremap(res->start, resource_size(res));
+	if (!omap->uhh_base) {
+		dev_err(&pdev->dev, "UHH ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_uhh_ioremap;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	omap->tll_base = ioremap(res->start, resource_size(res));
+	if (!omap->tll_base) {
+		dev_err(&pdev->dev, "TLL ioremap failed\n");
+		ret = -ENOMEM;
+		goto err_tll_ioremap;
+	}
+
+	ret = omap_start_ehc(omap, hcd);
+	if (ret) {
+		dev_dbg(&pdev->dev, "failed to start ehci\n");
+		goto err_start;
+	}
+
+	omap->ehci->regs = hcd->regs
+		+ HC_LENGTH(readl(&omap->ehci->caps->hc_capbase));
+
+	/* cache this readonly data; minimize chip reads */
+	omap->ehci->hcs_params = readl(&omap->ehci->caps->hcs_params);
+
+	/* SET 1 micro-frame Interrupt interval */
+	writel(readl(&omap->ehci->regs->command) | (1 << 16),
+			&omap->ehci->regs->command);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (ret) {
+		dev_dbg(&pdev->dev, "failed to add hcd with err %d\n", ret);
+		goto err_add_hcd;
+	}
+
+	return 0;
+
+err_add_hcd:
+	omap_stop_ehc(omap, hcd);
+
+err_start:
+	iounmap(omap->tll_base);
+
+err_tll_ioremap:
+	iounmap(omap->uhh_base);
+
+err_uhh_ioremap:
+	iounmap(hcd->regs);
+
+err_ioremap:
+	usb_put_hcd(hcd);
+
+err_create_hcd:
+err_disabled:
+err_pdata:
+	return ret;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * ehci_hcd_omap_remove - shutdown processing for EHCI HCDs
+ * @pdev: USB Host Controller being removed
+ *
+ * Reverses the effect of usb_ehci_hcd_omap_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ */
+static int ehci_hcd_omap_remove(struct platform_device *pdev)
+{
+	struct ehci_hcd_omap *omap = platform_get_drvdata(pdev);
+	struct usb_hcd *hcd = ehci_to_hcd(omap->ehci);
+
+	usb_remove_hcd(hcd);
+	omap_stop_ehc(omap, hcd);
+	iounmap(hcd->regs);
+	iounmap(omap->tll_base);
+	iounmap(omap->uhh_base);
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static void ehci_hcd_omap_shutdown(struct platform_device *pdev)
+{
+	struct ehci_hcd_omap *omap = platform_get_drvdata(pdev);
+	struct usb_hcd *hcd = ehci_to_hcd(omap->ehci);
+
+	if (hcd->driver->shutdown)
+		hcd->driver->shutdown(hcd);
+}
+
+static struct platform_driver ehci_hcd_omap_driver = {
+	.probe			= ehci_hcd_omap_probe,
+	.remove			= ehci_hcd_omap_remove,
+	.shutdown		= ehci_hcd_omap_shutdown,
+	/*.suspend		= ehci_hcd_omap_suspend, */
+	/*.resume		= ehci_hcd_omap_resume, */
+	.driver = {
+		.name		= "ehci-omap",
+	}
+};
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_omap_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "OMAP-EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq			= ehci_irq,
+	.flags			= HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset			= ehci_init,
+	.start			= ehci_run,
+	.stop			= ehci_stop,
+	.shutdown		= ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number	= ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+MODULE_ALIAS("platform:omap-ehci");
+MODULE_AUTHOR("Texas Instruments, Inc.");
+MODULE_AUTHOR("Felipe Balbi <felipe.balbi@nokia.com>");
+
diff --git a/drivers/video/omap/dispc.c b/drivers/video/omap/dispc.c
index f16e421..6f957ce 100644
--- a/drivers/video/omap/dispc.c
+++ b/drivers/video/omap/dispc.c
@@ -204,6 +204,7 @@ static u32 inline dispc_read_reg(int idx)
 /* Select RFBI or bypass mode */
 static void enable_rfbi_mode(int enable)
 {
+	void __iomem *rfbi_control;
 	u32 l;
 
 	l = dispc_read_reg(DISPC_CONTROL);
@@ -216,9 +217,15 @@ static void enable_rfbi_mode(int enable)
 	dispc_write_reg(DISPC_CONTROL, l);
 
 	/* Set bypass mode in RFBI module */
-	l = __raw_readl(OMAP2_IO_ADDRESS(RFBI_CONTROL));
+	rfbi_control = ioremap(RFBI_CONTROL, SZ_1K);
+	if (!rfbi_control) {
+		pr_err("Unable to ioremap rfbi_control\n");
+		return;
+	}
+	l = __raw_readl(rfbi_control);
 	l |= enable ? 0 : (1 << 1);
-	__raw_writel(l, OMAP2_IO_ADDRESS(RFBI_CONTROL));
+	__raw_writel(l, rfbi_control);
+	iounmap(rfbi_control);
 }
 
 static void set_lcd_data_lines(int data_lines)
@@ -1367,6 +1374,7 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 	int r;
 	u32 l;
 	struct lcd_panel *panel = fbdev->panel;
+	void __iomem *ram_fw_base;
 	int tmo = 10000;
 	int skip_init = 0;
 	int i;
@@ -1441,7 +1449,13 @@ static int omap_dispc_init(struct omapfb_device *fbdev, int ext_mode,
 	}
 
 	/* L3 firewall setting: enable access to OCM RAM */
-	__raw_writel(0x402000b0, OMAP2_IO_ADDRESS(0x680050a0));
+	ram_fw_base = ioremap(0x68005000, SZ_1K);
+	if (!ram_fw_base) {
+		dev_err(dispc.fbdev->dev, "Cannot ioremap to enable OCM RAM\n");
+		goto fail1;
+	}
+	__raw_writel(0x402000b0, ram_fw_base + 0xa0);
+	iounmap(ram_fw_base);
 
 	if ((r = alloc_palette_ram()) < 0)
 		goto fail2;
