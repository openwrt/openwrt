From 08891f5b4dedf2c490371cef6af91f3b7475282d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 7 May 2013 14:32:27 +0100
Subject: [PATCH 089/114] Add 2709 platform for Raspberry Pi 2

---
 arch/arm/Kconfig                                 |   21 +
 arch/arm/Makefile                                |    1 +
 arch/arm/boot/dts/Makefile                       |   11 +-
 arch/arm/boot/dts/bcm2709-rpi-2-b.dts            |  101 ++
 arch/arm/boot/dts/bcm2709.dtsi                   |  159 +++
 arch/arm/configs/bcm2709_defconfig               | 1149 ++++++++++++++++++++
 arch/arm/configs/bcm2709_sdcard_defconfig        |  129 +++
 arch/arm/configs/bcm2709_small_defconfig         |   61 ++
 arch/arm/configs/bcm2835_sdcard_defconfig        |  176 +++
 arch/arm/configs/bcmrpi_sdcard_defconfig         |  176 +++
 arch/arm/configs/bcmrpi_small_defconfig          |  103 ++
 arch/arm/kernel/head.S                           |    8 +
 arch/arm/mach-bcm2709/Kconfig                    |   49 +
 arch/arm/mach-bcm2709/Makefile                   |    7 +
 arch/arm/mach-bcm2709/Makefile.boot              |    3 +
 arch/arm/mach-bcm2709/armctrl.c                  |  357 +++++++
 arch/arm/mach-bcm2709/armctrl.h                  |   27 +
 arch/arm/mach-bcm2709/bcm2708_gpio.c             |  426 ++++++++
 arch/arm/mach-bcm2709/bcm2709.c                  | 1237 ++++++++++++++++++++++
 arch/arm/mach-bcm2709/bcm2709.h                  |   49 +
 arch/arm/mach-bcm2709/clock.c                    |   61 ++
 arch/arm/mach-bcm2709/clock.h                    |   24 +
 arch/arm/mach-bcm2709/delay.S                    |   21 +
 arch/arm/mach-bcm2709/dma.c                      |  409 +++++++
 arch/arm/mach-bcm2709/dmaer.c                    |  886 ++++++++++++++++
 arch/arm/mach-bcm2709/include/mach/arm_control.h |  493 +++++++++
 arch/arm/mach-bcm2709/include/mach/arm_power.h   |   62 ++
 arch/arm/mach-bcm2709/include/mach/barriers.h    |    3 +
 arch/arm/mach-bcm2709/include/mach/clkdev.h      |    7 +
 arch/arm/mach-bcm2709/include/mach/debug-macro.S |   22 +
 arch/arm/mach-bcm2709/include/mach/dma.h         |   94 ++
 arch/arm/mach-bcm2709/include/mach/entry-macro.S |  123 +++
 arch/arm/mach-bcm2709/include/mach/frc.h         |   38 +
 arch/arm/mach-bcm2709/include/mach/gpio.h        |   17 +
 arch/arm/mach-bcm2709/include/mach/hardware.h    |   28 +
 arch/arm/mach-bcm2709/include/mach/io.h          |   27 +
 arch/arm/mach-bcm2709/include/mach/irqs.h        |  225 ++++
 arch/arm/mach-bcm2709/include/mach/memory.h      |   57 +
 arch/arm/mach-bcm2709/include/mach/platform.h    |  225 ++++
 arch/arm/mach-bcm2709/include/mach/power.h       |   26 +
 arch/arm/mach-bcm2709/include/mach/system.h      |   38 +
 arch/arm/mach-bcm2709/include/mach/timex.h       |   23 +
 arch/arm/mach-bcm2709/include/mach/uncompress.h  |   84 ++
 arch/arm/mach-bcm2709/include/mach/vc_mem.h      |   35 +
 arch/arm/mach-bcm2709/include/mach/vc_support.h  |   69 ++
 arch/arm/mach-bcm2709/include/mach/vcio.h        |  165 +++
 arch/arm/mach-bcm2709/include/mach/vmalloc.h     |   20 +
 arch/arm/mach-bcm2709/power.c                    |  195 ++++
 arch/arm/mach-bcm2709/vc_mem.c                   |  431 ++++++++
 arch/arm/mach-bcm2709/vc_support.c               |  318 ++++++
 arch/arm/mach-bcm2709/vcio.c                     |  474 +++++++++
 arch/arm/mm/proc-v7.S                            |    1 +
 arch/arm/tools/mach-types                        |    1 +
 drivers/char/hw_random/Kconfig                   |    2 +-
 drivers/clocksource/arm_arch_timer.c             |   36 +
 drivers/dma/Kconfig                              |    2 +-
 drivers/i2c/busses/Kconfig                       |    4 +-
 drivers/media/platform/bcm2835/Kconfig           |    2 +-
 drivers/misc/vc04_services/Kconfig               |    2 +-
 drivers/misc/vc04_services/Makefile              |    3 -
 drivers/mmc/host/Kconfig                         |    2 +-
 drivers/spi/Kconfig                              |    4 +-
 drivers/watchdog/Kconfig                         |    2 +-
 sound/arm/Kconfig                                |    2 +-
 sound/soc/bcm/Kconfig                            |    2 +-
 65 files changed, 8999 insertions(+), 16 deletions(-)
 create mode 100644 arch/arm/boot/dts/bcm2709-rpi-2-b.dts
 create mode 100644 arch/arm/boot/dts/bcm2709.dtsi
 create mode 100644 arch/arm/configs/bcm2709_defconfig
 create mode 100644 arch/arm/configs/bcm2709_sdcard_defconfig
 create mode 100644 arch/arm/configs/bcm2709_small_defconfig
 create mode 100644 arch/arm/configs/bcm2835_sdcard_defconfig
 create mode 100644 arch/arm/configs/bcmrpi_sdcard_defconfig
 create mode 100644 arch/arm/configs/bcmrpi_small_defconfig
 create mode 100644 arch/arm/mach-bcm2709/Kconfig
 create mode 100644 arch/arm/mach-bcm2709/Makefile
 create mode 100644 arch/arm/mach-bcm2709/Makefile.boot
 create mode 100644 arch/arm/mach-bcm2709/armctrl.c
 create mode 100644 arch/arm/mach-bcm2709/armctrl.h
 create mode 100644 arch/arm/mach-bcm2709/bcm2708_gpio.c
 create mode 100644 arch/arm/mach-bcm2709/bcm2709.c
 create mode 100644 arch/arm/mach-bcm2709/bcm2709.h
 create mode 100644 arch/arm/mach-bcm2709/clock.c
 create mode 100644 arch/arm/mach-bcm2709/clock.h
 create mode 100644 arch/arm/mach-bcm2709/delay.S
 create mode 100644 arch/arm/mach-bcm2709/dma.c
 create mode 100755 arch/arm/mach-bcm2709/dmaer.c
 create mode 100644 arch/arm/mach-bcm2709/include/mach/arm_control.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/arm_power.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/barriers.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-bcm2709/include/mach/dma.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-bcm2709/include/mach/frc.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/gpio.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/hardware.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/io.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/irqs.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/memory.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/platform.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/power.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/system.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/timex.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/vc_mem.h
 create mode 100755 arch/arm/mach-bcm2709/include/mach/vc_support.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/vcio.h
 create mode 100644 arch/arm/mach-bcm2709/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-bcm2709/power.c
 create mode 100644 arch/arm/mach-bcm2709/vc_mem.c
 create mode 100755 arch/arm/mach-bcm2709/vc_support.c
 create mode 100644 arch/arm/mach-bcm2709/vcio.c

--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -803,6 +803,26 @@ config ARCH_OMAP1
 	help
 	  Support for older TI OMAP1 (omap7xx, omap15xx or omap16xx)
 
+config ARCH_BCM2709
+	bool "Broadcom BCM2709 family"
+	select ARCH_HAS_BARRIERS if SMP
+	select CPU_V7
+	select HAVE_SMP
+	select ARM_AMBA
+	select MIGHT_HAVE_CACHE_L2X0
+	select HAVE_SCHED_CLOCK
+	select NEED_MACH_MEMORY_H
+	select NEED_MACH_IO_H
+	select COMMON_CLK
+	select ARCH_HAS_CPUFREQ
+	select GENERIC_CLOCKEVENTS
+	select MACH_BCM2709
+	select VC4
+	select FIQ
+#	select ZONE_DMA
+	help
+	  This enables support for Broadcom BCM2709 boards.
+
 endchoice
 
 menu "Multiple platform selection"
@@ -990,6 +1010,7 @@ source "arch/arm/mach-vt8500/Kconfig"
 
 source "arch/arm/mach-w90x900/Kconfig"
 source "arch/arm/mach-bcm2708/Kconfig"
+source "arch/arm/mach-bcm2709/Kconfig"
 
 source "arch/arm/mach-zynq/Kconfig"
 
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -152,6 +152,7 @@ machine-$(CONFIG_ARCH_AT91)		+= at91
 machine-$(CONFIG_ARCH_AXXIA)		+= axxia
 machine-$(CONFIG_ARCH_BCM)		+= bcm
 machine-$(CONFIG_ARCH_BCM2708)		+= bcm2708
+machine-$(CONFIG_ARCH_BCM2709)		+= bcm2709
 machine-$(CONFIG_ARCH_BERLIN)		+= berlin
 machine-$(CONFIG_ARCH_CLPS711X)		+= clps711x
 machine-$(CONFIG_ARCH_CNS3XXX)		+= cns3xxx
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -53,6 +53,14 @@ dtb-$(CONFIG_ARCH_AT91)	+= at91-sama5d4e
 
 dtb-$(CONFIG_ARCH_ATLAS6) += atlas6-evb.dtb
 dtb-$(CONFIG_ARCH_AXXIA) += axm5516-amarillo.dtb
+
+# Raspberry Pi
+ifeq ($(CONFIG_BCM2708_DT),y)
+   RPI_DT_OVERLAYS=y
+endif
+ifeq ($(CONFIG_BCM2709_DT),y)
+   RPI_DT_OVERLAYS=y
+endif
 dtb-$(CONFIG_BCM2708_DT) += bcm2708-rpi-b.dtb
 dtb-$(CONFIG_BCM2708_DT) += bcm2708-rpi-b-plus.dtb
 dtb-$(CONFIG_BCM2708_DT) += hifiberry-dac-overlay.dtb
@@ -68,6 +76,7 @@ dtb-$(CONFIG_BCM2708_DT) += ds1307-rtc-o
 dtb-$(CONFIG_BCM2708_DT) += w1-gpio-overlay.dtb
 dtb-$(CONFIG_BCM2708_DT) += w1-gpio-pullup-overlay.dtb
 dtb-$(CONFIG_ARCH_BCM2835) += bcm2835-rpi-b.dtb
+
 dtb-$(CONFIG_ARCH_BCM_5301X) += bcm4708-netgear-r6250.dtb
 dtb-$(CONFIG_ARCH_BCM_63XX) += bcm963138dvt.dtb
 dtb-$(CONFIG_ARCH_BCM_MOBILE) += bcm28155-ap.dtb \
@@ -537,7 +546,7 @@ targets += $(dtb-y)
 endif
 
 # Enable fixups to support overlays on BCM2708 platforms
-ifeq ($(CONFIG_BCM2708_DT),y)
+ifeq ($(RPI_DT_OVERLAYS),y)
 	DTC_FLAGS ?= -@
 endif
 
--- /dev/null
+++ b/arch/arm/boot/dts/bcm2709-rpi-2-b.dts
@@ -0,0 +1,101 @@
+/dts-v1/;
+
+/include/ "bcm2709.dtsi"
+
+/ {
+	compatible = "brcm,bcm2709";
+	model = "Raspberry Pi 2 Model B";
+
+	aliases {
+		soc = &soc;
+		spi0 = &spi0;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2s  = &i2s;
+		gpio = &gpio;
+		intc = &intc;
+		leds = &leds;
+		sound = &sound;
+	};
+
+	sound: sound {
+	};
+};
+
+&gpio {
+	spi0_pins: spi0_pins {
+		brcm,pins = <7 8 9 10 11>;
+		brcm,function = <4>; /* alt0 */
+	};
+
+	i2c0_pins: i2c0 {
+		brcm,pins = <0 1>;
+		brcm,function = <4>;
+	};
+
+	i2c1_pins: i2c1 {
+		brcm,pins = <2 3>;
+		brcm,function = <4>;
+	};
+
+	i2s_pins: i2s {
+		brcm,pins = <18 19 20 21>;
+		brcm,function = <4>; /* alt0 */
+	};
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+
+	spidev@0{
+		compatible = "spidev";
+		reg = <0>;	/* CE0 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <500000>;
+	};
+
+	spidev@1{
+		compatible = "spidev";
+		reg = <1>;	/* CE1 */
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <500000>;
+	};
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+	clock-frequency = <100000>;
+};
+
+&i2c1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1_pins>;
+	clock-frequency = <100000>;
+};
+
+&i2s {
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s_pins>;
+};
+
+&act_led {
+	gpios = <&gpio 47 0>;
+};
+
+/ {
+	__overrides__ {
+		i2s = <&i2s>,"status";
+		spi = <&spi0>,"status";
+		i2c0 = <&i2c0>,"status";
+		i2c1 = <&i2c1>,"status";
+
+		act_led_gpio = <&act_led>,"gpios:4";
+		act_led_activelow = <&act_led>,"gpios:8";
+		act_led_trigger = <&act_led>,"linux,default-trigger";
+	};
+};
--- /dev/null
+++ b/arch/arm/boot/dts/bcm2709.dtsi
@@ -0,0 +1,159 @@
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "brcm,bcm2709";
+	model = "BCM2709";
+
+	interrupt-parent = <&intc>;
+
+	chosen {
+		/* No padding required - the boot loader can do that. */
+		bootargs = "";
+	};
+
+	soc: soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x7e000000 0x3f000000 0x01000000>;
+
+		intc: interrupt-controller {
+			compatible = "brcm,bcm2708-armctrl-ic";
+			reg = <0x7e00b200 0x200>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		gpio: gpio {
+			compatible = "brcm,bcm2835-gpio";
+			reg = <0x7e200000 0xb4>;
+			interrupts = <2 17>, <2 18>;
+
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+
+		i2s: i2s@7e203000 {
+			compatible = "brcm,bcm2708-i2s";
+			reg = <0x7e203000 0x20>,
+			      <0x7e101098 0x02>;
+
+			//dmas = <&dma 2>,
+			//       <&dma 3>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		spi0: spi@7e204000 {
+			compatible = "brcm,bcm2708-spi";
+			reg = <0x7e204000 0x1000>;
+			interrupts = <2 22>;
+			clocks = <&clk_spi>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@7e205000 {
+			compatible = "brcm,bcm2708-i2c";
+			reg = <0x7e205000 0x1000>;
+			interrupts = <2 21>;
+			clocks = <&clk_i2c>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@7e804000 {
+			compatible = "brcm,bcm2708-i2c";
+			reg = <0x7e804000 0x1000>;
+			interrupts = <2 21>;
+			clocks = <&clk_i2c>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		leds: leds {
+			compatible = "gpio-leds";
+
+			act_led: act {
+				label = "ACT";
+				linux,default-trigger = "mmc0";
+			};
+		};
+	};
+
+	clocks {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		clk_i2c: i2c {
+			compatible = "fixed-clock";
+			reg = <1>;
+			#clock-cells = <0>;
+			clock-frequency = <250000000>;
+		};
+
+		clk_spi: clock@2 {
+			compatible = "fixed-clock";
+			reg = <2>;
+			#clock-cells = <0>;
+			clock-output-names = "spi";
+			clock-frequency = <250000000>;
+		};
+	};
+
+	timer {
+		compatible = "arm,armv7-timer";
+		clock-frequency = <19200000>;
+		interrupts = <3 0>, // PHYS_SECURE_PPI
+			     <3 1>, // PHYS_NONSECURE_PPI
+			     <3 3>, // VIRT_PPI
+			     <3 2>; // HYP_PPI
+	};
+
+	cpus: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		v7_cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0xf00>;
+			clock-frequency = <800000000>;
+		};
+
+		v7_cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0xf01>;
+			clock-frequency = <800000000>;
+		};
+
+		v7_cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0xf02>;
+			clock-frequency = <800000000>;
+		};
+
+		v7_cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a7";
+			reg = <0xf03>;
+			clock-frequency = <800000000>;
+		};
+	};
+
+	__overrides__ {
+		arm_freq = <&v7_cpu0>, "clock-frequency:0",
+		       <&v7_cpu1>, "clock-frequency:0",
+		       <&v7_cpu2>, "clock-frequency:0",
+		       <&v7_cpu3>, "clock-frequency:0";
+	};
+};
--- /dev/null
+++ b/arch/arm/configs/bcm2709_defconfig
@@ -0,0 +1,1149 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_PHYS_OFFSET=0
+CONFIG_LOCALVERSION="-v7"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_FHANDLE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_NAMESPACES=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_MAC_PARTITION=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_BCM2709=y
+CONFIG_BCM2709_DT=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_VMSPLIT_2G=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_CLEANCACHE=y
+CONFIG_FRONTSWAP=y
+CONFIG_CMA=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_SECCOMP=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
+CONFIG_KEXEC=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=m
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_BINFMT_MISC=m
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=m
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=m
+CONFIG_INET_DIAG=m
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_NETFILTER=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_ZONES=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_XT_SET=m
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_BPF=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLABEL=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_IP_VS_PROTO_SCTP=y
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_PE_SIP=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_IP6_NF_TARGET_NPT=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+CONFIG_SCTP_COOKIE_HMAC_SHA1=y
+CONFIG_ATM=m
+CONFIG_L2TP=m
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=m
+CONFIG_L2TP_ETH=m
+CONFIG_BRIDGE=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_ATALK=m
+CONFIG_NET_SCHED=y
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+CONFIG_NET_SCH_QFQ=m
+CONFIG_NET_SCH_CODEL=m
+CONFIG_NET_SCH_FQ_CODEL=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_NET_SCH_PLUG=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_EMATCH_IPSET=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_NET_ACT_SIMP=m
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_CSUM=m
+CONFIG_BATMAN_ADV=m
+CONFIG_OPENVSWITCH=m
+CONFIG_NET_PKTGEN=m
+CONFIG_HAMRADIO=y
+CONFIG_AX25=m
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+CONFIG_BAYCOM_SER_FDX=m
+CONFIG_BAYCOM_SER_HDX=m
+CONFIG_YAM=m
+CONFIG_IRDA=m
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+CONFIG_IRDA_ULTRA=y
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+CONFIG_IRDA_FAST_RR=y
+CONFIG_IRTTY_SIR=m
+CONFIG_KINGSUN_DONGLE=m
+CONFIG_KSDAZZLE_DONGLE=m
+CONFIG_KS959_DONGLE=m
+CONFIG_USB_IRDA=m
+CONFIG_SIGMATEL_FIR=m
+CONFIG_MCS_FIR=m
+CONFIG_BT=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_HCIVHCI=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_ATH3K=m
+CONFIG_BT_WILINK=m
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=m
+CONFIG_MAC80211_MESH=y
+CONFIG_WIMAX=m
+CONFIG_RFKILL=m
+CONFIG_RFKILL_INPUT=y
+CONFIG_NET_9P=m
+CONFIG_NFC=m
+CONFIG_NFC_PN533=m
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=5
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+CONFIG_BLK_DEV_DRBD=m
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_CDROM_PKTCDVD=m
+CONFIG_EEPROM_AT24=m
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=m
+CONFIG_CHR_DEV_SG=m
+CONFIG_SCSI_ISCSI_ATTRS=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_BOOT_SYSFS=m
+CONFIG_MD=y
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_BLK_DEV_DM=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_RAID=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_DELAY=m
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=m
+CONFIG_DUMMY=m
+CONFIG_IFB=m
+CONFIG_MACVLAN=m
+CONFIG_NETCONSOLE=m
+CONFIG_TUN=m
+CONFIG_VETH=m
+CONFIG_MDIO_BITBANG=m
+CONFIG_PPP=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOATM=m
+CONFIG_PPPOE=m
+CONFIG_PPPOL2TP=m
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_SLIP=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_SLIP_SMART=y
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=m
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_AX88179_178A=m
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_USB_NET_CDC_EEM=m
+CONFIG_USB_NET_CDC_NCM=m
+CONFIG_USB_NET_HUAWEI_CDC_NCM=m
+CONFIG_USB_NET_CDC_MBIM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SR9700=m
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=y
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_KALMIA=m
+CONFIG_USB_NET_QMI_WWAN=m
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_IPHETH=m
+CONFIG_USB_SIERRA_NET=m
+CONFIG_USB_VL600=m
+CONFIG_LIBERTAS_THINFIRM=m
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_AT76C50X_USB=m
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8187=m
+CONFIG_MAC80211_HWSIM=m
+CONFIG_ATH_CARDS=m
+CONFIG_ATH9K=m
+CONFIG_ATH9K_HTC=m
+CONFIG_CARL9170=m
+CONFIG_ATH6KL=m
+CONFIG_ATH6KL_USB=m
+CONFIG_AR5523=m
+CONFIG_B43=m
+# CONFIG_B43_PHY_N is not set
+CONFIG_B43LEGACY=m
+CONFIG_BRCMFMAC=m
+CONFIG_BRCMFMAC_USB=y
+CONFIG_HOSTAP=m
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+CONFIG_LIBERTAS_SDIO=m
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+CONFIG_RT2X00=m
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT3573=y
+CONFIG_RT2800USB_RT53XX=y
+CONFIG_RT2800USB_RT55XX=y
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RTL8192CU=m
+CONFIG_ZD1211RW=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_INPUT_POLLDEV=m
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_JOYDEV=m
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_IFORCE=m
+CONFIG_JOYSTICK_IFORCE_USB=y
+CONFIG_JOYSTICK_XPAD=m
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_AD714X=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_GPIO_ROTARY_ENCODER=m
+CONFIG_INPUT_ADXL34X=m
+CONFIG_INPUT_CMA3000=m
+CONFIG_SERIO=m
+CONFIG_SERIO_RAW=m
+CONFIG_GAMEPORT=m
+CONFIG_GAMEPORT_NS558=m
+CONFIG_GAMEPORT_L4=m
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_TTY_PRINTK=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_BCM2708=m
+CONFIG_RAW_DRIVER=y
+CONFIG_BRCM_CHAR_DRIVERS=y
+CONFIG_BCM_VC_CMA=y
+CONFIG_BCM_VC_SM=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=m
+CONFIG_I2C_MUX=m
+CONFIG_I2C_BCM2708=m
+CONFIG_SPI=y
+CONFIG_SPI_BCM2708=m
+CONFIG_SPI_SPIDEV=y
+CONFIG_PPS=m
+CONFIG_PPS_CLIENT_LDISC=m
+CONFIG_PPS_CLIENT_GPIO=m
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_ARIZONA=m
+CONFIG_W1=m
+CONFIG_W1_MASTER_DS2490=m
+CONFIG_W1_MASTER_DS2482=m
+CONFIG_W1_MASTER_DS1WM=m
+CONFIG_W1_MASTER_GPIO=m
+CONFIG_W1_SLAVE_THERM=m
+CONFIG_W1_SLAVE_SMEM=m
+CONFIG_W1_SLAVE_DS2408=m
+CONFIG_W1_SLAVE_DS2413=m
+CONFIG_W1_SLAVE_DS2406=m
+CONFIG_W1_SLAVE_DS2423=m
+CONFIG_W1_SLAVE_DS2431=m
+CONFIG_W1_SLAVE_DS2433=m
+CONFIG_W1_SLAVE_DS2760=m
+CONFIG_W1_SLAVE_DS2780=m
+CONFIG_W1_SLAVE_DS2781=m
+CONFIG_W1_SLAVE_DS28E04=m
+CONFIG_W1_SLAVE_BQ27000=m
+CONFIG_BATTERY_DS2760=m
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_BCM2835=y
+CONFIG_WATCHDOG=y
+CONFIG_BCM2708_WDT=m
+CONFIG_UCB1400_CORE=m
+CONFIG_MFD_ARIZONA_I2C=m
+CONFIG_MFD_ARIZONA_SPI=m
+CONFIG_MFD_WM5102=y
+CONFIG_MEDIA_SUPPORT=m
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=y
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+CONFIG_MEDIA_RADIO_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_LIRC=m
+CONFIG_RC_DEVICES=y
+CONFIG_RC_ATI_REMOTE=m
+CONFIG_IR_IMON=m
+CONFIG_IR_MCEUSB=m
+CONFIG_IR_REDRAT3=m
+CONFIG_IR_STREAMZAP=m
+CONFIG_IR_IGUANA=m
+CONFIG_IR_TTUSBIR=m
+CONFIG_RC_LOOPBACK=m
+CONFIG_IR_GPIO_CIR=m
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_DTCS033=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_JL2005BCD=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STK1135=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TOPRO=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_USB_PWC=m
+CONFIG_VIDEO_CPIA2=m
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+CONFIG_VIDEO_USBTV=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_TLG2300=m
+CONFIG_VIDEO_USBVISION=m
+CONFIG_VIDEO_STK1160_COMMON=m
+CONFIG_VIDEO_STK1160_AC97=y
+CONFIG_VIDEO_GO7007=m
+CONFIG_VIDEO_GO7007_USB=m
+CONFIG_VIDEO_GO7007_USB_S2250_BOARD=m
+CONFIG_VIDEO_AU0828=m
+CONFIG_VIDEO_AU0828_RC=y
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_VIDEO_TM6000=m
+CONFIG_VIDEO_TM6000_ALSA=m
+CONFIG_VIDEO_TM6000_DVB=m
+CONFIG_DVB_USB=m
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_DVB_USB_DIBUSB_MB_FAULTY=y
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_PCTV452E=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_DVB_USB_AZ6027=m
+CONFIG_DVB_USB_TECHNISAT_USB2=m
+CONFIG_DVB_USB_V2=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_AF9035=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_AZ6007=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_EC168=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_LME2510=m
+CONFIG_DVB_USB_MXL111SF=m
+CONFIG_DVB_USB_RTL28XXU=m
+CONFIG_SMS_USB_DRV=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+CONFIG_DVB_AS102=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_BCM2835=y
+CONFIG_VIDEO_BCM2835_MMAL=m
+CONFIG_RADIO_SI470X=y
+CONFIG_USB_SI470X=m
+CONFIG_I2C_SI470X=m
+CONFIG_RADIO_SI4713=m
+CONFIG_I2C_SI4713=m
+CONFIG_USB_MR800=m
+CONFIG_USB_DSBR=m
+CONFIG_RADIO_SHARK=m
+CONFIG_RADIO_SHARK2=m
+CONFIG_USB_KEENE=m
+CONFIG_USB_MA901=m
+CONFIG_RADIO_TEA5764=m
+CONFIG_RADIO_SAA7706H=m
+CONFIG_RADIO_TEF6862=m
+CONFIG_RADIO_WL1273=m
+CONFIG_RADIO_WL128X=m
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+CONFIG_VIDEO_UDA1342=m
+CONFIG_VIDEO_SONY_BTF_MPX=m
+CONFIG_VIDEO_TVP5150=m
+CONFIG_VIDEO_TW2804=m
+CONFIG_VIDEO_TW9903=m
+CONFIG_VIDEO_TW9906=m
+CONFIG_VIDEO_OV7640=m
+CONFIG_VIDEO_MT9V011=m
+CONFIG_FB=y
+CONFIG_FB_BCM2708=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_DUMMY=m
+CONFIG_SND_ALOOP=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_SND_MTPAV=m
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_SND_MPU401=m
+CONFIG_SND_BCM2835=m
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+CONFIG_SND_USB_CAIAQ_INPUT=y
+CONFIG_SND_USB_6FIRE=m
+CONFIG_SND_SOC=m
+CONFIG_SND_BCM2708_SOC_I2S=m
+CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC=m
+CONFIG_SND_BCM2708_SOC_HIFIBERRY_DACPLUS=m
+CONFIG_SND_BCM2708_SOC_HIFIBERRY_DIGI=m
+CONFIG_SND_BCM2708_SOC_HIFIBERRY_AMP=m
+CONFIG_SND_BCM2708_SOC_RPI_DAC=m
+CONFIG_SND_BCM2708_SOC_IQAUDIO_DAC=m
+CONFIG_SND_SIMPLE_CARD=m
+CONFIG_SOUND_PRIME=m
+CONFIG_HIDRAW=y
+CONFIG_HID_A4TECH=m
+CONFIG_HID_ACRUX=m
+CONFIG_HID_APPLE=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_ELECOM=m
+CONFIG_HID_ELO=m
+CONFIG_HID_EZKEY=m
+CONFIG_HID_HOLTEK=m
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=m
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+CONFIG_HID_LCPOWER=m
+CONFIG_HID_LOGITECH=m
+CONFIG_HID_MAGICMOUSE=m
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THINGM=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_HID_WACOM=m
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_XINMO=m
+CONFIG_HID_ZEROPLUS=m
+CONFIG_HID_ZYDACRON=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_MON=m
+CONFIG_USB_DWCOTG=y
+CONFIG_USB_PRINTER=m
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_REALTEK=m
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_ENE_UB6250=m
+CONFIG_USB_UAS=m
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_F81232=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_METRO=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+CONFIG_USB_SERIAL_XSENS_MT=m
+CONFIG_USB_SERIAL_WISHBONE=m
+CONFIG_USB_SERIAL_SSU100=m
+CONFIG_USB_SERIAL_QT2=m
+CONFIG_USB_SERIAL_DEBUG=m
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+CONFIG_USB_TEST=m
+CONFIG_USB_ISIGHTFW=m
+CONFIG_USB_YUREX=m
+CONFIG_USB_ATM=m
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_USB_CXACRU=m
+CONFIG_USB_UEAGLEATM=m
+CONFIG_USB_XUSBATM=m
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_BCM2835=y
+CONFIG_MMC_BCM2835_DMA=y
+CONFIG_MMC_SPI=m
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGER_TRANSIENT=m
+CONFIG_LEDS_TRIGGER_CAMERA=m
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_RTC_DRV_DS1374=m
+CONFIG_RTC_DRV_DS1672=m
+CONFIG_RTC_DRV_DS3232=m
+CONFIG_RTC_DRV_MAX6900=m
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_RTC_DRV_ISL12022=m
+CONFIG_RTC_DRV_ISL12057=m
+CONFIG_RTC_DRV_X1205=m
+CONFIG_RTC_DRV_PCF2127=m
+CONFIG_RTC_DRV_PCF8523=m
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_RTC_DRV_M41T80=m
+CONFIG_RTC_DRV_BQ32K=m
+CONFIG_RTC_DRV_S35390A=m
+CONFIG_RTC_DRV_FM3130=m
+CONFIG_RTC_DRV_RX8581=m
+CONFIG_RTC_DRV_RX8025=m
+CONFIG_RTC_DRV_EM3027=m
+CONFIG_RTC_DRV_RV3029C2=m
+CONFIG_RTC_DRV_M41T93=m
+CONFIG_RTC_DRV_M41T94=m
+CONFIG_RTC_DRV_DS1305=m
+CONFIG_RTC_DRV_DS1390=m
+CONFIG_RTC_DRV_MAX6902=m
+CONFIG_RTC_DRV_R9701=m
+CONFIG_RTC_DRV_RS5C348=m
+CONFIG_RTC_DRV_DS3234=m
+CONFIG_RTC_DRV_PCF2123=m
+CONFIG_RTC_DRV_RX4581=m
+CONFIG_DMADEVICES=y
+CONFIG_DMA_BCM2708=y
+CONFIG_UIO=m
+CONFIG_UIO_PDRV_GENIRQ=m
+CONFIG_STAGING=y
+CONFIG_PRISM2_USB=m
+CONFIG_R8712U=m
+CONFIG_R8188EU=m
+CONFIG_R8723AU=m
+CONFIG_VT6656=m
+CONFIG_SPEAKUP=m
+CONFIG_SPEAKUP_SYNTH_SOFT=m
+CONFIG_STAGING_MEDIA=y
+CONFIG_LIRC_STAGING=y
+CONFIG_LIRC_IGORPLUGUSB=m
+CONFIG_LIRC_IMON=m
+CONFIG_LIRC_RPI=m
+CONFIG_LIRC_SASEM=m
+CONFIG_LIRC_SERIAL=m
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXTCON=m
+CONFIG_EXTCON_ARIZONA=m
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_REISERFS_FS=m
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+CONFIG_JFS_STATISTICS=y
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+CONFIG_GFS2_FS=m
+CONFIG_OCFS2_FS=m
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_NILFS2_FS=m
+CONFIG_FANOTIFY=y
+CONFIG_QFMT_V1=m
+CONFIG_QFMT_V2=m
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_FSCACHE_HISTOGRAM=y
+CONFIG_CACHEFILES=y
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=m
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_ECRYPT_FS=m
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_F2FS_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_SWAP=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFS_FSCACHE=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_CIFS=m
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+CONFIG_9P_FS=m
+CONFIG_9P_FS_POSIX_ACL=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_DLM=m
+CONFIG_PRINTK_TIME=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_IRQSOFF_TRACER=y
+CONFIG_SCHED_TRACER=y
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_KPROBE_EVENT is not set
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_KGDB=y
+CONFIG_KGDB_KDB=y
+CONFIG_KDB_KEYBOARD=y
+CONFIG_CRYPTO_USER=m
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_XTS=m
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_SHA1_ARM_NEON=m
+CONFIG_CRYPTO_SHA512_ARM_NEON=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+CONFIG_CRYPTO_AES_ARM_BS=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
--- /dev/null
+++ b/arch/arm/configs/bcm2709_sdcard_defconfig
@@ -0,0 +1,129 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_PHYS_OFFSET=0x0
+CONFIG_LOCALVERSION="-sdcard"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_FHANDLE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_NAMESPACES=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EMBEDDED=y
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_JUMP_LABEL=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_ARCH_BCM2709=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_CMA=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_SECCOMP=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+# CONFIG_COREDUMP is not set
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_UNIX=y
+CONFIG_CGROUP_NET_CLASSID=y
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=8
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_TTY_PRINTK=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_BRCM_CHAR_DRIVERS=y
+CONFIG_BCM_VC_CMA=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_FB=y
+CONFIG_FB_BCM2708=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_BCM2835=y
+CONFIG_MMC_BCM2835_DMA=y
+CONFIG_DMADEVICES=y
+CONFIG_DMA_BCM2708=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_FANOTIFY=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_FSCACHE_HISTOGRAM=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ASCII=y
+CONFIG_PRINTK_TIME=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DEBUG_FS=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_KEYS=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
+CONFIG_AVERAGE=y
--- /dev/null
+++ b/arch/arm/configs/bcm2709_small_defconfig
@@ -0,0 +1,61 @@
+CONFIG_LOCALVERSION="-small"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="../target_fs"
+CONFIG_SLAB=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_BCM2709=y
+# CONFIG_BCM2708_GPIO is not set
+# CONFIG_BCM2708_VCMEM is not set
+CONFIG_ARM_THUMBEE=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_SMP=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+# CONFIG_COMPACTION is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="earlyprintk=ttyAMA0,19200 loglevel=9 console=ttyAMA0,19200"
+CONFIG_AUTO_ZRELADDR=y
+CONFIG_BINFMT_MISC=y
+# CONFIG_SUSPEND is not set
+# CONFIG_UEVENT_HELPER is not set
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_PRINTK_TIME=y
+CONFIG_FRAME_WARN=4096
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_FTRACE is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRC16=y
+CONFIG_CRC_ITU_T=y
--- /dev/null
+++ b/arch/arm/configs/bcm2835_sdcard_defconfig
@@ -0,0 +1,176 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_LOCALVERSION="-quick"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_BCM2708=y
+# CONFIG_BCM2708_GPIO is not set
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_BINFMT_MISC=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_TTY_PRINTK=y
+CONFIG_RAW_DRIVER=y
+CONFIG_WATCHDOG=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_VIRTUAL_CONSUMER=y
+CONFIG_REGULATOR_USERSPACE_CONSUMER=y
+CONFIG_FB=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_BCM2708=y
+CONFIG_MMC_SDHCI_BCM2708_DMA=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FSCACHE=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFS_FSCACHE=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_FS=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_KGDB=y
+CONFIG_KGDB_KDB=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
--- /dev/null
+++ b/arch/arm/configs/bcmrpi_sdcard_defconfig
@@ -0,0 +1,176 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_LOCALVERSION="-quick"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_EMBEDDED=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_SLAB=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_BCM2708=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_BINFMT_MISC=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_WIRELESS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_SCSI=y
+# CONFIG_SCSI_PROC_FS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_TTY_PRINTK=y
+CONFIG_RAW_DRIVER=y
+CONFIG_WATCHDOG=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_VIRTUAL_CONSUMER=y
+CONFIG_REGULATOR_USERSPACE_CONSUMER=y
+CONFIG_FB=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_BCM2708=y
+CONFIG_MMC_SDHCI_BCM2708_DMA=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FSCACHE=y
+CONFIG_CACHEFILES=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_CONFIGFS_FS=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NFS_FSCACHE=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_FS=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_FTRACE is not set
+CONFIG_KGDB=y
+CONFIG_KGDB_KDB=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
--- /dev/null
+++ b/arch/arm/configs/bcmrpi_small_defconfig
@@ -0,0 +1,103 @@
+CONFIG_LOCALVERSION="-quick"
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_PERF_EVENTS=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_BCM2836=y
+# CONFIG_BCM2708_GPIO is not set
+# CONFIG_BCM2708_VCMEM is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT=y
+CONFIG_AEABI=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait"
+CONFIG_CPU_IDLE=y
+# CONFIG_SUSPEND is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+# CONFIG_BCM2708_VCHIQ is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+CONFIG_RAW_DRIVER=y
+# CONFIG_HID is not set
+CONFIG_DMADEVICES=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_FTRACE is not set
+CONFIG_KGDB=y
+CONFIG_KGDB_KDB=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC16=y
+CONFIG_CRC_ITU_T=y
+CONFIG_LIBCRC32C=y
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -673,6 +673,14 @@ ARM_BE8(rev16	ip, ip)
 	ldrcc	r7, [r4], #4	@ use branch for delay slot
 	bcc	1b
 	ret	lr
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
 #endif
 ENDPROC(__fixup_a_pv_table)
 
--- /dev/null
+++ b/arch/arm/mach-bcm2709/Kconfig
@@ -0,0 +1,49 @@
+menu "Broadcom BCM2709 Implementations"
+	depends on ARCH_BCM2709
+
+config MACH_BCM2709
+	bool "Broadcom BCM2709 Development Platform"
+	help
+	  Include support for the Broadcom(R) BCM2709 platform.
+
+config BCM2709_DT
+	bool "BCM2709 Device Tree support"
+	depends on MACH_BCM2709
+	default n
+	select USE_OF
+	select ARCH_REQUIRE_GPIOLIB
+	select PINCTRL
+	select PINCTRL_BCM2835
+	help
+	  Enable Device Tree support for BCM2709
+
+config BCM2708_GPIO
+	bool "BCM2709 gpio support"
+	depends on MACH_BCM2709
+	select ARCH_REQUIRE_GPIOLIB
+        default y
+	help
+	  Include support for the Broadcom(R) BCM2709 gpio.
+
+config BCM2708_VCMEM
+	bool "Videocore Memory"
+	depends on MACH_BCM2709
+        default y
+        help
+          Helper for videocore memory access and total size allocation.
+
+config BCM2708_NOL2CACHE
+	bool "Videocore L2 cache disable"
+	depends on MACH_BCM2709
+        default y
+        help
+          Do not allow ARM to use GPU's L2 cache. Requires disable_l2cache in config.txt.
+
+config BCM2708_SPIDEV
+	bool "Bind spidev to SPI0 master"
+	depends on MACH_BCM2709
+	depends on SPI
+	default y
+	help
+	  Binds spidev driver to the SPI0 master
+endmenu
--- /dev/null
+++ b/arch/arm/mach-bcm2709/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux kernel.
+#
+
+obj-$(CONFIG_MACH_BCM2709) 	+= bcm2709.o armctrl.o vcio.o power.o dma.o
+obj-$(CONFIG_BCM2708_GPIO)	+= bcm2708_gpio.o
+obj-$(CONFIG_BCM2708_VCMEM)	+= vc_mem.o
--- /dev/null
+++ b/arch/arm/mach-bcm2709/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x00008000
+params_phys-y	:= 0x00000100
+initrd_phys-y	:= 0x00800000
--- /dev/null
+++ b/arch/arm/mach-bcm2709/armctrl.c
@@ -0,0 +1,357 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/armctrl.c
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/version.h>
+#include <linux/syscore_ops.h>
+#include <linux/interrupt.h>
+#include <linux/irqdomain.h>
+#include <linux/of.h>
+
+#include <asm/mach/irq.h>
+#include <mach/hardware.h>
+#include "armctrl.h"
+
+/* For support of kernels >= 3.0 assume only one VIC for now*/
+static unsigned int remap_irqs[(INTERRUPT_ARASANSDIO + 1) - INTERRUPT_JPEG] = {
+	INTERRUPT_VC_JPEG,
+	INTERRUPT_VC_USB,
+	INTERRUPT_VC_3D,
+	INTERRUPT_VC_DMA2,
+	INTERRUPT_VC_DMA3,
+	INTERRUPT_VC_I2C,
+	INTERRUPT_VC_SPI,
+	INTERRUPT_VC_I2SPCM,
+	INTERRUPT_VC_SDIO,
+	INTERRUPT_VC_UART,
+	INTERRUPT_VC_ARASANSDIO
+};
+
+static void armctrl_mask_irq(struct irq_data *d)
+{
+	static const unsigned int disables[4] = {
+		ARM_IRQ_DIBL1,
+		ARM_IRQ_DIBL2,
+		ARM_IRQ_DIBL3,
+		0
+	};
+	int i;
+	if (d->irq >= FIQ_START) {
+		writel(0, __io_address(ARM_IRQ_FAST));
+	} else if (d->irq >= IRQ_ARM_LOCAL_CNTPSIRQ && d->irq < IRQ_ARM_LOCAL_CNTPSIRQ + 4) {
+#if 1
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq) - IRQ_ARM_LOCAL_CNTPSIRQ;
+		for (i=0; i<4; i++) // i = raw_smp_processor_id(); //
+		{
+			unsigned int val =   readl(__io_address(ARM_LOCAL_TIMER_INT_CONTROL0 + 4*i));
+			writel(val &~ (1 << data), __io_address(ARM_LOCAL_TIMER_INT_CONTROL0 + 4*i));
+		}
+#endif
+	} else if (d->irq >= IRQ_ARM_LOCAL_MAILBOX0 && d->irq < IRQ_ARM_LOCAL_MAILBOX0 + 4) {
+#if 0
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq) - IRQ_ARM_LOCAL_MAILBOX0;
+		for (i=0; i<4; i++) {
+			unsigned int val = readl(__io_address(ARM_LOCAL_MAILBOX_INT_CONTROL0 + 4*i));
+			writel(val &~ (1 << data), __io_address(ARM_LOCAL_MAILBOX_INT_CONTROL0 + 4*i));
+		}
+#endif
+	} else if (d->irq >= ARM_IRQ1_BASE && d->irq < ARM_IRQ_LOCAL_BASE) {
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq);
+		writel(1 << (data & 0x1f), __io_address(disables[(data >> 5) & 0x3]));
+	} else { printk("%s: %d\n", __func__, d->irq); BUG(); }
+}
+
+static void armctrl_unmask_irq(struct irq_data *d)
+{
+	static const unsigned int enables[4] = {
+		ARM_IRQ_ENBL1,
+		ARM_IRQ_ENBL2,
+		ARM_IRQ_ENBL3,
+		0
+	};
+	int i;
+	if (d->irq >= FIQ_START) {
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq) - FIQ_START;
+		writel(0x80 | data, __io_address(ARM_IRQ_FAST));
+	} else if (d->irq >= IRQ_ARM_LOCAL_CNTPSIRQ && d->irq < IRQ_ARM_LOCAL_CNTPSIRQ + 4) {
+#if 1
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq) - IRQ_ARM_LOCAL_CNTPSIRQ;
+		for (i=0; i<4; i++) // i = raw_smp_processor_id();
+		{
+			unsigned int val =  readl(__io_address(ARM_LOCAL_TIMER_INT_CONTROL0 + 4*i));
+			writel(val | (1 << data), __io_address(ARM_LOCAL_TIMER_INT_CONTROL0 + 4*i));
+		}
+#endif
+	} else if (d->irq >= IRQ_ARM_LOCAL_MAILBOX0 && d->irq < IRQ_ARM_LOCAL_MAILBOX0 + 4) {
+#if 0
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq) - IRQ_ARM_LOCAL_MAILBOX0;
+		for (i=0; i<4; i++) {
+			unsigned int val = readl(__io_address(ARM_LOCAL_MAILBOX_INT_CONTROL0 + 4*i));
+			writel(val | (1 << data), __io_address(ARM_LOCAL_MAILBOX_INT_CONTROL0 + 4*i));
+		}
+#endif
+	} else if (d->irq >= ARM_IRQ1_BASE && d->irq < ARM_IRQ_LOCAL_BASE) {
+		unsigned int data = (unsigned int)irq_get_chip_data(d->irq);
+		writel(1 << (data & 0x1f), __io_address(enables[(data >> 5) & 0x3]));
+	} else { printk("%s: %d\n", __func__, d->irq); BUG(); }
+}
+
+#ifdef CONFIG_OF
+
+#define NR_IRQS_BANK0           21
+#define NR_BANKS                4
+#define IRQS_PER_BANK           32
+
+/* from drivers/irqchip/irq-bcm2835.c */
+static int armctrl_xlate(struct irq_domain *d, struct device_node *ctrlr,
+        const u32 *intspec, unsigned int intsize,
+        unsigned long *out_hwirq, unsigned int *out_type)
+{
+        if (WARN_ON(intsize != 2))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[0] >= NR_BANKS))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[1] >= IRQS_PER_BANK))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[0] == 0 && intspec[1] >= NR_IRQS_BANK0))
+                return -EINVAL;
+
+        if (WARN_ON(intspec[0] == 3 && intspec[1] > 3 && intspec[1] != 5))
+                return -EINVAL;
+
+	if (intspec[0] == 0)
+		*out_hwirq = ARM_IRQ0_BASE + intspec[1];
+	else if (intspec[0] == 1)
+		*out_hwirq = ARM_IRQ1_BASE + intspec[1];
+	else if (intspec[0] == 2)
+		*out_hwirq = ARM_IRQ2_BASE + intspec[1];
+	else
+		*out_hwirq = ARM_IRQ_LOCAL_BASE + intspec[1];
+
+	/* reverse remap_irqs[] */
+	switch (*out_hwirq) {
+	case INTERRUPT_VC_JPEG:
+		*out_hwirq = INTERRUPT_JPEG;
+		break;
+	case INTERRUPT_VC_USB:
+		*out_hwirq = INTERRUPT_USB;
+		break;
+	case INTERRUPT_VC_3D:
+		*out_hwirq = INTERRUPT_3D;
+		break;
+	case INTERRUPT_VC_DMA2:
+		*out_hwirq = INTERRUPT_DMA2;
+		break;
+	case INTERRUPT_VC_DMA3:
+		*out_hwirq = INTERRUPT_DMA3;
+		break;
+	case INTERRUPT_VC_I2C:
+		*out_hwirq = INTERRUPT_I2C;
+		break;
+	case INTERRUPT_VC_SPI:
+		*out_hwirq = INTERRUPT_SPI;
+		break;
+	case INTERRUPT_VC_I2SPCM:
+		*out_hwirq = INTERRUPT_I2SPCM;
+		break;
+	case INTERRUPT_VC_SDIO:
+		*out_hwirq = INTERRUPT_SDIO;
+		break;
+	case INTERRUPT_VC_UART:
+		*out_hwirq = INTERRUPT_UART;
+		break;
+	case INTERRUPT_VC_ARASANSDIO:
+		*out_hwirq = INTERRUPT_ARASANSDIO;
+		break;
+	}
+
+        *out_type = IRQ_TYPE_NONE;
+        return 0;
+}
+
+static struct irq_domain_ops armctrl_ops = {
+        .xlate = armctrl_xlate
+};
+
+void __init armctrl_dt_init(void)
+{
+	struct device_node *np;
+	struct irq_domain *domain;
+
+	np = of_find_compatible_node(NULL, NULL, "brcm,bcm2708-armctrl-ic");
+	if (!np)
+		return;
+
+	domain = irq_domain_add_legacy(np, BCM2708_ALLOC_IRQS,
+					IRQ_ARMCTRL_START, 0,
+					&armctrl_ops, NULL);
+        WARN_ON(!domain);
+}
+#else
+void __init armctrl_dt_init(void) { }
+#endif /* CONFIG_OF */
+
+#if defined(CONFIG_PM)
+
+/* for kernels 3.xx use the new syscore_ops apis but for older kernels use the sys dev class */
+
+/* Static defines
+ * struct armctrl_device - VIC PM device (< 3.xx)
+ * @sysdev: The system device which is registered. (< 3.xx)
+ * @irq: The IRQ number for the base of the VIC.
+ * @base: The register base for the VIC.
+ * @resume_sources: A bitmask of interrupts for resume.
+ * @resume_irqs: The IRQs enabled for resume.
+ * @int_select: Save for VIC_INT_SELECT.
+ * @int_enable: Save for VIC_INT_ENABLE.
+ * @soft_int: Save for VIC_INT_SOFT.
+ * @protect: Save for VIC_PROTECT.
+ */
+struct armctrl_info {
+	void __iomem *base;
+	int irq;
+	u32 resume_sources;
+	u32 resume_irqs;
+	u32 int_select;
+	u32 int_enable;
+	u32 soft_int;
+	u32 protect;
+} armctrl;
+
+static int armctrl_suspend(void)
+{
+	return 0;
+}
+
+static void armctrl_resume(void)
+{
+	return;
+}
+
+/**
+ * armctrl_pm_register - Register a VIC for later power management control
+ * @base: The base address of the VIC.
+ * @irq: The base IRQ for the VIC.
+ * @resume_sources: bitmask of interrupts allowed for resume sources.
+ *
+ * For older kernels (< 3.xx) do -
+ * Register the VIC with the system device tree so that it can be notified
+ * of suspend and resume requests and ensure that the correct actions are
+ * taken to re-instate the settings on resume.
+ */
+static void __init armctrl_pm_register(void __iomem * base, unsigned int irq,
+				       u32 resume_sources)
+{
+	armctrl.base = base;
+	armctrl.resume_sources = resume_sources;
+	armctrl.irq = irq;
+}
+
+static int armctrl_set_wake(struct irq_data *d, unsigned int on)
+{
+	unsigned int off = d->irq & 31;
+	u32 bit = 1 << off;
+
+	if (!(bit & armctrl.resume_sources))
+		return -EINVAL;
+
+	if (on)
+		armctrl.resume_irqs |= bit;
+	else
+		armctrl.resume_irqs &= ~bit;
+
+	return 0;
+}
+
+#else
+static inline void armctrl_pm_register(void __iomem * base, unsigned int irq,
+				       u32 arg1)
+{
+}
+
+#define armctrl_suspend NULL
+#define armctrl_resume NULL
+#define armctrl_set_wake NULL
+#endif /* CONFIG_PM */
+
+static struct syscore_ops armctrl_syscore_ops = {
+	.suspend = armctrl_suspend,
+	.resume = armctrl_resume,
+};
+
+/**
+ * armctrl_syscore_init - initicall to register VIC pm functions
+ *
+ * This is called via late_initcall() to register
+ * the resources for the VICs due to the early
+ * nature of the VIC's registration.
+*/
+static int __init armctrl_syscore_init(void)
+{
+	register_syscore_ops(&armctrl_syscore_ops);
+	return 0;
+}
+
+late_initcall(armctrl_syscore_init);
+
+static struct irq_chip armctrl_chip = {
+	.name = "ARMCTRL",
+	.irq_ack = NULL,
+	.irq_mask = armctrl_mask_irq,
+	.irq_unmask = armctrl_unmask_irq,
+	.irq_set_wake = armctrl_set_wake,
+};
+
+/**
+ * armctrl_init - initialise a vectored interrupt controller
+ * @base: iomem base address
+ * @irq_start: starting interrupt number, must be muliple of 32
+ * @armctrl_sources: bitmask of interrupt sources to allow
+ * @resume_sources: bitmask of interrupt sources to allow for resume
+ */
+int __init armctrl_init(void __iomem * base, unsigned int irq_start,
+			u32 armctrl_sources, u32 resume_sources)
+{
+	unsigned int irq;
+
+	for (irq = 0; irq < BCM2708_ALLOC_IRQS; irq++) {
+		unsigned int data = irq;
+		if (irq >= INTERRUPT_JPEG && irq <= INTERRUPT_ARASANSDIO)
+			data = remap_irqs[irq - INTERRUPT_JPEG];
+		if (irq >= IRQ_ARM_LOCAL_CNTPSIRQ && irq <= IRQ_ARM_LOCAL_TIMER) {
+			irq_set_percpu_devid(irq);
+			irq_set_chip_and_handler(irq, &armctrl_chip, handle_percpu_devid_irq);
+			set_irq_flags(irq, IRQF_VALID | IRQF_NOAUTOEN);
+                } else {
+			irq_set_chip_and_handler(irq, &armctrl_chip, handle_level_irq);
+			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE | IRQF_DISABLED);
+                }
+		irq_set_chip_data(irq, (void *)data);
+	}
+
+	armctrl_pm_register(base, irq_start, resume_sources);
+	init_FIQ(FIQ_START);
+	armctrl_dt_init();
+	return 0;
+}
--- /dev/null
+++ b/arch/arm/mach-bcm2709/armctrl.h
@@ -0,0 +1,27 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/armctrl.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __BCM2708_ARMCTRL_H
+#define __BCM2708_ARMCTRL_H
+
+extern int __init armctrl_init(void __iomem * base, unsigned int irq_start,
+			       u32 armctrl_sources, u32 resume_sources);
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/bcm2708_gpio.c
@@ -0,0 +1,426 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/bcm2708_gpio.c
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <mach/gpio.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <mach/platform.h>
+#include <linux/pinctrl/consumer.h>
+
+#include <linux/platform_data/bcm2708.h>
+
+#define BCM_GPIO_DRIVER_NAME "bcm2708_gpio"
+#define DRIVER_NAME BCM_GPIO_DRIVER_NAME
+#define BCM_GPIO_USE_IRQ 1
+
+#define GPIOFSEL(x)  (0x00+(x)*4)
+#define GPIOSET(x)   (0x1c+(x)*4)
+#define GPIOCLR(x)   (0x28+(x)*4)
+#define GPIOLEV(x)   (0x34+(x)*4)
+#define GPIOEDS(x)   (0x40+(x)*4)
+#define GPIOREN(x)   (0x4c+(x)*4)
+#define GPIOFEN(x)   (0x58+(x)*4)
+#define GPIOHEN(x)   (0x64+(x)*4)
+#define GPIOLEN(x)   (0x70+(x)*4)
+#define GPIOAREN(x)  (0x7c+(x)*4)
+#define GPIOAFEN(x)  (0x88+(x)*4)
+#define GPIOUD(x)    (0x94+(x)*4)
+#define GPIOUDCLK(x) (0x98+(x)*4)
+
+#define GPIO_BANKS 2
+
+enum { GPIO_FSEL_INPUT, GPIO_FSEL_OUTPUT,
+	GPIO_FSEL_ALT5, GPIO_FSEL_ALT_4,
+	GPIO_FSEL_ALT0, GPIO_FSEL_ALT1,
+	GPIO_FSEL_ALT2, GPIO_FSEL_ALT3,
+};
+
+	/* Each of the two spinlocks protects a different set of hardware
+	 * regiters and data structurs. This decouples the code of the IRQ from
+	 * the GPIO code. This also makes the case of a GPIO routine call from
+	 * the IRQ code simpler.
+	 */
+static DEFINE_SPINLOCK(lock);	/* GPIO registers */
+
+struct bcm2708_gpio {
+	struct list_head list;
+	void __iomem *base;
+	struct gpio_chip gc;
+	unsigned long rising[(BCM2708_NR_GPIOS + 31) / 32];
+	unsigned long falling[(BCM2708_NR_GPIOS + 31) / 32];
+	unsigned long high[(BCM2708_NR_GPIOS + 31) / 32];
+	unsigned long low[(BCM2708_NR_GPIOS + 31) / 32];
+};
+
+static int bcm2708_set_function(struct gpio_chip *gc, unsigned offset,
+				int function)
+{
+	struct bcm2708_gpio *gpio = container_of(gc, struct bcm2708_gpio, gc);
+	unsigned long flags;
+	unsigned gpiodir;
+	unsigned gpio_bank = offset / 10;
+	unsigned gpio_field_offset = (offset - 10 * gpio_bank) * 3;
+
+//printk(KERN_ERR DRIVER_NAME ": bcm2708_gpio_set_function %p (%d,%d)\n", gc, offset, function);
+	if (offset >= BCM2708_NR_GPIOS)
+		return -EINVAL;
+
+	spin_lock_irqsave(&lock, flags);
+
+	gpiodir = readl(gpio->base + GPIOFSEL(gpio_bank));
+	gpiodir &= ~(7 << gpio_field_offset);
+	gpiodir |= function << gpio_field_offset;
+	writel(gpiodir, gpio->base + GPIOFSEL(gpio_bank));
+	spin_unlock_irqrestore(&lock, flags);
+	gpiodir = readl(gpio->base + GPIOFSEL(gpio_bank));
+
+	return 0;
+}
+
+static int bcm2708_gpio_dir_in(struct gpio_chip *gc, unsigned offset)
+{
+	return bcm2708_set_function(gc, offset, GPIO_FSEL_INPUT);
+}
+
+static void bcm2708_gpio_set(struct gpio_chip *gc, unsigned offset, int value);
+static int bcm2708_gpio_dir_out(struct gpio_chip *gc, unsigned offset,
+				int value)
+{
+	int ret;
+	ret = bcm2708_set_function(gc, offset, GPIO_FSEL_OUTPUT);
+	if (ret >= 0)
+		bcm2708_gpio_set(gc, offset, value);
+	return ret;
+}
+
+static int bcm2708_gpio_get(struct gpio_chip *gc, unsigned offset)
+{
+	struct bcm2708_gpio *gpio = container_of(gc, struct bcm2708_gpio, gc);
+	unsigned gpio_bank = offset / 32;
+	unsigned gpio_field_offset = (offset - 32 * gpio_bank);
+	unsigned lev;
+
+	if (offset >= BCM2708_NR_GPIOS)
+		return 0;
+	lev = readl(gpio->base + GPIOLEV(gpio_bank));
+//printk(KERN_ERR DRIVER_NAME ": bcm2708_gpio_get %p (%d)=%d\n", gc, offset, 0x1 & (lev>>gpio_field_offset));
+	return 0x1 & (lev >> gpio_field_offset);
+}
+
+static void bcm2708_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct bcm2708_gpio *gpio = container_of(gc, struct bcm2708_gpio, gc);
+	unsigned gpio_bank = offset / 32;
+	unsigned gpio_field_offset = (offset - 32 * gpio_bank);
+//printk(KERN_ERR DRIVER_NAME ": bcm2708_gpio_set %p (%d=%d)\n", gc, offset, value);
+	if (offset >= BCM2708_NR_GPIOS)
+		return;
+	if (value)
+		writel(1 << gpio_field_offset, gpio->base + GPIOSET(gpio_bank));
+	else
+		writel(1 << gpio_field_offset, gpio->base + GPIOCLR(gpio_bank));
+}
+
+/**********************
+ * extension to configure pullups
+ */
+int bcm2708_gpio_setpull(struct gpio_chip *gc, unsigned offset,
+		bcm2708_gpio_pull_t value)
+{
+	struct bcm2708_gpio *gpio = container_of(gc, struct bcm2708_gpio, gc);
+	unsigned gpio_bank = offset / 32;
+	unsigned gpio_field_offset = (offset - 32 * gpio_bank);
+
+	if (offset >= BCM2708_NR_GPIOS)
+		return -EINVAL;
+
+	switch (value) {
+	case BCM2708_PULL_UP:
+		writel(2, gpio->base + GPIOUD(0));
+		break;
+	case BCM2708_PULL_DOWN:
+		writel(1, gpio->base + GPIOUD(0));
+		break;
+	case BCM2708_PULL_OFF:
+		writel(0, gpio->base + GPIOUD(0));
+		break;
+	}
+
+	udelay(5);
+	writel(1 << gpio_field_offset, gpio->base + GPIOUDCLK(gpio_bank));
+	udelay(5);
+	writel(0, gpio->base + GPIOUD(0));
+	writel(0 << gpio_field_offset, gpio->base + GPIOUDCLK(gpio_bank));
+
+	return 0;
+}
+EXPORT_SYMBOL(bcm2708_gpio_setpull);
+
+/*************************************************************************************************************************
+ * bcm2708 GPIO IRQ
+ */
+
+#if BCM_GPIO_USE_IRQ
+
+static int bcm2708_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
+{
+	return gpio_to_irq(gpio);
+}
+
+static int bcm2708_gpio_irq_set_type(struct irq_data *d, unsigned type)
+{
+	unsigned irq = d->irq;
+	struct bcm2708_gpio *gpio = irq_get_chip_data(irq);
+	unsigned gn = irq_to_gpio(irq);
+	unsigned gb = gn / 32;
+	unsigned go = gn % 32;
+
+	gpio->rising[gb]  &= ~(1 << go);
+	gpio->falling[gb] &= ~(1 << go);
+	gpio->high[gb]    &= ~(1 << go);
+	gpio->low[gb]     &= ~(1 << go);
+
+	if (type & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))
+		return -EINVAL;
+
+	if (type & IRQ_TYPE_EDGE_RISING)
+		gpio->rising[gb] |= (1 << go);
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		gpio->falling[gb] |= (1 << go);
+	if (type & IRQ_TYPE_LEVEL_HIGH)
+		gpio->high[gb] |= (1 << go);
+	if (type & IRQ_TYPE_LEVEL_LOW)
+		gpio->low[gb] |= (1 << go);
+	return 0;
+}
+
+static void bcm2708_gpio_irq_mask(struct irq_data *d)
+{
+	unsigned irq = d->irq;
+	struct bcm2708_gpio *gpio = irq_get_chip_data(irq);
+	unsigned gn = irq_to_gpio(irq);
+	unsigned gb = gn / 32;
+	unsigned long rising  = readl(gpio->base + GPIOREN(gb));
+	unsigned long falling = readl(gpio->base + GPIOFEN(gb));
+	unsigned long high    = readl(gpio->base + GPIOHEN(gb));
+	unsigned long low     = readl(gpio->base + GPIOLEN(gb));
+
+	gn = gn % 32;
+
+	writel(rising  & ~(1 << gn), gpio->base + GPIOREN(gb));
+	writel(falling & ~(1 << gn), gpio->base + GPIOFEN(gb));
+	writel(high    & ~(1 << gn), gpio->base + GPIOHEN(gb));
+	writel(low     & ~(1 << gn), gpio->base + GPIOLEN(gb));
+}
+
+static void bcm2708_gpio_irq_unmask(struct irq_data *d)
+{
+	unsigned irq = d->irq;
+	struct bcm2708_gpio *gpio = irq_get_chip_data(irq);
+	unsigned gn = irq_to_gpio(irq);
+	unsigned gb = gn / 32;
+	unsigned go = gn % 32;
+	unsigned long rising  = readl(gpio->base + GPIOREN(gb));
+	unsigned long falling = readl(gpio->base + GPIOFEN(gb));
+	unsigned long high    = readl(gpio->base + GPIOHEN(gb));
+	unsigned long low     = readl(gpio->base + GPIOLEN(gb));
+
+	if (gpio->rising[gb] & (1 << go)) {
+		writel(rising |  (1 << go), gpio->base + GPIOREN(gb));
+	} else {
+		writel(rising & ~(1 << go), gpio->base + GPIOREN(gb));
+	}
+
+	if (gpio->falling[gb] & (1 << go)) {
+		writel(falling |  (1 << go), gpio->base + GPIOFEN(gb));
+	} else {
+		writel(falling & ~(1 << go), gpio->base + GPIOFEN(gb));
+	}
+
+	if (gpio->high[gb] & (1 << go)) {
+		writel(high |  (1 << go), gpio->base + GPIOHEN(gb));
+	} else {
+		writel(high & ~(1 << go), gpio->base + GPIOHEN(gb));
+	}
+
+	if (gpio->low[gb] & (1 << go)) {
+		writel(low |  (1 << go), gpio->base + GPIOLEN(gb));
+	} else {
+		writel(low & ~(1 << go), gpio->base + GPIOLEN(gb));
+	}
+}
+
+static struct irq_chip bcm2708_irqchip = {
+	.name = "GPIO",
+	.irq_enable = bcm2708_gpio_irq_unmask,
+	.irq_disable = bcm2708_gpio_irq_mask,
+	.irq_unmask = bcm2708_gpio_irq_unmask,
+	.irq_mask = bcm2708_gpio_irq_mask,
+	.irq_set_type = bcm2708_gpio_irq_set_type,
+};
+
+static irqreturn_t bcm2708_gpio_interrupt(int irq, void *dev_id)
+{
+	unsigned long edsr;
+	unsigned bank;
+	int i;
+	unsigned gpio;
+	unsigned level_bits;
+	struct bcm2708_gpio *gpio_data = dev_id;
+
+	for (bank = 0; bank < GPIO_BANKS; bank++) {
+		edsr = readl(__io_address(GPIO_BASE) + GPIOEDS(bank));
+		level_bits = gpio_data->high[bank] | gpio_data->low[bank];
+
+		for_each_set_bit(i, &edsr, 32) {
+			gpio = i + bank * 32;
+			/* ack edge triggered IRQs immediately */
+			if (!(level_bits & (1<<i)))
+				writel(1<<i,
+				       __io_address(GPIO_BASE) + GPIOEDS(bank));
+			generic_handle_irq(gpio_to_irq(gpio));
+			/* ack level triggered IRQ after handling them */
+			if (level_bits & (1<<i))
+				writel(1<<i,
+				       __io_address(GPIO_BASE) + GPIOEDS(bank));
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bcm2708_gpio_irq = {
+	.name = "BCM2708 GPIO catchall handler",
+	.flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler = bcm2708_gpio_interrupt,
+};
+
+static void bcm2708_gpio_irq_init(struct bcm2708_gpio *ucb)
+{
+	unsigned irq;
+
+	ucb->gc.to_irq = bcm2708_gpio_to_irq;
+
+	for (irq = GPIO_IRQ_START; irq < (GPIO_IRQ_START + GPIO_IRQS); irq++) {
+		irq_set_chip_data(irq, ucb);
+		irq_set_chip_and_handler(irq, &bcm2708_irqchip,
+					 handle_simple_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	bcm2708_gpio_irq.dev_id = ucb;
+	setup_irq(IRQ_GPIO3, &bcm2708_gpio_irq);
+}
+
+#else
+
+static void bcm2708_gpio_irq_init(struct bcm2708_gpio *ucb)
+{
+}
+
+#endif /* #if BCM_GPIO_USE_IRQ ***************************************************************************************************************** */
+
+static int bcm2708_gpio_probe(struct platform_device *dev)
+{
+	struct bcm2708_gpio *ucb;
+	struct resource *res;
+	int bank;
+	int err = 0;
+
+	printk(KERN_INFO DRIVER_NAME ": bcm2708_gpio_probe %p\n", dev);
+
+	ucb = kzalloc(sizeof(*ucb), GFP_KERNEL);
+	if (NULL == ucb) {
+		printk(KERN_ERR DRIVER_NAME ": failed to allocate "
+		       "mailbox memory\n");
+		err = -ENOMEM;
+		goto err;
+	}
+
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+
+	platform_set_drvdata(dev, ucb);
+	ucb->base = __io_address(GPIO_BASE);
+
+	ucb->gc.label = "bcm2708_gpio";
+	ucb->gc.base = 0;
+	ucb->gc.ngpio = BCM2708_NR_GPIOS;
+	ucb->gc.owner = THIS_MODULE;
+
+	ucb->gc.direction_input = bcm2708_gpio_dir_in;
+	ucb->gc.direction_output = bcm2708_gpio_dir_out;
+	ucb->gc.get = bcm2708_gpio_get;
+	ucb->gc.set = bcm2708_gpio_set;
+	ucb->gc.can_sleep = 0;
+
+	for (bank = 0; bank < GPIO_BANKS; bank++) {
+		writel(0, ucb->base + GPIOREN(bank));
+		writel(0, ucb->base + GPIOFEN(bank));
+		writel(0, ucb->base + GPIOHEN(bank));
+		writel(0, ucb->base + GPIOLEN(bank));
+		writel(0, ucb->base + GPIOAREN(bank));
+		writel(0, ucb->base + GPIOAFEN(bank));
+		writel(~0, ucb->base + GPIOEDS(bank));
+	}
+
+	bcm2708_gpio_irq_init(ucb);
+
+	err = gpiochip_add(&ucb->gc);
+
+err:
+	return err;
+
+}
+
+static int bcm2708_gpio_remove(struct platform_device *dev)
+{
+	int err = 0;
+	struct bcm2708_gpio *ucb = platform_get_drvdata(dev);
+
+	printk(KERN_ERR DRIVER_NAME ": bcm2708_gpio_remove %p\n", dev);
+
+	gpiochip_remove(&ucb->gc);
+
+	platform_set_drvdata(dev, NULL);
+	kfree(ucb);
+
+	return err;
+}
+
+static struct platform_driver bcm2708_gpio_driver = {
+	.probe = bcm2708_gpio_probe,
+	.remove = bcm2708_gpio_remove,
+	.driver = {
+		   .name = "bcm2708_gpio"},
+};
+
+static int __init bcm2708_gpio_init(void)
+{
+	return platform_driver_register(&bcm2708_gpio_driver);
+}
+
+static void __exit bcm2708_gpio_exit(void)
+{
+	platform_driver_unregister(&bcm2708_gpio_driver);
+}
+
+module_init(bcm2708_gpio_init);
+module_exit(bcm2708_gpio_exit);
+
+MODULE_DESCRIPTION("Broadcom BCM2708 GPIO driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/arch/arm/mach-bcm2709/bcm2709.c
@@ -0,0 +1,1237 @@
+/*
+ *  linux/arch/arm/mach-bcm2709/bcm2709.c
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/serial_8250.h>
+#include <linux/platform_device.h>
+#include <linux/syscore_ops.h>
+#include <linux/interrupt.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clockchips.h>
+#include <linux/cnt32_to_63.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/spi/spi.h>
+#include <linux/gpio/machine.h>
+#include <linux/w1-gpio.h>
+
+#include <linux/version.h>
+#include <linux/clkdev.h>
+#include <asm/system_info.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/cputype.h>
+#include <linux/sched_clock.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/mach/map.h>
+
+#include <mach/timex.h>
+#include <mach/dma.h>
+#include <mach/vcio.h>
+#include <mach/system.h>
+
+#include <linux/delay.h>
+
+#include "bcm2709.h"
+#include "armctrl.h"
+
+#ifdef CONFIG_BCM_VC_CMA
+#include <linux/broadcom/vc_cma.h>
+#endif
+
+//#define SYSTEM_TIMER
+
+/* Effectively we have an IOMMU (ARM<->VideoCore map) that is set up to
+ * give us IO access only to 64Mbytes of physical memory (26 bits).  We could
+ * represent this window by setting our dmamasks to 26 bits but, in fact
+ * we're not going to use addresses outside this range (they're not in real
+ * memory) so we don't bother.
+ *
+ * In the future we might include code to use this IOMMU to remap other
+ * physical addresses onto VideoCore memory then the use of 32-bits would be
+ * more legitimate.
+ */
+#define DMA_MASK_BITS_COMMON 32
+
+// use GPIO 4 for the one-wire GPIO pin, if enabled
+#define W1_GPIO 4
+// ensure one-wire GPIO pullup is disabled by default
+#define W1_PULLUP -1
+
+/* command line parameters */
+static unsigned boardrev, serial;
+static unsigned uart_clock = UART0_CLOCK;
+static unsigned disk_led_gpio = 16;
+static unsigned disk_led_active_low = 1;
+static unsigned reboot_part = 0;
+static unsigned w1_gpio_pin = W1_GPIO;
+static unsigned w1_gpio_pullup = W1_PULLUP;
+
+static unsigned use_dt = 0;
+
+static void __init bcm2709_init_led(void);
+
+void __init bcm2709_init_irq(void)
+{
+	armctrl_init(__io_address(ARMCTRL_IC_BASE), 0, 0, 0);
+}
+
+static struct map_desc bcm2709_io_desc[] __initdata = {
+	{
+	 .virtual = IO_ADDRESS(ARMCTRL_BASE),
+	 .pfn = __phys_to_pfn(ARMCTRL_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(UART0_BASE),
+	 .pfn = __phys_to_pfn(UART0_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(UART1_BASE),
+	 .pfn = __phys_to_pfn(UART1_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(DMA_BASE),
+	 .pfn = __phys_to_pfn(DMA_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(MCORE_BASE),
+	 .pfn = __phys_to_pfn(MCORE_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(ST_BASE),
+	 .pfn = __phys_to_pfn(ST_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(USB_BASE),
+	 .pfn = __phys_to_pfn(USB_BASE),
+	 .length = SZ_128K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(PM_BASE),
+	 .pfn = __phys_to_pfn(PM_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(GPIO_BASE),
+	 .pfn = __phys_to_pfn(GPIO_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = IO_ADDRESS(ARM_LOCAL_BASE),
+	 .pfn = __phys_to_pfn(ARM_LOCAL_BASE),
+	 .length = SZ_4K,
+	 .type = MT_DEVICE},
+};
+
+void __init bcm2709_map_io(void)
+{
+	iotable_init(bcm2709_io_desc, ARRAY_SIZE(bcm2709_io_desc));
+}
+
+#ifdef SYSTEM_TIMER
+
+/* The STC is a free running counter that increments at the rate of 1MHz */
+#define STC_FREQ_HZ 1000000
+
+static inline uint32_t timer_read(void)
+{
+	/* STC: a free running counter that increments at the rate of 1MHz */
+	return readl(__io_address(ST_BASE + 0x04));
+}
+
+static unsigned long bcm2709_read_current_timer(void)
+{
+	return timer_read();
+}
+
+static u64 notrace bcm2709_read_sched_clock(void)
+{
+	return timer_read();
+}
+
+static cycle_t clksrc_read(struct clocksource *cs)
+{
+	return timer_read();
+}
+
+static struct clocksource clocksource_stc = {
+	.name = "stc",
+	.rating = 300,
+	.read = clksrc_read,
+	.mask = CLOCKSOURCE_MASK(32),
+	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+unsigned long frc_clock_ticks32(void)
+{
+	return timer_read();
+}
+
+static void __init bcm2709_clocksource_init(void)
+{
+	if (clocksource_register_hz(&clocksource_stc, STC_FREQ_HZ)) {
+		printk(KERN_ERR "timer: failed to initialize clock "
+		       "source %s\n", clocksource_stc.name);
+	}
+}
+#endif
+
+struct clk __init *bcm2709_clk_register(const char *name, unsigned long fixed_rate)
+{
+	struct clk *clk;
+
+	clk = clk_register_fixed_rate(NULL, name, NULL, CLK_IS_ROOT,
+						fixed_rate);
+	if (IS_ERR(clk))
+		pr_err("%s not registered\n", name);
+
+	return clk;
+}
+
+void __init bcm2709_register_clkdev(struct clk *clk, const char *name)
+{
+	int ret;
+
+	ret = clk_register_clkdev(clk, NULL, name);
+	if (ret)
+		pr_err("%s alias not registered\n", name);
+}
+
+void __init bcm2709_init_clocks(void)
+{
+	struct clk *clk;
+
+	clk = bcm2709_clk_register("uart0_clk", uart_clock);
+	bcm2709_register_clkdev(clk, "dev:f1");
+
+	clk = bcm2709_clk_register("sdhost_clk", 250000000);
+	bcm2709_register_clkdev(clk, "bcm2708_spi.0");
+	bcm2709_register_clkdev(clk, "bcm2708_i2c.0");
+	bcm2709_register_clkdev(clk, "bcm2708_i2c.1");
+}
+
+#define UART0_IRQ	{ IRQ_UART, 0 /*NO_IRQ*/ }
+#define UART0_DMA	{ 15, 14 }
+
+AMBA_DEVICE(uart0, "dev:f1", UART0, NULL);
+
+static struct amba_device *amba_devs[] __initdata = {
+	&uart0_device,
+};
+
+static struct resource bcm2708_dmaman_resources[] = {
+	{
+	 .start = DMA_BASE,
+	 .end = DMA_BASE + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 }
+};
+
+static struct platform_device bcm2708_dmaman_device = {
+	.name = BCM_DMAMAN_DRIVER_NAME,
+	.id = 0,		/* first bcm2708_dma */
+	.resource = bcm2708_dmaman_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_dmaman_resources),
+};
+
+#if defined(CONFIG_W1_MASTER_GPIO) || defined(CONFIG_W1_MASTER_GPIO_MODULE)
+static struct w1_gpio_platform_data w1_gpio_pdata = {
+	.pin = W1_GPIO,
+        .ext_pullup_enable_pin = W1_PULLUP,
+	.is_open_drain = 0,
+};
+
+static struct platform_device w1_device = {
+	.name = "w1-gpio",
+	.id = -1,
+	.dev.platform_data = &w1_gpio_pdata,
+};
+#endif
+
+static u64 fb_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+
+static struct platform_device bcm2708_fb_device = {
+	.name = "bcm2708_fb",
+	.id = -1,		/* only one bcm2708_fb */
+	.resource = NULL,
+	.num_resources = 0,
+	.dev = {
+		.dma_mask = &fb_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
+};
+
+static struct plat_serial8250_port bcm2708_uart1_platform_data[] = {
+	{
+	 .mapbase = UART1_BASE + 0x40,
+	 .irq = IRQ_AUX,
+	 .uartclk = 125000000,
+	 .regshift = 2,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_FIXED_TYPE | UPF_IOREMAP | UPF_SKIP_TEST,
+	 .type = PORT_8250,
+	 },
+	{},
+};
+
+static struct platform_device bcm2708_uart1_device = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+		.platform_data = bcm2708_uart1_platform_data,
+		},
+};
+
+static struct resource bcm2708_usb_resources[] = {
+	[0] = {
+	       .start = USB_BASE,
+	       .end = USB_BASE + SZ_128K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+		.start = MPHI_BASE,
+		.end = MPHI_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	      },
+	[2] = {
+	       .start = IRQ_HOSTPORT,
+	       .end = IRQ_HOSTPORT,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+		.start = IRQ_USB,
+		.end = IRQ_USB,
+		.flags = IORESOURCE_IRQ,
+		},
+};
+
+
+static u64 usb_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+
+static struct platform_device bcm2708_usb_device = {
+	.name = "bcm2708_usb",
+	.id = -1,		/* only one bcm2708_usb */
+	.resource = bcm2708_usb_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_usb_resources),
+	.dev = {
+		.dma_mask = &usb_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
+};
+
+static struct resource bcm2708_vcio_resources[] = {
+	[0] = {			/* mailbox/semaphore/doorbell access */
+	       .start = MCORE_BASE,
+	       .end = MCORE_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static u64 vcio_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+
+static struct platform_device bcm2708_vcio_device = {
+	.name = BCM_VCIO_DRIVER_NAME,
+	.id = -1,		/* only one VideoCore I/O area */
+	.resource = bcm2708_vcio_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_vcio_resources),
+	.dev = {
+		.dma_mask = &vcio_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
+};
+
+#ifdef CONFIG_BCM2708_GPIO
+#define BCM_GPIO_DRIVER_NAME "bcm2708_gpio"
+
+static struct resource bcm2708_gpio_resources[] = {
+	[0] = {			/* general purpose I/O */
+	       .start = GPIO_BASE,
+	       .end = GPIO_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static u64 gpio_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+
+static struct platform_device bcm2708_gpio_device = {
+	.name = BCM_GPIO_DRIVER_NAME,
+	.id = -1,		/* only one VideoCore I/O area */
+	.resource = bcm2708_gpio_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_gpio_resources),
+	.dev = {
+		.dma_mask = &gpio_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
+};
+#endif
+
+#ifdef SYSTEM_TIMER
+static struct resource bcm2708_systemtimer_resources[] = {
+	[0] = {			/* system timer access */
+	       .start = ST_BASE,
+	       .end = ST_BASE + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	{
+	 .start = IRQ_TIMER3,
+	 .end = IRQ_TIMER3,
+	 .flags = IORESOURCE_IRQ,
+	 }
+
+};
+
+static u64 systemtimer_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+
+static struct platform_device bcm2708_systemtimer_device = {
+	.name = "bcm2708_systemtimer",
+	.id = -1,		/* only one VideoCore I/O area */
+	.resource = bcm2708_systemtimer_resources,
+	.num_resources = ARRAY_SIZE(bcm2708_systemtimer_resources),
+	.dev = {
+		.dma_mask = &systemtimer_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+		},
+};
+#endif
+
+#ifdef CONFIG_MMC_BCM2835	/* Arasan emmc SD (new) */
+static struct resource bcm2835_emmc_resources[] = {
+	[0] = {
+	       .start = EMMC_BASE,
+	       .end = EMMC_BASE + SZ_256 - 1,	/* we only need this area */
+	       /* the memory map actually makes SZ_4K available  */
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = IRQ_ARASANSDIO,
+	       .end = IRQ_ARASANSDIO,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+static u64 bcm2835_emmc_dmamask = 0xffffffffUL;
+
+struct platform_device bcm2835_emmc_device = {
+	.name = "mmc-bcm2835",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2835_emmc_resources),
+	.resource = bcm2835_emmc_resources,
+	.dev = {
+		.dma_mask = &bcm2835_emmc_dmamask,
+		.coherent_dma_mask = 0xffffffffUL},
+};
+#endif /* CONFIG_MMC_BCM2835 */
+
+static struct resource bcm2708_powerman_resources[] = {
+	[0] = {
+	       .start = PM_BASE,
+	       .end = PM_BASE + SZ_256 - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+};
+
+static u64 powerman_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+
+struct platform_device bcm2708_powerman_device = {
+	.name = "bcm2708_powerman",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2708_powerman_resources),
+	.resource = bcm2708_powerman_resources,
+	.dev = {
+		.dma_mask = &powerman_dmamask,
+		.coherent_dma_mask = 0xffffffffUL},
+};
+
+
+static struct platform_device bcm2708_alsa_devices[] = {
+	[0] = {
+	       .name = "bcm2835_AUD0",
+	       .id = 0,		/* first audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[1] = {
+	       .name = "bcm2835_AUD1",
+	       .id = 1,		/* second audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[2] = {
+	       .name = "bcm2835_AUD2",
+	       .id = 2,		/* third audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[3] = {
+	       .name = "bcm2835_AUD3",
+	       .id = 3,		/* forth audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[4] = {
+	       .name = "bcm2835_AUD4",
+	       .id = 4,		/* fifth audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[5] = {
+	       .name = "bcm2835_AUD5",
+	       .id = 5,		/* sixth audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[6] = {
+	       .name = "bcm2835_AUD6",
+	       .id = 6,		/* seventh audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+	[7] = {
+	       .name = "bcm2835_AUD7",
+	       .id = 7,		/* eighth audio device */
+	       .resource = 0,
+	       .num_resources = 0,
+	       },
+};
+
+static struct resource bcm2708_spi_resources[] = {
+	{
+		.start = SPI0_BASE,
+		.end = SPI0_BASE + SZ_256 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_SPI,
+		.end = IRQ_SPI,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+
+static u64 bcm2708_spi_dmamask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON);
+static struct platform_device bcm2708_spi_device = {
+	.name = "bcm2708_spi",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2708_spi_resources),
+	.resource = bcm2708_spi_resources,
+	.dev = {
+		.dma_mask = &bcm2708_spi_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON)},
+};
+
+#ifdef CONFIG_BCM2708_SPIDEV
+static struct spi_board_info bcm2708_spi_devices[] = {
+#ifdef CONFIG_SPI_SPIDEV
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 500000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_0,
+	}, {
+		.modalias = "spidev",
+		.max_speed_hz = 500000,
+		.bus_num = 0,
+		.chip_select = 1,
+		.mode = SPI_MODE_0,
+	}
+#endif
+};
+#endif
+
+static struct resource bcm2708_bsc0_resources[] = {
+	{
+		.start = BSC0_BASE,
+		.end = BSC0_BASE + SZ_256 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = INTERRUPT_I2C,
+		.end = INTERRUPT_I2C,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device bcm2708_bsc0_device = {
+	.name = "bcm2708_i2c",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2708_bsc0_resources),
+	.resource = bcm2708_bsc0_resources,
+};
+
+
+static struct resource bcm2708_bsc1_resources[] = {
+	{
+		.start = BSC1_BASE,
+		.end = BSC1_BASE + SZ_256 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = INTERRUPT_I2C,
+		.end = INTERRUPT_I2C,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device bcm2708_bsc1_device = {
+	.name = "bcm2708_i2c",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(bcm2708_bsc1_resources),
+	.resource = bcm2708_bsc1_resources,
+};
+
+static struct platform_device bcm2835_hwmon_device = {
+	.name = "bcm2835_hwmon",
+};
+
+static struct platform_device bcm2835_thermal_device = {
+	.name = "bcm2835_thermal",
+};
+
+#if defined(CONFIG_SND_BCM2708_SOC_I2S) || defined(CONFIG_SND_BCM2708_SOC_I2S_MODULE)
+static struct resource bcm2708_i2s_resources[] = {
+	{
+		.start = I2S_BASE,
+		.end = I2S_BASE + 0x20,
+		.flags = IORESOURCE_MEM,
+	},
+        {
+		.start = PCM_CLOCK_BASE,
+		.end = PCM_CLOCK_BASE + 0x02,
+		.flags = IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device bcm2708_i2s_device = {
+	.name = "bcm2708-i2s",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(bcm2708_i2s_resources),
+	.resource = bcm2708_i2s_resources,
+};
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC_MODULE)
+static struct platform_device snd_hifiberry_dac_device = {
+        .name = "snd-hifiberry-dac",
+        .id = 0,
+        .num_resources = 0,
+};
+
+static struct platform_device snd_pcm5102a_codec_device = {
+        .name = "pcm5102a-codec",
+        .id = -1,
+        .num_resources = 0,
+};
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DACPLUS) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DACPLUS_MODULE)
+static struct platform_device snd_rpi_hifiberry_dacplus_device = {
+        .name = "snd-rpi-hifiberry-dacplus",
+        .id = 0,
+        .num_resources = 0,
+};
+
+static struct i2c_board_info __initdata snd_pcm512x_hbdacplus_i2c_devices[] = {
+        {
+                I2C_BOARD_INFO("pcm5122", 0x4d)
+        },
+};
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DIGI) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DIGI_MODULE)
+static struct platform_device snd_hifiberry_digi_device = {
+        .name = "snd-hifiberry-digi",
+        .id = 0,
+        .num_resources = 0,
+};
+
+static struct i2c_board_info __initdata snd_wm8804_i2c_devices[] = {
+        {
+                I2C_BOARD_INFO("wm8804", 0x3b)
+        },
+};
+
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_AMP) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_AMP_MODULE)
+static struct platform_device snd_hifiberry_amp_device = {
+        .name = "snd-hifiberry-amp",
+        .id = 0,
+        .num_resources = 0,
+};
+
+static struct i2c_board_info __initdata snd_tas5713_i2c_devices[] = {
+        {
+                I2C_BOARD_INFO("tas5713", 0x1b)
+        },
+};
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_RPI_DAC) || defined(CONFIG_SND_BCM2708_SOC_RPI_DAC_MODULE)
+static struct platform_device snd_rpi_dac_device = {
+        .name = "snd-rpi-dac",
+        .id = 0,
+        .num_resources = 0,
+};
+
+static struct platform_device snd_pcm1794a_codec_device = {
+        .name = "pcm1794a-codec",
+        .id = -1,
+        .num_resources = 0,
+};
+#endif
+
+
+#if defined(CONFIG_SND_BCM2708_SOC_IQAUDIO_DAC) || defined(CONFIG_SND_BCM2708_SOC_IQAUDIO_DAC_MODULE)
+static struct platform_device snd_rpi_iqaudio_dac_device = {
+        .name = "snd-rpi-iqaudio-dac",
+        .id = 0,
+        .num_resources = 0,
+};
+
+// Use the actual device name rather than generic driver name
+static struct i2c_board_info __initdata snd_pcm512x_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("pcm5122", 0x4c)
+	},
+};
+#endif
+
+int __init bcm_register_device(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = platform_device_register(pdev);
+	if (ret)
+		pr_debug("Unable to register platform device '%s': %d\n",
+			 pdev->name, ret);
+
+	return ret;
+}
+
+/*
+ * Use these macros for platform and i2c devices that are present in the
+ * Device Tree. This way the devices are only added on non-DT systems.
+ */
+#define bcm_register_device_dt(pdev) \
+    if (!use_dt) bcm_register_device(pdev)
+
+#define i2c_register_board_info_dt(busnum, info, n) \
+    if (!use_dt) i2c_register_board_info(busnum, info, n)
+
+int calc_rsts(int partition)
+{
+	return PM_PASSWORD |
+		((partition & (1 << 0))  << 0) |
+		((partition & (1 << 1))  << 1) |
+		((partition & (1 << 2))  << 2) |
+		((partition & (1 << 3))  << 3) |
+		((partition & (1 << 4))  << 4) |
+		((partition & (1 << 5))  << 5);
+}
+
+static void bcm2709_restart(enum reboot_mode mode, const char *cmd)
+{
+	extern char bcm2708_reboot_mode;
+	uint32_t pm_rstc, pm_wdog;
+	uint32_t timeout = 10;
+	uint32_t pm_rsts = 0;
+
+	if(bcm2708_reboot_mode == 'q')
+	{
+		// NOOBS < 1.3 booting with reboot=q
+		pm_rsts = readl(__io_address(PM_RSTS));
+		pm_rsts = PM_PASSWORD | pm_rsts | PM_RSTS_HADWRQ_SET;
+	}
+	else if(bcm2708_reboot_mode == 'p')
+	{
+		// NOOBS < 1.3 halting
+		pm_rsts = readl(__io_address(PM_RSTS));
+		pm_rsts = PM_PASSWORD | pm_rsts | PM_RSTS_HADWRH_SET;
+	}
+	else
+	{
+		pm_rsts = calc_rsts(reboot_part);
+	}
+
+	writel(pm_rsts, __io_address(PM_RSTS));
+
+	/* Setup watchdog for reset */
+	pm_rstc = readl(__io_address(PM_RSTC));
+
+	pm_wdog = PM_PASSWORD | (timeout & PM_WDOG_TIME_SET); // watchdog timer = timer clock / 16; need password (31:16) + value (11:0)
+	pm_rstc = PM_PASSWORD | (pm_rstc & PM_RSTC_WRCFG_CLR) | PM_RSTC_WRCFG_FULL_RESET;
+
+	writel(pm_wdog, __io_address(PM_WDOG));
+	writel(pm_rstc, __io_address(PM_RSTC));
+}
+
+/* We can't really power off, but if we do the normal reset scheme, and indicate to bootcode.bin not to reboot, then most of the chip will be powered off */
+static void bcm2709_power_off(void)
+{
+	extern char bcm2708_reboot_mode;
+	if(bcm2708_reboot_mode == 'q')
+	{
+		// NOOBS < v1.3
+		bcm2709_restart('p', "");
+	}
+	else
+	{
+		/* partition 63 is special code for HALT the bootloader knows not to boot*/
+		reboot_part = 63;
+		/* continue with normal reset mechanism */
+		bcm2709_restart(0, "");
+	}
+}
+
+#ifdef CONFIG_OF
+static void __init bcm2709_dt_init(void)
+{
+	int ret;
+
+	ret = of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+	if (ret) {
+		pr_err("of_platform_populate failed: %d\n", ret);
+		use_dt = 0;
+	}
+}
+#else
+static void __init bcm2709_dt_init(void) { }
+#endif /* CONFIG_OF */
+
+void __init bcm2709_init(void)
+{
+	int i;
+
+#if defined(CONFIG_BCM_VC_CMA)
+	vc_cma_early_init();
+#endif
+	printk("bcm2709.uart_clock = %d\n", uart_clock);
+	pm_power_off = bcm2709_power_off;
+
+	bcm2709_init_clocks();
+	if (use_dt)
+	    bcm2709_dt_init();
+
+	bcm_register_device(&bcm2708_dmaman_device);
+	bcm_register_device(&bcm2708_vcio_device);
+#ifdef CONFIG_BCM2708_GPIO
+	bcm_register_device_dt(&bcm2708_gpio_device);
+#endif
+#if defined(CONFIG_W1_MASTER_GPIO) || defined(CONFIG_W1_MASTER_GPIO_MODULE)
+	w1_gpio_pdata.pin = w1_gpio_pin;
+	w1_gpio_pdata.ext_pullup_enable_pin = w1_gpio_pullup;
+	bcm_register_device_dt(&w1_device);
+#endif
+#ifdef SYSTEM_TIMER
+	bcm_register_device(&bcm2708_systemtimer_device);
+#endif
+	bcm_register_device(&bcm2708_fb_device);
+	bcm_register_device(&bcm2708_usb_device);
+	bcm_register_device(&bcm2708_uart1_device);
+	bcm_register_device(&bcm2708_powerman_device);
+
+#ifdef CONFIG_MMC_BCM2835
+	bcm_register_device(&bcm2835_emmc_device);
+#endif
+	bcm2709_init_led();
+	for (i = 0; i < ARRAY_SIZE(bcm2708_alsa_devices); i++)
+		bcm_register_device(&bcm2708_alsa_devices[i]);
+
+	bcm_register_device(&bcm2835_hwmon_device);
+	bcm_register_device(&bcm2835_thermal_device);
+
+	bcm_register_device_dt(&bcm2708_spi_device);
+	bcm_register_device_dt(&bcm2708_bsc0_device);
+	bcm_register_device_dt(&bcm2708_bsc1_device);
+
+#if defined(CONFIG_SND_BCM2708_SOC_I2S) || defined(CONFIG_SND_BCM2708_SOC_I2S_MODULE)
+	bcm_register_device_dt(&bcm2708_i2s_device);
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DAC_MODULE)
+        bcm_register_device_dt(&snd_hifiberry_dac_device);
+        bcm_register_device_dt(&snd_pcm5102a_codec_device);
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DACPLUS) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DACPLUS_MODULE)
+        bcm_register_device_dt(&snd_rpi_hifiberry_dacplus_device);
+        i2c_register_board_info_dt(1, snd_pcm512x_hbdacplus_i2c_devices, ARRAY_SIZE(snd_pcm512x_hbdacplus_i2c_devices));
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DIGI) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_DIGI_MODULE)
+        bcm_register_device_dt(&snd_hifiberry_digi_device);
+        i2c_register_board_info_dt(1, snd_wm8804_i2c_devices, ARRAY_SIZE(snd_wm8804_i2c_devices));
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_AMP) || defined(CONFIG_SND_BCM2708_SOC_HIFIBERRY_AMP_MODULE)
+        bcm_register_device_dt(&snd_hifiberry_amp_device);
+        i2c_register_board_info_dt(1, snd_tas5713_i2c_devices, ARRAY_SIZE(snd_tas5713_i2c_devices));
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_RPI_DAC) || defined(CONFIG_SND_BCM2708_SOC_RPI_DAC_MODULE)
+        bcm_register_device_dt(&snd_rpi_dac_device);
+        bcm_register_device_dt(&snd_pcm1794a_codec_device);
+#endif
+
+#if defined(CONFIG_SND_BCM2708_SOC_IQAUDIO_DAC) || defined(CONFIG_SND_BCM2708_SOC_IQAUDIO_DAC_MODULE)
+        bcm_register_device_dt(&snd_rpi_iqaudio_dac_device);
+        i2c_register_board_info_dt(1, snd_pcm512x_i2c_devices, ARRAY_SIZE(snd_pcm512x_i2c_devices));
+#endif
+
+
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+	system_rev = boardrev;
+	system_serial_low = serial;
+
+#ifdef CONFIG_BCM2708_SPIDEV
+	if (!use_dt)
+	    spi_register_board_info(bcm2708_spi_devices,
+				    ARRAY_SIZE(bcm2708_spi_devices));
+#endif
+}
+
+#ifdef SYSTEM_TIMER
+static void timer_set_mode(enum clock_event_mode mode,
+			   struct clock_event_device *clk)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_ONESHOT: /* Leave the timer disabled, .set_next_event will enable it */
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		break;
+	case CLOCK_EVT_MODE_PERIODIC:
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_RESUME:
+
+	default:
+		printk(KERN_ERR "timer_set_mode: unhandled mode:%d\n",
+		       (int)mode);
+		break;
+	}
+
+}
+
+static int timer_set_next_event(unsigned long cycles,
+				struct clock_event_device *unused)
+{
+	unsigned long stc;
+	do {
+		stc = readl(__io_address(ST_BASE + 0x04));
+		/* We could take a FIQ here, which may push ST above STC3 */
+		writel(stc + cycles, __io_address(ST_BASE + 0x18));
+	} while ((signed long) cycles >= 0 &&
+				(signed long) (readl(__io_address(ST_BASE + 0x04)) - stc)
+				>= (signed long) cycles);
+	return 0;
+}
+
+static struct clock_event_device timer0_clockevent = {
+	.name = "timer0",
+	.shift = 32,
+	.features = CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode = timer_set_mode,
+	.set_next_event = timer_set_next_event,
+};
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t bcm2709_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+
+	writel(1 << 3, __io_address(ST_BASE + 0x00));	/* stcs clear timer int */
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bcm2709_timer_irq = {
+	.name = "BCM2709 Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler = bcm2709_timer_interrupt,
+};
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ */
+
+static struct delay_timer bcm2709_delay_timer = {
+	.read_current_timer = bcm2709_read_current_timer,
+	.freq = STC_FREQ_HZ,
+};
+
+static void __init bcm2709_timer_init(void)
+{
+	/* init high res timer */
+	bcm2709_clocksource_init();
+
+	/*
+	 * Make irqs happen for the system timer
+	 */
+	setup_irq(IRQ_TIMER3, &bcm2708_timer_irq);
+
+	sched_clock_register(bcm2709_read_sched_clock, 32, STC_FREQ_HZ);
+
+	timer0_clockevent.mult =
+	    div_sc(STC_FREQ_HZ, NSEC_PER_SEC, timer0_clockevent.shift);
+	timer0_clockevent.max_delta_ns =
+	    clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+	timer0_clockevent.min_delta_ns =
+	    clockevent_delta2ns(0xf, &timer0_clockevent);
+
+	timer0_clockevent.cpumask = cpumask_of(0);
+	clockevents_register_device(&timer0_clockevent);
+
+	register_current_timer_delay(&bcm2708_delay_timer);
+}
+
+#else
+
+static void __init bcm2709_timer_init(void)
+{
+	extern void dc4_arch_timer_init(void);
+	// timer control
+	writel(0, __io_address(ARM_LOCAL_CONTROL));
+	// timer pre_scaler
+	writel(0x80000000, __io_address(ARM_LOCAL_PRESCALER)); // 19.2MHz
+	//writel(0x06AAAAAB, __io_address(ARM_LOCAL_PRESCALER)); // 1MHz
+
+	if (use_dt)
+	{
+		of_clk_init(NULL);
+		clocksource_of_init();
+	}
+	else
+		dc4_arch_timer_init();
+}
+
+#endif
+
+#if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
+#include <linux/leds.h>
+
+static struct gpio_led bcm2709_leds[] = {
+	[0] = {
+	       .gpio = 16,
+	       .name = "led0",
+	       .default_trigger = "mmc0",
+	       .active_low = 1,
+	       },
+};
+
+static struct gpio_led_platform_data bcm2709_led_pdata = {
+	.num_leds = ARRAY_SIZE(bcm2709_leds),
+	.leds = bcm2709_leds,
+};
+
+static struct platform_device bcm2709_led_device = {
+	.name = "leds-gpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &bcm2709_led_pdata,
+		},
+};
+
+static void __init bcm2709_init_led(void)
+{
+	bcm2709_leds[0].gpio = disk_led_gpio;
+	bcm2709_leds[0].active_low = disk_led_active_low;
+	bcm_register_device_dt(&bcm2709_led_device);
+}
+#else
+static inline void bcm2709_init_led(void)
+{
+}
+#endif
+
+void __init bcm2709_init_early(void)
+{
+	/*
+	 * Some devices allocate their coherent buffers from atomic
+	 * context. Increase size of atomic coherent pool to make sure such
+	 * the allocations won't fail.
+	 */
+	init_dma_coherent_pool_size(SZ_4M);
+
+#ifdef CONFIG_OF
+	if (of_allnodes)
+	    use_dt = 1;
+#endif
+}
+
+static void __init board_reserve(void)
+{
+#if defined(CONFIG_BCM_VC_CMA)
+	vc_cma_reserve();
+#endif
+}
+
+
+#include <linux/smp.h>
+
+#include <mach/hardware.h>
+#include <asm/cacheflush.h>
+#include <asm/smp_plat.h>
+int dc4=0;
+//void dc4_log(unsigned x) { if (dc4) writel((x), __io_address(ST_BASE+10 + raw_smp_processor_id()*4)); }
+void dc4_log_dead(unsigned x) { if (dc4) writel((readl(__io_address(ST_BASE+0x10 + raw_smp_processor_id()*4)) & 0xffff) | ((x)<<16), __io_address(ST_BASE+0x10 + raw_smp_processor_id()*4)); }
+
+static void bcm2835_send_doorbell(const struct cpumask *mask, unsigned int irq)
+{
+        int cpu;
+        /*
+         * Ensure that stores to Normal memory are visible to the
+         * other CPUs before issuing the IPI.
+         */
+        dsb();
+
+        /* Convert our logical CPU mask into a physical one. */
+        for_each_cpu(cpu, mask)
+	{
+		/* submit softirq */
+		writel(1<<irq, __io_address(ARM_LOCAL_MAILBOX0_SET0 + 0x10 * MPIDR_AFFINITY_LEVEL(cpu_logical_map(cpu), 0)));
+	}
+}
+
+void __init bcm2709_smp_init_cpus(void)
+{
+	void secondary_startup(void);
+	unsigned int i, ncores;
+
+	ncores = 4; // xxx scu_get_core_count(NULL);
+	printk("[%s] enter (%x->%x)\n", __FUNCTION__, (unsigned)virt_to_phys((void *)secondary_startup), (unsigned)__io_address(ST_BASE + 0x10));
+	printk("[%s] ncores=%d\n", __FUNCTION__, ncores);
+
+	for (i = 0; i < ncores; i++) {
+		set_cpu_possible(i, true);
+		/* enable IRQ (not FIQ) */
+		writel(0x1, __io_address(ARM_LOCAL_MAILBOX_INT_CONTROL0 + 0x4 * i));
+		//writel(0xf, __io_address(ARM_LOCAL_TIMER_INT_CONTROL0   + 0x4 * i));
+	}
+	set_smp_cross_call(bcm2835_send_doorbell);
+}
+
+/*
+ * for arch/arm/kernel/smp.c:smp_prepare_cpus(unsigned int max_cpus)
+ */
+void __init bcm2709_smp_prepare_cpus(unsigned int max_cpus)
+{
+    //void __iomem *scu_base;
+
+    printk("[%s] enter\n", __FUNCTION__);
+    //scu_base = scu_base_addr();
+    //scu_enable(scu_base);
+}
+
+/*
+ * for linux/arch/arm/kernel/smp.c:secondary_start_kernel(void)
+ */
+void __cpuinit bcm2709_secondary_init(unsigned int cpu)
+{
+    printk("[%s] enter cpu:%d\n", __FUNCTION__, cpu);
+    //gic_secondary_init(0);
+}
+
+/*
+ * for linux/arch/arm/kernel/smp.c:__cpu_up(..)
+ */
+int __cpuinit bcm2709_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+    void secondary_startup(void);
+    void *mbox_set = __io_address(ARM_LOCAL_MAILBOX3_SET0 + 0x10 * MPIDR_AFFINITY_LEVEL(cpu_logical_map(cpu), 0));
+    void *mbox_clr = __io_address(ARM_LOCAL_MAILBOX3_CLR0 + 0x10 * MPIDR_AFFINITY_LEVEL(cpu_logical_map(cpu), 0));
+    unsigned secondary_boot = (unsigned)virt_to_phys((void *)secondary_startup);
+    int timeout=20;
+    unsigned t = -1;
+    //printk("[%s] enter cpu:%d (%x->%p) %x\n", __FUNCTION__, cpu, secondary_boot, wake, readl(wake));
+
+    dsb();
+    BUG_ON(readl(mbox_clr) != 0);
+    writel(secondary_boot, mbox_set);
+
+    while (--timeout > 0) {
+	t = readl(mbox_clr);
+	if (t == 0) break;
+	cpu_relax();
+    }
+    if (timeout==0)
+        printk("[%s] cpu:%d failed to start (%x)\n", __FUNCTION__, cpu, t);
+    else
+        printk("[%s] cpu:%d started (%x) %d\n", __FUNCTION__, cpu, t, timeout);
+
+    return 0;
+}
+
+
+struct smp_operations  bcm2709_smp_ops __initdata = {
+	.smp_init_cpus		= bcm2709_smp_init_cpus,
+	.smp_prepare_cpus	= bcm2709_smp_prepare_cpus,
+	.smp_secondary_init	= bcm2709_secondary_init,
+	.smp_boot_secondary	= bcm2709_boot_secondary,
+};
+
+static const char * const bcm2709_compat[] = {
+	"brcm,bcm2709",
+	"brcm,bcm2708", /* Could use bcm2708 in a pinch */
+	NULL
+};
+
+MACHINE_START(BCM2709, "BCM2709")
+    /* Maintainer: Broadcom Europe Ltd. */
+	.smp		= smp_ops(bcm2709_smp_ops),
+	.map_io = bcm2709_map_io,
+	.init_irq = bcm2709_init_irq,
+	.init_time = bcm2709_timer_init,
+	.init_machine = bcm2709_init,
+	.init_early = bcm2709_init_early,
+	.reserve = board_reserve,
+	.restart	= bcm2709_restart,
+	.dt_compat = bcm2709_compat,
+MACHINE_END
+
+module_param(boardrev, uint, 0644);
+module_param(serial, uint, 0644);
+module_param(uart_clock, uint, 0644);
+module_param(disk_led_gpio, uint, 0644);
+module_param(disk_led_active_low, uint, 0644);
+module_param(reboot_part, uint, 0644);
+module_param(w1_gpio_pin, uint, 0644);
+module_param(w1_gpio_pullup, uint, 0644);
--- /dev/null
+++ b/arch/arm/mach-bcm2709/bcm2709.h
@@ -0,0 +1,49 @@
+/*
+ * linux/arch/arm/mach-bcm2708/bcm2708.h
+ *
+ * BCM2708 machine support header
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __BCM2708_BCM2708_H
+#define __BCM2708_BCM2708_H
+
+#include <linux/amba/bus.h>
+
+extern void __init bcm2708_init(void);
+extern void __init bcm2708_init_irq(void);
+extern void __init bcm2708_map_io(void);
+extern struct sys_timer bcm2708_timer;
+extern unsigned int mmc_status(struct device *dev);
+
+#define AMBA_DEVICE(name, busid, base, plat)			\
+static struct amba_device name##_device = {			\
+	.dev		= {					\
+		.coherent_dma_mask = ~0,			\
+		.init_name = busid,				\
+		.platform_data = plat,				\
+	},							\
+	.res		= {					\
+		.start	= base##_BASE,		\
+		.end	= (base##_BASE) + SZ_4K - 1,\
+		.flags	= IORESOURCE_MEM,			\
+	},							\
+	.irq		= base##_IRQ,				\
+}
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/clock.c
@@ -0,0 +1,61 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/clock.c
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <asm/clkdev.h>
+
+#include "clock.h"
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->rate;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	return -EIO;
+}
+EXPORT_SYMBOL(clk_set_rate);
--- /dev/null
+++ b/arch/arm/mach-bcm2709/clock.h
@@ -0,0 +1,24 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/clock.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+struct module;
+
+struct clk {
+	unsigned long		rate;
+};
--- /dev/null
+++ b/arch/arm/mach-bcm2709/delay.S
@@ -0,0 +1,21 @@
+/*
+ *  linux/arch/arm/lib/delay.S
+ *
+ *  Copyright (C) 1995, 1996 Russell King
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/param.h>
+
+		.text
+.align 3	@ 8 byte alignment seems to be needed to avoid fetching stalls
+@ Delay routine
+ENTRY(bcm2708_delay)
+		subs	r0, r0, #1
+		bhi	bcm2708_delay
+		mov	pc, lr
+ENDPROC(bcm2708_delay)
--- /dev/null
+++ b/arch/arm/mach-bcm2709/dma.c
@@ -0,0 +1,409 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/dma.c
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+
+#include <mach/dma.h>
+#include <mach/irqs.h>
+
+/*****************************************************************************\
+ *									     *
+ * Configuration							     *
+ *									     *
+\*****************************************************************************/
+
+#define CACHE_LINE_MASK 31
+#define DRIVER_NAME BCM_DMAMAN_DRIVER_NAME
+#define DEFAULT_DMACHAN_BITMAP 0x10  /* channel 4 only */
+
+/* valid only for channels 0 - 14, 15 has its own base address */
+#define BCM2708_DMA_CHAN(n)	((n)<<8) /* base address */
+#define BCM2708_DMA_CHANIO(dma_base, n) \
+   ((void __iomem *)((char *)(dma_base)+BCM2708_DMA_CHAN(n)))
+
+
+/*****************************************************************************\
+ *									     *
+ * DMA Auxilliary Functions						     *
+ *									     *
+\*****************************************************************************/
+
+/* A DMA buffer on an arbitrary boundary may separate a cache line into a
+   section inside the DMA buffer and another section outside it.
+   Even if we flush DMA buffers from the cache there is always the chance that
+   during a DMA someone will access the part of a cache line that is outside
+   the DMA buffer - which will then bring in unwelcome data.
+   Without being able to dictate our own buffer pools we must insist that
+   DMA buffers consist of a whole number of cache lines.
+*/
+
+extern int
+bcm_sg_suitable_for_dma(struct scatterlist *sg_ptr, int sg_len)
+{
+	int i;
+
+	for (i = 0; i < sg_len; i++) {
+		if (sg_ptr[i].offset & CACHE_LINE_MASK ||
+		    sg_ptr[i].length & CACHE_LINE_MASK)
+			return 0;
+	}
+
+	return 1;
+}
+EXPORT_SYMBOL_GPL(bcm_sg_suitable_for_dma);
+
+extern void
+bcm_dma_start(void __iomem *dma_chan_base, dma_addr_t control_block)
+{
+	dsb();	/* ARM data synchronization (push) operation */
+
+	writel(control_block,	     dma_chan_base + BCM2708_DMA_ADDR);
+	writel(BCM2708_DMA_ACTIVE,   dma_chan_base + BCM2708_DMA_CS);
+}
+
+extern void bcm_dma_wait_idle(void __iomem *dma_chan_base)
+{
+  dsb();
+
+  /* ugly busy wait only option for now */
+  while (readl(dma_chan_base + BCM2708_DMA_CS) & BCM2708_DMA_ACTIVE)
+    cpu_relax();
+}
+
+EXPORT_SYMBOL_GPL(bcm_dma_start);
+
+extern bool bcm_dma_is_busy(void __iomem *dma_chan_base)
+{
+	dsb();
+
+	return readl(dma_chan_base + BCM2708_DMA_CS) & BCM2708_DMA_ACTIVE;
+}
+EXPORT_SYMBOL_GPL(bcm_dma_is_busy);
+
+/* Complete an ongoing DMA (assuming its results are to be ignored)
+   Does nothing if there is no DMA in progress.
+   This routine waits for the current AXI transfer to complete before
+   terminating the current DMA.	 If the current transfer is hung on a DREQ used
+   by an uncooperative peripheral the AXI transfer may never complete.	In this
+   case the routine times out and return a non-zero error code.
+   Use of this routine doesn't guarantee that the ongoing or aborted DMA
+   does not produce an interrupt.
+*/
+extern int
+bcm_dma_abort(void __iomem *dma_chan_base)
+{
+	unsigned long int cs;
+	int rc = 0;
+
+	cs = readl(dma_chan_base + BCM2708_DMA_CS);
+
+	if (BCM2708_DMA_ACTIVE & cs) {
+		long int timeout = 10000;
+
+		/* write 0 to the active bit - pause the DMA */
+		writel(0, dma_chan_base + BCM2708_DMA_CS);
+
+		/* wait for any current AXI transfer to complete */
+		while (0 != (cs & BCM2708_DMA_ISPAUSED) && --timeout >= 0)
+			cs = readl(dma_chan_base + BCM2708_DMA_CS);
+
+		if (0 != (cs & BCM2708_DMA_ISPAUSED)) {
+			/* we'll un-pause when we set of our next DMA */
+			rc = -ETIMEDOUT;
+
+		} else if (BCM2708_DMA_ACTIVE & cs) {
+			/* terminate the control block chain */
+			writel(0, dma_chan_base + BCM2708_DMA_NEXTCB);
+
+			/* abort the whole DMA */
+			writel(BCM2708_DMA_ABORT | BCM2708_DMA_ACTIVE,
+			       dma_chan_base + BCM2708_DMA_CS);
+		}
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(bcm_dma_abort);
+
+
+/***************************************************************************** \
+ *									     *
+ * DMA Manager Device Methods						     *
+ *									     *
+\*****************************************************************************/
+
+struct vc_dmaman {
+	void __iomem *dma_base;
+	u32 chan_available; /* bitmap of available channels */
+	u32 has_feature[BCM_DMA_FEATURE_COUNT]; /* bitmap of feature presence */
+};
+
+static void vc_dmaman_init(struct vc_dmaman *dmaman, void __iomem *dma_base,
+			   u32 chans_available)
+{
+	dmaman->dma_base = dma_base;
+	dmaman->chan_available = chans_available;
+	dmaman->has_feature[BCM_DMA_FEATURE_FAST_ORD] = 0x0c;  /* chans 2 & 3 */
+	dmaman->has_feature[BCM_DMA_FEATURE_BULK_ORD] = 0x01;  /* chan 0 */
+	dmaman->has_feature[BCM_DMA_FEATURE_NORMAL_ORD] = 0xfe;  /* chans 1 to 7 */
+	dmaman->has_feature[BCM_DMA_FEATURE_LITE_ORD] = 0x7f00;  /* chans 8 to 14 */
+}
+
+static int vc_dmaman_chan_alloc(struct vc_dmaman *dmaman,
+				unsigned preferred_feature_set)
+{
+	u32 chans;
+	int feature;
+
+	chans = dmaman->chan_available;
+	for (feature = 0; feature < BCM_DMA_FEATURE_COUNT; feature++)
+		/* select the subset of available channels with the desired
+		   feature so long as some of the candidate channels have that
+		   feature */
+		if ((preferred_feature_set & (1 << feature)) &&
+		    (chans & dmaman->has_feature[feature]))
+			chans &= dmaman->has_feature[feature];
+
+	if (chans) {
+		int chan = 0;
+		/* return the ordinal of the first channel in the bitmap */
+		while (chans != 0 && (chans & 1) == 0) {
+			chans >>= 1;
+			chan++;
+		}
+		/* claim the channel */
+		dmaman->chan_available &= ~(1 << chan);
+		return chan;
+	} else
+		return -ENOMEM;
+}
+
+static int vc_dmaman_chan_free(struct vc_dmaman *dmaman, int chan)
+{
+	if (chan < 0)
+		return -EINVAL;
+	else if ((1 << chan) & dmaman->chan_available)
+		return -EIDRM;
+	else {
+		dmaman->chan_available |= (1 << chan);
+		return 0;
+	}
+}
+
+/*****************************************************************************\
+ *									     *
+ * DMA IRQs								     *
+ *									     *
+\*****************************************************************************/
+
+static unsigned char bcm_dma_irqs[] = {
+	IRQ_DMA0,
+	IRQ_DMA1,
+	IRQ_DMA2,
+	IRQ_DMA3,
+	IRQ_DMA4,
+	IRQ_DMA5,
+	IRQ_DMA6,
+	IRQ_DMA7,
+	IRQ_DMA8,
+	IRQ_DMA9,
+	IRQ_DMA10,
+	IRQ_DMA11,
+	IRQ_DMA12
+};
+
+
+/***************************************************************************** \
+ *									     *
+ * DMA Manager Monitor							     *
+ *									     *
+\*****************************************************************************/
+
+static struct device *dmaman_dev;	/* we assume there's only one! */
+
+extern int bcm_dma_chan_alloc(unsigned preferred_feature_set,
+			      void __iomem **out_dma_base, int *out_dma_irq)
+{
+	if (!dmaman_dev)
+		return -ENODEV;
+	else {
+		struct vc_dmaman *dmaman  = dev_get_drvdata(dmaman_dev);
+		int rc;
+
+		device_lock(dmaman_dev);
+		rc = vc_dmaman_chan_alloc(dmaman, preferred_feature_set);
+		if (rc >= 0) {
+			*out_dma_base = BCM2708_DMA_CHANIO(dmaman->dma_base,
+							   rc);
+			*out_dma_irq = bcm_dma_irqs[rc];
+		}
+		device_unlock(dmaman_dev);
+
+		return rc;
+	}
+}
+EXPORT_SYMBOL_GPL(bcm_dma_chan_alloc);
+
+extern int bcm_dma_chan_free(int channel)
+{
+	if (dmaman_dev) {
+		struct vc_dmaman *dmaman = dev_get_drvdata(dmaman_dev);
+		int rc;
+
+		device_lock(dmaman_dev);
+		rc = vc_dmaman_chan_free(dmaman, channel);
+		device_unlock(dmaman_dev);
+
+		return rc;
+	} else
+		return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(bcm_dma_chan_free);
+
+static int dev_dmaman_register(const char *dev_name, struct device *dev)
+{
+	int rc = dmaman_dev ? -EINVAL : 0;
+	dmaman_dev = dev;
+	return rc;
+}
+
+static void dev_dmaman_deregister(const char *dev_name, struct device *dev)
+{
+	dmaman_dev = NULL;
+}
+
+/*****************************************************************************\
+ *									     *
+ * DMA Device								     *
+ *									     *
+\*****************************************************************************/
+
+static int dmachans = -1; /* module parameter */
+
+static int bcm_dmaman_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct vc_dmaman *dmaman;
+	struct resource *dma_res = NULL;
+	void __iomem *dma_base = NULL;
+	int have_dma_region = 0;
+
+	dmaman = kzalloc(sizeof(*dmaman), GFP_KERNEL);
+	if (NULL == dmaman) {
+		printk(KERN_ERR DRIVER_NAME ": failed to allocate "
+		       "DMA management memory\n");
+		ret = -ENOMEM;
+	} else {
+
+		dma_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (dma_res == NULL) {
+			printk(KERN_ERR DRIVER_NAME ": failed to obtain memory "
+			       "resource\n");
+			ret = -ENODEV;
+		} else if (!request_mem_region(dma_res->start,
+					       resource_size(dma_res),
+					       DRIVER_NAME)) {
+			dev_err(&pdev->dev, "cannot obtain DMA region\n");
+			ret = -EBUSY;
+		} else {
+			have_dma_region = 1;
+			dma_base = ioremap(dma_res->start,
+					   resource_size(dma_res));
+			if (!dma_base) {
+				dev_err(&pdev->dev, "cannot map DMA region\n");
+				ret = -ENOMEM;
+			} else {
+				/* use module parameter if one was provided */
+				if (dmachans > 0)
+					vc_dmaman_init(dmaman, dma_base,
+						       dmachans);
+				else
+					vc_dmaman_init(dmaman, dma_base,
+						       DEFAULT_DMACHAN_BITMAP);
+
+				platform_set_drvdata(pdev, dmaman);
+				dev_dmaman_register(DRIVER_NAME, &pdev->dev);
+
+				printk(KERN_INFO DRIVER_NAME ": DMA manager "
+				       "at %p\n", dma_base);
+			}
+		}
+	}
+	if (ret != 0) {
+		if (dma_base)
+			iounmap(dma_base);
+		if (dma_res && have_dma_region)
+			release_mem_region(dma_res->start,
+					   resource_size(dma_res));
+		if (dmaman)
+			kfree(dmaman);
+	}
+	return ret;
+}
+
+static int bcm_dmaman_remove(struct platform_device *pdev)
+{
+	struct vc_dmaman *dmaman = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	dev_dmaman_deregister(DRIVER_NAME, &pdev->dev);
+	kfree(dmaman);
+
+	return 0;
+}
+
+static struct platform_driver bcm_dmaman_driver = {
+	.probe = bcm_dmaman_probe,
+	.remove = bcm_dmaman_remove,
+
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
+};
+
+/*****************************************************************************\
+ *									     *
+ * Driver init/exit							     *
+ *									     *
+\*****************************************************************************/
+
+static int __init bcm_dmaman_drv_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&bcm_dmaman_driver);
+	if (ret != 0) {
+		printk(KERN_ERR DRIVER_NAME ": failed to register "
+		       "on platform\n");
+	}
+
+	return ret;
+}
+
+static void __exit bcm_dmaman_drv_exit(void)
+{
+	platform_driver_unregister(&bcm_dmaman_driver);
+}
+
+module_init(bcm_dmaman_drv_init);
+module_exit(bcm_dmaman_drv_exit);
+
+module_param(dmachans, int, 0644);
+
+MODULE_AUTHOR("Gray Girling <grayg@broadcom.com>");
+MODULE_DESCRIPTION("DMA channel manager driver");
+MODULE_LICENSE("GPL");
+
+MODULE_PARM_DESC(dmachans, "Bitmap of DMA channels available to the ARM");
--- /dev/null
+++ b/arch/arm/mach-bcm2709/dmaer.c
@@ -0,0 +1,886 @@
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pagemap.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/timex.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+
+#include <mach/dma.h>
+#include <mach/vc_support.h>
+
+#ifdef ECLIPSE_IGNORE
+
+#define __user
+#define __init
+#define __exit
+#define __iomem
+#define KERN_DEBUG
+#define KERN_ERR
+#define KERN_WARNING
+#define KERN_INFO
+#define _IOWR(a, b, c) b
+#define _IOW(a, b, c) b
+#define _IO(a, b) b
+
+#endif
+
+//#define inline
+
+#define PRINTK(args...) printk(args)
+//#define PRINTK_VERBOSE(args...) printk(args)
+//#define PRINTK(args...)
+#define PRINTK_VERBOSE(args...)
+
+/***** TYPES ****/
+#define PAGES_PER_LIST 500
+struct PageList
+{
+	struct page *m_pPages[PAGES_PER_LIST];
+	unsigned int m_used;
+	struct PageList *m_pNext;
+};
+
+struct VmaPageList
+{
+	//each vma has a linked list of pages associated with it
+	struct PageList *m_pPageHead;
+	struct PageList *m_pPageTail;
+	unsigned int m_refCount;
+};
+
+struct DmaControlBlock
+{
+	unsigned int m_transferInfo;
+	void __user *m_pSourceAddr;
+	void __user *m_pDestAddr;
+	unsigned int m_xferLen;
+	unsigned int m_tdStride;
+	struct DmaControlBlock *m_pNext;
+	unsigned int m_blank1, m_blank2;
+};
+
+/***** DEFINES ******/
+//magic number defining the module
+#define DMA_MAGIC		0xdd
+
+//do user virtual to physical translation of the CB chain
+#define DMA_PREPARE		_IOWR(DMA_MAGIC, 0, struct DmaControlBlock *)
+
+//kick the pre-prepared CB chain
+#define DMA_KICK		_IOW(DMA_MAGIC, 1, struct DmaControlBlock *)
+
+//prepare it, kick it, wait for it
+#define DMA_PREPARE_KICK_WAIT	_IOWR(DMA_MAGIC, 2, struct DmaControlBlock *)
+
+//prepare it, kick it, don't wait for it
+#define DMA_PREPARE_KICK	_IOWR(DMA_MAGIC, 3, struct DmaControlBlock *)
+
+//not currently implemented
+#define DMA_WAIT_ONE		_IO(DMA_MAGIC, 4, struct DmaControlBlock *)
+
+//wait on all kicked CB chains
+#define DMA_WAIT_ALL		_IO(DMA_MAGIC, 5)
+
+//in order to discover the largest AXI burst that should be programmed into the transfer params
+#define DMA_MAX_BURST		_IO(DMA_MAGIC, 6)
+
+//set the address range through which the user address is assumed to already by a physical address
+#define DMA_SET_MIN_PHYS	_IOW(DMA_MAGIC, 7, unsigned long)
+#define DMA_SET_MAX_PHYS	_IOW(DMA_MAGIC, 8, unsigned long)
+#define DMA_SET_PHYS_OFFSET	_IOW(DMA_MAGIC, 9, unsigned long)
+
+//used to define the size for the CMA-based allocation *in pages*, can only be done once once the file is opened
+#define DMA_CMA_SET_SIZE	_IOW(DMA_MAGIC, 10, unsigned long)
+
+//used to get the version of the module, to test for a capability
+#define DMA_GET_VERSION		_IO(DMA_MAGIC, 99)
+
+#define VERSION_NUMBER 1
+
+#define VIRT_TO_BUS_CACHE_SIZE 8
+
+/***** FILE OPS *****/
+static int Open(struct inode *pInode, struct file *pFile);
+static int Release(struct inode *pInode, struct file *pFile);
+static long Ioctl(struct file *pFile, unsigned int cmd, unsigned long arg);
+static ssize_t Read(struct file *pFile, char __user *pUser, size_t count, loff_t *offp);
+static int Mmap(struct file *pFile, struct vm_area_struct *pVma);
+
+/***** VMA OPS ****/
+static void VmaOpen4k(struct vm_area_struct *pVma);
+static void VmaClose4k(struct vm_area_struct *pVma);
+static int VmaFault4k(struct vm_area_struct *pVma, struct vm_fault *pVmf);
+
+/**** DMA PROTOTYPES */
+static struct DmaControlBlock __user *DmaPrepare(struct DmaControlBlock __user *pUserCB, int *pError);
+static int DmaKick(struct DmaControlBlock __user *pUserCB);
+static void DmaWaitAll(void);
+
+/**** GENERIC ****/
+static int __init dmaer_init(void);
+static void __exit dmaer_exit(void);
+
+/*** OPS ***/
+static struct vm_operations_struct g_vmOps4k = {
+	.open = VmaOpen4k,
+	.close = VmaClose4k,
+	.fault = VmaFault4k,
+};
+
+static struct file_operations g_fOps = {
+	.owner = THIS_MODULE,
+	.llseek = 0,
+	.read = Read,
+	.write = 0,
+	.unlocked_ioctl = Ioctl,
+	.open = Open,
+	.release = Release,
+	.mmap = Mmap,
+};
+
+/***** GLOBALS ******/
+static dev_t g_majorMinor;
+
+//tracking usage of the two files
+static atomic_t g_oneLock4k = ATOMIC_INIT(1);
+
+//device operations
+static struct cdev g_cDev;
+static int g_trackedPages = 0;
+
+//dma control
+static unsigned int *g_pDmaChanBase;
+static int g_dmaIrq;
+static int g_dmaChan;
+
+//cma allocation
+static int g_cmaHandle;
+
+//user virtual to bus address translation acceleration
+static unsigned long g_virtAddr[VIRT_TO_BUS_CACHE_SIZE];
+static unsigned long g_busAddr[VIRT_TO_BUS_CACHE_SIZE];
+static unsigned long g_cbVirtAddr;
+static unsigned long g_cbBusAddr;
+static int g_cacheInsertAt;
+static int g_cacheHit, g_cacheMiss;
+
+//off by default
+static void __user *g_pMinPhys;
+static void __user *g_pMaxPhys;
+static unsigned long g_physOffset;
+
+/****** CACHE OPERATIONS ********/
+static inline void FlushAddrCache(void)
+{
+	int count = 0;
+	for (count = 0; count < VIRT_TO_BUS_CACHE_SIZE; count++)
+		g_virtAddr[count] = 0xffffffff;			//never going to match as we always chop the bottom bits anyway
+
+	g_cbVirtAddr = 0xffffffff;
+
+	g_cacheInsertAt = 0;
+}
+
+//translate from a user virtual address to a bus address by mapping the page
+//NB this won't lock a page in memory, so to avoid potential paging issues using kernel logical addresses
+static inline void __iomem *UserVirtualToBus(void __user *pUser)
+{
+	int mapped;
+	struct page *pPage;
+	void *phys;
+
+	//map it (requiring that the pointer points to something that does not hang off the page boundary)
+	mapped = get_user_pages(current, current->mm,
+		(unsigned long)pUser, 1,
+		1, 0,
+		&pPage,
+		0);
+
+	if (mapped <= 0)		//error
+		return 0;
+
+	PRINTK_VERBOSE(KERN_DEBUG "user virtual %p arm phys %p bus %p\n",
+			pUser, page_address(pPage), (void __iomem *)__virt_to_bus(page_address(pPage)));
+
+	//get the arm physical address
+	phys = page_address(pPage) + offset_in_page(pUser);
+	page_cache_release(pPage);
+
+	//and now the bus address
+	return (void __iomem *)__virt_to_bus(phys);
+}
+
+static inline void __iomem *UserVirtualToBusViaCbCache(void __user *pUser)
+{
+	unsigned long virtual_page = (unsigned long)pUser & ~4095;
+	unsigned long page_offset = (unsigned long)pUser & 4095;
+	unsigned long bus_addr;
+
+	if (g_cbVirtAddr == virtual_page)
+	{
+		bus_addr = g_cbBusAddr + page_offset;
+		g_cacheHit++;
+		return (void __iomem *)bus_addr;
+	}
+	else
+	{
+		bus_addr = (unsigned long)UserVirtualToBus(pUser);
+
+		if (!bus_addr)
+			return 0;
+
+		g_cbVirtAddr = virtual_page;
+		g_cbBusAddr = bus_addr & ~4095;
+		g_cacheMiss++;
+
+		return (void __iomem *)bus_addr;
+	}
+}
+
+//do the same as above, by query our virt->bus cache
+static inline void __iomem *UserVirtualToBusViaCache(void __user *pUser)
+{
+	int count;
+	//get the page and its offset
+	unsigned long virtual_page = (unsigned long)pUser & ~4095;
+	unsigned long page_offset = (unsigned long)pUser & 4095;
+	unsigned long bus_addr;
+
+	if (pUser >= g_pMinPhys && pUser < g_pMaxPhys)
+	{
+		PRINTK_VERBOSE(KERN_DEBUG "user->phys passthrough on %p\n", pUser);
+		return (void __iomem *)((unsigned long)pUser + g_physOffset);
+	}
+
+	//check the cache for our entry
+	for (count = 0; count < VIRT_TO_BUS_CACHE_SIZE; count++)
+		if (g_virtAddr[count] == virtual_page)
+		{
+			bus_addr = g_busAddr[count] + page_offset;
+			g_cacheHit++;
+			return (void __iomem *)bus_addr;
+		}
+
+	//not found, look up manually and then insert its page address
+	bus_addr = (unsigned long)UserVirtualToBus(pUser);
+
+	if (!bus_addr)
+		return 0;
+
+	g_virtAddr[g_cacheInsertAt] = virtual_page;
+	g_busAddr[g_cacheInsertAt] = bus_addr & ~4095;
+
+	//round robin
+	g_cacheInsertAt++;
+	if (g_cacheInsertAt == VIRT_TO_BUS_CACHE_SIZE)
+		g_cacheInsertAt = 0;
+
+	g_cacheMiss++;
+
+	return (void __iomem *)bus_addr;
+}
+
+/***** FILE OPERATIONS ****/
+static int Open(struct inode *pInode, struct file *pFile)
+{
+	PRINTK(KERN_DEBUG "file opening: %d/%d\n", imajor(pInode), iminor(pInode));
+
+	//check which device we are
+	if (iminor(pInode) == 0)		//4k
+	{
+		//only one at a time
+		if (!atomic_dec_and_test(&g_oneLock4k))
+		{
+			atomic_inc(&g_oneLock4k);
+			return -EBUSY;
+		}
+	}
+	else
+		return -EINVAL;
+
+	//todo there will be trouble if two different processes open the files
+
+	//reset after any file is opened
+	g_pMinPhys = (void __user *)-1;
+	g_pMaxPhys = (void __user *)0;
+	g_physOffset = 0;
+	g_cmaHandle = 0;
+
+	return 0;
+}
+
+static int Release(struct inode *pInode, struct file *pFile)
+{
+	PRINTK(KERN_DEBUG "file closing, %d pages tracked\n", g_trackedPages);
+	if (g_trackedPages)
+		PRINTK(KERN_ERR "we\'re leaking memory!\n");
+
+	//wait for any dmas to finish
+	DmaWaitAll();
+
+	//free this memory on the application closing the file or it crashing (implicitly closing the file)
+	if (g_cmaHandle)
+	{
+		PRINTK(KERN_DEBUG "unlocking vc memory\n");
+		if (UnlockVcMemory(g_cmaHandle))
+			PRINTK(KERN_ERR "uh-oh, unable to unlock vc memory!\n");
+		PRINTK(KERN_DEBUG "releasing vc memory\n");
+		if (ReleaseVcMemory(g_cmaHandle))
+			PRINTK(KERN_ERR "uh-oh, unable to release vc memory!\n");
+	}
+
+	if (iminor(pInode) == 0)
+		atomic_inc(&g_oneLock4k);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct DmaControlBlock __user *DmaPrepare(struct DmaControlBlock __user *pUserCB, int *pError)
+{
+	struct DmaControlBlock kernCB;
+	struct DmaControlBlock __user *pUNext;
+	void __iomem *pSourceBus, __iomem *pDestBus;
+
+	//get the control block into kernel memory so we can work on it
+	if (copy_from_user(&kernCB, pUserCB, sizeof(struct DmaControlBlock)) != 0)
+	{
+		PRINTK(KERN_ERR "copy_from_user failed for user cb %p\n", pUserCB);
+		*pError = 1;
+		return 0;
+	}
+
+	if (kernCB.m_pSourceAddr == 0 || kernCB.m_pDestAddr == 0)
+	{
+		PRINTK(KERN_ERR "faulty source (%p) dest (%p) addresses for user cb %p\n",
+			kernCB.m_pSourceAddr, kernCB.m_pDestAddr, pUserCB);
+		*pError = 1;
+		return 0;
+	}
+
+	pSourceBus = UserVirtualToBusViaCache(kernCB.m_pSourceAddr);
+	pDestBus = UserVirtualToBusViaCache(kernCB.m_pDestAddr);
+
+	if (!pSourceBus || !pDestBus)
+	{
+		PRINTK(KERN_ERR "virtual to bus translation failure for source/dest %p/%p->%p/%p\n",
+				kernCB.m_pSourceAddr, kernCB.m_pDestAddr,
+				pSourceBus, pDestBus);
+		*pError = 1;
+		return 0;
+	}
+
+	//update the user structure with the new bus addresses
+	kernCB.m_pSourceAddr = pSourceBus;
+	kernCB.m_pDestAddr = pDestBus;
+
+	PRINTK_VERBOSE(KERN_DEBUG "final source %p dest %p\n", kernCB.m_pSourceAddr, kernCB.m_pDestAddr);
+
+	//sort out the bus address for the next block
+	pUNext = kernCB.m_pNext;
+
+	if (kernCB.m_pNext)
+	{
+		void __iomem *pNextBus;
+		pNextBus = UserVirtualToBusViaCbCache(kernCB.m_pNext);
+
+		if (!pNextBus)
+		{
+			PRINTK(KERN_ERR "virtual to bus translation failure for m_pNext\n");
+			*pError = 1;
+			return 0;
+		}
+
+		//update the pointer with the bus address
+		kernCB.m_pNext = pNextBus;
+	}
+
+	//write it back to user space
+	if (copy_to_user(pUserCB, &kernCB, sizeof(struct DmaControlBlock)) != 0)
+	{
+		PRINTK(KERN_ERR "copy_to_user failed for cb %p\n", pUserCB);
+		*pError = 1;
+		return 0;
+	}
+
+	__cpuc_flush_dcache_area(pUserCB, 32);
+
+	*pError = 0;
+	return pUNext;
+}
+
+static int DmaKick(struct DmaControlBlock __user *pUserCB)
+{
+	void __iomem *pBusCB;
+
+	pBusCB = UserVirtualToBusViaCbCache(pUserCB);
+	if (!pBusCB)
+	{
+		PRINTK(KERN_ERR "virtual to bus translation failure for cb\n");
+		return 1;
+	}
+
+	//flush_cache_all();
+
+	bcm_dma_start(g_pDmaChanBase, (dma_addr_t)pBusCB);
+
+	return 0;
+}
+
+static void DmaWaitAll(void)
+{
+	int counter = 0;
+	volatile int inner_count;
+	volatile unsigned int cs;
+	unsigned long time_before, time_after;
+
+	time_before = jiffies;
+	//bcm_dma_wait_idle(g_pDmaChanBase);
+	dsb();
+
+	cs = readl(g_pDmaChanBase);
+
+	while ((cs & 1) == 1)
+	{
+		cs = readl(g_pDmaChanBase);
+		counter++;
+
+		for (inner_count = 0; inner_count < 32; inner_count++);
+
+		asm volatile ("MCR p15,0,r0,c7,c0,4 \n");
+		//cpu_do_idle();
+		if (counter >= 1000000)
+		{
+			PRINTK(KERN_WARNING "DMA failed to finish in a timely fashion\n");
+			break;
+		}
+	}
+	time_after = jiffies;
+	PRINTK_VERBOSE(KERN_DEBUG "done, counter %d, cs %08x", counter, cs);
+	PRINTK_VERBOSE(KERN_DEBUG "took %ld jiffies, %d HZ\n", time_after - time_before, HZ);
+}
+
+static long Ioctl(struct file *pFile, unsigned int cmd, unsigned long arg)
+{
+	int error = 0;
+	PRINTK_VERBOSE(KERN_DEBUG "ioctl cmd %x arg %lx\n", cmd, arg);
+
+	switch (cmd)
+	{
+	case DMA_PREPARE:
+	case DMA_PREPARE_KICK:
+	case DMA_PREPARE_KICK_WAIT:
+		{
+			struct DmaControlBlock __user *pUCB = (struct DmaControlBlock *)arg;
+			int steps = 0;
+			unsigned long start_time = jiffies;
+			(void)start_time;
+
+			//flush our address cache
+			FlushAddrCache();
+
+			PRINTK_VERBOSE(KERN_DEBUG "dma prepare\n");
+
+			//do virtual to bus translation for each entry
+			do
+			{
+				pUCB = DmaPrepare(pUCB, &error);
+			} while (error == 0 && ++steps && pUCB);
+			PRINTK_VERBOSE(KERN_DEBUG "prepare done in %d steps, %ld\n", steps, jiffies - start_time);
+
+			//carry straight on if we want to kick too
+			if (cmd == DMA_PREPARE || error)
+			{
+				PRINTK_VERBOSE(KERN_DEBUG "falling out\n");
+				return error ? -EINVAL : 0;
+			}
+		}
+	case DMA_KICK:
+		PRINTK_VERBOSE(KERN_DEBUG "dma begin\n");
+
+		if (cmd == DMA_KICK)
+			FlushAddrCache();
+
+		DmaKick((struct DmaControlBlock __user *)arg);
+
+		if (cmd != DMA_PREPARE_KICK_WAIT)
+			break;
+/*	case DMA_WAIT_ONE:
+		//PRINTK(KERN_DEBUG "dma wait one\n");
+		break;*/
+	case DMA_WAIT_ALL:
+		//PRINTK(KERN_DEBUG "dma wait all\n");
+		DmaWaitAll();
+		break;
+	case DMA_MAX_BURST:
+		if (g_dmaChan == 0)
+			return 10;
+		else
+			return 5;
+	case DMA_SET_MIN_PHYS:
+		g_pMinPhys = (void __user *)arg;
+		PRINTK(KERN_DEBUG "min/max user/phys bypass set to %p %p\n", g_pMinPhys, g_pMaxPhys);
+		break;
+	case DMA_SET_MAX_PHYS:
+		g_pMaxPhys = (void __user *)arg;
+		PRINTK(KERN_DEBUG "min/max user/phys bypass set to %p %p\n", g_pMinPhys, g_pMaxPhys);
+		break;
+	case DMA_SET_PHYS_OFFSET:
+		g_physOffset = arg;
+		PRINTK(KERN_DEBUG "user/phys bypass offset set to %ld\n", g_physOffset);
+		break;
+	case DMA_CMA_SET_SIZE:
+	{
+		unsigned int pBusAddr;
+
+		if (g_cmaHandle)
+		{
+			PRINTK(KERN_ERR "memory has already been allocated (handle %d)\n", g_cmaHandle);
+			return -EINVAL;
+		}
+
+		PRINTK(KERN_INFO "allocating %ld bytes of VC memory\n", arg * 4096);
+
+		//get the memory
+		if (AllocateVcMemory(&g_cmaHandle, arg * 4096, 4096, MEM_FLAG_L1_NONALLOCATING | MEM_FLAG_NO_INIT | MEM_FLAG_HINT_PERMALOCK))
+		{
+			PRINTK(KERN_ERR "failed to allocate %ld bytes of VC memory\n", arg * 4096);
+			g_cmaHandle = 0;
+			return -EINVAL;
+		}
+
+		//get an address for it
+		PRINTK(KERN_INFO "trying to map VC memory\n");
+
+		if (LockVcMemory(&pBusAddr, g_cmaHandle))
+		{
+			PRINTK(KERN_ERR "failed to map CMA handle %d, releasing memory\n", g_cmaHandle);
+			ReleaseVcMemory(g_cmaHandle);
+			g_cmaHandle = 0;
+		}
+
+		PRINTK(KERN_INFO "bus address for CMA memory is %x\n", pBusAddr);
+		return pBusAddr;
+	}
+	case DMA_GET_VERSION:
+		PRINTK(KERN_DEBUG "returning version number, %d\n", VERSION_NUMBER);
+		return VERSION_NUMBER;
+	default:
+		PRINTK(KERN_DEBUG "unknown ioctl: %d\n", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static ssize_t Read(struct file *pFile, char __user *pUser, size_t count, loff_t *offp)
+{
+	return -EIO;
+}
+
+static int Mmap(struct file *pFile, struct vm_area_struct *pVma)
+{
+	struct PageList *pPages;
+	struct VmaPageList *pVmaList;
+
+	PRINTK_VERBOSE(KERN_DEBUG "MMAP vma %p, length %ld (%s %d)\n",
+		pVma, pVma->vm_end - pVma->vm_start,
+		current->comm, current->pid);
+	PRINTK_VERBOSE(KERN_DEBUG "MMAP %p %d (tracked %d)\n", pVma, current->pid, g_trackedPages);
+
+	//make a new page list
+	pPages = (struct PageList *)kmalloc(sizeof(struct PageList), GFP_KERNEL);
+	if (!pPages)
+	{
+		PRINTK(KERN_ERR "couldn\'t allocate a new page list (%s %d)\n",
+			current->comm, current->pid);
+		return -ENOMEM;
+	}
+
+	//clear the page list
+	pPages->m_used = 0;
+	pPages->m_pNext = 0;
+
+	//insert our vma and new page list somewhere
+	if (!pVma->vm_private_data)
+	{
+		struct VmaPageList *pList;
+
+		PRINTK_VERBOSE(KERN_DEBUG "new vma list, making new one (%s %d)\n",
+			current->comm, current->pid);
+
+		//make a new vma list
+		pList = (struct VmaPageList *)kmalloc(sizeof(struct VmaPageList), GFP_KERNEL);
+		if (!pList)
+		{
+			PRINTK(KERN_ERR "couldn\'t allocate vma page list (%s %d)\n",
+				current->comm, current->pid);
+			kfree(pPages);
+			return -ENOMEM;
+		}
+
+		//clear this list
+		pVma->vm_private_data = (void *)pList;
+		pList->m_refCount = 0;
+	}
+
+	pVmaList = (struct VmaPageList *)pVma->vm_private_data;
+
+	//add it to the vma list
+	pVmaList->m_pPageHead = pPages;
+	pVmaList->m_pPageTail = pPages;
+
+	pVma->vm_ops = &g_vmOps4k;
+	pVma->vm_flags |= VM_IO;
+
+	VmaOpen4k(pVma);
+
+	return 0;
+}
+
+/****** VMA OPERATIONS ******/
+
+static void VmaOpen4k(struct vm_area_struct *pVma)
+{
+	struct VmaPageList *pVmaList;
+
+	PRINTK_VERBOSE(KERN_DEBUG "vma open %p private %p (%s %d), %d live pages\n", pVma, pVma->vm_private_data, current->comm, current->pid, g_trackedPages);
+	PRINTK_VERBOSE(KERN_DEBUG "OPEN %p %d %ld pages (tracked pages %d)\n",
+		pVma, current->pid, (pVma->vm_end - pVma->vm_start) >> 12,
+		g_trackedPages);
+
+	pVmaList = (struct VmaPageList *)pVma->vm_private_data;
+
+	if (pVmaList)
+	{
+		pVmaList->m_refCount++;
+		PRINTK_VERBOSE(KERN_DEBUG "ref count is now %d\n", pVmaList->m_refCount);
+	}
+	else
+	{
+		PRINTK_VERBOSE(KERN_DEBUG "err, open but no vma page list\n");
+	}
+}
+
+static void VmaClose4k(struct vm_area_struct *pVma)
+{
+	struct VmaPageList *pVmaList;
+	int freed = 0;
+
+	PRINTK_VERBOSE(KERN_DEBUG "vma close %p private %p (%s %d)\n", pVma, pVma->vm_private_data, current->comm, current->pid);
+
+	//wait for any dmas to finish
+	DmaWaitAll();
+
+	//find our vma in the list
+	pVmaList = (struct VmaPageList *)pVma->vm_private_data;
+
+	//may be a fork
+	if (pVmaList)
+	{
+		struct PageList *pPages;
+
+		pVmaList->m_refCount--;
+
+		if (pVmaList->m_refCount == 0)
+		{
+			PRINTK_VERBOSE(KERN_DEBUG "found vma, freeing pages (%s %d)\n",
+				current->comm, current->pid);
+
+			pPages = pVmaList->m_pPageHead;
+
+			if (!pPages)
+			{
+				PRINTK(KERN_ERR "no page list (%s %d)!\n",
+					current->comm, current->pid);
+				return;
+			}
+
+			while (pPages)
+			{
+				struct PageList *next;
+				int count;
+
+				PRINTK_VERBOSE(KERN_DEBUG "page list (%s %d)\n",
+					current->comm, current->pid);
+
+				next = pPages->m_pNext;
+				for (count = 0; count < pPages->m_used; count++)
+				{
+					PRINTK_VERBOSE(KERN_DEBUG "freeing page %p (%s %d)\n",
+						pPages->m_pPages[count],
+						current->comm, current->pid);
+					__free_pages(pPages->m_pPages[count], 0);
+					g_trackedPages--;
+					freed++;
+				}
+
+				PRINTK_VERBOSE(KERN_DEBUG "freeing page list (%s %d)\n",
+					current->comm, current->pid);
+				kfree(pPages);
+				pPages = next;
+			}
+
+			//remove our vma from the list
+			kfree(pVmaList);
+			pVma->vm_private_data = 0;
+		}
+		else
+		{
+			PRINTK_VERBOSE(KERN_DEBUG "ref count is %d, not closing\n", pVmaList->m_refCount);
+		}
+	}
+	else
+	{
+		PRINTK_VERBOSE(KERN_ERR "uh-oh, vma %p not found (%s %d)!\n", pVma, current->comm, current->pid);
+		PRINTK_VERBOSE(KERN_ERR "CLOSE ERR\n");
+	}
+
+	PRINTK_VERBOSE(KERN_DEBUG "CLOSE %p %d %d pages (tracked pages %d)",
+		pVma, current->pid, freed, g_trackedPages);
+
+	PRINTK_VERBOSE(KERN_DEBUG "%d pages open\n", g_trackedPages);
+}
+
+static int VmaFault4k(struct vm_area_struct *pVma, struct vm_fault *pVmf)
+{
+	PRINTK_VERBOSE(KERN_DEBUG "vma fault for vma %p private %p at offset %ld (%s %d)\n", pVma, pVma->vm_private_data, pVmf->pgoff,
+		current->comm, current->pid);
+	PRINTK_VERBOSE(KERN_DEBUG "FAULT\n");
+	pVmf->page = alloc_page(GFP_KERNEL);
+
+	if (pVmf->page)
+	{
+		PRINTK_VERBOSE(KERN_DEBUG "alloc page virtual %p\n", page_address(pVmf->page));
+	}
+
+	if (!pVmf->page)
+	{
+		PRINTK(KERN_ERR "vma fault oom (%s %d)\n", current->comm, current->pid);
+		return VM_FAULT_OOM;
+	}
+	else
+	{
+		struct VmaPageList *pVmaList;
+
+		get_page(pVmf->page);
+		g_trackedPages++;
+
+		//find our vma in the list
+		pVmaList = (struct VmaPageList *)pVma->vm_private_data;
+
+		if (pVmaList)
+		{
+			PRINTK_VERBOSE(KERN_DEBUG "vma found (%s %d)\n", current->comm, current->pid);
+
+			if (pVmaList->m_pPageTail->m_used == PAGES_PER_LIST)
+			{
+				PRINTK_VERBOSE(KERN_DEBUG "making new page list (%s %d)\n", current->comm, current->pid);
+				//making a new page list
+				pVmaList->m_pPageTail->m_pNext = (struct PageList *)kmalloc(sizeof(struct PageList), GFP_KERNEL);
+				if (!pVmaList->m_pPageTail->m_pNext)
+					return -ENOMEM;
+
+				//update the tail pointer
+				pVmaList->m_pPageTail = pVmaList->m_pPageTail->m_pNext;
+				pVmaList->m_pPageTail->m_used = 0;
+				pVmaList->m_pPageTail->m_pNext = 0;
+			}
+
+			PRINTK_VERBOSE(KERN_DEBUG "adding page to list (%s %d)\n", current->comm, current->pid);
+
+			pVmaList->m_pPageTail->m_pPages[pVmaList->m_pPageTail->m_used] = pVmf->page;
+			pVmaList->m_pPageTail->m_used++;
+		}
+		else
+			PRINTK(KERN_ERR "returned page for vma we don\'t know %p (%s %d)\n", pVma, current->comm, current->pid);
+
+		return 0;
+	}
+}
+
+/****** GENERIC FUNCTIONS ******/
+static int __init dmaer_init(void)
+{
+	int result = alloc_chrdev_region(&g_majorMinor, 0, 1, "dmaer");
+	if (result < 0)
+	{
+		PRINTK(KERN_ERR "unable to get major device number\n");
+		return result;
+	}
+	else
+		PRINTK(KERN_DEBUG "major device number %d\n", MAJOR(g_majorMinor));
+
+	PRINTK(KERN_DEBUG "vma list size %d, page list size %d, page size %ld\n",
+		sizeof(struct VmaPageList), sizeof(struct PageList), PAGE_SIZE);
+
+	//get a dma channel to work with
+	result = bcm_dma_chan_alloc(BCM_DMA_FEATURE_FAST, (void **)&g_pDmaChanBase, &g_dmaIrq);
+
+	//uncomment to force to channel 0
+	//result = 0;
+	//g_pDmaChanBase = 0xce808000;
+
+	if (result < 0)
+	{
+		PRINTK(KERN_ERR "failed to allocate dma channel\n");
+		cdev_del(&g_cDev);
+		unregister_chrdev_region(g_majorMinor, 1);
+	}
+
+	//reset the channel
+	PRINTK(KERN_DEBUG "allocated dma channel %d (%p), initial state %08x\n", result, g_pDmaChanBase, *g_pDmaChanBase);
+	*g_pDmaChanBase = 1 << 31;
+	PRINTK(KERN_DEBUG "post-reset %08x\n", *g_pDmaChanBase);
+
+	g_dmaChan = result;
+
+	//clear the cache stats
+	g_cacheHit = 0;
+	g_cacheMiss = 0;
+
+	//register our device - after this we are go go go
+	cdev_init(&g_cDev, &g_fOps);
+	g_cDev.owner = THIS_MODULE;
+	g_cDev.ops = &g_fOps;
+
+	result = cdev_add(&g_cDev, g_majorMinor, 1);
+	if (result < 0)
+	{
+		PRINTK(KERN_ERR "failed to add character device\n");
+		unregister_chrdev_region(g_majorMinor, 1);
+		bcm_dma_chan_free(g_dmaChan);
+		return result;
+	}
+
+	return 0;
+}
+
+static void __exit dmaer_exit(void)
+{
+	PRINTK(KERN_INFO "closing dmaer device, cache stats: %d hits %d misses\n", g_cacheHit, g_cacheMiss);
+	//unregister the device
+	cdev_del(&g_cDev);
+	unregister_chrdev_region(g_majorMinor, 1);
+	//free the dma channel
+	bcm_dma_chan_free(g_dmaChan);
+}
+
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_AUTHOR("Simon Hall");
+module_init(dmaer_init);
+module_exit(dmaer_exit);
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/arm_control.h
@@ -0,0 +1,493 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/arm_control.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __BCM2708_ARM_CONTROL_H
+#define __BCM2708_ARM_CONTROL_H
+
+/*
+ * Definitions and addresses for the ARM CONTROL logic
+ * This file is manually generated.
+ */
+
+#define ARM_BASE  0x7E00B000
+
+/* Basic configuration */
+#define ARM_CONTROL0  HW_REGISTER_RW(ARM_BASE+0x000)
+#define ARM_C0_SIZ128M   0x00000000
+#define ARM_C0_SIZ256M   0x00000001
+#define ARM_C0_SIZ512M   0x00000002
+#define ARM_C0_SIZ1G     0x00000003
+#define ARM_C0_BRESP0    0x00000000
+#define ARM_C0_BRESP1    0x00000004
+#define ARM_C0_BRESP2    0x00000008
+#define ARM_C0_BOOTHI    0x00000010
+#define ARM_C0_UNUSED05  0x00000020 /* free */
+#define ARM_C0_FULLPERI  0x00000040
+#define ARM_C0_UNUSED78  0x00000180 /* free */
+#define ARM_C0_JTAGMASK  0x00000E00
+#define ARM_C0_JTAGOFF   0x00000000
+#define ARM_C0_JTAGBASH  0x00000800 /* Debug on GPIO off */
+#define ARM_C0_JTAGGPIO  0x00000C00 /* Debug on GPIO on */
+#define ARM_C0_APROTMSK  0x0000F000
+#define ARM_C0_DBG0SYNC  0x00010000 /* VPU0 halt sync */
+#define ARM_C0_DBG1SYNC  0x00020000 /* VPU1 halt sync */
+#define ARM_C0_SWDBGREQ  0x00040000 /* HW debug request */
+#define ARM_C0_PASSHALT  0x00080000 /* ARM halt passed to debugger */
+#define ARM_C0_PRIO_PER  0x00F00000 /* per priority mask */
+#define ARM_C0_PRIO_L2   0x0F000000
+#define ARM_C0_PRIO_UC   0xF0000000
+
+#define ARM_C0_APROTPASS  0x0000A000 /* Translate 1:1 */
+#define ARM_C0_APROTUSER  0x00000000 /* Only user mode */
+#define ARM_C0_APROTSYST  0x0000F000 /* Only system mode */
+
+
+#define ARM_CONTROL1  HW_REGISTER_RW(ARM_BASE+0x440)
+#define ARM_C1_TIMER     0x00000001 /* re-route timer IRQ  to VC */
+#define ARM_C1_MAIL      0x00000002 /* re-route Mail IRQ   to VC */
+#define ARM_C1_BELL0     0x00000004 /* re-route Doorbell 0 to VC */
+#define ARM_C1_BELL1     0x00000008 /* re-route Doorbell 1 to VC */
+#define ARM_C1_PERSON    0x00000100 /* peripherals on */
+#define ARM_C1_REQSTOP   0x00000200 /* ASYNC bridge request stop */
+
+#define ARM_STATUS    HW_REGISTER_RW(ARM_BASE+0x444)
+#define ARM_S_ACKSTOP    0x80000000 /* Bridge stopped */
+#define ARM_S_READPEND   0x000003FF /* pending reads counter */
+#define ARM_S_WRITPEND   0x000FFC00 /* pending writes counter */
+
+#define ARM_ERRHALT   HW_REGISTER_RW(ARM_BASE+0x448)
+#define ARM_EH_PERIBURST  0x00000001 /* Burst write seen on peri bus */
+#define ARM_EH_ILLADDRS1  0x00000002 /* Address bits 25-27 error */
+#define ARM_EH_ILLADDRS2  0x00000004 /* Address bits 31-28 error */
+#define ARM_EH_VPU0HALT   0x00000008 /* VPU0 halted & in debug mode */
+#define ARM_EH_VPU1HALT   0x00000010 /* VPU1 halted & in debug mode */
+#define ARM_EH_ARMHALT    0x00000020 /* ARM in halted debug mode */
+
+#define ARM_ID_SECURE HW_REGISTER_RW(ARM_BASE+0x00C)
+#define ARM_ID        HW_REGISTER_RW(ARM_BASE+0x44C)
+#define ARM_IDVAL        0x364D5241
+
+/* Translation memory */
+#define ARM_TRANSLATE HW_REGISTER_RW(ARM_BASE+0x100)
+/* 32 locations: 0x100.. 0x17F */
+/* 32 spare means we CAN go to 64 pages.... */
+
+
+/* Interrupts */
+#define ARM_IRQ_PEND0 HW_REGISTER_RW(ARM_BASE+0x200)        /* Top IRQ bits */
+#define ARM_I0_TIMER    0x00000001 /* timer IRQ */
+#define ARM_I0_MAIL     0x00000002 /* Mail IRQ */
+#define ARM_I0_BELL0    0x00000004 /* Doorbell 0 */
+#define ARM_I0_BELL1    0x00000008 /* Doorbell 1 */
+#define ARM_I0_BANK1    0x00000100 /* Bank1 IRQ */
+#define ARM_I0_BANK2    0x00000200 /* Bank2 IRQ */
+
+#define ARM_IRQ_PEND1 HW_REGISTER_RW(ARM_BASE+0x204) /* All bank1 IRQ bits */
+/* todo: all I1_interrupt sources */
+#define ARM_IRQ_PEND2 HW_REGISTER_RW(ARM_BASE+0x208) /* All bank2 IRQ bits */
+/* todo: all I2_interrupt sources */
+
+#define ARM_IRQ_FAST  HW_REGISTER_RW(ARM_BASE+0x20C) /* FIQ control */
+#define ARM_IF_INDEX    0x0000007F     /* FIQ select */
+#define ARM_IF_ENABLE   0x00000080     /* FIQ enable */
+#define ARM_IF_VCMASK   0x0000003F     /* FIQ = (index from VC source) */
+#define ARM_IF_TIMER    0x00000040     /* FIQ = ARM timer */
+#define ARM_IF_MAIL     0x00000041     /* FIQ = ARM Mail */
+#define ARM_IF_BELL0    0x00000042     /* FIQ = ARM Doorbell 0 */
+#define ARM_IF_BELL1    0x00000043     /* FIQ = ARM Doorbell 1 */
+#define ARM_IF_VP0HALT  0x00000044     /* FIQ = VPU0 Halt seen */
+#define ARM_IF_VP1HALT  0x00000045     /* FIQ = VPU1 Halt seen */
+#define ARM_IF_ILLEGAL  0x00000046     /* FIQ = Illegal access seen */
+
+#define ARM_IRQ_ENBL1 HW_REGISTER_RW(ARM_BASE+0x210) /* Bank1 enable bits */
+#define ARM_IRQ_ENBL2 HW_REGISTER_RW(ARM_BASE+0x214) /* Bank2 enable bits */
+#define ARM_IRQ_ENBL3 HW_REGISTER_RW(ARM_BASE+0x218) /* ARM irqs enable bits */
+#define ARM_IRQ_DIBL1 HW_REGISTER_RW(ARM_BASE+0x21C) /* Bank1 disable bits */
+#define ARM_IRQ_DIBL2 HW_REGISTER_RW(ARM_BASE+0x220) /* Bank2 disable bits */
+#define ARM_IRQ_DIBL3 HW_REGISTER_RW(ARM_BASE+0x224) /* ARM irqs disable bits */
+#define ARM_IE_TIMER    0x00000001     /* Timer IRQ */
+#define ARM_IE_MAIL     0x00000002     /* Mail IRQ */
+#define ARM_IE_BELL0    0x00000004     /* Doorbell 0 */
+#define ARM_IE_BELL1    0x00000008     /* Doorbell 1 */
+#define ARM_IE_VP0HALT  0x00000010     /* VPU0 Halt */
+#define ARM_IE_VP1HALT  0x00000020     /* VPU1 Halt */
+#define ARM_IE_ILLEGAL  0x00000040     /* Illegal access seen */
+
+/* Timer */
+/* For reg. fields see sp804 spec. */
+#define ARM_T_LOAD    HW_REGISTER_RW(ARM_BASE+0x400)
+#define ARM_T_VALUE   HW_REGISTER_RW(ARM_BASE+0x404)
+#define ARM_T_CONTROL HW_REGISTER_RW(ARM_BASE+0x408)
+#define ARM_T_IRQCNTL HW_REGISTER_RW(ARM_BASE+0x40C)
+#define ARM_T_RAWIRQ  HW_REGISTER_RW(ARM_BASE+0x410)
+#define ARM_T_MSKIRQ  HW_REGISTER_RW(ARM_BASE+0x414)
+#define ARM_T_RELOAD  HW_REGISTER_RW(ARM_BASE+0x418)
+#define ARM_T_PREDIV  HW_REGISTER_RW(ARM_BASE+0x41c)
+#define ARM_T_FREECNT HW_REGISTER_RW(ARM_BASE+0x420)
+
+#define TIMER_CTRL_ONESHOT  (1 << 0)
+#define TIMER_CTRL_32BIT    (1 << 1)
+#define TIMER_CTRL_DIV1     (0 << 2)
+#define TIMER_CTRL_DIV16    (1 << 2)
+#define TIMER_CTRL_DIV256   (2 << 2)
+#define TIMER_CTRL_IE       (1 << 5)
+#define TIMER_CTRL_PERIODIC (1 << 6)
+#define TIMER_CTRL_ENABLE   (1 << 7)
+#define TIMER_CTRL_DBGHALT  (1 << 8)
+#define TIMER_CTRL_ENAFREE  (1 << 9)
+#define TIMER_CTRL_FREEDIV_SHIFT 16)
+#define TIMER_CTRL_FREEDIV_MASK  0xff
+
+/* Semaphores, Doorbells, Mailboxes */
+#define ARM_SBM_OWN0  (ARM_BASE+0x800)
+#define ARM_SBM_OWN1  (ARM_BASE+0x900)
+#define ARM_SBM_OWN2  (ARM_BASE+0xA00)
+#define ARM_SBM_OWN3  (ARM_BASE+0xB00)
+
+/* MAILBOXES
+ * Register flags are common across all
+ * owner registers. See end of this section
+ *
+ * Semaphores, Doorbells, Mailboxes Owner 0
+ *
+ */
+
+#define ARM_0_SEMS       HW_REGISTER_RW(ARM_SBM_OWN0+0x00)
+#define ARM_0_SEM0       HW_REGISTER_RW(ARM_SBM_OWN0+0x00)
+#define ARM_0_SEM1       HW_REGISTER_RW(ARM_SBM_OWN0+0x04)
+#define ARM_0_SEM2       HW_REGISTER_RW(ARM_SBM_OWN0+0x08)
+#define ARM_0_SEM3       HW_REGISTER_RW(ARM_SBM_OWN0+0x0C)
+#define ARM_0_SEM4       HW_REGISTER_RW(ARM_SBM_OWN0+0x10)
+#define ARM_0_SEM5       HW_REGISTER_RW(ARM_SBM_OWN0+0x14)
+#define ARM_0_SEM6       HW_REGISTER_RW(ARM_SBM_OWN0+0x18)
+#define ARM_0_SEM7       HW_REGISTER_RW(ARM_SBM_OWN0+0x1C)
+#define ARM_0_BELL0      HW_REGISTER_RW(ARM_SBM_OWN0+0x40)
+#define ARM_0_BELL1      HW_REGISTER_RW(ARM_SBM_OWN0+0x44)
+#define ARM_0_BELL2      HW_REGISTER_RW(ARM_SBM_OWN0+0x48)
+#define ARM_0_BELL3      HW_REGISTER_RW(ARM_SBM_OWN0+0x4C)
+/* MAILBOX 0 access in Owner 0 area */
+/* Some addresses should ONLY be used by owner 0 */
+#define ARM_0_MAIL0_WRT  HW_REGISTER_RW(ARM_SBM_OWN0+0x80)  /* .. 0x8C (4 locations) */
+#define ARM_0_MAIL0_RD   HW_REGISTER_RW(ARM_SBM_OWN0+0x80)  /* .. 0x8C (4 locations) Normal read */
+#define ARM_0_MAIL0_POL  HW_REGISTER_RW(ARM_SBM_OWN0+0x90)  /* none-pop read */
+#define ARM_0_MAIL0_SND  HW_REGISTER_RW(ARM_SBM_OWN0+0x94)  /* Sender read (only LS 2 bits) */
+#define ARM_0_MAIL0_STA  HW_REGISTER_RW(ARM_SBM_OWN0+0x98)  /* Status read */
+#define ARM_0_MAIL0_CNF  HW_REGISTER_RW(ARM_SBM_OWN0+0x9C)  /* Config read/write */
+/* MAILBOX 1 access in Owner 0 area */
+/* Owner 0 should only WRITE to this mailbox */
+#define ARM_0_MAIL1_WRT  HW_REGISTER_RW(ARM_SBM_OWN0+0xA0)   /* .. 0xAC (4 locations) */
+/*#define ARM_0_MAIL1_RD   HW_REGISTER_RW(ARM_SBM_OWN0+0xA0) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_0_MAIL1_POL  HW_REGISTER_RW(ARM_SBM_OWN0+0xB0) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_0_MAIL1_SND  HW_REGISTER_RW(ARM_SBM_OWN0+0xB4) */ /* DO NOT USE THIS !!!!! */
+#define ARM_0_MAIL1_STA  HW_REGISTER_RW(ARM_SBM_OWN0+0xB8)   /* Status read */
+/*#define ARM_0_MAIL1_CNF  HW_REGISTER_RW(ARM_SBM_OWN0+0xBC) */ /* DO NOT USE THIS !!!!! */
+/* General SEM, BELL, MAIL config/status */
+#define ARM_0_SEMCLRDBG   HW_REGISTER_RW(ARM_SBM_OWN0+0xE0)  /* semaphore clear/debug register */
+#define ARM_0_BELLCLRDBG  HW_REGISTER_RW(ARM_SBM_OWN0+0xE4)  /* Doorbells clear/debug register */
+#define ARM_0_ALL_IRQS    HW_REGISTER_RW(ARM_SBM_OWN0+0xF8)  /* ALL interrupts */
+#define ARM_0_MY_IRQS     HW_REGISTER_RW(ARM_SBM_OWN0+0xFC)  /* IRQS pending for owner 0 */
+
+/* Semaphores, Doorbells, Mailboxes Owner 1 */
+#define ARM_1_SEMS       HW_REGISTER_RW(ARM_SBM_OWN1+0x00)
+#define ARM_1_SEM0       HW_REGISTER_RW(ARM_SBM_OWN1+0x00)
+#define ARM_1_SEM1       HW_REGISTER_RW(ARM_SBM_OWN1+0x04)
+#define ARM_1_SEM2       HW_REGISTER_RW(ARM_SBM_OWN1+0x08)
+#define ARM_1_SEM3       HW_REGISTER_RW(ARM_SBM_OWN1+0x0C)
+#define ARM_1_SEM4       HW_REGISTER_RW(ARM_SBM_OWN1+0x10)
+#define ARM_1_SEM5       HW_REGISTER_RW(ARM_SBM_OWN1+0x14)
+#define ARM_1_SEM6       HW_REGISTER_RW(ARM_SBM_OWN1+0x18)
+#define ARM_1_SEM7       HW_REGISTER_RW(ARM_SBM_OWN1+0x1C)
+#define ARM_1_BELL0      HW_REGISTER_RW(ARM_SBM_OWN1+0x40)
+#define ARM_1_BELL1      HW_REGISTER_RW(ARM_SBM_OWN1+0x44)
+#define ARM_1_BELL2      HW_REGISTER_RW(ARM_SBM_OWN1+0x48)
+#define ARM_1_BELL3      HW_REGISTER_RW(ARM_SBM_OWN1+0x4C)
+/* MAILBOX 0 access in Owner 0 area */
+/* Owner 1 should only WRITE to this mailbox */
+#define ARM_1_MAIL0_WRT  HW_REGISTER_RW(ARM_SBM_OWN1+0x80)  /* .. 0x8C (4 locations) */
+/*#define ARM_1_MAIL0_RD  HW_REGISTER_RW(ARM_SBM_OWN1+0x80) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_1_MAIL0_POL HW_REGISTER_RW(ARM_SBM_OWN1+0x90) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_1_MAIL0_SND HW_REGISTER_RW(ARM_SBM_OWN1+0x94) */ /* DO NOT USE THIS !!!!! */
+#define ARM_1_MAIL0_STA  HW_REGISTER_RW(ARM_SBM_OWN1+0x98)  /* Status read */
+/*#define ARM_1_MAIL0_CNF HW_REGISTER_RW(ARM_SBM_OWN1+0x9C) */ /* DO NOT USE THIS !!!!! */
+/* MAILBOX 1 access in Owner 0 area */
+#define ARM_1_MAIL1_WRT  HW_REGISTER_RW(ARM_SBM_OWN1+0xA0)  /* .. 0xAC (4 locations) */
+#define ARM_1_MAIL1_RD   HW_REGISTER_RW(ARM_SBM_OWN1+0xA0)  /* .. 0xAC (4 locations) Normal read */
+#define ARM_1_MAIL1_POL  HW_REGISTER_RW(ARM_SBM_OWN1+0xB0)  /* none-pop read */
+#define ARM_1_MAIL1_SND  HW_REGISTER_RW(ARM_SBM_OWN1+0xB4)  /* Sender read (only LS 2 bits) */
+#define ARM_1_MAIL1_STA  HW_REGISTER_RW(ARM_SBM_OWN1+0xB8)  /* Status read */
+#define ARM_1_MAIL1_CNF  HW_REGISTER_RW(ARM_SBM_OWN1+0xBC)
+/* General SEM, BELL, MAIL config/status */
+#define ARM_1_SEMCLRDBG   HW_REGISTER_RW(ARM_SBM_OWN1+0xE0)  /* semaphore clear/debug register */
+#define ARM_1_BELLCLRDBG  HW_REGISTER_RW(ARM_SBM_OWN1+0xE4)  /* Doorbells clear/debug register */
+#define ARM_1_MY_IRQS     HW_REGISTER_RW(ARM_SBM_OWN1+0xFC)  /* IRQS pending for owner 1 */
+#define ARM_1_ALL_IRQS    HW_REGISTER_RW(ARM_SBM_OWN1+0xF8)  /* ALL interrupts */
+
+/* Semaphores, Doorbells, Mailboxes Owner 2 */
+#define ARM_2_SEMS       HW_REGISTER_RW(ARM_SBM_OWN2+0x00)
+#define ARM_2_SEM0       HW_REGISTER_RW(ARM_SBM_OWN2+0x00)
+#define ARM_2_SEM1       HW_REGISTER_RW(ARM_SBM_OWN2+0x04)
+#define ARM_2_SEM2       HW_REGISTER_RW(ARM_SBM_OWN2+0x08)
+#define ARM_2_SEM3       HW_REGISTER_RW(ARM_SBM_OWN2+0x0C)
+#define ARM_2_SEM4       HW_REGISTER_RW(ARM_SBM_OWN2+0x10)
+#define ARM_2_SEM5       HW_REGISTER_RW(ARM_SBM_OWN2+0x14)
+#define ARM_2_SEM6       HW_REGISTER_RW(ARM_SBM_OWN2+0x18)
+#define ARM_2_SEM7       HW_REGISTER_RW(ARM_SBM_OWN2+0x1C)
+#define ARM_2_BELL0      HW_REGISTER_RW(ARM_SBM_OWN2+0x40)
+#define ARM_2_BELL1      HW_REGISTER_RW(ARM_SBM_OWN2+0x44)
+#define ARM_2_BELL2      HW_REGISTER_RW(ARM_SBM_OWN2+0x48)
+#define ARM_2_BELL3      HW_REGISTER_RW(ARM_SBM_OWN2+0x4C)
+/* MAILBOX 0 access in Owner 2 area */
+/* Owner 2 should only WRITE to this mailbox */
+#define ARM_2_MAIL0_WRT  HW_REGISTER_RW(ARM_SBM_OWN2+0x80)   /* .. 0x8C (4 locations) */
+/*#define ARM_2_MAIL0_RD  HW_REGISTER_RW(ARM_SBM_OWN2+0x80)  */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_2_MAIL0_POL HW_REGISTER_RW(ARM_SBM_OWN2+0x90)  */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_2_MAIL0_SND HW_REGISTER_RW(ARM_SBM_OWN2+0x94)  */ /* DO NOT USE THIS !!!!! */
+#define ARM_2_MAIL0_STA  HW_REGISTER_RW(ARM_SBM_OWN2+0x98)   /* Status read */
+/*#define ARM_2_MAIL0_CNF HW_REGISTER_RW(ARM_SBM_OWN2+0x9C)  */ /* DO NOT USE THIS !!!!! */
+/* MAILBOX 1 access in Owner 2 area */
+/* Owner 2 should only WRITE to this mailbox */
+#define ARM_2_MAIL1_WRT  HW_REGISTER_RW(ARM_SBM_OWN2+0xA0)   /* .. 0xAC (4 locations) */
+/*#define ARM_2_MAIL1_RD   HW_REGISTER_RW(ARM_SBM_OWN2+0xA0) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_2_MAIL1_POL  HW_REGISTER_RW(ARM_SBM_OWN2+0xB0) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_2_MAIL1_SND  HW_REGISTER_RW(ARM_SBM_OWN2+0xB4) */ /* DO NOT USE THIS !!!!! */
+#define ARM_2_MAIL1_STA  HW_REGISTER_RW(ARM_SBM_OWN2+0xB8)   /* Status read */
+/*#define ARM_2_MAIL1_CNF  HW_REGISTER_RW(ARM_SBM_OWN2+0xBC) */ /* DO NOT USE THIS !!!!! */
+/* General SEM, BELL, MAIL config/status */
+#define ARM_2_SEMCLRDBG   HW_REGISTER_RW(ARM_SBM_OWN2+0xE0)  /* semaphore clear/debug register */
+#define ARM_2_BELLCLRDBG  HW_REGISTER_RW(ARM_SBM_OWN2+0xE4)  /* Doorbells clear/debug register */
+#define ARM_2_MY_IRQS     HW_REGISTER_RW(ARM_SBM_OWN2+0xFC)  /* IRQS pending for owner 2 */
+#define ARM_2_ALL_IRQS    HW_REGISTER_RW(ARM_SBM_OWN2+0xF8)  /* ALL interrupts */
+
+/* Semaphores, Doorbells, Mailboxes Owner 3 */
+#define ARM_3_SEMS       HW_REGISTER_RW(ARM_SBM_OWN3+0x00)
+#define ARM_3_SEM0       HW_REGISTER_RW(ARM_SBM_OWN3+0x00)
+#define ARM_3_SEM1       HW_REGISTER_RW(ARM_SBM_OWN3+0x04)
+#define ARM_3_SEM2       HW_REGISTER_RW(ARM_SBM_OWN3+0x08)
+#define ARM_3_SEM3       HW_REGISTER_RW(ARM_SBM_OWN3+0x0C)
+#define ARM_3_SEM4       HW_REGISTER_RW(ARM_SBM_OWN3+0x10)
+#define ARM_3_SEM5       HW_REGISTER_RW(ARM_SBM_OWN3+0x14)
+#define ARM_3_SEM6       HW_REGISTER_RW(ARM_SBM_OWN3+0x18)
+#define ARM_3_SEM7       HW_REGISTER_RW(ARM_SBM_OWN3+0x1C)
+#define ARM_3_BELL0      HW_REGISTER_RW(ARM_SBM_OWN3+0x40)
+#define ARM_3_BELL1      HW_REGISTER_RW(ARM_SBM_OWN3+0x44)
+#define ARM_3_BELL2      HW_REGISTER_RW(ARM_SBM_OWN3+0x48)
+#define ARM_3_BELL3      HW_REGISTER_RW(ARM_SBM_OWN3+0x4C)
+/* MAILBOX 0 access in Owner 3 area */
+/* Owner 3 should only WRITE to this mailbox */
+#define ARM_3_MAIL0_WRT  HW_REGISTER_RW(ARM_SBM_OWN3+0x80)   /* .. 0x8C (4 locations) */
+/*#define ARM_3_MAIL0_RD  HW_REGISTER_RW(ARM_SBM_OWN3+0x80)  */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_3_MAIL0_POL HW_REGISTER_RW(ARM_SBM_OWN3+0x90)  */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_3_MAIL0_SND HW_REGISTER_RW(ARM_SBM_OWN3+0x94)  */ /* DO NOT USE THIS !!!!! */
+#define ARM_3_MAIL0_STA HW_REGISTER_RW(ARM_SBM_OWN3+0x98)    /* Status read */
+/*#define ARM_3_MAIL0_CNF HW_REGISTER_RW(ARM_SBM_OWN3+0x9C)  */ /* DO NOT USE THIS !!!!! */
+/* MAILBOX 1 access in Owner 3 area */
+/* Owner 3 should only WRITE to this mailbox */
+#define ARM_3_MAIL1_WRT  HW_REGISTER_RW(ARM_SBM_OWN3+0xA0)   /* .. 0xAC (4 locations) */
+/*#define ARM_3_MAIL1_RD   HW_REGISTER_RW(ARM_SBM_OWN3+0xA0) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_3_MAIL1_POL  HW_REGISTER_RW(ARM_SBM_OWN3+0xB0) */ /* DO NOT USE THIS !!!!! */
+/*#define ARM_3_MAIL1_SND  HW_REGISTER_RW(ARM_SBM_OWN3+0xB4) */ /* DO NOT USE THIS !!!!! */
+#define ARM_3_MAIL1_STA  HW_REGISTER_RW(ARM_SBM_OWN3+0xB8)   /* Status read */
+/*#define ARM_3_MAIL1_CNF  HW_REGISTER_RW(ARM_SBM_OWN3+0xBC) */ /* DO NOT USE THIS !!!!! */
+/* General SEM, BELL, MAIL config/status */
+#define ARM_3_SEMCLRDBG   HW_REGISTER_RW(ARM_SBM_OWN3+0xE0)  /* semaphore clear/debug register */
+#define ARM_3_BELLCLRDBG  HW_REGISTER_RW(ARM_SBM_OWN3+0xE4)  /* Doorbells clear/debug register */
+#define ARM_3_MY_IRQS     HW_REGISTER_RW(ARM_SBM_OWN3+0xFC)  /* IRQS pending for owner 3 */
+#define ARM_3_ALL_IRQS    HW_REGISTER_RW(ARM_SBM_OWN3+0xF8)  /* ALL interrupts */
+
+
+
+/*  Mailbox flags. Valid for all owners */
+
+/* Mailbox status register (...0x98) */
+#define ARM_MS_FULL       0x80000000
+#define ARM_MS_EMPTY      0x40000000
+#define ARM_MS_LEVEL      0x400000FF /* Max. value depdnds on mailbox depth parameter */
+
+/* MAILBOX config/status register (...0x9C) */
+/* ANY write to this register clears the error bits! */
+#define ARM_MC_IHAVEDATAIRQEN    0x00000001 /* mailbox irq enable:  has data */
+#define ARM_MC_IHAVESPACEIRQEN   0x00000002 /* mailbox irq enable:  has space */
+#define ARM_MC_OPPISEMPTYIRQEN   0x00000004 /* mailbox irq enable: Opp. is empty */
+#define ARM_MC_MAIL_CLEAR        0x00000008 /* mailbox clear write 1, then  0 */
+#define ARM_MC_IHAVEDATAIRQPEND  0x00000010 /* mailbox irq pending:  has space */
+#define ARM_MC_IHAVESPACEIRQPEND 0x00000020 /* mailbox irq pending: Opp. is empty */
+#define ARM_MC_OPPISEMPTYIRQPEND 0x00000040 /* mailbox irq pending */
+/* Bit 7 is unused */
+#define ARM_MC_ERRNOOWN   0x00000100 /* error : none owner read from mailbox */
+#define ARM_MC_ERROVERFLW 0x00000200 /* error : write to fill mailbox */
+#define ARM_MC_ERRUNDRFLW 0x00000400 /* error : read from empty mailbox */
+
+/* Semaphore clear/debug register (...0xE0) */
+#define ARM_SD_OWN0      0x00000003  /* Owner of sem 0 */
+#define ARM_SD_OWN1      0x0000000C  /* Owner of sem 1 */
+#define ARM_SD_OWN2      0x00000030  /* Owner of sem 2 */
+#define ARM_SD_OWN3      0x000000C0  /* Owner of sem 3 */
+#define ARM_SD_OWN4      0x00000300  /* Owner of sem 4 */
+#define ARM_SD_OWN5      0x00000C00  /* Owner of sem 5 */
+#define ARM_SD_OWN6      0x00003000  /* Owner of sem 6 */
+#define ARM_SD_OWN7      0x0000C000  /* Owner of sem 7 */
+#define ARM_SD_SEM0      0x00010000  /* Status of sem 0 */
+#define ARM_SD_SEM1      0x00020000  /* Status of sem 1 */
+#define ARM_SD_SEM2      0x00040000  /* Status of sem 2 */
+#define ARM_SD_SEM3      0x00080000  /* Status of sem 3 */
+#define ARM_SD_SEM4      0x00100000  /* Status of sem 4 */
+#define ARM_SD_SEM5      0x00200000  /* Status of sem 5 */
+#define ARM_SD_SEM6      0x00400000  /* Status of sem 6 */
+#define ARM_SD_SEM7      0x00800000  /* Status of sem 7 */
+
+/* Doorbells clear/debug register (...0xE4) */
+#define ARM_BD_OWN0      0x00000003  /* Owner of doorbell 0 */
+#define ARM_BD_OWN1      0x0000000C  /* Owner of doorbell 1 */
+#define ARM_BD_OWN2      0x00000030  /* Owner of doorbell 2 */
+#define ARM_BD_OWN3      0x000000C0  /* Owner of doorbell 3 */
+#define ARM_BD_BELL0     0x00000100  /* Status of doorbell 0 */
+#define ARM_BD_BELL1     0x00000200  /* Status of doorbell 1 */
+#define ARM_BD_BELL2     0x00000400  /* Status of doorbell 2 */
+#define ARM_BD_BELL3     0x00000800  /* Status of doorbell 3 */
+
+/* MY IRQS register (...0xF8) */
+#define ARM_MYIRQ_BELL   0x00000001  /* This owner has a doorbell IRQ */
+#define ARM_MYIRQ_MAIL   0x00000002  /* This owner has a mailbox  IRQ */
+
+/* ALL IRQS register (...0xF8) */
+#define ARM_AIS_BELL0 0x00000001  /* Doorbell 0 IRQ pending */
+#define ARM_AIS_BELL1 0x00000002  /* Doorbell 1 IRQ pending */
+#define ARM_AIS_BELL2 0x00000004  /* Doorbell 2 IRQ pending */
+#define ARM_AIS_BELL3 0x00000008  /* Doorbell 3 IRQ pending */
+#define ARM_AIS0_HAVEDATA 0x00000010  /* MAIL 0 has data IRQ pending */
+#define ARM_AIS0_HAVESPAC 0x00000020  /* MAIL 0 has space IRQ pending */
+#define ARM_AIS0_OPPEMPTY 0x00000040  /* MAIL 0 opposite is empty IRQ */
+#define ARM_AIS1_HAVEDATA 0x00000080  /* MAIL 1 has data IRQ pending */
+#define ARM_AIS1_HAVESPAC 0x00000100  /* MAIL 1 has space IRQ pending */
+#define ARM_AIS1_OPPEMPTY 0x00000200  /* MAIL 1 opposite is empty IRQ */
+/* Note   that bell-0, bell-1 and MAIL0 IRQ go only to the ARM */
+/* Whilst that bell-2, bell-3 and MAIL1 IRQ go only to the VC */
+/* */
+/* ARM JTAG BASH */
+/* */
+#define AJB_BASE 0x7e2000c0
+
+#define AJBCONF HW_REGISTER_RW(AJB_BASE+0x00)
+#define   AJB_BITS0    0x000000
+#define   AJB_BITS4    0x000004
+#define   AJB_BITS8    0x000008
+#define   AJB_BITS12   0x00000C
+#define   AJB_BITS16   0x000010
+#define   AJB_BITS20   0x000014
+#define   AJB_BITS24   0x000018
+#define   AJB_BITS28   0x00001C
+#define   AJB_BITS32   0x000020
+#define   AJB_BITS34   0x000022
+#define   AJB_OUT_MS   0x000040
+#define   AJB_OUT_LS   0x000000
+#define   AJB_INV_CLK  0x000080
+#define   AJB_D0_RISE  0x000100
+#define   AJB_D0_FALL  0x000000
+#define   AJB_D1_RISE  0x000200
+#define   AJB_D1_FALL  0x000000
+#define   AJB_IN_RISE  0x000400
+#define   AJB_IN_FALL  0x000000
+#define   AJB_ENABLE   0x000800
+#define   AJB_HOLD0    0x000000
+#define   AJB_HOLD1    0x001000
+#define   AJB_HOLD2    0x002000
+#define   AJB_HOLD3    0x003000
+#define   AJB_RESETN   0x004000
+#define   AJB_CLKSHFT  16
+#define   AJB_BUSY     0x80000000
+#define AJBTMS HW_REGISTER_RW(AJB_BASE+0x04)
+#define AJBTDI HW_REGISTER_RW(AJB_BASE+0x08)
+#define AJBTDO HW_REGISTER_RW(AJB_BASE+0x0c)
+
+#define ARM_LOCAL_BASE 0x40000000
+#define ARM_LOCAL_CONTROL		HW_REGISTER_RW(ARM_LOCAL_BASE+0x000)
+#define ARM_LOCAL_PRESCALER		HW_REGISTER_RW(ARM_LOCAL_BASE+0x008)
+#define ARM_LOCAL_GPU_INT_ROUTING	HW_REGISTER_RW(ARM_LOCAL_BASE+0x00C)
+#define ARM_LOCAL_PM_ROUTING_SET	HW_REGISTER_RW(ARM_LOCAL_BASE+0x010)
+#define ARM_LOCAL_PM_ROUTING_CLR	HW_REGISTER_RW(ARM_LOCAL_BASE+0x014)
+#define ARM_LOCAL_TIMER_LS		HW_REGISTER_RW(ARM_LOCAL_BASE+0x01C)
+#define ARM_LOCAL_TIMER_MS		HW_REGISTER_RW(ARM_LOCAL_BASE+0x020)
+#define ARM_LOCAL_INT_ROUTING		HW_REGISTER_RW(ARM_LOCAL_BASE+0x024)
+#define ARM_LOCAL_AXI_COUNT		HW_REGISTER_RW(ARM_LOCAL_BASE+0x02C)
+#define ARM_LOCAL_AXI_IRQ		HW_REGISTER_RW(ARM_LOCAL_BASE+0x030)
+#define ARM_LOCAL_TIMER_CONTROL		HW_REGISTER_RW(ARM_LOCAL_BASE+0x034)
+#define ARM_LOCAL_TIMER_WRITE		HW_REGISTER_RW(ARM_LOCAL_BASE+0x038)
+
+#define ARM_LOCAL_TIMER_INT_CONTROL0	HW_REGISTER_RW(ARM_LOCAL_BASE+0x040)
+#define ARM_LOCAL_TIMER_INT_CONTROL1	HW_REGISTER_RW(ARM_LOCAL_BASE+0x044)
+#define ARM_LOCAL_TIMER_INT_CONTROL2	HW_REGISTER_RW(ARM_LOCAL_BASE+0x048)
+#define ARM_LOCAL_TIMER_INT_CONTROL3	HW_REGISTER_RW(ARM_LOCAL_BASE+0x04C)
+
+#define ARM_LOCAL_MAILBOX_INT_CONTROL0	HW_REGISTER_RW(ARM_LOCAL_BASE+0x050)
+#define ARM_LOCAL_MAILBOX_INT_CONTROL1	HW_REGISTER_RW(ARM_LOCAL_BASE+0x054)
+#define ARM_LOCAL_MAILBOX_INT_CONTROL2	HW_REGISTER_RW(ARM_LOCAL_BASE+0x058)
+#define ARM_LOCAL_MAILBOX_INT_CONTROL3	HW_REGISTER_RW(ARM_LOCAL_BASE+0x05C)
+
+#define ARM_LOCAL_IRQ_PENDING0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x060)
+#define ARM_LOCAL_IRQ_PENDING1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x064)
+#define ARM_LOCAL_IRQ_PENDING2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x068)
+#define ARM_LOCAL_IRQ_PENDING3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x06C)
+
+#define ARM_LOCAL_FIQ_PENDING0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x070)
+#define ARM_LOCAL_FIQ_PENDING1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x074)
+#define ARM_LOCAL_FIQ_PENDING2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x078)
+#define ARM_LOCAL_FIQ_PENDING3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x07C)
+
+#define ARM_LOCAL_MAILBOX0_SET0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x080)
+#define ARM_LOCAL_MAILBOX1_SET0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x084)
+#define ARM_LOCAL_MAILBOX2_SET0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x088)
+#define ARM_LOCAL_MAILBOX3_SET0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x08C)
+
+#define ARM_LOCAL_MAILBOX0_SET1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x090)
+#define ARM_LOCAL_MAILBOX1_SET1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x094)
+#define ARM_LOCAL_MAILBOX2_SET1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x098)
+#define ARM_LOCAL_MAILBOX3_SET1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x09C)
+
+#define ARM_LOCAL_MAILBOX0_SET2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0A0)
+#define ARM_LOCAL_MAILBOX1_SET2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0A4)
+#define ARM_LOCAL_MAILBOX2_SET2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0A8)
+#define ARM_LOCAL_MAILBOX3_SET2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0AC)
+
+#define ARM_LOCAL_MAILBOX0_SET3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0B0)
+#define ARM_LOCAL_MAILBOX1_SET3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0B4)
+#define ARM_LOCAL_MAILBOX2_SET3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0B8)
+#define ARM_LOCAL_MAILBOX3_SET3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0BC)
+
+#define ARM_LOCAL_MAILBOX0_CLR0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0C0)
+#define ARM_LOCAL_MAILBOX1_CLR0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0C4)
+#define ARM_LOCAL_MAILBOX2_CLR0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0C8)
+#define ARM_LOCAL_MAILBOX3_CLR0		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0CC)
+
+#define ARM_LOCAL_MAILBOX0_CLR1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0D0)
+#define ARM_LOCAL_MAILBOX1_CLR1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0D4)
+#define ARM_LOCAL_MAILBOX2_CLR1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0D8)
+#define ARM_LOCAL_MAILBOX3_CLR1		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0DC)
+
+#define ARM_LOCAL_MAILBOX0_CLR2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0E0)
+#define ARM_LOCAL_MAILBOX1_CLR2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0E4)
+#define ARM_LOCAL_MAILBOX2_CLR2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0E8)
+#define ARM_LOCAL_MAILBOX3_CLR2		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0EC)
+
+#define ARM_LOCAL_MAILBOX0_CLR3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0F0)
+#define ARM_LOCAL_MAILBOX1_CLR3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0F4)
+#define ARM_LOCAL_MAILBOX2_CLR3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0F8)
+#define ARM_LOCAL_MAILBOX3_CLR3		HW_REGISTER_RW(ARM_LOCAL_BASE+0x0FC)
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/arm_power.h
@@ -0,0 +1,62 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/include/mach/arm_power.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _ARM_POWER_H
+#define _ARM_POWER_H
+
+/* Use meaningful names on each side */
+#ifdef __VIDEOCORE__
+#define PREFIX(x) ARM_##x
+#else
+#define PREFIX(x) BCM_##x
+#endif
+
+enum {
+	PREFIX(POWER_SDCARD_BIT),
+	PREFIX(POWER_UART_BIT),
+	PREFIX(POWER_MINIUART_BIT),
+	PREFIX(POWER_USB_BIT),
+	PREFIX(POWER_I2C0_BIT),
+	PREFIX(POWER_I2C1_BIT),
+	PREFIX(POWER_I2C2_BIT),
+	PREFIX(POWER_SPI_BIT),
+	PREFIX(POWER_CCP2TX_BIT),
+	PREFIX(POWER_DSI_BIT),
+
+	PREFIX(POWER_MAX)
+};
+
+enum {
+	PREFIX(POWER_SDCARD) = (1 << PREFIX(POWER_SDCARD_BIT)),
+	PREFIX(POWER_UART) = (1 << PREFIX(POWER_UART_BIT)),
+	PREFIX(POWER_MINIUART) = (1 << PREFIX(POWER_MINIUART_BIT)),
+	PREFIX(POWER_USB) = (1 << PREFIX(POWER_USB_BIT)),
+	PREFIX(POWER_I2C0) = (1 << PREFIX(POWER_I2C0_BIT)),
+	PREFIX(POWER_I2C1_MASK) = (1 << PREFIX(POWER_I2C1_BIT)),
+	PREFIX(POWER_I2C2_MASK) = (1 << PREFIX(POWER_I2C2_BIT)),
+	PREFIX(POWER_SPI_MASK) = (1 << PREFIX(POWER_SPI_BIT)),
+	PREFIX(POWER_CCP2TX_MASK) = (1 << PREFIX(POWER_CCP2TX_BIT)),
+	PREFIX(POWER_DSI) = (1 << PREFIX(POWER_DSI_BIT)),
+
+	PREFIX(POWER_MASK) = (1 << PREFIX(POWER_MAX)) - 1,
+	PREFIX(POWER_NONE) = 0
+};
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/barriers.h
@@ -0,0 +1,3 @@
+#define mb()		dsb()
+#define rmb()		dsb()
+#define wmb()		mb()
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/debug-macro.S
@@ -0,0 +1,22 @@
+/* arch/arm/mach-bcm2708/include/mach/debug-macro.S
+ *
+ * Debugging macro include header
+ *
+ *  Copyright (C) 2010 Broadcom
+ *  Copyright (C) 1994-1999 Russell King
+ *  Moved from linux/arch/arm/kernel/debug.S by Ben Dooks
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <mach/platform.h>
+
+		.macro	addruart, rp, rv, tmp
+		ldr	\rp, =UART0_BASE
+		ldr	\rv, =IO_ADDRESS(UART0_BASE)
+		.endm
+
+#include <debug/pl01x.S>
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/dma.h
@@ -0,0 +1,94 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/include/mach/dma.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+
+#ifndef _MACH_BCM2708_DMA_H
+#define _MACH_BCM2708_DMA_H
+
+#define BCM_DMAMAN_DRIVER_NAME "bcm2708_dma"
+
+/* DMA CS Control and Status bits */
+#define BCM2708_DMA_ACTIVE	(1 << 0)
+#define BCM2708_DMA_INT		(1 << 2)
+#define BCM2708_DMA_ISPAUSED	(1 << 4)  /* Pause requested or not active */
+#define BCM2708_DMA_ISHELD	(1 << 5)  /* Is held by DREQ flow control */
+#define BCM2708_DMA_ERR		(1 << 8)
+#define BCM2708_DMA_ABORT	(1 << 30) /* stop current CB, go to next, WO */
+#define BCM2708_DMA_RESET	(1 << 31) /* WO, self clearing */
+
+/* DMA control block "info" field bits */
+#define BCM2708_DMA_INT_EN	(1 << 0)
+#define BCM2708_DMA_TDMODE	(1 << 1)
+#define BCM2708_DMA_WAIT_RESP	(1 << 3)
+#define BCM2708_DMA_D_INC	(1 << 4)
+#define BCM2708_DMA_D_WIDTH	(1 << 5)
+#define BCM2708_DMA_D_DREQ	(1 << 6)
+#define BCM2708_DMA_S_INC	(1 << 8)
+#define BCM2708_DMA_S_WIDTH	(1 << 9)
+#define BCM2708_DMA_S_DREQ	(1 << 10)
+
+#define	BCM2708_DMA_BURST(x)	(((x)&0xf) << 12)
+#define	BCM2708_DMA_PER_MAP(x)	((x) << 16)
+#define	BCM2708_DMA_WAITS(x)	(((x)&0x1f) << 21)
+
+#define BCM2708_DMA_DREQ_EMMC	11
+#define BCM2708_DMA_DREQ_SDHOST	13
+
+#define BCM2708_DMA_CS		0x00 /* Control and Status */
+#define BCM2708_DMA_ADDR	0x04
+/* the current control block appears in the following registers - read only */
+#define BCM2708_DMA_INFO	0x08
+#define BCM2708_DMA_SOURCE_AD	0x0c
+#define BCM2708_DMA_DEST_AD	0x10
+#define BCM2708_DMA_NEXTCB	0x1C
+#define BCM2708_DMA_DEBUG	0x20
+
+#define BCM2708_DMA4_CS		(BCM2708_DMA_CHAN(4)+BCM2708_DMA_CS)
+#define BCM2708_DMA4_ADDR	(BCM2708_DMA_CHAN(4)+BCM2708_DMA_ADDR)
+
+#define BCM2708_DMA_TDMODE_LEN(w, h) ((h) << 16 | (w))
+
+struct bcm2708_dma_cb {
+	unsigned long info;
+	unsigned long src;
+	unsigned long dst;
+	unsigned long length;
+	unsigned long stride;
+	unsigned long next;
+	unsigned long pad[2];
+};
+struct scatterlist;
+
+extern int bcm_sg_suitable_for_dma(struct scatterlist *sg_ptr, int sg_len);
+extern void bcm_dma_start(void __iomem *dma_chan_base,
+			  dma_addr_t control_block);
+extern void bcm_dma_wait_idle(void __iomem *dma_chan_base);
+extern bool bcm_dma_is_busy(void __iomem *dma_chan_base);
+extern int /*rc*/ bcm_dma_abort(void __iomem *dma_chan_base);
+
+/* When listing features we can ask for when allocating DMA channels give
+   those with higher priority smaller ordinal numbers */
+#define BCM_DMA_FEATURE_FAST_ORD 0
+#define BCM_DMA_FEATURE_BULK_ORD 1
+#define BCM_DMA_FEATURE_NORMAL_ORD 2
+#define BCM_DMA_FEATURE_LITE_ORD 3
+#define BCM_DMA_FEATURE_FAST	 (1<<BCM_DMA_FEATURE_FAST_ORD)
+#define BCM_DMA_FEATURE_BULK	 (1<<BCM_DMA_FEATURE_BULK_ORD)
+#define BCM_DMA_FEATURE_NORMAL	 (1<<BCM_DMA_FEATURE_NORMAL_ORD)
+#define BCM_DMA_FEATURE_LITE	 (1<<BCM_DMA_FEATURE_LITE_ORD)
+#define BCM_DMA_FEATURE_COUNT	 4
+
+/* return channel no or -ve error */
+extern int bcm_dma_chan_alloc(unsigned preferred_feature_set,
+			      void __iomem **out_dma_base, int *out_dma_irq);
+extern int bcm_dma_chan_free(int channel);
+
+
+#endif /* _MACH_BCM2708_DMA_H */
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/entry-macro.S
@@ -0,0 +1,123 @@
+/*
+ * arch/arm/mach-bcm2708/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for BCM2708 platforms
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro  get_irqnr_preamble, base, tmp
+		ldr	\base, =IO_ADDRESS(ARMCTRL_IC_BASE)
+		.endm
+
+		.macro  arch_ret_to_user, tmp1, tmp2
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		/* get core number */
+		mrc     p15, 0, \tmp, c0, c0, 5
+		ubfx    \tmp, \tmp, #0, #2
+
+		/* get core's local interrupt controller */
+		ldr	\irqstat, = __io_address(ARM_LOCAL_IRQ_PENDING0)	@ local interrupt source
+		add	\irqstat, \irqstat, \tmp, lsl #2
+		ldr	\tmp, [\irqstat]
+		/* ignore gpu interrupt */
+		bic     \tmp, #0x100
+		/* ignore mailbox interrupts */
+		bics    \tmp, #0xf0
+		beq	1005f
+
+		@ For non-zero x, LSB(x) = 31 - CLZ(x^(x-1))
+		@ N.B. CLZ is an ARM5 instruction.
+		mov	\irqnr, #(ARM_IRQ_LOCAL_BASE + 31)
+		sub	\irqstat, \tmp, #1
+		eor	\irqstat, \irqstat, \tmp
+		clz	\tmp, \irqstat
+		sub	\irqnr, \tmp
+		b	1020f
+1005:
+		/* get core number */
+		mrc     p15, 0, \tmp, c0, c0, 5
+		ubfx    \tmp, \tmp, #0, #2
+
+                cmp	\tmp, #1
+		beq	1020f
+                cmp	\tmp, #2
+		beq	1020f
+                cmp	\tmp, #3
+		beq	1020f
+
+		/* get masked status */
+		ldr	\irqstat, [\base, #(ARM_IRQ_PEND0 - ARMCTRL_IC_BASE)]
+		mov	\irqnr, #(ARM_IRQ0_BASE + 31)
+		and	\tmp, \irqstat, #0x300		 @ save bits 8 and 9
+		/* clear bits 8 and 9, and test */
+		bics	\irqstat, \irqstat, #0x300
+		bne	1010f
+
+		tst	\tmp, #0x100
+		ldrne	\irqstat, [\base, #(ARM_IRQ_PEND1 - ARMCTRL_IC_BASE)]
+		movne \irqnr, #(ARM_IRQ1_BASE + 31)
+		@ Mask out the interrupts also present in PEND0 - see SW-5809
+		bicne \irqstat, #((1<<7) | (1<<9) | (1<<10))
+		bicne \irqstat, #((1<<18) | (1<<19))
+		bne	1010f
+
+		tst	\tmp, #0x200
+		ldrne \irqstat, [\base, #(ARM_IRQ_PEND2 - ARMCTRL_IC_BASE)]
+		movne \irqnr, #(ARM_IRQ2_BASE + 31)
+		@ Mask out the interrupts also present in PEND0 - see SW-5809
+		bicne \irqstat, #((1<<21) | (1<<22) | (1<<23) | (1<<24) | (1<<25))
+		bicne \irqstat, #((1<<30))
+		beq 1020f
+
+1010:
+		@ For non-zero x, LSB(x) = 31 - CLZ(x^(x-1))
+		@ N.B. CLZ is an ARM5 instruction.
+		sub	\tmp, \irqstat, #1
+		eor	\irqstat, \irqstat, \tmp
+		clz	\tmp, \irqstat
+		sub	\irqnr, \tmp
+
+1020:	@ EQ will be set if no irqs pending
+
+		.endm
+
+		.macro  test_for_ipi, irqnr, irqstat, base, tmp
+		/* get core number */
+		mrc     p15, 0, \tmp, c0, c0, 5
+		ubfx    \tmp, \tmp, #0, #2
+		/* get core's mailbox interrupt control */
+		ldr	\irqstat, = __io_address(ARM_LOCAL_MAILBOX0_CLR0)	@ mbox_clr
+		add	\irqstat, \irqstat, \tmp, lsl #4
+		ldr	\tmp, [\irqstat]
+		cmp     \tmp, #0
+		beq	1030f
+		clz	\tmp, \tmp
+		rsb	\irqnr, \tmp, #31
+		mov	\tmp, #1
+		lsl	\tmp, \irqnr
+		str	\tmp, [\irqstat]  @ clear interrupt source
+		dsb
+1030:	@ EQ will be set if no irqs pending
+		.endm
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/frc.h
@@ -0,0 +1,38 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/timex.h
+ *
+ *  BCM2708 free running counter (timer)
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _MACH_FRC_H
+#define _MACH_FRC_H
+
+#define FRC_TICK_RATE		(1000000)
+
+/*! Free running counter incrementing at the CLOCK_TICK_RATE
+    (slightly faster than frc_clock_ticks63()
+ */
+extern unsigned long frc_clock_ticks32(void);
+
+/*! Free running counter incrementing at the CLOCK_TICK_RATE
+ *  Note - top bit should be ignored (see cnt32_to_63)
+ */
+extern unsigned long long frc_clock_ticks63(void);
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/gpio.h
@@ -0,0 +1,17 @@
+/*
+ * arch/arm/mach-bcm2708/include/mach/gpio.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#define BCM2708_NR_GPIOS 54 // number of gpio lines
+
+#define gpio_to_irq(x)	((x) + GPIO_IRQ_START)
+#define irq_to_gpio(x)	((x) - GPIO_IRQ_START)
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/hardware.h
@@ -0,0 +1,28 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/hardware.h
+ *
+ *  This file contains the hardware definitions of the BCM2708 devices.
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/platform.h>
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/io.h
@@ -0,0 +1,27 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/io.h
+ *
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+#define __io(a)		__typesafe_io(a)
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/irqs.h
@@ -0,0 +1,225 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/irqs.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _BCM2708_IRQS_H_
+#define _BCM2708_IRQS_H_
+
+#include <mach/platform.h>
+
+/*
+ *  IRQ interrupts definitions are the same as the INT definitions
+ *  held within platform.h
+ */
+#define IRQ_ARMCTRL_START     0
+#define IRQ_TIMER0            (IRQ_ARMCTRL_START + INTERRUPT_TIMER0)
+#define IRQ_TIMER1            (IRQ_ARMCTRL_START + INTERRUPT_TIMER1)
+#define IRQ_TIMER2            (IRQ_ARMCTRL_START + INTERRUPT_TIMER2)
+#define IRQ_TIMER3            (IRQ_ARMCTRL_START + INTERRUPT_TIMER3)
+#define IRQ_CODEC0            (IRQ_ARMCTRL_START + INTERRUPT_CODEC0)
+#define IRQ_CODEC1            (IRQ_ARMCTRL_START + INTERRUPT_CODEC1)
+#define IRQ_CODEC2            (IRQ_ARMCTRL_START + INTERRUPT_CODEC2)
+#define IRQ_JPEG              (IRQ_ARMCTRL_START + INTERRUPT_JPEG)
+#define IRQ_ISP               (IRQ_ARMCTRL_START + INTERRUPT_ISP)
+#define IRQ_USB               (IRQ_ARMCTRL_START + INTERRUPT_USB)
+#define IRQ_3D                (IRQ_ARMCTRL_START + INTERRUPT_3D)
+#define IRQ_TRANSPOSER        (IRQ_ARMCTRL_START + INTERRUPT_TRANSPOSER)
+#define IRQ_MULTICORESYNC0    (IRQ_ARMCTRL_START + INTERRUPT_MULTICORESYNC0)
+#define IRQ_MULTICORESYNC1    (IRQ_ARMCTRL_START + INTERRUPT_MULTICORESYNC1)
+#define IRQ_MULTICORESYNC2    (IRQ_ARMCTRL_START + INTERRUPT_MULTICORESYNC2)
+#define IRQ_MULTICORESYNC3    (IRQ_ARMCTRL_START + INTERRUPT_MULTICORESYNC3)
+#define IRQ_DMA0              (IRQ_ARMCTRL_START + INTERRUPT_DMA0)
+#define IRQ_DMA1              (IRQ_ARMCTRL_START + INTERRUPT_DMA1)
+#define IRQ_DMA2              (IRQ_ARMCTRL_START + INTERRUPT_DMA2)
+#define IRQ_DMA3              (IRQ_ARMCTRL_START + INTERRUPT_DMA3)
+#define IRQ_DMA4              (IRQ_ARMCTRL_START + INTERRUPT_DMA4)
+#define IRQ_DMA5              (IRQ_ARMCTRL_START + INTERRUPT_DMA5)
+#define IRQ_DMA6              (IRQ_ARMCTRL_START + INTERRUPT_DMA6)
+#define IRQ_DMA7              (IRQ_ARMCTRL_START + INTERRUPT_DMA7)
+#define IRQ_DMA8              (IRQ_ARMCTRL_START + INTERRUPT_DMA8)
+#define IRQ_DMA9              (IRQ_ARMCTRL_START + INTERRUPT_DMA9)
+#define IRQ_DMA10             (IRQ_ARMCTRL_START + INTERRUPT_DMA10)
+#define IRQ_DMA11             (IRQ_ARMCTRL_START + INTERRUPT_DMA11)
+#define IRQ_DMA12             (IRQ_ARMCTRL_START + INTERRUPT_DMA12)
+#define IRQ_AUX               (IRQ_ARMCTRL_START + INTERRUPT_AUX)
+#define IRQ_ARM               (IRQ_ARMCTRL_START + INTERRUPT_ARM)
+#define IRQ_VPUDMA            (IRQ_ARMCTRL_START + INTERRUPT_VPUDMA)
+#define IRQ_HOSTPORT          (IRQ_ARMCTRL_START + INTERRUPT_HOSTPORT)
+#define IRQ_VIDEOSCALER       (IRQ_ARMCTRL_START + INTERRUPT_VIDEOSCALER)
+#define IRQ_CCP2TX            (IRQ_ARMCTRL_START + INTERRUPT_CCP2TX)
+#define IRQ_SDC               (IRQ_ARMCTRL_START + INTERRUPT_SDC)
+#define IRQ_DSI0              (IRQ_ARMCTRL_START + INTERRUPT_DSI0)
+#define IRQ_AVE               (IRQ_ARMCTRL_START + INTERRUPT_AVE)
+#define IRQ_CAM0              (IRQ_ARMCTRL_START + INTERRUPT_CAM0)
+#define IRQ_CAM1              (IRQ_ARMCTRL_START + INTERRUPT_CAM1)
+#define IRQ_HDMI0             (IRQ_ARMCTRL_START + INTERRUPT_HDMI0)
+#define IRQ_HDMI1             (IRQ_ARMCTRL_START + INTERRUPT_HDMI1)
+#define IRQ_PIXELVALVE1       (IRQ_ARMCTRL_START + INTERRUPT_PIXELVALVE1)
+#define IRQ_I2CSPISLV         (IRQ_ARMCTRL_START + INTERRUPT_I2CSPISLV)
+#define IRQ_DSI1              (IRQ_ARMCTRL_START + INTERRUPT_DSI1)
+#define IRQ_PWA0              (IRQ_ARMCTRL_START + INTERRUPT_PWA0)
+#define IRQ_PWA1              (IRQ_ARMCTRL_START + INTERRUPT_PWA1)
+#define IRQ_CPR               (IRQ_ARMCTRL_START + INTERRUPT_CPR)
+#define IRQ_SMI               (IRQ_ARMCTRL_START + INTERRUPT_SMI)
+#define IRQ_GPIO0             (IRQ_ARMCTRL_START + INTERRUPT_GPIO0)
+#define IRQ_GPIO1             (IRQ_ARMCTRL_START + INTERRUPT_GPIO1)
+#define IRQ_GPIO2             (IRQ_ARMCTRL_START + INTERRUPT_GPIO2)
+#define IRQ_GPIO3             (IRQ_ARMCTRL_START + INTERRUPT_GPIO3)
+#define IRQ_I2C               (IRQ_ARMCTRL_START + INTERRUPT_I2C)
+#define IRQ_SPI               (IRQ_ARMCTRL_START + INTERRUPT_SPI)
+#define IRQ_I2SPCM            (IRQ_ARMCTRL_START + INTERRUPT_I2SPCM)
+#define IRQ_SDIO              (IRQ_ARMCTRL_START + INTERRUPT_SDIO)
+#define IRQ_UART              (IRQ_ARMCTRL_START + INTERRUPT_UART)
+#define IRQ_SLIMBUS           (IRQ_ARMCTRL_START + INTERRUPT_SLIMBUS)
+#define IRQ_VEC               (IRQ_ARMCTRL_START + INTERRUPT_VEC)
+#define IRQ_CPG               (IRQ_ARMCTRL_START + INTERRUPT_CPG)
+#define IRQ_RNG               (IRQ_ARMCTRL_START + INTERRUPT_RNG)
+#define IRQ_ARASANSDIO        (IRQ_ARMCTRL_START + INTERRUPT_ARASANSDIO)
+#define IRQ_AVSPMON           (IRQ_ARMCTRL_START + INTERRUPT_AVSPMON)
+
+#define IRQ_ARM_TIMER         (IRQ_ARMCTRL_START + INTERRUPT_ARM_TIMER)
+#define IRQ_ARM_MAILBOX       (IRQ_ARMCTRL_START + INTERRUPT_ARM_MAILBOX)
+#define IRQ_ARM_DOORBELL_0    (IRQ_ARMCTRL_START + INTERRUPT_ARM_DOORBELL_0)
+#define IRQ_ARM_DOORBELL_1    (IRQ_ARMCTRL_START + INTERRUPT_ARM_DOORBELL_1)
+#define IRQ_VPU0_HALTED       (IRQ_ARMCTRL_START + INTERRUPT_VPU0_HALTED)
+#define IRQ_VPU1_HALTED       (IRQ_ARMCTRL_START + INTERRUPT_VPU1_HALTED)
+#define IRQ_ILLEGAL_TYPE0     (IRQ_ARMCTRL_START + INTERRUPT_ILLEGAL_TYPE0)
+#define IRQ_ILLEGAL_TYPE1     (IRQ_ARMCTRL_START + INTERRUPT_ILLEGAL_TYPE1)
+#define IRQ_PENDING1          (IRQ_ARMCTRL_START + INTERRUPT_PENDING1)
+#define IRQ_PENDING2          (IRQ_ARMCTRL_START + INTERRUPT_PENDING2)
+
+#define IRQ_ARM_LOCAL_CNTPSIRQ   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTPSIRQ)
+#define IRQ_ARM_LOCAL_CNTPNSIRQ  (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTPNSIRQ)
+#define IRQ_ARM_LOCAL_CNTHPIRQ   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTHPIRQ)
+#define IRQ_ARM_LOCAL_CNTVIRQ    (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTVIRQ)
+#define IRQ_ARM_LOCAL_MAILBOX0   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX0)
+#define IRQ_ARM_LOCAL_MAILBOX1   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX1)
+#define IRQ_ARM_LOCAL_MAILBOX2   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX2)
+#define IRQ_ARM_LOCAL_MAILBOX3   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX3)
+#define IRQ_ARM_LOCAL_GPU_FAST   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_GPU_FAST)
+#define IRQ_ARM_LOCAL_PMU_FAST   (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_PMU_FAST)
+#define IRQ_ARM_LOCAL_ZERO       (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_ZERO)
+#define IRQ_ARM_LOCAL_TIMER      (IRQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_TIMER)
+
+#define FIQ_START             HARD_IRQS
+
+/*
+ *  FIQ interrupts definitions are the same as the INT definitions.
+ */
+#define FIQ_TIMER0            (FIQ_START+INTERRUPT_TIMER0)
+#define FIQ_TIMER1            (FIQ_START+INTERRUPT_TIMER1)
+#define FIQ_TIMER2            (FIQ_START+INTERRUPT_TIMER2)
+#define FIQ_TIMER3            (FIQ_START+INTERRUPT_TIMER3)
+#define FIQ_CODEC0            (FIQ_START+INTERRUPT_CODEC0)
+#define FIQ_CODEC1            (FIQ_START+INTERRUPT_CODEC1)
+#define FIQ_CODEC2            (FIQ_START+INTERRUPT_CODEC2)
+#define FIQ_JPEG              (FIQ_START+INTERRUPT_JPEG)
+#define FIQ_ISP               (FIQ_START+INTERRUPT_ISP)
+#define FIQ_USB               (FIQ_START+INTERRUPT_USB)
+#define FIQ_3D                (FIQ_START+INTERRUPT_3D)
+#define FIQ_TRANSPOSER        (FIQ_START+INTERRUPT_TRANSPOSER)
+#define FIQ_MULTICORESYNC0    (FIQ_START+INTERRUPT_MULTICORESYNC0)
+#define FIQ_MULTICORESYNC1    (FIQ_START+INTERRUPT_MULTICORESYNC1)
+#define FIQ_MULTICORESYNC2    (FIQ_START+INTERRUPT_MULTICORESYNC2)
+#define FIQ_MULTICORESYNC3    (FIQ_START+INTERRUPT_MULTICORESYNC3)
+#define FIQ_DMA0              (FIQ_START+INTERRUPT_DMA0)
+#define FIQ_DMA1              (FIQ_START+INTERRUPT_DMA1)
+#define FIQ_DMA2              (FIQ_START+INTERRUPT_DMA2)
+#define FIQ_DMA3              (FIQ_START+INTERRUPT_DMA3)
+#define FIQ_DMA4              (FIQ_START+INTERRUPT_DMA4)
+#define FIQ_DMA5              (FIQ_START+INTERRUPT_DMA5)
+#define FIQ_DMA6              (FIQ_START+INTERRUPT_DMA6)
+#define FIQ_DMA7              (FIQ_START+INTERRUPT_DMA7)
+#define FIQ_DMA8              (FIQ_START+INTERRUPT_DMA8)
+#define FIQ_DMA9              (FIQ_START+INTERRUPT_DMA9)
+#define FIQ_DMA10             (FIQ_START+INTERRUPT_DMA10)
+#define FIQ_DMA11             (FIQ_START+INTERRUPT_DMA11)
+#define FIQ_DMA12             (FIQ_START+INTERRUPT_DMA12)
+#define FIQ_AUX               (FIQ_START+INTERRUPT_AUX)
+#define FIQ_ARM               (FIQ_START+INTERRUPT_ARM)
+#define FIQ_VPUDMA            (FIQ_START+INTERRUPT_VPUDMA)
+#define FIQ_HOSTPORT          (FIQ_START+INTERRUPT_HOSTPORT)
+#define FIQ_VIDEOSCALER       (FIQ_START+INTERRUPT_VIDEOSCALER)
+#define FIQ_CCP2TX            (FIQ_START+INTERRUPT_CCP2TX)
+#define FIQ_SDC               (FIQ_START+INTERRUPT_SDC)
+#define FIQ_DSI0              (FIQ_START+INTERRUPT_DSI0)
+#define FIQ_AVE               (FIQ_START+INTERRUPT_AVE)
+#define FIQ_CAM0              (FIQ_START+INTERRUPT_CAM0)
+#define FIQ_CAM1              (FIQ_START+INTERRUPT_CAM1)
+#define FIQ_HDMI0             (FIQ_START+INTERRUPT_HDMI0)
+#define FIQ_HDMI1             (FIQ_START+INTERRUPT_HDMI1)
+#define FIQ_PIXELVALVE1       (FIQ_START+INTERRUPT_PIXELVALVE1)
+#define FIQ_I2CSPISLV         (FIQ_START+INTERRUPT_I2CSPISLV)
+#define FIQ_DSI1              (FIQ_START+INTERRUPT_DSI1)
+#define FIQ_PWA0              (FIQ_START+INTERRUPT_PWA0)
+#define FIQ_PWA1              (FIQ_START+INTERRUPT_PWA1)
+#define FIQ_CPR               (FIQ_START+INTERRUPT_CPR)
+#define FIQ_SMI               (FIQ_START+INTERRUPT_SMI)
+#define FIQ_GPIO0             (FIQ_START+INTERRUPT_GPIO0)
+#define FIQ_GPIO1             (FIQ_START+INTERRUPT_GPIO1)
+#define FIQ_GPIO2             (FIQ_START+INTERRUPT_GPIO2)
+#define FIQ_GPIO3             (FIQ_START+INTERRUPT_GPIO3)
+#define FIQ_I2C               (FIQ_START+INTERRUPT_I2C)
+#define FIQ_SPI               (FIQ_START+INTERRUPT_SPI)
+#define FIQ_I2SPCM            (FIQ_START+INTERRUPT_I2SPCM)
+#define FIQ_SDIO              (FIQ_START+INTERRUPT_SDIO)
+#define FIQ_UART              (FIQ_START+INTERRUPT_UART)
+#define FIQ_SLIMBUS           (FIQ_START+INTERRUPT_SLIMBUS)
+#define FIQ_VEC               (FIQ_START+INTERRUPT_VEC)
+#define FIQ_CPG               (FIQ_START+INTERRUPT_CPG)
+#define FIQ_RNG               (FIQ_START+INTERRUPT_RNG)
+#define FIQ_ARASANSDIO        (FIQ_START+INTERRUPT_ARASANSDIO)
+#define FIQ_AVSPMON           (FIQ_START+INTERRUPT_AVSPMON)
+
+#define FIQ_ARM_TIMER         (FIQ_START+INTERRUPT_ARM_TIMER)
+#define FIQ_ARM_MAILBOX       (FIQ_START+INTERRUPT_ARM_MAILBOX)
+#define FIQ_ARM_DOORBELL_0    (FIQ_START+INTERRUPT_ARM_DOORBELL_0)
+#define FIQ_ARM_DOORBELL_1    (FIQ_START+INTERRUPT_ARM_DOORBELL_1)
+#define FIQ_VPU0_HALTED       (FIQ_START+INTERRUPT_VPU0_HALTED)
+#define FIQ_VPU1_HALTED       (FIQ_START+INTERRUPT_VPU1_HALTED)
+#define FIQ_ILLEGAL_TYPE0     (FIQ_START+INTERRUPT_ILLEGAL_TYPE0)
+#define FIQ_ILLEGAL_TYPE1     (FIQ_START+INTERRUPT_ILLEGAL_TYPE1)
+#define FIQ_PENDING1          (FIQ_START+INTERRUPT_PENDING1)
+#define FIQ_PENDING2          (FIQ_START+INTERRUPT_PENDING2)
+
+#define FIQ_ARM_LOCAL_CNTPSIRQ   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTPSIRQ)
+#define FIQ_ARM_LOCAL_CNTPNSIRQ  (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTPNSIRQ)
+#define FIQ_ARM_LOCAL_CNTHPIRQ   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTHPIRQ)
+#define FIQ_ARM_LOCAL_CNTVIRQ    (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_CNTVIRQ)
+#define FIQ_ARM_LOCAL_MAILBOX0   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX0)
+#define FIQ_ARM_LOCAL_MAILBOX1   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX1)
+#define FIQ_ARM_LOCAL_MAILBOX2   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX2)
+#define FIQ_ARM_LOCAL_MAILBOX3   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_MAILBOX3)
+#define FIQ_ARM_LOCAL_GPU_FAST   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_GPU_FAST)
+#define FIQ_ARM_LOCAL_PMU_FAST   (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_PMU_FAST)
+#define FIQ_ARM_LOCAL_ZERO       (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_ZERO)
+#define FIQ_ARM_LOCAL_TIMER      (FIQ_ARMCTRL_START + INTERRUPT_ARM_LOCAL_TIMER)
+
+#define HARD_IRQS	(128)
+#define FIQ_IRQS	(128)
+#define GPIO_IRQ_START	(HARD_IRQS + FIQ_IRQS)
+#define GPIO_IRQS	(32*5)
+#define SPARE_ALLOC_IRQS      32
+#define BCM2708_ALLOC_IRQS    (HARD_IRQS+FIQ_IRQS+GPIO_IRQS+SPARE_ALLOC_IRQS)
+#define FREE_IRQS             32
+#define NR_IRQS               (BCM2708_ALLOC_IRQS+FREE_IRQS)
+
+#endif /* _BCM2708_IRQS_H_ */
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/memory.h
@@ -0,0 +1,57 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/memory.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/* Memory overview:
+
+   [ARMcore] <--virtual addr-->
+   [ARMmmu] <--physical addr-->
+   [GERTmap] <--bus add-->
+   [VCperiph]
+
+*/
+
+/*
+ * Physical DRAM offset.
+ */
+#define BCM_PLAT_PHYS_OFFSET	UL(0x00000000)
+#define VC_ARMMEM_OFFSET	UL(0x00000000)   /* offset in VC of ARM memory */
+
+#ifdef CONFIG_BCM2708_NOL2CACHE
+ #define _REAL_BUS_OFFSET UL(0xC0000000)   /* don't use L1 or L2 caches */
+#else
+ #define _REAL_BUS_OFFSET UL(0x40000000)   /* use L2 cache */
+#endif
+
+/* We're using the memory at 64M in the VideoCore for Linux - this adjustment
+ * will provide the offset into this area as well as setting the bits that
+ * stop the L1 and L2 cache from being used
+ *
+ * WARNING: this only works because the ARM is given memory at a fixed location
+ *          (ARMMEM_OFFSET)
+ */
+#define BUS_OFFSET          (VC_ARMMEM_OFFSET + _REAL_BUS_OFFSET)
+#define __virt_to_bus(x)    ((x) + (BUS_OFFSET - PAGE_OFFSET))
+#define __bus_to_virt(x)    ((x) - (BUS_OFFSET - PAGE_OFFSET))
+#define __pfn_to_bus(x)     (__pfn_to_phys(x) + (BUS_OFFSET - BCM_PLAT_PHYS_OFFSET))
+#define __bus_to_pfn(x)     __phys_to_pfn((x) - (BUS_OFFSET - BCM_PLAT_PHYS_OFFSET))
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/platform.h
@@ -0,0 +1,225 @@
+/*
+ * arch/arm/mach-bcm2708/include/mach/platform.h
+ *
+ * Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _BCM2708_PLATFORM_H
+#define _BCM2708_PLATFORM_H
+
+
+/* macros to get at IO space when running virtually */
+#define IO_ADDRESS(x)	(((x) & 0x00ffffff) + (((x) >> 4) & 0x0f000000) + 0xf0000000)
+
+#define __io_address(n)     IOMEM(IO_ADDRESS(n))
+
+
+/*
+ *  SDRAM
+ */
+#define BCM2708_SDRAM_BASE           0x00000000
+
+/*
+ *  Logic expansion modules
+ *
+ */
+
+
+/* ------------------------------------------------------------------------
+ *  BCM2708 ARMCTRL Registers
+ * ------------------------------------------------------------------------
+ */
+
+#define HW_REGISTER_RW(addr) (addr)
+#define HW_REGISTER_RO(addr) (addr)
+
+#include "arm_control.h"
+#undef ARM_BASE
+
+/*
+ * Definitions and addresses for the ARM CONTROL logic
+ * This file is manually generated.
+ */
+
+#define BCM2708_PERI_BASE        0x3F000000
+#define IC0_BASE                 (BCM2708_PERI_BASE + 0x2000)
+#define ST_BASE                  (BCM2708_PERI_BASE + 0x3000)   /* System Timer */
+#define MPHI_BASE		 (BCM2708_PERI_BASE + 0x6000)	/* Message -based Parallel Host Interface */
+#define DMA_BASE		 (BCM2708_PERI_BASE + 0x7000)	/* DMA controller */
+#define ARM_BASE                 (BCM2708_PERI_BASE + 0xB000)	 /* BCM2708 ARM control block */
+#define PM_BASE			 (BCM2708_PERI_BASE + 0x100000) /* Power Management, Reset controller and Watchdog registers */
+#define PCM_CLOCK_BASE           (BCM2708_PERI_BASE + 0x101098) /* PCM Clock */
+#define RNG_BASE                 (BCM2708_PERI_BASE + 0x104000) /* Hardware RNG */
+#define GPIO_BASE                (BCM2708_PERI_BASE + 0x200000) /* GPIO */
+#define UART0_BASE               (BCM2708_PERI_BASE + 0x201000)	/* Uart 0 */
+#define MMCI0_BASE               (BCM2708_PERI_BASE + 0x202000) /* MMC interface */
+#define I2S_BASE                 (BCM2708_PERI_BASE + 0x203000) /* I2S */
+#define SPI0_BASE		 (BCM2708_PERI_BASE + 0x204000) /* SPI0 */
+#define BSC0_BASE		 (BCM2708_PERI_BASE + 0x205000) /* BSC0 I2C/TWI */
+#define UART1_BASE               (BCM2708_PERI_BASE + 0x215000) /* Uart 1 */
+#define EMMC_BASE                (BCM2708_PERI_BASE + 0x300000) /* eMMC interface */
+#define SMI_BASE		 (BCM2708_PERI_BASE + 0x600000) /* SMI */
+#define BSC1_BASE		 (BCM2708_PERI_BASE + 0x804000) /* BSC1 I2C/TWI */
+#define USB_BASE                 (BCM2708_PERI_BASE + 0x980000) /* DTC_OTG USB controller */
+#define MCORE_BASE               (BCM2708_PERI_BASE + 0x0000)   /* Fake frame buffer device (actually the multicore sync block*/
+
+#define ARMCTRL_BASE             (ARM_BASE + 0x000)
+#define ARMCTRL_IC_BASE          (ARM_BASE + 0x200)           /* ARM interrupt controller */
+#define ARMCTRL_TIMER0_1_BASE    (ARM_BASE + 0x400)           /* Timer 0 and 1 */
+#define ARMCTRL_0_SBM_BASE       (ARM_BASE + 0x800)           /* User 0 (ARM)'s Semaphores Doorbells and Mailboxes */
+
+
+/*
+ * Interrupt assignments
+ */
+
+#define ARM_IRQ1_BASE                  0
+#define INTERRUPT_TIMER0               (ARM_IRQ1_BASE + 0)
+#define INTERRUPT_TIMER1               (ARM_IRQ1_BASE + 1)
+#define INTERRUPT_TIMER2               (ARM_IRQ1_BASE + 2)
+#define INTERRUPT_TIMER3               (ARM_IRQ1_BASE + 3)
+#define INTERRUPT_CODEC0               (ARM_IRQ1_BASE + 4)
+#define INTERRUPT_CODEC1               (ARM_IRQ1_BASE + 5)
+#define INTERRUPT_CODEC2               (ARM_IRQ1_BASE + 6)
+#define INTERRUPT_VC_JPEG              (ARM_IRQ1_BASE + 7)
+#define INTERRUPT_ISP                  (ARM_IRQ1_BASE + 8)
+#define INTERRUPT_VC_USB               (ARM_IRQ1_BASE + 9)
+#define INTERRUPT_VC_3D                (ARM_IRQ1_BASE + 10)
+#define INTERRUPT_TRANSPOSER           (ARM_IRQ1_BASE + 11)
+#define INTERRUPT_MULTICORESYNC0       (ARM_IRQ1_BASE + 12)
+#define INTERRUPT_MULTICORESYNC1       (ARM_IRQ1_BASE + 13)
+#define INTERRUPT_MULTICORESYNC2       (ARM_IRQ1_BASE + 14)
+#define INTERRUPT_MULTICORESYNC3       (ARM_IRQ1_BASE + 15)
+#define INTERRUPT_DMA0                 (ARM_IRQ1_BASE + 16)
+#define INTERRUPT_DMA1                 (ARM_IRQ1_BASE + 17)
+#define INTERRUPT_VC_DMA2              (ARM_IRQ1_BASE + 18)
+#define INTERRUPT_VC_DMA3              (ARM_IRQ1_BASE + 19)
+#define INTERRUPT_DMA4                 (ARM_IRQ1_BASE + 20)
+#define INTERRUPT_DMA5                 (ARM_IRQ1_BASE + 21)
+#define INTERRUPT_DMA6                 (ARM_IRQ1_BASE + 22)
+#define INTERRUPT_DMA7                 (ARM_IRQ1_BASE + 23)
+#define INTERRUPT_DMA8                 (ARM_IRQ1_BASE + 24)
+#define INTERRUPT_DMA9                 (ARM_IRQ1_BASE + 25)
+#define INTERRUPT_DMA10                (ARM_IRQ1_BASE + 26)
+#define INTERRUPT_DMA11                (ARM_IRQ1_BASE + 27)
+#define INTERRUPT_DMA12                (ARM_IRQ1_BASE + 28)
+#define INTERRUPT_AUX                (ARM_IRQ1_BASE + 29)
+#define INTERRUPT_ARM                  (ARM_IRQ1_BASE + 30)
+#define INTERRUPT_VPUDMA               (ARM_IRQ1_BASE + 31)
+
+#define ARM_IRQ2_BASE                  32
+#define INTERRUPT_HOSTPORT             (ARM_IRQ2_BASE + 0)
+#define INTERRUPT_VIDEOSCALER          (ARM_IRQ2_BASE + 1)
+#define INTERRUPT_CCP2TX               (ARM_IRQ2_BASE + 2)
+#define INTERRUPT_SDC                  (ARM_IRQ2_BASE + 3)
+#define INTERRUPT_DSI0                 (ARM_IRQ2_BASE + 4)
+#define INTERRUPT_AVE                  (ARM_IRQ2_BASE + 5)
+#define INTERRUPT_CAM0                 (ARM_IRQ2_BASE + 6)
+#define INTERRUPT_CAM1                 (ARM_IRQ2_BASE + 7)
+#define INTERRUPT_HDMI0                (ARM_IRQ2_BASE + 8)
+#define INTERRUPT_HDMI1                (ARM_IRQ2_BASE + 9)
+#define INTERRUPT_PIXELVALVE1          (ARM_IRQ2_BASE + 10)
+#define INTERRUPT_I2CSPISLV            (ARM_IRQ2_BASE + 11)
+#define INTERRUPT_DSI1                 (ARM_IRQ2_BASE + 12)
+#define INTERRUPT_PWA0                 (ARM_IRQ2_BASE + 13)
+#define INTERRUPT_PWA1                 (ARM_IRQ2_BASE + 14)
+#define INTERRUPT_CPR                  (ARM_IRQ2_BASE + 15)
+#define INTERRUPT_SMI                  (ARM_IRQ2_BASE + 16)
+#define INTERRUPT_GPIO0                (ARM_IRQ2_BASE + 17)
+#define INTERRUPT_GPIO1                (ARM_IRQ2_BASE + 18)
+#define INTERRUPT_GPIO2                (ARM_IRQ2_BASE + 19)
+#define INTERRUPT_GPIO3                (ARM_IRQ2_BASE + 20)
+#define INTERRUPT_VC_I2C               (ARM_IRQ2_BASE + 21)
+#define INTERRUPT_VC_SPI               (ARM_IRQ2_BASE + 22)
+#define INTERRUPT_VC_I2SPCM            (ARM_IRQ2_BASE + 23)
+#define INTERRUPT_VC_SDIO              (ARM_IRQ2_BASE + 24)
+#define INTERRUPT_VC_UART              (ARM_IRQ2_BASE + 25)
+#define INTERRUPT_SLIMBUS              (ARM_IRQ2_BASE + 26)
+#define INTERRUPT_VEC                  (ARM_IRQ2_BASE + 27)
+#define INTERRUPT_CPG                  (ARM_IRQ2_BASE + 28)
+#define INTERRUPT_RNG                  (ARM_IRQ2_BASE + 29)
+#define INTERRUPT_VC_ARASANSDIO        (ARM_IRQ2_BASE + 30)
+#define INTERRUPT_AVSPMON              (ARM_IRQ2_BASE + 31)
+
+#define ARM_IRQ0_BASE                  64
+#define INTERRUPT_ARM_TIMER            (ARM_IRQ0_BASE + 0)
+#define INTERRUPT_ARM_MAILBOX          (ARM_IRQ0_BASE + 1)
+#define INTERRUPT_ARM_DOORBELL_0       (ARM_IRQ0_BASE + 2)
+#define INTERRUPT_ARM_DOORBELL_1       (ARM_IRQ0_BASE + 3)
+#define INTERRUPT_VPU0_HALTED          (ARM_IRQ0_BASE + 4)
+#define INTERRUPT_VPU1_HALTED          (ARM_IRQ0_BASE + 5)
+#define INTERRUPT_ILLEGAL_TYPE0        (ARM_IRQ0_BASE + 6)
+#define INTERRUPT_ILLEGAL_TYPE1        (ARM_IRQ0_BASE + 7)
+#define INTERRUPT_PENDING1             (ARM_IRQ0_BASE + 8)
+#define INTERRUPT_PENDING2             (ARM_IRQ0_BASE + 9)
+#define INTERRUPT_JPEG                 (ARM_IRQ0_BASE + 10)
+#define INTERRUPT_USB                  (ARM_IRQ0_BASE + 11)
+#define INTERRUPT_3D                   (ARM_IRQ0_BASE + 12)
+#define INTERRUPT_DMA2                 (ARM_IRQ0_BASE + 13)
+#define INTERRUPT_DMA3                 (ARM_IRQ0_BASE + 14)
+#define INTERRUPT_I2C                  (ARM_IRQ0_BASE + 15)
+#define INTERRUPT_SPI                  (ARM_IRQ0_BASE + 16)
+#define INTERRUPT_I2SPCM               (ARM_IRQ0_BASE + 17)
+#define INTERRUPT_SDIO                 (ARM_IRQ0_BASE + 18)
+#define INTERRUPT_UART                 (ARM_IRQ0_BASE + 19)
+#define INTERRUPT_ARASANSDIO           (ARM_IRQ0_BASE + 20)
+
+#define ARM_IRQ_LOCAL_BASE             96
+#define INTERRUPT_ARM_LOCAL_CNTPSIRQ   (ARM_IRQ_LOCAL_BASE + 0)
+#define INTERRUPT_ARM_LOCAL_CNTPNSIRQ  (ARM_IRQ_LOCAL_BASE + 1)
+#define INTERRUPT_ARM_LOCAL_CNTHPIRQ   (ARM_IRQ_LOCAL_BASE + 2)
+#define INTERRUPT_ARM_LOCAL_CNTVIRQ    (ARM_IRQ_LOCAL_BASE + 3)
+#define INTERRUPT_ARM_LOCAL_MAILBOX0   (ARM_IRQ_LOCAL_BASE + 4)
+#define INTERRUPT_ARM_LOCAL_MAILBOX1   (ARM_IRQ_LOCAL_BASE + 5)
+#define INTERRUPT_ARM_LOCAL_MAILBOX2   (ARM_IRQ_LOCAL_BASE + 6)
+#define INTERRUPT_ARM_LOCAL_MAILBOX3   (ARM_IRQ_LOCAL_BASE + 7)
+#define INTERRUPT_ARM_LOCAL_GPU_FAST   (ARM_IRQ_LOCAL_BASE + 8)
+#define INTERRUPT_ARM_LOCAL_PMU_FAST   (ARM_IRQ_LOCAL_BASE + 9)
+#define INTERRUPT_ARM_LOCAL_ZERO       (ARM_IRQ_LOCAL_BASE + 10)
+#define INTERRUPT_ARM_LOCAL_TIMER      (ARM_IRQ_LOCAL_BASE + 11)
+
+/*
+ * Watchdog
+ */
+#define PM_RSTC			       (PM_BASE+0x1c)
+#define PM_RSTS			       (PM_BASE+0x20)
+#define PM_WDOG			       (PM_BASE+0x24)
+
+#define PM_WDOG_RESET                                         0000000000
+#define PM_PASSWORD		       0x5a000000
+#define PM_WDOG_TIME_SET	       0x000fffff
+#define PM_RSTC_WRCFG_CLR              0xffffffcf
+#define PM_RSTC_WRCFG_SET              0x00000030
+#define PM_RSTC_WRCFG_FULL_RESET       0x00000020
+#define PM_RSTC_RESET                  0x00000102
+
+#define PM_RSTS_HADPOR_SET                                 0x00001000
+#define PM_RSTS_HADSRH_SET                                 0x00000400
+#define PM_RSTS_HADSRF_SET                                 0x00000200
+#define PM_RSTS_HADSRQ_SET                                 0x00000100
+#define PM_RSTS_HADWRH_SET                                 0x00000040
+#define PM_RSTS_HADWRF_SET                                 0x00000020
+#define PM_RSTS_HADWRQ_SET                                 0x00000010
+#define PM_RSTS_HADDRH_SET                                 0x00000004
+#define PM_RSTS_HADDRF_SET                                 0x00000002
+#define PM_RSTS_HADDRQ_SET                                 0x00000001
+
+#define UART0_CLOCK      3000000
+
+#endif
+
+/* END */
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/power.h
@@ -0,0 +1,26 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/power.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This device provides a shared mechanism for controlling the power to
+ * VideoCore subsystems.
+ */
+
+#ifndef _MACH_BCM2708_POWER_H
+#define _MACH_BCM2708_POWER_H
+
+#include <linux/types.h>
+#include <mach/arm_power.h>
+
+typedef unsigned int BCM_POWER_HANDLE_T;
+
+extern int bcm_power_open(BCM_POWER_HANDLE_T *handle);
+extern int bcm_power_request(BCM_POWER_HANDLE_T handle, uint32_t request);
+extern int bcm_power_close(BCM_POWER_HANDLE_T handle);
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/system.h
@@ -0,0 +1,38 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/system.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *  Copyright (C) 2003 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+
+static inline void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks
+	 */
+	cpu_do_idle();
+}
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/timex.h
@@ -0,0 +1,23 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/timex.h
+ *
+ *  BCM2708 sysem clock frequency
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#define CLOCK_TICK_RATE		(1000000)
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/uncompress.h
@@ -0,0 +1,84 @@
+/*
+ *  arch/arm/mach-bcn2708/include/mach/uncompress.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *  Copyright (C) 2003 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/io.h>
+#include <linux/amba/serial.h>
+#include <mach/hardware.h>
+
+#define UART_BAUD 115200
+
+#define BCM2708_UART_DR   __io(UART0_BASE + UART01x_DR)
+#define BCM2708_UART_FR   __io(UART0_BASE + UART01x_FR)
+#define BCM2708_UART_IBRD __io(UART0_BASE + UART011_IBRD)
+#define BCM2708_UART_FBRD __io(UART0_BASE + UART011_FBRD)
+#define BCM2708_UART_LCRH __io(UART0_BASE + UART011_LCRH)
+#define BCM2708_UART_CR   __io(UART0_BASE + UART011_CR)
+
+/*
+ * This does not append a newline
+ */
+static inline void putc(int c)
+{
+	while (__raw_readl(BCM2708_UART_FR) & UART01x_FR_TXFF)
+		barrier();
+
+	__raw_writel(c, BCM2708_UART_DR);
+}
+
+static inline void flush(void)
+{
+	int fr;
+
+	do {
+		fr = __raw_readl(BCM2708_UART_FR);
+		barrier();
+	} while ((fr & (UART011_FR_TXFE | UART01x_FR_BUSY)) != UART011_FR_TXFE);
+}
+
+static inline void arch_decomp_setup(void)
+{
+	int temp, div, rem, frac;
+
+	temp = 16 * UART_BAUD;
+	div = UART0_CLOCK / temp;
+	rem = UART0_CLOCK % temp;
+	temp = (8 * rem) / UART_BAUD;
+	frac = (temp >> 1) + (temp & 1);
+
+	/* Make sure the UART is disabled before we start */
+	__raw_writel(0, BCM2708_UART_CR);
+
+	/* Set the baud rate */
+	__raw_writel(div, BCM2708_UART_IBRD);
+	__raw_writel(frac, BCM2708_UART_FBRD);
+
+	/* Set the UART to 8n1, FIFO enabled */
+	__raw_writel(UART01x_LCRH_WLEN_8 | UART01x_LCRH_FEN, BCM2708_UART_LCRH);
+
+	/* Enable the UART */
+	__raw_writel(UART01x_CR_UARTEN | UART011_CR_TXE | UART011_CR_RXE,
+			BCM2708_UART_CR);
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_wdog()
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/vc_mem.h
@@ -0,0 +1,35 @@
+/*****************************************************************************
+* Copyright 2010 - 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#if !defined( VC_MEM_H )
+#define VC_MEM_H
+
+#include <linux/ioctl.h>
+
+#define VC_MEM_IOC_MAGIC  'v'
+
+#define VC_MEM_IOC_MEM_PHYS_ADDR    _IOR( VC_MEM_IOC_MAGIC, 0, unsigned long )
+#define VC_MEM_IOC_MEM_SIZE         _IOR( VC_MEM_IOC_MAGIC, 1, unsigned int )
+#define VC_MEM_IOC_MEM_BASE         _IOR( VC_MEM_IOC_MAGIC, 2, unsigned int )
+#define VC_MEM_IOC_MEM_LOAD         _IOR( VC_MEM_IOC_MAGIC, 3, unsigned int )
+
+#if defined( __KERNEL__ )
+#define VC_MEM_TO_ARM_ADDR_MASK 0x3FFFFFFF
+
+extern unsigned long mm_vc_mem_phys_addr;
+extern unsigned int  mm_vc_mem_size;
+extern int vc_mem_get_current_size( void );
+#endif
+
+#endif  /* VC_MEM_H */
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/vc_support.h
@@ -0,0 +1,69 @@
+#ifndef _VC_SUPPORT_H_
+#define _VC_SUPPORT_H_
+
+/*
+ * vc_support.h
+ *
+ *  Created on: 25 Nov 2012
+ *      Author: Simon
+ */
+
+enum {
+/*
+      If a MEM_HANDLE_T is discardable, the memory manager may resize it to size
+      0 at any time when it is not locked or retained.
+   */
+   MEM_FLAG_DISCARDABLE = 1 << 0,
+
+   /*
+      If a MEM_HANDLE_T is allocating (or normal), its block of memory will be
+      accessed in an allocating fashion through the cache.
+   */
+   MEM_FLAG_NORMAL = 0 << 2,
+   MEM_FLAG_ALLOCATING = MEM_FLAG_NORMAL,
+
+   /*
+      If a MEM_HANDLE_T is direct, its block of memory will be accessed
+      directly, bypassing the cache.
+   */
+   MEM_FLAG_DIRECT = 1 << 2,
+
+   /*
+      If a MEM_HANDLE_T is coherent, its block of memory will be accessed in a
+      non-allocating fashion through the cache.
+   */
+   MEM_FLAG_COHERENT = 2 << 2,
+
+   /*
+      If a MEM_HANDLE_T is L1-nonallocating, its block of memory will be accessed by
+      the VPU in a fashion which is allocating in L2, but only coherent in L1.
+   */
+   MEM_FLAG_L1_NONALLOCATING = (MEM_FLAG_DIRECT | MEM_FLAG_COHERENT),
+
+   /*
+      If a MEM_HANDLE_T is zero'd, its contents are set to 0 rather than
+      MEM_HANDLE_INVALID on allocation and resize up.
+   */
+   MEM_FLAG_ZERO = 1 << 4,
+
+   /*
+      If a MEM_HANDLE_T is uninitialised, it will not be reset to a defined value
+      (either zero, or all 1's) on allocation.
+    */
+   MEM_FLAG_NO_INIT = 1 << 5,
+
+   /*
+      Hints.
+   */
+   MEM_FLAG_HINT_PERMALOCK = 1 << 6, /* Likely to be locked for long periods of time. */
+};
+
+unsigned int AllocateVcMemory(unsigned int *pHandle, unsigned int size, unsigned int alignment, unsigned int flags);
+unsigned int ReleaseVcMemory(unsigned int handle);
+unsigned int LockVcMemory(unsigned int *pBusAddress, unsigned int handle);
+unsigned int UnlockVcMemory(unsigned int handle);
+
+unsigned int ExecuteVcCode(unsigned int code,
+		unsigned int r0, unsigned int r1, unsigned int r2, unsigned int r3, unsigned int r4, unsigned int r5);
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/vcio.h
@@ -0,0 +1,165 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/vcio.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _MACH_BCM2708_VCIO_H
+#define _MACH_BCM2708_VCIO_H
+
+/* Routines to handle I/O via the VideoCore "ARM control" registers
+ * (semaphores, doorbells, mailboxes)
+ */
+
+#define BCM_VCIO_DRIVER_NAME "bcm2708_vcio"
+
+/* Constants shared with the ARM identifying separate mailbox channels */
+#define MBOX_CHAN_POWER    0 /* for use by the power management interface */
+#define MBOX_CHAN_FB       1 /* for use by the frame buffer */
+#define MBOX_CHAN_VCHIQ    3 /* for use by the VCHIQ interface */
+#define MBOX_CHAN_PROPERTY 8 /* for use by the property channel */
+#define MBOX_CHAN_COUNT    9
+
+enum {
+	VCMSG_PROCESS_REQUEST 		= 0x00000000
+};
+enum {
+	VCMSG_REQUEST_SUCCESSFUL 	= 0x80000000,
+	VCMSG_REQUEST_FAILED 		= 0x80000001
+};
+/* Mailbox property tags */
+enum {
+	VCMSG_PROPERTY_END               = 0x00000000,
+	VCMSG_GET_FIRMWARE_REVISION      = 0x00000001,
+	VCMSG_GET_BOARD_MODEL            = 0x00010001,
+	VCMSG_GET_BOARD_REVISION	 = 0x00010002,
+	VCMSG_GET_BOARD_MAC_ADDRESS	 = 0x00010003,
+	VCMSG_GET_BOARD_SERIAL		 = 0x00010004,
+	VCMSG_GET_ARM_MEMORY		 = 0x00010005,
+	VCMSG_GET_VC_MEMORY		 = 0x00010006,
+	VCMSG_GET_CLOCKS		 = 0x00010007,
+	VCMSG_GET_COMMAND_LINE           = 0x00050001,
+	VCMSG_GET_DMA_CHANNELS           = 0x00060001,
+	VCMSG_GET_POWER_STATE            = 0x00020001,
+	VCMSG_GET_TIMING		 = 0x00020002,
+	VCMSG_SET_POWER_STATE            = 0x00028001,
+	VCMSG_GET_CLOCK_STATE            = 0x00030001,
+	VCMSG_SET_CLOCK_STATE            = 0x00038001,
+	VCMSG_GET_CLOCK_RATE             = 0x00030002,
+	VCMSG_SET_CLOCK_RATE             = 0x00038002,
+	VCMSG_GET_VOLTAGE                = 0x00030003,
+	VCMSG_SET_VOLTAGE                = 0x00038003,
+	VCMSG_GET_MAX_CLOCK              = 0x00030004,
+	VCMSG_GET_MAX_VOLTAGE            = 0x00030005,
+	VCMSG_GET_TEMPERATURE            = 0x00030006,
+	VCMSG_GET_MIN_CLOCK              = 0x00030007,
+	VCMSG_GET_MIN_VOLTAGE            = 0x00030008,
+	VCMSG_GET_TURBO                  = 0x00030009,
+	VCMSG_GET_MAX_TEMPERATURE        = 0x0003000a,
+	VCMSG_GET_STC                    = 0x0003000b,
+	VCMSG_SET_TURBO                  = 0x00038009,
+	VCMSG_SET_ALLOCATE_MEM           = 0x0003000c,
+	VCMSG_SET_LOCK_MEM               = 0x0003000d,
+	VCMSG_SET_UNLOCK_MEM             = 0x0003000e,
+	VCMSG_SET_RELEASE_MEM            = 0x0003000f,
+	VCMSG_SET_EXECUTE_CODE           = 0x00030010,
+	VCMSG_SET_EXECUTE_QPU            = 0x00030011,
+	VCMSG_SET_ENABLE_QPU             = 0x00030012,
+	VCMSG_GET_RESOURCE_HANDLE        = 0x00030014,
+	VCMSG_GET_EDID_BLOCK             = 0x00030020,
+	VCMSG_GET_CUSTOMER_OTP           = 0x00030021,
+	VCMSG_SET_CUSTOMER_OTP           = 0x00038021,
+	VCMSG_SET_ALLOCATE_BUFFER        = 0x00040001,
+	VCMSG_SET_RELEASE_BUFFER         = 0x00048001,
+	VCMSG_SET_BLANK_SCREEN           = 0x00040002,
+	VCMSG_TST_BLANK_SCREEN           = 0x00044002,
+	VCMSG_GET_PHYSICAL_WIDTH_HEIGHT  = 0x00040003,
+	VCMSG_TST_PHYSICAL_WIDTH_HEIGHT  = 0x00044003,
+	VCMSG_SET_PHYSICAL_WIDTH_HEIGHT  = 0x00048003,
+	VCMSG_GET_VIRTUAL_WIDTH_HEIGHT   = 0x00040004,
+	VCMSG_TST_VIRTUAL_WIDTH_HEIGHT   = 0x00044004,
+	VCMSG_SET_VIRTUAL_WIDTH_HEIGHT   = 0x00048004,
+	VCMSG_GET_DEPTH                  = 0x00040005,
+	VCMSG_TST_DEPTH                  = 0x00044005,
+	VCMSG_SET_DEPTH                  = 0x00048005,
+	VCMSG_GET_PIXEL_ORDER            = 0x00040006,
+	VCMSG_TST_PIXEL_ORDER            = 0x00044006,
+	VCMSG_SET_PIXEL_ORDER            = 0x00048006,
+	VCMSG_GET_ALPHA_MODE             = 0x00040007,
+	VCMSG_TST_ALPHA_MODE             = 0x00044007,
+	VCMSG_SET_ALPHA_MODE             = 0x00048007,
+	VCMSG_GET_PITCH                  = 0x00040008,
+	VCMSG_TST_PITCH                  = 0x00044008,
+	VCMSG_SET_PITCH                  = 0x00048008,
+	VCMSG_GET_VIRTUAL_OFFSET         = 0x00040009,
+	VCMSG_TST_VIRTUAL_OFFSET         = 0x00044009,
+	VCMSG_SET_VIRTUAL_OFFSET         = 0x00048009,
+	VCMSG_GET_OVERSCAN               = 0x0004000a,
+	VCMSG_TST_OVERSCAN               = 0x0004400a,
+	VCMSG_SET_OVERSCAN               = 0x0004800a,
+	VCMSG_GET_PALETTE                = 0x0004000b,
+	VCMSG_TST_PALETTE                = 0x0004400b,
+	VCMSG_SET_PALETTE                = 0x0004800b,
+	VCMSG_GET_LAYER                  = 0x0004000c,
+	VCMSG_TST_LAYER                  = 0x0004400c,
+	VCMSG_SET_LAYER                  = 0x0004800c,
+	VCMSG_GET_TRANSFORM              = 0x0004000d,
+	VCMSG_TST_TRANSFORM              = 0x0004400d,
+	VCMSG_SET_TRANSFORM              = 0x0004800d,
+	VCMSG_TST_VSYNC                  = 0x0004400e,
+	VCMSG_SET_VSYNC                  = 0x0004800e,
+	VCMSG_SET_CURSOR_INFO            = 0x00008010,
+	VCMSG_SET_CURSOR_STATE           = 0x00008011,
+};
+
+extern int /*rc*/ bcm_mailbox_read(unsigned chan, uint32_t *data28);
+extern int /*rc*/ bcm_mailbox_write(unsigned chan, uint32_t data28);
+extern int /*rc*/ bcm_mailbox_property(void *data, int size);
+
+#include <linux/ioctl.h>
+
+/*
+ * The major device number. We can't rely on dynamic
+ * registration any more, because ioctls need to know
+ * it.
+ */
+#define MAJOR_NUM 100
+
+/*
+ * Set the message of the device driver
+ */
+#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
+/*
+ * _IOWR means that we're creating an ioctl command
+ * number for passing information from a user process
+ * to the kernel module and from the kernel module to user process
+ *
+ * The first arguments, MAJOR_NUM, is the major device
+ * number we're using.
+ *
+ * The second argument is the number of the command
+ * (there could be several with different meanings).
+ *
+ * The third argument is the type we want to get from
+ * the process to the kernel.
+ */
+
+/*
+ * The name of the device file
+ */
+#define DEVICE_FILE_NAME "vcio"
+
+#endif
--- /dev/null
+++ b/arch/arm/mach-bcm2709/include/mach/vmalloc.h
@@ -0,0 +1,20 @@
+/*
+ *  arch/arm/mach-bcm2708/include/mach/vmalloc.h
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define VMALLOC_END		(0xff000000)
--- /dev/null
+++ b/arch/arm/mach-bcm2709/power.c
@@ -0,0 +1,195 @@
+/*
+ *	 linux/arch/arm/mach-bcm2708/power.c
+ *
+ *	 Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This device provides a shared mechanism for controlling the power to
+ * VideoCore subsystems.
+ */
+
+#include <linux/module.h>
+#include <linux/semaphore.h>
+#include <linux/bug.h>
+#include <mach/power.h>
+#include <mach/vcio.h>
+#include <mach/arm_power.h>
+
+#define DRIVER_NAME "bcm2708_power"
+
+#define BCM_POWER_MAXCLIENTS 4
+#define BCM_POWER_NOCLIENT (1<<31)
+
+/* Some drivers expect there devices to be permanently powered */
+#ifdef CONFIG_USB
+#define BCM_POWER_ALWAYS_ON (BCM_POWER_USB)
+#endif
+
+#if 1
+#define DPRINTK printk
+#else
+#define DPRINTK if (0) printk
+#endif
+
+struct state_struct {
+	uint32_t global_request;
+	uint32_t client_request[BCM_POWER_MAXCLIENTS];
+	struct semaphore client_mutex;
+	struct semaphore mutex;
+} g_state;
+
+int bcm_power_open(BCM_POWER_HANDLE_T *handle)
+{
+	BCM_POWER_HANDLE_T i;
+	int ret = -EBUSY;
+
+	down(&g_state.client_mutex);
+
+	for (i = 0; i < BCM_POWER_MAXCLIENTS; i++) {
+		if (g_state.client_request[i] == BCM_POWER_NOCLIENT) {
+			g_state.client_request[i] = BCM_POWER_NONE;
+			*handle = i;
+			ret = 0;
+			break;
+		}
+	}
+
+	up(&g_state.client_mutex);
+
+	DPRINTK("bcm_power_open() -> %d\n", *handle);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(bcm_power_open);
+
+int bcm_power_request(BCM_POWER_HANDLE_T handle, uint32_t request)
+{
+	int rc = 0;
+
+	DPRINTK("bcm_power_request(%d, %x)\n", handle, request);
+
+	if ((handle < BCM_POWER_MAXCLIENTS) &&
+	    (g_state.client_request[handle] != BCM_POWER_NOCLIENT)) {
+		if (down_interruptible(&g_state.mutex) != 0) {
+			DPRINTK("bcm_power_request -> interrupted\n");
+			return -EINTR;
+		}
+
+		if (request != g_state.client_request[handle]) {
+			uint32_t others_request = 0;
+			uint32_t global_request;
+			BCM_POWER_HANDLE_T i;
+
+			for (i = 0; i < BCM_POWER_MAXCLIENTS; i++) {
+				if (i != handle)
+					others_request |=
+					    g_state.client_request[i];
+			}
+			others_request &= ~BCM_POWER_NOCLIENT;
+
+			global_request = request | others_request;
+			if (global_request != g_state.global_request) {
+				uint32_t actual;
+
+				/* Send a request to VideoCore */
+				bcm_mailbox_write(MBOX_CHAN_POWER,
+						  global_request << 4);
+
+				/* Wait for a response during power-up */
+				if (global_request & ~g_state.global_request) {
+					rc = bcm_mailbox_read(MBOX_CHAN_POWER,
+							      &actual);
+					DPRINTK
+					    ("bcm_mailbox_read -> %08x, %d\n",
+					     actual, rc);
+					actual >>= 4;
+				} else {
+					rc = 0;
+					actual = global_request;
+				}
+
+				if (rc == 0) {
+					if (actual != global_request) {
+						printk(KERN_ERR
+						     "%s: prev global %x, new global %x, actual %x, request %x, others_request %x\n",
+						     __func__,
+						     g_state.global_request,
+						     global_request, actual, request, others_request);
+						/* A failure */
+						BUG_ON((others_request & actual)
+						       != others_request);
+						request &= actual;
+						rc = -EIO;
+					}
+
+					g_state.global_request = actual;
+					g_state.client_request[handle] =
+					    request;
+				}
+			}
+		}
+		up(&g_state.mutex);
+	} else {
+		rc = -EINVAL;
+	}
+	DPRINTK("bcm_power_request -> %d\n", rc);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(bcm_power_request);
+
+int bcm_power_close(BCM_POWER_HANDLE_T handle)
+{
+	int rc;
+
+	DPRINTK("bcm_power_close(%d)\n", handle);
+
+	rc = bcm_power_request(handle, BCM_POWER_NONE);
+	if (rc == 0)
+		g_state.client_request[handle] = BCM_POWER_NOCLIENT;
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(bcm_power_close);
+
+static int __init bcm_power_init(void)
+{
+#if defined(BCM_POWER_ALWAYS_ON)
+	BCM_POWER_HANDLE_T always_on_handle;
+#endif
+	int rc = 0;
+	int i;
+
+	printk(KERN_INFO "bcm_power: Broadcom power driver\n");
+	bcm_mailbox_write(MBOX_CHAN_POWER, 0);
+
+	for (i = 0; i < BCM_POWER_MAXCLIENTS; i++)
+		g_state.client_request[i] = BCM_POWER_NOCLIENT;
+
+	sema_init(&g_state.client_mutex, 1);
+	sema_init(&g_state.mutex, 1);
+
+	g_state.global_request = 0;
+#if defined(BCM_POWER_ALWAYS_ON)
+	if (BCM_POWER_ALWAYS_ON) {
+		bcm_power_open(&always_on_handle);
+		bcm_power_request(always_on_handle, BCM_POWER_ALWAYS_ON);
+	}
+#endif
+
+	return rc;
+}
+
+static void __exit bcm_power_exit(void)
+{
+	bcm_mailbox_write(MBOX_CHAN_POWER, 0);
+}
+
+arch_initcall(bcm_power_init);	/* Initialize early */
+module_exit(bcm_power_exit);
+
+MODULE_AUTHOR("Phil Elwell");
+MODULE_DESCRIPTION("Interface to BCM2708 power management");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/arch/arm/mach-bcm2709/vc_mem.c
@@ -0,0 +1,431 @@
+/*****************************************************************************
+* Copyright 2010 - 2011 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/debugfs.h>
+#include <asm/uaccess.h>
+#include <linux/dma-mapping.h>
+
+#ifdef CONFIG_ARCH_KONA
+#include <chal/chal_ipc.h>
+#elif defined(CONFIG_ARCH_BCM2708) || defined(CONFIG_ARCH_BCM2709)
+#else
+#include <csp/chal_ipc.h>
+#endif
+
+#include "mach/vc_mem.h"
+#include <mach/vcio.h>
+
+#define DRIVER_NAME  "vc-mem"
+
+// Device (/dev) related variables
+static dev_t vc_mem_devnum = 0;
+static struct class *vc_mem_class = NULL;
+static struct cdev vc_mem_cdev;
+static int vc_mem_inited = 0;
+
+#ifdef CONFIG_DEBUG_FS
+static struct dentry *vc_mem_debugfs_entry;
+#endif
+
+/*
+ * Videocore memory addresses and size
+ *
+ * Drivers that wish to know the videocore memory addresses and sizes should
+ * use these variables instead of the MM_IO_BASE and MM_ADDR_IO defines in
+ * headers. This allows the other drivers to not be tied down to a a certain
+ * address/size at compile time.
+ *
+ * In the future, the goal is to have the videocore memory virtual address and
+ * size be calculated at boot time rather than at compile time. The decision of
+ * where the videocore memory resides and its size would be in the hands of the
+ * bootloader (and/or kernel). When that happens, the values of these variables
+ * would be calculated and assigned in the init function.
+ */
+// in the 2835 VC in mapped above ARM, but ARM has full access to VC space
+unsigned long mm_vc_mem_phys_addr = 0x00000000;
+unsigned int mm_vc_mem_size = 0;
+unsigned int mm_vc_mem_base = 0;
+
+EXPORT_SYMBOL(mm_vc_mem_phys_addr);
+EXPORT_SYMBOL(mm_vc_mem_size);
+EXPORT_SYMBOL(mm_vc_mem_base);
+
+static uint phys_addr = 0;
+static uint mem_size = 0;
+static uint mem_base = 0;
+
+
+/****************************************************************************
+*
+*   vc_mem_open
+*
+***************************************************************************/
+
+static int
+vc_mem_open(struct inode *inode, struct file *file)
+{
+	(void) inode;
+	(void) file;
+
+	pr_debug("%s: called file = 0x%p\n", __func__, file);
+
+	return 0;
+}
+
+/****************************************************************************
+*
+*   vc_mem_release
+*
+***************************************************************************/
+
+static int
+vc_mem_release(struct inode *inode, struct file *file)
+{
+	(void) inode;
+	(void) file;
+
+	pr_debug("%s: called file = 0x%p\n", __func__, file);
+
+	return 0;
+}
+
+/****************************************************************************
+*
+*   vc_mem_get_size
+*
+***************************************************************************/
+
+static void
+vc_mem_get_size(void)
+{
+}
+
+/****************************************************************************
+*
+*   vc_mem_get_base
+*
+***************************************************************************/
+
+static void
+vc_mem_get_base(void)
+{
+}
+
+/****************************************************************************
+*
+*   vc_mem_get_current_size
+*
+***************************************************************************/
+
+int
+vc_mem_get_current_size(void)
+{
+	return mm_vc_mem_size;
+}
+
+EXPORT_SYMBOL_GPL(vc_mem_get_current_size);
+
+/****************************************************************************
+*
+*   vc_mem_ioctl
+*
+***************************************************************************/
+
+static long
+vc_mem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rc = 0;
+
+	(void) cmd;
+	(void) arg;
+
+	pr_debug("%s: called file = 0x%p\n", __func__, file);
+
+	switch (cmd) {
+	case VC_MEM_IOC_MEM_PHYS_ADDR:
+		{
+			pr_debug("%s: VC_MEM_IOC_MEM_PHYS_ADDR=0x%p\n",
+				__func__, (void *) mm_vc_mem_phys_addr);
+
+			if (copy_to_user((void *) arg, &mm_vc_mem_phys_addr,
+					 sizeof (mm_vc_mem_phys_addr)) != 0) {
+				rc = -EFAULT;
+			}
+			break;
+		}
+	case VC_MEM_IOC_MEM_SIZE:
+		{
+			// Get the videocore memory size first
+			vc_mem_get_size();
+
+			pr_debug("%s: VC_MEM_IOC_MEM_SIZE=%u\n", __func__,
+				mm_vc_mem_size);
+
+			if (copy_to_user((void *) arg, &mm_vc_mem_size,
+					 sizeof (mm_vc_mem_size)) != 0) {
+				rc = -EFAULT;
+			}
+			break;
+		}
+	case VC_MEM_IOC_MEM_BASE:
+		{
+			// Get the videocore memory base
+			vc_mem_get_base();
+
+			pr_debug("%s: VC_MEM_IOC_MEM_BASE=%u\n", __func__,
+				mm_vc_mem_base);
+
+			if (copy_to_user((void *) arg, &mm_vc_mem_base,
+					 sizeof (mm_vc_mem_base)) != 0) {
+				rc = -EFAULT;
+			}
+			break;
+		}
+	case VC_MEM_IOC_MEM_LOAD:
+		{
+			// Get the videocore memory base
+			vc_mem_get_base();
+
+			pr_debug("%s: VC_MEM_IOC_MEM_LOAD=%u\n", __func__,
+				mm_vc_mem_base);
+
+			if (copy_to_user((void *) arg, &mm_vc_mem_base,
+					 sizeof (mm_vc_mem_base)) != 0) {
+				rc = -EFAULT;
+			}
+			break;
+		}
+	default:
+		{
+			return -ENOTTY;
+		}
+	}
+	pr_debug("%s: file = 0x%p returning %d\n", __func__, file, rc);
+
+	return rc;
+}
+
+/****************************************************************************
+*
+*   vc_mem_mmap
+*
+***************************************************************************/
+
+static int
+vc_mem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int rc = 0;
+	unsigned long length = vma->vm_end - vma->vm_start;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+
+	pr_debug("%s: vm_start = 0x%08lx vm_end = 0x%08lx vm_pgoff = 0x%08lx\n",
+		__func__, (long) vma->vm_start, (long) vma->vm_end,
+		(long) vma->vm_pgoff);
+
+	if (offset + length > mm_vc_mem_size) {
+		pr_err("%s: length %ld is too big\n", __func__, length);
+		return -EINVAL;
+	}
+	// Do not cache the memory map
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	rc = remap_pfn_range(vma, vma->vm_start,
+			     (mm_vc_mem_phys_addr >> PAGE_SHIFT) +
+			     vma->vm_pgoff, length, vma->vm_page_prot);
+	if (rc != 0) {
+		pr_err("%s: remap_pfn_range failed (rc=%d)\n", __func__, rc);
+	}
+
+	return rc;
+}
+
+/****************************************************************************
+*
+*   File Operations for the driver.
+*
+***************************************************************************/
+
+static const struct file_operations vc_mem_fops = {
+	.owner = THIS_MODULE,
+	.open = vc_mem_open,
+	.release = vc_mem_release,
+	.unlocked_ioctl = vc_mem_ioctl,
+	.mmap = vc_mem_mmap,
+};
+
+#ifdef CONFIG_DEBUG_FS
+static void vc_mem_debugfs_deinit(void)
+{
+	debugfs_remove_recursive(vc_mem_debugfs_entry);
+	vc_mem_debugfs_entry = NULL;
+}
+
+
+static int vc_mem_debugfs_init(
+	struct device *dev)
+{
+	vc_mem_debugfs_entry = debugfs_create_dir(DRIVER_NAME, NULL);
+	if (!vc_mem_debugfs_entry) {
+		dev_warn(dev, "could not create debugfs entry\n");
+		return -EFAULT;
+	}
+
+	if (!debugfs_create_x32("vc_mem_phys_addr",
+				0444,
+				vc_mem_debugfs_entry,
+				(u32 *)&mm_vc_mem_phys_addr)) {
+		dev_warn(dev, "%s:could not create vc_mem_phys entry\n",
+			__func__);
+		goto fail;
+	}
+
+	if (!debugfs_create_x32("vc_mem_size",
+				0444,
+				vc_mem_debugfs_entry,
+				(u32 *)&mm_vc_mem_size)) {
+		dev_warn(dev, "%s:could not create vc_mem_size entry\n",
+			__func__);
+		goto fail;
+	}
+
+	if (!debugfs_create_x32("vc_mem_base",
+				0444,
+				vc_mem_debugfs_entry,
+				(u32 *)&mm_vc_mem_base)) {
+		dev_warn(dev, "%s:could not create vc_mem_base entry\n",
+			 __func__);
+		goto fail;
+	}
+
+	return 0;
+
+fail:
+	vc_mem_debugfs_deinit();
+	return -EFAULT;
+}
+
+#endif /* CONFIG_DEBUG_FS */
+
+
+/****************************************************************************
+*
+*   vc_mem_init
+*
+***************************************************************************/
+
+static int __init
+vc_mem_init(void)
+{
+	int rc = -EFAULT;
+	struct device *dev;
+
+	pr_debug("%s: called\n", __func__);
+
+	mm_vc_mem_phys_addr = phys_addr;
+	mm_vc_mem_size = mem_size;
+	mm_vc_mem_base = mem_base;
+
+	vc_mem_get_size();
+
+	pr_info("vc-mem: phys_addr:0x%08lx mem_base=0x%08x mem_size:0x%08x(%u MiB)\n",
+		mm_vc_mem_phys_addr, mm_vc_mem_base, mm_vc_mem_size, mm_vc_mem_size / (1024 * 1024));
+
+	if ((rc = alloc_chrdev_region(&vc_mem_devnum, 0, 1, DRIVER_NAME)) < 0) {
+		pr_err("%s: alloc_chrdev_region failed (rc=%d)\n",
+		       __func__, rc);
+		goto out_err;
+	}
+
+	cdev_init(&vc_mem_cdev, &vc_mem_fops);
+	if ((rc = cdev_add(&vc_mem_cdev, vc_mem_devnum, 1)) != 0) {
+		pr_err("%s: cdev_add failed (rc=%d)\n", __func__, rc);
+		goto out_unregister;
+	}
+
+	vc_mem_class = class_create(THIS_MODULE, DRIVER_NAME);
+	if (IS_ERR(vc_mem_class)) {
+		rc = PTR_ERR(vc_mem_class);
+		pr_err("%s: class_create failed (rc=%d)\n", __func__, rc);
+		goto out_cdev_del;
+	}
+
+	dev = device_create(vc_mem_class, NULL, vc_mem_devnum, NULL,
+			    DRIVER_NAME);
+	if (IS_ERR(dev)) {
+		rc = PTR_ERR(dev);
+		pr_err("%s: device_create failed (rc=%d)\n", __func__, rc);
+		goto out_class_destroy;
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	/* don't fail if the debug entries cannot be created */
+	vc_mem_debugfs_init(dev);
+#endif
+
+	vc_mem_inited = 1;
+	return 0;
+
+	device_destroy(vc_mem_class, vc_mem_devnum);
+
+      out_class_destroy:
+	class_destroy(vc_mem_class);
+	vc_mem_class = NULL;
+
+      out_cdev_del:
+	cdev_del(&vc_mem_cdev);
+
+      out_unregister:
+	unregister_chrdev_region(vc_mem_devnum, 1);
+
+      out_err:
+	return -1;
+}
+
+/****************************************************************************
+*
+*   vc_mem_exit
+*
+***************************************************************************/
+
+static void __exit
+vc_mem_exit(void)
+{
+	pr_debug("%s: called\n", __func__);
+
+	if (vc_mem_inited) {
+#if CONFIG_DEBUG_FS
+		vc_mem_debugfs_deinit();
+#endif
+		device_destroy(vc_mem_class, vc_mem_devnum);
+		class_destroy(vc_mem_class);
+		cdev_del(&vc_mem_cdev);
+		unregister_chrdev_region(vc_mem_devnum, 1);
+	}
+}
+
+module_init(vc_mem_init);
+module_exit(vc_mem_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Broadcom Corporation");
+
+module_param(phys_addr, uint, 0644);
+module_param(mem_size, uint, 0644);
+module_param(mem_base, uint, 0644);
--- /dev/null
+++ b/arch/arm/mach-bcm2709/vc_support.c
@@ -0,0 +1,318 @@
+/*
+ * vc_support.c
+ *
+ *  Created on: 25 Nov 2012
+ *      Author: Simon
+ */
+
+#include <linux/module.h>
+#include <mach/vcio.h>
+
+#ifdef ECLIPSE_IGNORE
+
+#define __user
+#define __init
+#define __exit
+#define __iomem
+#define KERN_DEBUG
+#define KERN_ERR
+#define KERN_WARNING
+#define KERN_INFO
+#define _IOWR(a, b, c) b
+#define _IOW(a, b, c) b
+#define _IO(a, b) b
+
+#endif
+
+/****** VC MAILBOX FUNCTIONALITY ******/
+unsigned int AllocateVcMemory(unsigned int *pHandle, unsigned int size, unsigned int alignment, unsigned int flags)
+{
+	struct vc_msg
+	{
+		unsigned int m_msgSize;
+		unsigned int m_response;
+
+		struct vc_tag
+		{
+			unsigned int m_tagId;
+			unsigned int m_sendBufferSize;
+			union {
+				unsigned int m_sendDataSize;
+				unsigned int m_recvDataSize;
+			};
+
+			struct args
+			{
+				union {
+					unsigned int m_size;
+					unsigned int m_handle;
+				};
+				unsigned int m_alignment;
+				unsigned int m_flags;
+			} m_args;
+		} m_tag;
+
+		unsigned int m_endTag;
+	} msg;
+	int s;
+
+	msg.m_msgSize = sizeof(msg);
+	msg.m_response = 0;
+	msg.m_endTag = 0;
+
+	//fill in the tag for the allocation command
+	msg.m_tag.m_tagId = 0x3000c;
+	msg.m_tag.m_sendBufferSize = 12;
+	msg.m_tag.m_sendDataSize = 12;
+
+	//fill in our args
+	msg.m_tag.m_args.m_size = size;
+	msg.m_tag.m_args.m_alignment = alignment;
+	msg.m_tag.m_args.m_flags = flags;
+
+	//run the command
+	s = bcm_mailbox_property(&msg, sizeof(msg));
+
+	if (s == 0 && msg.m_response == 0x80000000 && msg.m_tag.m_recvDataSize == 0x80000004)
+	{
+		*pHandle = msg.m_tag.m_args.m_handle;
+		return 0;
+	}
+	else
+	{
+		printk(KERN_ERR "failed to allocate vc memory: s=%d response=%08x recv data size=%08x\n",
+				s, msg.m_response, msg.m_tag.m_recvDataSize);
+		return 1;
+	}
+}
+
+unsigned int ReleaseVcMemory(unsigned int handle)
+{
+	struct vc_msg
+	{
+		unsigned int m_msgSize;
+		unsigned int m_response;
+
+		struct vc_tag
+		{
+			unsigned int m_tagId;
+			unsigned int m_sendBufferSize;
+			union {
+				unsigned int m_sendDataSize;
+				unsigned int m_recvDataSize;
+			};
+
+			struct args
+			{
+				union {
+					unsigned int m_handle;
+					unsigned int m_error;
+				};
+			} m_args;
+		} m_tag;
+
+		unsigned int m_endTag;
+	} msg;
+	int s;
+
+	msg.m_msgSize = sizeof(msg);
+	msg.m_response = 0;
+	msg.m_endTag = 0;
+
+	//fill in the tag for the release command
+	msg.m_tag.m_tagId = 0x3000f;
+	msg.m_tag.m_sendBufferSize = 4;
+	msg.m_tag.m_sendDataSize = 4;
+
+	//pass across the handle
+	msg.m_tag.m_args.m_handle = handle;
+
+	s = bcm_mailbox_property(&msg, sizeof(msg));
+
+	if (s == 0 && msg.m_response == 0x80000000 && msg.m_tag.m_recvDataSize == 0x80000004 && msg.m_tag.m_args.m_error == 0)
+		return 0;
+	else
+	{
+		printk(KERN_ERR "failed to release vc memory: s=%d response=%08x recv data size=%08x error=%08x\n",
+				s, msg.m_response, msg.m_tag.m_recvDataSize, msg.m_tag.m_args.m_error);
+		return 1;
+	}
+}
+
+unsigned int LockVcMemory(unsigned int *pBusAddress, unsigned int handle)
+{
+	struct vc_msg
+	{
+		unsigned int m_msgSize;
+		unsigned int m_response;
+
+		struct vc_tag
+		{
+			unsigned int m_tagId;
+			unsigned int m_sendBufferSize;
+			union {
+				unsigned int m_sendDataSize;
+				unsigned int m_recvDataSize;
+			};
+
+			struct args
+			{
+				union {
+					unsigned int m_handle;
+					unsigned int m_busAddress;
+				};
+			} m_args;
+		} m_tag;
+
+		unsigned int m_endTag;
+	} msg;
+	int s;
+
+	msg.m_msgSize = sizeof(msg);
+	msg.m_response = 0;
+	msg.m_endTag = 0;
+
+	//fill in the tag for the lock command
+	msg.m_tag.m_tagId = 0x3000d;
+	msg.m_tag.m_sendBufferSize = 4;
+	msg.m_tag.m_sendDataSize = 4;
+
+	//pass across the handle
+	msg.m_tag.m_args.m_handle = handle;
+
+	s = bcm_mailbox_property(&msg, sizeof(msg));
+
+	if (s == 0 && msg.m_response == 0x80000000 && msg.m_tag.m_recvDataSize == 0x80000004)
+	{
+		//pick out the bus address
+		*pBusAddress = msg.m_tag.m_args.m_busAddress;
+		return 0;
+	}
+	else
+	{
+		printk(KERN_ERR "failed to lock vc memory: s=%d response=%08x recv data size=%08x\n",
+				s, msg.m_response, msg.m_tag.m_recvDataSize);
+		return 1;
+	}
+}
+
+unsigned int UnlockVcMemory(unsigned int handle)
+{
+	struct vc_msg
+	{
+		unsigned int m_msgSize;
+		unsigned int m_response;
+
+		struct vc_tag
+		{
+			unsigned int m_tagId;
+			unsigned int m_sendBufferSize;
+			union {
+				unsigned int m_sendDataSize;
+				unsigned int m_recvDataSize;
+			};
+
+			struct args
+			{
+				union {
+					unsigned int m_handle;
+					unsigned int m_error;
+				};
+			} m_args;
+		} m_tag;
+
+		unsigned int m_endTag;
+	} msg;
+	int s;
+
+	msg.m_msgSize = sizeof(msg);
+	msg.m_response = 0;
+	msg.m_endTag = 0;
+
+	//fill in the tag for the unlock command
+	msg.m_tag.m_tagId = 0x3000e;
+	msg.m_tag.m_sendBufferSize = 4;
+	msg.m_tag.m_sendDataSize = 4;
+
+	//pass across the handle
+	msg.m_tag.m_args.m_handle = handle;
+
+	s = bcm_mailbox_property(&msg, sizeof(msg));
+
+	//check the error code too
+	if (s == 0 && msg.m_response == 0x80000000 && msg.m_tag.m_recvDataSize == 0x80000004 && msg.m_tag.m_args.m_error == 0)
+		return 0;
+	else
+	{
+		printk(KERN_ERR "failed to unlock vc memory: s=%d response=%08x recv data size=%08x error%08x\n",
+				s, msg.m_response, msg.m_tag.m_recvDataSize, msg.m_tag.m_args.m_error);
+		return 1;
+	}
+}
+
+unsigned int ExecuteVcCode(unsigned int code,
+		unsigned int r0, unsigned int r1, unsigned int r2, unsigned int r3, unsigned int r4, unsigned int r5)
+{
+	struct vc_msg
+	{
+		unsigned int m_msgSize;
+		unsigned int m_response;
+
+		struct vc_tag
+		{
+			unsigned int m_tagId;
+			unsigned int m_sendBufferSize;
+			union {
+				unsigned int m_sendDataSize;
+				unsigned int m_recvDataSize;
+			};
+
+			struct args
+			{
+				union {
+					unsigned int m_pCode;
+					unsigned int m_return;
+				};
+				unsigned int m_r0;
+				unsigned int m_r1;
+				unsigned int m_r2;
+				unsigned int m_r3;
+				unsigned int m_r4;
+				unsigned int m_r5;
+			} m_args;
+		} m_tag;
+
+		unsigned int m_endTag;
+	} msg;
+	int s;
+
+	msg.m_msgSize = sizeof(msg);
+	msg.m_response = 0;
+	msg.m_endTag = 0;
+
+	//fill in the tag for the unlock command
+	msg.m_tag.m_tagId = 0x30010;
+	msg.m_tag.m_sendBufferSize = 28;
+	msg.m_tag.m_sendDataSize = 28;
+
+	//pass across the handle
+	msg.m_tag.m_args.m_pCode = code;
+	msg.m_tag.m_args.m_r0 = r0;
+	msg.m_tag.m_args.m_r1 = r1;
+	msg.m_tag.m_args.m_r2 = r2;
+	msg.m_tag.m_args.m_r3 = r3;
+	msg.m_tag.m_args.m_r4 = r4;
+	msg.m_tag.m_args.m_r5 = r5;
+
+	s = bcm_mailbox_property(&msg, sizeof(msg));
+
+	//check the error code too
+	if (s == 0 && msg.m_response == 0x80000000 && msg.m_tag.m_recvDataSize == 0x80000004)
+		return msg.m_tag.m_args.m_return;
+	else
+	{
+		printk(KERN_ERR "failed to execute: s=%d response=%08x recv data size=%08x\n",
+				s, msg.m_response, msg.m_tag.m_recvDataSize);
+		return 1;
+	}
+}
--- /dev/null
+++ b/arch/arm/mach-bcm2709/vcio.c
@@ -0,0 +1,474 @@
+/*
+ *  linux/arch/arm/mach-bcm2708/vcio.c
+ *
+ *  Copyright (C) 2010 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This device provides a shared mechanism for writing to the mailboxes,
+ * semaphores, doorbells etc. that are shared between the ARM and the
+ * VideoCore processor
+ */
+
+#if defined(CONFIG_SERIAL_BCM_MBOX_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/sysrq.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <linux/io.h>
+
+#include <mach/vcio.h>
+#include <mach/platform.h>
+
+#include <asm/uaccess.h>
+
+
+#define DRIVER_NAME BCM_VCIO_DRIVER_NAME
+
+/* ----------------------------------------------------------------------
+ *	Mailbox
+ * -------------------------------------------------------------------- */
+
+/* offsets from a mail box base address */
+#define MAIL_WRT	0x00	/* write - and next 4 words */
+#define MAIL_RD		0x00	/* read - and next 4 words */
+#define MAIL_POL	0x10	/* read without popping the fifo */
+#define MAIL_SND	0x14	/* sender ID (bottom two bits) */
+#define MAIL_STA	0x18	/* status */
+#define MAIL_CNF	0x1C	/* configuration */
+
+#define MBOX_MSG(chan, data28)		(((data28) & ~0xf) | ((chan) & 0xf))
+#define MBOX_MSG_LSB(chan, data28) (((data28) << 4) | ((chan) & 0xf))
+#define MBOX_CHAN(msg)			((msg) & 0xf)
+#define MBOX_DATA28(msg)		((msg) & ~0xf)
+#define MBOX_DATA28_LSB(msg)		(((uint32_t)msg) >> 4)
+
+#define MBOX_MAGIC 0xd0d0c0de
+
+struct vc_mailbox {
+	struct device *dev;	/* parent device */
+	void __iomem *status;
+	void __iomem *config;
+	void __iomem *read;
+	void __iomem *write;
+	uint32_t msg[MBOX_CHAN_COUNT];
+	struct semaphore sema[MBOX_CHAN_COUNT];
+	uint32_t magic;
+};
+
+static void mbox_init(struct vc_mailbox *mbox_out, struct device *dev,
+		      uint32_t addr_mbox)
+{
+	int i;
+
+	mbox_out->dev = dev;
+	mbox_out->status = __io_address(addr_mbox + MAIL_STA);
+	mbox_out->config = __io_address(addr_mbox + MAIL_CNF);
+	mbox_out->read = __io_address(addr_mbox + MAIL_RD);
+	/* Write to the other mailbox */
+	mbox_out->write =
+	    __io_address((addr_mbox ^ ARM_0_MAIL0_WRT ^ ARM_0_MAIL1_WRT) +
+			 MAIL_WRT);
+
+	for (i = 0; i < MBOX_CHAN_COUNT; i++) {
+		mbox_out->msg[i] = 0;
+		sema_init(&mbox_out->sema[i], 0);
+	}
+
+	/* Enable the interrupt on data reception */
+	writel(ARM_MC_IHAVEDATAIRQEN, mbox_out->config);
+
+	mbox_out->magic = MBOX_MAGIC;
+}
+
+static int mbox_write(struct vc_mailbox *mbox, unsigned chan, uint32_t data28)
+{
+	int rc;
+
+	if (mbox->magic != MBOX_MAGIC)
+		rc = -EINVAL;
+	else {
+		/* wait for the mailbox FIFO to have some space in it */
+		while (0 != (readl(mbox->status) & ARM_MS_FULL))
+			cpu_relax();
+
+		writel(MBOX_MSG(chan, data28), mbox->write);
+		rc = 0;
+	}
+	return rc;
+}
+
+static int mbox_read(struct vc_mailbox *mbox, unsigned chan, uint32_t *data28)
+{
+	int rc;
+
+	if (mbox->magic != MBOX_MAGIC)
+		rc = -EINVAL;
+	else {
+		down(&mbox->sema[chan]);
+		*data28 = MBOX_DATA28(mbox->msg[chan]);
+		mbox->msg[chan] = 0;
+		rc = 0;
+	}
+	return rc;
+}
+
+static irqreturn_t mbox_irq(int irq, void *dev_id)
+{
+	/* wait for the mailbox FIFO to have some data in it */
+	struct vc_mailbox *mbox = (struct vc_mailbox *) dev_id;
+	int status = readl(mbox->status);
+	int ret = IRQ_NONE;
+
+	while (!(status & ARM_MS_EMPTY)) {
+		uint32_t msg = readl(mbox->read);
+		int chan = MBOX_CHAN(msg);
+		if (chan < MBOX_CHAN_COUNT) {
+			if (mbox->msg[chan]) {
+				/* Overflow */
+				printk(KERN_ERR DRIVER_NAME
+				       ": mbox chan %d overflow - drop %08x\n",
+				       chan, msg);
+			} else {
+				mbox->msg[chan] = (msg | 0xf);
+				up(&mbox->sema[chan]);
+			}
+		} else {
+			printk(KERN_ERR DRIVER_NAME
+			       ": invalid channel selector (msg %08x)\n", msg);
+		}
+		ret = IRQ_HANDLED;
+		status = readl(mbox->status);
+	}
+	return ret;
+}
+
+static struct irqaction mbox_irqaction = {
+	.name = "ARM Mailbox IRQ",
+	.flags = IRQF_DISABLED | IRQF_IRQPOLL,
+	.handler = mbox_irq,
+};
+
+/* ----------------------------------------------------------------------
+ *	Mailbox Methods
+ * -------------------------------------------------------------------- */
+
+static struct device *mbox_dev;	/* we assume there's only one! */
+
+static int dev_mbox_write(struct device *dev, unsigned chan, uint32_t data28)
+{
+	int rc;
+
+	struct vc_mailbox *mailbox = dev_get_drvdata(dev);
+	device_lock(dev);
+	rc = mbox_write(mailbox, chan, data28);
+	device_unlock(dev);
+
+	return rc;
+}
+
+static int dev_mbox_read(struct device *dev, unsigned chan, uint32_t *data28)
+{
+	int rc;
+
+	struct vc_mailbox *mailbox = dev_get_drvdata(dev);
+	device_lock(dev);
+	rc = mbox_read(mailbox, chan, data28);
+	device_unlock(dev);
+
+	return rc;
+}
+
+extern int bcm_mailbox_write(unsigned chan, uint32_t data28)
+{
+	if (mbox_dev)
+		return dev_mbox_write(mbox_dev, chan, data28);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(bcm_mailbox_write);
+
+extern int bcm_mailbox_read(unsigned chan, uint32_t *data28)
+{
+	if (mbox_dev)
+		return dev_mbox_read(mbox_dev, chan, data28);
+	else
+		return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(bcm_mailbox_read);
+
+static void dev_mbox_register(const char *dev_name, struct device *dev)
+{
+	mbox_dev = dev;
+}
+
+static int mbox_copy_from_user(void *dst, const void *src, int size)
+{
+	if ( (uint32_t)src < TASK_SIZE)
+	{
+		return copy_from_user(dst, src, size);
+	}
+	else
+	{
+		memcpy( dst, src, size );
+		return 0;
+	}
+}
+
+static int mbox_copy_to_user(void *dst, const void *src, int size)
+{
+	if ( (uint32_t)dst < TASK_SIZE)
+	{
+		return copy_to_user(dst, src, size);
+	}
+	else
+	{
+		memcpy( dst, src, size );
+		return 0;
+	}
+}
+
+static DEFINE_MUTEX(mailbox_lock);
+extern int bcm_mailbox_property(void *data, int size)
+{
+	uint32_t success;
+	dma_addr_t mem_bus;				/* the memory address accessed from videocore */
+	void *mem_kern;					/* the memory address accessed from driver */
+	int s = 0;
+
+        mutex_lock(&mailbox_lock);
+	/* allocate some memory for the messages communicating with GPU */
+	mem_kern = dma_alloc_coherent(NULL, PAGE_ALIGN(size), &mem_bus, GFP_ATOMIC);
+	if (mem_kern) {
+		/* create the message */
+		mbox_copy_from_user(mem_kern, data, size);
+
+		/* send the message */
+		wmb();
+		s = bcm_mailbox_write(MBOX_CHAN_PROPERTY, (uint32_t)mem_bus);
+		if (s == 0) {
+			s = bcm_mailbox_read(MBOX_CHAN_PROPERTY, &success);
+		}
+		if (s == 0) {
+			/* copy the response */
+			rmb();
+			mbox_copy_to_user(data, mem_kern, size);
+		}
+		dma_free_coherent(NULL, PAGE_ALIGN(size), mem_kern, mem_bus);
+	} else {
+		s = -ENOMEM;
+	}
+	if (s != 0)
+		printk(KERN_ERR DRIVER_NAME ": %s failed (%d)\n", __func__, s);
+
+        mutex_unlock(&mailbox_lock);
+	return s;
+}
+EXPORT_SYMBOL_GPL(bcm_mailbox_property);
+
+/* ----------------------------------------------------------------------
+ *	Platform Device for Mailbox
+ * -------------------------------------------------------------------- */
+
+/*
+ * Is the device open right now? Used to prevent
+ * concurent access into the same device
+ */
+static int Device_Open = 0;
+
+/*
+ * This is called whenever a process attempts to open the device file
+ */
+static int device_open(struct inode *inode, struct file *file)
+{
+	/*
+	 * We don't want to talk to two processes at the same time
+	 */
+	if (Device_Open)
+		return -EBUSY;
+
+	Device_Open++;
+	/*
+	 * Initialize the message
+	 */
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int device_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * We're now ready for our next caller
+	 */
+	Device_Open--;
+
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+/*
+ * This function is called whenever a process tries to do an ioctl on our
+ * device file. We get two extra parameters (additional to the inode and file
+ * structures, which all device functions get): the number of the ioctl called
+ * and the parameter given to the ioctl function.
+ *
+ * If the ioctl is write or read/write (meaning output is returned to the
+ * calling process), the ioctl call returns the output of this function.
+ *
+ */
+static long device_ioctl(struct file *file,	/* see include/linux/fs.h */
+		 unsigned int ioctl_num,	/* number and param for ioctl */
+		 unsigned long ioctl_param)
+{
+	unsigned size;
+	/*
+	 * Switch according to the ioctl called
+	 */
+	switch (ioctl_num) {
+	case IOCTL_MBOX_PROPERTY:
+		/*
+		 * Receive a pointer to a message (in user space) and set that
+		 * to be the device's message.  Get the parameter given to
+		 * ioctl by the process.
+		 */
+		mbox_copy_from_user(&size, (void *)ioctl_param, sizeof size);
+		return bcm_mailbox_property((void *)ioctl_param, size);
+		break;
+	default:
+		printk(KERN_ERR DRIVER_NAME "unknown ioctl: %d\n", ioctl_num);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* Module Declarations */
+
+/*
+ * This structure will hold the functions to be called
+ * when a process does something to the device we
+ * created. Since a pointer to this structure is kept in
+ * the devices table, it can't be local to
+ * init_module. NULL is for unimplemented functios.
+ */
+struct file_operations fops = {
+	.unlocked_ioctl = device_ioctl,
+	.open = device_open,
+	.release = device_release,	/* a.k.a. close */
+};
+
+static int bcm_vcio_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct vc_mailbox *mailbox;
+
+	mailbox = kzalloc(sizeof(*mailbox), GFP_KERNEL);
+	if (NULL == mailbox) {
+		printk(KERN_ERR DRIVER_NAME ": failed to allocate "
+		       "mailbox memory\n");
+		ret = -ENOMEM;
+	} else {
+		struct resource *res;
+
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (res == NULL) {
+			printk(KERN_ERR DRIVER_NAME ": failed to obtain memory "
+			       "resource\n");
+			ret = -ENODEV;
+			kfree(mailbox);
+		} else {
+			/* should be based on the registers from res really */
+			mbox_init(mailbox, &pdev->dev, ARM_0_MAIL0_RD);
+
+			platform_set_drvdata(pdev, mailbox);
+			dev_mbox_register(DRIVER_NAME, &pdev->dev);
+
+			mbox_irqaction.dev_id = mailbox;
+			setup_irq(IRQ_ARM_MAILBOX, &mbox_irqaction);
+			printk(KERN_INFO DRIVER_NAME ": mailbox at %p\n",
+			       __io_address(ARM_0_MAIL0_RD));
+		}
+	}
+
+	if (ret == 0) {
+		/*
+		 * Register the character device
+		 */
+		ret = register_chrdev(MAJOR_NUM, DEVICE_FILE_NAME, &fops);
+
+		/*
+		 * Negative values signify an error
+		 */
+		if (ret < 0) {
+			printk(KERN_ERR DRIVER_NAME
+			       "Failed registering the character device %d\n", ret);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+static int bcm_vcio_remove(struct platform_device *pdev)
+{
+	struct vc_mailbox *mailbox = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(mailbox);
+
+	return 0;
+}
+
+static struct platform_driver bcm_mbox_driver = {
+	.probe = bcm_vcio_probe,
+	.remove = bcm_vcio_remove,
+
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init bcm_mbox_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "mailbox: Broadcom VideoCore Mailbox driver\n");
+
+	ret = platform_driver_register(&bcm_mbox_driver);
+	if (ret != 0) {
+		printk(KERN_ERR DRIVER_NAME ": failed to register "
+		       "on platform\n");
+	}
+
+	return ret;
+}
+
+static void __exit bcm_mbox_exit(void)
+{
+	platform_driver_unregister(&bcm_mbox_driver);
+}
+
+arch_initcall(bcm_mbox_init);	/* Initialize early */
+module_exit(bcm_mbox_exit);
+
+MODULE_AUTHOR("Gray Girling");
+MODULE_DESCRIPTION("ARM I/O to VideoCore processor");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:bcm-mbox");
--- a/arch/arm/mm/proc-v7.S
+++ b/arch/arm/mm/proc-v7.S
@@ -441,6 +441,7 @@ __v7_setup:
 	orr	r0, r0, r6			@ set them
  THUMB(	orr	r0, r0, #1 << 30	)	@ Thumb exceptions
 	ret	lr				@ return to head.S:__ret
+        .space 256
 ENDPROC(__v7_setup)
 
 	.align	2
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -523,6 +523,7 @@ prima2_evb		MACH_PRIMA2_EVB		PRIMA2_EVB
 paz00			MACH_PAZ00		PAZ00			3128
 acmenetusfoxg20		MACH_ACMENETUSFOXG20	ACMENETUSFOXG20		3129
 bcm2708			MACH_BCM2708		BCM2708			3138
+bcm2709			MACH_BCM2709		BCM2709			3139
 ag5evm			MACH_AG5EVM		AG5EVM			3189
 ics_if_voip		MACH_ICS_IF_VOIP	ICS_IF_VOIP		3206
 wlf_cragg_6410		MACH_WLF_CRAGG_6410	WLF_CRAGG_6410		3207
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -322,7 +322,7 @@ config HW_RANDOM_TPM
 
 config HW_RANDOM_BCM2708
 	tristate "BCM2708 generic true random number generator support"
-	depends on HW_RANDOM && ARCH_BCM2708
+	depends on HW_RANDOM && (ARCH_BCM2708 || ARCH_BCM2709)
 	---help---
 	 This driver provides the kernel-side support for the BCM2708 hardware.
 
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -795,3 +795,39 @@ static void __init arch_timer_mem_init(s
 }
 CLOCKSOURCE_OF_DECLARE(armv7_arch_timer_mem, "arm,armv7-timer-mem",
 		       arch_timer_mem_init);
+
+int __init dc4_arch_timer_init(void)
+{
+	if (arch_timers_present & ARCH_CP15_TIMER) {
+		pr_warn("arch_timer: multiple nodes in dt, skipping\n");
+		return -1;
+	}
+
+	arch_timers_present |= ARCH_CP15_TIMER;
+
+	/* Try to determine the frequency from the device tree or CNTFRQ */
+	arch_timer_rate = 19200000;
+
+	arch_timer_ppi[PHYS_SECURE_PPI]    = IRQ_ARM_LOCAL_CNTPSIRQ;
+	arch_timer_ppi[PHYS_NONSECURE_PPI] = IRQ_ARM_LOCAL_CNTPNSIRQ;
+	arch_timer_ppi[VIRT_PPI]           = IRQ_ARM_LOCAL_CNTVIRQ;
+	arch_timer_ppi[HYP_PPI]            = IRQ_ARM_LOCAL_CNTHPIRQ;
+
+	/*
+	 * If HYP mode is available, we know that the physical timer
+	 * has been configured to be accessible from PL1. Use it, so
+	 * that a guest can use the virtual timer instead.
+	 *
+	 * If no interrupt provided for virtual timer, we'll have to
+	 * stick to the physical timer. It'd better be accessible...
+	 */
+	if (is_hyp_mode_available() || !arch_timer_ppi[VIRT_PPI]) {
+		arch_timer_use_virtual = false;
+	}
+
+	arch_timer_c3stop = 0;
+
+	arch_timer_register();
+	arch_timer_common_init();
+	return 0;
+}
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -332,7 +332,7 @@ config DMA_BCM2835
 
 config DMA_BCM2708
 	tristate "BCM2708 DMA engine support"
-	depends on MACH_BCM2708
+	depends on MACH_BCM2708 || MACH_BCM2709
 	select DMA_ENGINE
 	select DMA_VIRTUAL_CHANNELS
 
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -361,7 +361,7 @@ config I2C_AXXIA
 
 config I2C_BCM2835
 	tristate "Broadcom BCM2835 I2C controller"
-	depends on ARCH_BCM2835 || ARCH_BCM2708
+	depends on ARCH_BCM2835 || ARCH_BCM2708 || ARCH_BCM2709
 	help
 	  If you say yes to this option, support will be included for the
 	  BCM2835 I2C controller.
@@ -373,7 +373,7 @@ config I2C_BCM2835
 
 config I2C_BCM2708
 	tristate "BCM2708 BSC"
-	depends on MACH_BCM2708
+	depends on MACH_BCM2708 || MACH_BCM2709
 	help
 	  Enabling this option will add BSC (Broadcom Serial Controller)
 	  support for the BCM2708. BSC is a Broadcom proprietary bus compatible
--- a/drivers/media/platform/bcm2835/Kconfig
+++ b/drivers/media/platform/bcm2835/Kconfig
@@ -2,7 +2,7 @@
 
 config VIDEO_BCM2835
 	bool "Broadcom BCM2835 camera interface driver"
-	depends on VIDEO_V4L2 && ARCH_BCM2708
+	depends on VIDEO_V4L2 && (ARCH_BCM2708 || ARCH_BCM2709)
 	---help---
 	  Say Y here to enable camera host interface devices for
 	  Broadcom BCM2835 SoC. This operates over the VCHIQ interface
--- a/drivers/misc/vc04_services/Kconfig
+++ b/drivers/misc/vc04_services/Kconfig
@@ -1,6 +1,6 @@
 config BCM2708_VCHIQ
 	tristate "Videocore VCHIQ"
-	depends on MACH_BCM2708
+	depends on MACH_BCM2708 || MACH_BCM2709
 	default y
 	help
 		Kernel to VideoCore communication interface for the
--- a/drivers/misc/vc04_services/Makefile
+++ b/drivers/misc/vc04_services/Makefile
@@ -1,5 +1,3 @@
-ifeq ($(CONFIG_MACH_BCM2708),y)
-
 obj-$(CONFIG_BCM2708_VCHIQ)	+= vchiq.o
 
 vchiq-objs := \
@@ -14,4 +12,3 @@ vchiq-objs := \
 
 ccflags-y += -DVCOS_VERIFY_BKPTS=1 -Idrivers/misc/vc04_services -DUSE_VCHIQ_ARM -D__VCCOREVER__=0x04000000
 
-endif
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -304,7 +304,7 @@ config MMC_SDHCI_ST
 
 config MMC_BCM2835
 	tristate "MMC support on BCM2835"
-	depends on MACH_BCM2708
+	depends on (MACH_BCM2708 || MACH_BCM2709)
 	help
 	  This selects the MMC Interface on BCM2835.
 
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -77,7 +77,7 @@ config SPI_ATMEL
 
 config SPI_BCM2835
 	tristate "BCM2835 SPI controller"
-	depends on ARCH_BCM2835 || ARCH_BCM2708 || COMPILE_TEST
+	depends on ARCH_BCM2835 || ARCH_BCM2708 || ARCH_BCM2709 || COMPILE_TEST
 	help
 	  This selects a driver for the Broadcom BCM2835 SPI master.
 
@@ -88,7 +88,7 @@ config SPI_BCM2835
 
 config SPI_BCM2708
 	tristate "BCM2708 SPI controller driver (SPI0)"
-	depends on MACH_BCM2708
+	depends on MACH_BCM2708 || MACH_BCM2709
 	help
 	  This selects a driver for the Broadcom BCM2708 SPI master (SPI0). This
 	  driver is not compatible with the "Universal SPI Master" or the SPI slave
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -454,7 +454,7 @@ config RETU_WATCHDOG
 
 config BCM2708_WDT
 	tristate "BCM2708 Watchdog"
-	depends on ARCH_BCM2708
+	depends on ARCH_BCM2708 || ARCH_BCM2709
 	help
 	  Enables BCM2708 watchdog support.
 
--- a/sound/arm/Kconfig
+++ b/sound/arm/Kconfig
@@ -41,7 +41,7 @@ config SND_PXA2XX_AC97
 
 config SND_BCM2835
 	tristate "BCM2835 ALSA driver"
-	depends on ARCH_BCM2708 && BCM2708_VCHIQ && SND
+	depends on (ARCH_BCM2708 || ARCH_BCM2709) && BCM2708_VCHIQ && SND
 	select SND_PCM
 	help
 	  Say Y or M if you want to support BCM2835 Alsa pcm card driver
--- a/sound/soc/bcm/Kconfig
+++ b/sound/soc/bcm/Kconfig
@@ -10,7 +10,7 @@ config SND_BCM2835_SOC_I2S
 
 config SND_BCM2708_SOC_I2S
 	tristate "SoC Audio support for the Broadcom BCM2708 I2S module"
-	depends on MACH_BCM2708
+	depends on MACH_BCM2708 || MACH_BCM2709
 	select REGMAP_MMIO
 	select SND_SOC_DMAENGINE_PCM
 	select SND_SOC_GENERIC_DMAENGINE_PCM
