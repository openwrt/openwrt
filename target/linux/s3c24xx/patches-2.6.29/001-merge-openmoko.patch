diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/include/asm/fiq.h linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/fiq.h
--- linux-2.6.29-rc3.owrt/arch/arm/include/asm/fiq.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/fiq.h	2009-05-10 22:27:59.000000000 +0200
@@ -29,8 +29,9 @@
 extern int claim_fiq(struct fiq_handler *f);
 extern void release_fiq(struct fiq_handler *f);
 extern void set_fiq_handler(void *start, unsigned int length);
-extern void set_fiq_regs(struct pt_regs *regs);
-extern void get_fiq_regs(struct pt_regs *regs);
+extern void set_fiq_c_handler(void (*handler)(void));
+extern void __attribute__((naked)) set_fiq_regs(struct pt_regs *regs);
+extern void __attribute__((naked)) get_fiq_regs(struct pt_regs *regs);
 extern void enable_fiq(int fiq);
 extern void disable_fiq(int fiq);
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/include/asm/hardware/tzic-sp890.h linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/hardware/tzic-sp890.h
--- linux-2.6.29-rc3.owrt/arch/arm/include/asm/hardware/tzic-sp890.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/hardware/tzic-sp890.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,22 @@
+#ifndef __SP890_TZIC_H__
+#define __SP890_TZIC_H__
+
+#define SP890_TZIC_UNLOCK_MAGIC (0x0ACCE550)
+
+#define SP890_TZIC_FIQSTATUS	0
+#define SP890_TZIC_RAWINTR	4
+#define SP890_TZIC_INTSELECT	8
+#define SP890_TZIC_FIQENABLE	0xc
+#define SP890_TZIC_FIQENCLEAR	0x10
+#define SP890_TZIC_FIQBYPASS	0x14
+#define SP890_TZIC_PROTECTION	0x18
+#define SP890_TZIC_LOCK		0x1c
+#define SP890_TZIC_LOCKSTATUS	0x20
+#define SP890_TZIC_ITCR		0x300
+#define SP890_TZIC_ITIP1	0x304
+#define SP890_TZIC_ITIP2	0x308
+#define SP890_TZIC_ITOP1	0x30c
+#define SP890_TZIC_ITOP2	0x310
+#define SP890_TZIC_PERIPHIDO	0xfe0
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/include/asm/irqflags.h linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/irqflags.h
--- linux-2.6.29-rc3.owrt/arch/arm/include/asm/irqflags.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/irqflags.h	2009-05-10 22:27:59.000000000 +0200
@@ -5,6 +5,16 @@
 
 #include <asm/ptrace.h>
 
+#ifdef CONFIG_FIND_IRQ_BLOCKERS
+void iblock_start(void);
+void iblock_end(void);
+void iblock_end_maybe(unsigned long flags);
+#else
+#define iblock_start()
+#define iblock_end()
+#define iblock_end_maybe(x)
+#endif
+
 /*
  * CPU interrupt mask handling.
  */
@@ -31,6 +41,7 @@
 #define raw_local_irq_save(x)					\
 	({							\
 		unsigned long temp;				\
+	iblock_start(); \
 		(void) (&temp == &x);				\
 	__asm__ __volatile__(					\
 	"mrs	%0, cpsr		@ local_irq_save\n"	\
@@ -47,6 +58,7 @@
 #define raw_local_irq_enable()					\
 	({							\
 		unsigned long temp;				\
+	 iblock_end(); \
 	__asm__ __volatile__(					\
 	"mrs	%0, cpsr		@ local_irq_enable\n"	\
 "	bic	%0, %0, #128\n"					\
@@ -62,6 +74,7 @@
 #define raw_local_irq_disable()					\
 	({							\
 		unsigned long temp;				\
+	iblock_start(); \
 	__asm__ __volatile__(					\
 	"mrs	%0, cpsr		@ local_irq_disable\n"	\
 "	orr	%0, %0, #128\n"					\
@@ -117,11 +130,12 @@
  * restore saved IRQ & FIQ state
  */
 #define raw_local_irq_restore(x)				\
+	({ iblock_end_maybe(x); \
 	__asm__ __volatile__(					\
 	"msr	cpsr_c, %0		@ local_irq_restore\n"	\
 	:							\
 	: "r" (x)						\
-	: "memory", "cc")
+	: "memory", "cc"); })
 
 #define raw_irqs_disabled_flags(flags)	\
 ({					\
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/include/asm/kexec.h linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/kexec.h
--- linux-2.6.29-rc3.owrt/arch/arm/include/asm/kexec.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/include/asm/kexec.h	2009-05-10 22:27:59.000000000 +0200
@@ -1,8 +1,6 @@
 #ifndef _ARM_KEXEC_H
 #define _ARM_KEXEC_H
 
-#ifdef CONFIG_KEXEC
-
 /* Maximum physical address we can use pages from */
 #define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)
 /* Maximum address we can reach in physical address mode */
@@ -14,6 +12,10 @@
 
 #define KEXEC_ARCH KEXEC_ARCH_ARM
 
+#define KEXEC_BOOT_PARAMS_SIZE 1536
+
+#ifdef CONFIG_KEXEC
+
 #define KEXEC_ARM_ATAGS_OFFSET  0x1000
 #define KEXEC_ARM_ZIMAGE_OFFSET 0x8000
 
@@ -29,3 +31,4 @@
 #endif /* CONFIG_KEXEC */
 
 #endif /* _ARM_KEXEC_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/Kconfig	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -1086,7 +1086,8 @@
 
 menu "CPU Power Management"
 
-if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX || ARCH_PXA)
+if (ARCH_SA1100 || ARCH_INTEGRATOR || ARCH_OMAP || ARCH_IMX || ARCH_PXA || \
+    ARCH_S3C64XX)
 
 source "drivers/cpufreq/Kconfig"
 
@@ -1126,6 +1127,10 @@
 	default y
 	select CPU_FREQ_DEFAULT_GOV_USERSPACE
 
+config CPU_FREQ_S3C64XX
+	bool "CPUfreq support for S3C64xx CPUs"
+	depends on CPU_FREQ && CPU_S3C6410
+
 endif
 
 source "drivers/cpuidle/Kconfig"
@@ -1305,6 +1310,8 @@
 
 source "drivers/uwb/Kconfig"
 
+source "drivers/ar6000/Kconfig"
+
 source "drivers/mmc/Kconfig"
 
 source "drivers/memstick/Kconfig"
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/kernel/fiq.c linux-2.6.29-rc3.owrt.om/arch/arm/kernel/fiq.c
--- linux-2.6.29-rc3.owrt/arch/arm/kernel/fiq.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/kernel/fiq.c	2009-05-10 22:27:59.000000000 +0200
@@ -8,6 +8,8 @@
  *
  *  FIQ support re-written by Russell King to be more generic
  *
+ *  FIQ handler in C supoprt written by Andy Green <andy@openmoko.com>
+ *
  * We now properly support a method by which the FIQ handlers can
  * be stacked onto the vector.  We still do not support sharing
  * the FIQ vector itself.
@@ -124,6 +126,83 @@
 	: "r" (&regs->ARM_r8), "I" (PSR_I_BIT | PSR_F_BIT | FIQ_MODE));
 }
 
+/* -------- FIQ handler in C ---------
+ *
+ * Major Caveats for using this
+ *  ---------------------------
+ *  *
+ *  * 1) it CANNOT touch any vmalloc()'d memory, only memory
+ *    that was kmalloc()'d.  Static allocations in the monolithic kernel
+ *    are kmalloc()'d so they are okay.  You can touch memory-mapped IO, but
+ *    the pointer for it has to have been stored in kmalloc'd memory.  The
+ *    reason for this is simple: every now and then Linux turns off interrupts
+ *    and reorders the paging tables.  If a FIQ happens during this time, the
+ *    virtual memory space can be partly or entirely disordered or missing.
+ *
+ * 2) Because vmalloc() is used when a module is inserted, THIS FIQ
+ *    ISR HAS TO BE IN THE MONOLITHIC KERNEL, not a module.  But the way
+ *    it is set up, you can all to enable and disable it from your module
+ *    and intercommunicate with it through struct fiq_ipc
+ *    fiq_ipc which you can define in
+ *    asm/archfiq_ipc_type.h.  The reason is the same as above, a
+ *    FIQ could happen while even the ISR is not present in virtual memory
+ *    space due to pagetables being changed at the time.
+ *
+ * 3) You can't call any Linux API code except simple macros
+ *    - understand that FIQ can come in at any time, no matter what
+ *      state of undress the kernel may privately be in, thinking it
+ *      locked the door by turning off interrupts... FIQ is an
+ *      unstoppable monster force (which is its value)
+ *    - they are not vmalloc()'d memory safe
+ *    - they might do crazy stuff like sleep: FIQ pisses fire and
+ *      is not interested in 'sleep' that the weak seem to need
+ *    - calling APIs from FIQ can re-enter un-renterable things
+ *    - summary: you cannot interoperate with linux APIs directly in the FIQ ISR
+ *
+ * If you follow these rules, it is fantastic, an extremely powerful, solid,
+ * genuine hard realtime feature.
+ */
+
+static void (*current_fiq_c_isr)(void);
+#define FIQ_C_ISR_STACK_SIZE 	256
+
+static void __attribute__((naked)) __jump_to_isr(void)
+{
+	asm __volatile__ ("mov pc, r8");
+}
+
+
+static void __attribute__((naked)) __actual_isr(void)
+{
+	asm __volatile__ (
+		"stmdb	sp!, {r0-r12, lr};"
+		"mov     fp, sp;"
+	);
+
+	current_fiq_c_isr();
+
+	asm __volatile__ (
+		"ldmia	sp!, {r0-r12, lr};"
+		"subs	pc, lr, #4;"
+	);
+}
+
+void set_fiq_c_handler(void (*isr)(void))
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof(regs));
+	regs.ARM_r8 = (unsigned long) __actual_isr;
+	regs.ARM_sp = 0xffff001c + FIQ_C_ISR_STACK_SIZE;
+
+	set_fiq_handler(__jump_to_isr, 4);
+
+	current_fiq_c_isr = isr;
+
+	set_fiq_regs(&regs);
+}
+/* -------- FIQ handler in C ---------*/
+
 int claim_fiq(struct fiq_handler *f)
 {
 	int ret = 0;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/kernel/iblock.c linux-2.6.29-rc3.owrt.om/arch/arm/kernel/iblock.c
--- linux-2.6.29-rc3.owrt/arch/arm/kernel/iblock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/kernel/iblock.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,158 @@
+/*
+ *
+ * /sys/kernel/iblock/
+ * All times are in microseconds (us).
+ *
+ * - limit
+ *   Interrupt blocking time reporting limit, in microseconds.
+ *   0 disables reporting. Auto-resets to zero after reporting.
+ *
+ * - max
+ *   Maximum blocking time recorded. Reset to zero by writing anything.
+ *
+ * - test
+ *   Force a delay with interrupts disabled.
+ *
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/irqflags.h>
+
+
+unsigned long s3c2410_gettimeoffset(void);
+
+
+static unsigned long iblock_t0;
+int iblock_limit;
+static int iblock_max;
+
+
+void iblock_start(void)
+{
+	unsigned long flags;
+
+	raw_local_save_flags(flags);
+	if (raw_irqs_disabled_flags(flags))
+		return;
+	iblock_t0 = s3c2410_gettimeoffset();
+}
+EXPORT_SYMBOL_GPL(iblock_start);
+
+void iblock_end(void)
+{
+	unsigned long flags;
+	unsigned long t, us;
+
+	raw_local_save_flags(flags);
+	if (!raw_irqs_disabled_flags(flags))
+		return;
+	if (!iblock_t0)
+		return;
+	t = s3c2410_gettimeoffset();
+	us = t-iblock_t0;
+	if (us > 40000000)
+		return;
+	if (us > iblock_max)
+		iblock_max = us;
+	if (!iblock_limit)
+		return;
+	if (us < iblock_limit)
+		return;
+//	iblock_limit = 0;
+	printk(KERN_ERR "interrupts were disabled for %lu us !\n", us);
+//	WARN_ON(1);
+}
+EXPORT_SYMBOL_GPL(iblock_end);
+
+void iblock_end_maybe(unsigned long flags)
+{
+	if (raw_irqs_disabled_flags(flags))
+		return;
+	iblock_end();
+}
+EXPORT_SYMBOL_GPL(iblock_end_maybe);
+
+static ssize_t limit_read(struct device *dev, struct device_attribute *attr,
+    char *buf)
+{
+	return sprintf(buf, "%u us\n", iblock_limit);
+}
+
+
+static ssize_t limit_write(struct device *dev, struct device_attribute *attr,
+    const char *buf, size_t count)
+{
+	unsigned long tmp;
+	char *end;
+
+	tmp = simple_strtoul(buf, &end, 0);
+	if (end == buf)
+		return -EINVAL;
+	iblock_limit = tmp;
+	return count;
+}
+
+
+static ssize_t max_read(struct device *dev, struct device_attribute *attr,
+    char *buf)
+{
+	return sprintf(buf, "%u us\n", iblock_max);
+}
+
+
+static ssize_t max_write(struct device *dev, struct device_attribute *attr,
+    const char *buf, size_t count)
+{
+	iblock_max = 0;
+	return count;
+}
+
+
+static ssize_t test_write(struct device *dev,
+    struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp, flags;
+	char *end;
+
+	tmp = simple_strtoul(buf, &end, 0);
+	if (end == buf)
+		return -EINVAL;
+	local_irq_save(flags);
+	udelay(tmp);
+	local_irq_restore(flags);
+	return count;
+}
+
+
+static DEVICE_ATTR(limit, 0644, limit_read, limit_write);
+static DEVICE_ATTR(max, 0644, max_read, max_write);
+static DEVICE_ATTR(test, 0200, NULL, test_write);
+
+
+static struct attribute *sysfs_entries[] = {
+	&dev_attr_limit.attr,
+	&dev_attr_max.attr,
+	&dev_attr_test.attr,
+	NULL
+};
+
+
+static struct attribute_group attr_group = {
+	.name	= "iblock",
+	.attrs	= sysfs_entries,
+};
+
+
+static int __devinit iblock_init(void)
+{
+	return sysfs_create_group(kernel_kobj, &attr_group);
+}
+
+
+module_init(iblock_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/kernel/irq.c linux-2.6.29-rc3.owrt.om/arch/arm/kernel/irq.c
--- linux-2.6.29-rc3.owrt/arch/arm/kernel/irq.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/kernel/irq.c	2009-05-10 22:27:59.000000000 +0200
@@ -104,6 +104,11 @@
 	.lock = SPIN_LOCK_UNLOCKED
 };
 
+#ifdef CONFIG_FIND_IRQ_BLOCKERS
+extern int iblock_limit;
+unsigned long s3c2410_gettimeoffset(void);
+#endif
+
 /*
  * do_IRQ handles all hardware IRQ's.  Decoded IRQs should not
  * come via this function.  Instead, they should provide their
@@ -112,9 +117,15 @@
 asmlinkage void __exception asm_do_IRQ(unsigned int irq, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
-
+#ifdef CONFIG_FIND_IRQ_BLOCKERS
+	unsigned long us;
+#endif
 	irq_enter();
 
+#ifdef CONFIG_FIND_IRQ_BLOCKERS
+	us = s3c2410_gettimeoffset();
+#endif
+
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
 	 * than crashing, do something sensible.
@@ -124,6 +135,12 @@
 	else
 		generic_handle_irq(irq);
 
+#ifdef CONFIG_FIND_IRQ_BLOCKERS
+	us = s3c2410_gettimeoffset() - us;
+
+	if (iblock_limit && us > iblock_limit && us < 10000000)
+		printk(KERN_ERR "asm_do_IRQ(%u): %lu us\n", irq, us);
+#endif
 	/* AT91 specific workaround */
 	irq_finish(irq);
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/kernel/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/kernel/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/kernel/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/kernel/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -44,5 +44,6 @@
 
 head-y			:= head$(MMUEXT).o
 obj-$(CONFIG_DEBUG_LL)	+= debug.o
+obj-$(CONFIG_FIND_IRQ_BLOCKERS)			+= iblock.o
 
 extra-y := $(head-y) init_task.o vmlinux.lds
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/kernel/vmlinux.lds.S linux-2.6.29-rc3.owrt.om/arch/arm/kernel/vmlinux.lds.S
--- linux-2.6.29-rc3.owrt/arch/arm/kernel/vmlinux.lds.S	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/kernel/vmlinux.lds.S	2009-05-10 22:27:59.000000000 +0200
@@ -106,6 +106,8 @@
 		*(.got)			/* Global offset table		*/
 	}
 
+	NOTES
+
 	RODATA
 
 	_etext = .;			/* End of text and rodata section */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/dma.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -17,18 +17,20 @@
 #include <linux/sysdev.h>
 #include <linux/serial_core.h>
 
+#include <mach/map.h>
 #include <mach/dma.h>
 
 #include <plat/cpu.h>
-#include <plat/dma.h>
+#include <plat/dma-plat.h>
 
 #include <plat/regs-serial.h>
 #include <mach/regs-gpio.h>
 #include <plat/regs-ac97.h>
+#include <plat/regs-dma.h>
 #include <mach/regs-mem.h>
 #include <mach/regs-lcd.h>
 #include <mach/regs-sdi.h>
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
 #include <plat/regs-spi.h>
 
 static struct s3c24xx_dma_map __initdata s3c2410_dma_mappings[] = {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/audio.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/audio.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/audio.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/audio.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/* arch/arm/mach-s3c2410/include/mach/audio.h
- *
- * Copyright (c) 2004-2005 Simtec Electronics
- *	http://www.simtec.co.uk/products/SWLINUX/
- *	Ben Dooks <ben@simtec.co.uk>
- *
- * S3C24XX - Audio platfrom_device info
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
-#ifndef __ASM_ARCH_AUDIO_H
-#define __ASM_ARCH_AUDIO_H __FILE__
-
-/* struct s3c24xx_iis_ops
- *
- * called from the s3c24xx audio core to deal with the architecture
- * or the codec's setup and control.
- *
- * the pointer to itself is passed through in case the caller wants to
- * embed this in an larger structure for easy reference to it's context.
-*/
-
-struct s3c24xx_iis_ops {
-	struct module *owner;
-
-	int	(*startup)(struct s3c24xx_iis_ops *me);
-	void	(*shutdown)(struct s3c24xx_iis_ops *me);
-	int	(*suspend)(struct s3c24xx_iis_ops *me);
-	int	(*resume)(struct s3c24xx_iis_ops *me);
-
-	int	(*open)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
-	int	(*close)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
-	int	(*prepare)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm, struct snd_pcm_runtime *rt);
-};
-
-struct s3c24xx_platdata_iis {
-	const char		*codec_clk;
-	struct s3c24xx_iis_ops	*ops;
-	int			(*match_dev)(struct device *dev);
-};
-
-#endif /* __ASM_ARCH_AUDIO_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/dma.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/dma.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/dma.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/dma.h	2009-05-10 22:27:59.000000000 +0200
@@ -3,7 +3,7 @@
  * Copyright (C) 2003,2004,2006 Simtec Electronics
  *	Ben Dooks <ben@simtec.co.uk>
  *
- * Samsung S3C241XX DMA support
+ * Samsung S3C24XX DMA support
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,8 +13,8 @@
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H __FILE__
 
+#include <plat/dma.h>
 #include <linux/sysdev.h>
-#include <mach/hardware.h>
 
 #define MAX_DMA_TRANSFER_SIZE   0x100000 /* Data Unit is half word  */
 
@@ -55,9 +55,9 @@
 
 /* we have 4 dma channels */
 #ifndef CONFIG_CPU_S3C2443
-#define S3C2410_DMA_CHANNELS		(4)
+#define S3C_DMA_CHANNELS		(4)
 #else
-#define S3C2410_DMA_CHANNELS		(6)
+#define S3C_DMA_CHANNELS		(6)
 #endif
 
 /* types */
@@ -68,7 +68,6 @@
 	S3C2410_DMA_PAUSED
 };
 
-
 /* enum s3c2410_dma_loadst
  *
  * This represents the state of the DMA engine, wrt to the loaded / running
@@ -104,32 +103,6 @@
 	S3C2410_DMALOAD_1LOADED_1RUNNING,
 };
 
-enum s3c2410_dma_buffresult {
-	S3C2410_RES_OK,
-	S3C2410_RES_ERR,
-	S3C2410_RES_ABORT
-};
-
-enum s3c2410_dmasrc {
-	S3C2410_DMASRC_HW,		/* source is memory */
-	S3C2410_DMASRC_MEM		/* source is hardware */
-};
-
-/* enum s3c2410_chan_op
- *
- * operation codes passed to the DMA code by the user, and also used
- * to inform the current channel owner of any changes to the system state
-*/
-
-enum s3c2410_chan_op {
-	S3C2410_DMAOP_START,
-	S3C2410_DMAOP_STOP,
-	S3C2410_DMAOP_PAUSE,
-	S3C2410_DMAOP_RESUME,
-	S3C2410_DMAOP_FLUSH,
-	S3C2410_DMAOP_TIMEOUT,		/* internal signal to handler */
-	S3C2410_DMAOP_STARTED,		/* indicate channel started */
-};
 
 /* flags */
 
@@ -137,19 +110,18 @@
 					    * waiting for reloads */
 #define S3C2410_DMAF_AUTOSTART    (1<<1)   /* auto-start if buffer queued */
 
+#define S3C2410_DMAF_CIRCULAR	  (0x00)   /* circular enqueue not supp. */
+
 /* dma buffer */
 
-struct s3c2410_dma_client {
-	char                *name;
-};
+struct s3c2410_dma_buf;
 
-/* s3c2410_dma_buf_s
+/* s3c2410_dma_buf
  *
  * internally used buffer structure to describe a queued or running
  * buffer.
 */
 
-struct s3c2410_dma_buf;
 struct s3c2410_dma_buf {
 	struct s3c2410_dma_buf	*next;
 	int			 magic;		/* magic */
@@ -161,20 +133,6 @@
 
 /* [1] is this updated for both recv/send modes? */
 
-struct s3c2410_dma_chan;
-
-/* s3c2410_dma_cbfn_t
- *
- * buffer callback routine type
-*/
-
-typedef void (*s3c2410_dma_cbfn_t)(struct s3c2410_dma_chan *,
-				   void *buf, int size,
-				   enum s3c2410_dma_buffresult result);
-
-typedef int  (*s3c2410_dma_opfn_t)(struct s3c2410_dma_chan *,
-				   enum s3c2410_chan_op );
-
 struct s3c2410_dma_stats {
 	unsigned long		loads;
 	unsigned long		timeout_longest;
@@ -206,10 +164,10 @@
 
 	/* channel configuration */
 	enum s3c2410_dmasrc	 source;
+	enum dma_ch		 req_ch;
 	unsigned long		 dev_addr;
 	unsigned long		 load_timeout;
 	unsigned int		 flags;		/* channel flags */
-	unsigned int		 hw_cfg;	/* last hw config */
 
 	struct s3c24xx_dma_map	*map;		/* channel hw maps */
 
@@ -236,213 +194,12 @@
 	struct sys_device	dev;
 };
 
-/* the currently allocated channel information */
-extern struct s3c2410_dma_chan s3c2410_chans[];
-
-/* note, we don't really use dma_device_t at the moment */
 typedef unsigned long dma_device_t;
 
-/* functions --------------------------------------------------------------- */
-
-/* s3c2410_dma_request
- *
- * request a dma channel exclusivley
-*/
-
-extern int s3c2410_dma_request(unsigned int channel,
-			       struct s3c2410_dma_client *, void *dev);
-
-
-/* s3c2410_dma_ctrl
- *
- * change the state of the dma channel
-*/
-
-extern int s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op);
-
-/* s3c2410_dma_setflags
- *
- * set the channel's flags to a given state
-*/
-
-extern int s3c2410_dma_setflags(unsigned int channel,
-				unsigned int flags);
-
-/* s3c2410_dma_free
- *
- * free the dma channel (will also abort any outstanding operations)
-*/
-
-extern int s3c2410_dma_free(unsigned int channel, struct s3c2410_dma_client *);
-
-/* s3c2410_dma_enqueue
- *
- * place the given buffer onto the queue of operations for the channel.
- * The buffer must be allocated from dma coherent memory, or the Dcache/WB
- * drained before the buffer is given to the DMA system.
-*/
-
-extern int s3c2410_dma_enqueue(unsigned int channel, void *id,
-			       dma_addr_t data, int size);
-
-/* s3c2410_dma_config
- *
- * configure the dma channel
-*/
-
-extern int s3c2410_dma_config(unsigned int channel, int xferunit, int dcon);
-
-/* s3c2410_dma_devconfig
- *
- * configure the device we're talking to
-*/
-
-extern int s3c2410_dma_devconfig(int channel, enum s3c2410_dmasrc source,
-				 int hwcfg, unsigned long devaddr);
-
-/* s3c2410_dma_getposition
- *
- * get the position that the dma transfer is currently at
-*/
-
-extern int s3c2410_dma_getposition(unsigned int channel,
-				   dma_addr_t *src, dma_addr_t *dest);
-
-extern int s3c2410_dma_set_opfn(unsigned int, s3c2410_dma_opfn_t rtn);
-extern int s3c2410_dma_set_buffdone_fn(unsigned int, s3c2410_dma_cbfn_t rtn);
-
-/* DMA Register definitions */
-
-#define S3C2410_DMA_DISRC       (0x00)
-#define S3C2410_DMA_DISRCC      (0x04)
-#define S3C2410_DMA_DIDST       (0x08)
-#define S3C2410_DMA_DIDSTC      (0x0C)
-#define S3C2410_DMA_DCON        (0x10)
-#define S3C2410_DMA_DSTAT       (0x14)
-#define S3C2410_DMA_DCSRC       (0x18)
-#define S3C2410_DMA_DCDST       (0x1C)
-#define S3C2410_DMA_DMASKTRIG   (0x20)
-#define S3C2412_DMA_DMAREQSEL	(0x24)
-#define S3C2443_DMA_DMAREQSEL	(0x24)
-
-#define S3C2410_DISRCC_INC	(1<<0)
-#define S3C2410_DISRCC_APB	(1<<1)
-
-#define S3C2410_DMASKTRIG_STOP   (1<<2)
-#define S3C2410_DMASKTRIG_ON     (1<<1)
-#define S3C2410_DMASKTRIG_SWTRIG (1<<0)
-
-#define S3C2410_DCON_DEMAND     (0<<31)
-#define S3C2410_DCON_HANDSHAKE  (1<<31)
-#define S3C2410_DCON_SYNC_PCLK  (0<<30)
-#define S3C2410_DCON_SYNC_HCLK  (1<<30)
-
-#define S3C2410_DCON_INTREQ     (1<<29)
-
-#define S3C2410_DCON_CH0_XDREQ0	(0<<24)
-#define S3C2410_DCON_CH0_UART0	(1<<24)
-#define S3C2410_DCON_CH0_SDI	(2<<24)
-#define S3C2410_DCON_CH0_TIMER	(3<<24)
-#define S3C2410_DCON_CH0_USBEP1	(4<<24)
-
-#define S3C2410_DCON_CH1_XDREQ1	(0<<24)
-#define S3C2410_DCON_CH1_UART1	(1<<24)
-#define S3C2410_DCON_CH1_I2SSDI	(2<<24)
-#define S3C2410_DCON_CH1_SPI	(3<<24)
-#define S3C2410_DCON_CH1_USBEP2	(4<<24)
-
-#define S3C2410_DCON_CH2_I2SSDO	(0<<24)
-#define S3C2410_DCON_CH2_I2SSDI	(1<<24)
-#define S3C2410_DCON_CH2_SDI	(2<<24)
-#define S3C2410_DCON_CH2_TIMER	(3<<24)
-#define S3C2410_DCON_CH2_USBEP3	(4<<24)
-
-#define S3C2410_DCON_CH3_UART2	(0<<24)
-#define S3C2410_DCON_CH3_SDI	(1<<24)
-#define S3C2410_DCON_CH3_SPI	(2<<24)
-#define S3C2410_DCON_CH3_TIMER	(3<<24)
-#define S3C2410_DCON_CH3_USBEP4	(4<<24)
-
-#define S3C2410_DCON_SRCSHIFT   (24)
-#define S3C2410_DCON_SRCMASK	(7<<24)
-
-#define S3C2410_DCON_BYTE       (0<<20)
-#define S3C2410_DCON_HALFWORD   (1<<20)
-#define S3C2410_DCON_WORD       (2<<20)
-
-#define S3C2410_DCON_AUTORELOAD (0<<22)
-#define S3C2410_DCON_NORELOAD   (1<<22)
-#define S3C2410_DCON_HWTRIG     (1<<23)
-
-#ifdef CONFIG_CPU_S3C2440
-#define S3C2440_DIDSTC_CHKINT	(1<<2)
-
-#define S3C2440_DCON_CH0_I2SSDO	(5<<24)
-#define S3C2440_DCON_CH0_PCMIN	(6<<24)
-
-#define S3C2440_DCON_CH1_PCMOUT	(5<<24)
-#define S3C2440_DCON_CH1_SDI	(6<<24)
-
-#define S3C2440_DCON_CH2_PCMIN	(5<<24)
-#define S3C2440_DCON_CH2_MICIN	(6<<24)
-
-#define S3C2440_DCON_CH3_MICIN	(5<<24)
-#define S3C2440_DCON_CH3_PCMOUT	(6<<24)
-#endif
-
-#ifdef CONFIG_CPU_S3C2412
-
-#define S3C2412_DMAREQSEL_SRC(x)	((x)<<1)
-
-#define S3C2412_DMAREQSEL_HW		(1)
-
-#define S3C2412_DMAREQSEL_SPI0TX	S3C2412_DMAREQSEL_SRC(0)
-#define S3C2412_DMAREQSEL_SPI0RX	S3C2412_DMAREQSEL_SRC(1)
-#define S3C2412_DMAREQSEL_SPI1TX	S3C2412_DMAREQSEL_SRC(2)
-#define S3C2412_DMAREQSEL_SPI1RX	S3C2412_DMAREQSEL_SRC(3)
-#define S3C2412_DMAREQSEL_I2STX		S3C2412_DMAREQSEL_SRC(4)
-#define S3C2412_DMAREQSEL_I2SRX		S3C2412_DMAREQSEL_SRC(5)
-#define S3C2412_DMAREQSEL_TIMER		S3C2412_DMAREQSEL_SRC(9)
-#define S3C2412_DMAREQSEL_SDI		S3C2412_DMAREQSEL_SRC(10)
-#define S3C2412_DMAREQSEL_USBEP1	S3C2412_DMAREQSEL_SRC(13)
-#define S3C2412_DMAREQSEL_USBEP2	S3C2412_DMAREQSEL_SRC(14)
-#define S3C2412_DMAREQSEL_USBEP3	S3C2412_DMAREQSEL_SRC(15)
-#define S3C2412_DMAREQSEL_USBEP4	S3C2412_DMAREQSEL_SRC(16)
-#define S3C2412_DMAREQSEL_XDREQ0	S3C2412_DMAREQSEL_SRC(17)
-#define S3C2412_DMAREQSEL_XDREQ1	S3C2412_DMAREQSEL_SRC(18)
-#define S3C2412_DMAREQSEL_UART0_0	S3C2412_DMAREQSEL_SRC(19)
-#define S3C2412_DMAREQSEL_UART0_1	S3C2412_DMAREQSEL_SRC(20)
-#define S3C2412_DMAREQSEL_UART1_0	S3C2412_DMAREQSEL_SRC(21)
-#define S3C2412_DMAREQSEL_UART1_1	S3C2412_DMAREQSEL_SRC(22)
-#define S3C2412_DMAREQSEL_UART2_0	S3C2412_DMAREQSEL_SRC(23)
-#define S3C2412_DMAREQSEL_UART2_1	S3C2412_DMAREQSEL_SRC(24)
-
-#endif
-
-#define S3C2443_DMAREQSEL_SRC(x)	((x)<<1)
-
-#define S3C2443_DMAREQSEL_HW		(1)
 
-#define S3C2443_DMAREQSEL_SPI0TX	S3C2443_DMAREQSEL_SRC(0)
-#define S3C2443_DMAREQSEL_SPI0RX	S3C2443_DMAREQSEL_SRC(1)
-#define S3C2443_DMAREQSEL_SPI1TX	S3C2443_DMAREQSEL_SRC(2)
-#define S3C2443_DMAREQSEL_SPI1RX	S3C2443_DMAREQSEL_SRC(3)
-#define S3C2443_DMAREQSEL_I2STX		S3C2443_DMAREQSEL_SRC(4)
-#define S3C2443_DMAREQSEL_I2SRX		S3C2443_DMAREQSEL_SRC(5)
-#define S3C2443_DMAREQSEL_TIMER		S3C2443_DMAREQSEL_SRC(9)
-#define S3C2443_DMAREQSEL_SDI		S3C2443_DMAREQSEL_SRC(10)
-#define S3C2443_DMAREQSEL_XDREQ0	S3C2443_DMAREQSEL_SRC(17)
-#define S3C2443_DMAREQSEL_XDREQ1	S3C2443_DMAREQSEL_SRC(18)
-#define S3C2443_DMAREQSEL_UART0_0	S3C2443_DMAREQSEL_SRC(19)
-#define S3C2443_DMAREQSEL_UART0_1	S3C2443_DMAREQSEL_SRC(20)
-#define S3C2443_DMAREQSEL_UART1_0	S3C2443_DMAREQSEL_SRC(21)
-#define S3C2443_DMAREQSEL_UART1_1	S3C2443_DMAREQSEL_SRC(22)
-#define S3C2443_DMAREQSEL_UART2_0	S3C2443_DMAREQSEL_SRC(23)
-#define S3C2443_DMAREQSEL_UART2_1	S3C2443_DMAREQSEL_SRC(24)
-#define S3C2443_DMAREQSEL_UART3_0	S3C2443_DMAREQSEL_SRC(25)
-#define S3C2443_DMAREQSEL_UART3_1	S3C2443_DMAREQSEL_SRC(26)
-#define S3C2443_DMAREQSEL_PCMOUT	S3C2443_DMAREQSEL_SRC(27)
-#define S3C2443_DMAREQSEL_PCMIN 	S3C2443_DMAREQSEL_SRC(28)
-#define S3C2443_DMAREQSEL_MICIN		S3C2443_DMAREQSEL_SRC(29)
+static int s3c_dma_has_circular(void)
+{
+	return 0;
+}
 
 #endif /* __ASM_ARCH_DMA_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gpio-core.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gpio-core.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gpio-core.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gpio-core.h	2009-05-10 22:27:59.000000000 +0200
@@ -15,20 +15,7 @@
 #ifndef __ASM_ARCH_GPIO_CORE_H
 #define __ASM_ARCH_GPIO_CORE_H __FILE__
 
+/* currently we just include the platform support */
 #include <plat/gpio-core.h>
-#include <mach/regs-gpio.h>
-
-extern struct s3c_gpio_chip s3c24xx_gpios[];
-
-static inline struct s3c_gpio_chip *s3c_gpiolib_getchip(unsigned int pin)
-{
-	struct s3c_gpio_chip *chip;
-
-	if (pin > S3C2410_GPG10)
-		return NULL;
-
-	chip = &s3c24xx_gpios[pin/32];
-	return (S3C2410_GPIO_OFFSET(pin) > chip->chip.ngpio) ? chip : NULL;
-}
 
 #endif /* __ASM_ARCH_GPIO_CORE_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gpio.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gpio.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gpio.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gpio.h	2009-05-10 22:27:59.000000000 +0200
@@ -22,4 +22,13 @@
 
 #define ARCH_NR_GPIOS	(256 + CONFIG_S3C24XX_GPIO_EXTRA)
 
+/* These two defines should be removed as soon as the
+ * generic irq handling makes it upstream */
+#include <mach/hardware.h>
+#define irq_to_gpio(irq)                s3c2410_gpio_irq2pin(irq)
+/* -- cut to here when generic irq makes it */
+
 #include <asm-generic/gpio.h>
+#include <mach/gpio-nrs.h>
+
+#define S3C_GPIO_END	(S3C2410_GPIO_BANKH + 32)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gpio-nrs.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gpio-nrs.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gpio-nrs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gpio-nrs.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,23 @@
+/* arch/arm/mach-s3c2410/include/mach/gpio-nrs.h
+ *
+ * Copyright (c) 2008 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - GPIO bank numbering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#define S3C2410_GPIONO(bank,offset) ((bank) + (offset))
+
+#define S3C2410_GPIO_BANKA   (32*0)
+#define S3C2410_GPIO_BANKB   (32*1)
+#define S3C2410_GPIO_BANKC   (32*2)
+#define S3C2410_GPIO_BANKD   (32*3)
+#define S3C2410_GPIO_BANKE   (32*4)
+#define S3C2410_GPIO_BANKF   (32*5)
+#define S3C2410_GPIO_BANKG   (32*6)
+#define S3C2410_GPIO_BANKH   (32*7)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gta01.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gta01.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gta01.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gta01.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,76 @@
+#ifndef _GTA01_H
+#define _GTA01_H
+
+#include <mach/regs-gpio.h>
+#include <mach/irqs.h>
+
+/* Different hardware revisions, passed in ATAG_REVISION by u-boot */
+#define GTA01v3_SYSTEM_REV	0x00000130
+#define GTA01v4_SYSTEM_REV	0x00000140
+#define GTA01Bv2_SYSTEM_REV	0x00000220
+#define GTA01Bv3_SYSTEM_REV	0x00000230
+#define GTA01Bv4_SYSTEM_REV	0x00000240
+
+/* Backlight */
+
+extern void gta01bl_deferred_resume(void);
+
+struct gta01bl_machinfo {
+	unsigned int default_intensity;
+	unsigned int max_intensity;
+	unsigned int limit_mask;
+	unsigned int defer_resume_backlight;
+};
+
+/* Definitions common to all revisions */
+#define GTA01_GPIO_BACKLIGHT	S3C2410_GPB0
+#define GTA01_GPIO_GPS_PWRON	S3C2410_GPB1
+#define GTA01_GPIO_MODEM_RST	S3C2410_GPB6
+#define GTA01_GPIO_MODEM_ON	S3C2410_GPB7
+#define GTA01_GPIO_LCD_RESET	S3C2410_GPC6
+#define GTA01_GPIO_PMU_IRQ	S3C2410_GPG8
+#define GTA01_GPIO_JACK_INSERT	S3C2410_GPF4
+#define GTA01_GPIO_nSD_DETECT	S3C2410_GPF5
+#define GTA01_GPIO_AUX_KEY	S3C2410_GPF6
+#define GTA01_GPIO_HOLD_KEY	S3C2410_GPF7
+#define GTA01_GPIO_VIBRATOR_ON	S3C2410_GPG11
+
+#define GTA01_IRQ_MODEM		IRQ_EINT1
+#define GTA01_IRQ_JACK_INSERT	IRQ_EINT4
+#define GTA01_IRQ_nSD_DETECT	IRQ_EINT5
+#define GTA01_IRQ_AUX_KEY	IRQ_EINT6
+#define GTA01_IRQ_PCF50606      IRQ_EINT16
+
+/* GTA01v3 */
+#define GTA01v3_GPIO_nGSM_EN	S3C2410_GPG9
+
+/* GTA01v4 */
+#define GTA01_GPIO_MODEM_DNLOAD	S3C2410_GPG0
+
+/* GTA01Bv2 */
+#define GTA01Bv2_GPIO_nGSM_EN	S3C2410_GPF2
+#define GTA01Bv2_GPIO_VIBRATOR_ON S3C2410_GPB10
+
+/* GTA01Bv3 */
+#define GTA01_GPIO_GPS_EN_3V3	S3C2410_GPG9
+
+#define GTA01_GPIO_SDMMC_ON	S3C2410_GPB2
+#define GTA01_GPIO_BT_EN	S3C2410_GPB5
+#define GTA01_GPIO_AB_DETECT	S3C2410_GPB8
+#define GTA01_GPIO_USB_PULLUP	S3C2410_GPB9
+#define GTA01_GPIO_USB_ATTACH	S3C2410_GPB10
+
+#define GTA01_GPIO_GPS_EN_2V8	S3C2410_GPG9
+#define GTA01_GPIO_GPS_EN_3V	S3C2410_GPG10
+#define GTA01_GPIO_GPS_RESET	S3C2410_GPC0
+
+/* GTA01Bv4 */
+#define GTA01Bv4_GPIO_nNAND_WP	S3C2410_GPA16
+#define GTA01Bv4_GPIO_VIBRATOR_ON S3C2410_GPB3
+#define GTA01Bv4_GPIO_PMU_IRQ	S3C2410_GPG1
+
+#define GTA01Bv4_IRQ_PCF50606	IRQ_EINT9
+
+extern struct pcf50606 *gta01_pcf;
+
+#endif /* _GTA01_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gta02-pm-wlan.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gta02-pm-wlan.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/gta02-pm-wlan.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/gta02-pm-wlan.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef __MACH_GTA02_PM_WLAN_H
+#define __MACH_GTA02_PM_WLAN_H
+
+void gta02_wlan_reset(int assert_reset);
+int gta02_wlan_query_rfkill_lock(void);
+void gta02_wlan_query_rfkill_unlock(void);
+void gta02_wlan_set_rfkill_cb(int (*cb)(void *user, int on), void *user);
+void gta02_wlan_clear_rfkill_cb(void);
+
+#endif /* __MACH_GTA02_PM_WLAN_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/hardware.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/hardware.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/hardware.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/hardware.h	2009-05-10 22:27:59.000000000 +0200
@@ -131,7 +131,4 @@
 
 /* machine specific hardware definitions should go after this */
 
-/* currently here until moved into config (todo) */
-#define CONFIG_NO_MULTIWORD_IO
-
 #endif /* __ASM_ARCH_HARDWARE_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/io.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/io.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/io.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/io.h	2009-05-10 22:27:59.000000000 +0200
@@ -9,7 +9,7 @@
 #ifndef __ASM_ARM_ARCH_IO_H
 #define __ASM_ARM_ARCH_IO_H
 
-#include <mach/hardware.h>
+#include <mach/map.h>
 
 #define IO_SPACE_LIMIT 0xffffffff
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/irqs.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/irqs.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/irqs.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/irqs.h	2009-05-10 22:27:59.000000000 +0200
@@ -80,7 +80,7 @@
 #define IRQ_EINT22     S3C2410_IRQ(50)
 #define IRQ_EINT23     S3C2410_IRQ(51)
 
-
+#define IRQ_EINT_BIT(x)	((x) - IRQ_EINT4 + 4)
 #define IRQ_EINT(x)    (((x) >= 4) ? (IRQ_EINT4 + (x) - 4) : (IRQ_EINT0 + (x)))
 
 #define IRQ_LCD_FIFO   S3C2410_IRQ(52)
@@ -153,9 +153,9 @@
 #define IRQ_S3C2443_AC97	S3C2410_IRQSUB(28)
 
 #ifdef CONFIG_CPU_S3C2443
-#define NR_IRQS (IRQ_S3C2443_AC97+1)
+#define _NR_IRQS (IRQ_S3C2443_AC97+1)
 #else
-#define NR_IRQS (IRQ_S3C2440_AC97+1)
+#define _NR_IRQS (IRQ_S3C2440_AC97+1)
 #endif
 
 /* compatibility define. */
@@ -167,4 +167,33 @@
 /* Our FIQs are routable from IRQ_EINT0 to IRQ_ADCPARENT */
 #define FIQ_START		IRQ_EINT0
 
+
+/*
+ * The next 16 interrupts are for board specific purposes.  Since
+ * the kernel can only run on one machine at a time, we can re-use
+ * these.  If you need more, increase IRQ_BOARD_END, but keep it
+ * within sensible limits.
+ */
+#define IRQ_BOARD_START         _NR_IRQS
+#define IRQ_BOARD_END           (_NR_IRQS + 10)
+
+#if defined(CONFIG_MACH_NEO1973_GTA02)
+#define NR_IRQS                 (IRQ_BOARD_END)
+#else
+#define NR_IRQS                 (IRQ_BOARD_START)
+#endif
+
+/* Neo1973 GTA02 interrupts */
+#define NEO1973_GTA02_IRQ(x)    (IRQ_BOARD_START + (x))
+#define IRQ_GLAMO(x)            NEO1973_GTA02_IRQ(x)
+#define IRQ_GLAMO_HOSTBUS       IRQ_GLAMO(0)
+#define IRQ_GLAMO_JPEG          IRQ_GLAMO(1)
+#define IRQ_GLAMO_MPEG          IRQ_GLAMO(2)
+#define IRQ_GLAMO_MPROC1        IRQ_GLAMO(3)
+#define IRQ_GLAMO_MPROC0        IRQ_GLAMO(4)
+#define IRQ_GLAMO_CMDQUEUE      IRQ_GLAMO(5)
+#define IRQ_GLAMO_2D            IRQ_GLAMO(6)
+#define IRQ_GLAMO_MMC           IRQ_GLAMO(7)
+#define IRQ_GLAMO_RISC          IRQ_GLAMO(8)
+
 #endif /* __ASM_ARCH_IRQ_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/map.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/map.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/map.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/map.h	2009-05-10 22:27:59.000000000 +0200
@@ -84,7 +84,6 @@
 
 #define S3C24XX_PA_IRQ      S3C2410_PA_IRQ
 #define S3C24XX_PA_MEMCTRL  S3C2410_PA_MEMCTRL
-#define S3C24XX_PA_USBHOST  S3C2410_PA_USBHOST
 #define S3C24XX_PA_DMA      S3C2410_PA_DMA
 #define S3C24XX_PA_CLKPWR   S3C2410_PA_CLKPWR
 #define S3C24XX_PA_LCD      S3C2410_PA_LCD
@@ -102,6 +101,7 @@
 
 #define S3C_PA_IIC          S3C2410_PA_IIC
 #define S3C_PA_UART	    S3C24XX_PA_UART
+#define S3C_PA_USBHOST	S3C2410_PA_USBHOST
 #define S3C_PA_HSMMC0	    S3C2443_PA_HSMMC
 
 #endif /* __ASM_ARCH_MAP_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/mci.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/mci.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/mci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/mci.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef _ARCH_MCI_H
+#define _ARCH_MCI_H
+
+struct s3c24xx_mci_pdata {
+	unsigned int	gpio_detect;
+	unsigned int	gpio_wprotect;
+	unsigned long	ocr_avail;
+	unsigned int	do_dma;
+	void		(*set_power)(unsigned char power_mode,
+				     unsigned short vdd);
+};
+
+#endif /* _ARCH_NCI_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/neo1973-pm-gsm.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/neo1973-pm-gsm.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/neo1973-pm-gsm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/neo1973-pm-gsm.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1 @@
+extern int gta_gsm_interrupts;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/regs-gpio.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/regs-gpio.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/regs-gpio.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/regs-gpio.h	2009-05-10 22:27:59.000000000 +0200
@@ -14,16 +14,7 @@
 #ifndef __ASM_ARCH_REGS_GPIO_H
 #define __ASM_ARCH_REGS_GPIO_H
 
-#define S3C2410_GPIONO(bank,offset) ((bank) + (offset))
-
-#define S3C2410_GPIO_BANKA   (32*0)
-#define S3C2410_GPIO_BANKB   (32*1)
-#define S3C2410_GPIO_BANKC   (32*2)
-#define S3C2410_GPIO_BANKD   (32*3)
-#define S3C2410_GPIO_BANKE   (32*4)
-#define S3C2410_GPIO_BANKF   (32*5)
-#define S3C2410_GPIO_BANKG   (32*6)
-#define S3C2410_GPIO_BANKH   (32*7)
+#include <mach/gpio-nrs.h>
 
 #ifdef CONFIG_CPU_S3C2400
 #define S3C24XX_GPIO_BASE(x)  S3C2400_GPIO_BASE(x)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/regs-sdi.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/regs-sdi.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/regs-sdi.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/regs-sdi.h	2009-05-10 22:27:59.000000000 +0200
@@ -30,6 +30,7 @@
 #define S3C2410_SDIFSTA               (0x38)
 
 #define S3C2410_SDIDATA               (0x3C)
+#define S3C2410_SDIDATA_BYTE          (0x3C)
 #define S3C2410_SDIIMSK               (0x40)
 
 #define S3C2440_SDIDATA               (0x40)
@@ -37,6 +38,8 @@
 
 #define S3C2440_SDICON_SDRESET        (1<<8)
 #define S3C2440_SDICON_MMCCLOCK       (1<<5)
+#define S3C2440_SDIDATA_BYTE          (0x48)
+
 #define S3C2410_SDICON_BYTEORDER      (1<<4)
 #define S3C2410_SDICON_SDIOIRQ        (1<<3)
 #define S3C2410_SDICON_RWAITEN        (1<<2)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/s3c24xx-serial.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/s3c24xx-serial.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/s3c24xx-serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/s3c24xx-serial.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,5 @@
+#include <linux/resume-dependency.h>
+
+extern void s3c24xx_serial_console_set_silence(int silence);
+extern void s3c24xx_serial_register_resume_dependency(struct resume_dependency *
+					     resume_dependency, int uart_index);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/spi-gpio.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/spi-gpio.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/spi-gpio.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/spi-gpio.h	2009-05-10 22:27:59.000000000 +0200
@@ -21,7 +21,8 @@
 	int			 num_chipselect;
 	int			 bus_num;
 
-	void (*chip_select)(struct s3c2410_spigpio_info *spi, int cs);
+	int			 non_blocking_transfer;
+	void (*chip_select)(struct s3c2410_spigpio_info *spi, int csid, int cs);
 };
 
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/ts.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/ts.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/ts.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/ts.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,35 @@
+/* arch/arm/mach-s3c2410/include/mach/ts.h
+ *
+ * Copyright (c) 2005 Arnaud Patard <arnaud.patard@rtp-net.org>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ *  Changelog:
+ *     24-Mar-2005     RTP     Created file
+ *     03-Aug-2005     RTP     Renamed to ts.h
+ */
+
+#ifndef __ASM_ARM_TS_H
+#define __ASM_ARM_TS_H
+
+#include <../drivers/input/touchscreen/ts_filter.h>
+
+struct s3c2410_ts_mach_info {
+	/* Touchscreen delay. */
+	int delay;
+	/* Prescaler value. */
+	int presc;
+	/*
+	 * Null-terminated array of pointers to filter APIs and configurations
+	 * we want to use. In the same order they will be applied.
+	 */
+	const struct ts_filter_chain_configuration *filter_config;
+};
+
+void set_s3c2410ts_info(const struct s3c2410_ts_mach_info *hard_s3c2410ts_info);
+
+#endif /* __ASM_ARM_TS_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/usb-control.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/usb-control.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/include/mach/usb-control.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/include/mach/usb-control.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-/* arch/arm/mach-s3c2410/include/mach/usb-control.h
- *
- * Copyright (c) 2004 Simtec Electronics
- *	Ben Dooks <ben@simtec.co.uk>
- *
- * S3C2410 - usb port information
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
-#ifndef __ASM_ARCH_USBCONTROL_H
-#define __ASM_ARCH_USBCONTROL_H "arch/arm/mach-s3c2410/include/mach/usb-control.h"
-
-#define S3C_HCDFLG_USED	(1)
-
-struct s3c2410_hcd_port {
-	unsigned char	flags;
-	unsigned char	power;
-	unsigned char	oc_status;
-	unsigned char	oc_changed;
-};
-
-struct s3c2410_hcd_info {
-	struct usb_hcd		*hcd;
-	struct s3c2410_hcd_port	port[2];
-
-	void		(*power_control)(int port, int to);
-	void		(*enable_oc)(struct s3c2410_hcd_info *, int on);
-	void		(*report_oc)(struct s3c2410_hcd_info *, int ports);
-};
-
-static void inline s3c2410_usb_report_oc(struct s3c2410_hcd_info *info, int ports)
-{
-	if (info->report_oc != NULL) {
-		(info->report_oc)(info, ports);
-	}
-}
-
-#endif /*__ASM_ARCH_USBCONTROL_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/Kconfig	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -10,6 +10,7 @@
 	select CPU_ARM920T
 	select S3C2410_CLOCK
 	select S3C2410_GPIO
+	select S3C_PWM
 	select CPU_LLSERIAL_S3C2410
 	select S3C2410_PM if PM
 	help
@@ -45,6 +46,7 @@
 	  Internal node for machines with an BAST style IDE
 	  interface
 
+
 menu "S3C2410 Machines"
 
 config ARCH_SMDK2410
@@ -59,6 +61,7 @@
 	bool "IPAQ H1940"
 	select CPU_S3C2410
 	select PM_H1940 if PM
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the HP IPAQ H1940
 
@@ -70,6 +73,7 @@
 config MACH_N30
 	bool "Acer N30 family"
 	select CPU_S3C2410
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you want suppt for the Acer N30, Acer N35,
 	  Navman PiN570, Yakumo AlphaX or Airis NC05 PDAs.
@@ -82,6 +86,7 @@
 	select MACH_BAST_IDE
 	select S3C24XX_DCLK
 	select ISA
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the Simtec Electronics EB2410ITX
 	  development board (also known as BAST)
@@ -89,6 +94,7 @@
 config MACH_OTOM
  	bool "NexVision OTOM Board"
  	select CPU_S3C2410
+	select S3C_DEV_USB_HOST
 	help
  	  Say Y here if you are using the Nex Vision OTOM board
 
@@ -96,6 +102,7 @@
 	bool "AML M5900 Series"
 	select CPU_S3C2410
 	select PM_SIMTEC if PM
+	select S3C_DEV_USB_HOST
 	help
 	   Say Y here if you are using the American Microsystems M5900 Series
            <http://www.amltd.com>
@@ -111,6 +118,7 @@
 config MACH_TCT_HAMMER
 	bool "TCT Hammer Board"
 	select CPU_S3C2410
+	select S3C_DEV_USB_HOST
 	help
 	   Say Y here if you are using the TinCanTools Hammer Board
            <http://www.tincantools.com>
@@ -128,7 +136,27 @@
 config MACH_QT2410
 	bool "QT2410"
 	select CPU_S3C2410
+	select DISPLAY_JBT6K74
 	help
 	   Say Y here if you are using the Armzone QT2410
 
+config MACH_NEO1973_GTA01
+	bool "FIC Neo1973 GSM Phone (GTA01 Hardware)"
+	select CPU_S3C2410
+	select MACH_NEO1973
+	select S3C_DEV_USB_HOST
+	select MFD_PCF50606
+	select INPUT_PCF50606_PMU
+	select PCF50606_ADC
+	select PCF50606_GPIO
+	select RTC_DRV_PCF50606
+	select REGULATOR_PCF50606
+	select CHARGER_PCF50606
+	select PCF50606_WATCHDOG
+	select POWER_SUPPLY
+	select BATTERY_GTA01
+
+	help
+	   Say Y here if you are using the FIC Neo1973 GSM Phone
+
 endmenu
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/mach-gta01.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/mach-gta01.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/mach-gta01.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/mach-gta01.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1008 @@
+/*
+ * linux/arch/arm/mach-s3c2410/mach-gta01.c
+ *
+ * S3C2410 Machine Support for the FIC Neo1973 GTA01
+ *
+ * Copyright (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/serial_core.h>
+#include <mach/ts.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/mmc/host.h>
+
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/mfd/pcf50606/pmic.h>
+#include <linux/mfd/pcf50606/mbc.h>
+#include <linux/mfd/pcf50606/adc.h>
+
+#include <linux/gta01_battery.h>
+
+#include <linux/regulator/machine.h>
+#include <linux/regulator/consumer.h>
+
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/fb.h>
+#include <mach/spi.h>
+#include <mach/spi-gpio.h>
+#include <mach/cpu.h>
+
+#include <mach/gta01.h>
+
+#include <plat/regs-serial.h>
+#include <plat/nand.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <plat/pm.h>
+#include <plat/udc.h>
+#include <plat/iic.h>
+#include <plat/mci.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+#include <plat/usb-control.h>
+#include <mach/neo1973-pm-gsm.h>
+
+#include <linux/jbt6k74.h>
+
+#include <../drivers/input/touchscreen/ts_filter_chain.h>
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+#include <../drivers/input/touchscreen/ts_filter_linear.h>
+#include <../drivers/input/touchscreen/ts_filter_mean.h>
+#include <../drivers/input/touchscreen/ts_filter_median.h>
+#include <../drivers/input/touchscreen/ts_filter_group.h>
+#endif
+
+
+static struct map_desc gta01_iodesc[] __initdata = {
+	{
+		.virtual	= 0xe0000000,
+		.pfn		= __phys_to_pfn(S3C2410_CS3+0x01000000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+};
+
+#define UCON S3C2410_UCON_DEFAULT
+#define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
+#define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
+/* UFCON for the gta01 sets the FIFO trigger level at 4, not 8 */
+#define UFCON_GTA01_PORT0 S3C2410_UFCON_FIFOMODE
+
+static struct s3c2410_uartcfg gta01_uartcfgs[] = {
+	[0] = {
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON_GTA01_PORT0,
+	},
+	[1] = {
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+};
+
+/* TODO */
+static void gta01_pmu_event_callback(struct pcf50606 *pcf, int irq)
+{
+	/*TODO : Handle ACD here */
+}
+
+/* FIXME : Goes away when ACD is handled above */
+#if 0 
+static int pmu_callback(struct device *dev, unsigned int feature,
+			enum pmu_event event)
+{
+	switch (feature) {
+	case PCF50606_FEAT_ACD:
+		switch (event) {
+		case PMU_EVT_INSERT:
+			pcf50606_charge_fast(pcf50606_global, 1);
+			break;
+		case PMU_EVT_REMOVE:
+			pcf50606_charge_fast(pcf50606_global, 0);
+			break;
+		default:
+			break;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+struct pcf50606 *gta01_pcf;
+
+static struct platform_device gta01_pm_gsm_dev = {
+	.name		= "neo1973-pm-gsm",
+};
+
+static struct platform_device gta01_pm_bt_dev = {
+	.name		= "neo1973-pm-bt",
+};
+static struct platform_device gta01_pm_gps_dev = {
+	.name		= "neo1973-pm-gps",
+};
+
+static struct regulator_consumer_supply ioreg_consumers[] = {
+	{
+		.dev = &gta01_pm_gps_dev.dev,
+		.supply = "GPS_2V8",
+	},
+};
+
+static struct regulator_consumer_supply d1reg_consumers[] = {
+	{
+		.dev = &gta01_pm_gps_dev.dev,
+		.supply = "GPS_3V",
+	},
+	{
+		.dev = &gta01_pm_bt_dev.dev,
+		.supply = "BT_3V1",
+	},
+};
+
+static struct regulator_consumer_supply dcd_consumers[] = {
+	{
+		.dev = &gta01_pm_gps_dev.dev,
+		.supply = "GPS_3V3",
+	},
+	{
+		.dev = &gta01_pm_gps_dev.dev,
+		.supply = "GPS_1V5",
+	},
+};
+
+static struct regulator_consumer_supply d2reg_consumers[] = {
+	{
+		.dev = &gta01_pm_gps_dev.dev,
+		.supply = "GPS_2V5",
+	},
+	{
+		.dev = &s3c_device_sdi.dev,
+		.supply = "SD_3V3",
+	},
+};
+
+static int gta01_bat_get_charging_status(void)
+{
+	struct pcf50606 *pcf = gta01_pcf;
+	u8 mbcc1, chgmod;
+
+	mbcc1 = pcf50606_reg_read(pcf, PCF50606_REG_MBCC1);
+	chgmod = mbcc1 & PCF50606_MBCC1_CHGMOD_MASK;
+
+	if (chgmod == PCF50606_MBCC1_CHGMOD_IDLE)
+		return 0;
+	else
+		return 1;
+}
+
+static int gta01_bat_get_voltage(void)
+{
+	struct pcf50606 *pcf = gta01_pcf;
+	u16 adc, mv = 0;
+
+	adc = pcf50606_adc_sync_read(pcf, PCF50606_ADCMUX_BATVOLT_RES);
+	mv = (adc * 6000) / 1024;
+	
+	return mv;
+}
+
+static int gta01_bat_get_current(void)
+{
+	struct pcf50606 *pcf = gta01_pcf;
+	u16 adc_battvolt, adc_adcin1;
+	s32 res;
+	
+	adc_battvolt = pcf50606_adc_sync_read(pcf, PCF50606_ADCMUX_BATVOLT_SUBTR);
+	adc_adcin1 = pcf50606_adc_sync_read(pcf, PCF50606_ADCMUX_ADCIN1_SUBTR);
+	res = (adc_adcin1 - adc_battvolt) * 2400;
+
+	/*rsense is 220 milli */
+	return (res * 1000) / (220 * 1024);
+}
+
+static struct gta01_bat_platform_data gta01_bat_pdata = {
+	.get_charging_status = gta01_bat_get_charging_status,
+	.get_voltage = gta01_bat_get_voltage,
+	.get_current = gta01_bat_get_current,
+};
+
+struct platform_device gta01_bat = {
+	.name = "gta01_battery",
+	.id = -1,
+	.dev = {
+		.platform_data = &gta01_bat_pdata,
+	}
+};
+
+static void gta01_pcf_probe_done(struct pcf50606 *pcf)
+{
+	gta01_pcf = pcf;
+	gta01_bat.dev.parent = pcf->dev;
+	platform_device_register(&gta01_bat);
+}
+
+static int gps_registered_regulators = 0;
+
+static void gta01_pmu_regulator_registered(struct pcf50606 *pcf, int id)
+{
+	switch(id) {
+		case PCF50606_REGULATOR_D1REG:
+			platform_device_register(&gta01_pm_bt_dev);
+			gps_registered_regulators++;
+			break;
+		case PCF50606_REGULATOR_D2REG:
+			gps_registered_regulators++;
+			break;
+		case PCF50606_REGULATOR_IOREG:
+		case PCF50606_REGULATOR_DCD:
+			gps_registered_regulators++;
+			break;
+	}
+
+	/* All GPS related regulators registered ? */
+	if (gps_registered_regulators == 4)
+		platform_device_register(&gta01_pm_gps_dev);
+			
+}
+
+static struct pcf50606_platform_data gta01_pcf_pdata = {
+	.resumers = {
+			[0] = 	PCF50606_INT1_ALARM |
+				PCF50606_INT1_ONKEYF |
+				PCF50606_INT1_EXTONR,
+			[1] = 	PCF50606_INT2_CHGWD10S |
+				PCF50606_INT2_CHGPROT |
+				PCF50606_INT2_CHGERR,
+			[2] =	PCF50606_INT3_LOWBAT |
+				PCF50606_INT3_HIGHTMP |
+				PCF50606_INT3_ACDINS,
+	},
+	.mbc_event_callback = gta01_pmu_event_callback,
+	.reg_init_data = {
+		[PCF50606_REGULATOR_D1REG] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3150000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = ARRAY_SIZE(d1reg_consumers),
+			.consumer_supplies = d1reg_consumers,
+		},
+		
+		[PCF50606_REGULATOR_D2REG] = {
+			.constraints = {
+				.min_uV = 1650000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = ARRAY_SIZE(d2reg_consumers),
+			.consumer_supplies = d2reg_consumers,
+
+		},
+
+		[PCF50606_REGULATOR_D3REG] = {
+			.constraints = {
+				.min_uV = 1800000,
+				.max_uV = 2100000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+
+		[PCF50606_REGULATOR_DCD] = {
+			.constraints = {
+				.min_uV = 1500000,
+				.max_uV = 1500000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = ARRAY_SIZE(dcd_consumers),
+			.consumer_supplies = dcd_consumers,
+		},
+
+		[PCF50606_REGULATOR_DCDE] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+
+		[PCF50606_REGULATOR_DCUD] = {
+			.constraints = {
+				.min_uV = 2100000,
+				.max_uV = 2100000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+		
+		[PCF50606_REGULATOR_IOREG] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = ARRAY_SIZE(ioreg_consumers),
+			.consumer_supplies = ioreg_consumers,
+
+		},
+		
+		[PCF50606_REGULATOR_LPREG] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+	},
+	.probe_done = gta01_pcf_probe_done,
+	.regulator_registered = gta01_pmu_regulator_registered,
+};
+
+static void cfg_pmu_vrail(struct regulator_init_data *vrail,
+			  unsigned int suspend_on, unsigned int min,
+			  unsigned int max)
+{
+	vrail->constraints.state_mem.enabled = suspend_on;
+	vrail->constraints.min_uV = min;
+	vrail->constraints.max_uV = min;
+	vrail->constraints.apply_uV = 1;
+}
+
+static void mangle_pmu_pdata_by_system_rev(void)
+{
+	struct regulator_init_data *reg_init_data;
+
+	reg_init_data = gta01_pcf_pdata.reg_init_data;
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01Bv4_SYSTEM_REV:
+
+		/* FIXME : gta01_pcf_pdata.used_features |= PCF50606_FEAT_ACD; */
+		break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+		reg_init_data[PCF50606_REGULATOR_D3REG].constraints.state_mem.enabled = 1;
+		break;
+	case GTA01v4_SYSTEM_REV:
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_DCUD],
+			      1, 18000000, 1800000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_D1REG],
+			      0, 3000000, 3000000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_D3REG],
+			      0, 2800000, 2800000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_DCD],
+			      0, 3500000, 3500000);
+		break;
+	case GTA01v3_SYSTEM_REV:
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_D1REG],
+			      0, 3000000, 3000000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_D2REG],
+			      0, 3300000, 3300000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_D3REG],
+			      0, 3300000, 3300000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_DCD],
+			      0, 3300000, 3300000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_DCUD],
+			      1, 1800000, 1800000);
+		cfg_pmu_vrail(&reg_init_data[PCF50606_REGULATOR_IOREG],
+			      0, 2800000, 2800000);
+		break;
+	}
+}
+
+static void gta01_power_off(void)
+{
+	pcf50606_reg_write(gta01_pcf, PCF50606_REG_OOCC1,
+			PCF50606_OOCC1_GOSTDBY);
+}
+
+/* LCD driver info */
+
+/* Configuration for 480x640 toppoly TD028TTEC1.
+ * Do not mark this as __initdata or it will break! */
+static struct s3c2410fb_display gta01_displays[] =  {
+	{
+		.type		= S3C2410_LCDCON1_TFT,
+		.width		= 43,
+		.height		= 58,
+		.xres		= 480,
+		.yres		= 640,
+		.bpp		= 16,
+
+		.pixclock	= 40000,	/* HCLK/4 */
+		.left_margin	= 104,
+		.right_margin	= 8,
+		.hsync_len	= 8,
+		.upper_margin	= 2,
+		.lower_margin	= 16,
+		.vsync_len	= 2,
+		.lcdcon5	= S3C2410_LCDCON5_FRM565 |
+				  S3C2410_LCDCON5_INVVCLK |
+				  S3C2410_LCDCON5_INVVLINE |
+				  S3C2410_LCDCON5_INVVFRAME |
+				  S3C2410_LCDCON5_PWREN |
+				  S3C2410_LCDCON5_HWSWP,
+	},
+	{
+		.type		= S3C2410_LCDCON1_TFT,
+		.width		= 43,
+		.height		= 58,
+		.xres		= 480,
+		.yres		= 640,
+		.bpp		= 32,
+
+		.pixclock	= 40000,	/* HCLK/4 */
+		.left_margin	= 104,
+		.right_margin	= 8,
+		.hsync_len	= 8,
+		.upper_margin	= 2,
+		.lower_margin	= 16,
+		.vsync_len	= 2,
+		.lcdcon5	= S3C2410_LCDCON5_FRM565 |
+				  S3C2410_LCDCON5_INVVCLK |
+				  S3C2410_LCDCON5_INVVLINE |
+				  S3C2410_LCDCON5_INVVFRAME |
+				  S3C2410_LCDCON5_PWREN |
+				  S3C2410_LCDCON5_HWSWP,
+	},
+	{
+		.type		= S3C2410_LCDCON1_TFT,
+		.width		= 43,
+		.height		= 58,
+		.xres		= 240,
+		.yres		= 320,
+		.bpp		= 16,
+
+		.pixclock	= 40000,	/* HCLK/4 */
+		.left_margin	= 104,
+		.right_margin	= 8,
+		.hsync_len	= 8,
+		.upper_margin	= 2,
+		.lower_margin	= 16,
+		.vsync_len	= 2,
+		.lcdcon5	= S3C2410_LCDCON5_FRM565 |
+				  S3C2410_LCDCON5_INVVCLK |
+				  S3C2410_LCDCON5_INVVLINE |
+				  S3C2410_LCDCON5_INVVFRAME |
+				  S3C2410_LCDCON5_PWREN |
+				  S3C2410_LCDCON5_HWSWP,
+	},
+};
+
+static struct s3c2410fb_mach_info gta01_lcd_cfg __initdata = {
+	.displays	= gta01_displays,
+	.num_displays	= ARRAY_SIZE(gta01_displays),
+	.default_display = 0,
+
+	.lpcsel		= ((0xCE6) & ~7) | 1<<4,
+};
+
+static struct platform_device *gta01_devices[] __initdata = {
+	&s3c_device_usb,
+	&s3c_device_lcd,
+	&s3c_device_wdt,
+	&s3c_device_i2c0,
+	&s3c_device_iis,
+	&s3c_device_sdi,
+	&s3c_device_usbgadget,
+	&s3c_device_nand,
+	&s3c_device_ts,
+};
+
+static struct s3c2410_nand_set gta01_nand_sets[] = {
+	[0] = {
+		.name		= "neo1973-nand",
+		.nr_chips	= 1,
+		.flags		= S3C2410_NAND_BBT,
+	},
+};
+
+static struct s3c2410_platform_nand gta01_nand_info = {
+	.tacls		= 20,
+	.twrph0		= 60,
+	.twrph1		= 20,
+	.nr_sets	= ARRAY_SIZE(gta01_nand_sets),
+	.sets		= gta01_nand_sets,
+};
+
+static struct regulator *s3c_sdi_regulator;
+
+static void gta01_mmc_set_power(unsigned char power_mode, unsigned short vdd)
+{
+	int bit;
+	int mv = 1700; /* 1.7V for MMC_VDD_165_195 */
+	struct regulator *regulator;
+
+	printk(KERN_DEBUG "mmc_set_power(power_mode=%u, vdd=%u)\n",
+	       power_mode, vdd);
+
+	if (!s3c_sdi_regulator) {
+		s3c_sdi_regulator =
+		       	regulator_get(&s3c_device_sdi.dev, "SD_3V3");
+		if (!s3c_sdi_regulator) {
+			printk(KERN_ERR "gta01_mmc_set_power : Cannot get regulator");
+			return;
+		}
+	}
+
+	regulator = s3c_sdi_regulator;
+
+		return;
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+		switch (power_mode) {
+		case MMC_POWER_OFF:
+			regulator_disable(regulator);
+			break;
+		case MMC_POWER_ON:
+			/* translate MMC_VDD_* VDD bit to mv */
+			for (bit = 8; bit != 24; bit++)
+				if (vdd == (1 << bit))
+					mv += 100 * (bit - 4);
+			regulator_set_voltage(regulator, mv * 1000, mv * 10000);
+			break;
+		case MMC_POWER_UP:
+			regulator_enable(regulator);
+			break;
+		}
+		break;
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		switch (power_mode) {
+		case MMC_POWER_OFF:
+			neo1973_gpb_setpin(GTA01_GPIO_SDMMC_ON, 1);
+			break;
+		case MMC_POWER_ON:
+			neo1973_gpb_setpin(GTA01_GPIO_SDMMC_ON, 0);
+			break;
+		}
+		break;
+	}
+	
+	if (regulator)
+		regulator_put(regulator);
+}
+
+static struct s3c24xx_mci_pdata gta01_mmc_cfg = {
+	.gpio_detect	= GTA01_GPIO_nSD_DETECT,
+	.set_power	= &gta01_mmc_set_power,	
+	.ocr_avail	= MMC_VDD_165_195|MMC_VDD_20_21|
+			  MMC_VDD_21_22|MMC_VDD_22_23|MMC_VDD_23_24|
+			  MMC_VDD_24_25|MMC_VDD_25_26|MMC_VDD_26_27|
+			  MMC_VDD_27_28|MMC_VDD_28_29|MMC_VDD_29_30|
+			  MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33,
+};
+
+static void gta01_udc_command(enum s3c2410_udc_cmd_e cmd)
+{
+	printk(KERN_DEBUG "%s(%d)\n", __func__, cmd);
+
+	switch (cmd) {
+	case S3C2410_UDC_P_ENABLE:
+		neo1973_gpb_setpin(GTA01_GPIO_USB_PULLUP, 1);
+		break;
+	case S3C2410_UDC_P_DISABLE:
+		neo1973_gpb_setpin(GTA01_GPIO_USB_PULLUP, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+/* use a work queue, since I2C API inherently schedules
+ * and we get called in hardirq context from UDC driver */
+
+struct vbus_draw {
+	struct work_struct work;
+	int ma;
+};
+static struct vbus_draw gta01_udc_vbus_drawer;
+
+static void __gta01_udc_vbus_draw(struct work_struct *work)
+{
+	/*
+	 * This is a fix to work around boot-time ordering problems if the
+	 * s3c2410_udc is initialized before the pcf50606 driver has defined
+	 * pcf50606_global
+	 */
+	if (!gta01_pcf)
+		return;
+
+	if (gta01_udc_vbus_drawer.ma >= 500) {
+		/* enable fast charge */
+		printk(KERN_DEBUG "udc: enabling fast charge\n");
+		pcf50606_charge_fast(gta01_pcf, 1);
+	} else {
+		/* disable fast charge */
+		printk(KERN_DEBUG "udc: disabling fast charge\n");
+		pcf50606_charge_fast(gta01_pcf, 0);
+	}
+}
+
+static void gta01_udc_vbus_draw(unsigned int ma)
+{
+	gta01_udc_vbus_drawer.ma = ma;
+	schedule_work(&gta01_udc_vbus_drawer.work);
+}
+
+static struct s3c2410_udc_mach_info gta01_udc_cfg = {
+	.vbus_draw	= gta01_udc_vbus_draw,
+};
+
+/* Touchscreen configuration. */
+
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+const static struct ts_filter_group_configuration gta01_ts_group = {
+	.length = 12,
+	.close_enough = 10,
+	.threshold = 6,		/* At least half of the points in a group. */
+	.attempts = 10,
+};
+
+const static struct ts_filter_median_configuration gta01_ts_median = {
+	.extent = 20,
+	.decimation_below = 3,
+	.decimation_threshold = 8 * 3,
+	.decimation_above = 4,
+};
+
+const static struct ts_filter_mean_configuration gta01_ts_mean = {
+	.length = 4,
+};
+
+const static struct ts_filter_linear_configuration gta01_ts_linear = {
+	.constants = {1, 0, 0, 0, 1, 0, 1},	/* Don't modify coords. */
+	.coord0 = 0,
+	.coord1 = 1,
+};
+#endif
+
+const static struct ts_filter_chain_configuration gta01_filter_configuration[] =
+{
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+	{&ts_filter_group_api,		&gta01_ts_group.config},
+	{&ts_filter_median_api,		&gta01_ts_median.config},
+	{&ts_filter_mean_api,		&gta01_ts_mean.config},
+	{&ts_filter_linear_api,		&gta01_ts_linear.config},
+#endif
+	{NULL, NULL},
+};
+
+const static struct s3c2410_ts_mach_info gta01_ts_cfg = {
+	.delay = 10000,
+	.presc = 0xff, /* slow as we can go */
+	.filter_config = gta01_filter_configuration,
+};
+
+/* SPI */
+
+static void gta01_jbt6k74_reset(int devidx, int level)
+{
+	/* empty place holder; gta01 does not yet use this */
+	printk(KERN_DEBUG "gta01_jbt6k74_reset\n");
+}
+
+static void gta01_jbt6k74_resuming(int devidx)
+{
+	gta01bl_deferred_resume();
+}
+
+const struct jbt6k74_platform_data gta01_jbt6k74_pdata = {
+	.reset		= gta01_jbt6k74_reset,
+	.resuming	= gta01_jbt6k74_resuming,
+};
+
+static struct spi_board_info gta01_spi_board_info[] = {
+	{
+		.modalias	= "jbt6k74",
+		.platform_data	= &gta01_jbt6k74_pdata,
+		/* controller_data */
+		/* irq */
+		.max_speed_hz	= 10 * 1000 * 1000,
+		.bus_num	= 1,
+		/* chip_select */
+	},
+};
+
+static void spi_gpio_cs(struct s3c2410_spigpio_info *spi, int csidx, int cs)
+{
+	switch (cs) {
+	case BITBANG_CS_ACTIVE:
+		s3c2410_gpio_setpin(S3C2410_GPG3, 0);
+		break;
+	case BITBANG_CS_INACTIVE:
+		s3c2410_gpio_setpin(S3C2410_GPG3, 1);
+		break;
+	}
+}
+
+static struct s3c2410_spigpio_info spi_gpio_cfg = {
+	.pin_clk	= S3C2410_GPG7,
+	.pin_mosi	= S3C2410_GPG6,
+	.pin_miso	= S3C2410_GPG5,
+	.chip_select	= &spi_gpio_cs,
+	.num_chipselect = 2,   /*** Should be 1 or 2 for gta01? ***/
+};
+
+static struct resource s3c_spi_lcm_resource[] = {
+	[0] = {
+		.start = S3C2410_GPG3,
+		.end   = S3C2410_GPG3,
+	},
+	[1] = {
+		.start = S3C2410_GPG5,
+		.end   = S3C2410_GPG5,
+	},
+	[2] = {
+		.start = S3C2410_GPG6,
+		.end   = S3C2410_GPG6,
+	},
+	[3] = {
+		.start = S3C2410_GPG7,
+		.end   = S3C2410_GPG7,
+	},
+};
+
+struct platform_device s3c_device_spi_lcm = {
+	.name		  = "spi_s3c24xx_gpio",
+	.id		  = 1,
+	.num_resources	  = ARRAY_SIZE(s3c_spi_lcm_resource),
+	.resource	  = s3c_spi_lcm_resource,
+	.dev = {
+		.platform_data = &spi_gpio_cfg,
+	},
+};
+
+static struct gta01bl_machinfo backlight_machinfo = {
+	.default_intensity	= 1,
+	.max_intensity		= 1,
+	.limit_mask		= 1,
+	.defer_resume_backlight	= 1,
+};
+
+static struct resource gta01_bl_resources[] = {
+	[0] = {
+		.start	= GTA01_GPIO_BACKLIGHT,
+		.end	= GTA01_GPIO_BACKLIGHT,
+	},
+};
+
+struct platform_device gta01_bl_dev = {
+	.name 		= "gta01-bl",
+	.num_resources	= ARRAY_SIZE(gta01_bl_resources),
+	.resource	= gta01_bl_resources,
+	.dev		= {
+		.platform_data = &backlight_machinfo,
+	},
+};
+
+static struct resource gta01_led_resources[] = {
+	[0] = {
+		.start	= GTA01_GPIO_VIBRATOR_ON,
+		.end	= GTA01_GPIO_VIBRATOR_ON,
+	},
+};
+
+struct platform_device gta01_led_dev = {
+	.name		= "neo1973-vibrator",
+	.num_resources	= ARRAY_SIZE(gta01_led_resources),
+	.resource	= gta01_led_resources,
+};
+
+static struct resource gta01_button_resources[] = {
+	[0] = {
+		.start = GTA01_GPIO_AUX_KEY,
+		.end   = GTA01_GPIO_AUX_KEY,
+	},
+	[1] = {
+		.start = GTA01_GPIO_HOLD_KEY,
+		.end   = GTA01_GPIO_HOLD_KEY,
+	},
+	[2] = {
+		.start = GTA01_GPIO_JACK_INSERT,
+		.end   = GTA01_GPIO_JACK_INSERT,
+	},
+};
+
+struct platform_device gta01_button_dev = {
+	.name		= "neo1973-button",
+	.num_resources	= ARRAY_SIZE(gta01_button_resources),
+	.resource	= gta01_button_resources,
+};
+
+/* USB */
+static struct s3c2410_hcd_info gta01_usb_info = {
+	.port[0]	= {
+		.flags	= S3C_HCDFLG_USED,
+	},
+	.port[1]	= {
+		.flags	= 0,
+	},
+};
+
+static void __init gta01_map_io(void)
+{
+	s3c24xx_init_io(gta01_iodesc, ARRAY_SIZE(gta01_iodesc));
+	s3c24xx_init_clocks(12*1000*1000);
+	s3c24xx_init_uarts(gta01_uartcfgs, ARRAY_SIZE(gta01_uartcfgs));
+}
+
+static irqreturn_t gta01_modem_irq(int irq, void *param)
+{
+	printk(KERN_DEBUG "GSM wakeup interrupt (IRQ %d)\n", irq);
+	gta_gsm_interrupts++;
+	return IRQ_HANDLED;
+}
+
+static struct i2c_board_info gta01_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf50606", 0x08),
+		.irq = GTA01_IRQ_PCF50606,
+		.platform_data = &gta01_pcf_pdata,
+	},
+	{
+		I2C_BOARD_INFO("lm4857", 0x7c),
+	},
+	{
+		I2C_BOARD_INFO("wm8753", 0x1a),
+	},
+};
+
+static void __init gta01_machine_init(void)
+{
+	int rc;
+
+	if (S3C_SYSTEM_REV_ATAG == GTA01v4_SYSTEM_REV ||
+	    S3C_SYSTEM_REV_ATAG == GTA01Bv2_SYSTEM_REV ||
+	    S3C_SYSTEM_REV_ATAG == GTA01Bv3_SYSTEM_REV ||
+	    S3C_SYSTEM_REV_ATAG == GTA01Bv4_SYSTEM_REV) {
+		gta01_udc_cfg.udc_command = gta01_udc_command;
+		gta01_mmc_cfg.ocr_avail = MMC_VDD_32_33;
+	}
+
+	s3c_device_usb.dev.platform_data = &gta01_usb_info;
+	s3c_device_nand.dev.platform_data = &gta01_nand_info;
+	s3c_device_sdi.dev.platform_data = &gta01_mmc_cfg;
+
+	s3c24xx_fb_set_platdata(&gta01_lcd_cfg);
+
+	INIT_WORK(&gta01_udc_vbus_drawer.work, __gta01_udc_vbus_draw);
+	s3c24xx_udc_set_platdata(&gta01_udc_cfg);
+	s3c_i2c0_set_platdata(NULL);
+	set_s3c2410ts_info(&gta01_ts_cfg);
+
+	/* Set LCD_RESET / XRES to high */
+	s3c2410_gpio_cfgpin(S3C2410_GPC6, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_setpin(S3C2410_GPC6, 1);
+
+	/* SPI chip select is gpio output */
+	s3c2410_gpio_cfgpin(S3C2410_GPG3, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_setpin(S3C2410_GPG3, 1);
+	platform_device_register(&s3c_device_spi_lcm);
+
+	platform_device_register(&gta01_bl_dev);
+	platform_device_register(&gta01_button_dev);
+	platform_device_register(&gta01_pm_gsm_dev);
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+		/* just use the default (GTA01_IRQ_PCF50606) */
+		break;
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+		/* just use the default (GTA01_IRQ_PCF50606) */
+		gta01_led_resources[0].start =
+			gta01_led_resources[0].end = GTA01Bv2_GPIO_VIBRATOR_ON;
+		break;
+	case GTA01Bv4_SYSTEM_REV:
+		gta01_i2c_devs[0].irq =	 GTA01Bv4_IRQ_PCF50606;
+		gta01_led_resources[0].start =
+			gta01_led_resources[0].end = GTA01Bv4_GPIO_VIBRATOR_ON;
+		break;
+	}
+	mangle_pmu_pdata_by_system_rev();
+	i2c_register_board_info(0, gta01_i2c_devs, ARRAY_SIZE(gta01_i2c_devs));
+	spi_register_board_info(gta01_spi_board_info, ARRAY_SIZE(gta01_spi_board_info));
+	
+	platform_device_register(&gta01_led_dev);
+
+	platform_add_devices(gta01_devices, ARRAY_SIZE(gta01_devices));
+
+	s3c_pm_init();
+
+	set_irq_type(GTA01_IRQ_MODEM, IRQ_TYPE_EDGE_RISING);
+	rc = request_irq(GTA01_IRQ_MODEM, gta01_modem_irq, IRQF_DISABLED,
+			 "modem", NULL);
+	enable_irq_wake(GTA01_IRQ_MODEM);
+	printk(KERN_DEBUG  "Enabled GSM wakeup IRQ %d (rc=%d)\n",
+	       GTA01_IRQ_MODEM, rc);
+
+	pm_power_off = &gta01_power_off;
+}
+
+MACHINE_START(NEO1973_GTA01, "GTA01")
+	.phys_io	= S3C2410_PA_UART,
+	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
+	.boot_params	= S3C2410_SDRAM_PA + 0x100,
+	.map_io		= gta01_map_io,
+	.init_irq	= s3c24xx_init_irq,
+	.init_machine	= gta01_machine_init,
+	.timer		= &s3c24xx_timer,
+MACHINE_END
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/mach-h1940.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/mach-h1940.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/mach-h1940.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/mach-h1940.c	2009-05-10 22:27:59.000000000 +0200
@@ -131,6 +131,11 @@
 	.vbus_pin_inverted	= 1,
 };
 
+static struct s3c2410_ts_mach_info h1940_ts_cfg __initdata = {
+		.delay = 10000,
+		.presc = 49,
+		.oversampling_shift = 2,
+};
 
 /**
  * Set lcd on or off
@@ -188,6 +193,7 @@
 	&s3c_device_i2c0,
 	&s3c_device_iis,
 	&s3c_device_usbgadget,
+	&s3c_device_ts,
 	&s3c_device_leds,
 	&s3c_device_bluetooth,
 };
@@ -203,7 +209,7 @@
 #ifdef CONFIG_PM_H1940
 	memcpy(phys_to_virt(H1940_SUSPEND_RESUMEAT), h1940_pm_return, 1024);
 #endif
-	s3c2410_pm_init();
+	s3c_pm_init();
 }
 
 static void __init h1940_init_irq(void)
@@ -216,6 +222,7 @@
 	u32 tmp;
 
 	s3c24xx_fb_set_platdata(&h1940_fb_info);
+	set_s3c2410ts_info(&h1940_ts_cfg);
  	s3c24xx_udc_set_platdata(&h1940_udc_cfg);
 	s3c_i2c0_set_platdata(NULL);
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/mach-qt2410.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/mach-qt2410.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/mach-qt2410.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/mach-qt2410.c	2009-05-10 22:27:59.000000000 +0200
@@ -1,6 +1,6 @@
 /* linux/arch/arm/mach-s3c2410/mach-qt2410.c
  *
- * Copyright (C) 2006 by OpenMoko, Inc.
+ * Copyright (C) 2006 by Openmoko, Inc.
  * Author: Harald Welte <laforge@openmoko.org>
  * All rights reserved.
  *
@@ -214,7 +214,7 @@
 
 /* SPI */
 
-static void spi_gpio_cs(struct s3c2410_spigpio_info *spi, int cs)
+static void spi_gpio_cs(struct s3c2410_spigpio_info *spi, int csidx, int cs)
 {
 	switch (cs) {
 	case BITBANG_CS_ACTIVE:
@@ -321,6 +321,24 @@
 
 __setup("tft=", qt2410_tft_setup);
 
+static struct resource qt2410_button_resources[] = {
+	[0] = {
+		.start = S3C2410_GPF0,
+		.end   = S3C2410_GPF0,
+	},
+	[1] = {
+		.start = S3C2410_GPF2,
+		.end   = S3C2410_GPF2,
+	},
+};
+
+struct platform_device qt2410_button_dev = {
+	.name		="qt2410-button",
+	.num_resources	= ARRAY_SIZE(qt2410_button_resources),
+	.resource	= qt2410_button_resources,
+};
+
+
 static void __init qt2410_map_io(void)
 {
 	s3c24xx_init_io(qt2410_iodesc, ARRAY_SIZE(qt2410_iodesc));
@@ -355,7 +373,7 @@
 	s3c2410_gpio_cfgpin(S3C2410_GPB5, S3C2410_GPIO_OUTPUT);
 
 	platform_add_devices(qt2410_devices, ARRAY_SIZE(qt2410_devices));
-	s3c2410_pm_init();
+	s3c_pm_init();
 }
 
 MACHINE_START(QT2410, "QT2410")
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -15,6 +15,7 @@
 obj-$(CONFIG_CPU_S3C2410_DMA)	+= dma.o
 obj-$(CONFIG_S3C2410_PM)	+= pm.o sleep.o
 obj-$(CONFIG_S3C2410_GPIO)	+= gpio.o
+#obj-$(CONFIG_S3C2410_CLOCK)	+= clock.o
 
 # Machine support
 
@@ -37,3 +38,5 @@
 # machine additions
 
 obj-$(CONFIG_MACH_BAST_IDE)	+= bast-ide.o
+obj-$(CONFIG_MACH_NEO1973_GTA01)+= mach-gta01.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/pm.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2410/pm.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2410/pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -37,21 +37,14 @@
 #include <plat/cpu.h>
 #include <plat/pm.h>
 
-#ifdef CONFIG_S3C2410_PM_DEBUG
-extern void pm_dbg(const char *fmt, ...);
-#define DBG(fmt...) pm_dbg(fmt)
-#else
-#define DBG(fmt...) printk(KERN_DEBUG fmt)
-#endif
-
 static void s3c2410_pm_prepare(void)
 {
 	/* ensure at least GSTATUS3 has the resume address */
 
-	__raw_writel(virt_to_phys(s3c2410_cpu_resume), S3C2410_GSTATUS3);
+	__raw_writel(virt_to_phys(s3c_cpu_resume), S3C2410_GSTATUS3);
 
-	DBG("GSTATUS3 0x%08x\n", __raw_readl(S3C2410_GSTATUS3));
-	DBG("GSTATUS4 0x%08x\n", __raw_readl(S3C2410_GSTATUS4));
+	S3C_PMDBG("GSTATUS3 0x%08x\n", __raw_readl(S3C2410_GSTATUS3));
+	S3C_PMDBG("GSTATUS4 0x%08x\n", __raw_readl(S3C2410_GSTATUS4));
 
 	if (machine_is_h1940()) {
 		void *base = phys_to_virt(H1940_SUSPEND_CHECK);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/dma.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -20,17 +20,18 @@
 
 #include <mach/dma.h>
 
-#include <plat/dma.h>
+#include <plat/dma-plat.h>
 #include <plat/cpu.h>
 
 #include <plat/regs-serial.h>
 #include <mach/regs-gpio.h>
 #include <plat/regs-ac97.h>
+#include <plat/regs-dma.h>
 #include <mach/regs-mem.h>
 #include <mach/regs-lcd.h>
 #include <mach/regs-sdi.h>
-#include <asm/plat-s3c24xx/regs-s3c2412-iis.h>
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-s3c2412-iis.h>
+#include <plat/regs-iis.h>
 #include <plat/regs-spi.h>
 
 #define MAP(x) { (x)| DMA_CH_VALID, (x)| DMA_CH_VALID, (x)| DMA_CH_VALID, (x)| DMA_CH_VALID }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/Kconfig	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -38,6 +38,7 @@
 config MACH_JIVE
 	bool "Logitech Jive"
 	select CPU_S3C2412
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the Logitech Jive.
 
@@ -50,6 +51,7 @@
 	select CPU_S3C2412
 	select MACH_S3C2413
 	select MACH_SMDK
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using an SMDK2413
 
@@ -72,6 +74,7 @@
 config MACH_VSTMS
 	bool "VMSTMS"
 	select CPU_S3C2412
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using an VSTMS board
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/mach-jive.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/mach-jive.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/mach-jive.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/mach-jive.c	2009-05-10 22:27:59.000000000 +0200
@@ -494,7 +494,7 @@
 	 * correct address to resume from. */
 
 	__raw_writel(0x2BED, S3C2412_INFORM0);
-	__raw_writel(virt_to_phys(s3c2410_cpu_resume), S3C2412_INFORM1);
+	__raw_writel(virt_to_phys(s3c_cpu_resume), S3C2412_INFORM1);
 
 	return 0;
 }
@@ -630,7 +630,7 @@
 
 	/* initialise the power management now we've setup everything. */
 
-	s3c2410_pm_init();
+	s3c_pm_init();
 
 	s3c_device_nand.dev.platform_data = &jive_nand_info;
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/pm.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/pm.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -85,7 +85,7 @@
 
 static int s3c2412_pm_suspend(struct sys_device *dev, pm_message_t state)
 {
-	s3c2410_pm_do_save(s3c2412_sleep, ARRAY_SIZE(s3c2412_sleep));
+	s3c_pm_do_save(s3c2412_sleep, ARRAY_SIZE(s3c2412_sleep));
 	return 0;
 }
 
@@ -98,7 +98,7 @@
 	tmp |=  S3C2412_PWRCFG_STANDBYWFI_IDLE;
 	__raw_writel(tmp, S3C2412_PWRCFG);
 
-	s3c2410_pm_do_restore(s3c2412_sleep, ARRAY_SIZE(s3c2412_sleep));
+	s3c_pm_do_restore(s3c2412_sleep, ARRAY_SIZE(s3c2412_sleep));
 	return 0;
 }
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/s3c2412.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/s3c2412.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2412/s3c2412.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2412/s3c2412.c	2009-05-10 22:27:59.000000000 +0200
@@ -231,5 +231,8 @@
 {
 	printk("S3C2412: Initialising architecture\n");
 
+	/* make sure SD/MMC driver can distinguish 2412 from 2410 */
+	s3c_device_sdi.name = "s3c2412-sdi";
+
 	return sysdev_register(&s3c2412_sysdev);
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/dma.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -17,18 +17,20 @@
 #include <linux/sysdev.h>
 #include <linux/serial_core.h>
 
+#include <mach/map.h>
 #include <mach/dma.h>
 
-#include <plat/dma.h>
+#include <plat/dma-plat.h>
 #include <plat/cpu.h>
 
 #include <plat/regs-serial.h>
 #include <mach/regs-gpio.h>
 #include <plat/regs-ac97.h>
+#include <plat/regs-dma.h>
 #include <mach/regs-mem.h>
 #include <mach/regs-lcd.h>
 #include <mach/regs-sdi.h>
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
 #include <plat/regs-spi.h>
 
 static struct s3c24xx_dma_map __initdata s3c2440_dma_mappings[] = {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/Kconfig	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -23,7 +23,6 @@
 	help
 	  Support for S3C2440 specific DMA code5A
 
-
 menu "S3C2440 Machines"
 
 config MACH_ANUBIS
@@ -33,6 +32,7 @@
 	select PM_SIMTEC if PM
 	select HAVE_PATA_PLATFORM
 	select S3C24XX_GPIO_EXTRA64
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the Simtec Electronics ANUBIS
 	  development system
@@ -43,6 +43,7 @@
 	select S3C24XX_DCLK
 	select PM_SIMTEC if PM
 	select S3C24XX_GPIO_EXTRA128
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the Simtec IM2440D20 module, also
 	  known as the Osiris.
@@ -58,12 +59,14 @@
 	bool "SMDK2440"
 	select CPU_S3C2440
 	select MACH_SMDK
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the SMDK2440.
 
 config MACH_NEXCODER_2440
  	bool "NexVision NEXCODER 2440 Light Board"
  	select CPU_S3C2440
+	select S3C_DEV_USB_HOST
 	help
  	  Say Y here if you are using the Nex Vision NEXCODER 2440 Light Board
 
@@ -76,8 +79,17 @@
 config MACH_AT2440EVB
 	bool "Avantech AT2440EVB development board"
 	select CPU_S3C2440
+	select S3C_DEV_USB_HOST
 	help
 	  Say Y here if you are using the AT2440EVB development board
 
+config NEO1973_GTA02_2440
+	bool "Old FIC Neo1973 GTA02 hardware using S3C2440 CPU"
+	depends on MACH_NEO1973_GTA02
+	select CPU_S3C2440
+	help
+	   Say Y here if you are using an early hardware revision
+	   of the FIC/Openmoko Neo1973 GTA02 GSM Phone.
+
 endmenu
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/mach-rx3715.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/mach-rx3715.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/mach-rx3715.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/mach-rx3715.c	2009-05-10 22:27:59.000000000 +0200
@@ -203,7 +203,7 @@
 #ifdef CONFIG_PM_H1940
 	memcpy(phys_to_virt(H1940_SUSPEND_RESUMEAT), h1940_pm_return, 1024);
 #endif
-	s3c2410_pm_init();
+	s3c_pm_init();
 
 	s3c24xx_fb_set_platdata(&rx3715_fb_info);
 	platform_add_devices(rx3715_devices, ARRAY_SIZE(rx3715_devices));
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -22,3 +22,5 @@
 obj-$(CONFIG_ARCH_S3C2440)	+= mach-smdk2440.o
 obj-$(CONFIG_MACH_NEXCODER_2440) += mach-nexcoder.o
 obj-$(CONFIG_MACH_AT2440EVB) += mach-at2440evb.o
+obj-$(CONFIG_MACH_HXD8)		+= mach-hxd8.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/s3c2440.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/s3c2440.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2440/s3c2440.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2440/s3c2440.c	2009-05-10 22:27:59.000000000 +0200
@@ -46,6 +46,9 @@
 	s3c_device_wdt.resource[1].start = IRQ_S3C2440_WDT;
 	s3c_device_wdt.resource[1].end   = IRQ_S3C2440_WDT;
 
+	/* make sure SD/MMC driver can distinguish 2440 from 2410 */
+	s3c_device_sdi.name = "s3c2440-sdi";
+
 	/* register our system device for everything else */
 
 	return sysdev_register(&s3c2440_sysdev);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/include/mach/gta02.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/include/mach/gta02.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/include/mach/gta02.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/include/mach/gta02.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,85 @@
+#ifndef _GTA02_H
+#define _GTA02_H
+
+#include <mach/regs-gpio.h>
+#include <mach/irqs.h>
+
+/* Different hardware revisions, passed in ATAG_REVISION by u-boot */
+#define GTA02v1_SYSTEM_REV	0x00000310
+#define GTA02v2_SYSTEM_REV	0x00000320
+#define GTA02v3_SYSTEM_REV	0x00000330
+#define GTA02v4_SYSTEM_REV	0x00000340
+#define GTA02v5_SYSTEM_REV	0x00000350
+#define GTA02v6_SYSTEM_REV	0x00000360
+
+#define GTA02_GPIO_n3DL_GSM	S3C2410_GPA13	/* v1 + v2 + v3 only */
+
+#define GTA02_GPIO_PWR_LED1	S3C2410_GPB0
+#define GTA02_GPIO_PWR_LED2	S3C2410_GPB1
+#define GTA02_GPIO_AUX_LED	S3C2410_GPB2
+#define GTA02_GPIO_VIBRATOR_ON	S3C2410_GPB3
+#define GTA02_GPIO_MODEM_RST	S3C2410_GPB5
+#define GTA02_GPIO_BT_EN	S3C2410_GPB6
+#define GTA02_GPIO_MODEM_ON	S3C2410_GPB7
+#define GTA02_GPIO_EXTINT8	S3C2410_GPB8
+#define GTA02_GPIO_USB_PULLUP	S3C2410_GPB9
+
+#define GTA02_GPIO_PIO5		S3C2410_GPC5	/* v3 + v4 only */
+#define GTA02v3_GPIO_nG1_CS	S3C2410_GPD12	/* v3 + v4 only */
+#define GTA02v3_GPIO_nG2_CS	S3C2410_GPD13	/* v3 + v4 only */
+#define GTA02v5_GPIO_HDQ	S3C2410_GPD14   /* v5 + */
+
+#define GTA02_GPIO_nG1_INT	S3C2410_GPF0
+#define GTA02_GPIO_IO1		S3C2410_GPF1
+#define GTA02_GPIO_PIO_2	S3C2410_GPF2	/* v2 + v3 + v4 only */
+#define GTA02_GPIO_JACK_INSERT	S3C2410_GPF4
+#define GTA02_GPIO_WLAN_GPIO1	S3C2410_GPF5	/* v2 + v3 + v4 only */
+#define GTA02_GPIO_AUX_KEY	S3C2410_GPF6
+#define GTA02_GPIO_HOLD_KEY	S3C2410_GPF7
+
+#define GTA02_GPIO_3D_IRQ	S3C2410_GPG4
+#define GTA02v2_GPIO_nG2_INT	S3C2410_GPG8	/* v2 + v3 + v4 only */
+#define GTA02v3_GPIO_nUSB_OC	S3C2410_GPG9	/* v3 + v4 only */
+#define GTA02v3_GPIO_nUSB_FLT	S3C2410_GPG10	/* v3 + v4 only */
+#define GTA02v3_GPIO_nGSM_OC	S3C2410_GPG11	/* v3 + v4 only */
+
+#define GTA02_GPIO_AMP_SHUT	S3C2440_GPJ1	/* v2 + v3 + v4 only */
+#define GTA02v1_GPIO_WLAN_GPIO10	S3C2440_GPJ2
+#define GTA02_GPIO_HP_IN	S3C2440_GPJ2	/* v2 + v3 + v4 only */
+#define GTA02_GPIO_INT0		S3C2440_GPJ3	/* v2 + v3 + v4 only */
+#define GTA02_GPIO_nGSM_EN	S3C2440_GPJ4
+#define GTA02_GPIO_3D_RESET	S3C2440_GPJ5
+#define GTA02_GPIO_nDL_GSM	S3C2440_GPJ6	/* v4 + v5 only */
+#define GTA02_GPIO_WLAN_GPIO0	S3C2440_GPJ7
+#define GTA02v1_GPIO_BAT_ID	S3C2440_GPJ8
+#define GTA02_GPIO_KEEPACT	S3C2440_GPJ8
+#define GTA02v1_GPIO_HP_IN	S3C2440_GPJ10
+#define GTA02_CHIP_PWD		S3C2440_GPJ11	/* v2 + v3 + v4 only */
+#define GTA02_GPIO_nWLAN_RESET	S3C2440_GPJ12	/* v2 + v3 + v4 only */
+
+#define GTA02_IRQ_GSENSOR_1	IRQ_EINT0
+#define GTA02_IRQ_MODEM		IRQ_EINT1
+#define GTA02_IRQ_PIO_2		IRQ_EINT2	/* v2 + v3 + v4 only */
+#define GTA02_IRQ_nJACK_INSERT	IRQ_EINT4
+#define GTA02_IRQ_WLAN_GPIO1	IRQ_EINT5
+#define GTA02_IRQ_AUX		IRQ_EINT6
+#define GTA02_IRQ_nHOLD		IRQ_EINT7
+#define GTA02_IRQ_PCF50633	IRQ_EINT9
+#define GTA02_IRQ_3D		IRQ_EINT12
+#define GTA02_IRQ_GSENSOR_2	IRQ_EINT16	/* v2 + v3 + v4 only */
+#define GTA02v3_IRQ_nUSB_OC	IRQ_EINT17	/* v3 + v4 only */
+#define GTA02v3_IRQ_nUSB_FLT	IRQ_EINT18	/* v3 + v4 only */
+#define GTA02v3_IRQ_nGSM_OC	IRQ_EINT19	/* v3 + v4 only */
+
+/* returns 00 000 on GTA02 A5 and earlier, A6 returns 01 001 */
+#define GTA02_PCB_ID1_0		S3C2410_GPC13
+#define GTA02_PCB_ID1_1		S3C2410_GPC15
+#define GTA02_PCB_ID1_2		S3C2410_GPD0
+#define GTA02_PCB_ID2_0		S3C2410_GPD3
+#define GTA02_PCB_ID2_1		S3C2410_GPD4
+
+int gta02_get_pcb_revision(void);
+
+extern struct pcf50633 *gta02_pcf;
+
+#endif /* _GTA02_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/Kconfig	2009-05-10 22:05:02.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -11,6 +11,7 @@
 	select S3C2410_CLOCK
 	select S3C2410_GPIO
 	select S3C2410_PM if PM
+	select S3C2440_DMA if S3C2410_DMA
 	select CPU_S3C244X
 	select CPU_LLSERIAL_S3C2440
 	help
@@ -24,6 +25,20 @@
 	depends on ARCH_S3C2440
 	select CPU_S3C2442
 
+config MACH_NEO1973_GTA02
+	bool "FIC Neo1973 GSM Phone (GTA02 Hardware)"
+	select CPU_S3C2442
+	select MFD_PCF50633
+	select PCF50633_GPIO
+	select I2C
+	select POWER_SUPPLY
+	select MACH_NEO1973
+	select S3C_PWM
+	select FIQ
+	select S3C_DEV_USB_HOST
+	help
+	   Say Y here if you are using the FIC Neo1973 GSM Phone
+
 
 endmenu
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/mach-gta02.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/mach-gta02.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/mach-gta02.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/mach-gta02.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1706 @@
+/*
+ * linux/arch/arm/mach-s3c2440/mach-gta02.c
+ *
+ * S3C2440 Machine Support for the FIC GTA02 (Neo1973)
+ *
+ * Copyright (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/glamo.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/mmc/host.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+
+#include <linux/i2c.h>
+#include <linux/backlight.h>
+#include <linux/regulator/machine.h>
+
+#include <linux/mfd/pcf50633/core.h>
+#include <linux/mfd/pcf50633/mbc.h>
+#include <linux/mfd/pcf50633/adc.h>
+#include <linux/mfd/pcf50633/gpio.h>
+#include <linux/mfd/pcf50633/pmic.h>
+
+#include <linux/lis302dl.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+
+#include <mach/regs-irq.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-gpioj.h>
+#include <mach/fb.h>
+#include <mach/mci.h>
+#include <mach/ts.h>
+#include <mach/spi.h>
+#include <mach/spi-gpio.h>
+#include <mach/regs-mem.h>
+#include <mach/spi-gpio.h>
+#include <plat/pwm.h>
+#include <mach/cpu.h>
+
+#include <mach/gta02.h>
+
+#include <plat/regs-serial.h>
+#include <plat/nand.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <plat/pm.h>
+#include <plat/udc.h>
+#include <plat/iic.h>
+#include <plat/usb-control.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+#include <mach/neo1973-pm-gsm.h>
+#include <mach/gta02-pm-wlan.h>
+#include <plat/regs-timer.h>
+
+#include <linux/jbt6k74.h>
+
+#include <linux/glamofb.h>
+
+#include <linux/hdq.h>
+#include <linux/bq27000_battery.h>
+
+#include "../plat-s3c24xx/neo1973_pm_gps.h"
+
+#include <../drivers/input/touchscreen/ts_filter_chain.h>
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+#include <../drivers/input/touchscreen/ts_filter_linear.h>
+#include <../drivers/input/touchscreen/ts_filter_mean.h>
+#include <../drivers/input/touchscreen/ts_filter_median.h>
+#include <../drivers/input/touchscreen/ts_filter_group.h>
+#endif
+
+#include <asm/fiq.h>
+
+#include <linux/neo1973_vibrator.h>
+
+/* arbitrates which sensor IRQ owns the shared SPI bus */
+static spinlock_t motion_irq_lock;
+
+
+/* -------------------------------------------------------------------------------
+ * GTA02 FIQ related
+ *
+ * Calls into vibrator and hdq and based on the return values
+ * determines if we the FIQ source be kept alive
+ */
+
+#define DIVISOR_FROM_US(x) ((x) << 3)
+
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+#define FIQ_DIVISOR_HDQ DIVISOR_FROM_US(HDQ_SAMPLE_PERIOD_US)
+extern int hdq_fiq_handler(void);
+#endif
+
+#ifdef CONFIG_LEDS_NEO1973_VIBRATOR
+#define FIQ_DIVISOR_VIBRATOR DIVISOR_FROM_US(100)
+extern int neo1973_vibrator_fiq_handler(void);
+#endif
+
+/* Global data related to our fiq source */
+static u32 gta02_fiq_ack_mask;
+static struct s3c2410_pwm gta02_fiq_pwm_timer;
+static u16 gta02_fiq_timer_index;
+static int gta02_fiq_irq;
+
+static void gta02_fiq_handler(void)
+{
+	u16 divisor = 0xffff;
+
+	/* Vibrator servicing */
+
+	/* disable further timer interrupts if nobody has any work
+	 * or adjust rate according to who still has work
+	 *
+	 * CAUTION: it means forground code must disable FIQ around
+	 * its own non-atomic S3C2410_INTMSK changes... not common
+	 * thankfully and taken care of by the fiq-basis patch
+	 */
+
+#ifdef CONFIG_LEDS_NEO1973_VIBRATOR
+	if (neo1973_vibrator_fiq_handler())
+		divisor = FIQ_DIVISOR_VIBRATOR;
+#endif
+
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+	if (hdq_fiq_handler())
+		divisor = FIQ_DIVISOR_HDQ;
+#endif
+
+	if (divisor == 0xffff) /* mask the fiq irq source */
+		__raw_writel(__raw_readl(S3C2410_INTMSK) | gta02_fiq_ack_mask,
+			     S3C2410_INTMSK);
+	else /* still working, maybe at a different rate */
+		__raw_writel(divisor, S3C2410_TCNTB(gta02_fiq_timer_index));
+
+	__raw_writel(gta02_fiq_ack_mask, S3C2410_SRCPND);
+}
+
+static void gta02_fiq_kick(void)
+{
+	unsigned long flags;
+	u32 tcon;
+	
+	/* we have to take care about FIQ because this modification is
+	 * non-atomic, FIQ could come in after the read and before the
+	 * writeback and its changes to the register would be lost
+	 * (platform INTMSK mod code is taken care of already)
+	 */
+	local_save_flags(flags);
+	local_fiq_disable();
+	/* allow FIQs to resume */
+	__raw_writel(__raw_readl(S3C2410_INTMSK) &
+		     ~(1 << (gta02_fiq_irq - S3C2410_CPUIRQ_OFFSET)),
+		     S3C2410_INTMSK);
+	tcon = __raw_readl(S3C2410_TCON) & ~S3C2410_TCON_T3START;
+	/* fake the timer to a count of 1 */
+	__raw_writel(1, S3C2410_TCNTB(gta02_fiq_timer_index));
+	__raw_writel(tcon | S3C2410_TCON_T3MANUALUPD, S3C2410_TCON);
+	__raw_writel(tcon | S3C2410_TCON_T3MANUALUPD | S3C2410_TCON_T3START,
+		     S3C2410_TCON);
+	__raw_writel(tcon | S3C2410_TCON_T3START, S3C2410_TCON);
+	local_irq_restore(flags);
+}
+
+static int gta02_fiq_enable(void)
+{
+	int irq_index_fiq = IRQ_TIMER3;
+	int rc = 0;
+
+	local_fiq_disable();
+
+	gta02_fiq_irq = irq_index_fiq;
+	gta02_fiq_ack_mask = 1 << (irq_index_fiq - S3C2410_CPUIRQ_OFFSET);
+	gta02_fiq_timer_index = (irq_index_fiq - IRQ_TIMER0);
+
+	/* set up the timer to operate as a pwm device */
+
+	rc = s3c2410_pwm_init(&gta02_fiq_pwm_timer);
+	if (rc)
+		goto bail;
+
+	gta02_fiq_pwm_timer.timerid = PWM0 + gta02_fiq_timer_index;
+	gta02_fiq_pwm_timer.prescaler = (6 - 1) / 2;
+	gta02_fiq_pwm_timer.divider = S3C2410_TCFG1_MUX3_DIV2;
+	/* default rate == ~32us */
+	gta02_fiq_pwm_timer.counter = gta02_fiq_pwm_timer.comparer = 3000;
+
+	rc = s3c2410_pwm_enable(&gta02_fiq_pwm_timer);
+	if (rc)
+		goto bail;
+
+	s3c2410_pwm_start(&gta02_fiq_pwm_timer);
+
+	/* let our selected interrupt be a magic FIQ interrupt */
+	__raw_writel(gta02_fiq_ack_mask, S3C2410_INTMOD);
+
+	/* it's ready to go as soon as we unmask the source in S3C2410_INTMSK */
+	local_fiq_enable();
+
+	set_fiq_c_handler(gta02_fiq_handler);
+
+	return 0;
+
+bail:
+	printk(KERN_ERR "Could not initialize FIQ for GTA02: %d\n", rc);
+
+	return rc;
+}
+
+static void gta02_fiq_disable(void)
+{
+	__raw_writel(0, S3C2410_INTMOD);
+	local_fiq_disable();
+	gta02_fiq_irq = 0; /* no active source interrupt now either */
+
+}
+/* -------------------- /GTA02 FIQ Handler ------------------------------------- */
+
+/*
+ * this gets called every 1ms when we paniced.
+ */
+
+static long gta02_panic_blink(long count)
+{
+	long delay = 0;
+	static long last_blink;
+	static char led;
+
+	if (count - last_blink < 100) /* 200ms period, fast blink */
+		return 0;
+
+	led ^= 1;
+	s3c2410_gpio_cfgpin(GTA02_GPIO_AUX_LED, S3C2410_GPIO_OUTPUT);
+	neo1973_gpb_setpin(GTA02_GPIO_AUX_LED, led);
+
+	last_blink = count;
+	return delay;
+}
+
+
+/**
+ * returns PCB revision information in b9,b8 and b2,b1,b0
+ * Pre-GTA02 A6 returns 0x000
+ *     GTA02 A6 returns 0x101
+ *     ...
+ */
+
+int gta02_get_pcb_revision(void)
+{
+	int n;
+	int u = 0;
+	static unsigned long pinlist[] = {
+		GTA02_PCB_ID1_0,
+		GTA02_PCB_ID1_1,
+		GTA02_PCB_ID1_2,
+		GTA02_PCB_ID2_0,
+		GTA02_PCB_ID2_1,
+	};
+	static int pin_offset[] = {
+		0, 1, 2, 8, 9
+	};
+
+	for (n = 0 ; n < ARRAY_SIZE(pinlist); n++) {
+		/*
+		 * set the PCB version GPIO to be pulled-down input
+		 * force low briefly first
+		 */
+		s3c2410_gpio_cfgpin(pinlist[n], S3C2410_GPIO_OUTPUT);
+		s3c2410_gpio_setpin(pinlist[n], 0);
+		/* misnomer: it is a pullDOWN in 2442 */
+		s3c2410_gpio_pullup(pinlist[n], 1);
+		s3c2410_gpio_cfgpin(pinlist[n], S3C2410_GPIO_INPUT);
+
+		udelay(10);
+
+		if (s3c2410_gpio_getpin(pinlist[n]))
+			u |= 1 << pin_offset[n];
+
+		/*
+		* when not being interrogated, all of the revision GPIO
+		* are set to output HIGH without pulldown so no current flows
+		* if they are NC or pulled up.
+		*/
+		s3c2410_gpio_setpin(pinlist[n], 1);
+		s3c2410_gpio_cfgpin(pinlist[n], S3C2410_GPIO_OUTPUT);
+		/* misnomer: it is a pullDOWN in 2442 */
+		s3c2410_gpio_pullup(pinlist[n], 0);
+	}
+
+	return u;
+}
+
+struct platform_device gta02_version_device = {
+	.name 		= "neo1973-version",
+	.num_resources	= 0,
+};
+
+struct platform_device gta02_resume_reason_device = {
+	.name 		= "neo1973-resume",
+	.num_resources	= 0,
+};
+
+struct platform_device gta02_memconfig_device = {
+	.name 		= "neo1973-memconfig",
+	.num_resources	= 0,
+};
+
+static struct map_desc gta02_iodesc[] __initdata = {
+	{
+		.virtual	= 0xe0000000,
+		.pfn		= __phys_to_pfn(S3C2410_CS3+0x01000000),
+		.length		= SZ_1M,
+		.type		= MT_DEVICE
+	},
+};
+
+#define UCON (S3C2410_UCON_DEFAULT | S3C2443_UCON_RXERR_IRQEN)
+#define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
+#define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
+
+static struct s3c2410_uartcfg gta02_uartcfgs[] = {
+	[0] = {
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+	[1] = {
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+	[2] = {
+		.hwport	     = 2,
+		.flags	     = 0,
+		.ucon	     = UCON,
+		.ulcon	     = ULCON,
+		.ufcon	     = UFCON,
+	},
+
+};
+
+struct pcf50633 *gta02_pcf;
+
+#ifdef CONFIG_CHARGER_PCF50633
+static int gta02_get_charger_online_status(void)
+{
+	struct pcf50633 *pcf = gta02_pcf;
+
+	return pcf50633_mbc_get_status(pcf) & PCF50633_MBC_USB_ONLINE;
+}
+
+static int gta02_get_charger_active_status(void)
+{
+	struct pcf50633 *pcf = gta02_pcf;
+
+	return pcf50633_mbc_get_status(pcf) & PCF50633_MBC_USB_ACTIVE;
+}
+
+#define ADC_NOM_CHG_DETECT_1A 6
+#define ADC_NOM_CHG_DETECT_USB 43
+
+static void
+gta02_configure_pmu_for_charger(struct pcf50633 *pcf, void *unused, int res)
+{
+	int  ma;
+	       
+	/* Interpret charger type */
+	if (res < ((ADC_NOM_CHG_DETECT_USB + ADC_NOM_CHG_DETECT_1A) / 2)) {
+
+		/* Stop GPO driving out now that we have a IA charger */
+		pcf50633_gpio_set(pcf, PCF50633_GPO, 0);
+	
+		ma = 1000;	
+	} else
+		ma = 100;
+
+	pcf50633_mbc_usb_curlim_set(pcf, ma);
+}
+
+static struct delayed_work gta02_charger_work;
+static int gta02_usb_vbus_draw;
+
+static void gta02_charger_worker(struct work_struct *work)
+{
+	struct pcf50633 *pcf = gta02_pcf;
+
+	if (gta02_usb_vbus_draw) {
+		pcf50633_mbc_usb_curlim_set(pcf, gta02_usb_vbus_draw);
+		return;
+	} else {
+#ifdef CONFIG_PCF50633_ADC
+		pcf50633_adc_async_read(pcf,
+			PCF50633_ADCC1_MUX_ADCIN1,
+			PCF50633_ADCC1_AVERAGE_16,
+			gta02_configure_pmu_for_charger, NULL);
+#else
+		/* If the PCF50633 ADC is disabled we fallback to a 100mA limit for safety. */
+		pcf50633_mbc_usb_curlim_set(pcf, 100);
+#endif
+		return;
+	}
+}
+
+#define GTA02_CHARGER_CONFIGURE_TIMEOUT ((3000 * HZ) / 1000)
+static void gta02_pmu_event_callback(struct pcf50633 *pcf, int irq)
+{
+	if (irq == PCF50633_IRQ_USBINS) {
+		schedule_delayed_work(&gta02_charger_work,
+				GTA02_CHARGER_CONFIGURE_TIMEOUT);
+		return;
+	} else if (irq == PCF50633_IRQ_USBREM) {
+		cancel_delayed_work_sync(&gta02_charger_work);
+		gta02_usb_vbus_draw = 0;
+	}
+}
+
+static void gta02_pmu_force_shutdown(struct pcf50633 *pcf)
+{
+	pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_OOCSHDWN,
+			PCF50633_OOCSHDWN_GOSTDBY, PCF50633_OOCSHDWN_GOSTDBY);
+}
+
+
+static void gta02_udc_vbus_draw(unsigned int ma)
+{
+        if (!gta02_pcf)
+		return;
+
+	gta02_usb_vbus_draw = ma;
+
+	schedule_delayed_work(&gta02_charger_work,
+				GTA02_CHARGER_CONFIGURE_TIMEOUT);
+}
+#else /* !CONFIG_CHARGER_PCF50633 */
+#define gta02_get_charger_online_status NULL
+#define gta02_get_charger_active_status NULL
+#define gta02_pmu_event_callback        NULL
+#define gta02_udc_vbus_draw             NULL
+#endif
+
+static struct platform_device gta01_pm_gps_dev = {
+	.name		= "neo1973-pm-gps",
+};
+
+static struct platform_device gta01_pm_bt_dev = {
+	.name		= "neo1973-pm-bt",
+};
+
+static struct platform_device gta02_pm_gsm_dev = {
+	.name		= "neo1973-pm-gsm",
+};
+
+/* this is called when pc50633 is probed, unfortunately quite late in the
+ * day since it is an I2C bus device.  Here we can belatedly define some
+ * platform devices with the advantage that we can mark the pcf50633 as the
+ * parent.  This makes them get suspended and resumed with their parent
+ * the pcf50633 still around.
+ */
+
+static struct platform_device gta02_glamo_dev;
+static void mangle_glamo_res_by_system_rev(void);
+
+static void gta02_pmu_attach_child_devices(struct pcf50633 *pcf);
+static void gta02_pmu_regulator_registered(struct pcf50633 *pcf, int id);
+
+static struct platform_device gta02_pm_wlan_dev = {
+	.name		= "gta02-pm-wlan",
+};
+
+static struct regulator_consumer_supply ldo4_consumers[] = {
+	{
+		.dev = &gta01_pm_bt_dev.dev,
+		.supply = "BT_3V2",
+	},
+};
+
+static struct regulator_consumer_supply ldo5_consumers[] = {
+	{
+		.dev = &gta01_pm_gps_dev.dev,
+		.supply = "RF_3V",
+	},
+};
+
+/*
+ * We need this dummy thing to fill the regulator consumers
+ */
+static struct platform_device gta02_mmc_dev = {
+	/* details filled in by glamo core */
+};
+
+static struct regulator_consumer_supply hcldo_consumers[] = {
+	{
+		.dev = &gta02_mmc_dev.dev,
+		.supply = "SD_3V3",
+	},
+};
+
+static char *gta02_batteries[] = {
+	"battery",
+};
+
+struct pcf50633_platform_data gta02_pcf_pdata = {
+	.resumers = {
+		[0] = 	PCF50633_INT1_USBINS |
+			PCF50633_INT1_USBREM |
+			PCF50633_INT1_ALARM,
+		[1] = 	PCF50633_INT2_ONKEYF,
+		[2] = 	PCF50633_INT3_ONKEY1S,
+		[3] = 	PCF50633_INT4_LOWSYS |
+			PCF50633_INT4_LOWBAT |
+			PCF50633_INT4_HIGHTMP,
+	},
+
+	.batteries = gta02_batteries,
+	.num_batteries = ARRAY_SIZE(gta02_batteries),
+	.charging_restart_interval = (900 * HZ),
+	.chg_ref_current_ma = 1000,
+
+	.reg_init_data = {
+		[PCF50633_REGULATOR_AUTO] = {
+			.constraints = {
+				.name = "IO_3V3",
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.boot_on = 1,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_DOWN1] = {
+			.constraints = {
+				.name = "CORE_1V3",
+				.min_uV = 1300000,
+				.max_uV = 1600000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.boot_on = 1,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_DOWN2] = {
+			.constraints = {
+				.name = "IO_1V8",
+				.min_uV = 1800000,
+				.max_uV = 1800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.boot_on = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_HCLDO] = {
+			.constraints = {
+				.name = "SD_3V3",
+				.min_uV = 2000000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+				.boot_on = 1,
+			},
+			.num_consumer_supplies = 1,
+			.consumer_supplies = hcldo_consumers,
+		},
+		[PCF50633_REGULATOR_LDO1] = {
+			.constraints = {
+				.name = "GSENSOR_3V3",
+				.min_uV = 1300000,
+				.max_uV = 1300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_LDO2] = {
+			.constraints = {
+				.name = "CODEC_3V3",
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_LDO3] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_LDO4] = {
+			.constraints = {
+				.name = "BT_3V2",
+				.min_uV = 3200000,
+				.max_uV = 3200000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 1,
+			.consumer_supplies = ldo4_consumers,
+		},
+		[PCF50633_REGULATOR_LDO5] = {
+			.constraints = {
+				.name = "RF_3V",
+				.min_uV = 1500000,
+				.max_uV = 1500000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 1,
+			.consumer_supplies = ldo5_consumers,
+		},
+		[PCF50633_REGULATOR_LDO6] = {
+			.constraints = {
+				.name = "LCM_3V",
+				.min_uV = 0,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+			},
+			.num_consumer_supplies = 0,
+		},
+		[PCF50633_REGULATOR_MEMLDO] = {
+			.constraints = {
+				.min_uV = 1800000,
+				.max_uV = 1800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+
+	},
+	.probe_done = gta02_pmu_attach_child_devices,
+	.regulator_registered = gta02_pmu_regulator_registered,
+	.mbc_event_callback = gta02_pmu_event_callback,
+	.force_shutdown = gta02_pmu_force_shutdown,
+};
+
+static void mangle_pmu_pdata_by_system_rev(void)
+{
+	struct regulator_init_data *reg_init_data;
+
+	reg_init_data = gta02_pcf_pdata.reg_init_data;
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA02v1_SYSTEM_REV:
+		/* FIXME: this is only in v1 due to wrong PMU variant */
+		reg_init_data[PCF50633_REGULATOR_DOWN2]
+					.constraints.state_mem.enabled = 1;
+		break;
+	case GTA02v2_SYSTEM_REV:
+	case GTA02v3_SYSTEM_REV:
+	case GTA02v4_SYSTEM_REV:
+	case GTA02v5_SYSTEM_REV:
+	case GTA02v6_SYSTEM_REV:
+		reg_init_data[PCF50633_REGULATOR_LDO1]
+					.constraints.min_uV = 3300000;
+		reg_init_data[PCF50633_REGULATOR_LDO1]
+					.constraints.min_uV = 3300000;
+		reg_init_data[PCF50633_REGULATOR_LDO1]
+					.constraints.state_mem.enabled = 0;
+
+		reg_init_data[PCF50633_REGULATOR_LDO5]
+					.constraints.min_uV = 3000000;
+		reg_init_data[PCF50633_REGULATOR_LDO5]
+					.constraints.max_uV = 3000000;
+		
+		reg_init_data[PCF50633_REGULATOR_LDO6]
+					.constraints.min_uV = 3000000;
+		reg_init_data[PCF50633_REGULATOR_LDO6]
+					.constraints.max_uV = 3000000;
+		reg_init_data[PCF50633_REGULATOR_LDO6]
+					.constraints.apply_uV = 1;
+		break;
+	default:
+		break;
+	}
+}
+
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+/* BQ27000 Battery */
+
+struct bq27000_platform_data bq27000_pdata = {
+	.name = "battery",
+	.rsense_mohms = 20,
+	.hdq_read = hdq_read,
+	.hdq_write = hdq_write,
+	.hdq_initialized = hdq_initialized,
+	.get_charger_online_status = gta02_get_charger_online_status,
+	.get_charger_active_status = gta02_get_charger_active_status
+};
+
+struct platform_device bq27000_battery_device = {
+	.name 		= "bq27000-battery",
+	.dev = {
+		.platform_data = &bq27000_pdata,
+	},
+};
+
+/* HDQ */
+
+static void gta02_hdq_attach_child_devices(struct device *parent_device)
+{
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA02v5_SYSTEM_REV:
+	case GTA02v6_SYSTEM_REV:
+		bq27000_battery_device.dev.parent = parent_device;
+		platform_device_register(&bq27000_battery_device);
+		break;
+	default:
+		break;
+	}
+}
+
+static void gta02_hdq_gpio_direction_out(void)
+{
+	s3c2410_gpio_cfgpin(GTA02v5_GPIO_HDQ, S3C2410_GPIO_OUTPUT);
+}
+
+static void gta02_hdq_gpio_direction_in(void)
+{
+	s3c2410_gpio_cfgpin(GTA02v5_GPIO_HDQ, S3C2410_GPIO_INPUT);
+}
+
+static void gta02_hdq_gpio_set_value(int val)
+{
+
+	s3c2410_gpio_setpin(GTA02v5_GPIO_HDQ, val);
+}
+
+static int gta02_hdq_gpio_get_value(void)
+{
+	return s3c2410_gpio_getpin(GTA02v5_GPIO_HDQ);
+}
+
+static struct resource gta02_hdq_resources[] = {
+	[0] = {
+		.start	= GTA02v5_GPIO_HDQ,
+		.end	= GTA02v5_GPIO_HDQ,
+	},
+};
+
+struct hdq_platform_data gta02_hdq_platform_data = {
+	.attach_child_devices = gta02_hdq_attach_child_devices,
+	.gpio_dir_out = gta02_hdq_gpio_direction_out,
+	.gpio_dir_in = gta02_hdq_gpio_direction_in,
+	.gpio_set = gta02_hdq_gpio_set_value,
+	.gpio_get = gta02_hdq_gpio_get_value,
+
+	.enable_fiq = gta02_fiq_enable,
+	.disable_fiq = gta02_fiq_disable,
+	.kick_fiq = gta02_fiq_kick,
+
+};
+
+struct platform_device gta02_hdq_device = {
+	.name 		= "hdq",
+	.num_resources	= 1,
+	.resource	= gta02_hdq_resources,
+	.dev		= {
+		.platform_data = &gta02_hdq_platform_data,
+	},
+};
+#endif
+
+
+#ifdef CONFIG_LEDS_NEO1973_VIBRATOR
+/* vibrator (child of FIQ) */
+
+static struct resource gta02_vibrator_resources[] = {
+	[0] = {
+		.start	= GTA02_GPIO_VIBRATOR_ON,
+		.end	= GTA02_GPIO_VIBRATOR_ON,
+	},
+};
+struct neo1973_vib_platform_data gta02_vib_pdata = {
+	.enable_fiq = gta02_fiq_enable,
+	.disable_fiq = gta02_fiq_disable,
+	.kick_fiq = gta02_fiq_kick,
+};
+
+static struct platform_device gta02_vibrator_dev = {
+	.name		= "neo1973-vibrator",
+	.num_resources	= ARRAY_SIZE(gta02_vibrator_resources),
+	.resource	= gta02_vibrator_resources,
+	.dev	 = {
+		.platform_data = &gta02_vib_pdata,
+		},
+};
+#endif
+
+/* NOR Flash */
+
+#define GTA02_FLASH_BASE	0x18000000 /* GCS3 */
+#define GTA02_FLASH_SIZE	0x200000 /* 2MBytes */
+
+static struct physmap_flash_data gta02_nor_flash_data = {
+	.width		= 2,
+};
+
+static struct resource gta02_nor_flash_resource = {
+	.start		= GTA02_FLASH_BASE,
+	.end		= GTA02_FLASH_BASE + GTA02_FLASH_SIZE - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device gta02_nor_flash = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+				.platform_data	= &gta02_nor_flash_data,
+			},
+	.resource	= &gta02_nor_flash_resource,
+	.num_resources	= 1,
+};
+
+
+struct platform_device s3c24xx_pwm_device = {
+	.name 		= "s3c24xx_pwm",
+	.num_resources	= 0,
+};
+
+static struct i2c_board_info gta02_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf50633", 0x73),
+		.irq = GTA02_IRQ_PCF50633,
+		.platform_data = &gta02_pcf_pdata,
+	},
+	{
+		I2C_BOARD_INFO("wm8753", 0x1a),
+	},
+};
+
+static struct s3c2410_nand_set gta02_nand_sets[] = {
+	[0] = {
+		.name		= "neo1973-nand",
+		.nr_chips	= 1,
+		.flags		= S3C2410_NAND_BBT,
+	},
+};
+
+/* choose a set of timings derived from S3C@2442B MCP54 
+ * data sheet (K5D2G13ACM-D075 MCP Memory)
+ */
+
+static struct s3c2410_platform_nand gta02_nand_info = {
+	.tacls		= 0,
+	.twrph0		= 25,
+	.twrph1		= 15,
+	.nr_sets	= ARRAY_SIZE(gta02_nand_sets),
+	.sets		= gta02_nand_sets,
+	.software_ecc	= 1,
+};
+
+
+static void gta02_s3c_mmc_set_power(unsigned char power_mode,
+    unsigned short vdd)
+{
+	static int is_on = -1;
+	int on;
+
+	on = power_mode == MMC_POWER_ON || power_mode == MMC_POWER_UP;
+	if (is_on != on)
+		gta02_wlan_reset(!on);
+	is_on = on;
+}
+
+
+static struct s3c24xx_mci_pdata gta02_s3c_mmc_cfg = {
+	.set_power	= gta02_s3c_mmc_set_power,
+};
+
+static void gta02_udc_command(enum s3c2410_udc_cmd_e cmd)
+{
+	switch (cmd) {
+	case S3C2410_UDC_P_ENABLE:
+		printk(KERN_DEBUG "%s S3C2410_UDC_P_ENABLE\n", __func__);
+		neo1973_gpb_setpin(GTA02_GPIO_USB_PULLUP, 1);
+		break;
+	case S3C2410_UDC_P_DISABLE:
+		printk(KERN_DEBUG "%s S3C2410_UDC_P_DISABLE\n", __func__);
+		neo1973_gpb_setpin(GTA02_GPIO_USB_PULLUP, 0);
+		break;
+	case S3C2410_UDC_P_RESET:
+		printk(KERN_DEBUG "%s S3C2410_UDC_P_RESET\n", __func__);
+		/* FIXME! */
+		break;
+	default:
+		break;
+	}
+}
+
+/* get PMU to set USB current limit accordingly */
+
+static struct s3c2410_udc_mach_info gta02_udc_cfg = {
+	.vbus_draw	= gta02_udc_vbus_draw,
+	.udc_command	= gta02_udc_command,
+
+};
+
+
+/* Touchscreen configuration. */
+
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+const static struct ts_filter_group_configuration gta02_ts_group = {
+	.length = 12,
+	.close_enough = 10,
+	.threshold = 6,		/* At least half of the points in a group. */
+	.attempts = 10,
+};
+
+const static struct ts_filter_median_configuration gta02_ts_median = {
+	.extent = 20,
+	.decimation_below = 3,
+	.decimation_threshold = 8 * 3,
+	.decimation_above = 4,
+};
+
+const static struct ts_filter_mean_configuration gta02_ts_mean = {
+	.length = 4,
+};
+
+const static struct ts_filter_linear_configuration gta02_ts_linear = {
+	.constants = {1, 0, 0, 0, 1, 0, 1},	/* Don't modify coords. */
+	.coord0 = 0,
+	.coord1 = 1,
+};
+#endif
+
+const static struct ts_filter_chain_configuration gta02_filter_configuration[] =
+{
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+	{&ts_filter_group_api,		&gta02_ts_group.config},
+	{&ts_filter_median_api,		&gta02_ts_median.config},
+	{&ts_filter_mean_api,		&gta02_ts_mean.config},
+	{&ts_filter_linear_api,		&gta02_ts_linear.config},
+#endif
+	{NULL, NULL},
+};
+
+const static struct s3c2410_ts_mach_info gta02_ts_cfg = {
+	.delay = 10000,
+	.presc = 0xff, /* slow as we can go */
+	.filter_config = gta02_filter_configuration,
+};
+
+
+
+static void gta02_bl_set_intensity(int intensity)
+{
+	struct pcf50633 *pcf = gta02_pcf;
+	int old_intensity = pcf50633_reg_read(pcf, PCF50633_REG_LEDOUT);
+	int ret;
+
+	intensity >>= 2;
+
+	/*
+	 * One code path that leads here is from a kernel panic. Trying to turn
+	 * the backlight on just gives us a nearly endless stream of complaints
+	 * and accomplishes nothing. We can't win. Just give up.
+	 *
+	 * In the unlikely event that there's another path leading here while
+	 * we're atomic, we print at least a warning.
+	 */
+	if (in_atomic()) {
+		printk(KERN_ERR
+		    "gta02_bl_set_intensity called while atomic\n");
+		return;
+	}
+
+	if (!(pcf50633_reg_read(pcf, PCF50633_REG_LEDENA) & 3))
+		old_intensity = 0;
+	else
+		old_intensity = pcf50633_reg_read(pcf, PCF50633_REG_LEDOUT);
+
+	if (intensity == old_intensity)
+		return;
+
+	/* We can't do this anywhere else */
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDDIM, 5);
+
+	/*
+	 * The PCF50633 cannot handle LEDOUT = 0 (datasheet p60)
+	 * if seen, you have to re-enable the LED unit
+	 */
+	if (!intensity || !old_intensity)
+		pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 0);
+
+	if (!intensity) /* illegal to set LEDOUT to 0 */
+		ret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_LEDOUT, 0x3f,
+									     2);
+	else
+		ret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_LEDOUT, 0x3f,
+			       intensity);
+
+	if (intensity)
+		pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 2);
+
+}
+
+static struct generic_bl_info gta02_bl_info = {
+	.name 			= "gta02-bl",
+	.max_intensity 		= 0xff,
+	.default_intensity 	= 0xff,
+	.set_bl_intensity 	= gta02_bl_set_intensity,
+};
+
+static struct platform_device gta02_bl_dev = {
+	.name		  = "generic-bl",
+	.id		  = 1,
+	.dev = {
+		.platform_data = &gta02_bl_info,
+	},
+};
+
+/* SPI: LCM control interface attached to Glamo3362 */
+
+static void gta02_jbt6k74_reset(int devidx, int level)
+{
+	glamo_lcm_reset(level);
+}	
+
+static void gta02_jbt6k74_probe_completed(struct device *dev)
+{
+	struct pcf50633 *pcf = gta02_pcf;
+
+	/* Switch on backlight. Qi does not do it for us */
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDOUT, 0x01);
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 0x00);
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDDIM, 0x01);
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 0x01);
+
+	gta02_bl_dev.dev.parent = dev;
+	platform_device_register(&gta02_bl_dev);
+}
+
+const struct jbt6k74_platform_data jbt6k74_pdata = {
+	.reset		= gta02_jbt6k74_reset,
+	.probe_completed = gta02_jbt6k74_probe_completed,
+};
+
+#if 0 /* currently this is not used and we use gpio spi */
+static struct glamo_spi_info glamo_spi_cfg = {
+	.board_size	= ARRAY_SIZE(gta02_spi_board_info),
+	.board_info	= gta02_spi_board_info,
+};
+#endif /* 0 */
+
+static struct glamo_spigpio_info glamo_spigpio_cfg = {
+	.pin_clk	= GLAMO_GPIO10_OUTPUT,
+	.pin_mosi	= GLAMO_GPIO11_OUTPUT,
+	.pin_cs		= GLAMO_GPIO12_OUTPUT,
+	.pin_miso	= 0,
+	.bus_num	= 2,
+};
+
+/*----------- SPI: Accelerometers attached to SPI of s3c244x ----------------- */
+
+void gta02_lis302dl_suspend_io(struct lis302dl_info *lis, int resume)
+{
+	struct lis302dl_platform_data *pdata = lis->pdata;
+
+	if (!resume) {
+		 /*
+		 * we don't want to power them with a high level
+		 * because GSENSOR_3V3 is not up during suspend
+		 */
+		s3c2410_gpio_setpin(pdata->pin_chip_select, 0);
+		s3c2410_gpio_setpin(pdata->pin_clk, 0);
+		s3c2410_gpio_setpin(pdata->pin_mosi, 0);
+		/* misnomer: it is a pullDOWN in 2442 */
+		s3c2410_gpio_pullup(pdata->pin_miso, 1);
+		return;
+	}
+
+	/* back to normal */
+	s3c2410_gpio_setpin(pdata->pin_chip_select, 1);
+	s3c2410_gpio_setpin(pdata->pin_clk, 1);
+	/* misnomer: it is a pullDOWN in 2442 */
+	s3c2410_gpio_pullup(pdata->pin_miso, 0);
+
+	s3c2410_gpio_cfgpin(pdata->pin_chip_select, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_cfgpin(pdata->pin_clk, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_cfgpin(pdata->pin_mosi, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_cfgpin(pdata->pin_miso, S3C2410_GPIO_INPUT);
+
+}
+
+struct lis302dl_platform_data lis302_pdata_top = {
+		.name		= "lis302-1 (top)",
+		.pin_chip_select= S3C2410_GPD12,
+		.pin_clk	= S3C2410_GPG7,
+		.pin_mosi	= S3C2410_GPG6,
+		.pin_miso	= S3C2410_GPG5,
+		.interrupt	= GTA02_IRQ_GSENSOR_1,
+		.open_drain	= 1, /* altered at runtime by PCB rev */
+		.lis302dl_suspend_io = gta02_lis302dl_suspend_io,
+};
+
+struct lis302dl_platform_data lis302_pdata_bottom = {
+		.name		= "lis302-2 (bottom)",
+		.pin_chip_select= S3C2410_GPD13,
+		.pin_clk	= S3C2410_GPG7,
+		.pin_mosi	= S3C2410_GPG6,
+		.pin_miso	= S3C2410_GPG5,
+		.interrupt	= GTA02_IRQ_GSENSOR_2,
+		.open_drain	= 1, /* altered at runtime by PCB rev */
+		.lis302dl_suspend_io = gta02_lis302dl_suspend_io,
+};
+
+static struct spi_board_info gta02_spi_board_info[] = {
+	{
+		.modalias	= "jbt6k74",
+		/* platform_data */
+		.platform_data	= &jbt6k74_pdata,
+		/* controller_data */
+		/* irq */
+		.max_speed_hz	= 100 * 1000,
+		.bus_num	= 2,
+		/* chip_select */
+	},
+	{
+		.modalias	= "lis302dl",
+		/* platform_data */
+		.platform_data	= &lis302_pdata_top,
+		/* controller_data */
+		/* irq */
+		.max_speed_hz	= 100 * 1000,
+		.bus_num	= 3,
+		.chip_select	= 0,
+	},
+
+	{
+		.modalias	= "lis302dl",
+		/* platform_data */
+		.platform_data	= &lis302_pdata_bottom,
+		/* controller_data */
+		/* irq */
+		.max_speed_hz	= 100 * 1000,
+		.bus_num	= 3,
+		.chip_select	= 1,
+	},
+
+};
+
+static void gta02_lis302_chip_select(struct s3c2410_spigpio_info *info, int csid, int cs)
+{
+
+	/*
+	 * Huh... "quirk"... CS on this device is not really "CS" like you can
+	 * expect.
+	 *
+	 * When it is 0 it selects SPI interface mode.
+	 * When it is 1 it selects I2C interface mode.
+	 *
+	 * Because we have 2 devices on one interface we have to make sure
+	 * that the "disabled" device (actually in I2C mode) don't think we're
+	 * talking to it.
+	 *
+	 * When we talk to the "enabled" device, the "disabled" device sees
+	 * the clocks as I2C clocks, creating havoc.
+	 *
+	 * I2C sees MOSI going LOW while CLK HIGH as a START action, thus we
+	 * must ensure this is never issued.
+	 */
+
+	int cs_gpio, other_cs_gpio;
+
+	cs_gpio = csid ? S3C2410_GPD13 : S3C2410_GPD12;
+	other_cs_gpio = (1 - csid) ? S3C2410_GPD13 : S3C2410_GPD12;
+	
+
+	if (cs == BITBANG_CS_ACTIVE) {
+		s3c2410_gpio_setpin(other_cs_gpio, 1);
+		s3c2410_gpio_setpin(cs_gpio, 1);
+		s3c2410_gpio_setpin(info->pin_clk, 1);
+		s3c2410_gpio_setpin(cs_gpio, 0);
+	} else {
+		s3c2410_gpio_setpin(cs_gpio, 1);
+		s3c2410_gpio_setpin(other_cs_gpio, 1);
+	} 
+}
+
+static struct s3c2410_spigpio_info gta02_spigpio_cfg = {
+	.pin_clk	= S3C2410_GPG7,
+	.pin_mosi	= S3C2410_GPG6,
+	.pin_miso	= S3C2410_GPG5,
+	.bus_num	= 3,
+	.num_chipselect	= 2,
+	.chip_select	= gta02_lis302_chip_select,
+	.non_blocking_transfer = 1,
+};
+
+static struct platform_device gta02_spi_gpio_dev = {
+	.name		= "spi_s3c24xx_gpio",
+	.dev = {
+		.platform_data = &gta02_spigpio_cfg,
+	},
+};
+
+/*----------- / SPI: Accelerometers attached to SPI of s3c244x ----------------- */
+
+static struct resource gta02_led_resources[] = {
+	{
+		.name	= "gta02-power:orange",
+		.start	= GTA02_GPIO_PWR_LED1,
+		.end	= GTA02_GPIO_PWR_LED1,
+	}, {
+		.name	= "gta02-power:blue",
+		.start	= GTA02_GPIO_PWR_LED2,
+		.end	= GTA02_GPIO_PWR_LED2,
+	}, {
+		.name	= "gta02-aux:red",
+		.start	= GTA02_GPIO_AUX_LED,
+		.end	= GTA02_GPIO_AUX_LED,
+	},
+};
+
+struct platform_device gta02_led_dev = {
+	.name		= "gta02-led",
+	.num_resources	= ARRAY_SIZE(gta02_led_resources),
+	.resource	= gta02_led_resources,
+};
+
+static struct resource gta02_button_resources[] = {
+	[0] = {
+		.start = GTA02_GPIO_AUX_KEY,
+		.end   = GTA02_GPIO_AUX_KEY,
+	},
+	[1] = {
+		.start = GTA02_GPIO_HOLD_KEY,
+		.end   = GTA02_GPIO_HOLD_KEY,
+	},
+	[2] = {
+		.start = GTA02_GPIO_JACK_INSERT,
+		.end   = GTA02_GPIO_JACK_INSERT,
+	},
+	[3] = {
+		.start = 0,
+		.end   = 0,
+	},
+	[4] = {
+		.start = 0,
+		.end   = 0,
+	},
+};
+
+static struct platform_device gta02_button_dev = {
+	.name		= "neo1973-button",
+	.num_resources	= ARRAY_SIZE(gta02_button_resources),
+	.resource	= gta02_button_resources,
+};
+
+
+static struct platform_device gta02_pm_usbhost_dev = {
+	.name		= "neo1973-pm-host",
+};
+
+
+/* USB */
+static struct s3c2410_hcd_info gta02_usb_info = {
+	.port[0]	= {
+		.flags	= S3C_HCDFLG_USED,
+	},
+	.port[1]	= {
+		.flags	= 0,
+	},
+};
+
+static int glamo_irq_is_wired(void)
+{
+	int rc;
+	int count = 0;
+
+	/*
+	* GTA02 S-Media IRQs prior to A5 are broken due to a lack of
+	* a pullup on the INT# line.  Check for the bad behaviour.
+	*/
+	s3c2410_gpio_setpin(S3C2410_GPG4, 0);
+	s3c2410_gpio_cfgpin(S3C2410_GPG4, S3C2410_GPG4_OUTP);
+	s3c2410_gpio_cfgpin(S3C2410_GPG4, S3C2410_GPG4_INP);
+	/*
+	* we force it low ourselves for a moment and resume being input.
+	* If there is a pullup, it won't stay low for long.  But if the
+	* level converter is there as on < A5 revision, the weak keeper
+	* on the input of the LC will hold the line low indefinitiely
+	*/
+	do
+		rc = s3c2410_gpio_getpin(S3C2410_GPG4);
+	while ((!rc) && ((count++) < 10));
+	if (rc) { /* it got pulled back up, it's good */
+		printk(KERN_INFO "Detected S-Media IRQ# pullup, "
+		"enabling interrupt\n");
+		return 0;
+	} else  /* Gah we can't work with this level converter */
+		printk(KERN_WARNING "** Detected bad IRQ# circuit found"
+		" on pre-A5 GTA02: S-Media interrupt disabled **\n");
+	return -ENODEV;
+}
+
+static int gta02_glamo_can_set_mmc_power(void)
+{
+	switch (S3C_SYSTEM_REV_ATAG) {
+		case GTA02v3_SYSTEM_REV:
+		case GTA02v4_SYSTEM_REV:
+		case GTA02v5_SYSTEM_REV:
+		case GTA02v6_SYSTEM_REV:
+			return 1;
+	}
+
+	return 0;
+}
+
+/* Smedia Glamo 3362 */
+
+/*
+ * we crank down SD Card clock dynamically when GPS is powered
+ */
+
+static int gta02_glamo_mci_use_slow(void)
+{
+	return neo1973_pm_gps_is_on();
+}
+
+static void gta02_glamo_external_reset(int level)
+{
+	s3c2410_gpio_setpin(GTA02_GPIO_3D_RESET, level);
+	s3c2410_gpio_cfgpin(GTA02_GPIO_3D_RESET, S3C2410_GPIO_OUTPUT);
+}
+
+static struct glamofb_platform_data gta02_glamo_pdata = {
+	.width		= 43,
+	.height		= 58,
+	 /* 24.5MHz --> 40.816ns */
+	.pixclock	= 40816,
+	.left_margin	= 8,
+	.right_margin	= 16,
+	.upper_margin	= 2,
+	.lower_margin	= 16,
+	.hsync_len	= 8,
+	.vsync_len	= 2,
+	.fb_mem_size	= 0x400000, /* glamo has 8 megs of SRAM. we use 4 */
+	.xres		= {
+		.min	= 240,
+		.max	= 640,
+		.defval	= 480,
+	},
+	.yres		= {
+		.min	= 320,
+		.max	= 640,
+		.defval	= 640,
+	},
+	.bpp		= {
+		.min	= 16,
+		.max	= 16,
+		.defval	= 16,
+	},
+	//.spi_info	= &glamo_spi_cfg,
+	.spigpio_info	= &glamo_spigpio_cfg,
+
+	/* glamo MMC function platform data */
+	.mmc_dev = &gta02_mmc_dev,
+	.glamo_can_set_mci_power = gta02_glamo_can_set_mmc_power,
+	.glamo_mci_use_slow = gta02_glamo_mci_use_slow,
+	.glamo_irq_is_wired = glamo_irq_is_wired,
+	.glamo_external_reset = gta02_glamo_external_reset
+};
+
+static struct resource gta02_glamo_resources[] = {
+	[0] = {
+		.start	= S3C2410_CS1,
+		.end	= S3C2410_CS1 + 0x1000000 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= GTA02_IRQ_3D,
+		.end	= GTA02_IRQ_3D,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = GTA02_GPIO_3D_RESET,
+		.end   = GTA02_GPIO_3D_RESET,
+	},
+};
+
+static struct platform_device gta02_glamo_dev = {
+	.name		= "glamo3362",
+	.num_resources	= ARRAY_SIZE(gta02_glamo_resources),
+	.resource	= gta02_glamo_resources,
+	.dev		= {
+		.platform_data	= &gta02_glamo_pdata,
+	},
+};
+
+static void mangle_glamo_res_by_system_rev(void)
+{
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA02v1_SYSTEM_REV:
+		break;
+	default:
+		gta02_glamo_resources[2].start = GTA02_GPIO_3D_RESET;
+		gta02_glamo_resources[2].end = GTA02_GPIO_3D_RESET;
+		break;
+	}
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA02v1_SYSTEM_REV:
+	case GTA02v2_SYSTEM_REV:
+	case GTA02v3_SYSTEM_REV:
+	/* case GTA02v4_SYSTEM_REV: - FIXME: handle this later */
+		/* The hardware is missing a pull-up resistor and thus can't
+		 * support the Smedia Glamo IRQ */
+		gta02_glamo_resources[1].start = 0;
+		gta02_glamo_resources[1].end = 0;
+		break;
+	}
+}
+
+static void __init gta02_map_io(void)
+{
+	s3c24xx_init_io(gta02_iodesc, ARRAY_SIZE(gta02_iodesc));
+	s3c24xx_init_clocks(12000000);
+	s3c24xx_init_uarts(gta02_uartcfgs, ARRAY_SIZE(gta02_uartcfgs));
+}
+
+static irqreturn_t gta02_modem_irq(int irq, void *param)
+{
+	printk(KERN_DEBUG "modem wakeup interrupt\n");
+	gta_gsm_interrupts++;
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ar6000_wow_irq(int irq, void *param)
+{
+	printk(KERN_DEBUG "ar6000_wow interrupt\n");
+	return IRQ_HANDLED;
+}
+
+/*
+ * hardware_ecc=1|0
+ */
+static char hardware_ecc_str[4] __initdata = "";
+
+static int __init hardware_ecc_setup(char *str)
+{
+	if (str)
+		strlcpy(hardware_ecc_str, str, sizeof(hardware_ecc_str));
+	return 1;
+}
+
+__setup("hardware_ecc=", hardware_ecc_setup);
+
+/* these are the guys that don't need to be children of PMU */
+
+static struct platform_device *gta02_devices[] __initdata = {
+	&gta02_version_device,
+	&s3c_device_usb,
+	&s3c_device_wdt,
+	&gta02_memconfig_device,
+	&s3c_device_sdi,
+	&s3c_device_usbgadget,
+	&s3c_device_nand,
+	&gta02_nor_flash,
+
+	&s3c24xx_pwm_device,
+	&gta02_led_dev,
+	&gta02_pm_wlan_dev, /* not dependent on PMU */
+
+	&s3c_device_iis,
+	&s3c_device_i2c0,
+};
+
+/* these guys DO need to be children of PMU */
+
+static struct platform_device *gta02_devices_pmu_children[] = {
+	&s3c_device_ts, /* input 1 */
+	&gta02_pm_gsm_dev,
+	&gta02_pm_usbhost_dev,
+	&gta02_spi_gpio_dev, /* input 2 and 3 */
+	&gta02_button_dev, /* input 4 */
+	&gta02_resume_reason_device,
+};
+
+static void gta02_pmu_regulator_registered(struct pcf50633 *pcf, int id)
+{
+	struct platform_device *regulator, *pdev;
+
+	gta02_pcf = pcf;
+
+	regulator = pcf->regulator_pdev[id];
+
+	switch(id) {
+		case PCF50633_REGULATOR_LDO4:
+			pdev = &gta01_pm_bt_dev;
+			break;
+		case PCF50633_REGULATOR_LDO5:
+			pdev = &gta01_pm_gps_dev;
+			break;
+		case PCF50633_REGULATOR_HCLDO:
+			pdev = &gta02_glamo_dev;
+			break;
+		default:
+			return;	
+	}
+	
+	pdev->dev.parent = &regulator->dev;
+	platform_device_register(pdev);
+}
+
+/* this is called when pc50633 is probed, unfortunately quite late in the
+ * day since it is an I2C bus device.  Here we can belatedly define some
+ * platform devices with the advantage that we can mark the pcf50633 as the
+ * parent.  This makes them get suspended and resumed with their parent
+ * the pcf50633 still around.
+ */
+
+static void gta02_pmu_attach_child_devices(struct pcf50633 *pcf)
+{
+	int n;
+
+	for (n = 0; n < ARRAY_SIZE(gta02_devices_pmu_children); n++)
+		gta02_devices_pmu_children[n]->dev.parent = pcf->dev;
+
+	mangle_glamo_res_by_system_rev();
+	platform_add_devices(gta02_devices_pmu_children,
+					ARRAY_SIZE(gta02_devices_pmu_children));
+}
+
+static void gta02_poweroff(void)
+{
+	pcf50633_reg_set_bit_mask(gta02_pcf, PCF50633_REG_OOCSHDWN,
+		  PCF50633_OOCSHDWN_GOSTDBY, PCF50633_OOCSHDWN_GOSTDBY);
+}
+
+static void __init gta02_machine_init(void)
+{
+	int rc;
+
+	/* set the panic callback to make AUX blink fast */
+	panic_blink = gta02_panic_blink;
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA02v6_SYSTEM_REV:
+		/* we need push-pull interrupt from motion sensors */
+		lis302_pdata_top.open_drain = 0;
+		lis302_pdata_bottom.open_drain = 0;
+		break;
+	default:
+		break;
+	}
+
+	spin_lock_init(&motion_irq_lock);
+
+#ifdef CONFIG_CHARGER_PCF50633
+	INIT_DELAYED_WORK(&gta02_charger_work, gta02_charger_worker);
+#endif
+
+	/* Glamo chip select optimization */
+/*	 *((u32 *)(S3C2410_MEMREG(((1 + 1) << 2)))) = 0x1280; */
+
+	/* do not force soft ecc if we are asked to use hardware_ecc */
+	if (hardware_ecc_str[0] == '1')
+		gta02_nand_info.software_ecc = 0;
+
+	s3c_device_usb.dev.platform_data = &gta02_usb_info;
+	s3c_device_nand.dev.platform_data = &gta02_nand_info;
+	s3c_device_sdi.dev.platform_data = &gta02_s3c_mmc_cfg;
+
+	/* acc sensor chip selects */
+	s3c2410_gpio_setpin(S3C2410_GPD12, 1);
+	s3c2410_gpio_cfgpin(S3C2410_GPD12, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_setpin(S3C2410_GPD13, 1);
+	s3c2410_gpio_cfgpin(S3C2410_GPD13, S3C2410_GPIO_OUTPUT);
+
+	s3c24xx_udc_set_platdata(&gta02_udc_cfg);
+	s3c_i2c0_set_platdata(NULL);
+	set_s3c2410ts_info(&gta02_ts_cfg);
+	
+	mangle_glamo_res_by_system_rev();
+
+	i2c_register_board_info(0, gta02_i2c_devs, ARRAY_SIZE(gta02_i2c_devs));
+	spi_register_board_info(gta02_spi_board_info,
+				ARRAY_SIZE(gta02_spi_board_info));
+
+	mangle_pmu_pdata_by_system_rev();
+
+	platform_add_devices(gta02_devices, ARRAY_SIZE(gta02_devices));
+
+	s3c_pm_init();
+
+	/* Make sure the modem can wake us up */
+	set_irq_type(GTA02_IRQ_MODEM, IRQ_TYPE_EDGE_RISING);
+	rc = request_irq(GTA02_IRQ_MODEM, gta02_modem_irq, IRQF_DISABLED,
+			 "modem", NULL);
+	if (rc < 0)
+		printk(KERN_ERR "GTA02: can't request GSM modem wakeup IRQ\n");
+	enable_irq_wake(GTA02_IRQ_MODEM);
+
+	/* Make sure the wifi module can wake us up*/
+	set_irq_type(GTA02_IRQ_WLAN_GPIO1, IRQ_TYPE_EDGE_RISING);
+	rc = request_irq(GTA02_IRQ_WLAN_GPIO1, ar6000_wow_irq, IRQF_DISABLED,
+			"ar6000", NULL);
+
+	if (rc < 0)
+		printk(KERN_ERR "GTA02: can't request ar6k wakeup IRQ\n");
+	enable_irq_wake(GTA02_IRQ_WLAN_GPIO1);
+
+	pm_power_off = gta02_poweroff;
+
+	/* Register the HDQ and vibrator as children of pwm device */
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+	gta02_hdq_device.dev.parent = &s3c24xx_pwm_device.dev;
+	platform_device_register(&gta02_hdq_device);
+#endif
+#ifdef CONFIG_LEDS_NEO1973_VIBRATOR
+	gta02_vibrator_dev.dev.parent = &s3c24xx_pwm_device.dev; 
+	platform_device_register(&gta02_vibrator_dev);
+#endif
+}
+
+void DEBUG_LED(int n)
+{
+//	int *p = NULL;
+	switch (n) {
+	case 0:
+		neo1973_gpb_setpin(GTA02_GPIO_PWR_LED1, 1);
+		break;
+	case 1:
+		neo1973_gpb_setpin(GTA02_GPIO_PWR_LED2, 1);
+		break;
+	default:
+		neo1973_gpb_setpin(GTA02_GPIO_AUX_LED, 1);
+		break;
+	}
+//	printk(KERN_ERR"die %d\n", *p);
+}
+EXPORT_SYMBOL_GPL(DEBUG_LED);
+
+MACHINE_START(NEO1973_GTA02, "GTA02")
+	.phys_io	= S3C2410_PA_UART,
+	.io_pg_offst	= (((u32)S3C24XX_VA_UART) >> 18) & 0xfffc,
+	.boot_params	= S3C2410_SDRAM_PA + 0x100,
+	.map_io		= gta02_map_io,
+	.init_irq	= s3c24xx_init_irq,
+	.init_machine	= gta02_machine_init,
+	.timer		= &s3c24xx_timer,
+MACHINE_END
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/Makefile	2009-05-10 22:05:02.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -9,8 +9,11 @@
 obj-n				:=
 obj-				:=
 
+obj-$(CONFIG_S3C2440_C_FIQ)	+= fiq_c_isr.o
+
 obj-$(CONFIG_CPU_S3C2442)	+= s3c2442.o
 obj-$(CONFIG_CPU_S3C2442)	+= clock.o
+obj-$(CONFIG_MACH_NEO1973_GTA02) += mach-gta02.o
 
 # Machine support
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/s3c2442.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/s3c2442.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2442/s3c2442.c	2009-05-10 22:05:02.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2442/s3c2442.c	2009-05-10 22:27:59.000000000 +0200
@@ -21,6 +21,7 @@
 
 #include <plat/s3c2442.h>
 #include <plat/cpu.h>
+#include <plat/devs.h>
 
 static struct sys_device s3c2442_sysdev = {
 	.cls		= &s3c2442_sysclass,
@@ -30,5 +31,8 @@
 {
 	printk("S3C2442: Initialising architecture\n");
 
+	/* make sure SD/MMC driver can distinguish 2440 from 2410 */
+	s3c_device_sdi.name = "s3c2440-sdi";
+
 	return sysdev_register(&s3c2442_sysdev);
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2443/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2443/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c2443/dma.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c2443/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -20,16 +20,17 @@
 
 #include <mach/dma.h>
 
-#include <plat/dma.h>
+#include <plat/dma-plat.h>
 #include <plat/cpu.h>
 
 #include <plat/regs-serial.h>
 #include <mach/regs-gpio.h>
 #include <plat/regs-ac97.h>
+#include <plat/regs-dma.h>
 #include <mach/regs-mem.h>
 #include <mach/regs-lcd.h>
 #include <mach/regs-sdi.h>
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
 #include <plat/regs-spi.h>
 
 #define MAP(x) { \
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c24a0/include/mach/io.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c24a0/include/mach/io.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c24a0/include/mach/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c24a0/include/mach/io.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,16 @@
+/* arch/arm/mach-s3c24a0/include/mach/io.h
+ *
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben-linux@fluff.org>
+ *
+ * IO access and mapping routines for the S3C24A0
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+/* No current ISA/PCI bus support. */
+#define __io(a)		((void __iomem *)(a))
+#define __mem_pci(a)	(a)
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c24a0/include/mach/irqs.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c24a0/include/mach/irqs.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c24a0/include/mach/irqs.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c24a0/include/mach/irqs.h	2009-05-10 22:27:59.000000000 +0200
@@ -70,6 +70,8 @@
 #define IRQ_EINT17	S3C2410_IRQ(49)
 #define IRQ_EINT18	S3C2410_IRQ(50)
 
+#define IRQ_EINT_BIT(x) ((x) - IRQ_EINT00)
+
 /* SUB IRQS */
 #define IRQ_S3CUART_RX0		S3C2410_IRQ(51)	/* 67 */
 #define IRQ_S3CUART_TX0		S3C2410_IRQ(52)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/dma.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/dma.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/dma.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/dma.h	2009-05-10 22:27:59.000000000 +0200
@@ -11,6 +11,63 @@
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H __FILE__
 
-/* currently nothing here, placeholder */
+#define S3C_DMA_CHANNELS	(16)
+
+/* see mach-s3c2410/dma.h for notes on dma channel numbers */
+
+/* Note, for the S3C64XX architecture we keep the DMACH_
+ * defines in the order they are allocated to [S]DMA0/[S]DMA1
+ * so that is easy to do DHACH_ -> DMA controller conversion
+ */ 
+enum dma_ch {
+	/* DMA0/SDMA0 */
+	DMACH_UART0 = 0,
+	DMACH_UART0_SRC2,
+	DMACH_UART1,
+	DMACH_UART1_SRC2,
+	DMACH_UART2,
+	DMACH_UART2_SRC2,
+	DMACH_UART3,
+	DMACH_UART3_SRC2,
+	DMACH_PCM0_TX,
+	DMACH_PCM0_RX,
+	DMACH_I2S0_OUT,
+	DMACH_I2S0_IN,
+	DMACH_SPI0_TX,
+	DMACH_SPI0_RX,
+	DMACH_HSI_I2SV40_TX,
+	DMACH_HSI_I2SV40_RX,
+
+	/* DMA1/SDMA1 */
+	DMACH_PCM1_TX = 16,
+	DMACH_PCM1_RX,
+	DMACH_I2S1_OUT,
+	DMACH_I2S1_IN,
+	DMACH_SPI1_TX,
+	DMACH_SPI1_RX,
+	DMACH_AC97_PCMOUT,
+	DMACH_AC97_PCMIN,
+	DMACH_AC97_MICIN,
+	DMACH_PWM, 
+	DMACH_IRDA,
+	DMACH_EXTERNAL,
+	DMACH_RES1,
+	DMACH_RES2,
+	DMACH_SECURITY_RX,	/* SDMA1 only */
+	DMACH_SECURITY_TX,	/* SDMA1 only */
+	DMACH_MAX		/* the end */
+};
+
+static __inline__ int s3c_dma_has_circular(void)
+{
+	/* we will be supporting ciruclar buffers as soon as we have DMA
+	 * engine support.
+	 */
+	return 1;
+}
+
+#define S3C2410_DMAF_CIRCULAR		(1 << 0)
+
+#include <plat/dma.h>
 
 #endif /* __ASM_ARCH_IRQ_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/map.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/map.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/map.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/map.h	2009-05-10 22:27:59.000000000 +0200
@@ -40,6 +40,8 @@
 
 #define S3C64XX_PA_FB		(0x77100000)
 #define S3C64XX_PA_SYSCON	(0x7E00F000)
+#define S3C64XX_PA_IIS0		(0x7F002000)
+#define S3C64XX_PA_IIS1		(0x7F003000)
 #define S3C64XX_PA_TIMER	(0x7F006000)
 #define S3C64XX_PA_IIC0		(0x7F004000)
 #define S3C64XX_PA_IIC1		(0x7F00F000)
@@ -49,12 +51,21 @@
 #define S3C64XX_SZ_GPIO		SZ_4K
 
 #define S3C64XX_PA_SDRAM	(0x50000000)
+#define S3C64XX_PA_TZIC0	(0x71000000)
+#define S3C64XX_PA_TZIC1	(0x71100000)
 #define S3C64XX_PA_VIC0		(0x71200000)
 #define S3C64XX_PA_VIC1		(0x71300000)
 
+#define S3C64XX_PA_MODEM	(0x74108000)
+#define S3C64XX_VA_MODEM	S3C_ADDR(0x00600000)
+
+#define S3C64XX_PA_USBHOST	(0x74300000)
+
 /* place VICs close together */
 #define S3C_VA_VIC0		(S3C_VA_IRQ + 0x00)
 #define S3C_VA_VIC1		(S3C_VA_IRQ + 0x10000)
+#define S3C_VA_TZIC0		(S3C_VA_IRQ + 0x20000)
+#define S3C_VA_TZIC1		(S3C_VA_IRQ + 0x30000)
 
 /* compatibiltiy defines. */
 #define S3C_PA_TIMER		S3C64XX_PA_TIMER
@@ -64,5 +75,12 @@
 #define S3C_PA_IIC		S3C64XX_PA_IIC0
 #define S3C_PA_IIC1		S3C64XX_PA_IIC1
 #define S3C_PA_FB		S3C64XX_PA_FB
+#define S3C_PA_USBHOST		S3C64XX_PA_USBHOST
+
+#define S3C64XX_VA_OTG		S3C_VA_OTG
+#define S3C64XX_PA_OTG		(0x7C000000)
+
+#define S3C64XX_VA_OTGSFR	S3C_VA_OTGSFR
+#define S3C64XX_PA_OTGSFR	(0x7C100000)
 
 #endif /* __ASM_ARCH_6400_MAP_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/regs-clock.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/regs-clock.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/regs-clock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/regs-clock.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,16 @@
+/* linux/arch/arm/mach-s3c6400/include/mach/regs-clock.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C64XX - clock register compatibility with s3c24xx
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <plat/regs-clock.h>
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/system.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/system.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6400/include/mach/system.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6400/include/mach/system.h	2009-05-10 22:27:59.000000000 +0200
@@ -11,9 +11,29 @@
 #ifndef __ASM_ARCH_SYSTEM_H
 #define __ASM_ARCH_SYSTEM_H __FILE__
 
+#include <linux/io.h>
+#include <mach/map.h>
+
+#include <plat/regs-sys.h>
+#include <plat/regs-syscon-power.h>
+
 static void arch_idle(void)
 {
-	/* nothing here yet */
+	unsigned long flags;
+	u32 mode;
+
+	/* ensure that if we execute the cpu idle sequence that we
+	 * go into idle mode instead of powering off. */
+
+	local_irq_save(flags);
+	mode = __raw_readl(S3C64XX_PWR_CFG);
+	mode &= ~S3C64XX_PWRCFG_CFG_WFI_MASK;
+	mode |= S3C64XX_PWRCFG_CFG_WFI_IDLE;
+	__raw_writel(mode, S3C64XX_PWR_CFG);
+
+	local_irq_restore(flags);
+
+	cpu_do_idle();
 }
 
 static void arch_reset(char mode)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/include/mach/om-3d7k.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/include/mach/om-3d7k.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/include/mach/om-3d7k.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/include/mach/om-3d7k.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,98 @@
+/*
+ * 3D7K GPIO Mappings
+ *
+ * (C) 2008 by Openmoko Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#ifndef _OM_3D7K_H
+#define _OM_3D7K_H
+
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <linux/mfd/pcf50633/core.h>
+
+extern struct pcf50633 *om_3d7k_pcf;
+
+/* ATAG_REVISION from bootloader */
+#define OM_3D7Kv1_SYSTEM_REV	0x00000001
+
+#define OM_3D7K_GPIO_VIBRATOR_ON	S3C64XX_GPF(13)
+#define OM_3D7K_GPIO_CLKOUT		S3C64XX_GPF(14)
+
+#define OM_3D7K_GPIO_ACCEL_MISO		S3C64XX_GPC(0)
+#define OM_3D7K_GPIO_ACCEL_CLK		S3C64XX_GPC(1)
+#define OM_3D7K_GPIO_ACCEL_MOSI		S3C64XX_GPC(2)
+
+#define OM_3D7K_GPIO_LCM_MISO		S3C64XX_GPC(4)
+#define OM_3D7K_GPIO_LCM_CLK		S3C64XX_GPC(5)
+#define OM_3D7K_GPIO_LCM_MOSI		S3C64XX_GPC(6)
+#define OM_3D7K_GPIO_LCM_CS		S3C64XX_GPC(7)
+
+#define OM_3D7K_GPIO_BTPCM_SHARED_SCLK	S3C64XX_GPE(0)
+#define OM_3D7K_GPIO_BTPCM_SHARED_EXTCLK	S3C64XX_GPE(1)
+#define OM_3D7K_GPIO_BTPCM_SHARED_FSYNC	S3C64XX_GPE(2)
+#define OM_3D7K_GPIO_BTPCM_SHARED_SIN	S3C64XX_GPE(3)
+#define OM_3D7K_GPIO_BTPCM_SHARED_SOUT	S3C64XX_GPE(4)
+
+#define OM_3D7K_GPIO_WLAN_RESET		S3C64XX_GPH(6)
+#define OM_3D7K_GPIO_HDQ		S3C64XX_GPH(7)
+#define OM_3D7K_GPIO_WLAN_PWRDN		S3C64XX_GPH(8)
+
+#define OM_3D7K_GPIO_VERSION2		S3C64XX_GPI(0)
+#define OM_3D7K_GPIO_VERSION1		S3C64XX_GPI(1)
+#define OM_3D7K_GPIO_VERSION0		S3C64XX_GPI(8)
+
+#define OM_3D7K_GPIO_NWLAN_POWER	S3C64XX_GPK(0)
+#define OM_3D7K_GPIO_MODEM_ON		S3C64XX_GPK(2)
+#define OM_3D7K_GPIO_LED_TRIG 		S3C64XX_GPK(3)
+#define OM_3D7K_GPIO_LED_EN 		S3C64XX_GPK(4)
+#define OM_3D7K_GPIO_LCM_RESET 		S3C64XX_GPK(6)
+
+#define OM_3D7K_GPIO_LCM_SD 		S3C64XX_GPL(0)
+
+#define OM_3D7K_GPIO_TP_RESET		S3C64XX_GPM(0)
+#define OM_3D7K_GPIO_GPS_LNA_EN		S3C64XX_GPM(2)
+
+#define OM_3D7K_GPIO_USB_FLT		S3C64XX_GPM(4)
+#define OM_3D7K_GPIO_USB_OC		S3C64XX_GPM(5)
+
+#define OM_3D7K_GPIO_ACCEL_INT1		S3C64XX_GPN(0)
+#define OM_3D7K_GPIO_KEY_MINUS		S3C64XX_GPN(1)
+#define OM_3D7K_GPIO_KEY_PLUS		S3C64XX_GPN(2)
+#define OM_3D7K_GPIO_PWR_IND		S3C64XX_GPN(3)
+#define OM_3D7K_GPIO_PWR_IRQ		S3C64XX_GPN(4)
+#define OM_3D7K_GPIO_TOUCH		S3C64XX_GPN(5)
+#define OM_3D7K_GPIO_JACK_INSERT	S3C64XX_GPN(6)
+#define OM_3D7K_GPIO_GPS_INT		S3C64XX_GPN(7)
+#define OM_3D7K_GPIO_HOLD		S3C64XX_GPN(8)
+#define OM_3D7K_GPIO_WLAN_WAKEUP	S3C64XX_GPN(9)
+#define OM_3D7K_GPIO_ACCEL_INT2		S3C64XX_GPN(10)
+#define OM_3D7K_GPIO_IO1		S3C64XX_GPN(11)
+#define OM_3D7K_GPIO_NONKEYWAKE		S3C64XX_GPN(12)
+
+#define OM_3D7K_GPIO_N_MODEM_RESET	S3C64XX_GPO(1)
+
+#define OM_3D7K_IRQ_GSENSOR_1	S3C_EINT(0)
+#define OM_3D7K_IRQ_KEY_MINUS	S3C_EINT(1)
+#define OM_3D7K_IRQ_KEY_PLUS	S3C_EINT(2)
+#define OM_3D7K_IRQ_PWR_IND	S3C_EINT(3)
+#define OM_3D7K_IRQ_PMU		S3C_EINT(4)
+#define OM_3D7K_IRQ_TOUCH	S3C_EINT(5)
+#define OM_3D7K_IRQ_JACK_INSERT	S3C_EINT(6)
+#define OM_3D7K_IRQ_GPS_INT	S3C_EINT(7)
+#define OM_3D7K_IRQ_NHOLD	S3C_EINT(8)
+#define OM_3D7K_IRQ_WLAN_WAKEUP	S3C_EINT(9)
+#define OM_3D7K_IRQ_GSENSOR_2	S3C_EINT(10)
+#define OM_3D7K_IRQ_IO1		S3C_EINT(11)
+#define OM_3D7K_IRQ_NONKEYWAKE	S3C_EINT(12)
+
+#define OM_3D7K_IRQ_LED 	IRQ_EINT_GROUP(6, 9)
+
+#endif /* _OM_3D7K_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/include/mach/spi-gpio.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/include/mach/spi-gpio.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/include/mach/spi-gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/include/mach/spi-gpio.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,28 @@
+/* arch/arm/mach-s3c6400/include/mach/spi-gpio.h
+ *
+ * Copyright (c) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C64XX - SPI Controller platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_SPIGPIO_H
+#define __ASM_ARCH_SPIGPIO_H __FILE__
+
+struct s3c64xx_spigpio_info {
+	unsigned long		 pin_clk;
+	unsigned long		 pin_mosi;
+	unsigned long		 pin_miso;
+
+	int			 bus_num;
+	int			 num_chipselect;
+
+	void (*chip_select)(struct s3c64xx_spigpio_info *spi, int csid, int cs);
+};
+
+
+#endif /* __ASM_ARCH_SPIGPIO_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/Kconfig	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -26,6 +26,7 @@
 	select S3C_DEV_HSMMC1
 	select S3C_DEV_I2C1
 	select S3C_DEV_FB
+	select S3C_DEV_USB_HOST
 	select S3C6410_SETUP_SDHCI
 	select S3C64XX_SETUP_I2C1
 	select S3C64XX_SETUP_FB_24BPP
@@ -60,3 +61,25 @@
 	  channels 0 and 1 are the same.
 
 endchoice
+
+config MACH_OM_3D7K
+        bool "Openmoko 3D7K Phone"
+	select CPU_S3C6410
+	select S3C_DEV_HSMMC
+	select S3C_DEV_HSMMC1
+	select S3C_DEV_I2C1
+	select S3C_DEV_USB_HOST
+	select S3C6410_SETUP_SDHCI
+	select S3C64XX_SETUP_I2C1
+	select S3C_DEV_FB
+	select S3C_DEV_CAMIF
+	select S3C64XX_SETUP_FB_24BPP
+#	select SENSORS_PCF50633
+	select POWER_SUPPLY
+	select HDQ_GPIO_BITBANG
+	select S3C_PWM
+	select FIQ
+	select MACH_NEO1973
+	help
+          Machine support for the Openmoko 3D7K Phone
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/mach-om-3d7k.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/mach-om-3d7k.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/mach-om-3d7k.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/mach-om-3d7k.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1196 @@
+/* linux/arch/arm/mach-s3c6410/mach-om-3d7k.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Andy Green <andy@openmoko.org>
+ *
+ * based on mach_smdk6410.c which is
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/serial_core.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/i2c.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/lis302dl.h>
+#include <linux/lp5521.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/l1k002.h>
+#include <linux/pcap7200.h>
+#include <linux/bq27000_battery.h>
+#include <linux/hdq.h>
+#include <linux/jbt6k74.h>
+
+#include <video/platform_lcd.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <asm/hardware/vic.h>
+#include <asm/hardware/tzic-sp890.h>
+#include <mach/map.h>
+#include <mach/regs-fb.h>
+#include <mach/spi-gpio.h>
+
+#include <asm/irq.h>
+#include <asm/mach-types.h>
+#include <asm/fiq.h>
+
+#include <plat/regs-serial.h>
+#include <plat/regs-timer.h>
+#include <plat/regs-gpio.h>
+#include <plat/iic.h>
+#include <plat/fb.h>
+#include <plat/gpio-cfg.h>
+#include <plat/pm.h>
+#include <plat/pwm.h>
+
+#include <plat/s3c6410.h>
+#include <plat/clock.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+#include <plat/tzic-sp890.h>
+#include <plat/usb-control.h>
+
+/* #include <plat/udc.h> */
+#include <linux/i2c.h>
+#include <linux/backlight.h>
+#include <linux/regulator/machine.h>
+
+#include <mach/om-3d7k.h>
+
+#include <linux/mfd/pcf50633/core.h>
+#include <linux/mfd/pcf50633/mbc.h>
+#include <linux/mfd/pcf50633/adc.h>
+#include <linux/mfd/pcf50633/gpio.h>
+#include <linux/mfd/pcf50633/pmic.h>
+
+#include <plat/regs-usb-hs-otg.h>
+
+extern struct platform_device s3c_device_usbgadget;
+extern struct platform_device s3c_device_camif; /* @@@ change plat/devs.h */
+
+
+/* -------------------------------------------------------------------------------
+ * OM_3D7K FIQ related
+ *
+ * Calls into vibrator and hdq and based on the return values
+ * determines if we the FIQ source be kept alive
+ */
+
+#define DIVISOR_FROM_US(x) ((x) * 23)
+
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+#define FIQ_DIVISOR_HDQ DIVISOR_FROM_US(HDQ_SAMPLE_PERIOD_US)
+extern int hdq_fiq_handler(void);
+#endif
+
+/* Global data related to our fiq source */
+static u32 om_3d7k_fiq_ack_mask;
+static u32 om_3d7k_fiq_mod_mask;
+static struct s3c2410_pwm om_3d7k_fiq_pwm_timer;
+static u16 om_3d7k_fiq_timer_index;
+static int om_3d7k_fiq_irq;
+
+/* Convinience defines */
+#define S3C6410_INTMSK	(S3C_VA_VIC0 + VIC_INT_ENABLE)
+#define S3C6410_INTMOD	(S3C_VA_VIC0 + VIC_INT_SELECT)
+
+
+
+static void om_3d7k_fiq_handler(void)
+{
+	u16 divisor = 0xffff;
+
+	/* Vibrator servicing */
+
+	/* disable further timer interrupts if nobody has any work
+	 * or adjust rate according to who still has work
+	 *
+	 * CAUTION: it means forground code must disable FIQ around
+	 * its own non-atomic S3C2410_INTMSK changes... not common
+	 * thankfully and taken care of by the fiq-basis patch
+	 */
+
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+	if (hdq_fiq_handler())
+		divisor = (u16)FIQ_DIVISOR_HDQ;
+#endif
+
+	if (divisor == 0xffff) /* mask the fiq irq source */
+		__raw_writel((__raw_readl(S3C64XX_TINT_CSTAT) & 0x1f) & ~(1 << 3),
+							    S3C64XX_TINT_CSTAT);
+	else /* still working, maybe at a different rate */
+		__raw_writel(divisor, S3C2410_TCNTB(om_3d7k_fiq_timer_index));
+
+	__raw_writel((__raw_readl(S3C64XX_TINT_CSTAT) & 0x1f ) | 1 << 8 , S3C64XX_TINT_CSTAT);
+
+}
+
+static void om_3d7k_fiq_kick(void)
+{
+	unsigned long flags;
+	u32 tcon;
+	
+	/* we have to take care about FIQ because this modification is
+	 * non-atomic, FIQ could come in after the read and before the
+	 * writeback and its changes to the register would be lost
+	 * (platform INTMSK mod code is taken care of already)
+	 */
+	local_save_flags(flags);
+	local_fiq_disable();
+	/* allow FIQs to resume   */
+	__raw_writel((__raw_readl(S3C64XX_TINT_CSTAT)  & 0x1f)| 1 << 3,
+							    S3C64XX_TINT_CSTAT);
+
+	tcon = __raw_readl(S3C2410_TCON) & ~S3C2410_TCON_T3START; 
+	/* fake the timer to a count of 1 */
+	__raw_writel(1, S3C2410_TCNTB(om_3d7k_fiq_timer_index));
+	__raw_writel(tcon | S3C2410_TCON_T3MANUALUPD, S3C2410_TCON);
+	__raw_writel(tcon | S3C2410_TCON_T3MANUALUPD | S3C2410_TCON_T3START,
+		     S3C2410_TCON);
+	__raw_writel(tcon | S3C2410_TCON_T3START, S3C2410_TCON);
+	local_irq_restore(flags);
+}
+
+static int om_3d7k_fiq_enable(void)
+{
+	int irq_index_fiq = IRQ_TIMER3_VIC;
+	int rc = 0;
+
+	local_fiq_disable();
+
+	om_3d7k_fiq_irq = irq_index_fiq;
+	om_3d7k_fiq_ack_mask = 1 << 3;
+	om_3d7k_fiq_mod_mask = 1 << 27;
+	om_3d7k_fiq_timer_index = 3;
+
+	/* set up the timer to operate as a pwm device */
+
+	rc = s3c2410_pwm_init(&om_3d7k_fiq_pwm_timer);
+	if (rc)
+		goto bail;
+
+	om_3d7k_fiq_pwm_timer.timerid = PWM0 + om_3d7k_fiq_timer_index;
+	om_3d7k_fiq_pwm_timer.prescaler = ((6 - 1) / 2);
+	om_3d7k_fiq_pwm_timer.divider = S3C64XX_TCFG1_MUX_DIV2 << S3C2410_TCFG1_SHIFT(3);
+	/* default rate == ~32us */
+	om_3d7k_fiq_pwm_timer.counter = om_3d7k_fiq_pwm_timer.comparer = 3000;
+
+	rc = s3c2410_pwm_enable(&om_3d7k_fiq_pwm_timer);
+	if (rc)
+		goto bail;
+
+	/* let our selected interrupt be a magic FIQ interrupt */
+	__raw_writel(om_3d7k_fiq_mod_mask, S3C6410_INTMSK + 4);
+	__raw_writel(om_3d7k_fiq_mod_mask, S3C6410_INTMOD);
+	__raw_writel(om_3d7k_fiq_mod_mask, S3C6410_INTMSK);
+
+	__raw_writel(SP890_TZIC_UNLOCK_MAGIC, S3C64XX_VA_TZIC0_LOCK);
+	__raw_writel(om_3d7k_fiq_mod_mask, S3C64XX_VA_TZIC0_FIQENABLE);
+	__raw_writel(om_3d7k_fiq_mod_mask, S3C64XX_VA_TZIC0_INTSELECT);
+
+	s3c2410_pwm_start(&om_3d7k_fiq_pwm_timer);
+
+	/* it's ready to go as soon as we unmask the source in S3C2410_INTMSK */
+	local_fiq_enable();
+
+	set_fiq_c_handler(om_3d7k_fiq_handler);
+
+	if (rc < 0)
+		goto bail;
+
+	return 0;
+bail:
+	printk(KERN_ERR "Count not initialize FIQ for OM_3D7K %d \n", rc);
+	return rc;
+}
+
+static void om_3d7k_fiq_disable(void)
+{
+	__raw_writel(0, S3C6410_INTMOD);
+	local_fiq_disable();
+	om_3d7k_fiq_irq = 0; /* no active source interrupt now either */
+
+}
+/* -------------------- /OM_3D7K FIQ Handler ------------------------------------- */
+
+#define UCON S3C2410_UCON_DEFAULT | S3C2410_UCON_UCLK
+#define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
+#define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
+
+static struct s3c2410_uartcfg om_3d7k_uartcfgs[] __initdata = {
+	[0] = {
+		.hwport	     = 0,
+		.flags	     = 0,
+		.ucon	     = 0x3c5,
+		.ulcon	     = 0x03,
+		.ufcon	     = 0x51,
+	},
+	[1] = {
+		.hwport	     = 1,
+		.flags	     = 0,
+		.ucon	     = 0x3c5,
+		.ulcon	     = 0x03,
+		.ufcon	     = 0x51,
+	},
+	[2] = {
+		.hwport      = 2,
+		.flags       = 0,
+		.ucon        = 0x3c5,
+		.ulcon       = 0x03,
+		.ufcon       = 0x51,
+	},
+	[3] = {
+		.hwport      = 3,
+		.flags       = 0,
+		.ucon        = 0x3c5,
+		.ulcon       = 0x03,
+		.ufcon       = 0x51,
+	},
+};
+
+
+/*
+ * Situation is that Linux SPI can't work in an interrupt context, so we
+ * implement our own bitbang here.  Arbitration is needed because not only
+ * can this interrupt happen at any time even if foreground wants to use
+ * the bitbang API from Linux, but multiple motion sensors can be on the
+ * same SPI bus, and multiple interrupts can happen.
+ *
+ * Foreground / interrupt arbitration is okay because the interrupts are
+ * disabled around all the foreground SPI code.
+ *
+ * Interrupt / Interrupt arbitration is evidently needed, otherwise we
+ * lose edge-triggered service after a while due to the two sensors sharing
+ * the SPI bus having irqs at the same time eventually.
+ *
+ * Servicing is typ 75 - 100us at 400MHz.
+ */
+
+/* #define DEBUG_SPEW_MS */
+#define MG_PER_SAMPLE 18
+
+struct lis302dl_platform_data lis302_pdata;
+
+/*
+ * generic SPI RX and TX bitbang
+ * only call with interrupts off!
+ */
+
+static void __3d7k_lis302dl_bitbang(struct lis302dl_info *lis, u8 *tx,
+					     int tx_bytes, u8 *rx, int rx_bytes)
+{
+	struct lis302dl_platform_data *pdata = lis->pdata;
+	int n;
+	u8 shifter = 0;
+
+	gpio_direction_output(pdata->pin_chip_select, 1);
+	gpio_direction_output(pdata->pin_clk, 1);
+	gpio_direction_output(pdata->pin_chip_select, 0);
+
+	/* send the register index, r/w and autoinc bits */
+	for (n = 0; n < (tx_bytes << 3); n++) {
+		if (!(n & 7))
+			shifter = ~tx[n >> 3];
+		gpio_direction_output(pdata->pin_clk, 0);
+		gpio_direction_output(pdata->pin_mosi, !(shifter & 0x80));
+		gpio_direction_output(pdata->pin_clk, 1);
+		shifter <<= 1;
+	}
+
+	for (n = 0; n < (rx_bytes << 3); n++) { /* 8 bits each */
+		gpio_direction_output(pdata->pin_clk, 0);
+		shifter <<= 1;
+		if (gpio_direction_input(pdata->pin_miso))
+			shifter |= 1;
+		if ((n & 7) == 7)
+			rx[n >> 3] = shifter;
+		gpio_direction_output(pdata->pin_clk, 1);
+	}
+	gpio_direction_output(pdata->pin_chip_select, 1);
+}
+
+
+static int om_3d7k_lis302dl_bitbang_read_reg(struct lis302dl_info *lis, u8 reg)
+{
+	u8 data = 0xc0 | reg; /* read, autoincrement */
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	__3d7k_lis302dl_bitbang(lis, &data, 1, &data, 1);
+
+	local_irq_restore(flags);
+
+	return data;
+}
+
+static void om_3d7k_lis302dl_bitbang_write_reg(struct lis302dl_info *lis, u8 reg,
+									 u8 val)
+{
+	u8 data[2] = { 0x00 | reg, val }; /* write, no autoincrement */
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	__3d7k_lis302dl_bitbang(lis, &data[0], 2, NULL, 0);
+
+	local_irq_restore(flags);
+
+}
+
+
+void om_3d7k_lis302dl_suspend_io(struct lis302dl_info *lis, int resume)
+{
+	struct lis302dl_platform_data *pdata = lis->pdata;
+
+	if (!resume) {
+		 /*
+		 * we don't want to power them with a high level
+		 * because GSENSOR_3V3 is not up during suspend
+		 */
+		gpio_direction_output(pdata->pin_chip_select, 0);
+		gpio_direction_output(pdata->pin_clk, 0);
+		gpio_direction_output(pdata->pin_mosi, 0);
+		s3c_gpio_setpull(pdata->pin_miso, S3C_GPIO_PULL_DOWN);
+
+		return;
+	}
+
+	/* back to normal */
+	gpio_direction_output(pdata->pin_chip_select, 1);
+	gpio_direction_output(pdata->pin_clk, 1);
+	s3c_gpio_setpull(pdata->pin_miso, S3C_GPIO_PULL_NONE);
+
+	s3c_gpio_cfgpin(pdata->pin_chip_select, S3C_GPIO_SFN(1));
+	s3c_gpio_cfgpin(pdata->pin_clk, S3C_GPIO_SFN(1));
+	s3c_gpio_cfgpin(pdata->pin_mosi, S3C_GPIO_SFN(1));
+	s3c_gpio_cfgpin(pdata->pin_miso, S3C_GPIO_SFN(0));
+
+}
+#if 0
+struct lis302dl_platform_data lis302_pdata = {
+		.name		= "lis302",
+		.pin_chip_select= S3C64XX_GPC(3), /* NC */
+		.pin_clk	= OM_3D7K_GPIO_ACCEL_CLK,
+		.pin_mosi	= OM_3D7K_GPIO_ACCEL_MOSI,
+		.pin_miso	= OM_3D7K_GPIO_ACCEL_MISO,
+		.interrupt	= OM_3D7K_IRQ_GSENSOR_1,
+		.open_drain	= 0,
+		.lis302dl_bitbang = __3d7k_lis302dl_bitbang,
+		.lis302dl_bitbang_reg_read = om_3d7k_lis302dl_bitbang_read_reg,
+		.lis302dl_bitbang_reg_write = om_3d7k_lis302dl_bitbang_write_reg,
+		.lis302dl_suspend_io = om_3d7k_lis302dl_suspend_io,
+};
+
+static struct platform_device s3c_device_spi_acc1 = {
+	.name		  = "lis302dl",
+	.id		  = 1,
+	.dev = {
+		.platform_data = &lis302_pdata,
+	},
+};
+
+#endif
+
+/* framebuffer and LCD setup. */
+
+/* GPF15 = LCD backlight control
+ * GPF13 => Panel power
+ * GPN5 = LCD nRESET signal
+ * PWM_TOUT1 => backlight brightness
+ */
+
+static void om_3d7k_lcd_power_set(struct plat_lcd_data *pd,
+				   unsigned int power)
+{
+
+}
+
+static struct plat_lcd_data om_3d7k_lcd_power_data = {
+	.set_power	= om_3d7k_lcd_power_set,
+};
+
+static struct platform_device om_3d7k_lcd_powerdev = {
+	.name			= "platform-lcd",
+	.dev.parent		= &s3c_device_fb.dev,
+	.dev.platform_data	= &om_3d7k_lcd_power_data,
+};
+
+static struct s3c_fb_pd_win om_3d7k_fb_win0 = {
+	/* this is to ensure we use win0 */
+	.win_mode	= {
+		.pixclock	= 40816,
+		.left_margin	= 8,
+		.right_margin	= 16,
+		.upper_margin	= 2,
+		.lower_margin	= 16,
+		.hsync_len	= 8,
+		.vsync_len	= 2,
+		.xres		= 480,
+		.yres		= 640,
+	},
+	.max_bpp	= 32,
+	.default_bpp	= 16,
+};
+
+static void om_3d7k_fb_gpio_setup(void)
+{
+	unsigned int gpio;
+
+	/* GPI0, GPI1, GPI8 are for hardware version contrl.
+	 * They should be set as input in order to prevent
+	 * current leaking
+	 */
+	for (gpio = S3C64XX_GPI(2); gpio <= S3C64XX_GPI(15); gpio++) {
+		if (gpio != S3C64XX_GPI(8)) {
+			s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+			s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+		}
+	}
+
+	for (gpio = S3C64XX_GPJ(0); gpio <= S3C64XX_GPJ(11); gpio++) {
+		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+	}
+}
+
+static struct s3c_fb_platdata om_3d7k_lcd_pdata __initdata = {
+	.setup_gpio	= om_3d7k_fb_gpio_setup,
+	.win[0]		= &om_3d7k_fb_win0,
+	.vidcon0	= VIDCON0_VIDOUT_RGB | VIDCON0_PNRMODE_RGB,
+	.vidcon1	= VIDCON1_INV_HSYNC | VIDCON1_INV_VSYNC,
+};
+
+
+struct map_desc om_3d7k_6410_iodesc[] = {};
+
+static struct resource om_3d7k_button_resources[] = {
+	[0] = {
+		.start = 0,
+		.end   = 0,
+	},
+	[1] = {
+		.start = OM_3D7K_GPIO_HOLD,
+		.end   = OM_3D7K_GPIO_HOLD,
+	},
+	[2] = {
+		.start = OM_3D7K_GPIO_JACK_INSERT,
+		.end   = OM_3D7K_GPIO_JACK_INSERT,
+	},
+	[3] = {
+		.start = OM_3D7K_GPIO_KEY_PLUS,
+		.end   = OM_3D7K_GPIO_KEY_PLUS,
+	},
+	[4] = {
+		.start = OM_3D7K_GPIO_KEY_MINUS,
+		.end   = OM_3D7K_GPIO_KEY_MINUS,
+	},
+};
+
+static struct platform_device om_3d7k_button_dev = {
+	.name		= "neo1973-button",
+	.num_resources	= ARRAY_SIZE(om_3d7k_button_resources),
+	.resource	= om_3d7k_button_resources,
+};
+
+
+/********************** PMU ***************************/
+/*
+ * OM_3D7K PMU Mapping info
+ *
+ *  name  maxcurr  default    Nom   consumers
+ *
+ *  AUTO   1100mA  ON  3.3V   3.3V  Main 3.3V rail
+ *  DOWN1   500mA  ON  1.2V   1.2V  CPU VddARM, VddINT, VddMPLL, VddOTGI
+ *  DOWN2   500mA  ON  1.8V   1.8V  CPU VddAlive via LDO, Memories, WLAN
+ *  LED      25mA  OFF        18V   Backlight
+ *  HCLDO   200mA  OFF        2.8V  Camera 2V8
+ *  LDO1     50mA  ON  3.3V   3.3V  Accel
+ *  LDO2     50mA  OFF        1.5V  Camera 1V5
+ *  LDO3     50mA  OFF        3.3V  CODEC 3.3V
+ *  LDO4    150mA  ON  2.8V   2.7V  uSD power
+ *  LDO5    150mA  OFF        3.0V  GPS 3V
+ *  LDO6     50mA  ON  3.0V   3.0V  LCM 3V
+ *
+ */
+
+
+/* PMU driver info */
+
+
+static struct regulator_consumer_supply ldo4_consumers[] = {
+	{
+		.dev = &s3c_device_hsmmc0.dev,
+		.supply = "SD_3V",
+	},
+};
+
+static struct platform_device om_3d7k_features_dev = {
+	.name		= "om-3d7k",
+};
+
+static struct regulator_consumer_supply ldo5_consumers[] = {
+	{
+		.dev = &om_3d7k_features_dev.dev,
+		.supply = "RF_3V",
+	},
+};
+
+
+static void om_3d7k_pmu_event_callback(struct pcf50633 *pcf, int irq)
+{
+#if 0
+	if (irq == PCF50633_IRQ_USBINS) {
+		schedule_delayed_work(&om_3d7k_charger_work,
+				GTA02_CHARGER_CONFIGURE_TIMEOUT);
+		return;
+	} else if (irq == PCF50633_IRQ_USBREM) {
+		cancel_delayed_work_sync(&om_3d7k_charger_work);
+		pcf50633_mbc_usb_curlim_set(pcf, 0);
+		om_3d7k_usb_vbus_draw = 0;
+	}
+
+	bq27000_charging_state_change(&bq27000_battery_device);
+#endif
+}
+
+static void om_3d7k_pcf50633_attach_child_devices(struct pcf50633 *pcf);
+static void om_3d7k_pmu_regulator_registered(struct pcf50633 *pcf, int id);
+
+/* Global reference */
+struct pcf50633 *om_3d7k_pcf;
+
+struct pcf50633_platform_data om_3d7k_pcf_pdata = {
+
+	.resumers = {
+		[0] = PCF50633_INT1_USBINS |
+		      PCF50633_INT1_USBREM |
+		      PCF50633_INT1_ALARM,
+		[1] = PCF50633_INT2_ONKEYF,
+		[2] = PCF50633_INT3_ONKEY1S
+	},
+	.chg_ref_current_ma = 1000,
+	.reg_init_data = {
+		/* OM_3D7K: Main 3.3V rail */
+		[PCF50633_REGULATOR_AUTO] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* OM_3D7K: CPU core power */
+		[PCF50633_REGULATOR_DOWN1] = {
+			.constraints = {
+				.min_uV = 900000,
+				.max_uV = 1200000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* OM_3D7K: Memories */
+		[PCF50633_REGULATOR_DOWN2] = {
+			.constraints = {
+				.min_uV = 1800000,
+				.max_uV = 1800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* OM_3D7K: Camera 2V8 */
+		[PCF50633_REGULATOR_HCLDO] = {
+			.constraints = {
+				.min_uV = 2800000,
+				.max_uV = 2800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+			},
+			.num_consumer_supplies = 0,
+/*			.consumer_supplies = hcldo_consumers, */
+		},
+
+		/* OM_3D7K: Accel 3V3 */
+		[PCF50633_REGULATOR_LDO1] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* OM_3D7K: Camera 1V5 */
+		[PCF50633_REGULATOR_LDO2] = {
+			.constraints = {
+				.min_uV = 1500000,
+				.max_uV = 1500000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* OM_3D7K: Codec 3.3V */
+		[PCF50633_REGULATOR_LDO3] = {
+			.constraints = {
+				.min_uV = 3300000,
+				.max_uV = 3300000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+				.always_on = 1,
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* OM_3D7K: uSD Power */
+		[PCF50633_REGULATOR_LDO4] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 1,
+			.consumer_supplies = ldo4_consumers,
+		},
+		/* OM_3D7K: GPS 3V */
+		[PCF50633_REGULATOR_LDO5] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.apply_uV = 1,
+			},
+			.num_consumer_supplies = 1,
+			.consumer_supplies = ldo5_consumers,
+		},
+		/* OM_3D7K: LCM 3V */
+		[PCF50633_REGULATOR_LDO6] = {
+			.constraints = {
+				.min_uV = 3000000,
+				.max_uV = 3000000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+		/* power for memories in suspend */
+		[PCF50633_REGULATOR_MEMLDO] = {
+			.constraints = {
+				.min_uV = 1800000,
+				.max_uV = 1800000,
+				.valid_modes_mask = REGULATOR_MODE_NORMAL,
+				.state_mem = {
+					.enabled = 1,
+				},
+			},
+			.num_consumer_supplies = 0,
+		},
+
+	},
+	.probe_done = om_3d7k_pcf50633_attach_child_devices,
+	.regulator_registered = om_3d7k_pmu_regulator_registered,
+	.mbc_event_callback = om_3d7k_pmu_event_callback,
+};
+
+static void om_3d7k_bl_set_intensity(int intensity)
+{
+	struct pcf50633 *pcf = om_3d7k_pcf;
+	int old_intensity = pcf50633_reg_read(pcf, PCF50633_REG_LEDOUT);
+	int ret;
+
+	intensity >>= 2;
+
+	/*
+	 * One code path that leads here is from a kernel panic. Trying to turn
+	 * the backlight on just gives us a nearly endless stream of complaints
+	 * and accomplishes nothing. We can't win. Just give up.
+	 *
+	 * In the unlikely event that there's another path leading here while
+	 * we're atomic, we print at least a warning.
+	 */
+	if (in_atomic()) {
+		printk(KERN_ERR
+		    "3d7k_bl_set_intensity called while atomic\n");
+		return;
+	}
+
+	old_intensity = pcf50633_reg_read(pcf, PCF50633_REG_LEDOUT);
+	if (intensity == old_intensity)
+		return;
+
+	/* We can't do this anywhere else */
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDDIM, 5);
+
+	if (!(pcf50633_reg_read(pcf, PCF50633_REG_LEDENA) & 3))
+		old_intensity = 0;
+
+	/*
+	 * The PCF50633 cannot handle LEDOUT = 0 (datasheet p60)
+	 * if seen, you have to re-enable the LED unit
+	 */
+	if (!intensity || !old_intensity)
+		pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 0);
+
+	if (!intensity) /* illegal to set LEDOUT to 0 */
+		ret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_LEDOUT, 0x3f,
+									     2);
+	else
+		ret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_LEDOUT, 0x3f,
+			       intensity);
+
+	if (intensity)
+		pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 2);
+
+}
+
+static struct generic_bl_info om_3d7k_bl_info = {
+	.name 			= "om-3d7k-bl",
+	.max_intensity 		= 0xff,
+	.default_intensity 	= 0x7f,
+	.set_bl_intensity 	= om_3d7k_bl_set_intensity,
+};
+
+static struct platform_device om_3d7k_bl_dev = {
+	.name  = "generic-bl",
+	.id  = 1,
+	.dev = {
+		.platform_data = &om_3d7k_bl_info,
+	},
+};
+
+/* BQ27000 Battery */
+static int om_3d7k_get_charger_online_status(void)
+{
+	struct pcf50633 *pcf = om_3d7k_pcf;
+
+	return pcf50633_mbc_get_status(pcf) & PCF50633_MBC_USB_ONLINE;
+}
+
+static int om_3d7k_get_charger_active_status(void)
+{
+	struct pcf50633 *pcf = om_3d7k_pcf;
+
+	return pcf50633_mbc_get_status(pcf) & PCF50633_MBC_USB_ACTIVE;
+}
+
+
+struct bq27000_platform_data bq27000_pdata = {
+	.name = "battery",
+	.rsense_mohms = 20,
+	.hdq_read = hdq_read,
+	.hdq_write = hdq_write,
+	.hdq_initialized = hdq_initialized,
+	.get_charger_online_status = om_3d7k_get_charger_online_status,
+	.get_charger_active_status = om_3d7k_get_charger_active_status
+};
+
+struct platform_device bq27000_battery_device = {
+	.name 		= "bq27000-battery",
+	.dev = {
+		.platform_data = &bq27000_pdata,
+	},
+};
+
+#ifdef CONFIG_HDQ_GPIO_BITBANG
+/* HDQ */
+
+static void om_3d7k_hdq_attach_child_devices(struct device *parent_device)
+{
+		bq27000_battery_device.dev.parent = parent_device;
+		platform_device_register(&bq27000_battery_device);
+}
+
+static void om_3d7k_hdq_gpio_direction_out(void)
+{
+	unsigned long con;
+	void __iomem *regcon = S3C64XX_GPH_BASE; 
+
+	con = __raw_readl(regcon);
+	con &= ~(0xf << 28);
+	con |= 0x01 << 28;
+	__raw_writel(con, regcon);
+
+	/* Set pull-up enabled */
+	con = __raw_readl(regcon + 0x0c);
+	con |= 3 << 14;
+	__raw_writel(con, regcon + 0x0c);
+}
+
+static void om_3d7k_hdq_gpio_direction_in(void)
+{
+	unsigned long con;
+	void __iomem *regcon = S3C64XX_GPH_BASE;
+
+	con = __raw_readl(regcon);
+	con &= ~(0xf << 28);
+	__raw_writel(con, regcon);
+}
+
+static void om_3d7k_hdq_gpio_set_value(int val)
+{
+	u32 dat;
+	void __iomem *base = S3C64XX_GPH_BASE;
+
+	dat = __raw_readl(base + 0x08);
+	if (val)
+		dat |= 1 << 7;
+	else
+		dat &= ~(1 << 7);
+
+	__raw_writel(dat, base + 0x08);
+}
+
+static int om_3d7k_hdq_gpio_get_value(void)
+{
+	u32 dat;
+	void *base = S3C64XX_GPH_BASE;
+	
+	dat = __raw_readl(base + 0x08);
+
+	return dat & (1 << 7);
+}
+
+static struct resource om_3d7k_hdq_resources[] = {
+	[0] = {
+		.start	= S3C64XX_GPH(7),
+		.end	= S3C64XX_GPH(7),
+	},
+};
+
+struct hdq_platform_data om_3d7k_hdq_platform_data = {
+	.attach_child_devices = om_3d7k_hdq_attach_child_devices,
+	.gpio_dir_out = om_3d7k_hdq_gpio_direction_out,
+	.gpio_dir_in = om_3d7k_hdq_gpio_direction_in,
+	.gpio_set = om_3d7k_hdq_gpio_set_value,
+	.gpio_get = om_3d7k_hdq_gpio_get_value,
+
+	.enable_fiq = om_3d7k_fiq_enable,
+	.disable_fiq = om_3d7k_fiq_disable,
+	.kick_fiq = om_3d7k_fiq_kick,
+
+};
+
+struct platform_device om_3d7k_hdq_device = {
+	.name 		= "hdq",
+	.num_resources	= 1,
+	.resource	= om_3d7k_hdq_resources,
+	.dev		= {
+		.platform_data = &om_3d7k_hdq_platform_data,
+	},
+};
+#endif
+
+static void om_3d7k_lp5521_chip_enable(int level)
+{
+	gpio_direction_output(OM_3D7K_GPIO_LED_EN, level);
+	udelay(500);
+}
+
+static struct lp5521_platform_data om_3d7k_lp5521_pdata = {
+	 .channels = {
+		[LP5521_BLUE] = LP5521_CONNECTED,
+		[LP5521_GREEN] = LP5521_CONNECTED,
+		[LP5521_RED] = LP5521_NC,
+	},
+	.ext_enable = om_3d7k_lp5521_chip_enable,
+};
+
+static void om_3d7k_pcap7200_reset(void)
+{
+	gpio_direction_output(OM_3D7K_GPIO_TP_RESET, 1);
+	udelay(10);
+	gpio_direction_output(OM_3D7K_GPIO_TP_RESET, 0);
+}
+
+static struct pcap7200_platform_data om_3d7k_pcap7200_pdata = {
+	.mode = MULTI_TOUCH,
+	.reset = om_3d7k_pcap7200_reset,
+};
+
+static struct i2c_board_info om_3d7k_i2c_devs[] __initdata = {
+	{
+		I2C_BOARD_INFO("pcf50633", 0x73),
+		.irq = OM_3D7K_IRQ_PMU,
+		.platform_data = &om_3d7k_pcf_pdata,
+	},
+	{
+		I2C_BOARD_INFO("pcap7200", 0x0a),
+		.irq = OM_3D7K_IRQ_TOUCH,
+		.platform_data = &om_3d7k_pcap7200_pdata,
+	},
+	{
+		I2C_BOARD_INFO("lp5521", 0x32),
+		/* mark this temporarily, since LED INT is connected
+		 * to EXT group6_9, the handling of EXT group1~group9
+		 * is not implemented. Besides, we don't need this IRQ
+		 * now
+		 */
+#if 0
+		.irq = OM_3D7K_IRQ_LED,
+#endif
+		.platform_data = &om_3d7k_lp5521_pdata,
+	},
+	{
+		I2C_BOARD_INFO("wm8753", 0x1a),
+	},
+};
+
+struct platform_device s3c24xx_pwm_device = {
+	.name 		= "s3c24xx_pwm",
+	.num_resources	= 0,
+};
+
+struct platform_device om_3d7k_device_spi_lcm;
+
+static struct platform_device *om_3d7k_devices[] __initdata = {
+	&s3c_device_fb,
+	&s3c_device_i2c0,
+	&om_3d7k_device_spi_lcm,
+	&s3c_device_usbgadget,
+	&s3c24xx_pwm_device,
+#ifdef CONFIG_S3C_DEV_CAMIF
+	&s3c_device_camif,
+#endif
+};
+
+
+static void om_3d7k_pmu_regulator_registered(struct pcf50633 *pcf, int id)
+{
+	struct platform_device *regulator, *pdev;
+
+	regulator = pcf->regulator_pdev[id];
+
+	switch(id) {
+		case PCF50633_REGULATOR_LDO4:
+			pdev = &s3c_device_hsmmc0; /* uSD card */
+			break;
+		case PCF50633_REGULATOR_LDO5: /* GPS regulator */
+			pdev = &om_3d7k_features_dev;
+			break;
+		case PCF50633_REGULATOR_LDO6:
+			pdev = &om_3d7k_lcd_powerdev;
+			break;
+		default:
+			return;
+	}
+
+	pdev->dev.parent = &regulator->dev;
+	platform_device_register(pdev);
+}
+
+static struct platform_device *om_3d7k_devices_pmu_children[] = {
+	&om_3d7k_button_dev,
+//	&s3c_device_spi_acc1, /* relies on PMU reg for power */
+	&s3c_device_usb,
+};
+
+/* this is called when pc50633 is probed, unfortunately quite late in the
+ * day since it is an I2C bus device.  Here we can belatedly define some
+ * platform devices with the advantage that we can mark the pcf50633 as the
+ * parent.  This makes them get suspended and resumed with their parent
+ * the pcf50633 still around.
+ */
+
+static void om_3d7k_pcf50633_attach_child_devices(struct pcf50633 *pcf)
+{
+	int n;
+
+	om_3d7k_pcf = pcf;
+
+	for (n = 0; n < ARRAY_SIZE(om_3d7k_devices_pmu_children); n++)
+		om_3d7k_devices_pmu_children[n]->dev.parent = pcf->dev;
+
+	platform_add_devices(om_3d7k_devices_pmu_children,
+				     ARRAY_SIZE(om_3d7k_devices_pmu_children));
+
+	/* backlight device should be registered until pcf50633 probe is done */
+	om_3d7k_bl_dev.dev.parent = &om_3d7k_device_spi_lcm.dev;
+	platform_device_register(&om_3d7k_bl_dev);
+
+	/* Switch on backlight. Qi does not do it for us */
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 0x00);
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDDIM, 0x01);
+	pcf50633_reg_write(pcf, PCF50633_REG_LEDENA, 0x01);
+}
+
+static void om_3d7k_l1k002_pwronoff(int level)
+{
+	gpio_direction_output(OM_3D7K_GPIO_LCM_SD, 1);
+	udelay(15);
+
+	gpio_direction_output(OM_3D7K_GPIO_LCM_RESET, !!level);
+
+	if (level){
+		udelay(15);
+		gpio_direction_output(OM_3D7K_GPIO_LCM_SD, 0);
+	}
+}
+
+const struct l1k002_platform_data om_3d7k_l1k002_pdata = {
+	.pwr_onoff = om_3d7k_l1k002_pwronoff,
+};
+
+static struct spi_board_info om_3d7k_spi_board_info[] = {
+	{
+	.modalias	= "l1k002",
+	.platform_data	= &om_3d7k_l1k002_pdata,
+	/* controller_data */
+	/* irq */
+	.max_speed_hz	= 10 * 1000 * 1000,
+	.bus_num	= 1,
+	/* chip_select */
+	},
+};
+
+static void om_3d7k_jbt6k74_probe_completed(struct device *dev)
+{
+	dev_info(dev, "device attached\n");
+}
+
+const struct jbt6k74_platform_data jbt6k74_pdata = {
+	.probe_completed = om_3d7k_jbt6k74_probe_completed,
+};
+
+static struct spi_board_info alt_om_3d7k_spi_board_info[] = {
+	{
+	.modalias	= "jbt6k74",
+	.platform_data	= &jbt6k74_pdata,
+	/* controller_data */
+	/* irq */
+	.max_speed_hz	= 100 * 1000,
+	.bus_num	= 1,
+	/* chip_select */
+	},
+};
+
+static void spi_gpio_cs(struct s3c64xx_spigpio_info *spi, int csidx, int cs)
+{
+	switch (cs) {
+	case BITBANG_CS_ACTIVE:
+		gpio_direction_output(OM_3D7K_GPIO_LCM_CS, 0);
+		break;
+	case BITBANG_CS_INACTIVE:
+		gpio_direction_output(OM_3D7K_GPIO_LCM_CS, 1);
+		break;
+	}
+}
+
+static struct s3c64xx_spigpio_info spi_gpio_cfg = {
+	.pin_clk	= OM_3D7K_GPIO_LCM_CLK,
+	.pin_mosi	= OM_3D7K_GPIO_LCM_MOSI,
+	/* no pinout to MISO */
+	.chip_select	= &spi_gpio_cs,
+	.num_chipselect = 1,
+	.bus_num	= 1,
+};
+
+struct platform_device om_3d7k_device_spi_lcm = {
+	.name		  = "spi_s3c64xx_gpio",
+	.id		  = 1,
+	.dev = {
+		.platform_data = &spi_gpio_cfg,
+	},
+};
+
+static int attached_lcm;
+
+static int __init om3d7k_lcm_probe(char *s)
+{
+	if (!strcmp(s, "jbt6k74"))
+		attached_lcm = 1;
+
+	return 1;
+}
+__setup("om_3d7k_lcm=", om3d7k_lcm_probe);
+
+extern void s3c64xx_init_io(struct map_desc *, int);
+
+struct s3c_plat_otg_data s3c_hs_otg_plat_data = {
+	.phyclk = 0
+};
+
+/* USB */
+static struct s3c2410_hcd_info om3d7k_usb_info = {
+	.port[0]	= {
+		.flags	= S3C_HCDFLG_USED,
+	},
+	.port[1]	= {
+		.flags	= 0,
+	},
+};
+
+static void __init om_3d7k_map_io(void)
+{
+	s3c64xx_init_io(om_3d7k_6410_iodesc, ARRAY_SIZE(om_3d7k_6410_iodesc));
+	s3c24xx_init_clocks(12000000);
+	s3c24xx_init_uarts(om_3d7k_uartcfgs, ARRAY_SIZE(om_3d7k_uartcfgs));
+}
+
+static void __init om_3d7k_machine_init(void)
+{
+	s3c_pm_init();
+
+	s3c_device_usb.dev.platform_data = &om3d7k_usb_info;
+	s3c_device_usbgadget.dev.platform_data = &s3c_hs_otg_plat_data;
+
+	s3c_i2c0_set_platdata(NULL);
+	s3c_fb_set_platdata(&om_3d7k_lcd_pdata);
+
+	i2c_register_board_info(0, om_3d7k_i2c_devs,
+						 ARRAY_SIZE(om_3d7k_i2c_devs));
+	if (attached_lcm)
+		spi_register_board_info(alt_om_3d7k_spi_board_info,
+					ARRAY_SIZE(alt_om_3d7k_spi_board_info));
+	else
+		spi_register_board_info(om_3d7k_spi_board_info,
+		       				ARRAY_SIZE(om_3d7k_spi_board_info));
+
+	platform_add_devices(om_3d7k_devices, ARRAY_SIZE(om_3d7k_devices));
+
+	/* Register the HDQ and vibrator as children of pwm device */
+	om_3d7k_hdq_device.dev.parent = &s3c24xx_pwm_device.dev;
+	platform_device_register(&om_3d7k_hdq_device);
+}
+
+MACHINE_START(OM_3D7K, "OM-3D7K")
+	/* Maintainer: Andy Green <andy@openmoko.com> */
+	.phys_io	= S3C_PA_UART & 0xfff00000,
+	.io_pg_offst	= (((u32)S3C_VA_UART) >> 18) & 0xfffc,
+	.boot_params	= S3C64XX_PA_SDRAM + 0x100,
+
+	.init_irq	= s3c6410_init_irq,
+	.map_io		= om_3d7k_map_io,
+	.init_machine	= om_3d7k_machine_init,
+	.timer		= &s3c24xx_timer,
+MACHINE_END
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/mach-smdk6410.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/mach-smdk6410.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/mach-smdk6410.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/mach-smdk6410.c	2009-05-10 22:27:59.000000000 +0200
@@ -39,14 +39,20 @@
 #include <asm/mach-types.h>
 
 #include <plat/regs-serial.h>
+#include <plat/regs-modem.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-sys.h>
 #include <plat/iic.h>
 #include <plat/fb.h>
+#include <plat/pm.h>
 
 #include <plat/s3c6410.h>
 #include <plat/clock.h>
 #include <plat/devs.h>
 #include <plat/cpu.h>
 
+#include <plat/regs-usb-hs-otg.h>
+
 #define UCON S3C2410_UCON_DEFAULT | S3C2410_UCON_UCLK
 #define ULCON S3C2410_LCON_CS8 | S3C2410_LCON_PNONE | S3C2410_LCON_STOPB
 #define UFCON S3C2410_UFCON_RXTRIG8 | S3C2410_UFCON_FIFOMODE
@@ -141,7 +147,10 @@
 	&s3c_device_i2c0,
 	&s3c_device_i2c1,
 	&s3c_device_fb,
+	&s3c_device_usb,
 	&smdk6410_lcd_powerdev,
+	&s3c_device_usbgadget,
+
 };
 
 static struct i2c_board_info i2c_devs0[] __initdata = {
@@ -155,13 +164,36 @@
 
 static void __init smdk6410_map_io(void)
 {
+	u32 tmp;
+
 	s3c64xx_init_io(smdk6410_iodesc, ARRAY_SIZE(smdk6410_iodesc));
 	s3c24xx_init_clocks(12000000);
 	s3c24xx_init_uarts(smdk6410_uartcfgs, ARRAY_SIZE(smdk6410_uartcfgs));
+
+	/* set the LCD type */
+
+	tmp = __raw_readl(S3C64XX_SPCON);
+	tmp &= ~S3C64XX_SPCON_LCD_SEL_MASK;
+	tmp |= S3C64XX_SPCON_LCD_SEL_RGB;
+	__raw_writel(tmp, S3C64XX_SPCON);
+
+	/* remove the lcd bypass */
+	tmp = __raw_readl(S3C64XX_MODEM_MIFPCON);
+	tmp &= ~MIFPCON_LCD_BYPASS;
+	__raw_writel(tmp, S3C64XX_MODEM_MIFPCON);
 }
 
+struct s3c_plat_otg_data s3c_hs_otg_plat_data = {
+	.phyclk = REF_CLK_OSCC
+};
+
+
 static void __init smdk6410_machine_init(void)
 {
+	s3c_pm_init();
+
+	s3c_device_usbgadget.dev.platform_data = &s3c_hs_otg_plat_data;
+
 	s3c_i2c0_set_platdata(NULL);
 	s3c_i2c1_set_platdata(NULL);
 	s3c_fb_set_platdata(&smdk6410_lcd_pdata);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -21,3 +21,6 @@
 # machine support
 
 obj-$(CONFIG_MACH_SMDK6410)	+= mach-smdk6410.o
+obj-$(CONFIG_MACH_OM_3D7K)	+= mach-om-3d7k.o \
+				   om-3d7k-features.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/om-3d7k-features.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/om-3d7k-features.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/om-3d7k-features.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/om-3d7k-features.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * Support for features of Openmoko 3D7K
+ *
+ * (C) 2008 by Openmoko Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * Somewhat based on the GTA01 / 02 neo1973_pm_ stuff mainly by Harald Welte
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <mach/om-3d7k.h>
+#include <asm/mach-types.h>
+
+#include <linux/regulator/consumer.h>
+#include <linux/mfd/pcf50633/core.h>
+#include <linux/mfd/pcf50633/gpio.h>
+#include <linux/mmc/host.h>
+
+#include <plat/sdhci.h>
+#include <plat/devs.h>
+
+#include <plat/gpio-cfg.h>
+
+enum feature {
+	OM_3D7K_GSM,		/* GSM module */
+	OM_3D7K_USBHOST,	/* USB Host power generation */
+	OM_3D7K_VIB,		/* Vibrator */
+
+	OM_3D7K_FEATURE_COUNT	/* always last */
+};
+
+
+struct om_3d7k_feature_info {
+	const char * name;
+	int depower_on_suspend;
+	int on;
+};
+
+static struct om_3d7k_feature_info feature_info[OM_3D7K_FEATURE_COUNT] = {
+	[OM_3D7K_GSM] =	{ "gsm_power",		0, 0 },
+	[OM_3D7K_USBHOST] =	{ "usbhost_power",	1, 0 },
+	[OM_3D7K_VIB] =	{ "vibrator_power",	1, 0 },
+};
+
+static struct regulator *gps_regulator;
+
+
+
+static void om_3d7k_features_pwron_set_on(enum feature feature)
+{
+	switch (feature) {
+	case OM_3D7K_GSM:
+		/* give power to GSM module */
+		s3c_gpio_setpull(OM_3D7K_GPIO_N_MODEM_RESET, S3C_GPIO_PULL_NONE);
+		s3c_gpio_setpull(OM_3D7K_GPIO_MODEM_ON, S3C_GPIO_PULL_NONE);
+		s3c_gpio_cfgpin(OM_3D7K_GPIO_N_MODEM_RESET, S3C_GPIO_SFN(1));
+		s3c_gpio_cfgpin(OM_3D7K_GPIO_MODEM_ON, S3C_GPIO_SFN(1));
+		gpio_direction_output(OM_3D7K_GPIO_N_MODEM_RESET, 0);
+		gpio_direction_output(OM_3D7K_GPIO_MODEM_ON, 1);
+		msleep(10);
+		gpio_direction_output(OM_3D7K_GPIO_MODEM_ON, 0);
+		msleep(150);
+		gpio_direction_output(OM_3D7K_GPIO_N_MODEM_RESET, 1);
+		msleep(300);
+		gpio_direction_output(OM_3D7K_GPIO_MODEM_ON, 1);
+		break;
+	case OM_3D7K_USBHOST:
+		pcf50633_gpio_set(om_3d7k_pcf, PCF50633_GPO, 1);
+		break;
+	case OM_3D7K_VIB:
+		gpio_direction_output(OM_3D7K_GPIO_VIBRATOR_ON, 1);
+		break;
+	default:
+		break;
+	}
+}
+
+static void om_3d7k_features_pwron_set_off(enum feature feature)
+{
+	switch (feature) {
+	case OM_3D7K_GSM:
+		/* remove power from WLAN / BT module */
+		s3c_gpio_cfgpin(OM_3D7K_GPIO_MODEM_ON, S3C_GPIO_SFN(1));
+		gpio_direction_output(OM_3D7K_GPIO_MODEM_ON, 0);
+		msleep(1100);
+		gpio_direction_output(OM_3D7K_GPIO_MODEM_ON, 1);
+		break;
+	case OM_3D7K_USBHOST:
+		pcf50633_gpio_set(om_3d7k_pcf, PCF50633_GPO, 0);
+		break;
+	case OM_3D7K_VIB:
+		gpio_direction_output(OM_3D7K_GPIO_VIBRATOR_ON, 0);
+		break;
+	default:
+		break;
+	}
+}
+
+static void om_3d7k_features_pwron_set(enum feature feature, int on)
+{
+	if ((on) && (!feature_info[feature].on))
+		om_3d7k_features_pwron_set_on(feature);
+	else
+		if ((!on) && (feature_info[feature].on))
+			om_3d7k_features_pwron_set_off(feature);
+}
+
+static ssize_t om_3d7k_feature_read(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	int on;
+	int feature = 0;
+	int hit = 0;
+
+	while (!hit && feature < OM_3D7K_FEATURE_COUNT) {
+		if (!strcmp(attr->attr.name, feature_info[feature].name))
+			hit = 1;
+		else
+			feature++;
+	}
+
+	if (!hit)
+		return -EINVAL;
+
+	switch (feature) {
+	case OM_3D7K_USBHOST:
+		on = pcf50633_gpio_get(om_3d7k_pcf, PCF50633_GPO);
+		break;
+	default:
+		on = feature_info[feature].on;
+	}
+
+	*buf++ = '0' + on;
+	*buf++='\n';
+	*buf = '\0';
+
+	return 3;
+}
+
+static ssize_t om_3d7k_feature_write(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	int on = !!simple_strtoul(buf, NULL, 10);
+	int feature = 0;
+	int hit = 0;
+
+	while (!hit && feature < OM_3D7K_FEATURE_COUNT) {
+		if (!strcmp(attr->attr.name, feature_info[feature].name))
+			hit = 1;
+		else
+			feature++;
+	}
+
+	if (!hit)
+		return -EINVAL;
+
+	om_3d7k_features_pwron_set(feature, on);
+	feature_info[feature].on = on;
+
+	return count;
+}
+
+
+static DEVICE_ATTR(gsm_power, 0644, om_3d7k_feature_read,
+							om_3d7k_feature_write);
+
+static DEVICE_ATTR(usbhost_power, 0644, om_3d7k_feature_read,
+							om_3d7k_feature_write);
+
+static DEVICE_ATTR(vibrator_power, 0644, om_3d7k_feature_read,
+							om_3d7k_feature_write);
+
+
+static struct attribute *om_3d7k_features_sysfs_entries[] = {
+	&dev_attr_gsm_power.attr,
+	&dev_attr_usbhost_power.attr,
+	&dev_attr_vibrator_power.attr,
+	NULL
+};
+
+
+static struct attribute_group om_3d7k_features_attr_group = {
+	.name	= NULL,
+	.attrs	= om_3d7k_features_sysfs_entries,
+};
+
+static int __init om_3d7k_features_probe(struct platform_device *pdev)
+{
+	gps_regulator = regulator_get(&pdev->dev, "RF_3V");
+	dev_info(&pdev->dev, "starting\n");
+
+	return sysfs_create_group(&pdev->dev.kobj,
+						 &om_3d7k_features_attr_group);
+}
+
+static int om_3d7k_features_remove(struct platform_device *pdev)
+{
+
+	regulator_put(gps_regulator);
+	sysfs_remove_group(&pdev->dev.kobj, &om_3d7k_features_attr_group);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int om_3d7k_features_suspend(struct platform_device *pdev,
+				     pm_message_t state)
+{
+	int feature;
+
+	for (feature = 0; feature < OM_3D7K_FEATURE_COUNT; feature++)
+		if (feature_info[feature].depower_on_suspend)
+			om_3d7k_features_pwron_set_off(feature);
+
+	return 0;
+}
+
+static int om_3d7k_features_resume(struct platform_device *pdev)
+{
+	int feature;
+
+	for (feature = 0; feature < OM_3D7K_FEATURE_COUNT; feature++)
+		if (feature_info[feature].depower_on_suspend)
+			if (feature_info[feature].on)
+				om_3d7k_features_pwron_set_on(feature);
+
+	return 0;
+}
+#else
+#define om_3d7k_features_suspend	NULL
+#define om_3d7k_features_resume	NULL
+#endif
+
+static struct platform_driver om_3d7k_features_driver = {
+	.probe		= om_3d7k_features_probe,
+	.remove		= om_3d7k_features_remove,
+	.suspend	= om_3d7k_features_suspend,
+	.resume		= om_3d7k_features_resume,
+	.driver		= {
+		.name		= "om-3d7k",
+	},
+};
+
+static int __devinit om_3d7k_features_init(void)
+{
+	return platform_driver_register(&om_3d7k_features_driver);
+}
+
+static void om_3d7k_features_exit(void)
+{
+	platform_driver_unregister(&om_3d7k_features_driver);
+}
+
+module_init(om_3d7k_features_init);
+module_exit(om_3d7k_features_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Openmoko OM_3D7K Feature Driver");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/setup-sdhci.c linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/setup-sdhci.c
--- linux-2.6.29-rc3.owrt/arch/arm/mach-s3c6410/setup-sdhci.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-s3c6410/setup-sdhci.c	2009-05-10 22:27:59.000000000 +0200
@@ -48,7 +48,8 @@
 		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
 	}
 
-	s3c_gpio_setpull(S3C64XX_GPG(6), S3C_GPIO_PULL_UP);
+	/* FIXME this needs defining in machine as to if we even have CD */
+	s3c_gpio_setpull(S3C64XX_GPG(6), S3C_GPIO_PULL_DOWN);
 	s3c_gpio_cfgpin(S3C64XX_GPG(6), S3C_GPIO_SFN(2));
 }
 
@@ -79,7 +80,7 @@
 	else
 		ctrl3 = (S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0);
 
-	printk(KERN_INFO "%s: CTRL 2=%08x, 3=%08x\n", __func__, ctrl2, ctrl3);
+	printk(KERN_INFO "%s: %p CTRL 2=%08x, 3=%08x\n", __func__, r, ctrl2, ctrl3);
 	writel(ctrl2, r + S3C_SDHCI_CONTROL2);
 	writel(ctrl3, r + S3C_SDHCI_CONTROL3);
 }
@@ -94,9 +95,9 @@
 	/* Set all the necessary GPG pins to special-function 0 */
 	for (gpio = S3C64XX_GPH(0); gpio < end; gpio++) {
 		s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2));
-		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_NONE);
+		s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP);
 	}
 
-	s3c_gpio_setpull(S3C64XX_GPG(6), S3C_GPIO_PULL_UP);
-	s3c_gpio_cfgpin(S3C64XX_GPG(6), S3C_GPIO_SFN(3));
+//	s3c_gpio_setpull(S3C64XX_GPG(6), S3C_GPIO_PULL_UP);
+//	s3c_gpio_cfgpin(S3C64XX_GPG(6), S3C_GPIO_SFN(3));
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/mach-shark/include/mach/io.h linux-2.6.29-rc3.owrt.om/arch/arm/mach-shark/include/mach/io.h
--- linux-2.6.29-rc3.owrt/arch/arm/mach-shark/include/mach/io.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/mach-shark/include/mach/io.h	2009-05-10 22:27:59.000000000 +0200
@@ -14,7 +14,7 @@
 #define PCIO_BASE	0xe0000000
 #define IO_SPACE_LIMIT	0xffffffff
 
-#define __io(a)		((void __iomem *)(PCIO_BASE + (a)))
+#define __io(a)		__typesafe_io(PCIO_BASE + (a))
 #define __mem_pci(addr)	(addr)
 
 #endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -55,7 +55,8 @@
 arch-$(CONFIG_CPU_32v6K)	:=-D__LINUX_ARM_ARCH__=6 $(call cc-option,-march=armv6k,-march=armv5t -Wa$(comma)-march=armv6k)
 endif
 arch-$(CONFIG_CPU_32v5)		:=-D__LINUX_ARM_ARCH__=5 $(call cc-option,-march=armv5te,-march=armv4t)
-arch-$(CONFIG_CPU_32v4T)	:=-D__LINUX_ARM_ARCH__=4 -march=armv4t
+# We can't load armv4t modules, but still need to assemble some armv4t code to be linked in.
+arch-$(CONFIG_CPU_32v4T)	:=-D__LINUX_ARM_ARCH__=4 -march=armv4 -Wa,-march=armv4t
 arch-$(CONFIG_CPU_32v4)		:=-D__LINUX_ARM_ARCH__=4 -march=armv4
 arch-$(CONFIG_CPU_32v3)		:=-D__LINUX_ARM_ARCH__=3 -march=armv3
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dev-camif.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dev-camif.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dev-camif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dev-camif.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,65 @@
+/* linux/arch/arm/plat-s3c/dev-camif.c
+ *
+ * Copyright 2009 Openmoko, Inc.
+ * Werner Almesberger <werner@openmoko.org>
+ *
+ * based on dev-hsmmc.c which is
+ *
+ * Copyright (c) 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series device definition for camera interface devices
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+
+#include <mach/map.h>
+#include <plat/devs.h>
+#include <plat/cpu.h>
+
+
+#define	S3C6400_PA_CAMIF	0x78000000
+#define S3C24XX_SZ_CAMIF	(0x1000)
+
+
+static struct resource s3c_camif_resource[] = {
+	[0] = {
+		.start = S3C6400_PA_CAMIF,
+		.end   = S3C6400_PA_CAMIF + S3C24XX_SZ_CAMIF - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_CAMIF_C,
+		.end   = IRQ_CAMIF_C,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = IRQ_CAMIF_P,
+		.end   = IRQ_CAMIF_P,
+		.flags = IORESOURCE_IRQ,
+	}
+
+};
+
+static u64 s3c_device_camif_dmamask = 0xffffffffUL;
+
+struct platform_device s3c_device_camif = {
+	.name		  = "s3c-camif",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_camif_resource),
+	.resource	  = s3c_camif_resource,
+	.dev              = {
+		.dma_mask = &s3c_device_camif_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+
+EXPORT_SYMBOL(s3c_device_camif);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dev-i2c0.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dev-i2c0.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dev-i2c0.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dev-i2c0.c	2009-05-10 22:27:59.000000000 +0200
@@ -51,8 +51,8 @@
 	.flags		= 0,
 	.slave_addr	= 0x10,
 	.bus_freq	= 100*1000,
-	.max_freq	= 400*1000,
-	.sda_delay	= S3C2410_IICLC_SDA_DELAY5 | S3C2410_IICLC_FILTER_ON,
+	.max_freq	= 100*1000,
+	.sda_delay	= S3C2410_IICLC_SDA_DELAY15 | S3C2410_IICLC_FILTER_ON,
 };
 
 void __init s3c_i2c0_set_platdata(struct s3c2410_platform_i2c *pd)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dev-usb.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dev-usb.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dev-usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dev-usb.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,50 @@
+/* linux/arch/arm/plat-s3c/dev-usb.c
+ *
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series device definition for USB host
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/platform_device.h>
+
+#include <mach/irqs.h>
+#include <mach/map.h>
+
+#include <plat/devs.h>
+
+
+static struct resource s3c_usb_resource[] = {
+	[0] = {
+		.start = S3C_PA_USBHOST,
+		.end   = S3C_PA_USBHOST + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_USBH,
+		.end   = IRQ_USBH,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+static u64 s3c_device_usb_dmamask = 0xffffffffUL;
+
+struct platform_device s3c_device_usb = {
+	.name		  = "s3c-ohci",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_usb_resource),
+	.resource	  = s3c_usb_resource,
+	.dev              = {
+		.dma_mask = &s3c_device_usb_dmamask,
+		.coherent_dma_mask = 0xffffffffUL
+	}
+};
+
+EXPORT_SYMBOL(s3c_device_usb);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,86 @@
+/* linux/arch/arm/plat-s3c/dma.c
+ *
+ * Copyright (c) 2003-2005,2006,2009 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C DMA core
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+struct s3c2410_dma_buf;
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+
+#include <mach/dma.h>
+#include <mach/irqs.h>
+
+#include <plat/dma-plat.h>
+
+/* dma channel state information */
+struct s3c2410_dma_chan s3c2410_chans[S3C_DMA_CHANNELS];
+struct s3c2410_dma_chan *s3c_dma_chan_map[DMACH_MAX];
+
+/* s3c_dma_lookup_channel
+ *
+ * change the dma channel number given into a real dma channel id
+*/
+
+struct s3c2410_dma_chan *s3c_dma_lookup_channel(unsigned int channel)
+{
+	if (channel & DMACH_LOW_LEVEL)
+		return &s3c2410_chans[channel & ~DMACH_LOW_LEVEL];
+	else
+		return s3c_dma_chan_map[channel];
+}
+
+/* do we need to protect the settings of the fields from
+ * irq?
+*/
+
+int s3c2410_dma_set_opfn(unsigned int channel, s3c2410_dma_opfn_t rtn)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, op rtn=%p\n", __func__, chan, rtn);
+
+	chan->op_fn = rtn;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_set_opfn);
+
+int s3c2410_dma_set_buffdone_fn(unsigned int channel, s3c2410_dma_cbfn_t rtn)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	pr_debug("%s: chan=%p, callback rtn=%p\n", __func__, chan, rtn);
+
+	chan->callback_fn = rtn;
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_set_buffdone_fn);
+
+int s3c2410_dma_setflags(unsigned int channel, unsigned int flags)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	chan->flags = flags;
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_setflags);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/gpio.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/gpio.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/gpio.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/gpio.c	2009-05-10 22:27:59.000000000 +0200
@@ -16,7 +16,7 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 
-#include <plat/gpio-core.h>
+#include <mach/gpio-core.h>
 
 #ifdef CONFIG_S3C_GPIO_TRACK
 struct s3c_gpio_chip *s3c_gpios[S3C_GPIO_END];
@@ -140,6 +140,15 @@
 	if (!gc->get)
 		gc->get = s3c_gpiolib_get;
 
+#ifdef CONFIG_PM
+	if (chip->pm != NULL) {
+		if (!chip->pm->save || !chip->pm->resume)
+			printk(KERN_ERR "gpio: %s has missing PM functions\n",
+			       gc->label);
+	} else
+		printk(KERN_ERR "gpio: %s has no PM function\n", gc->label);
+#endif
+
 	/* gpiochip_add() prints own failure message on error. */
 	ret = gpiochip_add(gc);
 	if (ret >= 0)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/gpio-config.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/gpio-config.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/gpio-config.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/gpio-config.c	2009-05-10 22:27:59.000000000 +0200
@@ -13,6 +13,7 @@
 */
 
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/gpio.h>
 #include <linux/io.h>
 
@@ -38,6 +39,7 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(s3c_gpio_cfgpin);
 
 int s3c_gpio_setpull(unsigned int pin, s3c_gpio_pull_t pull)
 {
@@ -56,6 +58,7 @@
 
 	return ret;
 }
+EXPORT_SYMBOL(s3c_gpio_setpull);
 
 #ifdef CONFIG_S3C_GPIO_CFG_S3C24XX
 int s3c_gpio_setcfg_s3c24xx_banka(struct s3c_gpio_chip *chip,
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/mach/cpu.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/mach/cpu.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/mach/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/mach/cpu.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,165 @@
+/*
+ * arch/arm/plat-s3c/include/mach/cpu.h
+ *
+ *  S3C cpu type detection
+ *
+ *  Copyright (C) 2008 Samsung Electronics
+ *  Kyungmin Park <kyungmin.park@samsung.com>
+ *
+ * Derived from OMAP cpu.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __ASM_ARCH_S3C_CPU_H
+#define __ASM_ARCH_S3C_CPU_H
+
+extern unsigned int system_rev;
+
+#define S3C_SYSTEM_REV_ATAG (system_rev & 0xffff)
+#define S3C_SYSTEM_REV_CPU (system_rev & 0xffff0000)
+
+/*
+ * cpu_is_s3c24xx():	True for s3c2400, s3c2410, s3c2440 and so on
+ * cpu_is_s3c241x():	True fro s3c2410, s3c2412
+ * cpu_is_s3c244x():	True fro s3c2440, s3c2442, s3c2443
+ * cpu_is_s3c64xx():	True for s3c6400, s3c6410
+ */
+#define GET_S3C_CLASS	((system_rev >> 24) & 0xff)
+
+#define IS_S3C_CLASS(class, id)						\
+static inline int is_s3c ##class (void)					\
+{									\
+	return (GET_S3C_CLASS == (id)) ? 1 : 0;				\
+}
+
+#define GET_S3C_SUBCLASS	((system_rev >> 20) & 0xfff)
+
+#define IS_S3C_SUBCLASS(subclass, id)					\
+static inline int is_s3c ##subclass (void)				\
+{									\
+	return (GET_S3C_SUBCLASS == (id)) ? 1 : 0;			\
+}
+
+IS_S3C_CLASS(24xx, 0x24)
+IS_S3C_CLASS(64xx, 0x64)
+
+IS_S3C_SUBCLASS(241x, 0x241)
+IS_S3C_SUBCLASS(244x, 0x244)
+
+#define cpu_is_s3c24xx()		0
+#define cpu_is_s3c241x()		0
+#define cpu_is_s3c244x()		0
+#define cpu_is_s3c64xx()		0
+
+#if defined(CONFIG_ARCH_S3C2410)
+# undef  cpu_is_s3c24xx
+# undef  cpu_is_s3c241x
+# undef  cpu_is_s3c244x
+# define cpu_is_s3c24xx()		is_s3c24xx()
+# define cpu_is_s3c241x()		is_s3c241x()
+# define cpu_is_s3c244x()		is_s3c244x()
+#endif
+
+#if defined(CONFIG_ARCH_S3C64XX)
+# undef  cpu_is_s3c64xx
+# define cpu_is_s3c64xx()		is_s3c64xx()
+#endif
+
+/*
+ * Macros to detect individual cpu types.
+ * cpu_is_s3c2410():	True for s3c2410
+ * cpu_is_s3c2440():	True for s3c2440
+ * cpu_is_s3c6400():	True for s3c6400
+ * cpu_is_s3c6410():	True for s3c6410
+ *
+ * Exception:
+ * Store Revision A to 1
+ * s3c2410a -> s3c2411
+ * s3c2440a -> s3c2441
+ */
+
+#define GET_S3C_TYPE	((system_rev >> 16) & 0xffff)
+
+#define IS_S3C_TYPE(type, id)						\
+static inline int is_s3c ##type (void)					\
+{									\
+	return (GET_S3C_TYPE == (id)) ? 1 : 0;				\
+}
+
+IS_S3C_TYPE(2400, 0x2400)
+IS_S3C_TYPE(2410, 0x2410)
+IS_S3C_TYPE(2410a, 0x2411)
+IS_S3C_TYPE(2412, 0x2412)
+IS_S3C_TYPE(2440, 0x2440)
+IS_S3C_TYPE(2440a, 0x2441)
+IS_S3C_TYPE(2442, 0x2442)
+IS_S3C_TYPE(2443, 0x2443)
+IS_S3C_TYPE(6400, 0x6400)
+IS_S3C_TYPE(6410, 0x6410)
+
+#define cpu_is_s3c2400()		0
+#define cpu_is_s3c2410()		0
+#define cpu_is_s3c2410a()		0
+#define cpu_is_s3c2412()		0
+#define cpu_is_s3c2440()		0
+#define cpu_is_s3c2440a()		0
+#define cpu_is_s3c2442()		0
+#define cpu_is_s3c2443()		0
+#define cpu_is_s3c6400()		0
+#define cpu_is_s3c6410()		0
+
+#if defined(CONFIG_ARCH_S3C2410)
+# undef  cpu_is_s3c2400
+# define cpu_is_s3c2400()		is_s3c2400()
+#endif
+
+#if defined(CONFIG_CPU_S3C2410)
+# undef  cpu_is_s3c2410
+# undef  cpu_is_s3c2410a
+# define cpu_is_s3c2410()		is_s3c2410()
+# define cpu_is_s3c2410a()		is_s3c2410a()
+#endif
+
+#if defined(CONFIG_CPU_S3C2412)
+# undef  cpu_is_s3c2412
+# define cpu_is_s3c2412()		is_s3c2412()
+#endif
+
+#if defined(CONFIG_CPU_S3C2440)
+# undef  cpu_is_s3c2440
+# undef  cpu_is_s3c2440a
+# define cpu_is_s3c2440()		is_s3c2440()
+# define cpu_is_s3c2440a()		is_s3c2440a()
+#endif
+
+#if defined(CONFIG_CPU_S3C2442)
+# undef  cpu_is_s3c2442
+# define cpu_is_s3c2442()		is_s3c2442()
+#endif
+
+#if defined(CONFIG_CPU_S3C2443)
+# undef  cpu_is_s3c2443
+# define cpu_is_s3c2443()		is_s3c2443()
+#endif
+
+#if defined(CONFIG_ARCH_S3C64XX)
+# undef  cpu_is_s3c6400
+# undef  cpu_is_s3c6410
+# define cpu_is_s3c6400()		is_s3c6400()
+# define cpu_is_s3c6410()		is_s3c6410()
+#endif
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/mach/io.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/mach/io.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/mach/io.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/mach/io.h	2009-05-10 22:27:59.000000000 +0200
@@ -10,6 +10,7 @@
 #define __ASM_ARM_ARCH_IO_H
 
 /* No current ISA/PCI bus support. */
+
 #define __io(a)		__typesafe_io(a)
 #define __mem_pci(a)	(a)
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/audio.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/audio.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/audio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/audio.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,45 @@
+/* arch/arm/mach-s3c2410/include/mach/audio.h
+ *
+ * Copyright (c) 2004-2005 Simtec Electronics
+ *	http://www.simtec.co.uk/products/SWLINUX/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C24XX - Audio platfrom_device info
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_AUDIO_H
+#define __ASM_ARCH_AUDIO_H __FILE__
+
+/* struct s3c24xx_iis_ops
+ *
+ * called from the s3c24xx audio core to deal with the architecture
+ * or the codec's setup and control.
+ *
+ * the pointer to itself is passed through in case the caller wants to
+ * embed this in an larger structure for easy reference to it's context.
+*/
+
+struct s3c24xx_iis_ops {
+	struct module *owner;
+
+	int	(*startup)(struct s3c24xx_iis_ops *me);
+	void	(*shutdown)(struct s3c24xx_iis_ops *me);
+	int	(*suspend)(struct s3c24xx_iis_ops *me);
+	int	(*resume)(struct s3c24xx_iis_ops *me);
+
+	int	(*open)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
+	int	(*close)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm);
+	int	(*prepare)(struct s3c24xx_iis_ops *me, struct snd_pcm_substream *strm, struct snd_pcm_runtime *rt);
+};
+
+struct s3c24xx_platdata_iis {
+	const char		*codec_clk;
+	struct s3c24xx_iis_ops	*ops;
+	int			(*match_dev)(struct device *dev);
+};
+
+#endif /* __ASM_ARCH_AUDIO_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/clock.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/clock.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/clock.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/clock.h	2009-05-10 22:27:59.000000000 +0200
@@ -50,6 +50,7 @@
 extern struct clk clk_ext;
 
 /* S3C64XX specific clocks */
+extern struct clk clk_h2;
 extern struct clk clk_27m;
 extern struct clk clk_48m;
 
@@ -80,6 +81,7 @@
 
 /* S3C64XX specific functions and clocks */
 
+extern int s3c64xx_hclk_ctrl(struct clk *clk, int enable);
 extern int s3c64xx_sclk_ctrl(struct clk *clk, int enable);
 
 /* Init for pwm clock code */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/cpu.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/cpu.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/cpu.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/cpu.h	2009-05-10 22:27:59.000000000 +0200
@@ -69,3 +69,6 @@
 extern struct sysdev_class s3c2440_sysclass;
 extern struct sysdev_class s3c2442_sysclass;
 extern struct sysdev_class s3c2443_sysclass;
+extern struct sysdev_class s3c6410_sysclass;
+extern struct sysdev_class s3c64xx_sysclass;
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/devs.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/devs.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/devs.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/devs.h	2009-05-10 22:27:59.000000000 +0200
@@ -16,6 +16,10 @@
 	unsigned long		 nr_resources;
 };
 
+struct s3c_plat_otg_data {
+	int		phyclk;
+};
+
 extern struct s3c24xx_uart_resources s3c2410_uart_resources[];
 extern struct s3c24xx_uart_resources s3c64xx_uart_resources[];
 
@@ -45,10 +49,11 @@
 
 extern struct platform_device s3c_device_usbgadget;
 
+extern struct platform_device s3c_device_ts;
+
 /* s3c2440 specific devices */
 
 #ifdef CONFIG_CPU_S3C2440
 
 extern struct platform_device s3c_device_camif;
-
 #endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/dma-core.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/dma-core.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/dma-core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/dma-core.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,22 @@
+/* arch/arm/plat-s3c/include/plat/dma.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * Samsung S3C DMA core support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+extern struct s3c2410_dma_chan *s3c_dma_lookup_channel(unsigned int channel);
+
+extern struct s3c2410_dma_chan *s3c_dma_chan_map[];
+
+/* the currently allocated channel information */
+extern struct s3c2410_dma_chan s3c2410_chans[];
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/dma.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/dma.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/dma.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,128 @@
+/* arch/arm/plat-s3c/include/plat/dma.h
+ *
+ * Copyright (C) 2003,2004,2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+enum s3c2410_dma_buffresult {
+	S3C2410_RES_OK,
+	S3C2410_RES_ERR,
+	S3C2410_RES_ABORT
+};
+
+enum s3c2410_dmasrc {
+	S3C2410_DMASRC_HW,		/* source is memory */
+	S3C2410_DMASRC_MEM		/* source is hardware */
+};
+
+/* enum s3c2410_chan_op
+ *
+ * operation codes passed to the DMA code by the user, and also used
+ * to inform the current channel owner of any changes to the system state
+*/
+
+enum s3c2410_chan_op {
+	S3C2410_DMAOP_START,
+	S3C2410_DMAOP_STOP,
+	S3C2410_DMAOP_PAUSE,
+	S3C2410_DMAOP_RESUME,
+	S3C2410_DMAOP_FLUSH,
+	S3C2410_DMAOP_TIMEOUT,		/* internal signal to handler */
+	S3C2410_DMAOP_STARTED,		/* indicate channel started */
+};
+
+struct s3c2410_dma_client {
+	char                *name;
+};
+
+struct s3c2410_dma_chan;
+
+/* s3c2410_dma_cbfn_t
+ *
+ * buffer callback routine type
+*/
+
+typedef void (*s3c2410_dma_cbfn_t)(struct s3c2410_dma_chan *,
+				   void *buf, int size,
+				   enum s3c2410_dma_buffresult result);
+
+typedef int  (*s3c2410_dma_opfn_t)(struct s3c2410_dma_chan *,
+				   enum s3c2410_chan_op );
+
+
+
+/* s3c2410_dma_request
+ *
+ * request a dma channel exclusivley
+*/
+
+extern int s3c2410_dma_request(unsigned int channel,
+			       struct s3c2410_dma_client *, void *dev);
+
+
+/* s3c2410_dma_ctrl
+ *
+ * change the state of the dma channel
+*/
+
+extern int s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op);
+
+/* s3c2410_dma_setflags
+ *
+ * set the channel's flags to a given state
+*/
+
+extern int s3c2410_dma_setflags(unsigned int channel,
+				unsigned int flags);
+
+/* s3c2410_dma_free
+ *
+ * free the dma channel (will also abort any outstanding operations)
+*/
+
+extern int s3c2410_dma_free(unsigned int channel, struct s3c2410_dma_client *);
+
+/* s3c2410_dma_enqueue
+ *
+ * place the given buffer onto the queue of operations for the channel.
+ * The buffer must be allocated from dma coherent memory, or the Dcache/WB
+ * drained before the buffer is given to the DMA system.
+*/
+
+extern int s3c2410_dma_enqueue(unsigned int channel, void *id,
+			       dma_addr_t data, int size);
+
+
+/* s3c2410_dma_config
+ *
+ * configure the dma channel
+*/
+
+extern int s3c2410_dma_config(unsigned int channel, int xferunit);
+
+/* s3c2410_dma_devconfig
+ *
+ * configure the device we're talking to
+*/
+
+extern int s3c2410_dma_devconfig(int channel, enum s3c2410_dmasrc source,
+				 unsigned long devaddr);
+
+/* s3c2410_dma_getposition
+ *
+ * get the position that the dma transfer is currently at
+*/
+
+extern int s3c2410_dma_getposition(unsigned int channel,
+				   dma_addr_t *src, dma_addr_t *dest);
+
+extern int s3c2410_dma_set_opfn(unsigned int, s3c2410_dma_opfn_t rtn);
+extern int s3c2410_dma_set_buffdone_fn(unsigned int, s3c2410_dma_cbfn_t rtn);
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/gpio-core.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/gpio-core.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/gpio-core.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/gpio-core.h	2009-05-10 22:27:59.000000000 +0200
@@ -20,6 +20,19 @@
  * specific code.
 */
 
+struct s3c_gpio_chip;
+
+/**
+ * struct s3c_gpio_pm - power management (suspend/resume) information
+ * @save: Routine to save the state of the GPIO block
+ * @resume: Routine to resume the GPIO block.
+ */
+struct s3c_gpio_pm {
+	void (*save)(struct s3c_gpio_chip *chip);
+	void (*resume)(struct s3c_gpio_chip *chip);
+};
+
+
 struct s3c_gpio_cfg;
 
 /**
@@ -27,6 +40,7 @@
  * @chip: The chip structure to be exported via gpiolib.
  * @base: The base pointer to the gpio configuration registers.
  * @config: special function and pull-resistor control information.
+ * @pm_save: Save information for suspend/resume support.
  *
  * This wrapper provides the necessary information for the Samsung
  * specific gpios being registered with gpiolib.
@@ -34,7 +48,11 @@
 struct s3c_gpio_chip {
 	struct gpio_chip	chip;
 	struct s3c_gpio_cfg	*config;
+	struct s3c_gpio_pm	*pm;
 	void __iomem		*base;
+#ifdef CONFIG_PM
+	u32			pm_save[4];
+#endif
 };
 
 static inline struct s3c_gpio_chip *to_s3c_gpio(struct gpio_chip *gpc)
@@ -75,3 +93,16 @@
 
 static inline void s3c_gpiolib_track(struct s3c_gpio_chip *chip) { }
 #endif
+
+#ifdef CONFIG_PM
+extern struct s3c_gpio_pm s3c_gpio_pm_1bit;
+extern struct s3c_gpio_pm s3c_gpio_pm_2bit;
+extern struct s3c_gpio_pm s3c_gpio_pm_4bit;
+#define __gpio_pm(x) x
+#else
+#define s3c_gpio_pm_1bit NULL
+#define s3c_gpio_pm_2bit NULL
+#define s3c_gpio_pm_4bit NULL
+#define __gpio_pm(x) NULL
+
+#endif /* CONFIG_PM */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/map-base.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/map-base.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/map-base.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/map-base.h	2009-05-10 22:27:59.000000000 +0200
@@ -36,5 +36,7 @@
 #define S3C_VA_TIMER	S3C_ADDR(0x00300000)	/* timer block */
 #define S3C_VA_WATCHDOG	S3C_ADDR(0x00400000)	/* watchdog */
 #define S3C_VA_UART	S3C_ADDR(0x01000000)	/* UART */
+#define S3C_VA_OTG	S3C_ADDR(0x03900000)	/* OTG */
+#define S3C_VA_OTGSFR	S3C_ADDR(0x03a00000)	/* OTGSFR */
 
 #endif /* __ASM_PLAT_MAP_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/nand.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/nand.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/nand.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/nand.h	2009-05-10 22:27:59.000000000 +0200
@@ -21,11 +21,14 @@
  * partitions	 = mtd partition list
 */
 
+#define S3C2410_NAND_BBT	0x0001
+
 struct s3c2410_nand_set {
 	unsigned int		disable_ecc : 1;
 
 	int			nr_chips;
 	int			nr_partitions;
+	unsigned int		flags;
 	char			*name;
 	int			*nr_map;
 	struct mtd_partition	*partitions;
@@ -44,6 +47,9 @@
 	int			nr_sets;
 	struct s3c2410_nand_set *sets;
 
+	/* force software_ecc at runtime */
+	int	software_ecc;
+
 	void			(*select_chip)(struct s3c2410_nand_set *,
 					       int chip);
 };
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/pm.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/pm.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/pm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/pm.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,184 @@
+/* linux/include/asm-arm/plat-s3c24xx/pm.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Written by Ben Dooks, <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/sysdev.h>
+
+/* s3c_pm_init
+ *
+ * called from board at initialisation time to setup the power
+ * management
+*/
+
+#ifdef CONFIG_PM
+
+extern __init int s3c_pm_init(void);
+
+#else
+
+static inline int s3c_pm_init(void)
+{
+	return 0;
+}
+#endif
+
+/* configuration for the IRQ mask over sleep */
+extern unsigned long s3c_irqwake_intmask;
+extern unsigned long s3c_irqwake_eintmask;
+
+/* IRQ masks for IRQs allowed to go to sleep (see irq.c) */
+extern unsigned long s3c_irqwake_intallow;
+extern unsigned long s3c_irqwake_eintallow;
+
+/* per-cpu sleep functions */
+
+extern void (*pm_cpu_prep)(void);
+extern void (*pm_cpu_sleep)(void);
+
+/* Flags for PM Control */
+
+extern unsigned long s3c_pm_flags;
+
+extern unsigned char pm_uart_udivslot;  /* true to save UART UDIVSLOT */
+
+/* from sleep.S */
+
+extern int  s3c_cpu_save(unsigned long *saveblk);
+extern void s3c_cpu_resume(void);
+
+extern void s3c2410_cpu_suspend(void);
+
+extern unsigned long s3c_sleep_save_phys;
+
+/* sleep save info */
+
+/**
+ * struct sleep_save - save information for shared peripherals.
+ * @reg: Pointer to the register to save.
+ * @val: Holder for the value saved from reg.
+ *
+ * This describes a list of registers which is used by the pm core and
+ * other subsystem to save and restore register values over suspend.
+ */
+struct sleep_save {
+	void __iomem	*reg;
+	unsigned long	val;
+};
+
+#define SAVE_ITEM(x) \
+	{ .reg = (x) }
+
+/**
+ * struct pm_uart_save - save block for core UART
+ * @ulcon: Save value for S3C2410_ULCON
+ * @ucon: Save value for S3C2410_UCON
+ * @ufcon: Save value for S3C2410_UFCON
+ * @umcon: Save value for S3C2410_UMCON
+ * @ubrdiv: Save value for S3C2410_UBRDIV
+ *
+ * Save block for UART registers to be held over sleep and restored if they
+ * are needed (say by debug).
+*/
+struct pm_uart_save {
+	u32	ulcon;
+	u32	ucon;
+	u32	ufcon;
+	u32	umcon;
+	u32	ubrdiv;
+	u32	udivslot;
+};
+
+/* helper functions to save/restore lists of registers. */
+
+extern void s3c_pm_do_save(struct sleep_save *ptr, int count);
+extern void s3c_pm_do_restore(struct sleep_save *ptr, int count);
+extern void s3c_pm_do_restore_core(struct sleep_save *ptr, int count);
+
+#ifdef CONFIG_PM
+extern int s3c_irqext_wake(unsigned int irqno, unsigned int state);
+extern int s3c24xx_irq_suspend(struct sys_device *dev, pm_message_t state);
+extern int s3c24xx_irq_resume(struct sys_device *dev);
+#else
+#define s3c_irqext_wake NULL
+#define s3c24xx_irq_suspend NULL
+#define s3c24xx_irq_resume  NULL
+#endif
+
+/* PM debug functions */
+
+#ifdef CONFIG_S3C2410_PM_DEBUG
+/**
+ * s3c_pm_dbg() - low level debug function for use in suspend/resume.
+ * @msg: The message to print.
+ *
+ * This function is used mainly to debug the resume process before the system
+ * can rely on printk/console output. It uses the low-level debugging output
+ * routine printascii() to do its work.
+ */
+extern void s3c_pm_dbg(const char *msg, ...);
+
+#define S3C_PMDBG(fmt...) s3c_pm_dbg(fmt)
+#else
+#define S3C_PMDBG(fmt...) printk(KERN_DEBUG fmt)
+#endif
+
+#ifdef CONFIG_S3C_PM_DEBUG_LED_SMDK
+/**
+ * s3c_pm_debug_smdkled() - Debug PM suspend/resume via SMDK Board LEDs
+ * @set: set bits for the state of the LEDs
+ * @clear: clear bits for the state of the LEDs.
+ */
+extern void s3c_pm_debug_smdkled(u32 set, u32 clear);
+
+#else
+static inline void s3c_pm_debug_smdkled(u32 set, u32 clear) { }
+#endif /* CONFIG_S3C_PM_DEBUG_LED_SMDK */
+
+/* suspend memory checking */
+
+#ifdef CONFIG_S3C2410_PM_CHECK
+extern void s3c_pm_check_prepare(void);
+extern void s3c_pm_check_restore(void);
+extern void s3c_pm_check_cleanup(void);
+extern void s3c_pm_check_store(void);
+#else
+#define s3c_pm_check_prepare() do { } while(0)
+#define s3c_pm_check_restore() do { } while(0)
+#define s3c_pm_check_cleanup() do { } while(0)
+#define s3c_pm_check_store()   do { } while(0)
+#endif
+
+/**
+ * s3c_pm_configure_extint() - ensure pins are correctly set for IRQ
+ *
+ * Setup all the necessary GPIO pins for waking the system on external
+ * interrupt.
+ */
+extern void s3c_pm_configure_extint(void);
+
+/**
+ * s3c_pm_restore_gpios() - restore the state of the gpios after sleep.
+ *
+ * Restore the state of the GPIO pins after sleep, which may involve ensuring
+ * that we do not glitch the state of the pins from that the bootloader's
+ * resume code has done.
+*/
+extern void s3c_pm_restore_gpios(void);
+
+/**
+ * s3c_pm_save_gpios() - save the state of the GPIOs for restoring after sleep.
+ *
+ * Save the GPIO states for resotration on resume. See s3c_pm_restore_gpios().
+ */
+extern void s3c_pm_save_gpios(void);
+
+extern void s3c_pm_save_core(void);
+extern void s3c_pm_restore_core(void);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/pwm.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/pwm.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/pwm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/pwm.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,45 @@
+#ifndef __S3C2410_PWM_H
+#define __S3C2410_PWM_H
+
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <mach/io.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <plat/regs-timer.h>
+
+enum pwm_timer {
+	PWM0,
+	PWM1,
+	PWM2,
+	PWM3,
+	PWM4
+};
+
+struct s3c2410_pwm {
+	enum pwm_timer timerid;
+	struct clk *pclk;
+	unsigned long pclk_rate;
+	unsigned long prescaler;
+	unsigned long divider;
+	unsigned long counter;
+	unsigned long comparer;
+};
+
+struct s3c24xx_pwm_platform_data{
+        /* callback to attach platform children (to enforce suspend / resume
+         * ordering */
+        void (*attach_child_devices)(struct device *parent_device);
+};
+
+int s3c2410_pwm_init(struct s3c2410_pwm *s3c2410_pwm);
+int s3c2410_pwm_enable(struct s3c2410_pwm *s3c2410_pwm);
+int s3c2410_pwm_disable(struct s3c2410_pwm *s3c2410_pwm);
+int s3c2410_pwm_start(struct s3c2410_pwm *s3c2410_pwm);
+int s3c2410_pwm_stop(struct s3c2410_pwm *s3c2410_pwm);
+int s3c2410_pwm_duty_cycle(int reg_value, struct s3c2410_pwm *s3c2410_pwm);
+int s3c2410_pwm_dumpregs(void);
+
+#endif /* __S3C2410_PWM_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-s3c2412-iis.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-s3c2412-iis.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-s3c2412-iis.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-s3c2412-iis.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,75 @@
+/* linux/include/asm-arm/plat-s3c24xx/regs-s3c2412-iis.h
+ *
+ * Copyright 2007 Simtec Electronics <linux@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2412 IIS register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_S3C2412_IIS_H
+#define __ASM_ARCH_REGS_S3C2412_IIS_H
+
+#define S3C2412_IISCON			(0x00)
+#define S3C2412_IISMOD			(0x04)
+#define S3C2412_IISFIC			(0x08)
+#define S3C2412_IISPSR			(0x0C)
+#define S3C2412_IISTXD			(0x10)
+#define S3C2412_IISRXD			(0x14)
+
+#define S3C2412_IISCON_LRINDEX		(1 << 11)
+#define S3C2412_IISCON_TXFIFO_EMPTY	(1 << 10)
+#define S3C2412_IISCON_RXFIFO_EMPTY	(1 << 9)
+#define S3C2412_IISCON_TXFIFO_FULL	(1 << 8)
+#define S3C2412_IISCON_RXFIFO_FULL	(1 << 7)
+#define S3C2412_IISCON_TXDMA_PAUSE	(1 << 6)
+#define S3C2412_IISCON_RXDMA_PAUSE	(1 << 5)
+#define S3C2412_IISCON_TXCH_PAUSE	(1 << 4)
+#define S3C2412_IISCON_RXCH_PAUSE	(1 << 3)
+#define S3C2412_IISCON_TXDMA_ACTIVE	(1 << 2)
+#define S3C2412_IISCON_RXDMA_ACTIVE	(1 << 1)
+#define S3C2412_IISCON_IIS_ACTIVE	(1 << 0)
+
+#define S3C64XX_IISMOD_IMS_PCLK		(0 << 10)
+#define S3C64XX_IISMOD_IMS_SYSMUX	(1 << 10)
+
+#define S3C2412_IISMOD_MASTER_INTERNAL	(0 << 10)
+#define S3C2412_IISMOD_MASTER_EXTERNAL	(1 << 10)
+#define S3C2412_IISMOD_SLAVE		(2 << 10)
+#define S3C2412_IISMOD_MASTER_MASK	(3 << 10)
+#define S3C2412_IISMOD_MODE_TXONLY	(0 << 8)
+#define S3C2412_IISMOD_MODE_RXONLY	(1 << 8)
+#define S3C2412_IISMOD_MODE_TXRX	(2 << 8)
+#define S3C2412_IISMOD_MODE_MASK	(3 << 8)
+#define S3C2412_IISMOD_LR_LLOW		(0 << 7)
+#define S3C2412_IISMOD_LR_RLOW		(1 << 7)
+#define S3C2412_IISMOD_SDF_IIS		(0 << 5)
+#define S3C2412_IISMOD_SDF_MSB		(1 << 5)
+#define S3C2412_IISMOD_SDF_LSB		(2 << 5)
+#define S3C2412_IISMOD_SDF_MASK		(3 << 5)
+#define S3C2412_IISMOD_RCLK_256FS	(0 << 3)
+#define S3C2412_IISMOD_RCLK_512FS	(1 << 3)
+#define S3C2412_IISMOD_RCLK_384FS	(2 << 3)
+#define S3C2412_IISMOD_RCLK_768FS	(3 << 3)
+#define S3C2412_IISMOD_RCLK_MASK 	(3 << 3)
+#define S3C2412_IISMOD_BCLK_32FS	(0 << 1)
+#define S3C2412_IISMOD_BCLK_48FS	(1 << 1)
+#define S3C2412_IISMOD_BCLK_16FS	(2 << 1)
+#define S3C2412_IISMOD_BCLK_24FS	(3 << 1)
+#define S3C2412_IISMOD_BCLK_MASK	(3 << 1)
+#define S3C2412_IISMOD_8BIT		(1 << 0)
+
+#define S3C2412_IISPSR_PSREN		(1 << 15)
+
+#define S3C2412_IISFIC_TXFLUSH		(1 << 15)
+#define S3C2412_IISFIC_RXFLUSH		(1 << 7)
+#define S3C2412_IISFIC_TXCOUNT(x)	(((x) >>  8) & 0xf)
+#define S3C2412_IISFIC_RXCOUNT(x)	(((x) >>  0) & 0xf)
+
+
+
+#endif /* __ASM_ARCH_REGS_S3C2412_IIS_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-serial.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-serial.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-serial.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-serial.h	2009-05-10 22:27:59.000000000 +0200
@@ -189,6 +189,11 @@
 
 #define S3C2443_DIVSLOT		  (0x2C)
 
+/* S3C64XX interrupt registers. */
+#define S3C64XX_UINTP		0x30
+#define S3C64XX_UINTSP		0x34
+#define S3C64XX_UINTM		0x38
+
 #ifndef __ASSEMBLY__
 
 /* struct s3c24xx_uart_clksrc
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-timer.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-timer.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-timer.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-timer.h	2009-05-10 22:27:59.000000000 +0200
@@ -10,6 +10,8 @@
  * S3C2410 Timer configuration
 */
 
+#include <plat/map-base.h>
+
 #ifndef __ASM_ARCH_REGS_TIMER_H
 #define __ASM_ARCH_REGS_TIMER_H
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-usb-hs-otg.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-usb-hs-otg.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/regs-usb-hs-otg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/regs-usb-hs-otg.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,360 @@
+/* linux/include/asm-arm/arch-s3c2410/regs-udc.h
+ *
+ * Copyright (C) 2008 Samsung Electronics
+ * Copyright (C) 2004 Herbert Poetzl <herbert@13thfloor.at>
+ *
+ * This include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+*/
+
+#ifndef __ASM_ARCH_REGS_USB_HS_OTG_H
+#define __ASM_ARCH_REGS_USB_HS_OTG_H
+
+/* USB2.0 OTG Controller register */
+#define S3C_USBOTG_PHYREG(x)	((x) + 0x100000 /* S3C64XX_VA_OTGSFR */)
+#define S3C_USBOTG_PHYPWR		S3C_USBOTG_PHYREG(0x0)
+#define S3C_USBOTG_PHYCLK		S3C_USBOTG_PHYREG(0x4)
+#define S3C_USBOTG_RSTCON		S3C_USBOTG_PHYREG(0x8)
+
+/* USB2.0 OTG Controller register */
+/* Core Global Registers */
+#define S3C_USBOTGREG(x)		((x) /*+ S3C64XX_VA_OTG */)
+/* OTG Control & Status */
+#define S3C_UDC_OTG_GOTGCTL		S3C_USBOTGREG(0x000)
+/* OTG Interrupt */
+#define S3C_UDC_OTG_GOTGINT		S3C_USBOTGREG(0x004)
+/* Core AHB Configuration */
+#define S3C_UDC_OTG_GAHBCFG		S3C_USBOTGREG(0x008)
+/* Core USB Configuration */
+#define S3C_UDC_OTG_GUSBCFG		S3C_USBOTGREG(0x00C)
+/* Core Reset */
+#define S3C_UDC_OTG_GRSTCTL		S3C_USBOTGREG(0x010)
+/* Core Interrupt */
+#define S3C_UDC_OTG_GINTSTS		S3C_USBOTGREG(0x014)
+/* Core Interrupt Mask */
+#define S3C_UDC_OTG_GINTMSK		S3C_USBOTGREG(0x018)
+/* Receive Status Debug Read/Status Read */
+#define S3C_UDC_OTG_GRXSTSR		S3C_USBOTGREG(0x01C)
+/* Receive Status Debug Pop/Status Pop */
+#define S3C_UDC_OTG_GRXSTSP		S3C_USBOTGREG(0x020)
+/* Receive FIFO Size */
+#define S3C_UDC_OTG_GRXFSIZ		S3C_USBOTGREG(0x024)
+/* Non-Periodic Transmit FIFO Size */
+#define S3C_UDC_OTG_GNPTXFSIZ	S3C_USBOTGREG(0x028)
+/* Non-Periodic Transmit FIFO/Queue Status */
+#define S3C_UDC_OTG_GNPTXSTS	S3C_USBOTGREG(0x02C)
+
+/* Host Periodic Transmit FIFO Size */
+#define S3C_UDC_OTG_HPTXFSIZ	S3C_USBOTGREG(0x100)
+/* Device Periodic Transmit FIFO-1 Size */
+#define S3C_UDC_OTG_DPTXFSIZ1	S3C_USBOTGREG(0x104)
+/* Device Periodic Transmit FIFO-2 Size */
+#define S3C_UDC_OTG_DPTXFSIZ2	S3C_USBOTGREG(0x108)
+/* Device Periodic Transmit FIFO-3 Size */
+#define S3C_UDC_OTG_DPTXFSIZ3	S3C_USBOTGREG(0x10C)
+/* Device Periodic Transmit FIFO-4 Size */
+#define S3C_UDC_OTG_DPTXFSIZ4	S3C_USBOTGREG(0x110)
+/* Device Periodic Transmit FIFO-5 Size */
+#define S3C_UDC_OTG_DPTXFSIZ5	S3C_USBOTGREG(0x114)
+/* Device Periodic Transmit FIFO-6 Size */
+#define S3C_UDC_OTG_DPTXFSIZ6	S3C_USBOTGREG(0x118)
+/* Device Periodic Transmit FIFO-7 Size */
+#define S3C_UDC_OTG_DPTXFSIZ7	S3C_USBOTGREG(0x11C)
+/* Device Periodic Transmit FIFO-8 Size */
+#define S3C_UDC_OTG_DPTXFSIZ8	S3C_USBOTGREG(0x120)
+/* Device Periodic Transmit FIFO-9 Size */
+#define S3C_UDC_OTG_DPTXFSIZ9	S3C_USBOTGREG(0x124)
+/* Device Periodic Transmit FIFO-10 Size */
+#define S3C_UDC_OTG_DPTXFSIZ10	S3C_USBOTGREG(0x128)
+/* Device Periodic Transmit FIFO-11 Size */
+#define S3C_UDC_OTG_DPTXFSIZ11	S3C_USBOTGREG(0x12C)
+/* Device Periodic Transmit FIFO-12 Size */
+#define S3C_UDC_OTG_DPTXFSIZ12	S3C_USBOTGREG(0x130)
+/* Device Periodic Transmit FIFO-13 Size */
+#define S3C_UDC_OTG_DPTXFSIZ13	S3C_USBOTGREG(0x134)
+/* Device Periodic Transmit FIFO-14 Size */
+#define S3C_UDC_OTG_DPTXFSIZ14	S3C_USBOTGREG(0x138)
+/* Device Periodic Transmit FIFO-15 Size */
+#define S3C_UDC_OTG_DPTXFSIZ15	S3C_USBOTGREG(0x13C)
+
+/* Host Mode Registers
+ * Host Global Registers */
+/* Host Configuration */
+#define S3C_UDC_OTG_HCFG		S3C_USBOTGREG(0x400)
+/* Host Frame Interval */
+#define S3C_UDC_OTG_HFIR		S3C_USBOTGREG(0x404)
+/* Host Frame Number/Frame Time Remaining */
+#define S3C_UDC_OTG_HFNUM		S3C_USBOTGREG(0x408)
+/* Host Periodic Transmit FIFO/Queue Status */
+#define S3C_UDC_OTG_HPTXSTS		S3C_USBOTGREG(0x410)
+/* Host All Channels Interrupt */
+#define S3C_UDC_OTG_HAINT		S3C_USBOTGREG(0x414)
+/* Host All Channels Interrupt Mask */
+#define S3C_UDC_OTG_HAINTMSK	S3C_USBOTGREG(0x418)
+
+/* Host Port Control & Status Registers */
+#define S3C_UDC_OTG_HPRT		S3C_USBOTGREG(0x440)
+
+/* Host Channel-Specific Registers */
+/* Host Channel-0 Characteristics */
+#define  S3C_UDC_OTG_HCCHAR0	S3C_USBOTGREG(0x500)
+/* Host Channel-0 Split Control */
+#define  S3C_UDC_OTG_HCSPLT0	S3C_USBOTGREG(0x504)
+/* Host Channel-0 Interrupt */
+#define  S3C_UDC_OTG_HCINT0		S3C_USBOTGREG(0x508)
+/* Host Channel-0 Interrupt Mask */
+#define  S3C_UDC_OTG_HCINTMSK0	S3C_USBOTGREG(0x50C)
+/* Host Channel-0 Transfer Size */
+#define  S3C_UDC_OTG_HCTSIZ0	S3C_USBOTGREG(0x510)
+/* Host Channel-0 DMA Address */
+#define  S3C_UDC_OTG_HCDMA0		S3C_USBOTGREG(0x514)
+
+/* Device Mode Registers
+ * Device Global Registers */
+/* Device Configuration */
+#define  S3C_UDC_OTG_DCFG		S3C_USBOTGREG(0x800)
+/* Device Control */
+#define  S3C_UDC_OTG_DCTL		S3C_USBOTGREG(0x804)
+/* Device Status */
+#define  S3C_UDC_OTG_DSTS		S3C_USBOTGREG(0x808)
+/* Device IN Endpoint Common Interrupt Mask */
+#define  S3C_UDC_OTG_DIEPMSK	S3C_USBOTGREG(0x810)
+/* Device OUT Endpoint Common Interrupt Mask */
+#define  S3C_UDC_OTG_DOEPMSK	S3C_USBOTGREG(0x814)
+/* Device All Endpoints Interrupt */
+#define  S3C_UDC_OTG_DAINT		S3C_USBOTGREG(0x818)
+/* Device All Endpoints Interrupt Mask */
+#define  S3C_UDC_OTG_DAINTMSK	S3C_USBOTGREG(0x81C)
+/* Device IN Token Sequence Learning Queue Read 1 */
+#define  S3C_UDC_OTG_DTKNQR1	S3C_USBOTGREG(0x820)
+/* Device IN Token Sequence Learning Queue Read 2 */
+#define  S3C_UDC_OTG_DTKNQR2	S3C_USBOTGREG(0x824)
+/* Device VBUS Discharge Time */
+#define  S3C_UDC_OTG_DVBUSDIS	S3C_USBOTGREG(0x828)
+/* Device VBUS Pulsing Time */
+#define  S3C_UDC_OTG_DVBUSPULSE	S3C_USBOTGREG(0x82C)
+/* Device IN Token Sequence Learning Queue Read 3 */
+#define  S3C_UDC_OTG_DTKNQR3	S3C_USBOTGREG(0x830)
+/* Device IN Token Sequence Learning Queue Read 4 */
+#define  S3C_UDC_OTG_DTKNQR4	S3C_USBOTGREG(0x834)
+
+/* Device Logical IN Endpoint-Specific Registers */
+/* Device IN Endpoint 0 Control */
+#define  S3C_UDC_OTG_DIEPCTL0	S3C_USBOTGREG(0x900)
+/* Device IN Endpoint 0 Interrupt */
+#define  S3C_UDC_OTG_DIEPINT0	S3C_USBOTGREG(0x908)
+/* Device IN Endpoint 0 Transfer Size */
+#define  S3C_UDC_OTG_DIEPTSIZ0	S3C_USBOTGREG(0x910)
+/* Device IN Endpoint 0 DMA Address */
+#define  S3C_UDC_OTG_DIEPDMA0	S3C_USBOTGREG(0x914)
+
+/* Device IN Endpoint 2 Control */
+#define  S3C_UDC_OTG_DIEPCTL2	S3C_USBOTGREG(0x940)
+/* Device IN Endpoint 2 Interrupt */
+#define  S3C_UDC_OTG_DIEPINT2	S3C_USBOTGREG(0x948)
+/* Device IN Endpoint 2 Transfer Size */
+#define  S3C_UDC_OTG_DIEPTSIZ2	S3C_USBOTGREG(0x950)
+/* Device IN Endpoint 2 DMA Address */
+#define  S3C_UDC_OTG_DIEPDMA2	S3C_USBOTGREG(0x954)
+
+/* Device IN Endpoint 3 Control */
+#define  S3C_UDC_OTG_DIEPCTL3	S3C_USBOTGREG(0x960)
+/* Device IN Endpoint 3 Interrupt */
+#define  S3C_UDC_OTG_DIEPINT3	S3C_USBOTGREG(0x968)
+/* Device IN Endpoint 3 Transfer Size */
+#define  S3C_UDC_OTG_DIEPTSIZ3	S3C_USBOTGREG(0x970)
+/* Device IN Endpoint 3 DMA Address */
+#define  S3C_UDC_OTG_DIEPDMA3	S3C_USBOTGREG(0x974)
+
+/* Device Logical OUT Endpoint-Specific Registers */
+/* Device OUT Endpoint 0 Control */
+#define  S3C_UDC_OTG_DOEPCTL0	S3C_USBOTGREG(0xB00)
+/* Device OUT Endpoint 0 Interrupt */
+#define  S3C_UDC_OTG_DOEPINT0	S3C_USBOTGREG(0xB08)
+/* Device OUT Endpoint 0 Transfer Size */
+#define  S3C_UDC_OTG_DOEPTSIZ0	S3C_USBOTGREG(0xB10)
+/* Device OUT Endpoint 0 DMA Address */
+#define  S3C_UDC_OTG_DOEPDMA0	S3C_USBOTGREG(0xB14)
+
+/* Device OUT Endpoint 1 Control */
+#define  S3C_UDC_OTG_DOEPCTL1	S3C_USBOTGREG(0xB20)
+/* Device OUT Endpoint 1 Interrupt */
+#define  S3C_UDC_OTG_DOEPINT1	S3C_USBOTGREG(0xB28)
+/* Device OUT Endpoint 1 Transfer Size */
+#define  S3C_UDC_OTG_DOEPTSIZ1	S3C_USBOTGREG(0xB30)
+/* Device OUT Endpoint 1 DMA Address */
+#define  S3C_UDC_OTG_DOEPDMA1	S3C_USBOTGREG(0xB34)
+
+/* Endpoint FIFO address */
+#define S3C_UDC_OTG_EP0_FIFO	S3C_USBOTGREG(0x1000)
+#define S3C_UDC_OTG_EP1_FIFO	S3C_USBOTGREG(0x2000)
+#define S3C_UDC_OTG_EP2_FIFO	S3C_USBOTGREG(0x3000)
+#define S3C_UDC_OTG_EP3_FIFO	S3C_USBOTGREG(0x4000)
+#define S3C_UDC_OTG_EP4_FIFO	S3C_USBOTGREG(0x5000)
+#define S3C_UDC_OTG_EP5_FIFO	S3C_USBOTGREG(0x6000)
+#define S3C_UDC_OTG_EP6_FIFO	S3C_USBOTGREG(0x7000)
+#define S3C_UDC_OTG_EP7_FIFO	S3C_USBOTGREG(0x8000)
+#define S3C_UDC_OTG_EP8_FIFO	S3C_USBOTGREG(0x9000)
+
+/* S3C_USBOTG_PHYPWR */
+#define OTG_ENABLE			(0x0<<4)
+#define OTG_DISABLE			(0x1<<4)
+#define ANALOG_PWR_UP		(0x0<<3)
+#define ANALOG_PWR_DOWN		(0x1<<3)
+#define SUSPEND_DISABLE		(0x0<<0)
+#define SUSPEND_ENABLE		(0x1<<0)
+
+/* S3C_USBOTG_PHYCLK */
+#define REF_CLK_CRYSTAL		(0x0<<5)
+#define REF_CLK_OSCC		(0x1<<5)
+
+/* S3C_USBOTG_RSTCON */
+#define SW_RST_OFF			(0x0<<0)
+#define SW_RST_ON			(0x1<<0)
+
+/* S3C_UDC_OTG_GOTGCTL */
+#define B_SESSION_VALID		(0x1<<19)
+#define A_SESSION_VALID		(0x1<<18)
+
+/* S3C_UDC_OTG_GAHBCFG */
+#define PTXFE_HALF			(0x0<<8)
+#define PTXFE_ZERO			(0x1<<8)
+#define NPTXFE_HALF			(0x0<<7)
+#define NPTXFE_ZERO			(0x1<<7)
+#define MODE_SLAVE			(0x0<<5)
+#define MODE_DMA			(0x1<<5)
+#define BURST_SINGLE		(0x0<<1)
+#define BURST_INCR			(0x1<<1)
+#define BURST_INCR4			(0x3<<1)
+#define BURST_INCR8			(0x5<<1)
+#define BURST_INCR16		(0x7<<1)
+#define GBL_INT_UNMASK		(0x1<<0)
+#define GBL_INT_MASK		(0x0<<0)
+
+/* S3C_UDC_OTG_GUSBCFG */
+#define PHY_CLK_480M		(0x0<<15)
+#define PHY_CLK_48M			(0x1<<15)
+#define TXFIFO_RE_DIS		(0x0<<14)
+#define TXFIFO_RE_EN		(0x1<<14)
+#define TURN_AROUND			(0x5<<10)
+#define HNP_DISABLE			(0x0<<9)
+#define HNP_ENABLE			(0x1<<9)
+#define SRP_DISABLE			(0x0<<8)
+#define SRP_ENABLE			(0x1<<8)
+#define ULPI_DDR			(0x0<<7)
+#define HS_UTMI				(0x0<<6)
+#define INTERF_UTMI			(0x0<<4)
+#define INTERF_ULPI			(0x1<<4)
+#define PHY_INTERF_8		(0x0<<3)
+#define PHY_INTERF_16		(0x1<<3)
+#define TIME_OUT_CAL		(0x7<<0)
+
+/* S3C_UDC_OTG_GRSTCTL */
+#define AHB_MASTER_IDLE		(1u<<31)
+#define CORE_SOFT_RESET		(0x1<<0)
+
+/* S3C_UDC_OTG_GINTSTS/S3C_UDC_OTG_GINTMSK core interrupt register */
+#define INT_RESUME			(0x1<<31)
+#define INT_DISCONN			(0x1<<29)
+#define INT_CONN_CNG		(0x1<<28)
+#define INT_OUT_EP			(0x1<<19)
+#define INT_IN_EP			(0x1<<18)
+#define INT_ENUMDONE		(0x1<<13)
+#define INT_RESET			(0x1<<12)
+#define INT_SUSPEND			(0x1<<11)
+#define INT_EARLY_SUSPEND	(0x1<<10)
+#define INT_TX_FIFO_EMPTY	(0x1<<5)
+#define INT_RX_FIFO_NOT_EMPTY	(0x1<<4)
+#define INT_SOF				(0x1<<3)
+#define INT_DEV_MODE		(0x0<<0)
+#define INT_HOST_MODE		(0x1<<1)
+
+#define FULL_SPEED_CONTROL_PKT_SIZE		8
+#define FULL_SPEED_BULK_PKT_SIZE		64
+
+#define HIGH_SPEED_CONTROL_PKT_SIZE		64
+#define HIGH_SPEED_BULK_PKT_SIZE		512
+
+/* S3C_UDC_OTG_DSTS */
+#define RX_FIFO_SIZE		(2048<<0)
+#define NPTX_FIFO_START_ADDR	(RX_FIFO_SIZE<<0)
+#define NPTX_FIFO_SIZE		(2048<<16)
+#define PTX_FIFO_SIZE		(2048<<16)
+#define USB_HIGH_30_60MHZ	(0x0<<1)
+#define USB_FULL_30_60MHZ	(0x1<<1)
+#define USB_LOW_6MHZ		(0x2<<1)
+#define USB_FULL_48MHZ		(0x3<<1)
+
+/* S3C_UDC_OTG_GRXSTSP */
+#define BYTE_COUNT(x)		((x & (0x7FF<<4)) >> 4)
+#define PKT_STS(x)			((x & (0xF<<17)) >> 17)
+#define EP_NUM(x)			(x & 0xF)
+
+#define OUT_PKT_RECEIVED	(0x2)
+#define OUT_COMPLELTED		(0x3)
+#define SETUP_COMPLETED		(0x4)
+#define SETUP_PKT_RECEIVED	(0x6)
+
+/* S3C_UDC_OTG_DCFG */
+#define EP_MIS_CNT(x)		(x<<18)
+#define DEVICE_ADDR(x)		(x<<4)
+#define SPEED_2_HIGH		(0x0<<0)
+#define SPEED_2_FULL		(0x1<<0)
+#define SPEED_1_LOW			(0x2<<0)
+#define SPEED_1_FULL		(0x3<<0)
+
+/* S3C_UDC_OTG_DCTL device control register */
+#define NORMAL_OPERATION	(0x1<<0)
+#define SOFT_DISCONNECT		(0x1<<1)
+
+/* S3C_UDC_OTG_DSTS */
+#define ENUM_SPEED(x)		(x & (0x3<<1))
+#define FRAME_CNT(x)		(x & (0x3ff<<8))
+
+/* S3C_UDC_OTG_DAINT device all endpoint interrupt register */
+#define S3C_UDC_INT_IN_EP0	(0x1<<0)
+#define S3C_UDC_INT_IN_EP2	(0x1<<2)
+#define S3C_UDC_INT_IN_EP3	(0x1<<3)
+#define S3C_UDC_INT_OUT_EP0	(0x1<<16)
+#define S3C_UDC_INT_OUT_EP1	(0x1<<17)
+#define S3C_UDC_INT_OUT_EP4	(0x1<<20)
+
+/* S3C_UDC_OTG_DIEPCTL0/DOEPCTL0 device control
+   IN/OUT endpoint 0 control register */
+#define DEPCTL_EPENA		(0x1<<31)
+#define DEPCTL_EPDIS		(0x1<<30)
+#define DEPCTL_SNAK			(0x1<<27)
+#define DEPCTL_CNAK			(0x1<<26)
+#define DEPCTL_CTRL_TYPE	(0x0<<18)
+#define DEPCTL_ISO_TYPE		(0x1<<18)
+#define DEPCTL_BULK_TYPE	(0x2<<18)
+#define DEPCTL_INTR_TYPE	(0x3<<18)
+#define DEPCTL_USBACTEP		(0x1<<15)
+#define DEPCTL0_MPS_64		(0x0<<0)
+#define DEPCTL0_MPS_32		(0x1<<0)
+#define DEPCTL0_MPS_16		(0x2<<0)
+#define DEPCTL0_MPS_8		(0x3<<0)
+
+/* S3C_UDC_OTG_DIEPINTn */
+#define IN_EP_NAK_EFF		(0x1<<6)
+#define IN_TK_EPMIS			(0x1<<5)
+#define IN_TK_TXFEMP		(0x1<<4)
+#define IN_EP_TIMEOUT		(0x1<<3)
+
+/* S3C_UDC_OTG_DOEPINTn */
+#define BACK2BACK_SETUP		(0x1<<6)
+#define OUT_TK_EP_DIS		(0x1<<4)
+#define SETUP_PHASE_DONE	(0x1<<3)
+
+/* S3C_UDC_OTG_DIEPINTn/DOEPINTn */
+#define AHB_ERROR			(0x1<<2)
+#define EPDISBLD			(0x1<<1)
+#define TRANSFER_DONE		(0x1<<0)
+
+/* S3C_UDC_OTG_DIEPTSIZn */
+#define PKT_CNT(x)			(x<<19)
+#define XFERSIZE(x)			(x<<0)
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/sdhci.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/sdhci.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/sdhci.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/sdhci.h	2009-05-10 22:27:59.000000000 +0200
@@ -29,6 +29,7 @@
  *            is necessary the controllers and/or GPIO blocks require the
  *	      changing of driver-strength and other controls dependant on
  *	      the card and speed of operation.
+ * sdhci_host: Pointer kept during init, allows presence change notification
  *
  * Initialisation data specific to either the machine or the platform
  * for the device driver to use or call-back when configuring gpio or
@@ -45,8 +46,11 @@
 			    void __iomem *regbase,
 			    struct mmc_ios *ios,
 			    struct mmc_card *card);
+	struct sdhci_host * sdhci_host;
 };
 
+extern void sdhci_s3c_force_presence_change(struct platform_device *pdev);
+
 /**
  * s3c_sdhci0_set_platdata - Set platform data for S3C SDHCI device.
  * @pd: Platform data to register to device.
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/usb-control.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/usb-control.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/include/plat/usb-control.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/include/plat/usb-control.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,41 @@
+/* arch/arm/plat-s3c/include/plat/usb-control.h
+ *
+ * Copyright (c) 2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C2410 - usb port information
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __ASM_ARCH_USBCONTROL_H
+#define __ASM_ARCH_USBCONTROL_H "arch/arm/plat-s3c/include/plat/usb-control.h"
+
+#define S3C_HCDFLG_USED	(1)
+
+struct s3c2410_hcd_port {
+	unsigned char	flags;
+	unsigned char	power;
+	unsigned char	oc_status;
+	unsigned char	oc_changed;
+};
+
+struct s3c2410_hcd_info {
+	struct usb_hcd		*hcd;
+	struct s3c2410_hcd_port	port[2];
+
+	void		(*power_control)(int port, int to);
+	void		(*enable_oc)(struct s3c2410_hcd_info *, int on);
+	void		(*report_oc)(struct s3c2410_hcd_info *, int ports);
+};
+
+static void inline s3c2410_usb_report_oc(struct s3c2410_hcd_info *info, int ports)
+{
+	if (info->report_oc != NULL) {
+		(info->report_oc)(info, ports);
+	}
+}
+
+#endif /*__ASM_ARCH_USBCONTROL_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/init.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/init.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/init.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/init.c	2009-05-10 22:27:59.000000000 +0200
@@ -31,6 +31,34 @@
 
 static struct cpu_table *cpu;
 
+static void __init set_system_rev(unsigned int idcode)
+{
+	/*
+	 * system_rev encoding is as follows
+	 * system_rev & 0xff000000 -> S3C Class (24xx/64xx)
+	 * system_rev & 0xfff00000 -> S3C Sub Class (241x/244x)
+	 * system_rev & 0xffff0000 -> S3C Type (2410/2440/6400/6410)
+	 *
+	 * Remaining[15:0] are preserved from the value set by ATAG
+	 *
+	 * Exception:
+	 *  Store Revision A to 1 such as
+	 *  s3c2410A to s3c2411
+	 *  s3c2440A to s3c2441
+	 */
+
+	system_rev &= 0xffff;
+	system_rev |= (idcode & 0x0ffff000) << 4;
+
+	if (idcode == 0x32410002 || idcode == 0x32440001)
+		system_rev |= (0x1 << 16);
+	if (idcode == 0x32440aaa	/* s3c2442 */
+	    || idcode == 0x32440aab)	/* s3c2442b */
+		system_rev |= (0x2 << 16);
+	if (idcode == 0x0)		/* s3c2400 */
+		system_rev |= (0x2400 << 16);
+}
+
 static struct cpu_table * __init s3c_lookup_cpu(unsigned long idcode,
 						struct cpu_table *tab,
 						unsigned int count)
@@ -53,6 +81,8 @@
 		panic("Unknown S3C24XX CPU");
 	}
 
+	set_system_rev(idcode);
+
 	printk("CPU %s (id 0x%08lx)\n", cpu->name, idcode);
 
 	if (cpu->map_io == NULL || cpu->init == NULL) {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/Kconfig	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -71,6 +71,15 @@
 	  Resume code. See <file:Documentation/arm/Samsung-S3C24XX/Suspend.txt>
 	  for more information.
 
+config S3C_PM_DEBUG_LED_SMDK
+       bool "SMDK LED suspend/resume debugging"
+       depends on PM && (MACH_SMDK6410)
+       help
+         Say Y here to enable the use of the SMDK LEDs on the baseboard
+	 for debugging of the state of the suspend and resume process.
+
+	 Note, this currently only works for S3C64XX based SMDK boards.
+
 config S3C2410_PM_CHECK
 	bool "S3C2410 PM Suspend Memory CRC"
 	depends on PM && CRC32
@@ -150,6 +159,18 @@
 	  Internal configuration to enable S3C64XX style GPIO configuration
 	  functions.
 
+# DMA
+
+config S3C_DMA
+	bool
+	help
+	  Internal configuration for S3C DMA core
+
+config S3C_PWM
+	bool
+	help
+	  PWM timer code for the S3C2410, and similar processors
+
 # device definitions to compile in
 
 config S3C_DEV_HSMMC
@@ -172,4 +193,14 @@
 	help
 	  Compile in platform device definition for framebuffer
 
+config S3C_DEV_USB_HOST
+	bool
+	help
+	  Compile in platform device definition for USB host.
+
+config S3C_DEV_CAMIF
+	bool
+	help
+	  Compile in platform device definitions for camera interface code
+
 endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -18,6 +18,16 @@
 obj-y				+= gpio.o
 obj-y				+= gpio-config.o
 
+# DMA support
+
+obj-$(CONFIG_S3C_DMA)		+= dma.o
+
+# PM support
+
+obj-$(CONFIG_PM)		+= pm.o
+obj-$(CONFIG_PM)		+= pm-gpio.o
+obj-$(CONFIG_S3C2410_PM_CHECK)	+= pm-check.o
+
 # devices
 
 obj-$(CONFIG_S3C_DEV_HSMMC)	+= dev-hsmmc.o
@@ -25,3 +35,9 @@
 obj-y				+= dev-i2c0.o
 obj-$(CONFIG_S3C_DEV_I2C1)	+= dev-i2c1.o
 obj-$(CONFIG_S3C_DEV_FB)	+= dev-fb.o
+obj-$(CONFIG_S3C_DEV_USB_HOST)	+= dev-usb.o
+obj-$(CONFIG_S3C_DEV_CAMIF)	+= dev-camif.o
+
+obj-$(CONFIG_S3C_PWM)		+= pwm.o
+obj-$(CONFIG_S3C_DMA)		+= dma.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,375 @@
+/* linux/arch/arm/plat-s3c/pm.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2004,2006,2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C common power management (suspend to ram) support.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/serial_core.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <mach/map.h>
+
+#include <plat/regs-serial.h>
+#include <mach/regs-clock.h>
+#include <mach/regs-irq.h>
+#include <asm/irq.h>
+
+#include <plat/pm.h>
+#include <plat/pm-core.h>
+
+/* for external use */
+
+unsigned long s3c_pm_flags;
+
+/* Debug code:
+ *
+ * This code supports debug output to the low level UARTs for use on
+ * resume before the console layer is available.
+*/
+
+#ifdef CONFIG_S3C2410_PM_DEBUG
+extern void printascii(const char *);
+
+void s3c_pm_dbg(const char *fmt, ...)
+{
+	va_list va;
+	char buff[256];
+
+	va_start(va, fmt);
+	vsprintf(buff, fmt, va);
+	va_end(va);
+
+	printascii(buff);
+}
+
+static inline void s3c_pm_debug_init(void)
+{
+	/* restart uart clocks so we can use them to output */
+	s3c_pm_debug_init_uart();
+}
+
+#else
+#define s3c_pm_debug_init() do { } while(0)
+
+#endif /* CONFIG_S3C2410_PM_DEBUG */
+
+/* Save the UART configurations if we are configured for debug. */
+
+unsigned char pm_uart_udivslot;
+
+#ifdef CONFIG_S3C2410_PM_DEBUG
+
+struct pm_uart_save uart_save[CONFIG_SERIAL_SAMSUNG_UARTS];
+
+static void s3c_pm_save_uart(unsigned int uart, struct pm_uart_save *save)
+{
+	void __iomem *regs = S3C_VA_UARTx(uart);
+
+	save->ulcon = __raw_readl(regs + S3C2410_ULCON);
+	save->ucon = __raw_readl(regs + S3C2410_UCON);
+	save->ufcon = __raw_readl(regs + S3C2410_UFCON);
+	save->umcon = __raw_readl(regs + S3C2410_UMCON);
+	save->ubrdiv = __raw_readl(regs + S3C2410_UBRDIV);
+
+	if (pm_uart_udivslot)
+		save->udivslot = __raw_readl(regs + S3C2443_DIVSLOT);
+
+	S3C_PMDBG("UART[%d]: ULCON=%04x, UCON=%04x, UFCON=%04x, UBRDIV=%04x\n",
+		  uart, save->ulcon, save->ucon, save->ufcon, save->ubrdiv);
+}
+
+static void s3c_pm_save_uarts(void)
+{
+	struct pm_uart_save *save = uart_save;
+	unsigned int uart;
+
+	for (uart = 0; uart < CONFIG_SERIAL_SAMSUNG_UARTS; uart++, save++)
+		s3c_pm_save_uart(uart, save);
+}
+
+static void s3c_pm_restore_uart(unsigned int uart, struct pm_uart_save *save)
+{
+	void __iomem *regs = S3C_VA_UARTx(uart);
+
+	s3c_pm_arch_update_uart(regs, save);
+
+	__raw_writel(save->ulcon, regs + S3C2410_ULCON);
+	__raw_writel(save->ucon,  regs + S3C2410_UCON);
+	__raw_writel(save->ufcon, regs + S3C2410_UFCON);
+	__raw_writel(save->umcon, regs + S3C2410_UMCON);
+	__raw_writel(save->ubrdiv, regs + S3C2410_UBRDIV);
+
+	if (pm_uart_udivslot)
+		__raw_writel(save->udivslot, regs + S3C2443_DIVSLOT);
+}
+
+static void s3c_pm_restore_uarts(void)
+{
+	struct pm_uart_save *save = uart_save;
+	unsigned int uart;
+
+	for (uart = 0; uart < CONFIG_SERIAL_SAMSUNG_UARTS; uart++, save++)
+		s3c_pm_restore_uart(uart, save);
+}
+#else
+static void s3c_pm_save_uarts(void) { }
+static void s3c_pm_restore_uarts(void) { }
+#endif
+
+/* The IRQ ext-int code goes here, it is too small to currently bother
+ * with its own file. */
+
+unsigned long s3c_irqwake_intmask	= 0xffffffffL;
+unsigned long s3c_irqwake_eintmask	= 0xffffffffL;
+
+int s3c_irqext_wake(unsigned int irqno, unsigned int state)
+{
+	unsigned long bit = 1L << IRQ_EINT_BIT(irqno);
+
+	if (!(s3c_irqwake_eintallow & bit))
+		return -ENOENT;
+
+	printk(KERN_INFO "wake %s for irq %d\n",
+	       state ? "enabled" : "disabled", irqno);
+
+	if (!state)
+		s3c_irqwake_eintmask |= bit;
+	else
+		s3c_irqwake_eintmask &= ~bit;
+
+	return 0;
+}
+
+/* helper functions to save and restore register state */
+
+/**
+ * s3c_pm_do_save() - save a set of registers for restoration on resume.
+ * @ptr: Pointer to an array of registers.
+ * @count: Size of the ptr array.
+ *
+ * Run through the list of registers given, saving their contents in the
+ * array for later restoration when we wakeup.
+ */
+void s3c_pm_do_save(struct sleep_save *ptr, int count)
+{
+	for (; count > 0; count--, ptr++) {
+		ptr->val = __raw_readl(ptr->reg);
+		S3C_PMDBG("saved %p value %08lx\n", ptr->reg, ptr->val);
+	}
+}
+
+/**
+ * s3c_pm_do_restore() - restore register values from the save list.
+ * @ptr: Pointer to an array of registers.
+ * @count: Size of the ptr array.
+ *
+ * Restore the register values saved from s3c_pm_do_save().
+ *
+ * Note, we do not use S3C_PMDBG() in here, as the system may not have
+ * restore the UARTs state yet
+*/
+
+void s3c_pm_do_restore(struct sleep_save *ptr, int count)
+{
+	for (; count > 0; count--, ptr++) {
+		printk(KERN_DEBUG "restore %p (restore %08lx, was %08x)\n",
+		       ptr->reg, ptr->val, __raw_readl(ptr->reg));
+
+		__raw_writel(ptr->val, ptr->reg);
+	}
+}
+
+/**
+ * s3c_pm_do_restore_core() - early restore register values from save list.
+ *
+ * This is similar to s3c_pm_do_restore() except we try and minimise the
+ * side effects of the function in case registers that hardware might need
+ * to work has been restored.
+ *
+ * WARNING: Do not put any debug in here that may effect memory or use
+ * peripherals, as things may be changing!
+*/
+
+void s3c_pm_do_restore_core(struct sleep_save *ptr, int count)
+{
+	for (; count > 0; count--, ptr++)
+		__raw_writel(ptr->val, ptr->reg);
+}
+
+/* s3c2410_pm_show_resume_irqs
+ *
+ * print any IRQs asserted at resume time (ie, we woke from)
+*/
+static void s3c_pm_show_resume_irqs(int start, unsigned long which,
+				    unsigned long mask)
+{
+	int i;
+
+	which &= ~mask;
+
+	for (i = 0; i <= 31; i++) {
+		if (which & (1L<<i)) {
+			S3C_PMDBG("IRQ %d asserted at resume\n", start+i);
+		}
+	}
+}
+
+
+void (*pm_cpu_prep)(void);
+void (*pm_cpu_sleep)(void);
+
+#define any_allowed(mask, allow) (((mask) & (allow)) != (allow))
+
+/* s3c_pm_enter
+ *
+ * central control for sleep/resume process
+*/
+
+static int s3c_pm_enter(suspend_state_t state)
+{
+	unsigned long regs_save[16];
+
+	/* ensure the debug is initialised (if enabled) */
+
+	s3c_pm_debug_init();
+
+	S3C_PMDBG("%s(%d)\n", __func__, state);
+
+	if (pm_cpu_prep == NULL || pm_cpu_sleep == NULL) {
+		printk(KERN_ERR "%s: error: no cpu sleep function\n", __func__);
+		return -EINVAL;
+	}
+
+	/* check if we have anything to wake-up with... bad things seem
+	 * to happen if you suspend with no wakeup (system will often
+	 * require a full power-cycle)
+	*/
+
+	if (!any_allowed(s3c_irqwake_intmask, s3c_irqwake_intallow) &&
+	    !any_allowed(s3c_irqwake_eintmask, s3c_irqwake_eintallow)) {
+		printk(KERN_ERR "%s: No wake-up sources!\n", __func__);
+		printk(KERN_ERR "%s: Aborting sleep\n", __func__);
+		return -EINVAL;
+	}
+
+	/* store the physical address of the register recovery block */
+
+	s3c_sleep_save_phys = virt_to_phys(regs_save);
+
+	S3C_PMDBG("s3c_sleep_save_phys=0x%08lx\n", s3c_sleep_save_phys);
+
+	/* save all necessary core registers not covered by the drivers */
+
+	s3c_pm_save_gpios();
+	s3c_pm_save_uarts();
+	s3c_pm_save_core();
+
+	/* set the irq configuration for wake */
+
+	s3c_pm_configure_extint();
+
+	S3C_PMDBG("sleep: irq wakeup masks: %08lx,%08lx\n",
+	    s3c_irqwake_intmask, s3c_irqwake_eintmask);
+
+	s3c_pm_arch_prepare_irqs();
+
+	/* call cpu specific preparation */
+
+	pm_cpu_prep();
+
+	/* flush cache back to ram */
+
+	flush_cache_all();
+
+	s3c_pm_check_store();
+
+	/* send the cpu to sleep... */
+
+	s3c_pm_arch_stop_clocks();
+
+	/* s3c2410_cpu_save will also act as our return point from when
+	 * we resume as it saves its own register state, so use the return
+	 * code to differentiate return from save and return from sleep */
+
+	if (s3c_cpu_save(regs_save) == 0) {
+		flush_cache_all();
+		pm_cpu_sleep();
+	}
+
+	/* restore the cpu state using the kernel's cpu init code. */
+
+	cpu_init();
+
+	/* restore the system state */
+
+	s3c_pm_restore_core();
+	s3c_pm_restore_uarts();
+	s3c_pm_restore_gpios();
+
+	s3c_pm_debug_init();
+
+	/* check what irq (if any) restored the system */
+
+	s3c_pm_arch_show_resume_irqs();
+
+	S3C_PMDBG("%s: post sleep, preparing to return\n", __func__);
+
+	s3c_pm_check_restore();
+
+	/* LEDs should now be 1110 */
+	s3c_pm_debug_smdkled(1 << 1, 0);
+
+	/* ok, let's return from sleep */
+
+	S3C_PMDBG("S3C PM Resume (post-restore)\n");
+	return 0;
+}
+
+static int s3c_pm_prepare(void)
+{
+	/* prepare check area if configured */
+
+	s3c_pm_check_prepare();
+	return 0;
+}
+
+static void s3c_pm_finish(void)
+{
+	s3c_pm_check_cleanup();
+}
+
+static struct platform_suspend_ops s3c_pm_ops = {
+	.enter		= s3c_pm_enter,
+	.prepare	= s3c_pm_prepare,
+	.finish		= s3c_pm_finish,
+	.valid		= suspend_valid_only_mem,
+};
+
+/* s3c_pm_init
+ *
+ * Attach the power management functions. This should be called
+ * from the board specific initialisation if the board supports
+ * it.
+*/
+
+int __init s3c_pm_init(void)
+{
+	printk("S3C Power Management, Copyright 2004 Simtec Electronics\n");
+
+	suspend_set_ops(&s3c_pm_ops);
+	return 0;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pm-check.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pm-check.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pm-check.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pm-check.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,242 @@
+/* linux/arch/arm/plat-s3c/pm-check.c
+ *  originally in linux/arch/arm/plat-s3c24xx/pm.c
+ *
+ * Copyright (c) 2004,2006,2008 Simtec Electronics
+ *	http://armlinux.simtec.co.uk
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C Power Mangament - suspend/resume memory corruptiuon check.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+#include <linux/init.h>
+#include <linux/crc32.h>
+#include <linux/ioport.h>
+
+#include <plat/pm.h>
+
+#if CONFIG_S3C2410_PM_CHECK_CHUNKSIZE < 1
+#error CONFIG_S3C2410_PM_CHECK_CHUNKSIZE must be a positive non-zero value
+#endif
+
+/* suspend checking code...
+ *
+ * this next area does a set of crc checks over all the installed
+ * memory, so the system can verify if the resume was ok.
+ *
+ * CONFIG_S3C2410_PM_CHECK_CHUNKSIZE defines the block-size for the CRC,
+ * increasing it will mean that the area corrupted will be less easy to spot,
+ * and reducing the size will cause the CRC save area to grow
+*/
+
+#define CHECK_CHUNKSIZE (CONFIG_S3C2410_PM_CHECK_CHUNKSIZE * 1024)
+
+static u32 crc_size;	/* size needed for the crc block */
+static u32 *crcs;	/* allocated over suspend/resume */
+
+typedef u32 *(run_fn_t)(struct resource *ptr, u32 *arg);
+
+/* s3c_pm_run_res
+ *
+ * go through the given resource list, and look for system ram
+*/
+
+static void s3c_pm_run_res(struct resource *ptr, run_fn_t fn, u32 *arg)
+{
+	while (ptr != NULL) {
+		if (ptr->child != NULL)
+			s3c_pm_run_res(ptr->child, fn, arg);
+
+		if ((ptr->flags & IORESOURCE_MEM) &&
+		    strcmp(ptr->name, "System RAM") == 0) {
+			S3C_PMDBG("Found system RAM at %08lx..%08lx\n",
+				  (unsigned long)ptr->start,
+				  (unsigned long)ptr->end);
+			arg = (fn)(ptr, arg);
+		}
+
+		ptr = ptr->sibling;
+	}
+}
+
+static void s3c_pm_run_sysram(run_fn_t fn, u32 *arg)
+{
+	s3c_pm_run_res(&iomem_resource, fn, arg);
+}
+
+static u32 *s3c_pm_countram(struct resource *res, u32 *val)
+{
+	u32 size = (u32)(res->end - res->start)+1;
+
+	size += CHECK_CHUNKSIZE-1;
+	size /= CHECK_CHUNKSIZE;
+
+	S3C_PMDBG("Area %08lx..%08lx, %d blocks\n",
+		  (unsigned long)res->start, (unsigned long)res->end, size);
+
+	*val += size * sizeof(u32);
+	return val;
+}
+
+/* s3c_pm_prepare_check
+ *
+ * prepare the necessary information for creating the CRCs. This
+ * must be done before the final save, as it will require memory
+ * allocating, and thus touching bits of the kernel we do not
+ * know about.
+*/
+
+void s3c_pm_check_prepare(void)
+{
+	crc_size = 0;
+
+	s3c_pm_run_sysram(s3c_pm_countram, &crc_size);
+
+	S3C_PMDBG("s3c_pm_prepare_check: %u checks needed\n", crc_size);
+
+	crcs = kmalloc(crc_size+4, GFP_KERNEL);
+	if (crcs == NULL)
+		printk(KERN_ERR "Cannot allocated CRC save area\n");
+}
+
+static u32 *s3c_pm_makecheck(struct resource *res, u32 *val)
+{
+	unsigned long addr, left;
+
+	for (addr = res->start; addr < res->end;
+	     addr += CHECK_CHUNKSIZE) {
+		left = res->end - addr;
+
+		if (left > CHECK_CHUNKSIZE)
+			left = CHECK_CHUNKSIZE;
+
+		*val = crc32_le(~0, phys_to_virt(addr), left);
+		val++;
+	}
+
+	return val;
+}
+
+/* s3c_pm_check_store
+ *
+ * compute the CRC values for the memory blocks before the final
+ * sleep.
+*/
+
+void s3c_pm_check_store(void)
+{
+	if (crcs != NULL)
+		s3c_pm_run_sysram(s3c_pm_makecheck, crcs);
+}
+
+/* in_region
+ *
+ * return TRUE if the area defined by ptr..ptr+size contains the
+ * what..what+whatsz
+*/
+
+static inline int in_region(void *ptr, int size, void *what, size_t whatsz)
+{
+	if ((what+whatsz) < ptr)
+		return 0;
+
+	if (what > (ptr+size))
+		return 0;
+
+	return 1;
+}
+
+/**
+ * s3c_pm_runcheck() - helper to check a resource on restore.
+ * @res: The resource to check
+ * @vak: Pointer to list of CRC32 values to check.
+ *
+ * Called from the s3c_pm_check_restore() via s3c_pm_run_sysram(), this
+ * function runs the given memory resource checking it against the stored
+ * CRC to ensure that memory is restored. The function tries to skip as
+ * many of the areas used during the suspend process.
+ */
+static u32 *s3c_pm_runcheck(struct resource *res, u32 *val)
+{
+	void *save_at = phys_to_virt(s3c_sleep_save_phys);
+	unsigned long addr;
+	unsigned long left;
+	void *stkpage;
+	void *ptr;
+	u32 calc;
+
+	stkpage = (void *)((u32)&calc & ~PAGE_MASK);
+
+	for (addr = res->start; addr < res->end;
+	     addr += CHECK_CHUNKSIZE) {
+		left = res->end - addr;
+
+		if (left > CHECK_CHUNKSIZE)
+			left = CHECK_CHUNKSIZE;
+
+		ptr = phys_to_virt(addr);
+
+		if (in_region(ptr, left, stkpage, 4096)) {
+			S3C_PMDBG("skipping %08lx, has stack in\n", addr);
+			goto skip_check;
+		}
+
+		if (in_region(ptr, left, crcs, crc_size)) {
+			S3C_PMDBG("skipping %08lx, has crc block in\n", addr);
+			goto skip_check;
+		}
+
+		if (in_region(ptr, left, save_at, 32*4 )) {
+			S3C_PMDBG("skipping %08lx, has save block in\n", addr);
+			goto skip_check;
+		}
+
+		/* calculate and check the checksum */
+
+		calc = crc32_le(~0, ptr, left);
+		if (calc != *val) {
+			printk(KERN_ERR "Restore CRC error at "
+			       "%08lx (%08x vs %08x)\n", addr, calc, *val);
+
+			S3C_PMDBG("Restore CRC error at %08lx (%08x vs %08x)\n",
+			    addr, calc, *val);
+		}
+
+	skip_check:
+		val++;
+	}
+
+	return val;
+}
+
+/**
+ * s3c_pm_check_restore() - memory check called on resume
+ *
+ * check the CRCs after the restore event and free the memory used
+ * to hold them
+*/
+void s3c_pm_check_restore(void)
+{
+	if (crcs != NULL)
+		s3c_pm_run_sysram(s3c_pm_runcheck, crcs);
+}
+
+/**
+ * s3c_pm_check_cleanup() - free memory resources
+ *
+ * Free the resources that where allocated by the suspend
+ * memory check code. We do this separately from the
+ * s3c_pm_check_restore() function as we cannot call any
+ * functions that might sleep during that resume.
+ */
+void s3c_pm_check_cleanup(void)
+{
+	kfree(crcs);
+	crcs = NULL;
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pm-gpio.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pm-gpio.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pm-gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pm-gpio.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,378 @@
+/* linux/arch/arm/plat-s3c/pm-gpio.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C series GPIO PM code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+
+#include <mach/gpio-core.h>
+#include <plat/pm.h>
+
+/* PM GPIO helpers */
+
+#define OFFS_CON	(0x00)
+#define OFFS_DAT	(0X04)
+#define OFFS_UP		(0X08)
+
+static void s3c_gpio_pm_1bit_save(struct s3c_gpio_chip *chip)
+{
+	chip->pm_save[0] = __raw_readl(chip->base + OFFS_CON);
+	chip->pm_save[1] = __raw_readl(chip->base + OFFS_DAT);
+}
+
+static void s3c_gpio_pm_1bit_resume(struct s3c_gpio_chip *chip)
+{
+	void __iomem *base = chip->base;
+	u32 old_gpcon = __raw_readl(base + OFFS_CON);
+	u32 old_gpdat = __raw_readl(base + OFFS_DAT);
+	u32 gps_gpcon = chip->pm_save[0];
+	u32 gps_gpdat = chip->pm_save[1];
+	u32 gpcon;
+
+	/* GPACON only has one bit per control / data and no PULLUPs.
+	 * GPACON[x] = 0 => Output, 1 => SFN */
+
+	/* first set all SFN bits to SFN */
+
+	gpcon = old_gpcon | gps_gpcon;
+	__raw_writel(gpcon, base + OFFS_CON);
+
+	/* now set all the other bits */
+
+	__raw_writel(gps_gpdat, base + OFFS_DAT);
+	__raw_writel(gps_gpcon, base + OFFS_CON);
+
+	S3C_PMDBG("%s: CON %08x => %08x, DAT %08x => %08x\n",
+		  chip->chip.label, old_gpcon, gps_gpcon, old_gpdat, gps_gpdat);
+}
+
+struct s3c_gpio_pm s3c_gpio_pm_1bit = {
+	.save	= s3c_gpio_pm_1bit_save,
+	.resume = s3c_gpio_pm_1bit_resume,
+};
+
+static void s3c_gpio_pm_2bit_save(struct s3c_gpio_chip *chip)
+{
+	chip->pm_save[0] = __raw_readl(chip->base + OFFS_CON);
+	chip->pm_save[1] = __raw_readl(chip->base + OFFS_DAT);
+	chip->pm_save[2] = __raw_readl(chip->base + OFFS_UP);
+}
+
+/* Test whether the given masked+shifted bits of an GPIO configuration
+ * are one of the SFN (special function) modes. */
+
+static inline int is_sfn(unsigned long con)
+{
+	return con >= 2;
+}
+
+/* Test if the given masked+shifted GPIO configuration is an input */
+
+static inline int is_in(unsigned long con)
+{
+	return con == 0;
+}
+
+/* Test if the given masked+shifted GPIO configuration is an output */
+
+static inline int is_out(unsigned long con)
+{
+	return con == 1;
+}
+
+/**
+ * s3c_gpio_pm_2bit_resume() - restore the given GPIO bank
+ * @chip: The chip information to resume.
+ *
+ * Restore one of the GPIO banks that was saved during suspend. This is
+ * not as simple as once thought, due to the possibility of glitches
+ * from the order that the CON and DAT registers are set in.
+ *
+ * The three states the pin can be are {IN,OUT,SFN} which gives us 9
+ * combinations of changes to check. Three of these, if the pin stays
+ * in the same configuration can be discounted. This leaves us with
+ * the following:
+ *
+ * { IN => OUT }  Change DAT first
+ * { IN => SFN }  Change CON first
+ * { OUT => SFN } Change CON first, so new data will not glitch
+ * { OUT => IN }  Change CON first, so new data will not glitch
+ * { SFN => IN }  Change CON first
+ * { SFN => OUT } Change DAT first, so new data will not glitch [1]
+ *
+ * We do not currently deal with the UP registers as these control
+ * weak resistors, so a small delay in change should not need to bring
+ * these into the calculations.
+ *
+ * [1] this assumes that writing to a pin DAT whilst in SFN will set the
+ *     state for when it is next output.
+ */
+static void s3c_gpio_pm_2bit_resume(struct s3c_gpio_chip *chip)
+{
+	void __iomem *base = chip->base;
+	u32 old_gpcon = __raw_readl(base + OFFS_CON);
+	u32 old_gpdat = __raw_readl(base + OFFS_DAT);
+	u32 gps_gpcon = chip->pm_save[0];
+	u32 gps_gpdat = chip->pm_save[1];
+	u32 gpcon, old, new, mask;
+	u32 change_mask = 0x0;
+	int nr;
+
+	/* restore GPIO pull-up settings */
+	__raw_writel(chip->pm_save[2], base + OFFS_UP);
+
+	/* Create a change_mask of all the items that need to have
+	 * their CON value changed before their DAT value, so that
+	 * we minimise the work between the two settings.
+	 */
+
+	for (nr = 0, mask = 0x03; nr < 32; nr += 2, mask <<= 2) {
+		old = (old_gpcon & mask) >> nr;
+		new = (gps_gpcon & mask) >> nr;
+
+		/* If there is no change, then skip */
+
+		if (old == new)
+			continue;
+
+		/* If both are special function, then skip */
+
+		if (is_sfn(old) && is_sfn(new))
+			continue;
+
+		/* Change is IN => OUT, do not change now */
+
+		if (is_in(old) && is_out(new))
+			continue;
+
+		/* Change is SFN => OUT, do not change now */
+
+		if (is_sfn(old) && is_out(new))
+			continue;
+
+		/* We should now be at the case of IN=>SFN,
+		 * OUT=>SFN, OUT=>IN, SFN=>IN. */
+
+		change_mask |= mask;
+	}
+
+
+	/* Write the new CON settings */
+
+	gpcon = old_gpcon & ~change_mask;
+	gpcon |= gps_gpcon & change_mask;
+
+	__raw_writel(gpcon, base + OFFS_CON);
+
+	/* Now change any items that require DAT,CON */
+
+	__raw_writel(gps_gpdat, base + OFFS_DAT);
+	__raw_writel(gps_gpcon, base + OFFS_CON);
+
+	S3C_PMDBG("%s: CON %08x => %08x, DAT %08x => %08x\n",
+		  chip->chip.label, old_gpcon, gps_gpcon, old_gpdat, gps_gpdat);
+}
+
+struct s3c_gpio_pm s3c_gpio_pm_2bit = {
+	.save	= s3c_gpio_pm_2bit_save,
+	.resume = s3c_gpio_pm_2bit_resume,
+};
+
+#ifdef CONFIG_ARCH_S3C64XX
+static void s3c_gpio_pm_4bit_save(struct s3c_gpio_chip *chip)
+{
+	chip->pm_save[1] = __raw_readl(chip->base + OFFS_CON);
+	chip->pm_save[2] = __raw_readl(chip->base + OFFS_DAT);
+	chip->pm_save[3] = __raw_readl(chip->base + OFFS_UP);
+
+	if (chip->chip.ngpio > 8)
+		chip->pm_save[0] = __raw_readl(chip->base - 4);
+}
+
+static u32 s3c_gpio_pm_4bit_mask(u32 old_gpcon, u32 gps_gpcon)
+{
+	u32 old, new, mask;
+	u32 change_mask = 0x0;
+	int nr;
+
+	for (nr = 0, mask = 0x0f; nr < 16; nr += 4, mask <<= 4) {
+		old = (old_gpcon & mask) >> nr;
+		new = (gps_gpcon & mask) >> nr;
+
+		/* If there is no change, then skip */
+
+		if (old == new)
+			continue;
+
+		/* If both are special function, then skip */
+
+		if (is_sfn(old) && is_sfn(new))
+			continue;
+
+		/* Change is IN => OUT, do not change now */
+
+		if (is_in(old) && is_out(new))
+			continue;
+
+		/* Change is SFN => OUT, do not change now */
+
+		if (is_sfn(old) && is_out(new))
+			continue;
+
+		/* We should now be at the case of IN=>SFN,
+		 * OUT=>SFN, OUT=>IN, SFN=>IN. */
+
+		change_mask |= mask;
+	}
+
+	return change_mask;
+}
+
+static void s3c_gpio_pm_4bit_con(struct s3c_gpio_chip *chip, int index)
+{
+	void __iomem *con = chip->base + (index * 4);
+	u32 old_gpcon = __raw_readl(con);
+	u32 gps_gpcon = chip->pm_save[index + 1];
+	u32 gpcon, mask;
+
+	mask = s3c_gpio_pm_4bit_mask(old_gpcon, gps_gpcon);
+
+	gpcon = old_gpcon & ~mask;
+	gpcon |= gps_gpcon & mask;
+
+	__raw_writel(gpcon, con);
+}
+
+static void s3c_gpio_pm_4bit_resume(struct s3c_gpio_chip *chip)
+{
+	void __iomem *base = chip->base;
+	u32 old_gpcon[2];
+	u32 old_gpdat = __raw_readl(base + OFFS_DAT);
+	u32 gps_gpdat = chip->pm_save[2];
+
+	/* First, modify the CON settings */
+
+	old_gpcon[0] = 0;
+	old_gpcon[1] = __raw_readl(base + OFFS_CON);
+
+	s3c_gpio_pm_4bit_con(chip, 0);
+	if (chip->chip.ngpio > 8) {
+		old_gpcon[0] = __raw_readl(base - 4);
+		s3c_gpio_pm_4bit_con(chip, -1);
+	}
+
+	/* Now change the configurations that require DAT,CON */
+
+	__raw_writel(chip->pm_save[2], base + OFFS_DAT);
+	__raw_writel(chip->pm_save[1], base + OFFS_CON);
+	if (chip->chip.ngpio > 8)
+		__raw_writel(chip->pm_save[0], base - 4);
+
+	__raw_writel(chip->pm_save[2], base + OFFS_DAT);
+	__raw_writel(chip->pm_save[3], base + OFFS_UP);
+
+	if (chip->chip.ngpio > 8) {
+		S3C_PMDBG("%s: CON4 %08x,%08x => %08x,%08x, DAT %08x => %08x\n",
+			  chip->chip.label, old_gpcon[0], old_gpcon[1],
+			  __raw_readl(base - 4),
+			  __raw_readl(base + OFFS_CON),
+			  old_gpdat, gps_gpdat);
+	} else
+		S3C_PMDBG("%s: CON4 %08x => %08x, DAT %08x => %08x\n",
+			  chip->chip.label, old_gpcon[1],
+			  __raw_readl(base + OFFS_CON),
+			  old_gpdat, gps_gpdat);
+}
+
+struct s3c_gpio_pm s3c_gpio_pm_4bit = {
+	.save	= s3c_gpio_pm_4bit_save,
+	.resume = s3c_gpio_pm_4bit_resume,
+};
+#endif /* CONFIG_ARCH_S3C64XX */
+
+/**
+ * s3c_pm_save_gpio() - save gpio chip data for suspend
+ * @ourchip: The chip for suspend.
+ */
+static void s3c_pm_save_gpio(struct s3c_gpio_chip *ourchip)
+{
+	struct s3c_gpio_pm *pm = ourchip->pm;
+
+	if (pm == NULL || pm->save == NULL)
+		S3C_PMDBG("%s: no pm for %s\n", __func__, ourchip->chip.label);
+	else
+		pm->save(ourchip);
+}
+
+/**
+ * s3c_pm_save_gpios() - Save the state of the GPIO banks.
+ *
+ * For all the GPIO banks, save the state of each one ready for going
+ * into a suspend mode.
+ */
+void s3c_pm_save_gpios(void)
+{
+	struct s3c_gpio_chip *ourchip;
+	unsigned int gpio_nr;
+
+	for (gpio_nr = 0; gpio_nr < S3C_GPIO_END; gpio_nr++) {
+		ourchip = s3c_gpiolib_getchip(gpio_nr);
+		if (!ourchip)
+			continue;
+
+		s3c_pm_save_gpio(ourchip);
+
+		S3C_PMDBG("%s: save %08x,%08x,%08x,%08x\n",
+			  ourchip->chip.label,
+			  ourchip->pm_save[0],
+			  ourchip->pm_save[1],
+			  ourchip->pm_save[2],
+			  ourchip->pm_save[3]);
+
+		gpio_nr += ourchip->chip.ngpio;
+		gpio_nr += CONFIG_S3C_GPIO_SPACE;
+	}
+}
+
+/**
+ * s3c_pm_resume_gpio() - restore gpio chip data after suspend
+ * @ourchip: The suspended chip.
+ */
+static void s3c_pm_resume_gpio(struct s3c_gpio_chip *ourchip)
+{
+	struct s3c_gpio_pm *pm = ourchip->pm;
+
+	if (pm == NULL || pm->resume == NULL)
+		S3C_PMDBG("%s: no pm for %s\n", __func__, ourchip->chip.label);
+	else
+		pm->resume(ourchip);
+}
+
+void s3c_pm_restore_gpios(void)
+{
+	struct s3c_gpio_chip *ourchip;
+	unsigned int gpio_nr;
+
+	for (gpio_nr = 0; gpio_nr < S3C_GPIO_END; gpio_nr++) {
+		ourchip = s3c_gpiolib_getchip(gpio_nr);
+		if (!ourchip)
+			continue;
+
+		s3c_pm_resume_gpio(ourchip);
+
+		gpio_nr += ourchip->chip.ngpio;
+		gpio_nr += CONFIG_S3C_GPIO_SPACE;
+	}
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pwm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pwm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/pwm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/pwm.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,288 @@
+/*
+ * arch/arm/plat-s3c/pwm.c
+ *
+ * Copyright (c) by Javi Roman <javiroman@kernel-labs.org>
+ * 		 for the Openmoko Project.
+ *
+ *     S3C2410A SoC PWM support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <mach/hardware.h>
+#include <plat/regs-timer.h>
+#include <plat/pwm.h>
+#include <asm/io.h>
+
+#ifdef CONFIG_PM
+	static unsigned long standby_reg_tcon;
+	static unsigned long standby_reg_tcfg0;
+	static unsigned long standby_reg_tcfg1;
+#endif
+
+int s3c2410_pwm_disable(struct s3c2410_pwm *pwm)
+{
+	unsigned long tcon;
+
+	/* stop timer */
+	tcon = __raw_readl(S3C2410_TCON);
+	tcon &= 0xffffff00;
+	__raw_writel(tcon, S3C2410_TCON);
+
+	clk_disable(pwm->pclk);
+	clk_put(pwm->pclk);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_disable);
+
+int s3c2410_pwm_init(struct s3c2410_pwm *pwm)
+{
+	pwm->pclk = clk_get(NULL, "timers");
+	if (IS_ERR(pwm->pclk))
+		return PTR_ERR(pwm->pclk);
+
+	clk_enable(pwm->pclk);
+	pwm->pclk_rate = clk_get_rate(pwm->pclk);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_init);
+
+int s3c2410_pwm_enable(struct s3c2410_pwm *pwm)
+{
+	unsigned long tcfg0, tcfg1, tcnt, tcmp;
+
+	/* control registers bits */
+	tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg0 = __raw_readl(S3C2410_TCFG0);
+
+	/* divider & scaler slection */
+	switch (pwm->timerid) {
+	case PWM0:
+		tcfg1 &= ~S3C2410_TCFG1_MUX0_MASK;
+		tcfg0 &= ~S3C2410_TCFG_PRESCALER0_MASK;
+		break;
+	case PWM1:
+		tcfg1 &= ~S3C2410_TCFG1_MUX1_MASK;
+		tcfg0 &= ~S3C2410_TCFG_PRESCALER0_MASK;
+		break;
+	case PWM2:
+		tcfg1 &= ~S3C2410_TCFG1_MUX2_MASK;
+		tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
+		break;
+	case PWM3:
+		tcfg1 &= ~S3C2410_TCFG1_MUX3_MASK;
+		tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
+		break;
+	case PWM4:
+		/* timer four is not capable of doing PWM */
+		break;
+	default:
+		clk_disable(pwm->pclk);
+		clk_put(pwm->pclk);
+		return -1;
+	}
+
+	/* divider & scaler values */
+	tcfg1 |= pwm->divider;
+	__raw_writel(tcfg1, S3C2410_TCFG1);
+
+	switch (pwm->timerid) {
+	case PWM0:
+	case PWM1:
+		tcfg0 |= pwm->prescaler;
+		__raw_writel(tcfg0, S3C2410_TCFG0);
+		break;
+	default:
+		if ((tcfg0 | pwm->prescaler) != tcfg0) {
+			printk(KERN_WARNING "not changing prescaler of PWM %u,"
+			       " since it's shared with timer4 (clock tick)\n",
+			       pwm->timerid);
+		}
+		break;
+	}
+
+	/* timer count and compare buffer initial values */
+	tcnt = pwm->counter;
+	tcmp = pwm->comparer;
+
+	__raw_writel(tcnt, S3C2410_TCNTB(pwm->timerid));
+	__raw_writel(tcmp, S3C2410_TCMPB(pwm->timerid));
+
+	/* ensure timer is stopped */
+	s3c2410_pwm_stop(pwm);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_enable);
+
+int s3c2410_pwm_start(struct s3c2410_pwm *pwm)
+{
+	unsigned long tcon;
+
+	tcon = __raw_readl(S3C2410_TCON);
+
+	switch (pwm->timerid) {
+	case PWM0:
+		tcon |= S3C2410_TCON_T0START;
+		tcon &= ~S3C2410_TCON_T0MANUALUPD;
+		break;
+	case PWM1:
+		tcon |= S3C2410_TCON_T1START;
+		tcon &= ~S3C2410_TCON_T1MANUALUPD;
+		break;
+	case PWM2:
+		tcon |= S3C2410_TCON_T2START;
+		tcon &= ~S3C2410_TCON_T2MANUALUPD;
+		break;
+	case PWM3:
+		tcon |= S3C2410_TCON_T3START;
+		tcon &= ~S3C2410_TCON_T3MANUALUPD;
+		break;
+	case PWM4:
+		/* timer four is not capable of doing PWM */
+	default:
+		return -ENODEV;
+	}
+
+	__raw_writel(tcon, S3C2410_TCON);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_start);
+
+int s3c2410_pwm_stop(struct s3c2410_pwm *pwm)
+{
+	unsigned long tcon;
+
+	tcon = __raw_readl(S3C2410_TCON);
+
+	switch (pwm->timerid) {
+	case PWM0:
+		tcon &= ~0x00000000;
+		tcon |= S3C2410_TCON_T0RELOAD;
+		tcon |= S3C2410_TCON_T0MANUALUPD;
+		break;
+	case PWM1:
+		tcon &= ~0x00000080;
+		tcon |= S3C2410_TCON_T1RELOAD;
+		tcon |= S3C2410_TCON_T1MANUALUPD;
+		break;
+	case PWM2:
+		tcon &= ~0x00000800;
+		tcon |= S3C2410_TCON_T2RELOAD;
+		tcon |= S3C2410_TCON_T2MANUALUPD;
+		break;
+	case PWM3:
+		tcon &= ~0x00008000;
+		tcon |= S3C2410_TCON_T3RELOAD;
+		tcon |= S3C2410_TCON_T3MANUALUPD;
+		break;
+	case PWM4:
+		/* timer four is not capable of doing PWM */
+	default:
+		return -ENODEV;
+	}
+
+	__raw_writel(tcon, S3C2410_TCON);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_stop);
+
+int s3c2410_pwm_duty_cycle(int reg_value, struct s3c2410_pwm *pwm)
+{
+	__raw_writel(reg_value, S3C2410_TCMPB(pwm->timerid));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_duty_cycle);
+
+int s3c2410_pwm_dumpregs(void)
+{
+	printk(KERN_INFO "TCON: %08lx, TCFG0: %08lx, TCFG1: %08lx\n",
+			(unsigned long)	__raw_readl(S3C2410_TCON),
+			(unsigned long)	__raw_readl(S3C2410_TCFG0),
+			(unsigned long)	__raw_readl(S3C2410_TCFG1));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2410_pwm_dumpregs);
+
+static int __init s3c24xx_pwm_probe(struct platform_device *pdev)
+{
+	struct s3c24xx_pwm_platform_data *pdata = pdev->dev.platform_data;
+
+	dev_info(&pdev->dev, "s3c24xx_pwm is registered \n");
+
+	/* if platform was interested, give him a chance to register
+	 * platform devices that switch power with us as the parent
+	 * at registration time -- ensures suspend / resume ordering
+	 */
+	if (pdata)
+		if (pdata->attach_child_devices)
+			(pdata->attach_child_devices)(&pdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c24xx_pwm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	/* PWM config should be kept in suspending */
+	standby_reg_tcon = __raw_readl(S3C2410_TCON);
+	standby_reg_tcfg0 = __raw_readl(S3C2410_TCFG0);
+	standby_reg_tcfg1 = __raw_readl(S3C2410_TCFG1);
+
+	return 0;
+}
+
+static int s3c24xx_pwm_resume(struct platform_device *pdev)
+{
+	__raw_writel(standby_reg_tcon, S3C2410_TCON);
+	__raw_writel(standby_reg_tcfg0, S3C2410_TCFG0);
+	__raw_writel(standby_reg_tcfg1, S3C2410_TCFG1);
+
+	return 0;
+}
+#else
+#define s3c24xx_pwm_suspend	NULL
+#define s3c24xx_pwm_resume	NULL
+#endif
+
+static struct platform_driver s3c24xx_pwm_driver = {
+	.driver = {
+		.name	= "s3c24xx_pwm",
+		.owner	= THIS_MODULE,
+	},
+	.probe	 = s3c24xx_pwm_probe,
+	.suspend = s3c24xx_pwm_suspend,
+	.resume	 = s3c24xx_pwm_resume,
+};
+
+static int __init s3c24xx_pwm_init(void)
+{
+	return platform_driver_register(&s3c24xx_pwm_driver);
+}
+
+static void __exit s3c24xx_pwm_exit(void)
+{
+}
+
+MODULE_AUTHOR("Javi Roman <javiroman@kernel-labs.org>");
+MODULE_LICENSE("GPL");
+
+module_init(s3c24xx_pwm_init);
+module_exit(s3c24xx_pwm_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/time.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/time.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c/time.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c/time.c	2009-05-10 22:27:59.000000000 +0200
@@ -97,7 +97,7 @@
  * IRQs are disabled before entering here from do_gettimeofday()
  */
 
-static unsigned long s3c2410_gettimeoffset (void)
+unsigned long s3c2410_gettimeoffset (void)
 {
 	unsigned long tdone;
 	unsigned long tval;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/clock-dclk.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/clock-dclk.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/clock-dclk.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/clock-dclk.c	2009-05-10 22:27:59.000000000 +0200
@@ -18,6 +18,7 @@
 
 #include <mach/regs-clock.h>
 #include <mach/regs-gpio.h>
+#include <mach/hardware.h>
 
 #include <plat/clock.h>
 #include <plat/cpu.h>
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/common-smdk.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/common-smdk.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/common-smdk.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/common-smdk.c	2009-05-10 22:27:59.000000000 +0200
@@ -201,5 +201,5 @@
 
 	platform_add_devices(smdk_devs, ARRAY_SIZE(smdk_devs));
 
-	s3c2410_pm_init();
+	s3c_pm_init();
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/cpu.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/cpu.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/cpu.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/cpu.c	2009-05-10 22:27:59.000000000 +0200
@@ -61,6 +61,7 @@
 static const char name_s3c2412[]  = "S3C2412";
 static const char name_s3c2440[]  = "S3C2440";
 static const char name_s3c2442[]  = "S3C2442";
+static const char name_s3c2442b[]  = "S3C2442B";
 static const char name_s3c2443[]  = "S3C2443";
 static const char name_s3c2410a[] = "S3C2410A";
 static const char name_s3c2440a[] = "S3C2440A";
@@ -112,6 +113,15 @@
 		.name		= name_s3c2442
 	},
 	{
+		.idcode		= 0x32440aab,
+		.idmask		= 0xffffffff,
+		.map_io		= s3c244x_map_io,
+		.init_clocks	= s3c244x_init_clocks,
+		.init_uarts	= s3c244x_init_uarts,
+		.init		= s3c2442_init,
+		.name		= name_s3c2442b
+	},
+	{
 		.idcode		= 0x32412001,
 		.idmask		= 0xffffffff,
 		.map_io		= s3c2412_map_io,
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/devs.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/devs.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/devs.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/devs.c	2009-05-10 22:27:59.000000000 +0200
@@ -26,6 +26,8 @@
 #include <asm/mach/irq.h>
 #include <mach/fb.h>
 #include <mach/hardware.h>
+#include <mach/ts.h>
+#include <asm/io.h>
 #include <asm/irq.h>
 
 #include <plat/regs-serial.h>
@@ -136,36 +138,6 @@
 struct platform_device *s3c24xx_uart_devs[4] = {
 };
 
-/* USB Host Controller */
-
-static struct resource s3c_usb_resource[] = {
-	[0] = {
-		.start = S3C24XX_PA_USBHOST,
-		.end   = S3C24XX_PA_USBHOST + S3C24XX_SZ_USBHOST - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = IRQ_USBH,
-		.end   = IRQ_USBH,
-		.flags = IORESOURCE_IRQ,
-	}
-};
-
-static u64 s3c_device_usb_dmamask = 0xffffffffUL;
-
-struct platform_device s3c_device_usb = {
-	.name		  = "s3c2410-ohci",
-	.id		  = -1,
-	.num_resources	  = ARRAY_SIZE(s3c_usb_resource),
-	.resource	  = s3c_usb_resource,
-	.dev              = {
-		.dma_mask = &s3c_device_usb_dmamask,
-		.coherent_dma_mask = 0xffffffffUL
-	}
-};
-
-EXPORT_SYMBOL(s3c_device_usb);
-
 /* LCD Controller */
 
 static struct resource s3c_lcd_resource[] = {
@@ -229,6 +201,24 @@
 
 EXPORT_SYMBOL(s3c_device_nand);
 
+/* Touchscreen */
+struct platform_device s3c_device_ts = {
+	.name		  = "s3c2410-ts",
+	.id		  = -1,
+};
+
+EXPORT_SYMBOL(s3c_device_ts);
+
+static struct s3c2410_ts_mach_info s3c2410ts_info;
+
+void set_s3c2410ts_info(const struct s3c2410_ts_mach_info *hard_s3c2410ts_info)
+{
+	memcpy(&s3c2410ts_info, hard_s3c2410ts_info,
+	       sizeof(struct s3c2410_ts_mach_info));
+	s3c_device_ts.dev.platform_data = &s3c2410ts_info;
+}
+EXPORT_SYMBOL(set_s3c2410ts_info);
+
 /* USB Device (Gadget)*/
 
 static struct resource s3c_usbgadget_resource[] = {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/dma.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -31,10 +31,11 @@
 #include <asm/irq.h>
 #include <mach/hardware.h>
 #include <mach/dma.h>
-
 #include <mach/map.h>
 
-#include <plat/dma.h>
+#include <plat/dma-core.h>
+#include <plat/regs-dma.h>
+#include <plat/dma-plat.h>
 
 /* io map for dma */
 static void __iomem *dma_base;
@@ -44,8 +45,6 @@
 
 static struct s3c24xx_dma_selection dma_sel;
 
-/* dma channel state information */
-struct s3c2410_dma_chan s3c2410_chans[S3C2410_DMA_CHANNELS];
 
 /* debugging functions */
 
@@ -135,21 +134,6 @@
 #define dbg_showchan(chan) do { } while(0)
 #endif /* CONFIG_S3C2410_DMA_DEBUG */
 
-static struct s3c2410_dma_chan *dma_chan_map[DMACH_MAX];
-
-/* lookup_dma_channel
- *
- * change the dma channel number given into a real dma channel id
-*/
-
-static struct s3c2410_dma_chan *lookup_dma_channel(unsigned int channel)
-{
-	if (channel & DMACH_LOW_LEVEL)
-		return &s3c2410_chans[channel & ~DMACH_LOW_LEVEL];
-	else
-		return dma_chan_map[channel];
-}
-
 /* s3c2410_dma_stats_timeout
  *
  * Update DMA stats from timeout info
@@ -214,8 +198,6 @@
 	return 0;
 }
 
-
-
 /* s3c2410_dma_loadbuffer
  *
  * load a buffer, and update the channel state
@@ -453,7 +435,7 @@
 int s3c2410_dma_enqueue(unsigned int channel, void *id,
 			dma_addr_t data, int size)
 {
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
 	struct s3c2410_dma_buf *buf;
 	unsigned long flags;
 
@@ -804,7 +786,7 @@
 
 int s3c2410_dma_free(unsigned int channel, struct s3c2410_dma_client *client)
 {
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
 	unsigned long flags;
 
 	if (chan == NULL)
@@ -836,7 +818,7 @@
 	chan->irq_claimed = 0;
 
 	if (!(channel & DMACH_LOW_LEVEL))
-		dma_chan_map[channel] = NULL;
+		s3c_dma_chan_map[channel] = NULL;
 
 	local_irq_restore(flags);
 
@@ -995,7 +977,7 @@
 int
 s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op)
 {
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
 
 	if (chan == NULL)
 		return -EINVAL;
@@ -1038,14 +1020,13 @@
 /* s3c2410_dma_config
  *
  * xfersize:     size of unit in bytes (1,2,4)
- * dcon:         base value of the DCONx register
 */
 
 int s3c2410_dma_config(unsigned int channel,
-		       int xferunit,
-		       int dcon)
+		       int xferunit)
 {
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+	unsigned int dcon;
 
 	pr_debug("%s: chan=%d, xfer_unit=%d, dcon=%08x\n",
 		 __func__, channel, xferunit, dcon);
@@ -1055,10 +1036,33 @@
 
 	pr_debug("%s: Initial dcon is %08x\n", __func__, dcon);
 
-	dcon |= chan->dcon & dma_sel.dcon_mask;
+	dcon = chan->dcon & dma_sel.dcon_mask;
 
 	pr_debug("%s: New dcon is %08x\n", __func__, dcon);
 
+	switch (chan->req_ch) {
+	case DMACH_I2S_IN:
+	case DMACH_I2S_OUT:
+	case DMACH_PCM_IN:
+	case DMACH_PCM_OUT:
+	case DMACH_MIC_IN:
+	default:
+		dcon |= S3C2410_DCON_HANDSHAKE;
+		dcon |= S3C2410_DCON_SYNC_PCLK;
+		break;
+
+	case DMACH_SDI:
+		/* note, ensure if need HANDSHAKE or not */
+		dcon |= S3C2410_DCON_SYNC_PCLK;
+		break;		
+
+	case DMACH_XD0:
+	case DMACH_XD1:
+		dcon |= S3C2410_DCON_HANDSHAKE;
+		dcon |= S3C2410_DCON_SYNC_HCLK;
+		break;
+	}
+
 	switch (xferunit) {
 	case 1:
 		dcon |= S3C2410_DCON_BYTE;
@@ -1089,10 +1093,10 @@
 }
 
 EXPORT_SYMBOL(s3c2410_dma_config);
-
+#if 0 /* moved to plat-s3c? */
 int s3c2410_dma_setflags(unsigned int channel, unsigned int flags)
 {
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
 
 	if (chan == NULL)
 		return -EINVAL;
@@ -1105,43 +1109,7 @@
 }
 
 EXPORT_SYMBOL(s3c2410_dma_setflags);
-
-
-/* do we need to protect the settings of the fields from
- * irq?
-*/
-
-int s3c2410_dma_set_opfn(unsigned int channel, s3c2410_dma_opfn_t rtn)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: chan=%p, op rtn=%p\n", __func__, chan, rtn);
-
-	chan->op_fn = rtn;
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_set_opfn);
-
-int s3c2410_dma_set_buffdone_fn(unsigned int channel, s3c2410_dma_cbfn_t rtn)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: chan=%p, callback rtn=%p\n", __func__, chan, rtn);
-
-	chan->callback_fn = rtn;
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_set_buffdone_fn);
+#endif
 
 /* s3c2410_dma_devconfig
  *
@@ -1150,29 +1118,38 @@
  * source:    S3C2410_DMASRC_HW: source is hardware
  *            S3C2410_DMASRC_MEM: source is memory
  *
- * hwcfg:     the value for xxxSTCn register,
- *            bit 0: 0=increment pointer, 1=leave pointer
- *            bit 1: 0=source is AHB, 1=source is APB
- *
  * devaddr:   physical address of the source
 */
 
 int s3c2410_dma_devconfig(int channel,
 			  enum s3c2410_dmasrc source,
-			  int hwcfg,
 			  unsigned long devaddr)
 {
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+	unsigned int hwcfg;
 
 	if (chan == NULL)
 		return -EINVAL;
 
-	pr_debug("%s: source=%d, hwcfg=%08x, devaddr=%08lx\n",
-		 __func__, (int)source, hwcfg, devaddr);
+	pr_debug("%s: source=%d, devaddr=%08lx\n",
+		 __func__, (int)source, devaddr);
 
 	chan->source = source;
 	chan->dev_addr = devaddr;
-	chan->hw_cfg = hwcfg;
+
+	switch (chan->req_ch) {
+	case DMACH_XD0:
+	case DMACH_XD1:
+		hwcfg = 0; /* AHB */
+		break;
+
+	default:
+		hwcfg = S3C2410_DISRCC_APB;
+	}
+
+	/* always assume our peripheral desintation is a fixed
+	 * address in memory. */
+	 hwcfg |= S3C2410_DISRCC_INC;
 
 	switch (source) {
 	case S3C2410_DMASRC_HW:
@@ -1219,7 +1196,7 @@
 
 int s3c2410_dma_getposition(unsigned int channel, dma_addr_t *src, dma_addr_t *dst)
 {
- 	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
+ 	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
 
 	if (chan == NULL)
 		return -EINVAL;
@@ -1278,8 +1255,8 @@
 
 	printk(KERN_INFO "dma%d: restoring configuration\n", cp->number);
 
-	s3c2410_dma_config(no, cp->xfer_unit, cp->dcon);
-	s3c2410_dma_devconfig(no, cp->source, cp->hw_cfg, cp->dev_addr);
+	s3c2410_dma_config(no, cp->xfer_unit);
+	s3c2410_dma_devconfig(no, cp->source, cp->dev_addr);
 
 	/* re-select the dma source for this channel */
 
@@ -1476,7 +1453,8 @@
  found:
 	dmach = &s3c2410_chans[ch];
 	dmach->map = ch_map;
-	dma_chan_map[channel] = dmach;
+	dmach->req_ch = channel;
+	s3c_dma_chan_map[channel] = dmach;
 
 	/* select the channel */
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/gpio.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/gpio.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/gpio.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/gpio.c	2009-05-10 22:27:59.000000000 +0200
@@ -32,6 +32,7 @@
 #include <asm/irq.h>
 
 #include <mach/regs-gpio.h>
+#include <mach/regs-gpioj.h>
 
 void s3c2410_gpio_cfgpin(unsigned int pin, unsigned int function)
 {
@@ -215,3 +216,423 @@
 }
 
 EXPORT_SYMBOL(s3c2410_gpio_irq2pin);
+
+static void pretty_dump(u32 cfg, u32 state, u32 pull,
+			const char ** function_names_2,
+			const char ** function_names_3,
+			const char * prefix,
+			int count)
+{
+	int n;
+	const char *tag_type = NULL,
+		   *tag_state = NULL,
+		   *tag_pulldown = NULL,
+		   * level0 = "0",
+		   * level1 = "1";
+
+	for (n = 0; n < count; n++) {
+		switch ((cfg >> (2 * n)) & 3) {
+		case 0:
+			tag_type = "input      ";
+			break;
+		case 1:
+			tag_type = "OUTPUT     ";
+			break;
+		case 2:
+			if (function_names_2) {
+				if (function_names_2[n])
+					tag_type = function_names_2[n];
+				else
+					tag_type = "*** ILLEGAL CFG (2) *** ";
+			} else
+				tag_type = "(function) ";
+			break;
+		default:
+			if (function_names_3) {
+				if (function_names_3[n])
+					tag_type = function_names_3[n];
+				else
+					tag_type = "*** ILLEGAL CFG (3) *** ";
+			} else
+				tag_type = "(function) ";
+			break;
+		}
+		if ((state >> n) & 1)
+			tag_state = level1;
+		else
+			tag_state = level0;
+
+		if (((pull >> n) & 1))
+			tag_pulldown = "";
+		else
+			tag_pulldown = "(pulldown)";
+
+		printk(KERN_INFO"%s%02d: %s %s %s\n", prefix, n, tag_type,
+						      tag_state, tag_pulldown);
+	}
+	printk(KERN_INFO"\n");
+}
+
+static void pretty_dump_a(u32 cfg, u32 state,
+			  const char ** function_names,
+			  const char * prefix,
+			  int count)
+{
+	int n;
+	const char *tag_type = NULL,
+		   *tag_state = NULL,
+		   * level0 = "0",
+		   * level1 = "1";
+
+	for (n = 0; n < count; n++) {
+		switch ((cfg >> n) & 1) {
+		case 0:
+			tag_type = "OUTPUT     ";
+			break;
+		default:
+			if (function_names) {
+				if (function_names[n])
+					tag_type = function_names[n];
+				else
+					tag_type = "*** ILLEGAL CFG *** ";
+			} else
+				tag_type = "(function) ";
+			break;
+		}
+		if ((state >> n) & 1)
+			tag_state = level1;
+		else
+			tag_state = level0;
+
+		printk(KERN_INFO"%s%02d: %s %s\n", prefix, n, tag_type,
+						   tag_state);
+	}
+	printk(KERN_INFO"\n");
+}
+
+static const char * funcs_a[] = {
+	"ADDR0      ",
+	"ADDR16     ",
+	"ADDR17     ",
+	"ADDR18     ",
+	"ADDR19     ",
+	"ADDR20     ",
+	"ADDR21     ",
+	"ADDR22     ",
+	"ADDR23     ",
+	"ADDR24     ",
+	"ADDR25     ",
+	"ADDR26     ",
+	"nGCS[1]    ",
+	"nGCS[2]    ",
+	"nGCS[3]    ",
+	"nGCS[4]    ",
+	"nGCS[5]    ",
+	"CLE        ",
+	"ALE        ",
+	"nFWE       ",
+	"nFRE       ",
+	"nRSTOUT    ",
+	"nFCE       ",
+	NULL,
+	NULL
+};
+
+
+static const char * funcs_b2[] = {
+	"TOUT0      ",
+	"TOUT1      ",
+	"TOUT2      ",
+	"TOUT3      ",
+	"TCLK[0]    ",
+	"nXBACK     ",
+	"nXBREQ     ",
+	"nXDACK1    ",
+	"nXDREQ1    ",
+	"nXDACK0    ",
+	"nXDREQ0    ",
+};
+static const char * funcs_b3[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const char * funcs_c2[] = {
+	"LEND       ",
+	"VCLK       ",
+	"VLINE      ",
+	"VFRAME     ",
+	"VM         ",
+	"LCD_LPCOE  ",
+	"LCD_LPCREV ",
+	"LCD_LPCREVB",
+	"VD[0]      ",
+	"VD[1]      ",
+	"VD[2]      ",
+	"VD[3]      ",
+	"VD[4]      ",
+	"VD[5]      ",
+	"VD[6]      ",
+	"VD[7]      ",
+};
+static const char * funcs_c3[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	"I2SSDI     ",
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const char * funcs_d2[] = {
+	"VD[8]      ",
+	"VD[9]      ",
+	"VD[10]     ",
+	"VD[11]     ",
+	"VD[12]     ",
+	"VD[13]     ",
+	"VD[14]     ",
+	"VD[15]     ",
+	"VD[16]     ",
+	"VD[17]     ",
+	"VD[18]     ",
+	"VD[19]     ",
+	"VD[20]     ",
+	"VD[21]     ",
+	"VD[22]     ",
+	"VD[23]     ",
+};
+static const char * funcs_d3[] = {
+	"nSPICS1    ",
+	"SPICLK1    ",
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	"SPIMISO1   ",
+	"SPIMOSI1   ",
+	"SPICLK1    ",
+	NULL,
+	NULL,
+	NULL,
+	"nSS1       ",
+	"nSS0       ",
+};
+
+static const char * funcs_e2[] = {
+	"I2SLRCK    ",
+	"I2SSCLK    ",
+	"CDCLK      ",
+	"I2SDI      ",
+	"I2SDO      ",
+	"SDCLK      ",
+	"SDCMD      ",
+	"SDDAT0     ",
+	"SDDAT1     ",
+	"SDDAT2     ",
+	"SDDAT3     ",
+	"SPIMISO0   ",
+	"SPIMOSI0   ",
+	"SPICLK0    ",
+	"IICSCL     ",
+	"IICSDA     ",
+};
+static const char * funcs_e3[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const char * funcs_f2[] = {
+	"EINT[0]    ",
+	"EINT[1]    ",
+	"EINT[2]    ",
+	"EINT[3]    ",
+	"EINT[4]    ",
+	"EINT[5]    ",
+	"EINT[6]    ",
+	"EINT[7]    ",
+};
+static const char * funcs_f3[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+
+static const char * funcs_g2[] = {
+	"EINT[8]    ",
+	"EINT[9]    ",
+	"EINT[10]   ",
+	"EINT[11]   ",
+	"EINT[12]   ",
+	"EINT[13]   ",
+	"EINT[14]   ",
+	"EINT[15]   ",
+	"EINT[16]   ",
+	"EINT[17]   ",
+	"EINT[18]   ",
+	"EINT[19]   ",
+	"EINT[20]   ",
+	"EINT[21]   ",
+	"EINT[22]   ",
+	"EINT[23]   ",
+};
+static const char * funcs_g3[] = {
+	NULL,
+	NULL,
+	"nSS0       ",
+	"nSS1       ",
+	"LCD_PWRDN  ",
+	"SPIMISO1   ",
+	"SPIMOSI1   ",
+	"SPICLK1    ",
+	NULL,
+	"nRTS1      ",
+	"nCTS1      ",
+	"TCLK[1]    ",
+	"nSPICS0    ",
+	NULL,
+	NULL,
+	NULL,
+};
+
+static const char * funcs_h2[] = {
+	"nCTS0      ",
+	"nRTS0      ",
+	"TXD[0]     ",
+	"RXD[0]     ",
+	"TXD[1]     ",
+	"RXD[1]     ",
+	"TXD[2]     ",
+	"RXD[2]     ",
+	"UEXTCLK    ",
+	"CLKOUT0    ",
+	"CLKOUT1    ",
+};
+static const char * funcs_h3[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	"nRTS1      ",
+	"nCTS1      ",
+	NULL,
+	"nSPICS0    ",
+	NULL,
+};
+
+static const char * funcs_j2[] = {
+	"CAMDATA[0] ",
+	"CAMDATA[1] ",
+	"CAMDATA[2] ",
+	"CAMDATA[3] ",
+	"CAMDATA[4] ",
+	"CAMDATA[5] ",
+	"CAMDATA[6] ",
+	"CAMDATA[7] ",
+	"CAMPCLK    ",
+	"CAMVSYNC   ",
+	"CAMHREF    ",
+	"CAMCLKOUT  ",
+	"CAMRESET   ",
+};
+static const char * funcs_j3[] = {
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+/* used to dump GPIO states at suspend */
+void s3c24xx_dump_gpio_states(void)
+{
+	pretty_dump_a(__raw_readl(S3C2410_GPACON),
+		      __raw_readl(S3C2410_GPADAT),
+		      funcs_a, "GPA", 25);
+	pretty_dump(__raw_readl(S3C2410_GPBCON),
+		    __raw_readl(S3C2410_GPBDAT),
+		    __raw_readl(S3C2410_GPBUP),
+		    funcs_b2, funcs_b3, "GPB", 11);
+	pretty_dump(__raw_readl(S3C2410_GPCCON),
+		    __raw_readl(S3C2410_GPCDAT),
+		    __raw_readl(S3C2410_GPCUP),
+		    funcs_c2, funcs_c3, "GPC", 16);
+	pretty_dump(__raw_readl(S3C2410_GPDCON),
+		    __raw_readl(S3C2410_GPDDAT),
+		    __raw_readl(S3C2410_GPDUP),
+		    funcs_d2, funcs_d3, "GPD", 16);
+	pretty_dump(__raw_readl(S3C2410_GPECON),
+		    __raw_readl(S3C2410_GPEDAT),
+		    __raw_readl(S3C2410_GPEUP),
+		    funcs_e2, funcs_e3, "GPE", 16);
+	pretty_dump(__raw_readl(S3C2410_GPFCON),
+		    __raw_readl(S3C2410_GPFDAT),
+		    __raw_readl(S3C2410_GPFUP),
+		    funcs_f2, funcs_f3, "GPF", 8);
+	pretty_dump(__raw_readl(S3C2410_GPGCON),
+		    __raw_readl(S3C2410_GPGDAT),
+		    __raw_readl(S3C2410_GPGUP),
+		    funcs_g2, funcs_g3, "GPG", 16);
+	pretty_dump(__raw_readl(S3C2410_GPHCON),
+		    __raw_readl(S3C2410_GPHDAT),
+		    __raw_readl(S3C2410_GPHUP),
+		    funcs_h2, funcs_h3, "GPH", 11);
+	pretty_dump(__raw_readl(S3C2440_GPJCON),
+		    __raw_readl(S3C2440_GPJDAT),
+		    __raw_readl(S3C2440_GPJUP),
+		    funcs_j2, funcs_j3, "GPJ", 13);
+
+}
+EXPORT_SYMBOL(s3c24xx_dump_gpio_states);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/gpiolib.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/gpiolib.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/gpiolib.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/gpiolib.c	2009-05-10 22:27:59.000000000 +0200
@@ -22,6 +22,7 @@
 #include <plat/gpio-core.h>
 #include <mach/hardware.h>
 #include <asm/irq.h>
+#include <plat/pm.h>
 
 #include <mach/regs-gpio.h>
 
@@ -78,6 +79,7 @@
 struct s3c_gpio_chip s3c24xx_gpios[] = {
 	[0] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPA0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_1bit),
 		.chip	= {
 			.base			= S3C2410_GPA0,
 			.owner			= THIS_MODULE,
@@ -89,6 +91,7 @@
 	},
 	[1] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPB0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
 		.chip	= {
 			.base			= S3C2410_GPB0,
 			.owner			= THIS_MODULE,
@@ -98,6 +101,7 @@
 	},
 	[2] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPC0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
 		.chip	= {
 			.base			= S3C2410_GPC0,
 			.owner			= THIS_MODULE,
@@ -107,6 +111,7 @@
 	},
 	[3] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPD0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
 		.chip	= {
 			.base			= S3C2410_GPD0,
 			.owner			= THIS_MODULE,
@@ -116,6 +121,7 @@
 	},
 	[4] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPE0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
 		.chip	= {
 			.base			= S3C2410_GPE0,
 			.label			= "GPIOE",
@@ -125,6 +131,7 @@
 	},
 	[5] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPF0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
 		.chip	= {
 			.base			= S3C2410_GPF0,
 			.owner			= THIS_MODULE,
@@ -135,12 +142,23 @@
 	},
 	[6] = {
 		.base	= S3C24XX_GPIO_BASE(S3C2410_GPG0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
 		.chip	= {
 			.base			= S3C2410_GPG0,
 			.owner			= THIS_MODULE,
 			.label			= "GPIOG",
-			.ngpio			= 10,
 			.to_irq			= s3c24xx_gpiolib_bankg_toirq,
+			.ngpio			= 16,
+		},
+	},
+	[7] = {
+		.base	= S3C24XX_GPIO_BASE(S3C2410_GPH0),
+		.pm	= __gpio_pm(&s3c_gpio_pm_2bit),
+		.chip	= {
+			.base			= S3C2410_GPH0,
+			.owner			= THIS_MODULE,
+			.label			= "GPIOH",
+			.ngpio			= 11,
 		},
 	},
 };
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/gta02_pm_wlan.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/gta02_pm_wlan.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/gta02_pm_wlan.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/gta02_pm_wlan.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,222 @@
+/*
+ * GTA02 WLAN power management
+ *
+ * (C) 2008, 2009 by Openmoko Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+
+#include <mach/gta02.h>
+#include <mach/gta02-pm-wlan.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-gpioj.h>
+
+#include <linux/delay.h>
+#include <linux/rfkill.h>
+
+
+/* ----- Module hardware reset ("power") ----------------------------------- */
+
+
+void gta02_wlan_reset(int assert_reset)
+{
+	if (assert_reset) {
+		s3c2410_gpio_setpin(GTA02_GPIO_nWLAN_RESET, 0);
+		msleep(200); /* probably excessive but we don't have specs */
+	} else {
+		s3c2410_gpio_setpin(GTA02_GPIO_nWLAN_RESET, 1);
+	}
+}
+
+#ifdef CONFIG_PM
+static int gta02_wlan_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dev_dbg(&pdev->dev, "suspending\n");
+
+	return 0;
+}
+
+static int gta02_wlan_resume(struct platform_device *pdev)
+{
+	dev_dbg(&pdev->dev, "resuming\n");
+
+	return 0;
+}
+#else
+#define gta02_wlan_suspend	NULL
+#define gta02_wlan_resume		NULL
+#endif
+
+
+/* ----- rfkill ------------------------------------------------------------ */
+
+/*
+ * S3C MCI handles suspend/resume through device removal/insertion. In order to
+ * preserve rfkill state, as required in clause 7 of section 3.1 in rfkill.txt,
+ * we therefore need to maintain rfkill state outside the driver.
+ *
+ * This platform driver is as good a place as any other.
+ */
+
+static int (*gta02_wlan_rfkill_cb)(void *user, int on);
+static void *gta02_wlan_rfkill_user;
+static DEFINE_MUTEX(gta02_wlan_rfkill_lock);
+static int gta02_wlan_rfkill_on;
+
+
+/*
+ * gta02_wlan_query_rfkill_lock is used to obtain the rfkill state before the
+ * driver is ready to process rfkill callbacks. To prevent the state from
+ * changing until the driver has completed its initialization, we grab and hold
+ * the rfkill lock.
+ *
+ * A call to gta02_wlan_query_rfkill_lock must be followed by either
+ * - a call to gta02_wlan_set_rfkill_cb, to complete the setup, or
+ * - a call to gta02_wlan_query_rfkill_unlock to abort the setup process.
+ */
+
+int gta02_wlan_query_rfkill_lock(void)
+{
+	mutex_lock(&gta02_wlan_rfkill_lock);
+	return gta02_wlan_rfkill_on;
+}
+EXPORT_SYMBOL_GPL(gta02_wlan_query_rfkill_lock);
+
+void gta02_wlan_query_rfkill_unlock(void)
+{
+	mutex_unlock(&gta02_wlan_rfkill_lock);
+}
+EXPORT_SYMBOL_GPL(gta02_wlan_query_rfkill_unlock);
+
+
+void gta02_wlan_set_rfkill_cb(int (*cb)(void *user, int on), void *user)
+{
+	BUG_ON(!mutex_is_locked(&gta02_wlan_rfkill_lock));
+	BUG_ON(gta02_wlan_rfkill_cb);
+	gta02_wlan_rfkill_cb = cb;
+	gta02_wlan_rfkill_user = user;
+	mutex_unlock(&gta02_wlan_rfkill_lock);
+}
+EXPORT_SYMBOL_GPL(gta02_wlan_set_rfkill_cb);
+
+void gta02_wlan_clear_rfkill_cb(void)
+{
+	mutex_lock(&gta02_wlan_rfkill_lock);
+	BUG_ON(!gta02_wlan_rfkill_cb);
+	gta02_wlan_rfkill_cb = NULL;
+	mutex_unlock(&gta02_wlan_rfkill_lock);
+}
+EXPORT_SYMBOL_GPL(gta02_wlan_clear_rfkill_cb);
+
+static int gta02_wlan_toggle_radio(void *data, enum rfkill_state state)
+{
+	struct device *dev = data;
+	int on = state == RFKILL_STATE_UNBLOCKED;
+	int res = 0;
+
+	dev_dbg(dev, "gta02_wlan_toggle_radio: state %d (%p)\n",
+	    state, gta02_wlan_rfkill_cb);
+	mutex_lock(&gta02_wlan_rfkill_lock);
+	if (gta02_wlan_rfkill_cb)
+		res = gta02_wlan_rfkill_cb(gta02_wlan_rfkill_user, on);
+	if (!res)
+		gta02_wlan_rfkill_on = on;
+	mutex_unlock(&gta02_wlan_rfkill_lock);
+	return res;
+}
+
+
+/* ----- Initialization/removal -------------------------------------------- */
+
+
+static int __init gta02_wlan_probe(struct platform_device *pdev)
+{
+	/* default-on for now */
+	const int default_state = 1;
+	struct rfkill *rfkill;
+	int error;
+
+	if (!machine_is_neo1973_gta02())
+		return -EINVAL;
+
+	dev_info(&pdev->dev, "starting\n");
+
+	s3c2410_gpio_cfgpin(GTA02_GPIO_nWLAN_RESET, S3C2410_GPIO_OUTPUT);
+	gta02_wlan_reset(1);
+	gta02_wlan_reset(0);
+
+	rfkill = rfkill_allocate(&pdev->dev, RFKILL_TYPE_WLAN);
+	rfkill->name = "ar6000";
+	rfkill->data = &pdev->dev;
+	rfkill->state = default_state ? RFKILL_STATE_ON : RFKILL_STATE_OFF;
+	/*
+	 * If the WLAN driver somehow managed to get activated before we're
+	 * ready, the driver is now in an unknown state, which isn't something
+	 * we're prepared to handle. This can't happen, so just fail hard.
+	 */
+	BUG_ON(gta02_wlan_rfkill_cb);
+	gta02_wlan_rfkill_on = default_state;
+	rfkill->toggle_radio = gta02_wlan_toggle_radio;
+
+	error = rfkill_register(rfkill);
+	if (error) {
+		rfkill_free(rfkill);
+		return error;
+	}
+
+	dev_set_drvdata(&pdev->dev, rfkill);
+
+	return 0;
+}
+
+static int gta02_wlan_remove(struct platform_device *pdev)
+{
+	struct rfkill *rfkill = dev_get_drvdata(&pdev->dev);
+
+	rfkill_unregister(rfkill);
+	rfkill_free(rfkill);
+
+	return 0;
+}
+
+static struct platform_driver gta02_wlan_driver = {
+	.probe		= gta02_wlan_probe,
+	.remove		= gta02_wlan_remove,
+	.suspend	= gta02_wlan_suspend,
+	.resume		= gta02_wlan_resume,
+	.driver		= {
+		.name		= "gta02-pm-wlan",
+	},
+};
+
+static int __devinit gta02_wlan_init(void)
+{
+	return platform_driver_register(&gta02_wlan_driver);
+}
+
+static void gta02_wlan_exit(void)
+{
+	platform_driver_unregister(&gta02_wlan_driver);
+}
+
+module_init(gta02_wlan_init);
+module_exit(gta02_wlan_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Openmoko GTA02 WLAN power management");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/dma.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/dma.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/dma.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/dma.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-/* linux/include/asm-arm/plat-s3c24xx/dma.h
- *
- * Copyright (C) 2006 Simtec Electronics
- *	Ben Dooks <ben@simtec.co.uk>
- *
- * Samsung S3C24XX DMA support
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
-extern struct sysdev_class dma_sysclass;
-extern struct s3c2410_dma_chan s3c2410_chans[S3C2410_DMA_CHANNELS];
-
-#define DMA_CH_VALID		(1<<31)
-#define DMA_CH_NEVER		(1<<30)
-
-struct s3c24xx_dma_addr {
-	unsigned long		from;
-	unsigned long		to;
-};
-
-/* struct s3c24xx_dma_map
- *
- * this holds the mapping information for the channel selected
- * to be connected to the specified device
-*/
-
-struct s3c24xx_dma_map {
-	const char		*name;
-	struct s3c24xx_dma_addr  hw_addr;
-
-	unsigned long		 channels[S3C2410_DMA_CHANNELS];
-	unsigned long		 channels_rx[S3C2410_DMA_CHANNELS];
-};
-
-struct s3c24xx_dma_selection {
-	struct s3c24xx_dma_map	*map;
-	unsigned long		 map_size;
-	unsigned long		 dcon_mask;
-
-	void	(*select)(struct s3c2410_dma_chan *chan,
-			  struct s3c24xx_dma_map *map);
-
-	void	(*direction)(struct s3c2410_dma_chan *chan,
-			     struct s3c24xx_dma_map *map,
-			     enum s3c2410_dmasrc dir);
-};
-
-extern int s3c24xx_dma_init_map(struct s3c24xx_dma_selection *sel);
-
-/* struct s3c24xx_dma_order_ch
- *
- * channel map for one of the `enum dma_ch` dma channels. the list
- * entry contains a set of low-level channel numbers, orred with
- * DMA_CH_VALID, which are checked in the order in the array.
-*/
-
-struct s3c24xx_dma_order_ch {
-	unsigned int	list[S3C2410_DMA_CHANNELS];	/* list of channels */
-	unsigned int	flags;				/* flags */
-};
-
-/* struct s3c24xx_dma_order
- *
- * information provided by either the core or the board to give the
- * dma system a hint on how to allocate channels
-*/
-
-struct s3c24xx_dma_order {
-	struct s3c24xx_dma_order_ch	channels[DMACH_MAX];
-};
-
-extern int s3c24xx_dma_order_set(struct s3c24xx_dma_order *map);
-
-/* DMA init code, called from the cpu support code */
-
-extern int s3c2410_dma_init(void);
-
-extern int s3c24xx_dma_init(unsigned int channels, unsigned int irq,
-			    unsigned int stride);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/dma-plat.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/dma-plat.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/dma-plat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/dma-plat.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,84 @@
+/* linux/arch/arm/plat-s3c24xx/include/plat/dma-plat.h
+ *
+ * Copyright (C) 2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C24XX DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <plat/dma-core.h>
+
+extern struct sysdev_class dma_sysclass;
+extern struct s3c2410_dma_chan s3c2410_chans[S3C_DMA_CHANNELS];
+
+#define DMA_CH_VALID		(1<<31)
+#define DMA_CH_NEVER		(1<<30)
+
+struct s3c24xx_dma_addr {
+	unsigned long		from;
+	unsigned long		to;
+};
+
+/* struct s3c24xx_dma_map
+ *
+ * this holds the mapping information for the channel selected
+ * to be connected to the specified device
+*/
+
+struct s3c24xx_dma_map {
+	const char		*name;
+	struct s3c24xx_dma_addr  hw_addr;
+
+	unsigned long		 channels[S3C_DMA_CHANNELS];
+	unsigned long		 channels_rx[S3C_DMA_CHANNELS];
+};
+
+struct s3c24xx_dma_selection {
+	struct s3c24xx_dma_map	*map;
+	unsigned long		 map_size;
+	unsigned long		 dcon_mask;
+
+	void	(*select)(struct s3c2410_dma_chan *chan,
+			  struct s3c24xx_dma_map *map);
+
+	void	(*direction)(struct s3c2410_dma_chan *chan,
+			     struct s3c24xx_dma_map *map,
+			     enum s3c2410_dmasrc dir);
+};
+
+extern int s3c24xx_dma_init_map(struct s3c24xx_dma_selection *sel);
+
+/* struct s3c24xx_dma_order_ch
+ *
+ * channel map for one of the `enum dma_ch` dma channels. the list
+ * entry contains a set of low-level channel numbers, orred with
+ * DMA_CH_VALID, which are checked in the order in the array.
+*/
+
+struct s3c24xx_dma_order_ch {
+	unsigned int	list[S3C_DMA_CHANNELS];	/* list of channels */
+	unsigned int	flags;				/* flags */
+};
+
+/* struct s3c24xx_dma_order
+ *
+ * information provided by either the core or the board to give the
+ * dma system a hint on how to allocate channels
+*/
+
+struct s3c24xx_dma_order {
+	struct s3c24xx_dma_order_ch	channels[DMACH_MAX];
+};
+
+extern int s3c24xx_dma_order_set(struct s3c24xx_dma_order *map);
+
+/* DMA init code, called from the cpu support code */
+
+extern int s3c2410_dma_init(void);
+
+extern int s3c24xx_dma_init(unsigned int channels, unsigned int irq,
+			    unsigned int stride);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/irq.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/irq.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/irq.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/irq.h	2009-05-10 22:27:59.000000000 +0200
@@ -10,6 +10,13 @@
  * published by the Free Software Foundation.
 */
 
+#include <linux/io.h>
+
+#include <mach/irqs.h>
+#include <mach/hardware.h>
+#include <mach/regs-irq.h>
+#include <mach/regs-gpio.h>
+
 #define irqdbf(x...)
 #define irqdbf2(x...)
 
@@ -25,8 +32,15 @@
 {
 	unsigned long mask;
 	unsigned long submask;
+#ifdef CONFIG_S3C2440_C_FIQ
+	unsigned long flags;
+#endif
 
 	submask = __raw_readl(S3C2410_INTSUBMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_save_flags(flags);
+	local_fiq_disable();
+#endif
 	mask = __raw_readl(S3C2410_INTMSK);
 
 	submask |= (1UL << (irqno - IRQ_S3CUART_RX0));
@@ -39,6 +53,9 @@
 
 	/* write back masks */
 	__raw_writel(submask, S3C2410_INTSUBMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_irq_restore(flags);
+#endif
 
 }
 
@@ -47,8 +64,15 @@
 {
 	unsigned long mask;
 	unsigned long submask;
+#ifdef CONFIG_S3C2440_C_FIQ
+	unsigned long flags;
+#endif
 
 	submask = __raw_readl(S3C2410_INTSUBMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_save_flags(flags);
+	local_fiq_disable();
+#endif
 	mask = __raw_readl(S3C2410_INTMSK);
 
 	submask &= ~(1UL << (irqno - IRQ_S3CUART_RX0));
@@ -57,6 +81,9 @@
 	/* write back masks */
 	__raw_writel(submask, S3C2410_INTSUBMSK);
 	__raw_writel(mask, S3C2410_INTMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_irq_restore(flags);
+#endif
 }
 
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/map.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/map.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/map.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/map.h	2009-05-10 22:27:59.000000000 +0200
@@ -31,6 +31,8 @@
 #define S3C24XX_SZ_UART	   SZ_1M
 #define S3C_UART_OFFSET	   (0x4000)
 
+#define S3C_VA_UARTx(uart) (S3C_VA_UART + ((uart * S3C_UART_OFFSET)))
+
 /* Timers */
 #define S3C24XX_VA_TIMER   S3C_VA_TIMER
 #define S3C2410_PA_TIMER   (0x51000000)
@@ -56,7 +58,6 @@
 #define S3C24XX_SZ_SPI		SZ_1M
 #define S3C24XX_SZ_SDI		SZ_1M
 #define S3C24XX_SZ_NAND		SZ_1M
-#define S3C24XX_SZ_USBHOST	SZ_1M
 
 /* GPIO ports */
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/pm-core.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/pm-core.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/pm-core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/pm-core.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,64 @@
+/* linux/arch/arm/plat-s3c24xx/include/plat/pll.h
+ *
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C24xx - PM core support for arch/arm/plat-s3c/pm.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+static inline void s3c_pm_debug_init_uart(void)
+{
+	unsigned long tmp = __raw_readl(S3C2410_CLKCON);
+
+	/* re-start uart clocks */
+	tmp |= S3C2410_CLKCON_UART0;
+	tmp |= S3C2410_CLKCON_UART1;
+	tmp |= S3C2410_CLKCON_UART2;
+
+	__raw_writel(tmp, S3C2410_CLKCON);
+	udelay(10);
+}
+
+static inline void s3c_pm_arch_prepare_irqs(void)
+{
+	__raw_writel(s3c_irqwake_intmask, S3C2410_INTMSK);
+	__raw_writel(s3c_irqwake_eintmask, S3C2410_EINTMASK);
+
+	/* ack any outstanding external interrupts before we go to sleep */
+
+	__raw_writel(__raw_readl(S3C2410_EINTPEND), S3C2410_EINTPEND);
+	__raw_writel(__raw_readl(S3C2410_INTPND), S3C2410_INTPND);
+	__raw_writel(__raw_readl(S3C2410_SRCPND), S3C2410_SRCPND);
+
+}
+
+static inline void s3c_pm_arch_stop_clocks(void)
+{
+	__raw_writel(0x00, S3C2410_CLKCON);  /* turn off clocks over sleep */
+}
+
+static void s3c_pm_show_resume_irqs(int start, unsigned long which,
+				    unsigned long mask);
+
+static inline void s3c_pm_arch_show_resume_irqs(void)
+{
+	S3C_PMDBG("post sleep: IRQs 0x%08x, 0x%08x\n",
+		  __raw_readl(S3C2410_SRCPND),
+		  __raw_readl(S3C2410_EINTPEND));
+
+	s3c_pm_show_resume_irqs(IRQ_EINT0, __raw_readl(S3C2410_SRCPND),
+				s3c_irqwake_intmask);
+
+	s3c_pm_show_resume_irqs(IRQ_EINT4-4, __raw_readl(S3C2410_EINTPEND),
+				s3c_irqwake_eintmask);
+}
+
+static inline void s3c_pm_arch_update_uart(void __iomem *regs,
+					   struct pm_uart_save *save)
+{
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/pm.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/pm.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/pm.h	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/pm.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,73 +0,0 @@
-/* linux/include/asm-arm/plat-s3c24xx/pm.h
- *
- * Copyright (c) 2004 Simtec Electronics
- *	Written by Ben Dooks, <ben@simtec.co.uk>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
-/* s3c2410_pm_init
- *
- * called from board at initialisation time to setup the power
- * management
-*/
-
-#ifdef CONFIG_PM
-
-extern __init int s3c2410_pm_init(void);
-
-#else
-
-static inline int s3c2410_pm_init(void)
-{
-	return 0;
-}
-#endif
-
-/* configuration for the IRQ mask over sleep */
-extern unsigned long s3c_irqwake_intmask;
-extern unsigned long s3c_irqwake_eintmask;
-
-/* IRQ masks for IRQs allowed to go to sleep (see irq.c) */
-extern unsigned long s3c_irqwake_intallow;
-extern unsigned long s3c_irqwake_eintallow;
-
-/* per-cpu sleep functions */
-
-extern void (*pm_cpu_prep)(void);
-extern void (*pm_cpu_sleep)(void);
-
-/* Flags for PM Control */
-
-extern unsigned long s3c_pm_flags;
-
-/* from sleep.S */
-
-extern int  s3c2410_cpu_save(unsigned long *saveblk);
-extern void s3c2410_cpu_suspend(void);
-extern void s3c2410_cpu_resume(void);
-
-extern unsigned long s3c2410_sleep_save_phys;
-
-/* sleep save info */
-
-struct sleep_save {
-	void __iomem	*reg;
-	unsigned long	val;
-};
-
-#define SAVE_ITEM(x) \
-	{ .reg = (x) }
-
-extern void s3c2410_pm_do_save(struct sleep_save *ptr, int count);
-extern void s3c2410_pm_do_restore(struct sleep_save *ptr, int count);
-
-#ifdef CONFIG_PM
-extern int s3c24xx_irq_suspend(struct sys_device *dev, pm_message_t state);
-extern int s3c24xx_irq_resume(struct sys_device *dev);
-#else
-#define s3c24xx_irq_suspend NULL
-#define s3c24xx_irq_resume  NULL
-#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/regs-dma.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/regs-dma.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/regs-dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/regs-dma.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,145 @@
+/* arch/arm/mach-s3c2410/include/mach/dma.h
+ *
+ * Copyright (C) 2003,2004,2006 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * Samsung S3C24XX DMA support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* DMA Register definitions */
+
+#define S3C2410_DMA_DISRC		(0x00)
+#define S3C2410_DMA_DISRCC		(0x04)
+#define S3C2410_DMA_DIDST		(0x08)
+#define S3C2410_DMA_DIDSTC		(0x0C)
+#define S3C2410_DMA_DCON		(0x10)
+#define S3C2410_DMA_DSTAT		(0x14)
+#define S3C2410_DMA_DCSRC		(0x18)
+#define S3C2410_DMA_DCDST		(0x1C)
+#define S3C2410_DMA_DMASKTRIG		(0x20)
+#define S3C2412_DMA_DMAREQSEL		(0x24)
+#define S3C2443_DMA_DMAREQSEL		(0x24)
+
+#define S3C2410_DISRCC_INC		(1<<0)
+#define S3C2410_DISRCC_APB		(1<<1)
+
+#define S3C2410_DMASKTRIG_STOP		(1<<2)
+#define S3C2410_DMASKTRIG_ON		(1<<1)
+#define S3C2410_DMASKTRIG_SWTRIG	(1<<0)
+
+#define S3C2410_DCON_DEMAND		(0<<31)
+#define S3C2410_DCON_HANDSHAKE		(1<<31)
+#define S3C2410_DCON_SYNC_PCLK		(0<<30)
+#define S3C2410_DCON_SYNC_HCLK		(1<<30)
+
+#define S3C2410_DCON_INTREQ		(1<<29)
+
+#define S3C2410_DCON_CH0_XDREQ0		(0<<24)
+#define S3C2410_DCON_CH0_UART0		(1<<24)
+#define S3C2410_DCON_CH0_SDI		(2<<24)
+#define S3C2410_DCON_CH0_TIMER		(3<<24)
+#define S3C2410_DCON_CH0_USBEP1		(4<<24)
+
+#define S3C2410_DCON_CH1_XDREQ1		(0<<24)
+#define S3C2410_DCON_CH1_UART1		(1<<24)
+#define S3C2410_DCON_CH1_I2SSDI		(2<<24)
+#define S3C2410_DCON_CH1_SPI		(3<<24)
+#define S3C2410_DCON_CH1_USBEP2		(4<<24)
+
+#define S3C2410_DCON_CH2_I2SSDO		(0<<24)
+#define S3C2410_DCON_CH2_I2SSDI		(1<<24)
+#define S3C2410_DCON_CH2_SDI		(2<<24)
+#define S3C2410_DCON_CH2_TIMER		(3<<24)
+#define S3C2410_DCON_CH2_USBEP3		(4<<24)
+
+#define S3C2410_DCON_CH3_UART2		(0<<24)
+#define S3C2410_DCON_CH3_SDI		(1<<24)
+#define S3C2410_DCON_CH3_SPI		(2<<24)
+#define S3C2410_DCON_CH3_TIMER		(3<<24)
+#define S3C2410_DCON_CH3_USBEP4		(4<<24)
+
+#define S3C2410_DCON_SRCSHIFT		(24)
+#define S3C2410_DCON_SRCMASK		(7<<24)
+
+#define S3C2410_DCON_BYTE		(0<<20)
+#define S3C2410_DCON_HALFWORD		(1<<20)
+#define S3C2410_DCON_WORD		(2<<20)
+
+#define S3C2410_DCON_AUTORELOAD		(0<<22)
+#define S3C2410_DCON_NORELOAD		(1<<22)
+#define S3C2410_DCON_HWTRIG		(1<<23)
+
+#if defined(CONFIG_CPU_S3C2440) || defined(CONFIG_CPU_S3C2442)
+#define S3C2440_DIDSTC_CHKINT		(1<<2)
+
+#define S3C2440_DCON_CH0_I2SSDO		(5<<24)
+#define S3C2440_DCON_CH0_PCMIN		(6<<24)
+
+#define S3C2440_DCON_CH1_PCMOUT		(5<<24)
+#define S3C2440_DCON_CH1_SDI		(6<<24)
+
+#define S3C2440_DCON_CH2_PCMIN		(5<<24)
+#define S3C2440_DCON_CH2_MICIN		(6<<24)
+
+#define S3C2440_DCON_CH3_MICIN		(5<<24)
+#define S3C2440_DCON_CH3_PCMOUT		(6<<24)
+#endif
+
+#ifdef CONFIG_CPU_S3C2412
+
+#define S3C2412_DMAREQSEL_SRC(x)	((x)<<1)
+
+#define S3C2412_DMAREQSEL_HW		(1)
+
+#define S3C2412_DMAREQSEL_SPI0TX	S3C2412_DMAREQSEL_SRC(0)
+#define S3C2412_DMAREQSEL_SPI0RX	S3C2412_DMAREQSEL_SRC(1)
+#define S3C2412_DMAREQSEL_SPI1TX	S3C2412_DMAREQSEL_SRC(2)
+#define S3C2412_DMAREQSEL_SPI1RX	S3C2412_DMAREQSEL_SRC(3)
+#define S3C2412_DMAREQSEL_I2STX		S3C2412_DMAREQSEL_SRC(4)
+#define S3C2412_DMAREQSEL_I2SRX		S3C2412_DMAREQSEL_SRC(5)
+#define S3C2412_DMAREQSEL_TIMER		S3C2412_DMAREQSEL_SRC(9)
+#define S3C2412_DMAREQSEL_SDI		S3C2412_DMAREQSEL_SRC(10)
+#define S3C2412_DMAREQSEL_USBEP1	S3C2412_DMAREQSEL_SRC(13)
+#define S3C2412_DMAREQSEL_USBEP2	S3C2412_DMAREQSEL_SRC(14)
+#define S3C2412_DMAREQSEL_USBEP3	S3C2412_DMAREQSEL_SRC(15)
+#define S3C2412_DMAREQSEL_USBEP4	S3C2412_DMAREQSEL_SRC(16)
+#define S3C2412_DMAREQSEL_XDREQ0	S3C2412_DMAREQSEL_SRC(17)
+#define S3C2412_DMAREQSEL_XDREQ1	S3C2412_DMAREQSEL_SRC(18)
+#define S3C2412_DMAREQSEL_UART0_0	S3C2412_DMAREQSEL_SRC(19)
+#define S3C2412_DMAREQSEL_UART0_1	S3C2412_DMAREQSEL_SRC(20)
+#define S3C2412_DMAREQSEL_UART1_0	S3C2412_DMAREQSEL_SRC(21)
+#define S3C2412_DMAREQSEL_UART1_1	S3C2412_DMAREQSEL_SRC(22)
+#define S3C2412_DMAREQSEL_UART2_0	S3C2412_DMAREQSEL_SRC(23)
+#define S3C2412_DMAREQSEL_UART2_1	S3C2412_DMAREQSEL_SRC(24)
+
+#endif
+
+#define S3C2443_DMAREQSEL_SRC(x)	((x)<<1)
+
+#define S3C2443_DMAREQSEL_HW		(1)
+
+#define S3C2443_DMAREQSEL_SPI0TX	S3C2443_DMAREQSEL_SRC(0)
+#define S3C2443_DMAREQSEL_SPI0RX	S3C2443_DMAREQSEL_SRC(1)
+#define S3C2443_DMAREQSEL_SPI1TX	S3C2443_DMAREQSEL_SRC(2)
+#define S3C2443_DMAREQSEL_SPI1RX	S3C2443_DMAREQSEL_SRC(3)
+#define S3C2443_DMAREQSEL_I2STX		S3C2443_DMAREQSEL_SRC(4)
+#define S3C2443_DMAREQSEL_I2SRX		S3C2443_DMAREQSEL_SRC(5)
+#define S3C2443_DMAREQSEL_TIMER		S3C2443_DMAREQSEL_SRC(9)
+#define S3C2443_DMAREQSEL_SDI		S3C2443_DMAREQSEL_SRC(10)
+#define S3C2443_DMAREQSEL_XDREQ0	S3C2443_DMAREQSEL_SRC(17)
+#define S3C2443_DMAREQSEL_XDREQ1	S3C2443_DMAREQSEL_SRC(18)
+#define S3C2443_DMAREQSEL_UART0_0	S3C2443_DMAREQSEL_SRC(19)
+#define S3C2443_DMAREQSEL_UART0_1	S3C2443_DMAREQSEL_SRC(20)
+#define S3C2443_DMAREQSEL_UART1_0	S3C2443_DMAREQSEL_SRC(21)
+#define S3C2443_DMAREQSEL_UART1_1	S3C2443_DMAREQSEL_SRC(22)
+#define S3C2443_DMAREQSEL_UART2_0	S3C2443_DMAREQSEL_SRC(23)
+#define S3C2443_DMAREQSEL_UART2_1	S3C2443_DMAREQSEL_SRC(24)
+#define S3C2443_DMAREQSEL_UART3_0	S3C2443_DMAREQSEL_SRC(25)
+#define S3C2443_DMAREQSEL_UART3_1	S3C2443_DMAREQSEL_SRC(26)
+#define S3C2443_DMAREQSEL_PCMOUT	S3C2443_DMAREQSEL_SRC(27)
+#define S3C2443_DMAREQSEL_PCMIN 	S3C2443_DMAREQSEL_SRC(28)
+#define S3C2443_DMAREQSEL_MICIN		S3C2443_DMAREQSEL_SRC(29)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/regs-iis.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/regs-iis.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/include/plat/regs-iis.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/include/plat/regs-iis.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,77 @@
+/* arch/arm/mach-s3c2410/include/mach/regs-iis.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * S3C2410 IIS register definition
+*/
+
+#ifndef __ASM_ARCH_REGS_IIS_H
+#define __ASM_ARCH_REGS_IIS_H
+
+#define S3C2410_IISCON	 (0x00)
+
+#define S3C2410_IISCON_LRINDEX	  (1<<8)
+#define S3C2410_IISCON_TXFIFORDY  (1<<7)
+#define S3C2410_IISCON_RXFIFORDY  (1<<6)
+#define S3C2410_IISCON_TXDMAEN	  (1<<5)
+#define S3C2410_IISCON_RXDMAEN	  (1<<4)
+#define S3C2410_IISCON_TXIDLE	  (1<<3)
+#define S3C2410_IISCON_RXIDLE	  (1<<2)
+#define S3C2410_IISCON_PSCEN	  (1<<1)
+#define S3C2410_IISCON_IISEN	  (1<<0)
+
+#define S3C2410_IISMOD	 (0x04)
+
+#define S3C2440_IISMOD_MPLL	  (1<<9)
+#define S3C2410_IISMOD_SLAVE	  (1<<8)
+#define S3C2410_IISMOD_NOXFER	  (0<<6)
+#define S3C2410_IISMOD_RXMODE	  (1<<6)
+#define S3C2410_IISMOD_TXMODE	  (2<<6)
+#define S3C2410_IISMOD_TXRXMODE	  (3<<6)
+#define S3C2410_IISMOD_LR_LLOW	  (0<<5)
+#define S3C2410_IISMOD_LR_RLOW	  (1<<5)
+#define S3C2410_IISMOD_IIS	  (0<<4)
+#define S3C2410_IISMOD_MSB	  (1<<4)
+#define S3C2410_IISMOD_8BIT	  (0<<3)
+#define S3C2410_IISMOD_16BIT	  (1<<3)
+#define S3C2410_IISMOD_BITMASK	  (1<<3)
+#define S3C2410_IISMOD_256FS	  (0<<2)
+#define S3C2410_IISMOD_384FS	  (1<<2)
+#define S3C2410_IISMOD_16FS	  (0<<0)
+#define S3C2410_IISMOD_32FS	  (1<<0)
+#define S3C2410_IISMOD_48FS	  (2<<0)
+#define S3C2410_IISMOD_FS_MASK	  (3<<0)
+
+#define S3C2410_IISPSR		(0x08)
+#define S3C2410_IISPSR_INTMASK	(31<<5)
+#define S3C2410_IISPSR_INTSHIFT	(5)
+#define S3C2410_IISPSR_EXTMASK	(31<<0)
+#define S3C2410_IISPSR_EXTSHFIT	(0)
+
+#define S3C2410_IISFCON  (0x0c)
+
+#define S3C2410_IISFCON_TXDMA	  (1<<15)
+#define S3C2410_IISFCON_RXDMA	  (1<<14)
+#define S3C2410_IISFCON_TXENABLE  (1<<13)
+#define S3C2410_IISFCON_RXENABLE  (1<<12)
+#define S3C2410_IISFCON_TXMASK	  (0x3f << 6)
+#define S3C2410_IISFCON_TXSHIFT	  (6)
+#define S3C2410_IISFCON_RXMASK	  (0x3f)
+#define S3C2410_IISFCON_RXSHIFT	  (0)
+
+#define S3C2400_IISFCON_TXDMA     (1<<11)
+#define S3C2400_IISFCON_RXDMA     (1<<10)
+#define S3C2400_IISFCON_TXENABLE  (1<<9)
+#define S3C2400_IISFCON_RXENABLE  (1<<8)
+#define S3C2400_IISFCON_TXMASK	  (0x07 << 4)
+#define S3C2400_IISFCON_TXSHIFT	  (4)
+#define S3C2400_IISFCON_RXMASK	  (0x07)
+#define S3C2400_IISFCON_RXSHIFT	  (0)
+
+#define S3C2410_IISFIFO  (0x10)
+#endif /* __ASM_ARCH_REGS_IIS_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/irq.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/irq.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/irq.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/irq.c	2009-05-10 22:27:59.000000000 +0200
@@ -1,6 +1,6 @@
 /* linux/arch/arm/plat-s3c24xx/irq.c
  *
- * Copyright (c) 2003,2004 Simtec Electronics
+ * Copyright (c) 2003,2004 Simtec Electronics 
  *	Ben Dooks <ben@simtec.co.uk>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -16,38 +16,6 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Changelog:
- *
- *   22-Jul-2004  Ben Dooks <ben@simtec.co.uk>
- *                Fixed compile warnings
- *
- *   22-Jul-2004  Roc Wu <cooloney@yahoo.com.cn>
- *                Fixed s3c_extirq_type
- *
- *   21-Jul-2004  Arnaud Patard (Rtp) <arnaud.patard@rtp-net.org>
- *                Addition of ADC/TC demux
- *
- *   04-Oct-2004  Klaus Fetscher <k.fetscher@fetron.de>
- *		  Fix for set_irq_type() on low EINT numbers
- *
- *   05-Oct-2004  Ben Dooks <ben@simtec.co.uk>
- *		  Tidy up KF's patch and sort out new release
- *
- *   05-Oct-2004  Ben Dooks <ben@simtec.co.uk>
- *		  Add support for power management controls
- *
- *   04-Nov-2004  Ben Dooks
- *		  Fix standard IRQ wake for EINT0..4 and RTC
- *
- *   22-Feb-2005  Ben Dooks
- *		  Fixed edge-triggering on ADC IRQ
- *
- *   28-Jun-2005  Ben Dooks
- *		  Mark IRQ_LCD valid
- *
- *   25-Jul-2005  Ben Dooks
- *		  Split the S3C2440 IRQ code to separate file
 */
 
 #include <linux/init.h>
@@ -55,11 +23,8 @@
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
 #include <linux/sysdev.h>
-#include <linux/io.h>
 
-#include <mach/hardware.h>
 #include <asm/irq.h>
-
 #include <asm/mach/irq.h>
 
 #include <plat/regs-irqtype.h>
@@ -70,76 +35,24 @@
 #include <plat/pm.h>
 #include <plat/irq.h>
 
-/* wakeup irq control */
-
-#ifdef CONFIG_PM
-
-/* state for IRQs over sleep */
-
-/* default is to allow for EINT0..EINT15, and IRQ_RTC as wakeup sources
- *
- * set bit to 1 in allow bitfield to enable the wakeup settings on it
-*/
-
-unsigned long s3c_irqwake_intallow	= 1L << (IRQ_RTC - IRQ_EINT0) | 0xfL;
-unsigned long s3c_irqwake_intmask	= 0xffffffffL;
-unsigned long s3c_irqwake_eintallow	= 0x0000fff0L;
-unsigned long s3c_irqwake_eintmask	= 0xffffffffL;
-
-int
-s3c_irq_wake(unsigned int irqno, unsigned int state)
-{
-	unsigned long irqbit = 1 << (irqno - IRQ_EINT0);
-
-	if (!(s3c_irqwake_intallow & irqbit))
-		return -ENOENT;
-
-	printk(KERN_INFO "wake %s for irq %d\n",
-	       state ? "enabled" : "disabled", irqno);
-
-	if (!state)
-		s3c_irqwake_intmask |= irqbit;
-	else
-		s3c_irqwake_intmask &= ~irqbit;
-
-	return 0;
-}
-
-static int
-s3c_irqext_wake(unsigned int irqno, unsigned int state)
-{
-	unsigned long bit = 1L << (irqno - EXTINT_OFF);
-
-	if (!(s3c_irqwake_eintallow & bit))
-		return -ENOENT;
-
-	printk(KERN_INFO "wake %s for irq %d\n",
-	       state ? "enabled" : "disabled", irqno);
-
-	if (!state)
-		s3c_irqwake_eintmask |= bit;
-	else
-		s3c_irqwake_eintmask &= ~bit;
-
-	return 0;
-}
-
-#else
-#define s3c_irqext_wake NULL
-#define s3c_irq_wake NULL
-#endif
-
-
 static void
 s3c_irq_mask(unsigned int irqno)
 {
 	unsigned long mask;
-
+#ifdef CONFIG_S3C2440_C_FIQ
+	unsigned long flags;
+#endif
 	irqno -= IRQ_EINT0;
-
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_save_flags(flags);
+	local_fiq_disable();
+#endif
 	mask = __raw_readl(S3C2410_INTMSK);
 	mask |= 1UL << irqno;
 	__raw_writel(mask, S3C2410_INTMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_irq_restore(flags);
+#endif
 }
 
 static inline void
@@ -156,9 +69,19 @@
 {
 	unsigned long bitval = 1UL << (irqno - IRQ_EINT0);
 	unsigned long mask;
+#ifdef CONFIG_S3C2440_C_FIQ
+	unsigned long flags;
+#endif
 
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_save_flags(flags);
+	local_fiq_disable();
+#endif
 	mask = __raw_readl(S3C2410_INTMSK);
 	__raw_writel(mask|bitval, S3C2410_INTMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_irq_restore(flags);
+#endif
 
 	__raw_writel(bitval, S3C2410_SRCPND);
 	__raw_writel(bitval, S3C2410_INTPND);
@@ -169,15 +92,25 @@
 s3c_irq_unmask(unsigned int irqno)
 {
 	unsigned long mask;
+#ifdef CONFIG_S3C2440_C_FIQ
+	unsigned long flags;
+#endif
 
 	if (irqno != IRQ_TIMER4 && irqno != IRQ_EINT8t23)
 		irqdbf2("s3c_irq_unmask %d\n", irqno);
 
 	irqno -= IRQ_EINT0;
 
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_save_flags(flags);
+	local_fiq_disable();
+#endif
 	mask = __raw_readl(S3C2410_INTMSK);
 	mask &= ~(1UL << irqno);
 	__raw_writel(mask, S3C2410_INTMSK);
+#ifdef CONFIG_S3C2440_C_FIQ
+	local_irq_restore(flags);
+#endif
 }
 
 struct irq_chip s3c_irq_level_chip = {
@@ -590,59 +523,6 @@
 	}
 }
 
-#ifdef CONFIG_PM
-
-static struct sleep_save irq_save[] = {
-	SAVE_ITEM(S3C2410_INTMSK),
-	SAVE_ITEM(S3C2410_INTSUBMSK),
-};
-
-/* the extint values move between the s3c2410/s3c2440 and the s3c2412
- * so we use an array to hold them, and to calculate the address of
- * the register at run-time
-*/
-
-static unsigned long save_extint[3];
-static unsigned long save_eintflt[4];
-static unsigned long save_eintmask;
-
-int s3c24xx_irq_suspend(struct sys_device *dev, pm_message_t state)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(save_extint); i++)
-		save_extint[i] = __raw_readl(S3C24XX_EXTINT0 + (i*4));
-
-	for (i = 0; i < ARRAY_SIZE(save_eintflt); i++)
-		save_eintflt[i] = __raw_readl(S3C24XX_EINFLT0 + (i*4));
-
-	s3c2410_pm_do_save(irq_save, ARRAY_SIZE(irq_save));
-	save_eintmask = __raw_readl(S3C24XX_EINTMASK);
-
-	return 0;
-}
-
-int s3c24xx_irq_resume(struct sys_device *dev)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(save_extint); i++)
-		__raw_writel(save_extint[i], S3C24XX_EXTINT0 + (i*4));
-
-	for (i = 0; i < ARRAY_SIZE(save_eintflt); i++)
-		__raw_writel(save_eintflt[i], S3C24XX_EINFLT0 + (i*4));
-
-	s3c2410_pm_do_restore(irq_save, ARRAY_SIZE(irq_save));
-	__raw_writel(save_eintmask, S3C24XX_EINTMASK);
-
-	return 0;
-}
-
-#else
-#define s3c24xx_irq_suspend NULL
-#define s3c24xx_irq_resume  NULL
-#endif
-
 /* s3c24xx_init_irq
  *
  * Initialise S3C2410 IRQ system
@@ -673,26 +553,26 @@
 
 	last = 0;
 	for (i = 0; i < 4; i++) {
-		pend = __raw_readl(S3C2410_INTPND);
+		pend = __raw_readl(S3C2410_SUBSRCPND);
 
 		if (pend == 0 || pend == last)
 			break;
 
-		__raw_writel(pend, S3C2410_SRCPND);
-		__raw_writel(pend, S3C2410_INTPND);
-		printk("irq: clearing pending status %08x\n", (int)pend);
+		printk("irq: clearing subpending status %08x\n", (int)pend);
+		__raw_writel(pend, S3C2410_SUBSRCPND);
 		last = pend;
 	}
 
 	last = 0;
 	for (i = 0; i < 4; i++) {
-		pend = __raw_readl(S3C2410_SUBSRCPND);
+		pend = __raw_readl(S3C2410_INTPND);
 
 		if (pend == 0 || pend == last)
 			break;
 
-		printk("irq: clearing subpending status %08x\n", (int)pend);
-		__raw_writel(pend, S3C2410_SUBSRCPND);
+		__raw_writel(pend, S3C2410_SRCPND);
+		__raw_writel(pend, S3C2410_INTPND);
+		printk("irq: clearing pending status %08x\n", (int)pend);
 		last = pend;
 	}
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/irq-pm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/irq-pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/irq-pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/irq-pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,118 @@
+/* linux/arch/arm/plat-s3c24xx/irq-om.c
+ *
+ * Copyright (c) 2003,2004 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C24XX - IRQ PM code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/irq.h>
+
+#include <plat/cpu.h>
+#include <plat/pm.h>
+#include <plat/irq.h>
+
+/* state for IRQs over sleep */
+
+/* default is to allow for EINT0..EINT15, and IRQ_RTC as wakeup sources
+ *
+ * set bit to 1 in allow bitfield to enable the wakeup settings on it
+*/
+
+unsigned long s3c_irqwake_intallow	= 1L << (IRQ_RTC - IRQ_EINT0) | 0xfL;
+unsigned long s3c_irqwake_eintallow	= 0x0000fff0L;
+
+int s3c_irq_wake(unsigned int irqno, unsigned int state)
+{
+	unsigned long irqbit = 1 << (irqno - IRQ_EINT0);
+
+	if (!(s3c_irqwake_intallow & irqbit))
+		return -ENOENT;
+
+	printk(KERN_INFO "wake %s for irq %d\n",
+	       state ? "enabled" : "disabled", irqno);
+
+	if (!state)
+		s3c_irqwake_intmask |= irqbit;
+	else
+		s3c_irqwake_intmask &= ~irqbit;
+
+	return 0;
+}
+
+static struct sleep_save irq_save[] = {
+	SAVE_ITEM(S3C2410_INTMSK),
+	SAVE_ITEM(S3C2410_INTSUBMSK),
+};
+
+/* the extint values move between the s3c2410/s3c2440 and the s3c2412
+ * so we use an array to hold them, and to calculate the address of
+ * the register at run-time
+*/
+
+static unsigned long save_extint[3];
+static unsigned long save_eintflt[4];
+static unsigned long save_eintmask;
+
+int s3c24xx_irq_suspend(struct sys_device *dev, pm_message_t state)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(save_extint); i++)
+		save_extint[i] = __raw_readl(S3C24XX_EXTINT0 + (i*4));
+
+	for (i = 0; i < ARRAY_SIZE(save_eintflt); i++)
+		save_eintflt[i] = __raw_readl(S3C24XX_EINFLT0 + (i*4));
+
+	s3c_pm_do_save(irq_save, ARRAY_SIZE(irq_save));
+	save_eintmask = __raw_readl(S3C24XX_EINTMASK);
+
+	return 0;
+}
+
+int s3c24xx_irq_resume(struct sys_device *dev)
+{
+	unsigned int i, irq;
+	unsigned long eintpnd;
+	struct irq_desc *desc;
+
+	for (i = 0; i < ARRAY_SIZE(save_extint); i++)
+		__raw_writel(save_extint[i], S3C24XX_EXTINT0 + (i*4));
+
+	for (i = 0; i < ARRAY_SIZE(save_eintflt); i++)
+		__raw_writel(save_eintflt[i], S3C24XX_EINFLT0 + (i*4));
+
+	s3c_pm_do_restore(irq_save, ARRAY_SIZE(irq_save));
+	__raw_writel(save_eintmask, S3C24XX_EINTMASK);
+
+	/*
+	 * ACK those interrupts which are now masked and pending.
+	 * Level interrupts if not ACKed here, create an interrupt storm
+	 * because they are not handled at all.
+	 */
+
+	eintpnd = __raw_readl(S3C24XX_EINTPEND);
+
+	eintpnd &= save_eintmask;
+	eintpnd &= ~0xff;	/* ignore lower irqs */
+
+	while (eintpnd) {
+		irq = __ffs(eintpnd);
+		eintpnd &= ~(1 << irq);
+
+		irq += (IRQ_EINT4 - 4);
+		desc = irq_to_desc(irq);
+		desc->chip->ack(irq);
+	}
+
+	return 0;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/Kconfig	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -10,6 +10,7 @@
 	default y
 	select NO_IOPORT
 	select ARCH_REQUIRE_GPIOLIB
+	select S3C_GPIO_TRACK
 	help
 	  Base platform code for any Samsung S3C24XX device
 
@@ -30,7 +31,7 @@
 
 config CPU_S3C244X
 	bool
-	depends on ARCH_S3C2410 && (CPU_S3C2440 || CPU_S3C2442)
+	default y if CPU_S3C2440 || CPU_S3C2442
 	help
 	  Support for S3C2440 and S3C2442 Samsung Mobile CPU based systems.
 
@@ -71,6 +72,7 @@
 config S3C2410_DMA
 	bool "S3C2410 DMA support"
 	depends on ARCH_S3C2410
+	select S3C_DMA
 	help
 	  S3C2410 DMA support. This is needed for drivers like sound which
 	  use the S3C2410's DMA system to move data to and from the
@@ -111,4 +113,12 @@
 	help
 	  Common machine code for SMDK2410 and SMDK2440
 
+config MACH_NEO1973
+	bool
+	select RFKILL
+	select SERIAL_SAMSUNG
+	select SERIAL_SAMSUNG_CONSOLE
+	help
+	  Common machine code for Neo1973 hardware
+
 endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/Makefile	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -27,6 +27,7 @@
 obj-$(CONFIG_CPU_S3C244X)	+= s3c244x-clock.o
 obj-$(CONFIG_PM_SIMTEC)		+= pm-simtec.o
 obj-$(CONFIG_PM)		+= pm.o
+obj-$(CONFIG_PM)		+= irq-pm.o
 obj-$(CONFIG_PM)		+= sleep.o
 obj-$(CONFIG_HAVE_PWM)		+= pwm.o
 obj-$(CONFIG_S3C2410_CLOCK)	+= s3c2410-clock.o
@@ -44,3 +45,9 @@
 # machine common support
 
 obj-$(CONFIG_MACH_SMDK)		+= common-smdk.o
+obj-$(CONFIG_MACH_NEO1973)	+= \
+                                   neo1973_pm_gsm.o \
+                                   neo1973_pm_gps.o \
+                                   neo1973_pm_bt.o  \
+                                   gta02_pm_wlan.o  \
+                                   neo1973_shadow.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_bt.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_bt.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_bt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_bt.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,339 @@
+/*
+ * Bluetooth PM code for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2007 by Openmoko Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <linux/err.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+
+/* For GTA01 */
+#include <mach/gta01.h>
+#include <linux/pcf50606.h>
+
+/* For GTA02 */
+#include <mach/gta02.h>
+#include <linux/mfd/pcf50633/gpio.h>
+
+#include <linux/regulator/consumer.h>
+
+#define DRVMSG "FIC Neo1973 Bluetooth Power Management"
+
+struct gta01_pm_bt_data {
+	struct regulator *regulator;
+	struct rfkill *rfkill;
+	int pre_resume_state;
+};
+
+static ssize_t bt_read(struct device *dev, struct device_attribute *attr,
+		       char *buf)
+{
+	int ret = 0;	
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(dev);
+
+	if (!strcmp(attr->attr.name, "power_on")) {
+		if (machine_is_neo1973_gta01()) {
+			ret = regulator_is_enabled(bt_data->regulator);
+		} else if (machine_is_neo1973_gta02()) {
+			if (s3c2410_gpio_getpin(GTA02_GPIO_BT_EN))
+				ret = 1;
+		}
+	} else if (!strcmp(attr->attr.name, "reset")) {
+		if (machine_is_neo1973_gta01()) {
+			if (s3c2410_gpio_getpin(GTA01_GPIO_BT_EN) == 0)
+				ret = 1;
+		} else if (machine_is_neo1973_gta02()) {
+			if (s3c2410_gpio_getpin(GTA02_GPIO_BT_EN) == 0)
+				ret = 1;
+		}
+	}
+
+	if (!ret) {
+		return strlcpy(buf, "0\n", 3);
+	} else {
+		return strlcpy(buf, "1\n", 3);
+	}
+}
+
+static void __gta02_pm_bt_toggle_radio(struct device *dev, unsigned int on)
+{
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(dev);
+
+	dev_info(dev, "__gta02_pm_bt_toggle_radio %d\n", on);
+
+	if (machine_is_neo1973_gta02()) {
+
+		bt_data = dev_get_drvdata(dev);
+
+		neo1973_gpb_setpin(GTA02_GPIO_BT_EN, !on);
+
+		if (on) {
+			if (!regulator_is_enabled(bt_data->regulator))
+				regulator_enable(bt_data->regulator);
+		} else {
+			if (regulator_is_enabled(bt_data->regulator))
+				regulator_disable(bt_data->regulator);
+		}
+
+		neo1973_gpb_setpin(GTA02_GPIO_BT_EN, on);
+	}
+}
+
+
+static int bt_rfkill_toggle_radio(void *data, enum rfkill_state state)
+{
+	struct device *dev = data;
+	unsigned long on = (state == RFKILL_STATE_ON);
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(dev);
+
+	if (machine_is_neo1973_gta01()) {
+		/* if we are powering up, assert reset, then power,
+		 * then release reset */
+		if (on) {
+			neo1973_gpb_setpin(GTA01_GPIO_BT_EN, 0);
+				if (!regulator_is_enabled(bt_data->regulator))
+					regulator_enable(bt_data->regulator);
+		} else {
+			if (regulator_is_enabled(bt_data->regulator))
+				regulator_disable(bt_data->regulator);
+		}
+		neo1973_gpb_setpin(GTA01_GPIO_BT_EN, on);
+	} else if (machine_is_neo1973_gta02())
+		__gta02_pm_bt_toggle_radio(dev, on);
+
+	return 0;
+}
+
+static ssize_t bt_write(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	unsigned long on = simple_strtoul(buf, NULL, 10);
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(dev);
+
+	if (!strcmp(attr->attr.name, "power_on")) {
+		enum rfkill_state state = on ? RFKILL_STATE_ON : RFKILL_STATE_OFF;
+		bt_rfkill_toggle_radio(dev, state);
+		bt_data->rfkill->state = state;
+
+		if (machine_is_neo1973_gta01()) {
+			/* if we are powering up, assert reset, then power,
+			 * then release reset */
+			if (on) {
+				neo1973_gpb_setpin(GTA01_GPIO_BT_EN, 0);
+				if (!regulator_is_enabled(bt_data->regulator))
+					regulator_enable(bt_data->regulator);
+			} else {
+				if (regulator_is_enabled(bt_data->regulator))
+					regulator_disable(bt_data->regulator);
+			}
+
+			neo1973_gpb_setpin(GTA01_GPIO_BT_EN, on);
+		} else if (machine_is_neo1973_gta02())
+			__gta02_pm_bt_toggle_radio(dev, on);
+
+	} else if (!strcmp(attr->attr.name, "reset")) {
+		/* reset is low-active, so we need to invert */
+		if (machine_is_neo1973_gta01()) {
+			neo1973_gpb_setpin(GTA01_GPIO_BT_EN, on ? 0 : 1);
+		} else if (machine_is_neo1973_gta02()) {
+			neo1973_gpb_setpin(GTA02_GPIO_BT_EN, on ? 0 : 1);
+		}
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(power_on, 0644, bt_read, bt_write);
+static DEVICE_ATTR(reset, 0644, bt_read, bt_write);
+
+#ifdef CONFIG_PM
+static int gta01_bt_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(&pdev->dev);
+
+	dev_dbg(&pdev->dev, DRVMSG ": suspending\n");
+
+	if (machine_is_neo1973_gta01()) {
+		if (regulator_is_enabled(bt_data->regulator))
+			regulator_disable(bt_data->regulator);
+	} else if (machine_is_neo1973_gta02()) {
+		bt_data->pre_resume_state =
+					  s3c2410_gpio_getpin(GTA02_GPIO_BT_EN);
+		__gta02_pm_bt_toggle_radio(&pdev->dev, 0);
+	}
+
+	return 0;
+}
+
+static int gta01_bt_resume(struct platform_device *pdev)
+{
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(&pdev->dev);
+	dev_dbg(&pdev->dev, DRVMSG ": resuming\n");
+
+	if (machine_is_neo1973_gta02()) {
+		__gta02_pm_bt_toggle_radio(&pdev->dev,
+						     bt_data->pre_resume_state);
+	}
+
+	return 0;
+}
+#else
+#define gta01_bt_suspend	NULL
+#define gta01_bt_resume		NULL
+#endif
+
+static struct attribute *gta01_bt_sysfs_entries[] = {
+	&dev_attr_power_on.attr,
+	&dev_attr_reset.attr,
+	NULL
+};
+
+static struct attribute_group gta01_bt_attr_group = {
+	.name	= NULL,
+	.attrs	= gta01_bt_sysfs_entries,
+};
+
+static int __init gta01_bt_probe(struct platform_device *pdev)
+{
+	struct rfkill *rfkill;
+	struct regulator *regulator;
+	struct gta01_pm_bt_data *bt_data;
+	int ret;
+
+	dev_info(&pdev->dev, DRVMSG ": starting\n");
+
+	bt_data = kzalloc(sizeof(*bt_data), GFP_KERNEL);
+	dev_set_drvdata(&pdev->dev, bt_data);
+
+	if (machine_is_neo1973_gta01()) {
+		/* we make sure that the voltage is off */
+		regulator = regulator_get(&pdev->dev, "BT_3V1");
+		if (IS_ERR(regulator))
+			return -ENODEV;
+
+		bt_data->regulator = regulator;
+
+		/* this tests the true physical state of the regulator... */
+		if (regulator_is_enabled(regulator)) {
+			/*
+			 * but these only operate on the logical state of the
+			 * regulator... so we need to logicaly "adopt" it on
+			 * to turn it off
+			 */
+			regulator_enable(regulator);
+			regulator_disable(regulator);
+		}
+
+		/* we pull reset to low to make sure that the chip doesn't
+	 	 * drain power through the reset line */
+		neo1973_gpb_setpin(GTA01_GPIO_BT_EN, 0);
+	} else if (machine_is_neo1973_gta02()) {
+		regulator = regulator_get(&pdev->dev, "BT_3V2");
+		if (IS_ERR(regulator))
+			return -ENODEV;
+
+		bt_data->regulator = regulator;
+
+		/* this tests the true physical state of the regulator... */
+		if (regulator_is_enabled(regulator)) {
+			/*
+			 * but these only operate on the logical state of the
+			 * regulator... so we need to logicaly "adopt" it on
+			 * to turn it off
+			 */
+			regulator_enable(regulator);
+			regulator_disable(regulator);
+		}
+
+		/* we pull reset to low to make sure that the chip doesn't
+	 	 * drain power through the reset line */
+		neo1973_gpb_setpin(GTA02_GPIO_BT_EN, 0);
+	}
+
+	rfkill = rfkill_allocate(&pdev->dev, RFKILL_TYPE_BLUETOOTH);
+
+	rfkill->name = pdev->name;
+	rfkill->data = &pdev->dev;
+	rfkill->state = RFKILL_STATE_OFF;
+	rfkill->toggle_radio = bt_rfkill_toggle_radio;
+
+	ret = rfkill_register(rfkill);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register rfkill\n");
+		return ret;
+	}
+
+	bt_data->rfkill = rfkill;
+
+	return sysfs_create_group(&pdev->dev.kobj, &gta01_bt_attr_group);
+}
+
+static int gta01_bt_remove(struct platform_device *pdev)
+{
+	struct gta01_pm_bt_data *bt_data = dev_get_drvdata(&pdev->dev);
+	struct regulator *regulator;
+
+	sysfs_remove_group(&pdev->dev.kobj, &gta01_bt_attr_group);
+
+	if (bt_data->rfkill) {
+		rfkill_unregister(bt_data->rfkill);
+		rfkill_free(bt_data->rfkill);
+	}
+
+	if (!bt_data || !bt_data->regulator)
+		return 0;
+
+	regulator = bt_data->regulator;
+
+	/* Make sure regulator is disabled before calling regulator_put */
+	if (regulator_is_enabled(regulator))
+		regulator_disable(regulator);
+
+	regulator_put(regulator);
+
+	kfree(bt_data);
+	
+	return 0;
+}
+
+static struct platform_driver gta01_bt_driver = {
+	.probe		= gta01_bt_probe,
+	.remove		= gta01_bt_remove,
+	.suspend	= gta01_bt_suspend,
+	.resume		= gta01_bt_resume,
+	.driver		= {
+		.name		= "neo1973-pm-bt",
+	},
+};
+
+static int __devinit gta01_bt_init(void)
+{
+	return platform_driver_register(&gta01_bt_driver);
+}
+
+static void gta01_bt_exit(void)
+{
+	platform_driver_unregister(&gta01_bt_driver);
+}
+
+module_init(gta01_bt_init);
+module_exit(gta01_bt_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION(DRVMSG);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_gps.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_gps.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_gps.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_gps.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,803 @@
+/*
+ * GPS Power Management code for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2007-2009 by Openmoko Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <mach/cpu.h>
+
+#include <asm/mach-types.h>
+
+#include <asm/plat-s3c24xx/neo1973.h>
+
+/* For GTA01 */
+#include <mach/gta01.h>
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/mfd/pcf50606/gpo.h>
+
+/* For GTA02 */
+#include <mach/gta02.h>
+#include <linux/mfd/pcf50633/core.h>
+#include <linux/mfd/pcf50633/pmic.h>
+
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+
+enum gta01_pm_gps_supplies {
+
+	/* GTA01 */
+	GTA01_GPS_REG_2V8,
+	GTA01_GPS_REG_3V,
+	GTA01_GPS_REG_3V3,
+	GTA01_GPS_REG_1V5,
+	GTA01_GPS_REG_2V5,
+
+	/* GTA02 */
+	GTA02_GPS_REG_RF_3V,
+
+	/* Always last */
+	GTA01_GPS_NUM_REG
+};
+
+struct neo1973_pm_gps_data {
+#ifdef CONFIG_PM
+	int keep_on_in_suspend;
+#endif
+	int power_was_on; /* For GTA02 only */
+	int regulator_state[GTA01_GPS_NUM_REG];
+	struct regulator *regulator[GTA01_GPS_NUM_REG];
+};
+
+static struct neo1973_pm_gps_data neo1973_gps;
+
+int neo1973_pm_gps_is_on(void)
+{
+	return neo1973_gps.power_was_on;
+}
+EXPORT_SYMBOL_GPL(neo1973_pm_gps_is_on);
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+
+/* This is the 2.8V supply for the RTC crystal, the mail clock crystal and
+ * the input to VDD_RF */
+static void gps_power_2v8_set(int on)
+{
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_2V8];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+		if (on)
+			regulator_enable(regulator);
+		else
+			regulator_disable(regulator);
+		neo1973_gps.regulator_state[GTA01_GPS_REG_2V8] = on;
+		break;
+	case GTA01Bv2_SYSTEM_REV:
+		s3c2410_gpio_setpin(GTA01_GPIO_GPS_EN_2V8, on);
+			break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		break;
+	}
+}
+
+static int gps_power_2v8_get(void)
+{
+	int ret = 0;
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_2V8];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+			ret = regulator_is_enabled(regulator);
+		break;
+	case GTA01Bv2_SYSTEM_REV:
+		if (s3c2410_gpio_getpin(GTA01_GPIO_GPS_EN_2V8))
+			ret = 1;
+		break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		break;
+	}
+
+	return ret;
+}
+
+/* This is the 3V supply (AVDD) for the external RF frontend (LNA bias) */
+static void gps_power_3v_set(int on)
+{
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_3V];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+		if (on)
+			regulator_enable(regulator);
+		else
+			regulator_disable(regulator);
+		neo1973_gps.regulator_state[GTA01_GPS_REG_3V] = on;
+		break;
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		s3c2410_gpio_setpin(GTA01_GPIO_GPS_EN_3V, on);
+		break;
+	}
+}
+
+static int gps_power_3v_get(void)
+{
+	int ret = 0;
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_3V];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+		ret = regulator_is_enabled(regulator);
+		break;
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		if (s3c2410_gpio_getpin(GTA01_GPIO_GPS_EN_3V))
+			ret = 1;
+		break;
+	}
+
+	return ret;
+}
+
+/* This is the 3.3V supply for VDD_IO and VDD_LPREG input */
+static void gps_power_3v3_set(int on)
+{
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_3V3];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+		if (on)
+			regulator_enable(regulator);
+		else
+			regulator_disable(regulator);
+		neo1973_gps.regulator_state[GTA01_GPS_REG_3V3] = on;
+		break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		s3c2410_gpio_setpin(GTA01_GPIO_GPS_EN_3V3, on);
+		break;
+	}
+}
+
+static int gps_power_3v3_get(void)
+{
+	int ret = 0;
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_3V3];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+		ret = regulator_is_enabled(regulator);
+		break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		if (s3c2410_gpio_getpin(GTA01_GPIO_GPS_EN_3V3))
+			ret = 1;
+		break;
+	}
+
+	return ret;
+}
+
+/* This is the 2.5V supply for VDD_PLLREG and VDD_COREREG input */
+static void gps_power_2v5_set(int on)
+{
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_2V5];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+		/* This is CORE_1V8 and cannot be disabled */
+		break;
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		if (on)
+			regulator_enable(regulator);
+		else
+			regulator_disable(regulator);
+		neo1973_gps.regulator_state[GTA01_GPS_REG_2V5] = on;
+		break;
+	}
+}
+
+static int gps_power_2v5_get(void)
+{
+	int ret = 0;
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_2V5];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+		/* This is CORE_1V8 and cannot be disabled */
+		ret = 1;
+		break;
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		ret = regulator_is_enabled(regulator);
+		break;
+	}
+
+	return ret;
+}
+
+/* This is the 1.5V supply for VDD_CORE */
+static void gps_power_1v5_set(int on)
+{
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_1V5];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+		/* This is switched via 2v5 */
+		break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		if (on)
+			regulator_enable(regulator);
+		else
+			regulator_disable(regulator);
+		neo1973_gps.regulator_state[GTA01_GPS_REG_1V5] = on;
+		break;
+	}
+}
+
+static int gps_power_1v5_get(void)
+{
+	int ret = 0;
+	struct regulator *regulator = neo1973_gps.regulator[GTA01_GPS_REG_1V5];
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+		/* This is switched via 2v5 */
+		ret = 1;
+		break;
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		ret = regulator_is_enabled(regulator);
+		break;
+	}
+
+	return ret;
+}
+#endif
+
+/* This is the POWERON pin */
+static void gps_pwron_set(int on)
+{
+
+	if (machine_is_neo1973_gta01())
+		neo1973_gpb_setpin(GTA01_GPIO_GPS_PWRON, on);
+
+	if (machine_is_neo1973_gta02()) {
+		if (on) {
+			/* return UART pins to being UART pins */
+			s3c2410_gpio_cfgpin(S3C2410_GPH4, S3C2410_GPH4_TXD1);
+			/* remove pulldown now it won't be floating any more */
+			s3c2410_gpio_pullup(S3C2410_GPH5, 0);
+
+			if (!neo1973_gps.power_was_on)
+				regulator_enable(neo1973_gps.regulator[
+							  GTA02_GPS_REG_RF_3V]);
+			return;
+		}
+
+		/*
+		 * take care not to power unpowered GPS from UART TX
+		 * return them to GPIO and force low
+		 */
+		s3c2410_gpio_cfgpin(S3C2410_GPH4, S3C2410_GPH4_OUTP);
+		s3c2410_gpio_setpin(S3C2410_GPH4, 0);
+		/* don't let RX from unpowered GPS float */
+		s3c2410_gpio_pullup(S3C2410_GPH5, 1);
+		if (neo1973_gps.power_was_on)
+			regulator_disable(neo1973_gps.regulator[
+							  GTA02_GPS_REG_RF_3V]);
+	}
+}
+
+static int gps_pwron_get(void)
+{
+	if (machine_is_neo1973_gta01())
+		return !!s3c2410_gpio_getpin(GTA01_GPIO_GPS_PWRON);
+
+	if (machine_is_neo1973_gta02())
+		return regulator_is_enabled(neo1973_gps.regulator[GTA02_GPS_REG_RF_3V]);
+	return -1;
+}
+
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+static void gps_rst_set(int on);
+static int gps_rst_get(void);
+#endif
+
+#ifdef CONFIG_PM
+/* This is the flag for keeping gps ON during suspend */
+static void gps_keep_on_in_suspend_set(int on)
+{
+	neo1973_gps.keep_on_in_suspend = on;
+}
+
+static int gps_keep_on_in_suspend_get(void)
+{
+	return neo1973_gps.keep_on_in_suspend;
+}
+#endif
+
+static ssize_t power_gps_read(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	int ret = 0;
+
+	if (!strcmp(attr->attr.name, "power_on") ||
+	    !strcmp(attr->attr.name, "pwron")) {
+		ret = gps_pwron_get();
+#ifdef CONFIG_PM
+	} else if (!strcmp(attr->attr.name, "keep_on_in_suspend")) {
+		ret = gps_keep_on_in_suspend_get();
+#endif
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	} else if (!strcmp(attr->attr.name, "power_avdd_3v")) {
+		ret = gps_power_3v_get();
+	} else if (!strcmp(attr->attr.name, "power_tcxo_2v8")) {
+		ret = gps_power_2v8_get();
+	} else if (!strcmp(attr->attr.name, "reset")) {
+		ret = gps_rst_get();
+	} else if (!strcmp(attr->attr.name, "power_lp_io_3v3")) {
+		ret = gps_power_3v3_get();
+	} else if (!strcmp(attr->attr.name, "power_pll_core_2v5")) {
+		ret = gps_power_2v5_get();
+	} else if (!strcmp(attr->attr.name, "power_core_1v5") ||
+		   !strcmp(attr->attr.name, "power_vdd_core_1v5")) {
+		ret = gps_power_1v5_get();
+#endif
+	}
+	if (ret)
+		return strlcpy(buf, "1\n", 3);
+	else
+		return strlcpy(buf, "0\n", 3);
+}
+
+static ssize_t power_gps_write(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	unsigned long on = simple_strtoul(buf, NULL, 10);
+
+	if (!strcmp(attr->attr.name, "power_on") ||
+	    !strcmp(attr->attr.name, "pwron")) {
+		gps_pwron_set(on);
+		neo1973_gps.power_was_on = !!on;
+#ifdef CONFIG_PM
+	} else if (!strcmp(attr->attr.name, "keep_on_in_suspend")) {
+		gps_keep_on_in_suspend_set(on);
+#endif
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	} else if (!strcmp(attr->attr.name, "power_avdd_3v")) {
+		gps_power_3v_set(on);
+	} else if (!strcmp(attr->attr.name, "power_tcxo_2v8")) {
+		gps_power_2v8_set(on);
+	} else if (!strcmp(attr->attr.name, "reset")) {
+		gps_rst_set(on);
+	} else if (!strcmp(attr->attr.name, "power_lp_io_3v3")) {
+		gps_power_3v3_set(on);
+	} else if (!strcmp(attr->attr.name, "power_pll_core_2v5")) {
+		gps_power_2v5_set(on);
+	} else if (!strcmp(attr->attr.name, "power_core_1v5") ||
+		   !strcmp(attr->attr.name, "power_vdd_core_1v5")) {
+		gps_power_1v5_set(on);
+#endif
+	}
+	return count;
+}
+
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+
+/* This is the nRESET pin */
+static void gps_rst_set(int on)
+{
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+		pcf50606_gpo_set_active(gta01_pcf, PCF50606_GPO1, on);
+		break;
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		s3c2410_gpio_setpin(GTA01_GPIO_GPS_RESET, on);
+		break;
+	}
+}
+
+static int gps_rst_get(void)
+{
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+		return pcf50606_gpo_get_active(gta01_pcf, PCF50606_GPO1);
+		break;
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		if (s3c2410_gpio_getpin(GTA01_GPIO_GPS_RESET))
+			return 1;
+		break;
+	}
+
+	return 0;
+}
+
+
+static void gps_power_sequence_up(void)
+{
+	/* According to PMB2520 Data Sheet, Rev. 2006-06-05,
+	 * Chapter 4.2.2 */
+
+	/* nRESET must be asserted low */
+	gps_rst_set(0);
+
+	/* POWERON must be de-asserted (low) */
+	gps_pwron_set(0);
+
+	/* Apply VDD_IO and VDD_LPREG_IN */
+	gps_power_3v3_set(1);
+
+	/* VDD_COREREG_IN, VDD_PLLREG_IN */
+	gps_power_1v5_set(1);
+	gps_power_2v5_set(1);
+
+	/* and VDD_RF may be applied */
+	gps_power_2v8_set(1);
+
+	/* We need to enable AVDD, since in GTA01Bv3 it is
+	 * shared with RFREG_IN */
+	gps_power_3v_set(1);
+
+	msleep(3); 	/* Is 3ms enough? */
+
+	/* De-asert nRESET */
+	gps_rst_set(1);
+
+	/* Switch power on */
+	gps_pwron_set(1);
+
+}
+
+static void gps_power_sequence_down(void)
+{
+	/* According to PMB2520 Data Sheet, Rev. 2006-06-05,
+	 * Chapter 4.2.3.1 */
+	gps_pwron_set(0);
+
+	/* Don't disable AVDD before PWRON is cleared, since
+	 * in GTA01Bv3, AVDD and RFREG_IN are shared */
+	if (neo1973_gps.regulator_state[GTA01_GPS_REG_3V])
+		gps_power_3v_set(0);
+
+	/* Remove VDD_COREREG_IN, VDD_PLLREG_IN and VDD_REFREG_IN */
+	if (neo1973_gps.regulator_state[GTA01_GPS_REG_1V5])
+		gps_power_1v5_set(0);
+	if (neo1973_gps.regulator_state[GTA01_GPS_REG_2V5])
+		gps_power_2v5_set(0);
+	if (neo1973_gps.regulator_state[GTA01_GPS_REG_2V8])
+		gps_power_2v8_set(0);
+
+	/* Remove VDD_LPREG_IN and VDD_IO */
+	if (neo1973_gps.regulator_state[GTA01_GPS_REG_3V3])
+		gps_power_3v3_set(0);
+
+}
+
+static ssize_t power_sequence_read(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	return strlcpy(buf, "power_up power_down\n", PAGE_SIZE);
+}
+
+static ssize_t power_sequence_write(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	dev_dbg(dev, "wrote: '%s'\n", buf);
+
+	if (!strncmp(buf, "power_up", 8))
+		gps_power_sequence_up();
+	else if (!strncmp(buf, "power_down", 10))
+		gps_power_sequence_down();
+	else
+		return -EINVAL;
+
+	return count;
+}
+
+static DEVICE_ATTR(power_tcxo_2v8, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(power_avdd_3v, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(reset, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(power_lp_io_3v3, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(power_pll_core_2v5, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(power_core_1v5, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(power_vdd_core_1v5, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(power_sequence, 0644, power_sequence_read,
+		   power_sequence_write);
+#endif
+
+#ifdef CONFIG_PM
+static int gta01_pm_gps_suspend(struct platform_device *pdev,
+				pm_message_t state)
+{
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	if (machine_is_neo1973_gta01())
+		/* FIXME */
+		gps_power_sequence_down();
+#endif
+	if (machine_is_neo1973_gta02()) {
+		if (!neo1973_gps.keep_on_in_suspend ||
+		    !neo1973_gps.power_was_on)
+			gps_pwron_set(0);
+		else
+			dev_warn(&pdev->dev, "GTA02: keeping gps ON "
+				 "during suspend\n");
+	}
+
+	return 0;
+}
+
+static int gta01_pm_gps_resume(struct platform_device *pdev)
+{
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	if (machine_is_neo1973_gta01())
+		if (neo1973_gps.power_was_on)
+			gps_power_sequence_up();
+#endif
+	if (machine_is_neo1973_gta02())
+		if (!neo1973_gps.keep_on_in_suspend && neo1973_gps.power_was_on)
+		    gps_pwron_set(1);
+
+	return 0;
+}
+
+static DEVICE_ATTR(keep_on_in_suspend, 0644, power_gps_read, power_gps_write);
+#else
+#define gta01_pm_gps_suspend	NULL
+#define gta01_pm_gps_resume	NULL
+#endif
+
+static DEVICE_ATTR(power_on, 0644, power_gps_read, power_gps_write);
+static DEVICE_ATTR(pwron, 0644, power_gps_read, power_gps_write);
+
+
+static struct attribute *gta01_gps_sysfs_entries[] = {
+	&dev_attr_power_on.attr,
+	&dev_attr_pwron.attr,
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	&dev_attr_power_avdd_3v.attr,
+	&dev_attr_reset.attr,
+	&dev_attr_power_lp_io_3v3.attr,
+	&dev_attr_power_pll_core_2v5.attr,
+	&dev_attr_power_sequence.attr,
+	NULL,	/* power_core_1v5 */
+	NULL,	/* power_vdd_core_1v5 */
+#endif
+	NULL    /* terminating entry */
+};
+
+static struct attribute_group gta01_gps_attr_group = {
+	.name	= NULL,
+	.attrs	= gta01_gps_sysfs_entries,
+};
+
+static struct attribute *gta02_gps_sysfs_entries[] = {
+	&dev_attr_power_on.attr,
+#ifdef CONFIG_PM
+	&dev_attr_keep_on_in_suspend.attr,
+#endif
+	NULL
+};
+
+static struct attribute_group gta02_gps_attr_group = {
+	.name	= NULL,
+	.attrs	= gta02_gps_sysfs_entries,
+};
+
+static int __init gta01_pm_gps_probe(struct platform_device *pdev)
+{
+	int ret;
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	int entries = ARRAY_SIZE(gta01_gps_sysfs_entries);
+#endif
+
+	if (machine_is_neo1973_gta01()) {
+		s3c2410_gpio_cfgpin(GTA01_GPIO_GPS_PWRON, S3C2410_GPIO_OUTPUT);
+
+		switch (S3C_SYSTEM_REV_ATAG) {
+		case GTA01v3_SYSTEM_REV:
+			break;
+		case GTA01v4_SYSTEM_REV:
+			s3c2410_gpio_cfgpin(GTA01_GPIO_GPS_RESET,
+			    S3C2410_GPIO_OUTPUT);
+			break;
+		case GTA01Bv3_SYSTEM_REV:
+		case GTA01Bv4_SYSTEM_REV:
+			s3c2410_gpio_cfgpin(GTA01_GPIO_GPS_EN_3V3,
+			    S3C2410_GPIO_OUTPUT);
+			/* fallthrough */
+		case GTA01Bv2_SYSTEM_REV:
+			s3c2410_gpio_cfgpin(GTA01_GPIO_GPS_EN_2V8,
+			    S3C2410_GPIO_OUTPUT);
+			s3c2410_gpio_cfgpin(GTA01_GPIO_GPS_EN_3V,
+			    S3C2410_GPIO_OUTPUT);
+			s3c2410_gpio_cfgpin(GTA01_GPIO_GPS_RESET,
+			    S3C2410_GPIO_OUTPUT);
+			break;
+		default:
+			dev_warn(&pdev->dev, "Unknown GTA01 Revision 0x%x, "
+				"AGPS PM features not available!!!\n",
+				system_rev);
+			return -1;
+			break;
+		}
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	
+		neo1973_gps.regulator[GTA01_GPS_REG_2V8] =
+		       			regulator_get(&pdev->dev, "GPS_2V8");
+		neo1973_gps.regulator[GTA01_GPS_REG_3V] =
+		       			regulator_get(&pdev->dev, "GPS_3V");
+		neo1973_gps.regulator[GTA01_GPS_REG_3V3] =
+		       			regulator_get(&pdev->dev, "GPS_3V3");
+		neo1973_gps.regulator[GTA01_GPS_REG_1V5] =
+		       			regulator_get(&pdev->dev, "GPS_1V5");
+		neo1973_gps.regulator[GTA01_GPS_REG_2V5] =
+		       			regulator_get(&pdev->dev, "GPS_2V5");
+
+		gps_power_sequence_down();
+
+		switch (S3C_SYSTEM_REV_ATAG) {
+		case GTA01v3_SYSTEM_REV:
+		case GTA01v4_SYSTEM_REV:
+		case GTA01Bv2_SYSTEM_REV:
+			gta01_gps_sysfs_entries[entries-3] =
+			    &dev_attr_power_tcxo_2v8.attr;
+			break;
+		case GTA01Bv3_SYSTEM_REV:
+		case GTA01Bv4_SYSTEM_REV:
+			gta01_gps_sysfs_entries[entries-3] =
+			    &dev_attr_power_core_1v5.attr;
+			gta01_gps_sysfs_entries[entries-2] =
+			    &dev_attr_power_vdd_core_1v5.attr;
+			break;
+		}
+#endif
+		ret = sysfs_create_group(&pdev->dev.kobj,
+		    &gta01_gps_attr_group);
+		if (ret)
+			return ret;
+		return bus_create_device_link(&platform_bus_type,
+				&pdev->dev.kobj, "gta01-pm-gps.0");
+	}
+
+	if (machine_is_neo1973_gta02()) {
+
+		neo1973_gps.regulator[GTA02_GPS_REG_RF_3V] = regulator_get(
+						&pdev->dev, "RF_3V");
+		if (IS_ERR(neo1973_gps.regulator)) {
+			dev_err(&pdev->dev, "probe failed %ld\n",
+			    PTR_ERR(neo1973_gps.regulator));
+
+			return PTR_ERR(neo1973_gps.regulator);
+		}
+
+		dev_info(&pdev->dev, "starting\n");
+
+		/*
+		 * Here we should call the code that handles the set GPS power
+		 * off action.  But, the regulator API does not allow us to
+		 * reassert regulator state, and when we read the regulator API
+		 * logical state, it can differ from the actual state,  So
+		 * a workaround for this is to just set the regulator off in the
+		 * PMU directly.  Because that's different from normal flow, we
+		 * have to reproduce other things from the OFF action here too.
+		 */
+
+		/*
+		 * u-boot enables LDO5 (GPS), which doesn't make sense and
+		 * causes confusion. We therefore disable the regulator here.
+		 */
+		pcf50633_reg_write(gta02_pcf, PCF50633_REG_LDO5ENA, 0);
+
+		/*
+		 * take care not to power unpowered GPS from UART TX
+		 * return them to GPIO and force low
+		 */
+		s3c2410_gpio_cfgpin(S3C2410_GPH4, S3C2410_GPH4_OUTP);
+		s3c2410_gpio_setpin(S3C2410_GPH4, 0);
+		/* don't let RX from unpowered GPS float */
+		s3c2410_gpio_pullup(S3C2410_GPH5, 1);
+
+		return sysfs_create_group(&pdev->dev.kobj,
+					  &gta02_gps_attr_group);
+	}
+	return -1;
+}
+
+static int gta01_pm_gps_remove(struct platform_device *pdev)
+{
+	if (machine_is_neo1973_gta01()) {
+#ifdef CONFIG_MACH_NEO1973_GTA01
+		int i;
+
+		gps_power_sequence_down();
+		/* Now disable all regulators */
+		for (i = 0; i < GTA01_GPS_NUM_REG; i++) {
+			regulator_put(neo1973_gps.regulator[i]);
+		}
+#endif
+		bus_remove_device_link(&platform_bus_type, "gta01-pm-gps.0");
+		sysfs_remove_group(&pdev->dev.kobj, &gta01_gps_attr_group);
+	}
+
+	if (machine_is_neo1973_gta02()) {
+		regulator_put(neo1973_gps.regulator[GTA02_GPS_REG_RF_3V]);
+		sysfs_remove_group(&pdev->dev.kobj, &gta02_gps_attr_group);
+	}
+	return 0;
+}
+
+static struct platform_driver gta01_pm_gps_driver = {
+	.probe		= gta01_pm_gps_probe,
+	.remove		= gta01_pm_gps_remove,
+	.suspend	= gta01_pm_gps_suspend,
+	.resume		= gta01_pm_gps_resume,
+	.driver		= {
+		.name		= "neo1973-pm-gps",
+	},
+};
+
+static int __devinit gta01_pm_gps_init(void)
+{
+	return platform_driver_register(&gta01_pm_gps_driver);
+}
+
+static void gta01_pm_gps_exit(void)
+{
+	platform_driver_unregister(&gta01_pm_gps_driver);
+}
+
+module_init(gta01_pm_gps_init);
+module_exit(gta01_pm_gps_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("FIC Neo1973 GPS Power Management");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_gps.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_gps.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_gps.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_gps.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1 @@
+extern int neo1973_pm_gps_is_on(void);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_pm_gsm.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,380 @@
+/*
+ * GSM Management code for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2007 by Openmoko Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/console.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include <mach/gpio.h>
+#include <asm/mach-types.h>
+#include <mach/gta01.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+#include <mach/s3c24xx-serial.h>
+
+#include <mach/hardware.h>
+#include <mach/cpu.h>
+
+/* For GTA02 */
+#include <mach/gta02.h>
+#include <linux/mfd/pcf50633/gpio.h>
+#include <mach/regs-gpio.h>
+#include <mach/regs-gpioj.h>
+
+int gta_gsm_interrupts;
+EXPORT_SYMBOL(gta_gsm_interrupts);
+
+extern void s3c24xx_serial_console_set_silence(int);
+
+struct gta01pm_priv {
+	int gpio_ngsm_en;
+        int gpio_ndl_gsm;
+
+	struct console *con;
+};
+
+static struct gta01pm_priv gta01_gsm;
+
+static struct console *find_s3c24xx_console(void)
+{
+	struct console *con;
+
+	acquire_console_sem();
+
+	for (con = console_drivers; con; con = con->next) {
+		if (!strcmp(con->name, "ttySAC"))
+			break;
+	}
+
+	release_console_sem();
+
+	return con;
+}
+
+static ssize_t gsm_read(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	if (!strcmp(attr->attr.name, "power_on")) {
+		if (gta01_gsm.gpio_ngsm_en) {
+			if (!s3c2410_gpio_getpin(gta01_gsm.gpio_ngsm_en))
+				goto out_1;
+		} else if (machine_is_neo1973_gta02())
+			if (pcf50633_gpio_get(gta02_pcf, PCF50633_GPIO2))
+				goto out_1;
+	} else if (!strcmp(attr->attr.name, "download")) {
+		if (machine_is_neo1973_gta01()) {
+			if (s3c2410_gpio_getpin(GTA01_GPIO_MODEM_DNLOAD))
+				goto out_1;
+		} else if (machine_is_neo1973_gta02()) {
+			if (!s3c2410_gpio_getpin(GTA02_GPIO_nDL_GSM))
+				goto out_1;
+		}
+	} else if (!strcmp(attr->attr.name, "flowcontrolled")) {
+		if (s3c2410_gpio_getcfg(S3C2410_GPH1) == S3C2410_GPIO_OUTPUT)
+			goto out_1;
+	}
+
+	return strlcpy(buf, "0\n", 3);
+out_1:
+	return strlcpy(buf, "1\n", 3);
+}
+
+static void gsm_on_off(struct device *dev, int on)
+{
+	if (!on) {
+		if (machine_is_neo1973_gta02()) {
+			/*
+			 * Do not drive into powered-down GSM side
+			 * GTA02 only, because on GTA01 maybe serial
+			 * is used otherwise.
+			 */
+			s3c2410_gpio_cfgpin(S3C2410_GPH1, S3C2410_GPIO_INPUT);
+			s3c2410_gpio_cfgpin(S3C2410_GPH2, S3C2410_GPIO_INPUT);
+
+			pcf50633_gpio_set(gta02_pcf, PCF50633_GPIO2, 0);
+		}
+
+		if (gta01_gsm.gpio_ngsm_en)
+			s3c2410_gpio_setpin(gta01_gsm.gpio_ngsm_en, 1);
+
+		if (gta01_gsm.con) {
+			s3c24xx_serial_console_set_silence(0);
+			console_start(gta01_gsm.con);
+
+			dev_dbg(dev, "powered down GTA01 GSM, enabling "
+					"serial console\n");
+		}
+
+		return;
+	}
+
+	if (gta01_gsm.con) {
+		dev_dbg(dev, "powering up GSM, thus "
+				"disconnecting serial console\n");
+
+		console_stop(gta01_gsm.con);
+		s3c24xx_serial_console_set_silence(1);
+	}
+
+	/* allow UART to talk to GSM side now we will power it */
+	s3c2410_gpio_cfgpin(S3C2410_GPH1, S3C2410_GPH1_nRTS0);
+	s3c2410_gpio_cfgpin(S3C2410_GPH2, S3C2410_GPH2_TXD0);
+
+	if (gta01_gsm.gpio_ngsm_en)
+		s3c2410_gpio_setpin(gta01_gsm.gpio_ngsm_en, 0);
+
+	if (machine_is_neo1973_gta02())
+		pcf50633_gpio_set(gta02_pcf, PCF50633_GPIO2, 7);
+
+	msleep(100);
+
+	neo1973_gpb_setpin(GTA01_GPIO_MODEM_ON, 1);
+	msleep(500);
+	neo1973_gpb_setpin(GTA01_GPIO_MODEM_ON, 0);
+
+	/*
+	 * workaround for calypso firmware moko10 and earlier,
+	 * without this it will leave IRQ line high after
+	 * booting
+	 */
+	s3c2410_gpio_setpin(S3C2410_GPH1, 1);
+	s3c2410_gpio_cfgpin(S3C2410_GPH1, S3C2410_GPH1_OUTP);
+	msleep(1000);
+	s3c2410_gpio_cfgpin(S3C2410_GPH1, S3C2410_GPH1_nRTS0);
+
+}
+
+static ssize_t gsm_write(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	unsigned long on = simple_strtoul(buf, NULL, 10);
+
+	if (!strcmp(attr->attr.name, "power_on")) {
+		gsm_on_off(dev, on);
+
+		return count;
+	}
+
+	if (!strcmp(attr->attr.name, "download")) {
+		if (machine_is_neo1973_gta01())
+			s3c2410_gpio_setpin(GTA01_GPIO_MODEM_DNLOAD, on);
+
+		if (machine_is_neo1973_gta02()) {
+			/*
+			 * the keyboard / buttons driver requests and enables
+			 * the JACK_INSERT IRQ.  We have to take care about
+			 * not enabling and disabling the IRQ when it was
+			 * already in that state or we get "unblanaced IRQ"
+			 * kernel warnings and stack dumps.  So we use the
+			 * copy of the ndl_gsm state to figure out if we should
+			 * enable or disable the jack interrupt
+			 */
+			if (on) {
+				if (gta01_gsm.gpio_ndl_gsm)
+					disable_irq(gpio_to_irq(
+						       GTA02_GPIO_JACK_INSERT));
+			} else {
+				if (!gta01_gsm.gpio_ndl_gsm)
+					enable_irq(gpio_to_irq(
+						       GTA02_GPIO_JACK_INSERT));
+			}
+
+			gta01_gsm.gpio_ndl_gsm = !on;
+			s3c2410_gpio_setpin(GTA02_GPIO_nDL_GSM, !on);
+		}
+
+		return count;
+	}
+
+	if (!strcmp(attr->attr.name, "flowcontrolled")) {
+		if (on) {
+			gta_gsm_interrupts = 0;
+			s3c2410_gpio_setpin(S3C2410_GPH1, 1);
+			s3c2410_gpio_cfgpin(S3C2410_GPH1, S3C2410_GPH1_OUTP);
+		} else
+			s3c2410_gpio_cfgpin(S3C2410_GPH1, S3C2410_GPH1_nRTS0);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(power_on, 0644, gsm_read, gsm_write);
+static DEVICE_ATTR(reset, 0644, gsm_read, gsm_write);
+static DEVICE_ATTR(download, 0644, gsm_read, gsm_write);
+static DEVICE_ATTR(flowcontrolled, 0644, gsm_read, gsm_write);
+
+#ifdef CONFIG_PM
+
+static int gta01_gsm_resume(struct platform_device *pdev);
+static int gta01_gsm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	/* GPIO state is saved/restored by S3C2410 core GPIO driver, so we
+	 * don't need to do much here. */
+
+	/* If flowcontrol asserted, abort if GSM already interrupted */
+	if (s3c2410_gpio_getcfg(S3C2410_GPH1) == S3C2410_GPIO_OUTPUT) {
+		if (gta_gsm_interrupts)
+			goto busy;
+	}
+
+	/* disable DL GSM to prevent jack_insert becoming 'floating' */
+	if (machine_is_neo1973_gta02())
+		s3c2410_gpio_setpin(GTA02_GPIO_nDL_GSM, 1);
+	return 0;
+
+busy:
+	return -EBUSY;
+}
+
+static int
+gta01_gsm_suspend_late(struct platform_device *pdev, pm_message_t state)
+{
+	/* Last chance: abort if GSM already interrupted */
+	if (s3c2410_gpio_getcfg(S3C2410_GPH1) == S3C2410_GPIO_OUTPUT) {
+		if (gta_gsm_interrupts)
+			return -EBUSY;
+	}
+	return 0;
+}
+
+static int gta01_gsm_resume(struct platform_device *pdev)
+{
+	/* GPIO state is saved/restored by S3C2410 core GPIO driver, so we
+	 * don't need to do much here. */
+
+	/* Make sure that the kernel console on the serial port is still
+	 * disabled. FIXME: resume ordering race with serial driver! */
+	if (gta01_gsm.con && s3c2410_gpio_getpin(GTA01_GPIO_MODEM_ON))
+		console_stop(gta01_gsm.con);
+
+	if (machine_is_neo1973_gta02())
+		s3c2410_gpio_setpin(GTA02_GPIO_nDL_GSM, gta01_gsm.gpio_ndl_gsm);
+
+	return 0;
+}
+#else
+#define gta01_gsm_suspend	NULL
+#define gta01_gsm_suspend_late	NULL
+#define gta01_gsm_resume	NULL
+#endif /* CONFIG_PM */
+
+static struct attribute *gta01_gsm_sysfs_entries[] = {
+	&dev_attr_power_on.attr,
+	&dev_attr_reset.attr,
+	&dev_attr_download.attr,
+	&dev_attr_flowcontrolled.attr,
+	NULL
+};
+
+static struct attribute_group gta01_gsm_attr_group = {
+	.name	= NULL,
+	.attrs	= gta01_gsm_sysfs_entries,
+};
+
+static int __init gta01_gsm_probe(struct platform_device *pdev)
+{
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v3_SYSTEM_REV:
+		gta01_gsm.gpio_ngsm_en = GTA01v3_GPIO_nGSM_EN;
+		break;
+	case GTA01v4_SYSTEM_REV:
+		gta01_gsm.gpio_ngsm_en = 0;
+		break;
+	case GTA01Bv2_SYSTEM_REV:
+	case GTA01Bv3_SYSTEM_REV:
+	case GTA01Bv4_SYSTEM_REV:
+		gta01_gsm.gpio_ngsm_en = GTA01Bv2_GPIO_nGSM_EN;
+		s3c2410_gpio_setpin(GTA01v3_GPIO_nGSM_EN, 0);
+		break;
+	case GTA02v1_SYSTEM_REV:
+	case GTA02v2_SYSTEM_REV:
+	case GTA02v3_SYSTEM_REV:
+	case GTA02v4_SYSTEM_REV:
+	case GTA02v5_SYSTEM_REV:
+	case GTA02v6_SYSTEM_REV:
+		gta01_gsm.gpio_ngsm_en = 0;
+		break;
+	default:
+		dev_warn(&pdev->dev, "Unknown Neo1973 Revision 0x%x, "
+			 "some PM features not available!!!\n",
+			 system_rev);
+		break;
+	}
+
+	switch (S3C_SYSTEM_REV_ATAG) {
+	case GTA01v4_SYSTEM_REV:
+	case GTA01Bv2_SYSTEM_REV:
+		gta01_gsm_sysfs_entries[ARRAY_SIZE(gta01_gsm_sysfs_entries)-2] =
+							&dev_attr_download.attr;
+		break;
+	default:
+		break;
+	}
+
+	if (machine_is_neo1973_gta01()) {
+		gta01_gsm.con = find_s3c24xx_console();
+		if (!gta01_gsm.con)
+			dev_warn(&pdev->dev,
+				 "cannot find S3C24xx console driver\n");
+	} else
+		gta01_gsm.con = NULL;
+
+	/* note that download initially disabled, and enforce that */
+	gta01_gsm.gpio_ndl_gsm = 1;
+	if (machine_is_neo1973_gta02())
+		s3c2410_gpio_setpin(GTA02_GPIO_nDL_GSM, 1);
+
+	/* GSM is to be initially off (at boot, or if this module inserted) */
+	gsm_on_off(&pdev->dev, 0);
+
+	return sysfs_create_group(&pdev->dev.kobj, &gta01_gsm_attr_group);
+}
+
+static int gta01_gsm_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &gta01_gsm_attr_group);
+
+	return 0;
+}
+
+static struct platform_driver gta01_gsm_driver = {
+	.probe		= gta01_gsm_probe,
+	.remove		= gta01_gsm_remove,
+	.suspend	= gta01_gsm_suspend,
+	.suspend_late	= gta01_gsm_suspend_late,
+	.resume		= gta01_gsm_resume,
+	.driver		= {
+		.name		= "neo1973-pm-gsm",
+	},
+};
+
+static int __devinit gta01_gsm_init(void)
+{
+	return platform_driver_register(&gta01_gsm_driver);
+}
+
+static void gta01_gsm_exit(void)
+{
+	platform_driver_unregister(&gta01_gsm_driver);
+}
+
+module_init(gta01_gsm_init);
+module_exit(gta01_gsm_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("FIC Neo1973 GSM Power Management");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_shadow.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_shadow.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/neo1973_shadow.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/neo1973_shadow.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,88 @@
+/*
+ * include/asm-arm/plat-s3c24xx/neo1973.h
+ *
+ * Common utility code for GTA01 and GTA02
+ *
+ * Copyright (C) 2008 by Openmoko, Inc.
+ * Author: Holger Hans Peter Freyther <freyther@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+
+#include <asm/gpio.h>
+#include <mach/regs-gpio.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+
+/**
+ * Shadow GPIO bank B handling. For the LEDs we need to keep track of the state
+ * in software. The s3c2410_gpio_setpin must not be used for GPIOs on bank B
+ */
+static unsigned long gpb_mask;
+static unsigned long gpb_state;
+
+void neo1973_gpb_add_shadow_gpio(unsigned int gpio)
+{
+	unsigned long offset = S3C2410_GPIO_OFFSET(gpio);
+	unsigned long flags;
+
+	local_irq_save(flags);
+	gpb_mask |= 1L << offset;
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL(neo1973_gpb_add_shadow_gpio);
+
+static void set_shadow_gpio(unsigned long offset, unsigned int value)
+{
+	unsigned long state = value != 0;
+
+	gpb_state &= ~(1L << offset);
+	gpb_state |= state << offset;
+}
+
+void neo1973_gpb_setpin(unsigned int pin, unsigned to)
+{
+	void __iomem *base = S3C24XX_GPIO_BASE(S3C2410_GPB0);
+	unsigned long offset = S3C2410_GPIO_OFFSET(pin);
+	unsigned long flags;
+	unsigned long dat;
+
+	BUG_ON(base != S3C24XX_GPIO_BASE(pin));
+
+	local_irq_save(flags);
+	dat = __raw_readl(base + 0x04);
+
+	/* Add the shadow values */
+	dat &= ~gpb_mask;
+	dat |= gpb_state;
+
+	/* Do the operation like s3c2410_gpio_setpin */
+	dat &= ~(1L << offset);
+	dat |= to << offset;
+
+	/* Update the shadow state */
+	if ((1L << offset) & gpb_mask)
+		set_shadow_gpio(offset, to);
+
+	__raw_writel(dat, base + 0x04);
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL(neo1973_gpb_setpin);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/pm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/pm.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -31,28 +31,20 @@
 #include <linux/errno.h>
 #include <linux/time.h>
 #include <linux/interrupt.h>
-#include <linux/crc32.h>
-#include <linux/ioport.h>
 #include <linux/serial_core.h>
 #include <linux/io.h>
 
-#include <asm/cacheflush.h>
-#include <mach/hardware.h>
-
 #include <plat/regs-serial.h>
 #include <mach/regs-clock.h>
 #include <mach/regs-gpio.h>
 #include <mach/regs-mem.h>
 #include <mach/regs-irq.h>
+#include <mach/hardware.h>
 
 #include <asm/mach/time.h>
 
 #include <plat/pm.h>
 
-/* for external use */
-
-unsigned long s3c_pm_flags;
-
 #define PFX "s3c24xx-pm: "
 
 static struct sleep_save core_save[] = {
@@ -84,364 +76,17 @@
 	SAVE_ITEM(S3C2410_CLKSLOW),
 };
 
-static struct gpio_sleep {
-	void __iomem	*base;
-	unsigned int	 gpcon;
-	unsigned int	 gpdat;
-	unsigned int	 gpup;
-} gpio_save[] = {
-	[0] = {
-		.base	= S3C2410_GPACON,
-	},
-	[1] = {
-		.base	= S3C2410_GPBCON,
-	},
-	[2] = {
-		.base	= S3C2410_GPCCON,
-	},
-	[3] = {
-		.base	= S3C2410_GPDCON,
-	},
-	[4] = {
-		.base	= S3C2410_GPECON,
-	},
-	[5] = {
-		.base	= S3C2410_GPFCON,
-	},
-	[6] = {
-		.base	= S3C2410_GPGCON,
-	},
-	[7] = {
-		.base	= S3C2410_GPHCON,
-	},
-};
-
 static struct sleep_save misc_save[] = {
 	SAVE_ITEM(S3C2410_DCLKCON),
 };
 
-#ifdef CONFIG_S3C2410_PM_DEBUG
-
-#define SAVE_UART(va) \
-	SAVE_ITEM((va) + S3C2410_ULCON), \
-	SAVE_ITEM((va) + S3C2410_UCON), \
-	SAVE_ITEM((va) + S3C2410_UFCON), \
-	SAVE_ITEM((va) + S3C2410_UMCON), \
-	SAVE_ITEM((va) + S3C2410_UBRDIV)
-
-static struct sleep_save uart_save[] = {
-	SAVE_UART(S3C24XX_VA_UART0),
-	SAVE_UART(S3C24XX_VA_UART1),
-#ifndef CONFIG_CPU_S3C2400
-	SAVE_UART(S3C24XX_VA_UART2),
-#endif
-};
-
-/* debug
- *
- * we send the debug to printascii() to allow it to be seen if the
- * system never wakes up from the sleep
-*/
-
-extern void printascii(const char *);
-
-void pm_dbg(const char *fmt, ...)
-{
-	va_list va;
-	char buff[256];
-
-	va_start(va, fmt);
-	vsprintf(buff, fmt, va);
-	va_end(va);
-
-	printascii(buff);
-}
-
-static void s3c2410_pm_debug_init(void)
-{
-	unsigned long tmp = __raw_readl(S3C2410_CLKCON);
-
-	/* re-start uart clocks */
-	tmp |= S3C2410_CLKCON_UART0;
-	tmp |= S3C2410_CLKCON_UART1;
-	tmp |= S3C2410_CLKCON_UART2;
-
-	__raw_writel(tmp, S3C2410_CLKCON);
-	udelay(10);
-}
-
-#define DBG(fmt...) pm_dbg(fmt)
-#else
-#define DBG(fmt...) printk(KERN_DEBUG fmt)
-
-#define s3c2410_pm_debug_init() do { } while(0)
-
-static struct sleep_save uart_save[] = {};
-#endif
-
-#if defined(CONFIG_S3C2410_PM_CHECK) && CONFIG_S3C2410_PM_CHECK_CHUNKSIZE != 0
-
-/* suspend checking code...
- *
- * this next area does a set of crc checks over all the installed
- * memory, so the system can verify if the resume was ok.
- *
- * CONFIG_S3C2410_PM_CHECK_CHUNKSIZE defines the block-size for the CRC,
- * increasing it will mean that the area corrupted will be less easy to spot,
- * and reducing the size will cause the CRC save area to grow
-*/
-
-#define CHECK_CHUNKSIZE (CONFIG_S3C2410_PM_CHECK_CHUNKSIZE * 1024)
-
-static u32 crc_size;	/* size needed for the crc block */
-static u32 *crcs;	/* allocated over suspend/resume */
-
-typedef u32 *(run_fn_t)(struct resource *ptr, u32 *arg);
-
-/* s3c2410_pm_run_res
- *
- * go thorugh the given resource list, and look for system ram
-*/
-
-static void s3c2410_pm_run_res(struct resource *ptr, run_fn_t fn, u32 *arg)
-{
-	while (ptr != NULL) {
-		if (ptr->child != NULL)
-			s3c2410_pm_run_res(ptr->child, fn, arg);
-
-		if ((ptr->flags & IORESOURCE_MEM) &&
-		    strcmp(ptr->name, "System RAM") == 0) {
-			DBG("Found system RAM at %08lx..%08lx\n",
-			    ptr->start, ptr->end);
-			arg = (fn)(ptr, arg);
-		}
-
-		ptr = ptr->sibling;
-	}
-}
-
-static void s3c2410_pm_run_sysram(run_fn_t fn, u32 *arg)
-{
-	s3c2410_pm_run_res(&iomem_resource, fn, arg);
-}
-
-static u32 *s3c2410_pm_countram(struct resource *res, u32 *val)
-{
-	u32 size = (u32)(res->end - res->start)+1;
-
-	size += CHECK_CHUNKSIZE-1;
-	size /= CHECK_CHUNKSIZE;
-
-	DBG("Area %08lx..%08lx, %d blocks\n", res->start, res->end, size);
-
-	*val += size * sizeof(u32);
-	return val;
-}
-
-/* s3c2410_pm_prepare_check
- *
- * prepare the necessary information for creating the CRCs. This
- * must be done before the final save, as it will require memory
- * allocating, and thus touching bits of the kernel we do not
- * know about.
-*/
-
-static void s3c2410_pm_check_prepare(void)
-{
-	crc_size = 0;
-
-	s3c2410_pm_run_sysram(s3c2410_pm_countram, &crc_size);
-
-	DBG("s3c2410_pm_prepare_check: %u checks needed\n", crc_size);
-
-	crcs = kmalloc(crc_size+4, GFP_KERNEL);
-	if (crcs == NULL)
-		printk(KERN_ERR "Cannot allocated CRC save area\n");
-}
-
-static u32 *s3c2410_pm_makecheck(struct resource *res, u32 *val)
-{
-	unsigned long addr, left;
-
-	for (addr = res->start; addr < res->end;
-	     addr += CHECK_CHUNKSIZE) {
-		left = res->end - addr;
-
-		if (left > CHECK_CHUNKSIZE)
-			left = CHECK_CHUNKSIZE;
-
-		*val = crc32_le(~0, phys_to_virt(addr), left);
-		val++;
-	}
-
-	return val;
-}
-
-/* s3c2410_pm_check_store
- *
- * compute the CRC values for the memory blocks before the final
- * sleep.
-*/
-
-static void s3c2410_pm_check_store(void)
-{
-	if (crcs != NULL)
-		s3c2410_pm_run_sysram(s3c2410_pm_makecheck, crcs);
-}
-
-/* in_region
- *
- * return TRUE if the area defined by ptr..ptr+size contatins the
- * what..what+whatsz
-*/
-
-static inline int in_region(void *ptr, int size, void *what, size_t whatsz)
-{
-	if ((what+whatsz) < ptr)
-		return 0;
-
-	if (what > (ptr+size))
-		return 0;
-
-	return 1;
-}
-
-static u32 *s3c2410_pm_runcheck(struct resource *res, u32 *val)
-{
-	void *save_at = phys_to_virt(s3c2410_sleep_save_phys);
-	unsigned long addr;
-	unsigned long left;
-	void *ptr;
-	u32 calc;
-
-	for (addr = res->start; addr < res->end;
-	     addr += CHECK_CHUNKSIZE) {
-		left = res->end - addr;
-
-		if (left > CHECK_CHUNKSIZE)
-			left = CHECK_CHUNKSIZE;
-
-		ptr = phys_to_virt(addr);
-
-		if (in_region(ptr, left, crcs, crc_size)) {
-			DBG("skipping %08lx, has crc block in\n", addr);
-			goto skip_check;
-		}
-
-		if (in_region(ptr, left, save_at, 32*4 )) {
-			DBG("skipping %08lx, has save block in\n", addr);
-			goto skip_check;
-		}
-
-		/* calculate and check the checksum */
-
-		calc = crc32_le(~0, ptr, left);
-		if (calc != *val) {
-			printk(KERN_ERR PFX "Restore CRC error at "
-			       "%08lx (%08x vs %08x)\n", addr, calc, *val);
-
-			DBG("Restore CRC error at %08lx (%08x vs %08x)\n",
-			    addr, calc, *val);
-		}
-
-	skip_check:
-		val++;
-	}
-
-	return val;
-}
-
-/* s3c2410_pm_check_restore
- *
- * check the CRCs after the restore event and free the memory used
- * to hold them
-*/
-
-static void s3c2410_pm_check_restore(void)
-{
-	if (crcs != NULL) {
-		s3c2410_pm_run_sysram(s3c2410_pm_runcheck, crcs);
-		kfree(crcs);
-		crcs = NULL;
-	}
-}
-
-#else
-
-#define s3c2410_pm_check_prepare() do { } while(0)
-#define s3c2410_pm_check_restore() do { } while(0)
-#define s3c2410_pm_check_store()   do { } while(0)
-#endif
-
-/* helper functions to save and restore register state */
-
-void s3c2410_pm_do_save(struct sleep_save *ptr, int count)
-{
-	for (; count > 0; count--, ptr++) {
-		ptr->val = __raw_readl(ptr->reg);
-		DBG("saved %p value %08lx\n", ptr->reg, ptr->val);
-	}
-}
-
-/* s3c2410_pm_do_restore
- *
- * restore the system from the given list of saved registers
- *
- * Note, we do not use DBG() in here, as the system may not have
- * restore the UARTs state yet
-*/
-
-void s3c2410_pm_do_restore(struct sleep_save *ptr, int count)
-{
-	for (; count > 0; count--, ptr++) {
-		printk(KERN_DEBUG "restore %p (restore %08lx, was %08x)\n",
-		       ptr->reg, ptr->val, __raw_readl(ptr->reg));
-
-		__raw_writel(ptr->val, ptr->reg);
-	}
-}
-
-/* s3c2410_pm_do_restore_core
- *
- * similar to s3c2410_pm_do_restore_core
- *
- * WARNING: Do not put any debug in here that may effect memory or use
- * peripherals, as things may be changing!
-*/
-
-static void s3c2410_pm_do_restore_core(struct sleep_save *ptr, int count)
-{
-	for (; count > 0; count--, ptr++) {
-		__raw_writel(ptr->val, ptr->reg);
-	}
-}
-
-/* s3c2410_pm_show_resume_irqs
- *
- * print any IRQs asserted at resume time (ie, we woke from)
-*/
-
-static void s3c2410_pm_show_resume_irqs(int start, unsigned long which,
-					unsigned long mask)
-{
-	int i;
-
-	which &= ~mask;
-
-	for (i = 0; i <= 31; i++) {
-		if ((which) & (1L<<i)) {
-			DBG("IRQ %d asserted at resume\n", start+i);
-		}
-	}
-}
-
-/* s3c2410_pm_check_resume_pin
+/* s3c_pm_check_resume_pin
  *
  * check to see if the pin is configured correctly for sleep mode, and
  * make any necessary adjustments if it is not
 */
 
-static void s3c2410_pm_check_resume_pin(unsigned int pin, unsigned int irqoffs)
+static void s3c_pm_check_resume_pin(unsigned int pin, unsigned int irqoffs)
 {
 	unsigned long irqstate;
 	unsigned long pinstate;
@@ -456,21 +101,21 @@
 
 	if (!irqstate) {
 		if (pinstate == S3C2410_GPIO_IRQ)
-			DBG("Leaving IRQ %d (pin %d) enabled\n", irq, pin);
+			S3C_PMDBG("Leaving IRQ %d (pin %d) enabled\n", irq, pin);
 	} else {
 		if (pinstate == S3C2410_GPIO_IRQ) {
-			DBG("Disabling IRQ %d (pin %d)\n", irq, pin);
+			S3C_PMDBG("Disabling IRQ %d (pin %d)\n", irq, pin);
 			s3c2410_gpio_cfgpin(pin, S3C2410_GPIO_INPUT);
 		}
 	}
 }
 
-/* s3c2410_pm_configure_extint
+/* s3c_pm_configure_extint
  *
  * configure all external interrupt pins
 */
 
-static void s3c2410_pm_configure_extint(void)
+void s3c_pm_configure_extint(void)
 {
 	int pin;
 
@@ -480,336 +125,24 @@
 	*/
 
 	for (pin = S3C2410_GPF0; pin <= S3C2410_GPF7; pin++) {
-		s3c2410_pm_check_resume_pin(pin, pin - S3C2410_GPF0);
+		s3c_pm_check_resume_pin(pin, pin - S3C2410_GPF0);
 	}
 
 	for (pin = S3C2410_GPG0; pin <= S3C2410_GPG7; pin++) {
-		s3c2410_pm_check_resume_pin(pin, (pin - S3C2410_GPG0)+8);
-	}
-}
-
-/* offsets for CON/DAT/UP registers */
-
-#define OFFS_CON	(S3C2410_GPACON - S3C2410_GPACON)
-#define OFFS_DAT	(S3C2410_GPADAT - S3C2410_GPACON)
-#define OFFS_UP		(S3C2410_GPBUP  - S3C2410_GPBCON)
-
-/* s3c2410_pm_save_gpios()
- *
- * Save the state of the GPIOs
- */
-
-static void s3c2410_pm_save_gpios(void)
-{
-	struct gpio_sleep *gps = gpio_save;
-	unsigned int gpio;
-
-	for (gpio = 0; gpio < ARRAY_SIZE(gpio_save); gpio++, gps++) {
-		void __iomem *base = gps->base;
-
-		gps->gpcon = __raw_readl(base + OFFS_CON);
-		gps->gpdat = __raw_readl(base + OFFS_DAT);
-
-		if (gpio > 0)
-			gps->gpup = __raw_readl(base + OFFS_UP);
-
-	}
-}
-
-/* Test whether the given masked+shifted bits of an GPIO configuration
- * are one of the SFN (special function) modes. */
-
-static inline int is_sfn(unsigned long con)
-{
-	return (con == 2 || con == 3);
-}
-
-/* Test if the given masked+shifted GPIO configuration is an input */
-
-static inline int is_in(unsigned long con)
-{
-	return con == 0;
-}
-
-/* Test if the given masked+shifted GPIO configuration is an output */
-
-static inline int is_out(unsigned long con)
-{
-	return con == 1;
-}
-
-/* s3c2410_pm_restore_gpio()
- *
- * Restore one of the GPIO banks that was saved during suspend. This is
- * not as simple as once thought, due to the possibility of glitches
- * from the order that the CON and DAT registers are set in.
- *
- * The three states the pin can be are {IN,OUT,SFN} which gives us 9
- * combinations of changes to check. Three of these, if the pin stays
- * in the same configuration can be discounted. This leaves us with
- * the following:
- *
- * { IN => OUT }  Change DAT first
- * { IN => SFN }  Change CON first
- * { OUT => SFN } Change CON first, so new data will not glitch
- * { OUT => IN }  Change CON first, so new data will not glitch
- * { SFN => IN }  Change CON first
- * { SFN => OUT } Change DAT first, so new data will not glitch [1]
- *
- * We do not currently deal with the UP registers as these control
- * weak resistors, so a small delay in change should not need to bring
- * these into the calculations.
- *
- * [1] this assumes that writing to a pin DAT whilst in SFN will set the
- *     state for when it is next output.
- */
-
-static void s3c2410_pm_restore_gpio(int index, struct gpio_sleep *gps)
-{
-	void __iomem *base = gps->base;
-	unsigned long gps_gpcon = gps->gpcon;
-	unsigned long gps_gpdat = gps->gpdat;
-	unsigned long old_gpcon;
-	unsigned long old_gpdat;
-	unsigned long old_gpup = 0x0;
-	unsigned long gpcon;
-	int nr;
-
-	old_gpcon = __raw_readl(base + OFFS_CON);
-	old_gpdat = __raw_readl(base + OFFS_DAT);
-
-	if (base == S3C2410_GPACON) {
-		/* GPACON only has one bit per control / data and no PULLUPs.
-		 * GPACON[x] = 0 => Output, 1 => SFN */
-
-		/* first set all SFN bits to SFN */
-
-		gpcon = old_gpcon | gps->gpcon;
-		__raw_writel(gpcon, base + OFFS_CON);
-
-		/* now set all the other bits */
-
-		__raw_writel(gps_gpdat, base + OFFS_DAT);
-		__raw_writel(gps_gpcon, base + OFFS_CON);
-	} else {
-		unsigned long old, new, mask;
-		unsigned long change_mask = 0x0;
-
-		old_gpup = __raw_readl(base + OFFS_UP);
-
-		/* Create a change_mask of all the items that need to have
-		 * their CON value changed before their DAT value, so that
-		 * we minimise the work between the two settings.
-		 */
-
-		for (nr = 0, mask = 0x03; nr < 32; nr += 2, mask <<= 2) {
-			old = (old_gpcon & mask) >> nr;
-			new = (gps_gpcon & mask) >> nr;
-
-			/* If there is no change, then skip */
-
-			if (old == new)
-				continue;
-
-			/* If both are special function, then skip */
-
-			if (is_sfn(old) && is_sfn(new))
-				continue;
-
-			/* Change is IN => OUT, do not change now */
-
-			if (is_in(old) && is_out(new))
-				continue;
-
-			/* Change is SFN => OUT, do not change now */
-
-			if (is_sfn(old) && is_out(new))
-				continue;
-
-			/* We should now be at the case of IN=>SFN,
-			 * OUT=>SFN, OUT=>IN, SFN=>IN. */
-
-			change_mask |= mask;
-		}
-
-		/* Write the new CON settings */
-
-		gpcon = old_gpcon & ~change_mask;
-		gpcon |= gps_gpcon & change_mask;
-
-		__raw_writel(gpcon, base + OFFS_CON);
-
-		/* Now change any items that require DAT,CON */
-
-		__raw_writel(gps_gpdat, base + OFFS_DAT);
-		__raw_writel(gps_gpcon, base + OFFS_CON);
-		__raw_writel(gps->gpup, base + OFFS_UP);
+		s3c_pm_check_resume_pin(pin, (pin - S3C2410_GPG0)+8);
 	}
-
-	DBG("GPIO[%d] CON %08lx => %08lx, DAT %08lx => %08lx\n",
-	    index, old_gpcon, gps_gpcon, old_gpdat, gps_gpdat);
 }
 
 
-/** s3c2410_pm_restore_gpios()
- *
- * Restore the state of the GPIOs
- */
-
-static void s3c2410_pm_restore_gpios(void)
+void s3c_pm_restore_core(void)
 {
-	struct gpio_sleep *gps = gpio_save;
-	int gpio;
-
-	for (gpio = 0; gpio < ARRAY_SIZE(gpio_save); gpio++, gps++) {
-		s3c2410_pm_restore_gpio(gpio, gps);
-	}
+	s3c_pm_do_restore_core(core_save, ARRAY_SIZE(core_save));
+	s3c_pm_do_restore(misc_save, ARRAY_SIZE(misc_save));
 }
 
-void (*pm_cpu_prep)(void);
-void (*pm_cpu_sleep)(void);
-
-#define any_allowed(mask, allow) (((mask) & (allow)) != (allow))
-
-/* s3c2410_pm_enter
- *
- * central control for sleep/resume process
-*/
-
-static int s3c2410_pm_enter(suspend_state_t state)
+void s3c_pm_save_core(void)
 {
-	unsigned long regs_save[16];
-
-	/* ensure the debug is initialised (if enabled) */
-
-	s3c2410_pm_debug_init();
-
-	DBG("s3c2410_pm_enter(%d)\n", state);
-
-	if (pm_cpu_prep == NULL || pm_cpu_sleep == NULL) {
-		printk(KERN_ERR PFX "error: no cpu sleep functions set\n");
-		return -EINVAL;
-	}
-
-	/* check if we have anything to wake-up with... bad things seem
-	 * to happen if you suspend with no wakeup (system will often
-	 * require a full power-cycle)
-	*/
-
-	if (!any_allowed(s3c_irqwake_intmask, s3c_irqwake_intallow) &&
-	    !any_allowed(s3c_irqwake_eintmask, s3c_irqwake_eintallow)) {
-		printk(KERN_ERR PFX "No sources enabled for wake-up!\n");
-		printk(KERN_ERR PFX "Aborting sleep\n");
-		return -EINVAL;
-	}
-
-	/* prepare check area if configured */
-
-	s3c2410_pm_check_prepare();
-
-	/* store the physical address of the register recovery block */
-
-	s3c2410_sleep_save_phys = virt_to_phys(regs_save);
-
-	DBG("s3c2410_sleep_save_phys=0x%08lx\n", s3c2410_sleep_save_phys);
-
-	/* save all necessary core registers not covered by the drivers */
-
-	s3c2410_pm_save_gpios();
-	s3c2410_pm_do_save(misc_save, ARRAY_SIZE(misc_save));
-	s3c2410_pm_do_save(core_save, ARRAY_SIZE(core_save));
-	s3c2410_pm_do_save(uart_save, ARRAY_SIZE(uart_save));
-
-	/* set the irq configuration for wake */
-
-	s3c2410_pm_configure_extint();
-
-	DBG("sleep: irq wakeup masks: %08lx,%08lx\n",
-	    s3c_irqwake_intmask, s3c_irqwake_eintmask);
-
-	__raw_writel(s3c_irqwake_intmask, S3C2410_INTMSK);
-	__raw_writel(s3c_irqwake_eintmask, S3C2410_EINTMASK);
-
-	/* ack any outstanding external interrupts before we go to sleep */
-
-	__raw_writel(__raw_readl(S3C2410_EINTPEND), S3C2410_EINTPEND);
-	__raw_writel(__raw_readl(S3C2410_INTPND), S3C2410_INTPND);
-	__raw_writel(__raw_readl(S3C2410_SRCPND), S3C2410_SRCPND);
-
-	/* call cpu specific preparation */
-
-	pm_cpu_prep();
-
-	/* flush cache back to ram */
-
-	flush_cache_all();
-
-	s3c2410_pm_check_store();
-
-	/* send the cpu to sleep... */
-
-	__raw_writel(0x00, S3C2410_CLKCON);  /* turn off clocks over sleep */
-
-	/* s3c2410_cpu_save will also act as our return point from when
-	 * we resume as it saves its own register state, so use the return
-	 * code to differentiate return from save and return from sleep */
-
-	if (s3c2410_cpu_save(regs_save) == 0) {
-		flush_cache_all();
-		pm_cpu_sleep();
-	}
-
-	/* restore the cpu state */
-
-	cpu_init();
-
-	/* restore the system state */
-
-	s3c2410_pm_do_restore_core(core_save, ARRAY_SIZE(core_save));
-	s3c2410_pm_do_restore(misc_save, ARRAY_SIZE(misc_save));
-	s3c2410_pm_do_restore(uart_save, ARRAY_SIZE(uart_save));
-	s3c2410_pm_restore_gpios();
-
-	s3c2410_pm_debug_init();
-
-	/* check what irq (if any) restored the system */
-
-	DBG("post sleep: IRQs 0x%08x, 0x%08x\n",
-	    __raw_readl(S3C2410_SRCPND),
-	    __raw_readl(S3C2410_EINTPEND));
-
-	s3c2410_pm_show_resume_irqs(IRQ_EINT0, __raw_readl(S3C2410_SRCPND),
-				    s3c_irqwake_intmask);
-
-	s3c2410_pm_show_resume_irqs(IRQ_EINT4-4, __raw_readl(S3C2410_EINTPEND),
-				    s3c_irqwake_eintmask);
-
-	DBG("post sleep, preparing to return\n");
-
-	s3c2410_pm_check_restore();
-
-	/* ok, let's return from sleep */
-
-	DBG("S3C2410 PM Resume (post-restore)\n");
-	return 0;
+	s3c_pm_do_save(misc_save, ARRAY_SIZE(misc_save));
+	s3c_pm_do_save(core_save, ARRAY_SIZE(core_save));
 }
 
-static struct platform_suspend_ops s3c2410_pm_ops = {
-	.enter		= s3c2410_pm_enter,
-	.valid		= suspend_valid_only_mem,
-};
-
-/* s3c2410_pm_init
- *
- * Attach the power management functions. This should be called
- * from the board specific initialisation if the board supports
- * it.
-*/
-
-int __init s3c2410_pm_init(void)
-{
-	printk("S3C2410 Power Management, (c) 2004 Simtec Electronics\n");
-
-	suspend_set_ops(&s3c2410_pm_ops);
-	return 0;
-}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/pm-simtec.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/pm-simtec.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/pm-simtec.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/pm-simtec.c	2009-05-10 22:27:59.000000000 +0200
@@ -61,7 +61,7 @@
 
 	__raw_writel(gstatus4, S3C2410_GSTATUS4);
 
-	return s3c2410_pm_init();
+	return s3c_pm_init();
 }
 
 arch_initcall(pm_simtec_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/pwm-clock.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/pwm-clock.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/pwm-clock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/pwm-clock.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,437 @@
+/* linux/arch/arm/plat-s3c24xx/pwm-clock.c
+ *
+ * Copyright (c) 2007 Simtec Electronics
+ * Copyright (c) 2007, 2008 Ben Dooks
+ *	Ben Dooks <ben-linux@fluff.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+*/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+
+#include <asm/plat-s3c24xx/clock.h>
+#include <asm/plat-s3c24xx/cpu.h>
+
+#include <asm/plat-s3c/regs-timer.h>
+
+/* Each of the timers 0 through 5 go through the following
+ * clock tree, with the inputs depending on the timers.
+ *
+ * pclk ---- [ prescaler 0 ] -+---> timer 0
+ *			      +---> timer 1
+ *
+ * pclk ---- [ prescaler 1 ] -+---> timer 2
+ *			      +---> timer 3
+ *			      \---> timer 4
+ *
+ * Which are fed into the timers as so:
+ *
+ * prescaled 0 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 0
+ * tclk 0 ------------------------------/
+ *
+ * prescaled 0 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 1
+ * tclk 0 ------------------------------/
+ *
+ *
+ * prescaled 1 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 2
+ * tclk 1 ------------------------------/
+ *
+ * prescaled 1 ---- [ div 2,4,8,16 ] ---\
+ *				       [mux] -> timer 3
+ * tclk 1 ------------------------------/
+ *
+ * prescaled 1 ---- [ div 2,4,8, 16 ] --\
+ *				       [mux] -> timer 4
+ * tclk 1 ------------------------------/
+ *
+ * Since the mux and the divider are tied together in the
+ * same register space, it is impossible to set the parent
+ * and the rate at the same time. To avoid this, we add an
+ * intermediate 'prescaled-and-divided' clock to select
+ * as the parent for the timer input clock called tdiv.
+ *
+ * prescaled clk --> pwm-tdiv ---\
+ *                             [ mux ] --> timer X
+ * tclk -------------------------/
+*/
+
+static unsigned long clk_pwm_scaler_getrate(struct clk *clk)
+{
+	unsigned long tcfg0 = __raw_readl(S3C2410_TCFG0);
+
+	if (clk->id == 1) {
+		tcfg0 &= S3C2410_TCFG_PRESCALER1_MASK;
+		tcfg0 >>= S3C2410_TCFG_PRESCALER1_SHIFT;
+	} else {
+		tcfg0 &= S3C2410_TCFG_PRESCALER0_MASK;
+	}
+
+	return clk_get_rate(clk->parent) / (tcfg0 + 1);
+}
+
+/* TODO - add set rate calls. */
+
+static struct clk clk_timer_scaler[] = {
+	[0]	= {
+		.name		= "pwm-scaler0",
+		.id		= -1,
+		.get_rate	= clk_pwm_scaler_getrate,
+	},
+	[1]	= {
+		.name		= "pwm-scaler1",
+		.id		= -1,
+		.get_rate	= clk_pwm_scaler_getrate,
+	},
+};
+
+static struct clk clk_timer_tclk[] = {
+	[0]	= {
+		.name		= "pwm-tclk0",
+		.id		= -1,
+	},
+	[1]	= {
+		.name		= "pwm-tclk1",
+		.id		= -1,
+	},
+};
+
+struct pwm_tdiv_clk {
+	struct clk	clk;
+	unsigned int	divisor;
+};
+
+static inline struct pwm_tdiv_clk *to_tdiv(struct clk *clk)
+{
+	return container_of(clk, struct pwm_tdiv_clk, clk);
+}
+
+static inline unsigned long tcfg_to_divisor(unsigned long tcfg1)
+{
+	return 1 << (1 + tcfg1);
+}
+
+static unsigned long clk_pwm_tdiv_get_rate(struct clk *clk)
+{
+	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned int divisor;
+
+	tcfg1 >>= S3C2410_TCFG1_SHIFT(clk->id);
+	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+
+	if (tcfg1 == S3C2410_TCFG1_MUX_TCLK)
+		divisor = to_tdiv(clk)->divisor;
+	else
+		divisor = tcfg_to_divisor(tcfg1);
+
+	return clk_get_rate(clk->parent) / divisor;
+}
+
+static unsigned long clk_pwm_tdiv_round_rate(struct clk *clk,
+					     unsigned long rate)
+{
+	unsigned long parent_rate;
+	unsigned long divisor;
+
+	parent_rate = clk_get_rate(clk->parent);
+	divisor = parent_rate / rate;
+
+	if (divisor <= 2)
+		divisor = 2;
+	else if (divisor <= 4)
+		divisor = 4;
+	else if (divisor <= 8)
+		divisor = 8;
+	else
+		divisor = 16;
+
+	return parent_rate / divisor;
+}
+
+static unsigned long clk_pwm_tdiv_bits(struct pwm_tdiv_clk *divclk)
+{
+	unsigned long bits;
+
+	switch (divclk->divisor) {
+	case 2:
+		bits = S3C2410_TCFG1_MUX_DIV2;
+		break;
+	case 4:
+		bits = S3C2410_TCFG1_MUX_DIV4;
+		break;
+	case 8:
+		bits = S3C2410_TCFG1_MUX_DIV8;
+		break;
+	case 16:
+	default:
+		bits = S3C2410_TCFG1_MUX_DIV16;
+		break;
+	}
+
+	return bits;
+}
+
+static void clk_pwm_tdiv_update(struct pwm_tdiv_clk *divclk)
+{
+	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long bits = clk_pwm_tdiv_bits(divclk);
+	unsigned long flags;
+	unsigned long shift =  S3C2410_TCFG1_SHIFT(divclk->clk.id);
+
+	local_irq_save(flags);
+
+	tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg1 &= ~(S3C2410_TCFG1_MUX_MASK << shift);
+	tcfg1 |= bits << shift;
+	__raw_writel(tcfg1, S3C2410_TCFG1);
+
+	local_irq_restore(flags);
+}
+
+static int clk_pwm_tdiv_set_rate(struct clk *clk, unsigned long rate)
+{
+	struct pwm_tdiv_clk *divclk = to_tdiv(clk);
+	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned long parent_rate = clk_get_rate(clk->parent);
+	unsigned long divisor;
+
+	tcfg1 >>= S3C2410_TCFG1_SHIFT(clk->id);
+	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+
+	rate = clk_round_rate(clk, rate);
+	divisor = parent_rate / rate;
+
+	if (divisor > 16)
+		return -EINVAL;
+
+	divclk->divisor = divisor;
+
+	/* Update the current MUX settings if we are currently
+	 * selected as the clock source for this clock. */
+
+	if (tcfg1 != S3C2410_TCFG1_MUX_TCLK)
+		clk_pwm_tdiv_update(divclk);
+
+	return 0;
+}
+
+static struct pwm_tdiv_clk clk_timer_tdiv[] = {
+	[0]	= {
+		.clk	= {
+			.name		= "pwm-tdiv",
+			.parent		= &clk_timer_scaler[0],
+			.get_rate	= clk_pwm_tdiv_get_rate,
+			.set_rate	= clk_pwm_tdiv_set_rate,
+			.round_rate	= clk_pwm_tdiv_round_rate,
+		},
+	},
+	[1]	= {
+		.clk	= {
+			.name		= "pwm-tdiv",
+			.parent		= &clk_timer_scaler[0],
+			.get_rate	= clk_pwm_tdiv_get_rate,
+			.set_rate	= clk_pwm_tdiv_set_rate,
+			.round_rate	= clk_pwm_tdiv_round_rate,
+		}
+	},
+	[2]	= {
+		.clk	= {
+			.name		= "pwm-tdiv",
+			.parent		= &clk_timer_scaler[1],
+			.get_rate	= clk_pwm_tdiv_get_rate,
+			.set_rate	= clk_pwm_tdiv_set_rate,
+			.round_rate	= clk_pwm_tdiv_round_rate,
+		},
+	},
+	[3]	= {
+		.clk	= {
+			.name		= "pwm-tdiv",
+			.parent		= &clk_timer_scaler[1],
+			.get_rate	= clk_pwm_tdiv_get_rate,
+			.set_rate	= clk_pwm_tdiv_set_rate,
+			.round_rate	= clk_pwm_tdiv_round_rate,
+		},
+	},
+	[4]	= {
+		.clk	= {
+			.name		= "pwm-tdiv",
+			.parent		= &clk_timer_scaler[1],
+			.get_rate	= clk_pwm_tdiv_get_rate,
+			.set_rate	= clk_pwm_tdiv_set_rate,
+			.round_rate	= clk_pwm_tdiv_round_rate,
+		},
+	},
+};
+
+static int __init clk_pwm_tdiv_register(unsigned int id)
+{
+	struct pwm_tdiv_clk *divclk = &clk_timer_tdiv[id];
+	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+
+	tcfg1 >>= S3C2410_TCFG1_SHIFT(id);
+	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+
+	divclk->clk.id = id;
+	divclk->divisor = tcfg_to_divisor(tcfg1);
+
+	return s3c24xx_register_clock(&divclk->clk);
+}
+
+static inline struct clk *s3c24xx_pwmclk_tclk(unsigned int id)
+{
+	return (id >= 2) ? &clk_timer_tclk[1] : &clk_timer_tclk[0];
+}
+
+static inline struct clk *s3c24xx_pwmclk_tdiv(unsigned int id)
+{
+	return &clk_timer_tdiv[id].clk;
+}
+
+static int clk_pwm_tin_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned int id = clk->id;
+	unsigned long tcfg1;
+	unsigned long flags;
+	unsigned long bits;
+	unsigned long shift = S3C2410_TCFG1_SHIFT(id);
+
+	if (parent == s3c24xx_pwmclk_tclk(id))
+		bits = S3C2410_TCFG1_MUX_TCLK << shift;
+	else if (parent == s3c24xx_pwmclk_tdiv(id))
+		bits = clk_pwm_tdiv_bits(to_tdiv(parent)) << shift;
+	else
+		return -EINVAL;
+
+	clk->parent = parent;
+
+	local_irq_save(flags);
+
+	tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg1 &= ~(S3C2410_TCFG1_MUX_MASK << shift);
+	__raw_writel(tcfg1 | bits, S3C2410_TCFG1);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static struct clk clk_tin[] = {
+	[0]	= {
+		.name		= "pwm-tin",
+		.id		= 0,
+		.set_parent	= clk_pwm_tin_set_parent,
+	},
+	[1]	= {
+		.name		= "pwm-tin",
+		.id		= 1,
+		.set_parent	= clk_pwm_tin_set_parent,
+	},
+	[2]	= {
+		.name		= "pwm-tin",
+		.id		= 2,
+		.set_parent	= clk_pwm_tin_set_parent,
+	},
+	[3]	= {
+		.name		= "pwm-tin",
+		.id		= 3,
+		.set_parent	= clk_pwm_tin_set_parent,
+	},
+	[4]	= {
+		.name		= "pwm-tin",
+		.id		= 4,
+		.set_parent	= clk_pwm_tin_set_parent,
+	},
+};
+
+static __init int clk_pwm_tin_register(struct clk *pwm)
+{
+	unsigned long tcfg1 = __raw_readl(S3C2410_TCFG1);
+	unsigned int id = pwm->id;
+
+	struct clk *parent;
+	int ret;
+
+	ret = s3c24xx_register_clock(pwm);
+	if (ret < 0)
+		return ret;
+
+	tcfg1 >>= S3C2410_TCFG1_SHIFT(id);
+	tcfg1 &= S3C2410_TCFG1_MUX_MASK;
+
+	if (tcfg1 == S3C2410_TCFG1_MUX_TCLK)
+		parent = s3c24xx_pwmclk_tclk(id);
+	else
+		parent = s3c24xx_pwmclk_tdiv(id);
+
+	return clk_set_parent(pwm, parent);
+}
+
+static __init int s3c24xx_pwmclk_init(void)
+{
+	struct clk *clk_timers;
+	unsigned int clk;
+	int ret;
+
+	clk_timers = clk_get(NULL, "timers");
+	if (IS_ERR(clk_timers)) {
+		printk(KERN_ERR "%s: no parent clock\n", __func__);
+		return -EINVAL;
+	}
+
+	for (clk = 0; clk < ARRAY_SIZE(clk_timer_scaler); clk++) {
+		clk_timer_scaler[clk].parent = clk_timers;
+		ret = s3c24xx_register_clock(&clk_timer_scaler[clk]);
+		if (ret < 0) {
+			printk(KERN_ERR "error adding pwm scaler%d clock\n", clk);
+			goto err;
+		}
+	}
+
+	for (clk = 0; clk < ARRAY_SIZE(clk_timer_tclk); clk++) {
+		ret = s3c24xx_register_clock(&clk_timer_tclk[clk]);
+		if (ret < 0) {
+			printk(KERN_ERR "error adding pww tclk%d\n", clk);
+			goto err;
+		}
+	}
+
+	for (clk = 0; clk < ARRAY_SIZE(clk_timer_tdiv); clk++) {
+		ret = clk_pwm_tdiv_register(clk);
+		if (ret < 0) {
+			printk(KERN_ERR "error adding pwm%d tdiv clock\n", clk);
+			goto err;
+		}
+	}
+
+	for (clk = 0; clk < ARRAY_SIZE(clk_tin); clk++) {
+		ret = clk_pwm_tin_register(&clk_tin[clk]);
+		if (ret < 0) {
+			printk(KERN_ERR "error adding pwm%d tin clock\n", clk);
+			goto err;
+		}
+	}
+
+	return 0;
+
+ err:
+	return ret;
+}
+
+arch_initcall(s3c24xx_pwmclk_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/s3c244x.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/s3c244x.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/s3c244x.c	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/s3c244x.c	2009-05-10 22:27:59.000000000 +0200
@@ -59,6 +59,8 @@
 	s3c24xx_init_uartdevs("s3c2440-uart", s3c2410_uart_resources, cfg, no);
 }
 
+extern struct platform_device s3c_device_ts;
+
 void __init s3c244x_map_io(void)
 {
 	/* register our io-tables */
@@ -70,6 +72,7 @@
 	s3c_device_sdi.name  = "s3c2440-sdi";
 	s3c_device_i2c0.name  = "s3c2440-i2c";
 	s3c_device_nand.name = "s3c2440-nand";
+	s3c_device_ts.name = "s3c2440-ts";
 	s3c_device_usbgadget.name = "s3c2440-usbgadget";
 }
 
@@ -145,13 +148,13 @@
 
 static int s3c244x_suspend(struct sys_device *dev, pm_message_t state)
 {
-	s3c2410_pm_do_save(s3c244x_sleep, ARRAY_SIZE(s3c244x_sleep));
+	s3c_pm_do_save(s3c244x_sleep, ARRAY_SIZE(s3c244x_sleep));
 	return 0;
 }
 
 static int s3c244x_resume(struct sys_device *dev)
 {
-	s3c2410_pm_do_restore(s3c244x_sleep, ARRAY_SIZE(s3c244x_sleep));
+	s3c_pm_do_restore(s3c244x_sleep, ARRAY_SIZE(s3c244x_sleep));
 	return 0;
 }
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/sleep.S linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/sleep.S
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/sleep.S	2009-05-10 22:05:03.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/sleep.S	2009-05-10 22:27:59.000000000 +0200
@@ -41,7 +41,7 @@
 
 	.text
 
-	/* s3c2410_cpu_save
+	/* s3c_cpu_save
 	 *
 	 * save enough of the CPU state to allow us to re-start
 	 * pm.c code. as we store items like the sp/lr, we will
@@ -59,7 +59,7 @@
 	 *	     1 => resumed from sleep
 	*/
 
-ENTRY(s3c2410_cpu_save)
+ENTRY(s3c_cpu_save)
 	stmfd	sp!, { r4 - r12, lr }
 
 	@@ store co-processor registers
@@ -84,7 +84,7 @@
 	.ltorg
 
 	@@ the next bits sit in the .data segment, even though they
-	@@ happen to be code... the s3c2410_sleep_save_phys needs to be
+	@@ happen to be code... the s3c_sleep_save_phys needs to be
 	@@ accessed by the resume code before it can restore the MMU.
 	@@ This means that the variable has to be close enough for the
 	@@ code to read it... since the .text segment needs to be RO,
@@ -92,19 +92,19 @@
 
 	.data
 
-	.global	s3c2410_sleep_save_phys
-s3c2410_sleep_save_phys:
+	.global	s3c_sleep_save_phys
+s3c_sleep_save_phys:
 	.word	0
 
 
 	/* sleep magic, to allow the bootloader to check for an valid
 	 * image to resume to. Must be the first word before the
-	 * s3c2410_cpu_resume entry.
+	 * s3c_cpu_resume entry.
 	*/
 
 	.word	0x2bedf00d
 
-	/* s3c2410_cpu_resume
+	/* s3c_cpu_resume
 	 *
 	 * resume code entry for bootloader to call
 	 *
@@ -113,7 +113,7 @@
 	 * must not write to the code segment (code is read-only)
 	*/
 
-ENTRY(s3c2410_cpu_resume)
+ENTRY(s3c_cpu_resume)
 	mov	r0, #PSR_I_BIT | PSR_F_BIT | SVC_MODE
 	msr	cpsr_c, r0
 
@@ -145,7 +145,7 @@
 	mcr	p15, 0, r1, c8, c7, 0		@@ invalidate I & D TLBs
 	mcr	p15, 0, r1, c7, c7, 0		@@ invalidate I & D caches
 
-	ldr	r0, s3c2410_sleep_save_phys	@ address of restore block
+	ldr	r0, s3c_sleep_save_phys		@ address of restore block
 	ldmia	r0, { r4 - r13 }
 
 	mcr	p15, 0, r4, c13, c0, 0		@ PID
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/time.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/time.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c24xx/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c24xx/time.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,480 @@
+/* linux/arch/arm/plat-s3c24xx/time.c
+ *
+ * Copyright (C) 2003-2005 Simtec Electronics
+ *	Ben Dooks, <ben@simtec.co.uk>
+ *
+ * dyn_tick support by Andrzej Zaborowski based on omap_dyn_tick_timer.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+
+#include <asm/system.h>
+#include <asm/leds.h>
+#include <asm/mach-types.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/map.h>
+#include <asm/plat-s3c/regs-timer.h>
+#include <mach/regs-irq.h>
+#include <asm/mach/time.h>
+
+#include <asm/plat-s3c24xx/clock.h>
+#include <asm/plat-s3c24xx/cpu.h>
+
+static unsigned long timer_startval;
+static unsigned long timer_usec_ticks;
+static struct work_struct resume_work;
+
+unsigned long pclk;
+struct clk *clk;
+
+#define TIMER_USEC_SHIFT 16
+
+/* we use the shifted arithmetic to work out the ratio of timer ticks
+ * to usecs, as often the peripheral clock is not a nice even multiple
+ * of 1MHz.
+ *
+ * shift of 14 and 15 are too low for the 12MHz, 16 seems to be ok
+ * for the current HZ value of 200 without producing overflows.
+ *
+ * Original patch by Dimitry Andric, updated by Ben Dooks
+*/
+
+
+/* timer_mask_usec_ticks
+ *
+ * given a clock and divisor, make the value to pass into timer_ticks_to_usec
+ * to scale the ticks into usecs
+*/
+
+static inline unsigned long
+timer_mask_usec_ticks(unsigned long scaler, unsigned long pclk)
+{
+	unsigned long den = pclk / 1000;
+
+	return ((1000 << TIMER_USEC_SHIFT) * scaler + (den >> 1)) / den;
+}
+
+/* timer_ticks_to_usec
+ *
+ * convert timer ticks to usec.
+*/
+
+static inline unsigned long timer_ticks_to_usec(unsigned long ticks)
+{
+	unsigned long res;
+
+	res = ticks * timer_usec_ticks;
+	res += 1 << (TIMER_USEC_SHIFT - 4);	/* round up slightly */
+
+	return res >> TIMER_USEC_SHIFT;
+}
+
+/***
+ * Returns microsecond  since last clock interrupt.  Note that interrupts
+ * will have been disabled by do_gettimeoffset()
+ * IRQs are disabled before entering here from do_gettimeofday()
+ */
+
+#define SRCPND_TIMER4 (1<<(IRQ_TIMER4 - IRQ_EINT0))
+
+unsigned long s3c2410_gettimeoffset (void)
+{
+	unsigned long tdone;
+	unsigned long irqpend;
+	unsigned long tval;
+
+	/* work out how many ticks have gone since last timer interrupt */
+
+        tval =  __raw_readl(S3C2410_TCNTO(4));
+	tdone = timer_startval - tval;
+
+	/* check to see if there is an interrupt pending */
+
+	irqpend = __raw_readl(S3C2410_SRCPND);
+	if (irqpend & SRCPND_TIMER4) {
+		/* re-read the timer, and try and fix up for the missed
+		 * interrupt. Note, the interrupt may go off before the
+		 * timer has re-loaded from wrapping.
+		 */
+
+		tval =  __raw_readl(S3C2410_TCNTO(4));
+		tdone = timer_startval - tval;
+
+		if (tval != 0)
+			tdone += timer_startval;
+	}
+
+	return timer_ticks_to_usec(tdone);
+}
+
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t
+s3c2410_timer_interrupt(int irq, void *dev_id)
+{
+	timer_tick();
+	return IRQ_HANDLED;
+}
+
+static struct irqaction s3c2410_timer_irq = {
+	.name		= "S3C2410 Timer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= s3c2410_timer_interrupt,
+};
+
+#define use_tclk1_12() ( \
+	machine_is_bast()	|| \
+	machine_is_vr1000()	|| \
+	machine_is_anubis()	|| \
+	machine_is_osiris() )
+
+/*
+ * Set up timer interrupt, and return the current time in seconds.
+ *
+ * Currently we only use timer4, as it is the only timer which has no
+ * other function that can be exploited externally
+ */
+static void s3c2410_timer_setup (void)
+{
+	unsigned long tcon;
+	unsigned long tcnt;
+	unsigned long tcfg1;
+	unsigned long tcfg0;
+
+	tcnt = 0xffff;  /* default value for tcnt */
+
+	/* read the current timer configuration bits */
+
+	tcon = __raw_readl(S3C2410_TCON);
+	tcfg1 = __raw_readl(S3C2410_TCFG1);
+	tcfg0 = __raw_readl(S3C2410_TCFG0);
+
+	/* configure the system for whichever machine is in use */
+
+	if (use_tclk1_12()) {
+		/* timer is at 12MHz, scaler is 1 */
+		timer_usec_ticks = timer_mask_usec_ticks(1, 12000000);
+		tcnt = 12000000 / HZ;
+
+		tcfg1 &= ~S3C2410_TCFG1_MUX4_MASK;
+		tcfg1 |= S3C2410_TCFG1_MUX4_TCLK1;
+	} else {
+		/* since values around 50 to
+		 * 70MHz are not values we can directly generate the timer
+		 * value from, we need to pre-scale and divide before using it.
+		 *
+		 * for instance, using 50.7MHz and dividing by 6 gives 8.45MHz
+		 * (8.45 ticks per usec)
+		 */
+
+		/* configure clock tick */
+		timer_usec_ticks = timer_mask_usec_ticks(6, pclk);
+		printk("timer_usec_ticks = %lu\n", timer_usec_ticks);
+
+		tcfg1 &= ~S3C2410_TCFG1_MUX4_MASK;
+		tcfg1 |= S3C2410_TCFG1_MUX4_DIV2;
+
+		tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
+		tcfg0 |= ((6 - 1) / 2) << S3C2410_TCFG_PRESCALER1_SHIFT;
+
+		tcnt = (pclk / 6) / HZ;
+	}
+
+	/* timers reload after counting zero, so reduce the count by 1 */
+
+	tcnt--;
+
+	printk("timer tcon=%08lx, tcnt %04lx, tcfg %08lx,%08lx, usec %08lx\n",
+	       tcon, tcnt, tcfg0, tcfg1, timer_usec_ticks);
+
+	/* check to see if timer is within 16bit range... */
+	if (tcnt > 0xffff) {
+		panic("setup_timer: HZ is too small, cannot configure timer!");
+		return;
+	}
+
+	__raw_writel(tcfg1, S3C2410_TCFG1);
+	__raw_writel(tcfg0, S3C2410_TCFG0);
+
+	timer_startval = tcnt;
+	__raw_writel(tcnt, S3C2410_TCNTB(4));
+
+	/* ensure timer is stopped... */
+
+	tcon &= ~(7<<20);
+	tcon |= S3C2410_TCON_T4RELOAD;
+	tcon |= S3C2410_TCON_T4MANUALUPD;
+
+	__raw_writel(tcon, S3C2410_TCON);
+	__raw_writel(tcnt, S3C2410_TCNTB(4));
+	__raw_writel(tcnt, S3C2410_TCMPB(4));
+
+	/* start the timer running */
+	tcon |= S3C2410_TCON_T4START;
+	tcon &= ~S3C2410_TCON_T4MANUALUPD;
+	__raw_writel(tcon, S3C2410_TCON);
+
+	__raw_writel(__raw_readl(S3C2410_INTMSK) & (~(1UL << 14)),
+		     S3C2410_INTMSK);
+
+}
+
+struct sys_timer s3c24xx_timer;
+static void timer_resume_work(struct work_struct *work)
+{
+	clk_enable(clk);
+
+#ifdef CONFIG_NO_IDLE_HZ
+	if (s3c24xx_timer.dyn_tick->state & DYN_TICK_ENABLED)
+		s3c24xx_timer.dyn_tick->enable();
+	else
+#endif
+		s3c2410_timer_setup();
+}
+
+static void __init s3c2410_timer_init (void)
+{
+	if (!use_tclk1_12()) {
+		/* for the h1940 (and others), we use the pclk from the core
+		 * to generate the timer values.
+		 */
+
+		/* this is used as default if no other timer can be found */
+		clk = clk_get(NULL, "timers");
+		if (IS_ERR(clk))
+			panic("failed to get clock for system timer");
+
+		clk_enable(clk);
+
+		pclk = clk_get_rate(clk);
+		printk("pclk = %lu\n", pclk);
+	}
+
+	INIT_WORK(&resume_work, timer_resume_work);
+	s3c2410_timer_setup();
+	setup_irq(IRQ_TIMER4, &s3c2410_timer_irq);
+}
+
+static void s3c2410_timer_resume_work(struct work_struct *work)
+{
+	s3c2410_timer_setup();
+}
+
+static void s3c2410_timer_resume(void)
+{
+	static DECLARE_WORK(work, s3c2410_timer_resume_work);
+	int res;
+
+	res = schedule_work(&work);
+	if (!res)
+		printk(KERN_ERR
+		    "s3c2410_timer_resume_work already queued ???\n");
+}
+
+#ifdef CONFIG_NO_IDLE_HZ
+/*
+ * We'll set a constant prescaler so we don't have to bother setting it
+ * when reprogramming and so that we avoid costly divisions.
+ *
+ * (2 * HZ) << INPUT_FREQ_SHIFT is the desired frequency after prescaler.
+ * At HZ == 200, HZ * 1024 should work for PCLKs of up to ~53.5 MHz.
+ */
+#define INPUT_FREQ_SHIFT	9
+
+static int ticks_last;
+static int ticks_left;
+static uint32_t tcnto_last;
+
+static inline int s3c24xx_timer_read(void)
+{
+	uint32_t tcnto = __raw_readl(S3C2410_TCNTO(4));
+
+	/*
+	 * WARNING: sometimes we get called before TCNTB has been
+	 * loaded into the counter and TCNTO then returns its previous
+	 * value and kill us, so don't do anything before counter is
+	 * reloaded.
+	 */
+	if (unlikely(tcnto == tcnto_last))
+		return ticks_last;
+
+	tcnto_last = -1;
+	return tcnto <<
+		((__raw_readl(S3C2410_TCFG1) >> S3C2410_TCFG1_MUX4_SHIFT) & 3);
+}
+
+static inline void s3c24xx_timer_program(int ticks)
+{
+	uint32_t tcon = __raw_readl(S3C2410_TCON) & ~(7 << 20);
+	uint32_t tcfg1 = __raw_readl(S3C2410_TCFG1) & ~S3C2410_TCFG1_MUX4_MASK;
+
+	/* Just make sure the timer is stopped.  */
+	__raw_writel(tcon, S3C2410_TCON);
+
+	/* TODO: add likely()ies / unlikely()ies */
+	if (ticks >> 18) {
+		ticks_last = min(ticks, 0xffff << 3);
+		ticks_left = ticks - ticks_last;
+		__raw_writel(tcfg1 | S3C2410_TCFG1_MUX4_DIV16, S3C2410_TCFG1);
+		__raw_writel(ticks_last >> 3, S3C2410_TCNTB(4));
+	} else if (ticks >> 17) {
+		ticks_last = ticks;
+		ticks_left = 0;
+		__raw_writel(tcfg1 | S3C2410_TCFG1_MUX4_DIV8, S3C2410_TCFG1);
+		__raw_writel(ticks_last >> 2, S3C2410_TCNTB(4));
+	} else if (ticks >> 16) {
+		ticks_last = ticks;
+		ticks_left = 0;
+		__raw_writel(tcfg1 | S3C2410_TCFG1_MUX4_DIV4, S3C2410_TCFG1);
+		__raw_writel(ticks_last >> 1, S3C2410_TCNTB(4));
+	} else {
+		ticks_last = ticks;
+		ticks_left = 0;
+		__raw_writel(tcfg1 | S3C2410_TCFG1_MUX4_DIV2, S3C2410_TCFG1);
+		__raw_writel(ticks_last >> 0, S3C2410_TCNTB(4));
+	}
+
+	tcnto_last = __raw_readl(S3C2410_TCNTO(4));
+	__raw_writel(tcon | S3C2410_TCON_T4MANUALUPD,
+			S3C2410_TCON);
+	__raw_writel(tcon | S3C2410_TCON_T4START,
+			S3C2410_TCON);
+}
+
+/*
+ * If we have already waited all the time we were supposed to wait,
+ * kick the timer, setting the longest allowed timeout value just
+ * for time-keeping.
+ */
+static inline void s3c24xx_timer_program_idle(void)
+{
+	s3c24xx_timer_program(0xffff << 3);
+}
+
+static inline void s3c24xx_timer_update(int restart)
+{
+	int ticks_cur = s3c24xx_timer_read();
+	int jiffies_elapsed = (ticks_last - ticks_cur) >> INPUT_FREQ_SHIFT;
+	int subjiffy = ticks_last - (jiffies_elapsed << INPUT_FREQ_SHIFT);
+
+	if (restart) {
+		if (ticks_left >= (1 << INPUT_FREQ_SHIFT))
+			s3c24xx_timer_program(ticks_left);
+		else
+			s3c24xx_timer_program_idle();
+		ticks_last += subjiffy;
+	} else
+		ticks_last = subjiffy;
+
+	while (jiffies_elapsed --)
+		timer_tick();
+}
+
+/* Called when the timer expires.  */
+static irqreturn_t s3c24xx_timer_handler(int irq, void *dev_id)
+{
+	tcnto_last = -1;
+	s3c24xx_timer_update(1);
+
+	return IRQ_HANDLED;
+}
+
+/* Called to update jiffies with time elapsed.  */
+static irqreturn_t s3c24xx_timer_handler_dyn_tick(int irq, void *dev_id)
+{
+	s3c24xx_timer_update(0);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Programs the next timer interrupt needed.  Called when dynamic tick is
+ * enabled, and to reprogram the ticks to skip from pm_idle.  The CPU goes
+ * to sleep directly after this.
+ */
+static void s3c24xx_timer_reprogram_dyn_tick(unsigned long next_jiffies)
+{
+	int subjiffy_left = ticks_last - s3c24xx_timer_read();
+
+	s3c24xx_timer_program(max((int) next_jiffies, 1) << INPUT_FREQ_SHIFT);
+	ticks_last += subjiffy_left;
+}
+
+static unsigned long s3c24xx_timer_offset_dyn_tick(void)
+{
+	/* TODO */
+	return 0;
+}
+
+static int s3c24xx_timer_enable_dyn_tick(void)
+{
+	/* Set our constant prescaler.  */
+	uint32_t tcfg0 = __raw_readl(S3C2410_TCFG0);
+	int prescaler =
+		max(min(256, (int) pclk / (HZ << (INPUT_FREQ_SHIFT + 1))), 1);
+
+	tcfg0 &= ~S3C2410_TCFG_PRESCALER1_MASK;
+	tcfg0 |= (prescaler - 1) << S3C2410_TCFG_PRESCALER1_SHIFT;
+	__raw_writel(tcfg0, S3C2410_TCFG0);
+
+	/* Override handlers.  */
+	s3c2410_timer_irq.handler = s3c24xx_timer_handler;
+	s3c24xx_timer.offset = s3c24xx_timer_offset_dyn_tick;
+
+	printk(KERN_INFO "dyn_tick enabled on s3c24xx timer 4, "
+			"%li Hz pclk with prescaler %i\n", pclk, prescaler);
+
+	s3c24xx_timer_program_idle();
+
+	return 0;
+}
+
+static int s3c24xx_timer_disable_dyn_tick(void)
+{
+	s3c2410_timer_irq.handler = s3c2410_timer_interrupt;
+	s3c24xx_timer.offset = s3c2410_gettimeoffset;
+	s3c2410_timer_setup();
+
+	return 0;
+}
+
+static struct dyn_tick_timer s3c24xx_dyn_tick_timer = {
+	.enable		= s3c24xx_timer_enable_dyn_tick,
+	.disable	= s3c24xx_timer_disable_dyn_tick,
+	.reprogram	= s3c24xx_timer_reprogram_dyn_tick,
+	.handler	= s3c24xx_timer_handler_dyn_tick,
+};
+#endif	/* CONFIG_NO_IDLE_HZ */
+
+struct sys_timer s3c24xx_timer = {
+	.init		= s3c2410_timer_init,
+	.offset		= s3c2410_gettimeoffset,
+	.resume		= s3c2410_timer_resume,
+#ifdef CONFIG_NO_IDLE_HZ
+	.dyn_tick	= &s3c24xx_dyn_tick_timer,
+#endif
+};
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/clock.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/clock.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/clock.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/clock.c	2009-05-10 22:27:59.000000000 +0200
@@ -27,6 +27,12 @@
 #include <plat/devs.h>
 #include <plat/clock.h>
 
+struct clk clk_h2 = {
+	.name		= "hclk2",
+	.id		= -1,
+	.rate		= 0,
+};
+
 struct clk clk_27m = {
 	.name		= "clk_27m",
 	.id		= -1,
@@ -83,7 +89,7 @@
 	return s3c64xx_gate(S3C_PCLK_GATE, clk, enable);
 }
 
-static int s3c64xx_hclk_ctrl(struct clk *clk, int enable)
+int s3c64xx_hclk_ctrl(struct clk *clk, int enable)
 {
 	return s3c64xx_gate(S3C_HCLK_GATE, clk, enable);
 }
@@ -152,6 +158,30 @@
 		.parent		= &clk_48m,
 		.enable		= s3c64xx_sclk_ctrl,
 		.ctrlbit	= S3C_CLKCON_SCLK_MMC2_48,
+	}, {
+		.name		= "dma0",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_DMA0,
+	}, {
+		.name		= "dma1",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_DMA1,
+	}, {
+		.name		= "dma2",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_SDMA0,
+	}, {
+		.name		= "dma3",
+		.id		= -1,
+		.parent		= &clk_h,
+		.enable		= s3c64xx_hclk_ctrl,
+		.ctrlbit	= S3C_CLKCON_HCLK_SDMA1,
 	},
 };
 
@@ -246,6 +276,7 @@
 	&clk_epll,
 	&clk_27m,
 	&clk_48m,
+	&clk_h2,
 };
 
 void s3c64xx_register_clocks(void)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/cpu.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/cpu.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/cpu.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/cpu.c	2009-05-10 22:27:59.000000000 +0200
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
+#include <linux/sysdev.h>
 #include <linux/serial_core.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
@@ -96,9 +97,34 @@
 		.pfn		= __phys_to_pfn(S3C64XX_PA_GPIO),
 		.length		= SZ_4K,
 		.type		= MT_DEVICE,
-	},
+	}, {
+		.virtual	= (unsigned long)S3C64XX_VA_MODEM,
+		.pfn		= __phys_to_pfn(S3C64XX_PA_MODEM),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual 	= (unsigned long)S3C_VA_TZIC0,
+		.pfn		= __phys_to_pfn(S3C64XX_PA_TZIC0),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= (unsigned long)S3C_VA_TZIC1,
+		.pfn		= __phys_to_pfn(S3C64XX_PA_TZIC1),
+		.length		= SZ_4K,
+		.type		= MT_DEVICE,
+	}
 };
 
+
+struct sysdev_class s3c64xx_sysclass = {
+	.name	= "s3c64xx-core",
+};
+
+static struct sys_device s3c64xx_sysdev = {
+	.cls	= &s3c64xx_sysclass,
+};
+
+
 /* read cpu identification code */
 
 void __init s3c64xx_init_io(struct map_desc *mach_desc, int size)
@@ -112,3 +138,11 @@
 	idcode = __raw_readl(S3C_VA_SYS + 0x118);
 	s3c_init_cpu(idcode, cpu_ids, ARRAY_SIZE(cpu_ids));
 }
+
+static __init int s3c64xx_sysdev_init(void)
+{
+	sysdev_class_register(&s3c64xx_sysclass);
+	return sysdev_register(&s3c64xx_sysdev);
+}
+
+core_initcall(s3c64xx_sysdev_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/cpufreq.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/cpufreq.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/cpufreq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/cpufreq.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,225 @@
+/* linux/arch/arm/plat-s3c64xx/cpufreq.c
+ *
+ * Copyright 2009 Wolfson Microelectronics plc
+ *
+ * S3C64XX CPUfreq Support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/regulator/consumer.h>
+
+#include <mach/cpu.h>
+
+static struct clk *armclk;
+static struct regulator *vddarm;
+
+struct s3c64xx_dvfs {
+	unsigned int vddarm_min;
+	unsigned int vddarm_max;
+};
+
+static struct s3c64xx_dvfs s3c6410_dvfs_table[] = {
+	[0] = { 1000000, 1000000 },
+	[1] = { 1000000, 1050000 },
+	[2] = { 1050000, 1100000 },
+	[3] = { 1050000, 1150000 },
+	[4] = { 1250000, 1350000 },
+};
+
+static struct cpufreq_frequency_table s3c6410_freq_table[] = {
+	{ 0,  66000 },
+	{ 0, 133000 },
+	{ 1, 222000 },
+	{ 1, 266000 },
+	{ 2, 333000 },
+	{ 2, 400000 },
+	{ 3, 532000 },
+	{ 3, 533000 },
+	{ 4, 667000 },
+	{ 0, CPUFREQ_TABLE_END },
+};
+
+/* Data tables for current CPU and maximum index into it */
+static struct cpufreq_frequency_table *s3c64xx_freq_table;
+static struct s3c64xx_dvfs *s3c64xx_dvfs_table;
+
+static int s3c64xx_cpufreq_verify_speed(struct cpufreq_policy *policy)
+{
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	return cpufreq_frequency_table_verify(policy, s3c64xx_freq_table);
+}
+
+static unsigned int s3c64xx_cpufreq_get_speed(unsigned int cpu)
+{
+	if (cpu != 0)
+		return 0;
+
+	return clk_get_rate(armclk) / 1000;
+}
+
+static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,
+				      unsigned int target_freq,
+				      unsigned int relation)
+{
+	int ret = 0;
+	unsigned int i;
+	struct cpufreq_freqs freqs;
+	struct s3c64xx_dvfs *dvfs;
+
+	ret = cpufreq_frequency_table_target(policy, s3c64xx_freq_table,
+					     target_freq, relation, &i);
+	if (ret != 0)
+		return ret;
+
+	freqs.cpu = 0;
+	freqs.old = clk_get_rate(armclk) / 1000;
+	freqs.new = s3c64xx_freq_table[i].frequency;
+	freqs.flags = 0;
+	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];
+
+	if (freqs.old == freqs.new)
+		return 0;
+
+	pr_debug("cpufreq: Transition %d-%dkHz\n", freqs.old, freqs.new);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+#ifdef CONFIG_REGULATOR
+	if (vddarm && freqs.new > freqs.old) {
+		ret = regulator_set_voltage(vddarm,
+					    dvfs->vddarm_min,
+					    dvfs->vddarm_max);
+		if (ret != 0) {
+			pr_err("cpufreq: Failed to set VDDARM for %dkHz: %d\n",
+			       freqs.new, ret);
+			goto err;
+		}
+	}
+#endif
+
+	ret = clk_set_rate(armclk, freqs.new * 1000);
+	if (ret < 0) {
+		pr_err("cpufreq: Failed to set rate %dkHz: %d\n",
+		       freqs.new, ret);
+		goto err;
+	}
+
+#ifdef CONFIG_REGULATOR
+	if (vddarm && freqs.new < freqs.old) {
+		ret = regulator_set_voltage(vddarm,
+					    dvfs->vddarm_min,
+					    dvfs->vddarm_max);
+		if (ret != 0) {
+			pr_err("cpufreq: Failed to set VDDARM for %dkHz: %d\n",
+			       freqs.new, ret);
+			goto err_clk;
+		}
+	}
+#endif
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	pr_debug("cpufreq: Set actual frequency %lukHz\n",
+		 clk_get_rate(armclk) / 1000);
+
+	return 0;
+
+err_clk:
+	if (clk_set_rate(armclk, freqs.old * 1000) < 0)
+		pr_err("Failed to restore original clock rate\n");
+err:
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return ret;
+}
+
+
+static int __init s3c64xx_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+	int ret;
+	struct cpufreq_frequency_table *freq;;
+
+	if (policy->cpu != 0)
+		return -EINVAL;
+
+	if (cpu_is_s3c6410()) {
+		s3c64xx_freq_table = s3c6410_freq_table;
+		s3c64xx_dvfs_table = s3c6410_dvfs_table;
+	}
+
+	if (s3c64xx_freq_table == NULL) {
+		pr_err("cpufreq: No frequency information for this CPU\n");
+		return -ENODEV;
+	}
+
+	armclk = clk_get(NULL, "armclk");
+	if (IS_ERR(armclk)) {
+		pr_err("cpufreq: Unable to obtain ARMCLK: %ld\n",
+		       PTR_ERR(armclk));
+		return PTR_ERR(armclk);
+	}
+
+#ifdef CONFIG_REGULATOR
+	vddarm = regulator_get(NULL, "vddarm");
+	if (IS_ERR(vddarm)) {
+		ret = PTR_ERR(vddarm);
+		pr_err("cpufreq: Failed to obtain VDDARM: %d\n", ret);
+		pr_err("cpufreq: Only frequency scaling available\n");
+		vddarm = NULL;
+	}
+#endif
+
+	/* Check for frequencies we can generate */
+	freq = s3c64xx_freq_table;
+	while (freq->frequency != CPUFREQ_TABLE_END) {
+		unsigned long r;
+
+		r = clk_round_rate(armclk, freq->frequency * 1000);
+		r /= 1000;
+
+		if (r != freq->frequency)
+			freq->frequency = CPUFREQ_ENTRY_INVALID;
+
+		freq++;
+	}
+
+	policy->cur = clk_get_rate(armclk) / 1000;
+	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
+
+	ret = cpufreq_frequency_table_cpuinfo(policy, s3c64xx_freq_table);
+	if (ret == 0)
+		return ret;
+
+	pr_err("cpufreq: Failed to configure frequency table: %d\n", ret);
+
+	regulator_put(vddarm);
+	clk_put(armclk);
+	return ret;
+}
+
+static struct cpufreq_driver s3c64xx_cpufreq_driver = {
+	.owner		= THIS_MODULE,
+	.flags          = 0,
+	.verify		= s3c64xx_cpufreq_verify_speed,
+	.target		= s3c64xx_cpufreq_set_target,
+	.get		= s3c64xx_cpufreq_get_speed,
+	.init		= s3c64xx_cpufreq_driver_init,
+	.name		= "s3c64xx",
+};
+
+static int __init s3c64xx_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&s3c64xx_cpufreq_driver);
+}
+module_init(s3c64xx_cpufreq_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/dev-usbgadget.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/dev-usbgadget.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/dev-usbgadget.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/dev-usbgadget.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,32 @@
+/* Base S3C64XX usbgadget resource and device definitions */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+
+#include <mach/map.h>
+#include <plat/map-base.h>
+#include <plat/devs.h>
+#include <plat/irqs.h>
+
+static struct resource s3c_usbgadget_resource[] = {
+	[0] = {
+		.start = S3C64XX_PA_OTG,
+		.end   = S3C64XX_PA_OTG + 0x200000  - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_OTG,
+		.end   = IRQ_OTG,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device s3c_device_usbgadget = {
+	.name		  = "s3c-otg-usbgadget",
+	.id		  = -1,
+	.num_resources	  = ARRAY_SIZE(s3c_usbgadget_resource),
+	.resource	  = s3c_usbgadget_resource,
+};
+EXPORT_SYMBOL(s3c_device_usbgadget);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/dma.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/dma.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/dma.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/dma.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,728 @@
+/* linux/arch/arm/plat-s3c64xx/dma.c
+ *
+ * Copyright 2009 Openmoko, Inc.
+ * Copyright 2009 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX DMA core
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/dmapool.h>
+#include <linux/sysdev.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <mach/dma.h>
+#include <mach/irqs.h>
+
+#include <plat/dma-plat.h>
+
+#include <plat/pl080.h>
+#include <mach/map.h>
+#include <plat/regs-sys.h>
+
+#define DEBUG
+
+#undef pr_debug
+#define pr_debug(x...) printk(x)
+
+/* dma channel state information */
+
+
+struct s3c64xx_dmac {
+	struct sys_device	 sysdev;
+	struct clk		*clk;
+	void __iomem		*regs;
+	struct s3c2410_dma_chan *channels;
+	enum dma_ch		 chanbase;
+};
+
+/* pool to provide LLI buffers */
+static struct dma_pool *dma_pool;
+
+/* Debug configuration and code */
+
+static unsigned char debug_show_buffs = 0;
+
+static void dbg_showchan(struct s3c2410_dma_chan *chan)
+{
+	pr_debug("DMA%d: %08x->%08x L %08x C %08x,%08x S %08x\n",
+		 chan->number,
+		 readl(chan->regs + PL080_CH_SRC_ADDR),
+		 readl(chan->regs + PL080_CH_DST_ADDR),
+		 readl(chan->regs + PL080_CH_LLI),
+		 readl(chan->regs + PL080_CH_CONTROL),
+		 readl(chan->regs + PL080S_CH_CONTROL2),
+		 readl(chan->regs + PL080S_CH_CONFIG));
+}
+
+static void show_lli(struct pl080_lli *lli)
+{
+	pr_debug("LLI[%p] %08x->%08x, NL %08x C %08x,%08x\n",
+		 lli, lli->src_addr, lli->dst_addr, lli->next_lli,
+		 lli->control0, lli->control1);
+}
+
+static void dbg_showbuffs(struct s3c2410_dma_chan *chan)
+{
+	struct s3c64xx_dma_buff *ptr;
+	struct s3c64xx_dma_buff *end;
+
+	pr_debug("DMA%d: buffs next %p, curr %p, end %p\n",
+		 chan->number, chan->next, chan->curr, chan->end);
+
+	ptr = chan->next;
+	end = chan->end;
+
+	if (debug_show_buffs) {
+		for (; ptr != NULL; ptr = ptr->next) {
+			pr_debug("DMA%d: %08x ",
+				 chan->number, ptr->lli_dma);
+			show_lli(ptr->lli);
+		}
+	}
+}
+
+/* End of Debug */
+
+static struct s3c2410_dma_chan *s3c64xx_dma_map_channel(unsigned int channel)
+{
+	struct s3c2410_dma_chan *chan;
+	unsigned int start, offs;
+
+	start = 0;
+
+	if (channel >= DMACH_PCM1_TX)
+		start = 8;
+
+	for (offs = 0; offs < 8; offs++) {
+		chan = &s3c2410_chans[start + offs];
+		if (!chan->in_use)
+			goto found;
+	}
+
+	return NULL;
+
+found:
+	s3c_dma_chan_map[channel] = chan;
+	return chan;
+}
+
+int s3c2410_dma_config(unsigned int channel, int xferunit)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	switch (xferunit) {
+	case 1:
+		chan->hw_width = 0;
+		break;
+	case 2:
+		chan->hw_width = 1;
+		break;
+	case 4:
+		chan->hw_width = 2;
+		break;
+	default:
+		printk(KERN_ERR "%s: illegal width %d\n", __func__, xferunit);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_config);
+
+static void s3c64xx_dma_fill_lli(struct s3c2410_dma_chan *chan,
+				 struct pl080_lli *lli,
+				 dma_addr_t data, int size)
+{
+	dma_addr_t src, dst;
+	u32 control0, control1;
+
+	switch (chan->source) {
+	case S3C2410_DMASRC_HW:
+		src = chan->dev_addr;
+		dst = data;
+		control0 = PL080_CONTROL_SRC_AHB2;
+		control0 |= (u32)chan->hw_width << PL080_CONTROL_SWIDTH_SHIFT;
+		control0 |= 2 << PL080_CONTROL_DWIDTH_SHIFT;
+		control0 |= PL080_CONTROL_DST_INCR;
+		break;
+
+	case S3C2410_DMASRC_MEM:
+		src = data;
+		dst = chan->dev_addr;
+		control0 = PL080_CONTROL_DST_AHB2;
+		control0 |= (u32)chan->hw_width << PL080_CONTROL_DWIDTH_SHIFT;
+		control0 |= 2 << PL080_CONTROL_SWIDTH_SHIFT;
+		control0 |= PL080_CONTROL_SRC_INCR;
+		break;
+	default:
+		BUG();
+	}
+
+	/* todo - burst control */
+
+	control1 = size / 4; /* TODO - calculate */
+	control0 |= PL080_CONTROL_PROT_SYS;	/* always in priv. mode */
+	control0 |= PL080_CONTROL_TC_IRQ_EN;	/* always fire IRQ */
+
+	lli->src_addr = src;
+	lli->dst_addr = dst;
+	lli->next_lli = 0;
+	lli->control0 = control0;
+	lli->control1 = control1;
+}
+
+static void s3c64xx_lli_to_regs(struct s3c2410_dma_chan *chan,
+				struct pl080_lli *lli)
+{
+	void __iomem *regs = chan->regs;
+
+	pr_debug("%s: LLI %p => regs\n", __func__, lli);
+	show_lli(lli);
+
+	writel(lli->src_addr, regs + PL080_CH_SRC_ADDR);
+	writel(lli->dst_addr, regs + PL080_CH_DST_ADDR);
+	writel(lli->next_lli, regs + PL080_CH_LLI);
+	writel(lli->control0, regs + PL080_CH_CONTROL);
+	writel(lli->control1, regs + PL080S_CH_CONTROL2);
+}
+
+static int s3c64xx_dma_start(struct s3c2410_dma_chan *chan)
+{
+	struct s3c64xx_dmac *dmac = chan->dmac;
+	u32 config;
+	u32 bit = chan->bit;
+
+	dbg_showchan(chan);
+
+	pr_debug("%s: clearing interrupts\n", __func__);
+
+	/* clear interrupts */
+	writel(bit, dmac->regs + PL080_TC_CLEAR);
+	writel(bit, dmac->regs + PL080_ERR_CLEAR);
+
+	pr_debug("%s: starting channel\n", __func__);
+
+	config = readl(chan->regs + PL080S_CH_CONFIG);
+	config |= PL080_CONFIG_ENABLE;
+
+	pr_debug("%s: writing config %08x\n", __func__, config);
+	writel(config, chan->regs + PL080S_CH_CONFIG);
+
+	return 0;
+}
+
+static int s3c64xx_dma_stop(struct s3c2410_dma_chan *chan)
+{
+	u32 config;
+	int timeout;
+
+	pr_debug("%s: stopping channel\n", __func__);
+
+	dbg_showchan(chan);
+
+	config = readl(chan->regs + PL080S_CH_CONFIG);
+	config |= PL080_CONFIG_HALT;
+	writel(config, chan->regs + PL080S_CH_CONFIG);
+
+	timeout = 1000;
+	do {
+		config = readl(chan->regs + PL080S_CH_CONFIG);
+		pr_debug("%s: %d - config %08x\n", __func__, timeout, config);
+		if (config & PL080_CONFIG_ACTIVE)
+			udelay(100);
+		else
+			break;
+		} while (--timeout > 0);
+
+	if (config & PL080_CONFIG_ACTIVE) {
+		printk(KERN_ERR "%s: channel still active\n", __func__);
+		return -EFAULT;
+	}
+
+	config = readl(chan->regs + PL080S_CH_CONFIG);
+	config &= ~PL080_CONFIG_ENABLE;
+	writel(config, chan->regs + PL080S_CH_CONFIG);
+
+	return 0;
+}
+
+static inline void s3c64xx_dma_bufffdone(struct s3c2410_dma_chan *chan,
+					 struct s3c64xx_dma_buff *buf,
+					 enum s3c2410_dma_buffresult result)
+{
+	if (chan->callback_fn != NULL)
+		(chan->callback_fn)(chan, buf->pw, 0, result);
+}
+
+static void s3c64xx_dma_freebuff(struct s3c64xx_dma_buff *buff)
+{
+	dma_pool_free(dma_pool, buff->lli, buff->lli_dma);
+	kfree(buff);
+}
+
+static int s3c64xx_dma_flush(struct s3c2410_dma_chan *chan)
+{
+	struct s3c64xx_dma_buff *buff, *next;
+	u32 config;
+
+	dbg_showchan(chan);
+
+	pr_debug("%s: flushing channel\n", __func__);
+
+	config = readl(chan->regs + PL080S_CH_CONFIG);
+	config &= ~PL080_CONFIG_ENABLE;
+	writel(config, chan->regs + PL080S_CH_CONFIG);
+
+	/* dump all the buffers associated with this channel */
+
+	for (buff = chan->curr; buff != NULL; buff = next) {
+		next = buff->next;
+		pr_debug("%s: buff %p (next %p)\n", __func__, buff, buff->next);
+
+		s3c64xx_dma_bufffdone(chan, buff, S3C2410_RES_ABORT);
+		s3c64xx_dma_freebuff(buff);
+	}
+
+	chan->curr = chan->next = chan->end = NULL;
+
+	return 0;
+}
+
+int s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+
+	WARN_ON(!chan);
+	if (!chan)
+		return -EINVAL;
+
+	switch (op) {
+	case S3C2410_DMAOP_START:
+		return s3c64xx_dma_start(chan);
+
+	case S3C2410_DMAOP_STOP:
+		return s3c64xx_dma_stop(chan);
+
+	case S3C2410_DMAOP_FLUSH:
+		return s3c64xx_dma_flush(chan);
+
+	/* belive PAUSE/RESUME are no-ops */
+	case S3C2410_DMAOP_PAUSE:
+	case S3C2410_DMAOP_RESUME:
+	case S3C2410_DMAOP_STARTED:
+	case S3C2410_DMAOP_TIMEOUT:
+		return 0;
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL(s3c2410_dma_ctrl);
+
+/* s3c2410_dma_enque
+ *
+ */
+
+int s3c2410_dma_enqueue(unsigned int channel, void *id,
+			dma_addr_t data, int size)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+	struct s3c64xx_dma_buff *next;
+	struct s3c64xx_dma_buff *buff;
+	struct pl080_lli *lli;
+	int ret;
+
+	WARN_ON(!chan);
+	if (!chan)
+		return -EINVAL;
+
+	buff = kzalloc(sizeof(struct s3c64xx_dma_buff), GFP_KERNEL);
+	if (!buff) {
+		printk(KERN_ERR "%s: no memory for buffer\n", __func__);
+		return -ENOMEM;
+	}
+
+	lli = dma_pool_alloc(dma_pool, GFP_KERNEL, &buff->lli_dma);
+	if (!lli) {
+		printk(KERN_ERR "%s: no memory for lli\n", __func__);
+		ret = -ENOMEM;
+		goto err_buff;
+	}
+
+	pr_debug("%s: buff %p, dp %08x lli (%p, %08x) %d\n",
+		 __func__, buff, data, lli, (u32)buff->lli_dma, size);
+
+	buff->lli = lli;
+	buff->pw = id;
+
+	s3c64xx_dma_fill_lli(chan, lli, data, size);
+
+	if ((next = chan->next) != NULL) {
+		struct s3c64xx_dma_buff *end = chan->end;
+		struct pl080_lli *endlli = end->lli;
+
+		pr_debug("enquing onto channel\n");
+
+		end->next = buff;
+		endlli->next_lli = buff->lli_dma;
+
+		if (chan->flags & S3C2410_DMAF_CIRCULAR) {
+			struct s3c64xx_dma_buff *curr = chan->curr;
+			lli->next_lli = curr->lli_dma;
+		}
+
+		if (next == chan->curr) {
+			writel(buff->lli_dma, chan->regs + PL080_CH_LLI);
+			chan->next = buff;
+		}
+
+		show_lli(endlli);
+		chan->end = buff;
+	} else {
+		pr_debug("enquing onto empty channel\n");
+
+		chan->curr = buff;
+		chan->next = buff;
+		chan->end = buff;
+
+		s3c64xx_lli_to_regs(chan, lli);
+	}
+
+	show_lli(lli);
+
+	dbg_showchan(chan);
+	dbg_showbuffs(chan);
+	return 0;
+
+err_buff:
+	kfree(buff);
+	return ret;
+}
+
+EXPORT_SYMBOL(s3c2410_dma_enqueue);
+
+
+int s3c2410_dma_devconfig(int channel,
+			  enum s3c2410_dmasrc source,
+			  unsigned long devaddr)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+	u32 peripheral;
+	u32 config = 0;
+
+	printk("%s: channel %d, source %d, dev %08lx, chan %p\n",
+		 __func__, channel, source, devaddr, chan);
+
+	WARN_ON(!chan);
+	if (!chan)
+		return -EINVAL;
+
+	peripheral = (chan->peripheral & 0xf);
+	chan->source = source;
+	chan->dev_addr = devaddr;
+
+	pr_debug("%s: peripheral %d\n", __func__, peripheral);
+
+	switch (source) {
+	case S3C2410_DMASRC_HW:
+		config = 2 << PL080_CONFIG_FLOW_CONTROL_SHIFT;
+		config |= peripheral << PL080_CONFIG_SRC_SEL_SHIFT;
+		break;
+	case S3C2410_DMASRC_MEM:
+		config = 1 << PL080_CONFIG_FLOW_CONTROL_SHIFT;
+		config |= peripheral << PL080_CONFIG_DST_SEL_SHIFT;
+		break;
+	default:
+		printk(KERN_ERR "%s: bad source\n", __func__);
+		return -EINVAL;
+	}
+
+	/* allow TC and ERR interrupts */
+	config |= PL080_CONFIG_TC_IRQ_MASK;
+	config |= PL080_CONFIG_ERR_IRQ_MASK;
+
+	pr_debug("%s: config %08x\n", __func__, config);
+
+	writel(config, chan->regs + PL080S_CH_CONFIG);
+
+	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_devconfig);
+
+
+int s3c2410_dma_getposition(unsigned int channel,
+			    dma_addr_t *src, dma_addr_t *dst)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+
+	WARN_ON(!chan);
+	if (!chan)
+		return -EINVAL;
+
+	if (src != NULL)
+ 		*src = readl(chan->regs + PL080_CH_SRC_ADDR);
+
+ 	if (dst != NULL)
+ 		*dst = readl(chan->regs + PL080_CH_DST_ADDR);
+
+ 	return 0;
+}
+EXPORT_SYMBOL(s3c2410_dma_getposition);
+
+/* s3c2410_request_dma
+ *
+ * get control of an dma channel
+*/
+
+int s3c2410_dma_request(unsigned int channel,
+			struct s3c2410_dma_client *client,
+			void *dev)
+{
+	struct s3c2410_dma_chan *chan;
+	unsigned long flags;
+
+	pr_debug("dma%d: s3c2410_request_dma: client=%s, dev=%p\n",
+		 channel, client->name, dev);
+
+	local_irq_save(flags);
+
+	chan = s3c64xx_dma_map_channel(channel);
+	if (chan == NULL) {
+		local_irq_restore(flags);
+		return -EBUSY;
+	}
+
+	dbg_showchan(chan);
+
+	chan->client = client;
+	chan->in_use = 1;
+	chan->peripheral = channel;
+
+	local_irq_restore(flags);
+
+	/* need to setup */
+
+	pr_debug("%s: channel initialised, %p\n", __func__, chan);
+
+	return chan->number | DMACH_LOW_LEVEL;
+}
+
+EXPORT_SYMBOL(s3c2410_dma_request);
+
+/* s3c2410_dma_free
+ *
+ * release the given channel back to the system, will stop and flush
+ * any outstanding transfers, and ensure the channel is ready for the
+ * next claimant.
+ *
+ * Note, although a warning is currently printed if the freeing client
+ * info is not the same as the registrant's client info, the free is still
+ * allowed to go through.
+*/
+
+int s3c2410_dma_free(unsigned int channel, struct s3c2410_dma_client *client)
+{
+	struct s3c2410_dma_chan *chan = s3c_dma_lookup_channel(channel);
+	unsigned long flags;
+
+	if (chan == NULL)
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (chan->client != client) {
+		printk(KERN_WARNING "dma%d: possible free from different client (channel %p, passed %p)\n",
+		       channel, chan->client, client);
+	}
+
+	/* sort out stopping and freeing the channel */
+
+
+	chan->client = NULL;
+	chan->in_use = 0;
+
+	if (!(channel & DMACH_LOW_LEVEL))
+		s3c_dma_chan_map[channel] = NULL;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(s3c2410_dma_free);
+
+
+static void s3c64xx_dma_tcirq(struct s3c64xx_dmac *dmac, int offs)
+{
+	struct s3c2410_dma_chan *chan = dmac->channels + offs;
+
+	/* note, we currently do not bother to work out which buffer
+	 * or buffers have been completed since the last tc-irq. */
+
+	if (chan->callback_fn)
+		(chan->callback_fn)(chan, chan->curr->pw, 0, S3C2410_RES_OK);
+}
+
+static void s3c64xx_dma_errirq(struct s3c64xx_dmac *dmac, int offs)
+{
+	printk(KERN_DEBUG "%s: offs %d\n", __func__, offs);
+}
+
+static irqreturn_t s3c64xx_dma_irq(int irq, void *pw)
+{
+	struct s3c64xx_dmac *dmac = pw;
+	u32 tcstat, errstat;
+	u32 bit;
+	int offs;
+
+	tcstat = readl(dmac->regs + PL080_TC_STATUS);
+	errstat = readl(dmac->regs + PL080_ERR_STATUS);
+
+	for (offs = 0, bit = 1; offs < 8; offs++, bit <<= 1) {
+		if (tcstat & bit) {
+			writel(bit, dmac->regs + PL080_TC_CLEAR);
+			s3c64xx_dma_tcirq(dmac, offs);
+		}
+
+		if (errstat & bit) {
+			s3c64xx_dma_errirq(dmac, offs);
+			writel(bit, dmac->regs + PL080_ERR_CLEAR);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct sysdev_class dma_sysclass = {
+	.name		= "s3c64xx-dma",
+};
+
+static int s3c64xx_dma_init1(int chno, enum dma_ch chbase,
+			     int irq, unsigned int base)
+{
+	struct s3c2410_dma_chan *chptr = &s3c2410_chans[chno];
+	struct s3c64xx_dmac *dmac;
+	char clkname[16];
+	void __iomem *regs;
+	void __iomem *regptr;
+	int err, ch;
+
+	dmac = kzalloc(sizeof(struct s3c64xx_dmac), GFP_KERNEL);
+	if (!dmac) {
+		printk(KERN_ERR "%s: failed to alloc mem\n", __func__);
+		return -ENOMEM;
+	}
+
+	dmac->sysdev.id = chno / 8;
+	dmac->sysdev.cls = &dma_sysclass;
+
+	err = sysdev_register(&dmac->sysdev);
+	if (err) {
+		printk(KERN_ERR "%s: failed to register sysdevice\n", __func__);
+		goto err_alloc;
+	}
+
+	regs = ioremap(base, 0x200);
+	if (!regs) {
+		printk(KERN_ERR "%s: failed to ioremap()\n", __func__);
+		err = -ENXIO;
+		goto err_dev;
+	}
+
+	snprintf(clkname, sizeof(clkname), "dma%d", dmac->sysdev.id);
+
+	dmac->clk = clk_get(NULL, clkname);
+	if (IS_ERR(dmac->clk)) {
+		printk(KERN_ERR "%s: failed to get clock %s\n", __func__, clkname);
+		err = PTR_ERR(dmac->clk);
+		goto err_map;
+	}
+
+	clk_enable(dmac->clk);
+
+	dmac->regs = regs;
+	dmac->chanbase = chbase;
+	dmac->channels = chptr;
+
+	err = request_irq(irq, s3c64xx_dma_irq, 0, "DMA", dmac);
+	if (err < 0) {
+		printk(KERN_ERR "%s: failed to get irq\n", __func__);
+		goto err_clk;
+	}
+
+	regptr = regs + PL080_Cx_BASE(0);
+
+	for (ch = 0; ch < 8; ch++, chno++, chptr++) {
+		printk(KERN_INFO "%s: registering DMA %d (%p)\n",
+		       __func__, chno, regptr);
+
+		chptr->bit = 1 << ch;
+		chptr->number = chno;
+		chptr->dmac = dmac;
+		chptr->regs = regptr;
+		regptr += PL008_Cx_STRIDE;
+	}
+
+	/* for the moment, permanently enable the controller */
+	writel(PL080_CONFIG_ENABLE, regs + PL080_CONFIG);
+
+	printk(KERN_INFO "PL080: IRQ %d, at %p\n", irq, regs);
+
+	return 0;
+
+err_clk:
+	clk_disable(dmac->clk);
+	clk_put(dmac->clk);
+err_map:
+	iounmap(regs);
+err_dev:
+	sysdev_unregister(&dmac->sysdev);
+err_alloc:
+	kfree(dmac);
+	return err;
+}  
+
+static int __init s3c64xx_dma_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "%s: Registering DMA channels\n", __func__);
+
+	dma_pool = dma_pool_create("DMA-LLI", NULL, 32, 16, 0);
+	if (!dma_pool) {
+		printk(KERN_ERR "%s: failed to create pool\n", __func__);
+		return -ENOMEM;
+	}
+
+	ret = sysdev_class_register(&dma_sysclass);
+	if (ret) {
+		printk(KERN_ERR "%s: failed to create sysclass\n", __func__);
+		return -ENOMEM;
+	}
+
+	/* Set all DMA configuration to be DMA, not SDMA */
+	writel(0xffffff, S3C_SYSREG(0x110));
+	
+	/* Register standard DMA controlers */
+	s3c64xx_dma_init1(0, DMACH_UART0, IRQ_DMA0, 0x75000000);
+	s3c64xx_dma_init1(8, DMACH_PCM1_TX, IRQ_DMA1, 0x75100000);
+
+	return 0;
+}
+
+arch_initcall(s3c64xx_dma_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/dma-fake.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/dma-fake.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/dma-fake.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/dma-fake.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,36 @@
+/* linux/arch/arm/plat-s3c64xx/dma.c
+ *
+ * Copyright 2009 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C64XX DMA core - fake
+ *
+ * http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/sysdev.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <mach/dma.h>
+
+
+int s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(s3c2410_dma_ctrl);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/gpiolib.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/gpiolib.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/gpiolib.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/gpiolib.c	2009-05-10 22:27:59.000000000 +0200
@@ -18,6 +18,7 @@
 
 #include <mach/map.h>
 #include <mach/gpio.h>
+#include <mach/irqs.h>
 #include <mach/gpio-core.h>
 
 #include <plat/gpio-cfg.h>
@@ -321,6 +322,11 @@
 	.get_pull	= s3c_gpio_getpull_updown,
 };
 
+static int s3c_gpiolib_bankn_toirq(struct gpio_chip *chip, unsigned offset)
+{
+	return S3C_EINT(0) + offset;
+}
+
 static struct s3c_gpio_chip gpio_2bit[] = {
 	{
 		.base	= S3C64XX_GPF_BASE,
@@ -353,6 +359,7 @@
 			.base	= S3C64XX_GPN(0),
 			.ngpio	= S3C64XX_GPIO_N_NR,
 			.label	= "GPN",
+			.to_irq = s3c_gpiolib_bankn_toirq,
 		},
 	}, {
 		.base	= S3C64XX_GPO_BASE,
@@ -385,12 +392,19 @@
 {
 	chip->chip.direction_input = s3c64xx_gpiolib_4bit_input;
 	chip->chip.direction_output = s3c64xx_gpiolib_4bit_output;
+	chip->pm = __gpio_pm(&s3c_gpio_pm_4bit);
 }
 
 static __init void s3c64xx_gpiolib_add_4bit2(struct s3c_gpio_chip *chip)
 {
 	chip->chip.direction_input = s3c64xx_gpiolib_4bit2_input;
 	chip->chip.direction_output = s3c64xx_gpiolib_4bit2_output;
+	chip->pm = __gpio_pm(&s3c_gpio_pm_4bit);
+}
+
+static __init void s3c64xx_gpiolib_add_2bit(struct s3c_gpio_chip *chip)
+{
+	chip->pm = __gpio_pm(&s3c_gpio_pm_2bit);
 }
 
 static __init void s3c64xx_gpiolib_add(struct s3c_gpio_chip *chips,
@@ -412,7 +426,8 @@
 	s3c64xx_gpiolib_add(gpio_4bit2, ARRAY_SIZE(gpio_4bit2),
 			    s3c64xx_gpiolib_add_4bit2);
 
-	s3c64xx_gpiolib_add(gpio_2bit, ARRAY_SIZE(gpio_2bit), NULL);
+	s3c64xx_gpiolib_add(gpio_2bit, ARRAY_SIZE(gpio_2bit),
+			    s3c64xx_gpiolib_add_2bit);
 
 	return 0;
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/dma-plat.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/dma-plat.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/dma-plat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/dma-plat.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,70 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/dma-plat.h
+ *
+ * Copyright 2009 Openmoko, Inc.
+ * Copyright 2009 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX DMA core
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#define DMACH_LOW_LEVEL (1<<28) /* use this to specifiy hardware ch no */
+
+struct s3c64xx_dma_buff;
+
+/** s3c64xx_dma_buff - S3C64XX DMA buffer descriptor
+ * @next: Pointer to next buffer in queue or ring.
+ * @pw: Client provided identifier
+ * @lli: Pointer to hardware descriptor this buffer is associated with.
+ * @lli_dma: Hardare address of the descriptor.
+ */
+struct s3c64xx_dma_buff {
+	struct s3c64xx_dma_buff *next;
+
+	void			*pw;
+	struct pl080_lli	*lli;
+	dma_addr_t		 lli_dma;
+};
+
+struct s3c64xx_dmac;
+
+struct s3c2410_dma_chan {
+	unsigned char		 number;      /* number of this dma channel */
+	unsigned char		 in_use;      /* channel allocated */
+	unsigned char		 bit;	      /* bit for enable/disable/etc */
+	unsigned char		 hw_width;
+	unsigned char		 peripheral;
+
+	unsigned int		 flags;
+	enum s3c2410_dmasrc	 source;
+
+
+	dma_addr_t		dev_addr;
+
+	struct s3c2410_dma_client *client;
+	struct s3c64xx_dmac	*dmac;		/* pointer to controller */
+
+	void __iomem		*regs;
+
+	/* cdriver callbacks */
+	s3c2410_dma_cbfn_t	 callback_fn;	/* buffer done callback */
+	s3c2410_dma_opfn_t	 op_fn;		/* channel op callback */
+
+	/* buffer list and information */
+	struct s3c64xx_dma_buff	*curr;		/* current dma buffer */
+	struct s3c64xx_dma_buff	*next;		/* next buffer to load */
+	struct s3c64xx_dma_buff	*end;		/* end of queue */
+
+	/* note, when channel is running in circular mode, curr is the
+	 * first buffer enqueued, end is the last and curr is where the
+	 * last buffer-done event is set-at. The buffers are not freed
+	 * and the last buffer hardware descriptor points back to the
+	 * first. 
+	 */
+};
+
+#include <plat/dma-core.h>
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/irqs.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/irqs.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/irqs.h	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/irqs.h	2009-05-10 22:27:59.000000000 +0200
@@ -148,6 +148,7 @@
 /* compatibility for device defines */
 
 #define IRQ_IIC1		IRQ_S3C6410_IIC1
+#define IRQ_USBH		IRQ_UHOST
 
 /* Since the IRQ_EINT(x) are a linear mapping on current s3c64xx series
  * we just defined them as an IRQ_EINT(x) macro from S3C_IRQ_EINT_BASE
@@ -157,6 +158,7 @@
 
 #define S3C_EINT(x)		((x) + S3C_IRQ_EINT_BASE)
 #define IRQ_EINT(x)		S3C_EINT(x)
+#define IRQ_EINT_BIT(x)		((x) - S3C_EINT(0))
 
 /* Next the external interrupt groups. These are similar to the IRQ_EINT(x)
  * that they are sourced from the GPIO pins but with a different scheme for
@@ -197,5 +199,6 @@
 
 #define NR_IRQS	(IRQ_EINT_GROUP9_BASE + IRQ_EINT_GROUP9_NR + 1)
 
+#define FIQ_START S3C_IRQ(0)
 #endif /* __ASM_PLAT_S3C64XX_IRQS_H */
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/pl080.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/pl080.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/pl080.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/pl080.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,110 @@
+/* arch/arm/include/asm/hardware/pl080.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      http://armlinux.simtec.co.uk/
+ *      Ben Dooks <ben@simtec.co.uk>
+ *
+ * ARM PrimeCell PL080 DMA controller
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/* Note, there are some Samsung updates to this controller block which
+ * make it not entierly compatible with the PL080 specification from
+ * ARM. When in doubt, check the Samsung documentation first.
+ *
+ * The Samsung defines are PL080S, and add an extra controll register,
+ * the ability to move more than 2^11 counts of data and some extra
+ * OneNAND features.
+*/
+
+#define PL080_INT_STATUS			(0x00)
+#define PL080_TC_STATUS				(0x04)
+#define PL080_TC_CLEAR				(0x08)
+#define PL080_ERR_STATUS			(0x0C)
+#define PL080_ERR_CLEAR				(0x10)
+#define PL080_RAW_TC_STATUS			(0x14)
+#define PL080_RAW_ERR_STATUS			(0x18)
+#define PL080_EN_CHAN				(0x1c)
+#define PL080_SOFT_BREQ				(0x20)
+#define PL080_SOFT_SREQ				(0x24)
+#define PL080_SOFT_LBREQ			(0x28)
+#define PL080_SOFT_LSREQ			(0x2C)
+
+#define PL080_CONFIG				(0x30)
+#define PL080_CONFIG_M2_BE			(1 << 2)
+#define PL080_CONFIG_M1_BE			(1 << 1)
+#define PL080_CONFIG_ENABLE			(1 << 0)
+
+#define PL080_SYNC				(0x34)
+
+/* Per channel configuration registers */
+
+#define PL008_Cx_STRIDE				(0x20)
+#define PL080_Cx_BASE(x)			((0x100 + (x * 0x20)))
+#define PL080_Cx_SRC_ADDR(x)			((0x100 + (x * 0x20)))
+#define PL080_Cx_DST_ADDR(x)			((0x104 + (x * 0x20)))
+#define PL080_Cx_LLI(x)				((0x108 + (x * 0x20)))
+#define PL080_Cx_CONTROL(x)			((0x10C + (x * 0x20)))
+#define PL080_Cx_CONFIG(x)			((0x110 + (x * 0x20)))
+#define PL080S_Cx_CONTROL2(x)			((0x110 + (x * 0x20)))
+#define PL080S_Cx_CONFIG(x)			((0x114 + (x * 0x20)))
+
+#define PL080_CH_SRC_ADDR			(0x00)
+#define PL080_CH_DST_ADDR			(0x04)
+#define PL080_CH_LLI				(0x08)
+#define PL080_CH_CONTROL			(0x0C)
+#define PL080_CH_CONFIG				(0x10)
+#define PL080S_CH_CONTROL2			(0x10)
+#define PL080S_CH_CONFIG			(0x14)
+
+#define PL080_LLI_ADDR_MASK			(0x3fffffff << 2)
+#define PL080_LLI_ADDR_SHIFT			(2)
+#define PL080_LLI_LM_AHB2			(1 << 0)
+
+#define PL080_CONTROL_TC_IRQ_EN			(1 << 31)
+#define PL080_CONTROL_PROT_MASK			(0x7 << 28)
+#define PL080_CONTROL_PROT_SHIFT		(28)
+#define PL080_CONTROL_PROT_SYS			(1 << 28)
+#define PL080_CONTROL_DST_INCR			(1 << 27)
+#define PL080_CONTROL_SRC_INCR			(1 << 26)
+#define PL080_CONTROL_DST_AHB2			(1 << 25)
+#define PL080_CONTROL_SRC_AHB2			(1 << 24)
+#define PL080_CONTROL_DWIDTH_MASK		(0x7 << 21)
+#define PL080_CONTROL_DWIDTH_SHIFT		(21)
+#define PL080_CONTROL_SWIDTH_MASK		(0x7 << 18)
+#define PL080_CONTROL_SWIDTH_SHIFT		(18)
+#define PL080_CONTROL_DB_SIZE_MASK		(0x7 << 15)
+#define PL080_CONTROL_DB_SIZE_SHIFT		(15)
+#define PL080_CONTROL_SB_SIZE_MASK		(0x7 << 12)
+#define PL080_CONTROL_SB_SIZE_SHIFT		(12)
+#define PL080_CONTROL_TRANSFER_SIZE_MASK	(0xfff << 0)
+#define PL080_CONTROL_TRANSFER_SIZE_SHIFT	(0)
+
+#define PL080_CONFIG_HALT			(1 << 18)
+#define PL080_CONFIG_ACTIVE			(1 << 17)
+#define PL080_CONFIG_LOCK			(1 << 16)
+#define PL080_CONFIG_TC_IRQ_MASK		(1 << 15)
+#define PL080_CONFIG_ERR_IRQ_MASK		(1 << 14)
+#define PL080_CONFIG_FLOW_CONTROL_MASK		(0x7 << 11)
+#define PL080_CONFIG_FLOW_CONTROL_SHIFT		(11)
+#define PL080_CONFIG_DST_SEL_MASK		(0xf << 6)
+#define PL080_CONFIG_DST_SEL_SHIFT		(6)
+#define PL080_CONFIG_SRC_SEL_MASK		(0xf << 1)
+#define PL080_CONFIG_SRC_SEL_SHIFT		(1)
+#define PL080_CONFIG_ENABLE			(1 << 0)
+
+
+/* DMA linked list chain structure */
+
+struct pl080_lli {
+	u32	src_addr;
+	u32	dst_addr;
+	u32	next_lli;
+	u32	control0;
+	u32	control1;
+};
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/pm-core.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/pm-core.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/pm-core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/pm-core.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,106 @@
+/* linux/arch/arm/plat-s3c64xx/include/plat/pm-core.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX - PM core support for arch/arm/plat-s3c/pm.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <plat/regs-gpio.h>
+
+static inline void s3c_pm_debug_init_uart(void)
+{
+	u32 tmp = __raw_readl(S3C_PCLK_GATE);
+
+	/* As a note, since the S3C64XX UARTs generally have multiple
+	 * clock sources, we simply enable PCLK at the moment and hope
+	 * that the resume settings for the UART are suitable for the
+	 * use with PCLK.
+	 */
+
+	tmp |= S3C_CLKCON_PCLK_UART0;
+	tmp |= S3C_CLKCON_PCLK_UART1;
+	tmp |= S3C_CLKCON_PCLK_UART2;
+	tmp |= S3C_CLKCON_PCLK_UART3;
+
+	__raw_writel(tmp, S3C_PCLK_GATE);
+	udelay(10);
+}
+
+static inline void s3c_pm_arch_clear_vic(void __iomem *base)
+{
+	__raw_writel(~0, base + VIC_INT_ENABLE_CLEAR);
+	__raw_writel(~0, base + VIC_INT_SOFT_CLEAR);
+}
+
+static inline void s3c_pm_arch_prepare_irqs(void)
+{
+	/* shutdown the VICs */
+	s3c_pm_arch_clear_vic(S3C_VA_VIC0);
+	s3c_pm_arch_clear_vic(S3C_VA_VIC1);
+
+	/* clear any pending EINT0 interrupts */
+	__raw_writel(__raw_readl(S3C64XX_EINT0PEND), S3C64XX_EINT0PEND);
+}
+
+static inline void s3c_pm_arch_stop_clocks(void)
+{
+}
+
+static inline void s3c_pm_arch_show_resume_irqs(void)
+{
+}
+
+/* make these defines, we currently do not have any need to change
+ * the IRQ wake controls depending on the CPU we are running on */
+
+#define s3c_irqwake_eintallow	((1 << 28) - 1)
+#define s3c_irqwake_intallow	(0)
+
+static inline void s3c_pm_arch_update_uart(void __iomem *regs,
+					   struct pm_uart_save *save)
+{
+	u32 ucon = __raw_readl(regs + S3C2410_UCON);
+	u32 ucon_clk = ucon & S3C6400_UCON_CLKMASK;
+	u32 save_clk = save->ucon & S3C6400_UCON_CLKMASK;
+	u32 new_ucon;
+	u32 delta;
+
+	/* S3C64XX UART blocks only support level interrupts, so ensure that
+	 * when we restore unused UART blocks we force the level interrupt
+	 * settigs. */
+	save->ucon |= S3C2410_UCON_TXILEVEL | S3C2410_UCON_RXILEVEL;
+
+	/* We have a constraint on changing the clock type of the UART
+	 * between UCLKx and PCLK, so ensure that when we restore UCON
+	 * that the CLK field is correctly modified if the bootloader
+	 * has changed anything.
+	 */
+	if (ucon_clk != save_clk) {
+		new_ucon = save->ucon;
+		delta = ucon_clk ^ save_clk;
+
+		/* change from UCLKx => wrong PCLK,
+		 * either UCLK can be tested for by a bit-test
+		 * with UCLK0 */
+		if (ucon_clk & S3C6400_UCON_UCLK0 &&
+		    !(save_clk & S3C6400_UCON_UCLK0) &&
+		    delta & S3C6400_UCON_PCLK2) {
+			new_ucon &= ~S3C6400_UCON_UCLK0;
+		} else if (delta == S3C6400_UCON_PCLK2) {
+			/* as an precaution, don't change from
+			 * PCLK2 => PCLK or vice-versa */
+			new_ucon ^= S3C6400_UCON_PCLK2;
+		}
+
+		S3C_PMDBG("ucon change %04x => %04x (save=%04x)\n",
+			  ucon, new_ucon, save->ucon);
+		save->ucon = new_ucon;
+	}
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-camif.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-camif.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-camif.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-camif.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,460 @@
+/* arch/arm/plat-s3c64xx/include/plat/regs-camif.h
+ *
+ * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
+ *		      http://www.simtec.co.uk/products/SWLINUX/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+
+#ifndef ___ASM_ARCH_REGS_CAMIF_H
+#define ___ASM_ARCH_REGS_CAMIF_H
+
+#define S3C_CAMIFREG(x) (x)
+
+/*************************************************************************
+ * Macro part
+ ************************************************************************/
+#define S3C_CISRCFMT_SOURCEHSIZE(x)			((x) << 16)
+#define S3C_CISRCFMT_GET_SOURCEHSIZE(x)			(((x) >> 16) & 0x1FFFF)
+#define S3C_CISRCFMT_SOURCEVSIZE(x)			((x) << 0)
+#define S3C_CISRCFMT_GET_SOURCEVSIZE(x)			(((x) >> 0) & 0x1FFF)
+
+#define S3C_CIWDOFST_WINHOROFST(x)			((x) << 16)
+#define S3C_CIWDOFST_GET_WINHOROFST(x)			(((x) >> 16) & 0x7FF)
+#define S3C_CIWDOFST_WINVEROFST(x)			((x) << 0)
+#define S3C_CIWDOFST_GET_WINVEROFST(x)			(((x) >> 0) & 0x7FF)
+
+#define S3C_CIDOWSFT2_WINHOROFST2(x)			((x) << 16)
+#define S3C_CIDOWSFT2_GET_WINHOROFST2(x)		(((x) >> 16) & 0x7FF)
+#define S3C_CIDOWSFT2_WINVEROFST2(x)			((x) << 0)
+#define S3C_CIDOWSFT2_GET_WINVEROFST2(x)		(((x) >> 0) & 0x7FF)
+
+#define S3C_CICOTRGFMT_TARGETHSIZE_CO(x)		((x) << 16)
+#define S3C_CICOTRGFMT_GET_TARGETHSIZE_CO(x)		(((x) >> 16) & 0x1FFF)
+
+#define S3C_CICOTRGFMT_TARGETVSIZE_CO(x)		((x) << 0)
+#define S3C_CICOTRGFMT_GET_TARGETVSIZE_CO(x)		(((x) >> 0) & 0x1FFF)
+
+#define S3C_CICOCTRL_YBURST1_CO(x)			((x) << 19)
+#define S3C_CICOCTRL_YBURST2_CO(x)			((x) << 14)
+#define S3C_CICOCTRL_CBURST1_CO(x)			((x) << 9)
+#define S3C_CICOCTRL_CBURST2_CO(x)			((x) << 4)
+
+#define S3C_CICOSCPRERATIO_SHFACTOR_CO(x)		((x) << 28)
+#define S3C_CICOSCPRERATIO_GET_SHFACTOR_CO(x)		(((x) >> 28) & 0x7F)
+#define S3C_CICOSCPRERATIO_PREHORRATIO_CO(x)		((x) << 16)
+#define S3C_CICOSCPRERATIO_GET_PREHORRATIO_CO(x)	(((x) >> 16) & 0x7F)
+#define S3C_CICOSCPRERATIO_PREVERRATIO_CO(x)		((x) << 0)
+#define S3C_CICOSCPRERATIO_GET_PREVERRATIO_CO(x)	(((x) >> 0) & 0x7F)
+
+#define S3C_CICOSCPREDST_PREDSTWIDTH_CO(x)		((x) << 16)
+#define S3C_CICOSCPREDST_GET_PREDSTWIDTH_CO(x)		(((x) >> 16) & 0x7FF)
+#define S3C_CICOSCPREDST_PREDSTHEIGHT_CO(x)		((x) << 0)
+#define S3C_CICOSCPREDST_GET_PREDSTHEIGHT_CO(x)		(((x) >> 0) & 0x7FF)
+
+#define S3C_CICOSCCTRL_MAINHORRATIO_CO(x)		((x) << 16)
+#define S3C_CICOSCCTRL_GET_MAINHORRATIO_CO(x)		(((x) >> 16) & 0x1FF)
+#define S3C_CICOSCCTRL_MAINVERRATIO_CO(x)		((x) << 0)
+
+#define S3C_CICOSTATUS_FRAMECNT_CO(x)			((x) << 26)
+#define S3C_CICOSTATUS_GET_FRAMECNT_CO(x)		(((x) >> 26) & 0x3)
+
+#define S3C_CIPRTRGFMT_TARGETHSIZE_PR(x)		((x) << 16)
+#define S3C_CIPRTRGFMT_GET_TARGETHSIZE_PR(x)		(((x) >> 16) & 0x1FFF)
+
+#define S3C_CIPRTRGFMT_GET_ROT90_PR(x)			(((x) >> 13) & 0x1)
+
+#define S3C_CIPRTRGFMT_TARGETVSIZE_PR(x)		((x) << 0)
+#define S3C_CIPRTRGFMT_GET_TARGETVSIZE_PR(x)		(((x) >> 0) & 0x1FFF)
+
+#define S3C_CIPRSCPRERATIO_SHFACTOR_PR(x)		((x) << 28)
+#define S3C_CIPRSCPRERATIO_GET_SHFACTOR_PR(x)		(((x) >> 28) & 0xF)
+#define S3C_CIPRSCPRERATIO_PREHORRATIO_PR(x)		((x) << 16)
+#define S3C_CIPRSCPRERATIO_GET_PREHORRATIO_PR(x)	(((x) >> 16) & 0x7F)
+#define S3C_CIPRSCPRERATIO_PREVERRATIO_PR(x)		((x) << 0)
+#define S3C_CIPRSCPRERATIO_GET_PREVERRATIO_PR(x)	(((x) >> 0) & 0x7F)
+
+#define S3C_CIPRSCPREDST_PREDSTWIDTH_PR(x)		((x) << 16)
+#define S3C_CIPRSCPREDST_GET_PREDSTWIDTH_PR(x)		(((x) >> 16) & 0xFFF)
+#define S3C_CIPRSCPREDST_PREDSTHEIGHT_PR(x)		((x) << 0)
+#define S3C_CIPRSCPREDST_GET_PREDSTHEIGHT_PR(x)		(((x) >> 0) & 0xFFF)
+
+#define S3C_CIPRSCCTRL_MAINHORRATIO_PR(x)		((x) << 16)
+#define S3C_CIPRSCCTRL_GET_MAINHORRATIO_PR(x)		(((x) >> 16) && 0x1FF)
+#define S3C_CIPRSCCTRL_MAINVERRATIO_PR(x)		((x) << 0)
+#define S3C_CIPRSCCTRL_GET_MAINVERRATIO_PR(x)		(((x) >> 0) && 0x1FF)
+
+/*************************************************************************
+ * Bit definition part
+ ************************************************************************/
+/* Windows Offset Register */
+#define S3C_CIWDOFST_WINOFSEN				(1 << 31)
+#define S3C_CIWDOFST_CLROVCOFIY				(1 << 30)
+#define S3C_CIWDOFST_CLROVRLB_CO			(1 << 29)
+#define S3C_CIWDOFST_CLROVRLB_PR			(1 << 28)
+#define S3C_CIWDOFST_CLROVPRFIY				(1 << 27)
+#define S3C_CIWDOFST_CLROVCOFICB			(1 << 15)
+#define S3C_CIWDOFST_CLROVCOFICR			(1 << 14)
+#define S3C_CIWDOFST_CLROVPRFICB			(1 << 13)
+#define S3C_CIWDOFST_CLROVPRFICR			(1 << 12)
+
+/* Global Control Register */
+#define S3C_CIGCTRL_SWRST				(1 << 31)
+#define S3C_CIGCTRL_CAMRST				(1 << 30)
+
+#if defined (CONFIG_CPU_S3C6400) || defined (CONFIG_CPU_S3C6410)
+#define	S3C_CIGCTRL_IRQ_LEVEL				(1 << 20)
+#endif
+
+#define S3C_CIGCTRL_TESTPATTERN_VER_INC			(3 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_HOR_INC			(2 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_COLOR_BAR		(1 << 27)
+#define S3C_CIGCTRL_TESTPATTERN_NORMAL			(0 << 27)
+
+#define S3C_CIGCTRL_INVPOLPCLK				(1 << 26)
+#define S3C_CIGCTRL_INVPOLVSYNC				(1 << 25)
+#define S3C_CIGCTRL_INVPOLHREF				(1 << 24)
+#define S3C_CIGCTRL_IRQ_OVFEN				(1 << 22)
+#define S3C_CIGCTRL_HREF_MASK				(1 << 21)
+#define S3C_CIGCTRL_IRQ_LEVEL				(1 << 20)
+#define S3C_CIGCTRL_IRQ_CLR_C				(1 << 19)
+#define S3C_CIGCTRL_IRQ_CLR_P				(1 << 18)
+
+/* Codec Target Format Register */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_CICOTRGFMT_IN422_422			(1 << 31)
+#define S3C_CICOTRGFMT_IN422_420			(0 << 31)
+#define S3C_CICOTRGFMT_OUT422_422			(1 << 30)
+#define S3C_CICOTRGFMT_OUT422_420			(0 << 30)
+
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+#define S3C_CICOTRGFMT_OUTFORMAT_RGBOUT			(3 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUTINTERLEAVE	(2 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUT		(1 << 29)
+#define S3C_CICOTRGFMT_OUTFORMAT_YCBCR420OUT		(0 << 29)
+#endif
+
+#define S3C_CICOTRGFMT_INTERLEAVE_ON			(1 << 29)
+#define S3C_CICOTRGFMT_INTERLEAVE_OFF			(0 << 29)
+
+#define S3C_CICOTRGFMT_FLIP_180				(3 << 14)
+#define S3C_CICOTRGFMT_FLIP_Y_MIRROR			(2 << 14)
+#define S3C_CICOTRGFMT_FLIP_X_MIRROR			(1 << 14)
+#define S3C_CICOTRGFMT_FLIP_NORMAL			(0 << 14)
+
+/* Codec DMA Control Register */
+#define S3C_CICOCTRL_LASTIRQEN				(1 << 2)
+#define S3C_CICOCTRL_ORDER422_CRYCBY			(3 << 0)
+#define S3C_CICOCTRL_ORDER422_CBYCRY			(2 << 0)
+#define S3C_CICOCTRL_ORDER422_YCRYCB			(1 << 0)
+#define S3C_CICOCTRL_ORDER422_YCBYCR			(0 << 0)
+
+/* Codec Main-Scaler Control Register */
+#define S3C_CICOSCCTRL_SCALERBYPASS_CO			(1 << 31)
+#define S3C_CICOSCCTRL_SCALEUP_H			(1 << 30)
+#define S3C_CICOSCCTRL_SCALEUP_V			(1 << 29)
+
+#define S3C_CICOSCCTRL_CSCR2Y_WIDE			(1 << 28)
+#define S3C_CICOSCCTRL_CSCR2Y_NARROW			(0 << 28)
+
+#define S3C_CICOSCCTRL_CSCY2R_WIDE			(1 << 27)
+#define S3C_CICOSCCTRL_CSCY2R_NARROW			(0 << 27)
+
+#define S3C_CICOSCCTRL_LCDPATHEN_FIFO			(1 << 26)
+#define S3C_CICOSCCTRL_LCDPATHEN_DMA			(0 << 26)
+
+#define S3C_CICOSCCTRL_INTERLACE_INTERLACE		(1 << 25)
+#define S3C_CICOSCCTRL_INTERLACE_PROGRESSIVE		(0 << 25)
+
+#define S3C_CICOSCCTRL_COSCALERSTART			(1 << 15)
+
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB888			(2 << 13)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB666			(1 << 13)
+#define S3C_CICOSCCTRL_INRGB_FMT_RGB565			(0 << 13)
+
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB888		(2 << 11)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB666		(1 << 11)
+#define S3C_CICOSCCTRL_OUTRGB_FMT_RGB565		(0 << 11)
+
+#define S3C_CICOSCCTRL_EXTRGB_EXTENSION			(1 << 10)
+#define S3C_CICOSCCTRL_EXTRGB_NORMAL			(0 << 10)
+
+/* Codec Status Register */
+#define S3C_CICOSTATUS_OVFIY_CO				(1 << 31)
+#define S3C_CICOSTATUS_OVFICB_CO			(1 << 30)
+#define S3C_CICOSTATUS_OVFICR_CO			(1 << 29)
+#define S3C_CICOSTATUS_VSYNC				(1 << 28)
+#define S3C_CICOSTATUS_WINOFSTEN_CO			(1 << 25)
+#define S3C_CICOSTATUS_IMGCPTEN_CAMIF			(1 << 22)
+#define S3C_CICOSTATUS_IMGCPTEN_COSC			(1 << 21)
+#define S3C_CICOSTATUS_VSYNC_A				(1 << 20)
+#define S3C_CICOSTATUS_VSYNC_B				(1 << 19)
+#define S3C_CICOSTATUS_OVRLB_CO				(1 << 18)
+#define S3C_CICOSTATUS_FRAMEEND_CO			(1 << 17)
+
+/* Preview Target Format Register */
+#define S3C_CIPRTRGFMT_FLIPMD_180ROT			(3 << 14)
+#define S3C_CIPRTRGFMT_FLIPMD_YMIRROR			(2 << 14)
+#define S3C_CIPRTRGFMT_FLIPMD_XMIRROR			(1 << 14)
+#define S3C_CIPRTRGFMT_FLIPMD_NORMAL			(0 << 14)
+
+#define S3C_CIPRTRGFMT_ROT90_ROTATE			(1 << 13)
+#define S3C_CIPRTRGFMT_ROT90_BYPASS			(0 << 13)
+
+/* Preview DMA Control Register */
+#define S3C_CIPRCTRL_LASTIRQEN_ENABLE			(1 << 2)
+#define S3C_CIPRCTRL_LASTIRQEN_NORMAL			(0 << 2)
+
+#define S3C_CIPRCTRL_ORDER422_CRYCBY			(3 << 0)
+#define S3C_CIPRCTRL_ORDER422_CBYCRY			(2 << 0)
+#define S3C_CIPRCTRL_ORDER422_YCRYCB			(1 << 0)
+#define S3C_CIPRCTRL_ORDER422_YCBYCR			(0 << 0)
+
+/* Preview Main-Scaler Control Register */
+#define S3C_CIPRSCCTRL_SAMPLE_PR			(1 << 31)
+
+#define S3C_CIPRSCCTRL_RGBFORMAT_24			(1 << 30)
+#define S3C_CIPRSCCTRL_RGBFORMAT_16			(0 << 30)
+
+#define S3C_CIPRSCCTRL_START				(1 << 15)
+
+#define S3C_CIPRSCCTRL_INRGB_FMT_PR_RGB888		(2 << 13)
+#define S3C_CIPRSCCTRL_INRGB_FMT_PR_RGB666		(1 << 13)
+#define S3C_CIPRSCCTRL_INRGB_FMT_PR_RGB565		(0 << 13)
+
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB888		(2 << 11)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB666		(1 << 11)
+#define S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB565		(0 << 11)
+
+/* Preview Status Register */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_CIPRSTATUS_OVFICB_PR			(1 << 31)
+#define S3C_CIPRSTATUS_OVFICR_PR			(1 << 30)
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410
+#define S3C_CIPRSTATUS_OVFIY_PR				(1 << 31)
+#define S3C_CIPRSTATUS_OVFICB_PR			(1 << 30)
+#define S3C_CIPRSTATUS_OVFICR_PR			(1 << 29)
+#endif
+
+/* Image Capture Enable Register */
+#define S3C_CIIMGCPT_IMGCPTEN				(1 << 31)
+#define S3C_CIIMGCPT_IMGCPTEN_COSC			(1 << 30)
+#define S3C_CIIMGCPT_IMGCPTEN_PRSC			(1 << 29)
+
+#define S3C_CIIMGCPT_CPT_CODMA_SEL_RGB			(1 << 26)
+#define S3C_CIIMGCPT_CPT_CODMA_SEL_YUV			(0 << 26)
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_CIIMGCPT_CPT_CODMA_RGBFMT_24		(1 << 25)
+#define S3C_CIIMGCPT_CPT_CODMA_RGBFMT_16		(0 << 25)
+#define S3C_CIIMGCPT_CPT_CODMA_ENABLE			(1 << 24)
+#define S3C_CIIMGCPT_CPT_CODMA_DISABLE			(0 << 24)
+#define S3C_CIIMGCPT_CPT_CODMA_MOD_CNT			(1 << 18)
+#define S3C_CIIMGCPT_CPT_CODMA_MOD_EN			(0 << 18)
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410
+#define S3C_CIIMGCPT_CPT_FREN_CO_ENABLE			(1 << 25)
+#define S3C_CIIMGCPT_CPT_FREN_CO_DISABLE		(0 << 25)
+#define S3C_CIIMGCPT_CPT_FREN_PR_ENABLE			(1 << 24)
+#define S3C_CIIMGCPT_CPT_FREN_PR_DISABLE		(0 << 24)
+#define S3C_CIIMGCPT_CPT_FRMOD_CNT			(1 << 18)
+#define S3C_CIIMGCPT_CPT_FRMOD_EN			(0 << 18)
+#endif
+
+/* Image Effects Register */
+#define S3C_CIIMGEFF_IE_ON_PR_ENABLE			(1 << 31)
+#define S3C_CIIMGEFF_IE_ON_PR_DISABLE			(0 << 31)
+
+#define S3C_CIIMGEFF_IE_ON_CO_ENABLE			(1 << 30)
+#define S3C_CIIMGEFF_IE_ON_CO_DISABLE			(0 << 30)
+
+#define S3C_CIIMGEFF_IE_AFTER_SC_BEFORE			(0 << 29)
+#define S3C_CIIMGEFF_IE_AFTER_SC_AFTER			(1 << 29)
+
+#define S3C_CIIMGEFF_FIN_SILHOUETTE			(5 << 26)
+#define S3C_CIIMGEFF_FIN_EMBOSSING			(4 << 26)
+#define S3C_CIIMGEFF_FIN_ARTFREEZE			(3 << 26)
+#define S3C_CIIMGEFF_FIN_NEGATIVE			(2 << 26)
+#define S3C_CIIMGEFF_FIN_ARBITRARY			(1 << 26)
+#define S3C_CIIMGEFF_FIN_BYPASS				(0 << 26)
+
+/* MSDMA for Codec Source Image Width Register */
+#define S3C_MSCOWIDTH_AUTOLOAD_ENABLE			(1 << 31)
+#define S3C_MSCOWIDTH_AUTOLOAD_DISABLE			(0 << 31)
+
+#define S3C_MSCOWIDTH_ADDR_CH_ENABLE			(1 << 30)
+#define S3C_MSCOWIDTH_ADDR_CH_DISABLE			(0 << 30)
+
+/* MSDMA Control Register */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_CIMSCTRL_INTERLEAVE_MS_INTERLEAVE		(1 << 5)
+#define S3C_CIMSCTRL_INTERLEAVE_MS_NONINTERLEAVE	(0 << 5)
+#define S3C_CIMSCTRL_ORDER422_MS_CRYCBY			(3 << 3)
+#define S3C_CIMSCTRL_ORDER422_MS_CBYCRY			(2 << 3)
+#define S3C_CIMSCTRL_ORDER422_MS_YCRYCB			(1 << 3)
+#define S3C_CIMSCTRL_ORDER422_MS_YCBYCR			(0 << 3)
+#define S3C_CIMSCTRL_SEL_DMA_CAM_MEMORY			(1 << 2)
+#define S3C_CIMSCTRL_SEL_DMA_CAM_EXTCAM			(0 << 2)
+#define S3C_CIMSCTRL_SRC420_MS_420			(1 << 1)
+#define S3C_CIMSCTRL_SRC420_MS_422			(0 << 1)
+#define S3C_CIMSCTRL_ENVID_MS_SET			(1 << 0)
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410
+#define S3C_MSCOCTRL_BC_SEL_FRAME			(0 << 10)
+#define S3C_MSCOCTRL_BC_SEL_FIELD			(1 << 10)
+#define S3C_MSCOCTRL_BUFFER_INI_0			(0 << 8)
+#define S3C_MSCOCTRL_BUFFER_INI_1			(1 << 8)
+#define S3C_MSCOCTRL_TRG_MODE_SOFT			(0 << 7)
+#define S3C_MSCOCTRL_TRG_MODE_HARD			(1 << 7)
+#define S3C_MSCOCTRL_ORDER422_M_C_YCBYCR		(0 << 4)
+#define S3C_MSCOCTRL_ORDER422_M_C_YCRYCB		(1 << 4)
+#define S3C_MSCOCTRL_ORDER422_M_C_CBYCRY		(2 << 4)
+#define S3C_MSCOCTRL_ORDER422_M_C_CRYCBY		(3 << 4)
+#define S3C_MSCOCTRL_SEL_DMA_CAM_C_EXTCAM		(0 << 3)
+#define S3C_MSCOCTRL_SEL_DMA_CAM_C_MEMORY		(1 << 3)
+#define S3C_MSCOCTRL_INFORMAT_M_C_420			(0 << 1)
+#define S3C_MSCOCTRL_INFORMAT_M_C_422			(1 << 1)
+#define S3C_MSCOCTRL_INFORMAT_M_C_422_INT		(2 << 1)
+#define S3C_MSCOCTRL_INFORMAT_M_C_RGB			(3 << 1)
+#define S3C_MSCOCTRL_ENVID_M_C_SET			(1 << 0)
+#define S3C_MSPRCTRL_BC_SEL_FIELD			(0 << 10)
+#define S3C_MSPRCTRL_BC_SEL_FRAME			(1 << 10)
+#define S3C_MSPRCTRL_BUFFER_INI_0			(0 << 8)
+#define S3C_MSPRCTRL_BUFFER_INI_1			(1 << 8)
+#define S3C_MSPRCTRL_TRG_MODE_SOFT			(0 << 7)
+#define S3C_MSPRCTRL_TRG_MODE_HARD			(1 << 7)
+#define S3C_MSPRCTRL_ORDER422_M_P_YCBYCR		(0 << 4)
+#define S3C_MSPRCTRL_ORDER422_M_P_YCRYCB		(1 << 4)
+#define S3C_MSPRCTRL_ORDER422_M_P_CBYCRY		(2 << 4)
+#define S3C_MSPRCTRL_ORDER422_M_P_CRYCBY		(3 << 4)
+#define S3C_MSPRCTRL_SEL_DMA_CAM_P_EXTCAM		(0 << 3)
+#define S3C_MSPRCTRL_SEL_DMA_CAM_P_MEMORY		(1 << 3)
+#define S3C_MSPRCTRL_INFORMAT_M_P_420			(0 << 1)
+#define S3C_MSPRCTRL_INFORMAT_M_P_422			(1 << 1)
+#define S3C_MSPRCTRL_INFORMAT_M_P_422_INT		(2 << 1)
+#define S3C_MSPRCTRL_INFORMAT_M_P_RGB			(3 << 1)
+#define S3C_MSPRCTRL_ENVID_M_P_SET			(1 << 0)
+#endif
+
+/*************************************************************************
+ * Register part
+ ************************************************************************/
+#define S3C_CICOYSA(__x) 	S3C_CAMIFREG(0x18 + (__x) * 4)
+#define S3C_CICOCBSA(__x) 	S3C_CAMIFREG(0x28 + (__x) * 4)
+#define S3C_CICOCRSA(__x)  	S3C_CAMIFREG(0x38 + (__x) * 4)
+#define S3C_CIPRCLRSA(__x)  	S3C_CAMIFREG(0x6C + (__x) * 4)
+#define S3C_CIPRYSA(__x)     	S3C_CAMIFREG(0x6C + (__x) * 4)
+#define S3C_CIPRCBSA(__x)   	S3C_CAMIFREG(0x7C + (__x) * 4)
+#define S3C_CIPRCRSA(__x)   	S3C_CAMIFREG(0x8C + (__x) * 4)
+
+#define S3C_CISRCFMT		S3C_CAMIFREG(0x00)
+#define S3C_CIWDOFST		S3C_CAMIFREG(0x04)
+#define S3C_CIGCTRL		S3C_CAMIFREG(0x08)
+#define S3C_CIDOWSFT2		S3C_CAMIFREG(0x14)
+#define S3C_CICOYSA1		S3C_CAMIFREG(0x18)
+#define S3C_CICOYSA2		S3C_CAMIFREG(0x1C)
+#define S3C_CICOYSA3		S3C_CAMIFREG(0x20)
+#define S3C_CICOYSA4		S3C_CAMIFREG(0x24)
+#define S3C_CICOCBSA1		S3C_CAMIFREG(0x28)
+#define S3C_CICOCBSA2		S3C_CAMIFREG(0x2C)
+#define S3C_CICOCBSA3		S3C_CAMIFREG(0x30)
+#define S3C_CICOCBSA4		S3C_CAMIFREG(0x34)
+#define S3C_CICOCRSA1		S3C_CAMIFREG(0x38)
+#define S3C_CICOCRSA2		S3C_CAMIFREG(0x3C)
+#define S3C_CICOCRSA3		S3C_CAMIFREG(0x40)
+#define S3C_CICOCRSA4		S3C_CAMIFREG(0x44)
+#define S3C_CICOTRGFMT		S3C_CAMIFREG(0x48)	/* CODEC target format */
+#define S3C_CICOCTRL		S3C_CAMIFREG(0x4C)	/* CODEC DMA control register */
+#define S3C_CICOSCPRERATIO	S3C_CAMIFREG(0x50)	/* CODEC pre-scaler control register 1 */
+#define S3C_CICOSCPREDST	S3C_CAMIFREG(0x54)	/* CODEC pre-scaler control register 2 */
+#define S3C_CICOSCCTRL		S3C_CAMIFREG(0x58)	/* CODEC main-scaler control */
+#define S3C_CICOTAREA		S3C_CAMIFREG(0x5C)	/* CODEC DMA target area register */
+#define S3C_CICOSTATUS		S3C_CAMIFREG(0x64)	/* CODEC status register */
+
+#if defined (CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define S3C_CIPRCLRSA1		S3C_CAMIFREG(0x6C)	/* RGB 1st frame start address for preview DMA */
+#define S3C_CIPRCLRSA2		S3C_CAMIFREG(0x70)	/* RGB 2nd frame start address for preview DMA */
+#define S3C_CIPRCLRSA3		S3C_CAMIFREG(0x74)	/* RGB 3rd frame start address for preview DMA */
+#define S3C_CIPRCLRSA4		S3C_CAMIFREG(0x78)	/* RGB 4th frame start address for preview DMA */
+#define S3C_CIPRTRGFMT		S3C_CAMIFREG(0x7C)	/* PREVIEW target format register */
+#define S3C_CIPRCTRL		S3C_CAMIFREG(0x80)	/* PREVIEW DMA control register */
+#define S3C_CIPRSCPRERATIO	S3C_CAMIFREG(0x84)	/* PREVIEW pre-scaler control register 1 */
+#define S3C_CIPRSCPREDST	S3C_CAMIFREG(0x88)	/* PREVIEW pre-scaler control register 2 */
+#define S3C_CIPRSCCTRL		S3C_CAMIFREG(0x8C)	/* PREVIEW main-scaler control register */
+#define S3C_CIPRTAREA		S3C_CAMIFREG(0x90)	/* PREVIEW DMA target area register */
+#define S3C_CIPRSTATUS		S3C_CAMIFREG(0x98)	/* PREVIEW status register */
+#define S3C_CIIMGCPT		S3C_CAMIFREG(0xA0)	/* image capture enable register */
+#define S3C_CICOCPTSEQ		S3C_CAMIFREG(0xA4)	/* CODEC capture sequence register */
+#define S3C_CICOSCOS		S3C_CAMIFREG(0xA8)	/* CODEC scan line offset register */
+#define S3C_CIIMGEFF		S3C_CAMIFREG(0xB0)	/* image effect register */
+#define S3C_CIMSYSA		S3C_CAMIFREG(0xB4)	/* MSDMA Y start address register */
+#define S3C_CIMSCBSA		S3C_CAMIFREG(0xB8)	/* MSDMA CB start address register */
+#define S3C_CIMSCRSA		S3C_CAMIFREG(0xBC)	/* MSDMA CR start address register */
+#define S3C_CIMSYEND		S3C_CAMIFREG(0xC0)	/* MSDMA Y end address register */
+#define S3C_CIMSCBEND		S3C_CAMIFREG(0xC4)	/* MSDMA CB end address register */
+#define S3C_CIMSCREND		S3C_CAMIFREG(0xC8)	/* MSDMA CR end address register */
+#define S3C_CIMSYOFF		S3C_CAMIFREG(0xCC)	/* MSDMA Y offset register */
+#define S3C_CIMSCBOFF		S3C_CAMIFREG(0xD0)	/* MSDMA CB offset register */
+#define S3C_CIMSCROFF		S3C_CAMIFREG(0xD4)	/* MSDMA CR offset register */
+#define S3C_CIMSWIDTH		S3C_CAMIFREG(0xD8)	/* MSDMA source image width register */
+#define S3C_CIMSCTRL		S3C_CAMIFREG(0xDC)	/* MSDMA control register */
+
+#elif defined CONFIG_CPU_S3C6400 || defined CONFIG_CPU_S3C6410
+#define S3C_CIPRYSA1		S3C_CAMIFREG(0x6C)	/* 1st frame start address for preview DMA */
+#define S3C_CIPRYSA2		S3C_CAMIFREG(0x70)	/* 2nd frame start address for preview DMA */
+#define S3C_CIPRYSA3		S3C_CAMIFREG(0x74)	/* 3rd frame start address for preview DMA */
+#define S3C_CIPRYSA4		S3C_CAMIFREG(0x78)	/* 4th frame start address for preview DMA */
+#define S3C_CIPRCBSA1		S3C_CAMIFREG(0x7C)	/* 1st frame start address for preview DMA */
+#define S3C_CIPRCBSA2		S3C_CAMIFREG(0x80)	/* 2nd frame start address for preview DMA */
+#define S3C_CIPRCBSA3		S3C_CAMIFREG(0x84)	/* 3rd frame start address for preview DMA */
+#define S3C_CIPRCBSA4		S3C_CAMIFREG(0x88)	/* 4th frame start address for preview DMA */
+#define S3C_CIPRCRSA1		S3C_CAMIFREG(0x8C)	/* 1st frame start address for preview DMA */
+#define S3C_CIPRCRSA2		S3C_CAMIFREG(0x90)	/* 2nd frame start address for preview DMA */
+#define S3C_CIPRCRSA3		S3C_CAMIFREG(0x94)	/* 3rd frame start address for preview DMA */
+#define S3C_CIPRCRSA4		S3C_CAMIFREG(0x98)	/* 4th frame start address for preview DMA */
+#define S3C_CIPRTRGFMT		S3C_CAMIFREG(0x9C)	/* PREVIEW target format register */
+#define S3C_CIPRCTRL		S3C_CAMIFREG(0xA0)	/* PREVIEW DMA control register */
+#define S3C_CIPRSCPRERATIO	S3C_CAMIFREG(0xA4)	/* PREVIEW pre-scaler control register 1 */
+#define S3C_CIPRSCPREDST	S3C_CAMIFREG(0xA8)	/* PREVIEW pre-scaler control register 2 */
+#define S3C_CIPRSCCTRL		S3C_CAMIFREG(0xAC)	/* PREVIEW main-scaler control register */
+#define S3C_CIPRTAREA		S3C_CAMIFREG(0xB0)	/* PREVIEW DMA target area register */
+#define S3C_CIPRSTATUS		S3C_CAMIFREG(0xB8)	/* PREVIEW status register */
+#define S3C_CIIMGCPT		S3C_CAMIFREG(0xC0)	/* image capture enable register */
+#define S3C_CICOCPTSEQ		S3C_CAMIFREG(0xC4)	/* CODEC capture sequence register */
+#define S3C_CIIMGEFF		S3C_CAMIFREG(0xD0)	/* image effect register */
+#define S3C_MSCOY0SA		S3C_CAMIFREG(0xD4)	/* MSDMA for CODEC Y start address register */
+#define S3C_MSCOCB0SA		S3C_CAMIFREG(0xD8)	/* MSDMA for CODEC CB start address register */
+#define S3C_MSCOCR0SA		S3C_CAMIFREG(0xDC)	/* MSDMA for CODEC CR start address register */
+#define S3C_MSCOY0END		S3C_CAMIFREG(0xE0)	/* MSDMA for CODEC Y end address register */
+#define S3C_MSCOCB0END		S3C_CAMIFREG(0xE4)	/* MSDMA for CODEC CB end address register */
+#define S3C_MSCOCR0END		S3C_CAMIFREG(0xE8)	/* MSDMA for CODEC CR end address register */
+#define S3C_MSCOYOFF		S3C_CAMIFREG(0xEC)	/* MSDMA for CODEC Y offset register */
+#define S3C_MSCOCBOFF		S3C_CAMIFREG(0xF0)	/* MSDMA for CODEC CB offset register */
+#define S3C_MSCOCROFF		S3C_CAMIFREG(0xF4)	/* MSDMA for CODEC CR offset register */
+#define S3C_MSCOWIDTH		S3C_CAMIFREG(0xF8)	/* MSDMA for CODEC source image width register */
+#define S3C_MSCOCTRL		S3C_CAMIFREG(0xFC)	/* MSDMA for CODEC control register */
+#define S3C_MSPRY0SA		S3C_CAMIFREG(0x100)	/* MSDMA for PREVIEW Y0 start address register */
+#define S3C_MSPRCB0SA		S3C_CAMIFREG(0x104)	/* MSDMA for PREVIEW CB0 start address register */
+#define S3C_MSPRCR0SA		S3C_CAMIFREG(0x108)	/* MSDMA for PREVIEW CR0 start address register */
+#define S3C_MSPRY0END		S3C_CAMIFREG(0x10C)	/* MSDMA for PREVIEW Y0 end address register */
+#define S3C_MSPRCB0END		S3C_CAMIFREG(0x110)	/* MSDMA for PREVIEW CB0 end address register */
+#define S3C_MSPRCR0END		S3C_CAMIFREG(0x114)	/* MSDMA for PREVIEW CR0 end address register */
+#define S3C_MSPRYOFF		S3C_CAMIFREG(0x118)	/* MSDMA for PREVIEW Y offset register */
+#define S3C_MSPRCBOFF		S3C_CAMIFREG(0x11C)	/* MSDMA for PREVIEW CB offset register */
+#define S3C_MSPRCROFF		S3C_CAMIFREG(0x120)	/* MSDMA for PREVIEW CR offset register */
+#define S3C_MSPRWIDTH		S3C_CAMIFREG(0x124)	/* MSDMA for PREVIEW source image width register */
+#define S3C_CIMSCTRL		S3C_CAMIFREG(0x128)	/* MSDMA for PREVIEW control register */
+#define S3C_CICOSCOSY		S3C_CAMIFREG(0x12C)	/* CODEC scan line Y offset register */
+#define S3C_CICOSCOSCB		S3C_CAMIFREG(0x130)	/* CODEC scan line CB offset register */
+#define S3C_CICOSCOSCR		S3C_CAMIFREG(0x134)	/* CODEC scan line CR offset register */
+#define S3C_CIPRSCOSY		S3C_CAMIFREG(0x138)	/* PREVIEW scan line Y offset register */
+#define S3C_CIPRSCOSCB		S3C_CAMIFREG(0x13C)	/* PREVIEW scan line CB offset register */
+#define S3C_CIPRSCOSCR		S3C_CAMIFREG(0x140)	/* PREVIEW scan line CR offset register */
+#endif
+
+#endif /* ___ASM_ARCH_REGS_CAMIF_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-clock.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-clock.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-clock.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-clock.h	2009-05-10 22:27:59.000000000 +0200
@@ -32,6 +32,7 @@
 #define S3C_HCLK_GATE		S3C_CLKREG(0x30)
 #define S3C_PCLK_GATE		S3C_CLKREG(0x34)
 #define S3C_SCLK_GATE		S3C_CLKREG(0x38)
+#define S3C_MEM0_GATE		S3C_CLKREG(0x3C)
 
 /* CLKDIV0 */
 #define S3C6400_CLKDIV0_MFC_MASK	(0xf << 28)
@@ -88,10 +89,10 @@
 
 /* HCLK GATE Registers */
 #define S3C_CLKCON_HCLK_BUS	(1<<30)
-#define S3C_CLKCON_HCLK_SECUR	(1<<29)
-#define S3C_CLKCON_HCLK_SDMA1	(1<<28)
-#define S3C_CLKCON_HCLK_SDMA2	(1<<27)
-#define S3C_CLKCON_HCLK_UHOST	(1<<26)
+#define S3C_CLKCON_HCLK_UHOST	(1<<29)
+#define S3C_CLKCON_HCLK_SECUR	(1<<28)
+#define S3C_CLKCON_HCLK_SDMA1	(1<<27)
+#define S3C_CLKCON_HCLK_SDMA0	(1<<26)
 #define S3C_CLKCON_HCLK_IROM	(1<<25)
 #define S3C_CLKCON_HCLK_DDR1	(1<<24)
 #define S3C_CLKCON_HCLK_DDR0	(1<<23)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-gpio.h	2009-05-10 22:27:59.000000000 +0200
@@ -13,23 +13,175 @@
 
 /* Base addresses for each of the banks */
 
-#define S3C64XX_GPA_BASE	(S3C64XX_VA_GPIO + 0x0000)
-#define S3C64XX_GPB_BASE	(S3C64XX_VA_GPIO + 0x0020)
-#define S3C64XX_GPC_BASE	(S3C64XX_VA_GPIO + 0x0040)
-#define S3C64XX_GPD_BASE	(S3C64XX_VA_GPIO + 0x0060)
-#define S3C64XX_GPE_BASE	(S3C64XX_VA_GPIO + 0x0080)
-#define S3C64XX_GPF_BASE	(S3C64XX_VA_GPIO + 0x00A0)
-#define S3C64XX_GPG_BASE	(S3C64XX_VA_GPIO + 0x00C0)
-#define S3C64XX_GPH_BASE	(S3C64XX_VA_GPIO + 0x00E0)
-#define S3C64XX_GPI_BASE	(S3C64XX_VA_GPIO + 0x0100)
-#define S3C64XX_GPJ_BASE	(S3C64XX_VA_GPIO + 0x0120)
-#define S3C64XX_GPK_BASE	(S3C64XX_VA_GPIO + 0x0800)
-#define S3C64XX_GPL_BASE	(S3C64XX_VA_GPIO + 0x0810)
-#define S3C64XX_GPM_BASE	(S3C64XX_VA_GPIO + 0x0820)
-#define S3C64XX_GPN_BASE	(S3C64XX_VA_GPIO + 0x0830)
-#define S3C64XX_GPO_BASE	(S3C64XX_VA_GPIO + 0x0140)
-#define S3C64XX_GPP_BASE	(S3C64XX_VA_GPIO + 0x0160)
-#define S3C64XX_GPQ_BASE	(S3C64XX_VA_GPIO + 0x0180)
+#define S3C64XX_GPIOREG(reg)	(S3C64XX_VA_GPIO + (reg))
+
+#define S3C64XX_GPA_BASE	S3C64XX_GPIOREG(0x0000)
+#define S3C64XX_GPB_BASE	S3C64XX_GPIOREG(0x0020)
+#define S3C64XX_GPC_BASE	S3C64XX_GPIOREG(0x0040)
+#define S3C64XX_GPD_BASE	S3C64XX_GPIOREG(0x0060)
+#define S3C64XX_GPE_BASE	S3C64XX_GPIOREG(0x0080)
+#define S3C64XX_GPF_BASE	S3C64XX_GPIOREG(0x00A0)
+#define S3C64XX_GPG_BASE	S3C64XX_GPIOREG(0x00C0)
+#define S3C64XX_GPH_BASE	S3C64XX_GPIOREG(0x00E0)
+#define S3C64XX_GPI_BASE	S3C64XX_GPIOREG(0x0100)
+#define S3C64XX_GPJ_BASE	S3C64XX_GPIOREG(0x0120)
+#define S3C64XX_GPK_BASE	S3C64XX_GPIOREG(0x0800)
+#define S3C64XX_GPL_BASE	S3C64XX_GPIOREG(0x0810)
+#define S3C64XX_GPM_BASE	S3C64XX_GPIOREG(0x0820)
+#define S3C64XX_GPN_BASE	S3C64XX_GPIOREG(0x0830)
+#define S3C64XX_GPO_BASE	S3C64XX_GPIOREG(0x0140)
+#define S3C64XX_GPP_BASE	S3C64XX_GPIOREG(0x0160)
+#define S3C64XX_GPQ_BASE	S3C64XX_GPIOREG(0x0180)
+
+/* SPCON */
+
+#define S3C64XX_SPCON		S3C64XX_GPIOREG(0x1A0)
+
+#define S3C64XX_SPCON_DRVCON_CAM_MASK		(0x3 << 30)
+#define S3C64XX_SPCON_DRVCON_CAM_SHIFT		(30)
+#define S3C64XX_SPCON_DRVCON_CAM_2mA		(0x0 << 30)
+#define S3C64XX_SPCON_DRVCON_CAM_4mA		(0x1 << 30)
+#define S3C64XX_SPCON_DRVCON_CAM_7mA		(0x2 << 30)
+#define S3C64XX_SPCON_DRVCON_CAM_9mA		(0x3 << 30)
+
+#define S3C64XX_SPCON_DRVCON_HSSPI_MASK		(0x3 << 28)
+#define S3C64XX_SPCON_DRVCON_HSSPI_SHIFT	(28)
+#define S3C64XX_SPCON_DRVCON_HSSPI_2mA		(0x0 << 28)
+#define S3C64XX_SPCON_DRVCON_HSSPI_4mA		(0x1 << 28)
+#define S3C64XX_SPCON_DRVCON_HSSPI_7mA		(0x2 << 28)
+#define S3C64XX_SPCON_DRVCON_HSSPI_9mA		(0x3 << 28)
+
+#define S3C64XX_SPCON_DRVCON_HSMMC_MASK		(0x3 << 26)
+#define S3C64XX_SPCON_DRVCON_HSMMC_SHIFT	(26)
+#define S3C64XX_SPCON_DRVCON_HSMMC_2mA		(0x0 << 26)
+#define S3C64XX_SPCON_DRVCON_HSMMC_4mA		(0x1 << 26)
+#define S3C64XX_SPCON_DRVCON_HSMMC_7mA		(0x2 << 26)
+#define S3C64XX_SPCON_DRVCON_HSMMC_9mA		(0x3 << 26)
+
+#define S3C64XX_SPCON_DRVCON_LCD_MASK		(0x3 << 24)
+#define S3C64XX_SPCON_DRVCON_LCD_SHIFT		(24)
+#define S3C64XX_SPCON_DRVCON_LCD_2mA		(0x0 << 24)
+#define S3C64XX_SPCON_DRVCON_LCD_4mA		(0x1 << 24)
+#define S3C64XX_SPCON_DRVCON_LCD_7mA		(0x2 << 24)
+#define S3C64XX_SPCON_DRVCON_LCD_9mA		(0x3 << 24)
+
+#define S3C64XX_SPCON_DRVCON_MODEM_MASK		(0x3 << 22)
+#define S3C64XX_SPCON_DRVCON_MODEM_SHIFT	(22)
+#define S3C64XX_SPCON_DRVCON_MODEM_2mA		(0x0 << 22)
+#define S3C64XX_SPCON_DRVCON_MODEM_4mA		(0x1 << 22)
+#define S3C64XX_SPCON_DRVCON_MODEM_7mA		(0x2 << 22)
+#define S3C64XX_SPCON_DRVCON_MODEM_9mA		(0x3 << 22)
+
+#define S3C64XX_SPCON_nRSTOUT_OEN		(1 << 21)
+
+#define S3C64XX_SPCON_DRVCON_SPICLK1_MASK	(0x3 << 18)
+#define S3C64XX_SPCON_DRVCON_SPICLK1_SHIFT	(18)
+#define S3C64XX_SPCON_DRVCON_SPICLK1_2mA	(0x0 << 18)
+#define S3C64XX_SPCON_DRVCON_SPICLK1_4mA	(0x1 << 18)
+#define S3C64XX_SPCON_DRVCON_SPICLK1_7mA	(0x2 << 18)
+#define S3C64XX_SPCON_DRVCON_SPICLK1_9mA	(0x3 << 18)
+
+#define S3C64XX_SPCON_MEM1_DQS_PUD_MASK		(0x3 << 16)
+#define S3C64XX_SPCON_MEM1_DQS_PUD_SHIFT	(16)
+#define S3C64XX_SPCON_MEM1_DQS_PUD_DISABLED	(0x0 << 16)
+#define S3C64XX_SPCON_MEM1_DQS_PUD_DOWN		(0x1 << 16)
+#define S3C64XX_SPCON_MEM1_DQS_PUD_UP		(0x2 << 16)
+
+#define S3C64XX_SPCON_MEM1_D_PUD1_MASK		(0x3 << 14)
+#define S3C64XX_SPCON_MEM1_D_PUD1_SHIFT		(14)
+#define S3C64XX_SPCON_MEM1_D_PUD1_DISABLED	(0x0 << 14)
+#define S3C64XX_SPCON_MEM1_D_PUD1_DOWN		(0x1 << 14)
+#define S3C64XX_SPCON_MEM1_D_PUD1_UP		(0x2 << 14)
+
+#define S3C64XX_SPCON_MEM1_D_PUD0_MASK		(0x3 << 12)
+#define S3C64XX_SPCON_MEM1_D_PUD0_SHIFT		(12)
+#define S3C64XX_SPCON_MEM1_D_PUD0_DISABLED	(0x0 << 12)
+#define S3C64XX_SPCON_MEM1_D_PUD0_DOWN		(0x1 << 12)
+#define S3C64XX_SPCON_MEM1_D_PUD0_UP		(0x2 << 12)
+
+#define S3C64XX_SPCON_MEM0_D_PUD_MASK		(0x3 << 8)
+#define S3C64XX_SPCON_MEM0_D_PUD_SHIFT		(8)
+#define S3C64XX_SPCON_MEM0_D_PUD_DISABLED	(0x0 << 8)
+#define S3C64XX_SPCON_MEM0_D_PUD_DOWN		(0x1 << 8)
+#define S3C64XX_SPCON_MEM0_D_PUD_UP		(0x2 << 8)
+
+#define S3C64XX_SPCON_USBH_DMPD			(1 << 7)
+#define S3C64XX_SPCON_USBH_DPPD			(1 << 6)
+#define S3C64XX_SPCON_USBH_PUSW2		(1 << 5)
+#define S3C64XX_SPCON_USBH_PUSW1		(1 << 4)
+#define S3C64XX_SPCON_USBH_SUSPND		(1 << 3)
+
+#define S3C64XX_SPCON_LCD_SEL_MASK		(0x3 << 0)
+#define S3C64XX_SPCON_LCD_SEL_SHIFT		(0)
+#define S3C64XX_SPCON_LCD_SEL_HOST		(0x0 << 0)
+#define S3C64XX_SPCON_LCD_SEL_RGB		(0x1 << 0)
+#define S3C64XX_SPCON_LCD_SEL_606_656		(0x2 << 0)
+
+
+/* External interrupt registers */
+
+#define S3C64XX_EINT12CON	S3C64XX_GPIOREG(0x200)
+#define S3C64XX_EINT34CON	S3C64XX_GPIOREG(0x204)
+#define S3C64XX_EINT56CON	S3C64XX_GPIOREG(0x208)
+#define S3C64XX_EINT78CON	S3C64XX_GPIOREG(0x20C)
+#define S3C64XX_EINT9CON	S3C64XX_GPIOREG(0x210)
+
+#define S3C64XX_EINT12FLTCON	S3C64XX_GPIOREG(0x220)
+#define S3C64XX_EINT34FLTCON	S3C64XX_GPIOREG(0x224)
+#define S3C64XX_EINT56FLTCON	S3C64XX_GPIOREG(0x228)
+#define S3C64XX_EINT78FLTCON	S3C64XX_GPIOREG(0x22C)
+#define S3C64XX_EINT9FLTCON	S3C64XX_GPIOREG(0x230)
+
+#define S3C64XX_EINT12MASK	S3C64XX_GPIOREG(0x240)
+#define S3C64XX_EINT34MASK	S3C64XX_GPIOREG(0x244)
+#define S3C64XX_EINT56MASK	S3C64XX_GPIOREG(0x248)
+#define S3C64XX_EINT78MASK	S3C64XX_GPIOREG(0x24C)
+#define S3C64XX_EINT9MASK	S3C64XX_GPIOREG(0x250)
+
+#define S3C64XX_EINT12PEND	S3C64XX_GPIOREG(0x260)
+#define S3C64XX_EINT34PEND	S3C64XX_GPIOREG(0x264)
+#define S3C64XX_EINT56PEND	S3C64XX_GPIOREG(0x268)
+#define S3C64XX_EINT78PEND	S3C64XX_GPIOREG(0x26C)
+#define S3C64XX_EINT9PEND	S3C64XX_GPIOREG(0x270)
+
+#define S3C64XX_PRIORITY	S3C64XX_GPIOREG(0x280)
+#define S3C64XX_PRIORITY_ARB(x)	(1 << (x))
+
+#define S3C64XX_SERVICE		S3C64XX_GPIOREG(0x284)
+#define S3C64XX_SERVICEPEND	S3C64XX_GPIOREG(0x288)
+
+#define S3C64XX_EINT0CON0	S3C64XX_GPIOREG(0x900)
+#define S3C64XX_EINT0CON1	S3C64XX_GPIOREG(0x904)
+#define S3C64XX_EINT0FLTCON0	S3C64XX_GPIOREG(0x910)
+#define S3C64XX_EINT0FLTCON1	S3C64XX_GPIOREG(0x914)
+#define S3C64XX_EINT0FLTCON2	S3C64XX_GPIOREG(0x918)
+#define S3C64XX_EINT0FLTCON3	S3C64XX_GPIOREG(0x91C)
+
+#define S3C64XX_EINT0MASK	S3C64XX_GPIOREG(0x920)
+#define S3C64XX_EINT0PEND	S3C64XX_GPIOREG(0x924)
+
+/* GPIO sleep configuration */
+
+#define S3C64XX_SPCONSLP	S3C64XX_GPIOREG(0x880)
+
+#define S3C64XX_SPCONSLP_TDO_PULLDOWN	(1 << 14)
+#define S3C64XX_SPCONSLP_CKE1INIT	(1 << 5)
+
+#define S3C64XX_SPCONSLP_RSTOUT_MASK	(0x3 << 12)
+#define S3C64XX_SPCONSLP_RSTOUT_OUT0	(0x0 << 12)
+#define S3C64XX_SPCONSLP_RSTOUT_OUT1	(0x1 << 12)
+#define S3C64XX_SPCONSLP_RSTOUT_HIZ	(0x2 << 12)
+
+#define S3C64XX_SPCONSLP_KPCOL_MASK	(0x3 << 0)
+#define S3C64XX_SPCONSLP_KPCOL_OUT0	(0x0 << 0)
+#define S3C64XX_SPCONSLP_KPCOL_OUT1	(0x1 << 0)
+#define S3C64XX_SPCONSLP_KPCOL_INP	(0x2 << 0)
+
+
+#define S3C64XX_SLPEN		S3C64XX_GPIOREG(0x930)
+
+#define S3C64XX_SLPEN_USE_xSLP		(1 << 0)
+#define S3C64XX_SLPEN_CFG_BYSLPEN	(1 << 1)
 
 #endif /* __ASM_PLAT_S3C64XX_REGS_GPIO_H */
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-gpio-memport.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-gpio-memport.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-gpio-memport.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-gpio-memport.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,25 @@
+/* linux/arch/arm/plat-s3c64xx/include/mach/regs-gpio-memport.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX - GPIO memory port register definitions
+ */
+
+#ifndef __ASM_PLAT_S3C64XX_REGS_GPIO_MEMPORT_H
+#define __ASM_PLAT_S3C64XX_REGS_GPIO_MEMPORT_H __FILE__
+
+#define S3C64XX_MEM0CONSTOP	S3C64XX_GPIOREG(0x1B0)
+#define S3C64XX_MEM1CONSTOP	S3C64XX_GPIOREG(0x1B4)
+
+#define S3C64XX_MEM0CONSLP0	S3C64XX_GPIOREG(0x1C0)
+#define S3C64XX_MEM0CONSLP1	S3C64XX_GPIOREG(0x1C4)
+#define S3C64XX_MEM1CONSLP	S3C64XX_GPIOREG(0x1C8)
+
+#define S3C64XX_MEM0DRVCON	S3C64XX_GPIOREG(0x1D0)
+#define S3C64XX_MEM1DRVCON	S3C64XX_GPIOREG(0x1D4)
+
+#endif /* __ASM_PLAT_S3C64XX_REGS_GPIO_MEMPORT_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-modem.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-modem.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-modem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-modem.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,31 @@
+/* arch/arm/plat-s3c64xx/include/plat/regs-modem.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      http://armlinux.simtec.co.uk/
+ *      Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C64XX - modem block registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __PLAT_S3C64XX_REGS_MODEM_H
+#define __PLAT_S3C64XX_REGS_MODEM_H __FILE__
+
+#define S3C64XX_MODEMREG(x)	(S3C64XX_VA_MODEM + (x))
+
+#define S3C64XX_MODEM_INT2AP			S3C64XX_MODEMREG(0x0)
+#define S3C64XX_MODEM_INT2MODEM			S3C64XX_MODEMREG(0x4)
+#define S3C64XX_MODEM_MIFCON			S3C64XX_MODEMREG(0x8)
+#define S3C64XX_MODEM_MIFPCON			S3C64XX_MODEMREG(0xC)
+#define S3C64XX_MODEM_INTCLR			S3C64XX_MODEMREG(0x10)
+#define S3C64XX_MODEM_DMA_TXADDR		S3C64XX_MODEMREG(0x14)
+#define S3C64XX_MODEM_DMA_RXADDR		S3C64XX_MODEMREG(0x18)
+
+#define MIFPCON_INT2M_LEVEL			(1 << 4)
+#define MIFPCON_LCD_BYPASS			(1 << 3)
+
+#endif /* __PLAT_S3C64XX_REGS_MODEM_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-syscon-power.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-syscon-power.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-syscon-power.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-syscon-power.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,116 @@
+/* arch/arm/plat-s3c64xx/include/plat/regs-syscon-power.h
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      http://armlinux.simtec.co.uk/
+ *      Ben Dooks <ben@simtec.co.uk>
+ *
+ * S3C64XX - syscon power and sleep control registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#ifndef __PLAT_S3C64XX_REGS_SYSCON_POWER_H
+#define __PLAT_S3C64XX_REGS_SYSCON_POWER_H __FILE__
+
+#define S3C64XX_PWR_CFG				S3C_SYSREG(0x804)
+
+#define S3C64XX_PWRCFG_OSC_OTG_DISABLE		(1 << 17)
+#define S3C64XX_PWRCFG_MMC2_DISABLE		(1 << 16)
+#define S3C64XX_PWRCFG_MMC1_DISABLE		(1 << 15)
+#define S3C64XX_PWRCFG_MMC0_DISABLE		(1 << 14)
+#define S3C64XX_PWRCFG_HSI_DISABLE		(1 << 13)
+#define S3C64XX_PWRCFG_TS_DISABLE		(1 << 12)
+#define S3C64XX_PWRCFG_RTC_TICK_DISABLE		(1 << 11)
+#define S3C64XX_PWRCFG_RTC_ALARM_DISABLE	(1 << 10)
+#define S3C64XX_PWRCFG_MSM_DISABLE		(1 << 9)
+#define S3C64XX_PWRCFG_KEY_DISABLE		(1 << 8)
+#define S3C64XX_PWRCFG_BATF_DISABLE		(1 << 7)
+
+#define S3C64XX_PWRCFG_CFG_WFI_MASK		(0x3 << 5)
+#define S3C64XX_PWRCFG_CFG_WFI_SHIFT		(5)
+#define S3C64XX_PWRCFG_CFG_WFI_IGNORE		(0x0 << 5)
+#define S3C64XX_PWRCFG_CFG_WFI_IDLE		(0x1 << 5)
+#define S3C64XX_PWRCFG_CFG_WFI_STOP		(0x2 << 5)
+#define S3C64XX_PWRCFG_CFG_WFI_SLEEP		(0x3 << 5)
+
+#define S3C64XX_PWRCFG_CFG_BATFLT_MASK		(0x3 << 3)
+#define S3C64XX_PWRCFG_CFG_BATFLT_SHIFT		(3)
+#define S3C64XX_PWRCFG_CFG_BATFLT_IGNORE	(0x0 << 3)
+#define S3C64XX_PWRCFG_CFG_BATFLT_IRQ		(0x1 << 3)
+#define S3C64XX_PWRCFG_CFG_BATFLT_SLEEP		(0x3 << 3)
+
+#define S3C64XX_PWRCFG_CFG_BAT_WAKE		(1 << 2)
+#define S3C64XX_PWRCFG_OSC27_EN			(1 << 0)
+
+#define S3C64XX_EINT_MASK			S3C_SYSREG(0x808)
+
+#define S3C64XX_NORMAL_CFG			S3C_SYSREG(0x810)
+
+#define S3C64XX_NORMALCFG_IROM_ON		(1 << 30)
+#define S3C64XX_NORMALCFG_DOMAIN_ETM_ON		(1 << 16)
+#define S3C64XX_NORMALCFG_DOMAIN_S_ON		(1 << 15)
+#define S3C64XX_NORMALCFG_DOMAIN_F_ON		(1 << 14)
+#define S3C64XX_NORMALCFG_DOMAIN_P_ON		(1 << 13)
+#define S3C64XX_NORMALCFG_DOMAIN_I_ON		(1 << 12)
+#define S3C64XX_NORMALCFG_DOMAIN_G_ON		(1 << 10)
+#define S3C64XX_NORMALCFG_DOMAIN_V_ON		(1 << 9)
+
+#define S3C64XX_STOP_CFG			S3C_SYSREG(0x814)
+
+#define S3C64XX_STOPCFG_MEMORY_ARM_ON		(1 << 29)
+#define S3C64XX_STOPCFG_TOP_MEMORY_ON		(1 << 20)
+#define S3C64XX_STOPCFG_ARM_LOGIC_ON		(1 << 17)
+#define S3C64XX_STOPCFG_TOP_LOGIC_ON		(1 << 8)
+#define S3C64XX_STOPCFG_OSC_EN			(1 << 0)
+
+#define S3C64XX_SLEEP_CFG			S3C_SYSREG(0x818)
+
+#define S3C64XX_SLEEPCFG_OSC_EN			(1 << 0)
+
+#define S3C64XX_STOP_MEM_CFG			S3C_SYSREG(0x81c)
+
+#define S3C64XX_STOPMEMCFG_MODEMIF_RETAIN	(1 << 6)
+#define S3C64XX_STOPMEMCFG_HOSTIF_RETAIN	(1 << 5)
+#define S3C64XX_STOPMEMCFG_OTG_RETAIN		(1 << 4)
+#define S3C64XX_STOPMEMCFG_HSMCC_RETAIN		(1 << 3)
+#define S3C64XX_STOPMEMCFG_IROM_RETAIN		(1 << 2)
+#define S3C64XX_STOPMEMCFG_IRDA_RETAIN		(1 << 1)
+#define S3C64XX_STOPMEMCFG_NFCON_RETAIN		(1 << 0)
+
+#define S3C64XX_OSC_STABLE			S3C_SYSREG(0x824)
+#define S3C64XX_PWR_STABLE			S3C_SYSREG(0x828)
+
+#define S3C64XX_WAKEUP_STAT			S3C_SYSREG(0x908)
+
+#define S3C64XX_WAKEUPSTAT_MMC2			(1 << 11)
+#define S3C64XX_WAKEUPSTAT_MMC1			(1 << 10)
+#define S3C64XX_WAKEUPSTAT_MMC0			(1 << 9)
+#define S3C64XX_WAKEUPSTAT_HSI			(1 << 8)
+#define S3C64XX_WAKEUPSTAT_BATFLT		(1 << 6)
+#define S3C64XX_WAKEUPSTAT_MSM			(1 << 5)
+#define S3C64XX_WAKEUPSTAT_KEY			(1 << 4)
+#define S3C64XX_WAKEUPSTAT_TS			(1 << 3)
+#define S3C64XX_WAKEUPSTAT_RTC_TICK		(1 << 2)
+#define S3C64XX_WAKEUPSTAT_RTC_ALARM		(1 << 1)
+#define S3C64XX_WAKEUPSTAT_EINT			(1 << 0)
+
+#define S3C64XX_BLK_PWR_STAT			S3C_SYSREG(0x90c)
+
+#define S3C64XX_BLKPWRSTAT_G			(1 << 7)
+#define S3C64XX_BLKPWRSTAT_ETM			(1 << 6)
+#define S3C64XX_BLKPWRSTAT_S			(1 << 5)
+#define S3C64XX_BLKPWRSTAT_F			(1 << 4)
+#define S3C64XX_BLKPWRSTAT_P			(1 << 3)
+#define S3C64XX_BLKPWRSTAT_I			(1 << 2)
+#define S3C64XX_BLKPWRSTAT_V			(1 << 1)
+#define S3C64XX_BLKPWRSTAT_TOP			(1 << 0)
+
+#define S3C64XX_INFORM0				S3C_SYSREG(0xA00)
+#define S3C64XX_INFORM1				S3C_SYSREG(0xA04)
+#define S3C64XX_INFORM2				S3C_SYSREG(0xA08)
+#define S3C64XX_INFORM3				S3C_SYSREG(0xA0C)
+
+#endif /* __PLAT_S3C64XX_REGS_SYSCON_POWER_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-sys.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-sys.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/regs-sys.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/regs-sys.h	2009-05-10 22:27:59.000000000 +0200
@@ -17,6 +17,10 @@
 
 #define S3C_SYSREG(x)		(S3C_VA_SYS + (x))
 
+#define S3C64XX_AHB_CON0	S3C_SYSREG(0x100)
+#define S3C64XX_AHB_CON1	S3C_SYSREG(0x104)
+#define S3C64XX_AHB_CON2	S3C_SYSREG(0x108)
+
 #define S3C64XX_OTHERS		S3C_SYSREG(0x900)
 
 #define S3C64XX_OTHERS_USBMASK	(1 << 16)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/tzic-sp890.h linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/tzic-sp890.h
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/include/plat/tzic-sp890.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/include/plat/tzic-sp890.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,21 @@
+#ifndef __S3C64XX_TZIC_SP890_H__
+#define __S3C64XX_TZIC_SP890_H__
+
+
+#define S3C64XX_VA_TZIC0_FIQ_STATUS (S3C_VA_TZIC0 + SP890_TZIC_FIQSTATUS)
+#define S3C64XX_VA_TZIC0_RAWINTR (S3C_VA_TZIC0 + SP890_TZIC_RAWINTR)
+#define S3C64XX_VA_TZIC0_INTSELECT (S3C_VA_TZIC0 + SP890_TZIC_INTSELECT)
+#define S3C64XX_VA_TZIC0_FIQENABLE (S3C_VA_TZIC0 + SP890_TZIC_FIQENABLE)
+#define S3C64XX_VA_TZIC0_FIQENCLEAR (S3C_VA_TZIC0 + SP890_TZIC_FIQENCLEAR)
+#define S3C64XX_VA_TZIC0_FIQBYPASS (S3C_VA_TZIC0 + SP890_TZIC_FIQBYPASS)
+#define S3C64XX_VA_TZIC0_FPROTECTION (S3C_VA_TZIC0 + SP890_TZIC_PROTECTION)
+#define S3C64XX_VA_TZIC0_LOCK (S3C_VA_TZIC0 + SP890_TZIC_LOCK)
+#define S3C64XX_VA_TZIC0_LOCKSTATUS (S3C_VA_TZIC0 + SP890_TZIC_LOCKSTATUS)
+#define S3C64XX_VA_TZIC0_ITCR (S3C_VA_TZIC0 + SP890_TZIC_ITCR)
+#define S3C64XX_VA_TZIC0_ITIP1 (S3C_VA_TZIC0 + SP890_TZIC_ITIP1)
+#define S3C64XX_VA_TZIC0_ITIP2 (S3C_VA_TZIC0 + SP890_TZIC_ITIP2)
+#define S3C64XX_VA_TZIC0_ITOP1 (S3C_VA_TZIC0 + SP890_TZIC_ITOP1)
+#define S3C64XX_VA_TZIC0_ITOP2 (S3C_VA_TZIC0 + SP890_TZIC_ITOP2)
+#define S3C64XX_VA_TZIC0_PERIPHIDO (S3C_VA_TZIC0 + SP890_TZIC_PERIPHIDO)
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/irq.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/irq.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/irq.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/irq.c	2009-05-10 22:27:59.000000000 +0200
@@ -14,12 +14,14 @@
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
+#include <linux/serial_core.h>
 #include <linux/irq.h>
 #include <linux/io.h>
 
 #include <asm/hardware/vic.h>
 
 #include <mach/map.h>
+#include <plat/regs-serial.h>
 #include <plat/regs-timer.h>
 #include <plat/cpu.h>
 
@@ -135,9 +137,6 @@
 }
 
 /* UART interrupt registers, not worth adding to seperate include header */
-#define S3C64XX_UINTP	0x30
-#define S3C64XX_UINTSP	0x34
-#define S3C64XX_UINTM	0x38
 
 static void s3c_irq_uart_mask(unsigned int irq)
 {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/irq-eint.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/irq-eint.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/irq-eint.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/irq-eint.c	2009-05-10 22:27:59.000000000 +0200
@@ -14,29 +14,20 @@
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
+#include <linux/gpio.h>
 #include <linux/irq.h>
 #include <linux/io.h>
+#include <linux/gpio.h>
 
 #include <asm/hardware/vic.h>
 
 #include <plat/regs-irqtype.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-cfg.h>
 
 #include <mach/map.h>
 #include <plat/cpu.h>
-
-/* GPIO is 0x7F008xxx, */
-#define S3C64XX_GPIOREG(x)	(S3C64XX_VA_GPIO + (x))
-
-#define S3C64XX_EINT0CON0	S3C64XX_GPIOREG(0x900)
-#define S3C64XX_EINT0CON1	S3C64XX_GPIOREG(0x904)
-#define S3C64XX_EINT0FLTCON0	S3C64XX_GPIOREG(0x910)
-#define S3C64XX_EINT0FLTCON1	S3C64XX_GPIOREG(0x914)
-#define S3C64XX_EINT0FLTCON2	S3C64XX_GPIOREG(0x918)
-#define S3C64XX_EINT0FLTCON3	S3C64XX_GPIOREG(0x91C)
-
-#define S3C64XX_EINT0MASK	S3C64XX_GPIOREG(0x920)
-#define S3C64XX_EINT0PEND	S3C64XX_GPIOREG(0x924)
-
+#include <plat/pm.h>
 
 #define eint_offset(irq)	((irq) - IRQ_EINT(0))
 #define eint_irq_to_bit(irq)	(1 << eint_offset(irq))
@@ -55,7 +46,7 @@
 	u32 mask;
 
 	mask = __raw_readl(S3C64XX_EINT0MASK);
-	mask |= eint_irq_to_bit(irq);
+	mask &= ~eint_irq_to_bit(irq);
 	__raw_writel(mask, S3C64XX_EINT0MASK);
 }
 
@@ -74,6 +65,7 @@
 static int s3c_irq_eint_set_type(unsigned int irq, unsigned int type)
 {
 	int offs = eint_offset(irq);
+	int pin;
 	int shift;
 	u32 ctrl, mask;
 	u32 newvalue = 0;
@@ -125,6 +117,14 @@
 	ctrl |= newvalue << shift;
 	__raw_writel(ctrl, reg);
 
+	/* set the GPIO pin appropriately */
+
+	if (offs < 23)
+		pin = S3C64XX_GPN(offs);
+	else
+		pin = S3C64XX_GPM(offs - 23);
+
+	s3c_gpio_cfgpin(pin, S3C_GPIO_SFN(2));
 	return 0;
 }
 
@@ -135,6 +135,7 @@
 	.mask_ack	= s3c_irq_eint_maskack,
 	.ack		= s3c_irq_eint_ack,
 	.set_type	= s3c_irq_eint_set_type,
+	.set_wake	= s3c_irqext_wake,
 };
 
 /* s3c_irq_demux_eint
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/irq-pm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/irq-pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/irq-pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/irq-pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,173 @@
+/* arch/arm/plat-s3c64xx/irq-pm.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX - Interrupt handling Power Management
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/serial_core.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include <asm/hardware/vic.h>
+
+#include <mach/map.h>
+
+#include <plat/regs-serial.h>
+#include <plat/regs-timer.h>
+#include <plat/regs-gpio.h>
+#include <plat/cpu.h>
+#include <plat/pm.h>
+
+/* We handled all the IRQ types in this code, to save having to make several
+ * small files to handle each different type separately. Having the EINT_GRP
+ * code here shouldn't be as much bloat as the IRQ table space needed when
+ * they are enabled. The added benefit is we ensure that these registers are
+ * in the same state as we suspended.
+ */
+
+static struct sleep_save irq_save[] = {
+	SAVE_ITEM(S3C64XX_PRIORITY),
+	SAVE_ITEM(S3C64XX_EINT0CON0),
+	SAVE_ITEM(S3C64XX_EINT0CON1),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON0),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON1),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON2),
+	SAVE_ITEM(S3C64XX_EINT0FLTCON3),
+	SAVE_ITEM(S3C64XX_EINT0MASK),
+	SAVE_ITEM(S3C64XX_TINT_CSTAT),
+};
+
+static struct irq_grp_save {
+	u32	fltcon;
+	u32	con;
+	u32	mask;
+} eint_grp_save[5];
+
+struct irq_vic_save {
+	u32	int_select;
+	u32	int_enable;
+	u32	soft_int;
+	u32	protect;
+	u32	vect_addr[32];
+	u32	vect_cntl[32];
+};
+
+static struct irq_vic_save irq_pm_vic0_save;
+static struct irq_vic_save irq_pm_vic1_save;
+
+static u32 irq_uart_mask[CONFIG_SERIAL_SAMSUNG_UARTS];
+
+static void s3c64xx_vic_save(void __iomem *base, struct irq_vic_save *save)
+{
+	int v;
+
+	save->int_select = readl(base + VIC_INT_SELECT);
+	save->int_enable = readl(base + VIC_INT_ENABLE);
+	save->soft_int = readl(base + VIC_INT_SOFT);
+	save->protect = readl(base + VIC_PROTECT);
+
+	S3C_PMDBG("%s: select=%08x, enable=%08x, protect=%08x\n", __func__,
+		  save->int_select, save->int_enable, save->protect);
+
+	for (v = 0; v < ARRAY_SIZE(save->vect_addr); v++) {
+		save->vect_addr[v] = readl(base + VIC_VECT_ADDR0 + (v * 4));
+		save->vect_cntl[v] = readl(base + VIC_VECT_CNTL0 + (v * 4));
+	}
+}
+
+static void s3c64xx_vic_restore(void __iomem *base, struct irq_vic_save *save)
+{
+	int v;
+
+	writel(save->int_select, base + VIC_INT_SELECT);
+	writel(save->protect, base + VIC_PROTECT);
+
+	/* set the enabled ints and then clear the non-enabled */
+	writel(save->int_enable, base + VIC_INT_ENABLE);
+	writel(~save->int_enable, base + VIC_INT_ENABLE_CLEAR);
+
+	/* and the same for the soft-int register */
+
+	writel(save->soft_int, base + VIC_INT_SOFT);
+	writel(~save->soft_int, base + VIC_INT_SOFT_CLEAR);
+
+	S3C_PMDBG("%s: vic int_enable=%08x\n", __func__, readl(base + VIC_INT_ENABLE));
+
+	for (v = 0; v < ARRAY_SIZE(save->vect_addr); v++) {
+		writel(save->vect_addr[v], base + VIC_VECT_ADDR0 + (v * 4));
+		writel(save->vect_cntl[v], base + VIC_VECT_CNTL0 + (v * 4));
+	}
+}
+
+static int s3c64xx_irq_pm_suspend(struct sys_device *dev, pm_message_t state)
+{
+	struct irq_grp_save *grp = eint_grp_save;
+	int i;
+
+	S3C_PMDBG("%s: suspending IRQs\n", __func__);
+
+	s3c64xx_vic_save(S3C_VA_VIC0, &irq_pm_vic0_save);
+	s3c64xx_vic_save(S3C_VA_VIC1, &irq_pm_vic1_save);
+
+	s3c_pm_do_save(irq_save, ARRAY_SIZE(irq_save));
+
+	for (i = 0; i < CONFIG_SERIAL_SAMSUNG_UARTS; i++)
+		irq_uart_mask[i] = __raw_readl(S3C_VA_UARTx(i) + S3C64XX_UINTM);
+
+	for (i = 0; i < ARRAY_SIZE(eint_grp_save); i++, grp++) {
+		grp->con = __raw_readl(S3C64XX_EINT12CON + (i * 4));
+		grp->mask = __raw_readl(S3C64XX_EINT12MASK + (i * 4));
+		grp->fltcon = __raw_readl(S3C64XX_EINT12FLTCON + (i * 4));
+	}
+
+	return 0;
+}
+
+static int s3c64xx_irq_pm_resume(struct sys_device *dev)
+{
+	struct irq_grp_save *grp = eint_grp_save;
+	int i;
+
+	S3C_PMDBG("%s: resuming IRQs\n", __func__);
+
+	s3c_pm_do_restore(irq_save, ARRAY_SIZE(irq_save));
+
+	s3c64xx_vic_restore(S3C_VA_VIC0, &irq_pm_vic0_save);
+	s3c64xx_vic_restore(S3C_VA_VIC1, &irq_pm_vic1_save);
+
+	for (i = 0; i < CONFIG_SERIAL_SAMSUNG_UARTS; i++)
+		__raw_writel(irq_uart_mask[i], S3C_VA_UARTx(i) + S3C64XX_UINTM);
+
+	for (i = 0; i < ARRAY_SIZE(eint_grp_save); i++, grp++) {
+		__raw_writel(grp->con, S3C64XX_EINT12CON + (i * 4));
+		__raw_writel(grp->mask, S3C64XX_EINT12MASK + (i * 4));
+		__raw_writel(grp->fltcon, S3C64XX_EINT12FLTCON + (i * 4));
+	}
+
+	S3C_PMDBG("%s: IRQ configuration restored\n", __func__);
+	return 0;
+}
+
+static struct sysdev_driver s3c64xx_irq_driver = {
+	.suspend = s3c64xx_irq_pm_suspend,
+	.resume	 = s3c64xx_irq_pm_resume,
+};
+
+static int __init s3c64xx_irq_pm_init(void)
+{
+	return sysdev_driver_register(&s3c64xx_sysclass, &s3c64xx_irq_driver);
+}
+
+arch_initcall(s3c64xx_irq_pm_init);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/Kconfig linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/Kconfig
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/Kconfig	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -19,6 +19,8 @@
 	select S3C_GPIO_PULL_UPDOWN
 	select S3C_GPIO_CFG_S3C24XX
 	select S3C_GPIO_CFG_S3C64XX
+	select USB_ARCH_HAS_OHCI
+	select S3C64XX_SETUP_USBOTG
 	help
 	  Base platform code for any Samsung S3C64XX device
 
@@ -38,6 +40,10 @@
 	  Common clock support code for the S3C6400 that is shared
 	  by other CPUs in the series, such as the S3C6410.
 
+config S3C64XX_DMA
+	bool "S3C64XX DMA"
+	select S3C_DMA
+
 # platform specific device setup
 
 config S3C64XX_SETUP_I2C0
@@ -59,4 +65,10 @@
 	help
 	  Common setup code for S3C64XX with an 24bpp RGB display helper.
 
+config S3C64XX_SETUP_USBOTG
+	bool
+	help
+	  Common setup code for S3C64XX with USB OTG
+
+
 endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/Makefile linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/Makefile
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/Makefile	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -24,8 +24,22 @@
 obj-$(CONFIG_CPU_S3C6400_INIT)	+= s3c6400-init.o
 obj-$(CONFIG_CPU_S3C6400_CLOCK)	+= s3c6400-clock.o
 
+# DMA support
+
+obj-$(CONFIG_S3C64XX_DMA)	+= dma.o
+
+# PM support
+
+obj-$(CONFIG_PM)		+= pm.o
+obj-$(CONFIG_PM)		+= sleep.o
+obj-$(CONFIG_PM)		+= irq-pm.o
+
+obj-$(CONFIG_CPU_FREQ_S3C64XX)	+= cpufreq.o
+
 # Device setup
 
 obj-$(CONFIG_S3C64XX_SETUP_I2C0) += setup-i2c0.o
 obj-$(CONFIG_S3C64XX_SETUP_I2C1) += setup-i2c1.o
 obj-$(CONFIG_S3C64XX_SETUP_FB_24BPP) += setup-fb-24bpp.o
+obj-$(CONFIG_S3C64XX_SETUP_USBOTG) += dev-usbgadget.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/pm.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/pm.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/pm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/pm.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,177 @@
+/* linux/arch/arm/plat-s3c64xx/pm.c
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX CPU PM support.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/serial_core.h>
+#include <linux/io.h>
+
+#include <mach/map.h>
+
+#include <plat/pm.h>
+#include <plat/regs-sys.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-modem.h>
+#include <plat/regs-syscon-power.h>
+#include <plat/regs-gpio-memport.h>
+
+#ifdef CONFIG_S3C_PM_DEBUG_LED_SMDK
+#include <plat/gpio-bank-n.h>
+
+void s3c_pm_debug_smdkled(u32 set, u32 clear)
+{
+	unsigned long flags;
+	u32 reg;
+
+	local_irq_save(flags);
+	reg = __raw_readl(S3C64XX_GPNCON);
+	reg &= ~(S3C64XX_GPN_CONMASK(12) | S3C64XX_GPN_CONMASK(13) |
+		 S3C64XX_GPN_CONMASK(14) | S3C64XX_GPN_CONMASK(15));
+	reg |= S3C64XX_GPN_OUTPUT(12) | S3C64XX_GPN_OUTPUT(13) |
+	       S3C64XX_GPN_OUTPUT(14) | S3C64XX_GPN_OUTPUT(15);
+	__raw_writel(reg, S3C64XX_GPNCON);
+
+	reg = __raw_readl(S3C64XX_GPNDAT);
+	reg &= ~(clear << 12);
+	reg |= set << 12;
+	__raw_writel(reg, S3C64XX_GPNDAT);
+
+	local_irq_restore(flags);
+}
+#endif
+
+static struct sleep_save core_save[] = {
+	SAVE_ITEM(S3C_APLL_LOCK),
+	SAVE_ITEM(S3C_MPLL_LOCK),
+	SAVE_ITEM(S3C_EPLL_LOCK),
+	SAVE_ITEM(S3C_CLK_SRC),
+	SAVE_ITEM(S3C_CLK_DIV0),
+	SAVE_ITEM(S3C_CLK_DIV1),
+	SAVE_ITEM(S3C_CLK_DIV2),
+	SAVE_ITEM(S3C_CLK_OUT),
+	SAVE_ITEM(S3C_HCLK_GATE),
+	SAVE_ITEM(S3C_PCLK_GATE),
+	SAVE_ITEM(S3C_SCLK_GATE),
+	SAVE_ITEM(S3C_MEM0_GATE),
+
+	SAVE_ITEM(S3C_EPLL_CON1),
+	SAVE_ITEM(S3C_EPLL_CON0),
+
+	SAVE_ITEM(S3C64XX_MEM0DRVCON),
+	SAVE_ITEM(S3C64XX_MEM1DRVCON),
+
+#ifndef CONFIG_CPU_FREQ
+	SAVE_ITEM(S3C_APLL_CON),
+	SAVE_ITEM(S3C_MPLL_CON),
+#endif
+};
+
+static struct sleep_save misc_save[] = {
+	SAVE_ITEM(S3C64XX_AHB_CON0),
+	SAVE_ITEM(S3C64XX_AHB_CON1),
+	SAVE_ITEM(S3C64XX_AHB_CON2),
+	
+	SAVE_ITEM(S3C64XX_MODEM_MIFPCON),
+	SAVE_ITEM(S3C64XX_SPCON),
+
+	SAVE_ITEM(S3C64XX_MEM0CONSTOP),
+	SAVE_ITEM(S3C64XX_MEM1CONSTOP),
+	SAVE_ITEM(S3C64XX_MEM0CONSLP0),
+	SAVE_ITEM(S3C64XX_MEM0CONSLP1),
+	SAVE_ITEM(S3C64XX_MEM1CONSLP),
+};
+
+void s3c_pm_configure_extint(void)
+{
+	__raw_writel(s3c_irqwake_eintmask, S3C64XX_EINT_MASK);
+}
+
+void s3c_pm_restore_core(void)
+{
+	__raw_writel(0, S3C64XX_EINT_MASK);
+
+	s3c_pm_debug_smdkled(1 << 2, 0);
+
+	s3c_pm_do_restore_core(core_save, ARRAY_SIZE(core_save));
+	s3c_pm_do_restore(misc_save, ARRAY_SIZE(misc_save));
+}
+
+void s3c_pm_save_core(void)
+{
+	s3c_pm_do_save(misc_save, ARRAY_SIZE(misc_save));
+	s3c_pm_do_save(core_save, ARRAY_SIZE(core_save));
+}
+
+/* since both s3c6400 and s3c6410 share the same sleep pm calls, we
+ * put the per-cpu code in here until any new cpu comes along and changes
+ * this.
+ */
+
+#include <plat/regs-gpio.h>
+
+static void s3c64xx_cpu_suspend(void)
+{
+	unsigned long tmp;
+
+	/* set our standby method to sleep */
+
+	tmp = __raw_readl(S3C64XX_PWR_CFG);
+	tmp &= ~S3C64XX_PWRCFG_CFG_WFI_MASK;
+	tmp |= S3C64XX_PWRCFG_CFG_WFI_SLEEP;
+	__raw_writel(tmp, S3C64XX_PWR_CFG);
+
+	/* clear any old wakeup */
+
+	__raw_writel(__raw_readl(S3C64XX_WAKEUP_STAT),
+		     S3C64XX_WAKEUP_STAT);
+
+	/* set the LED state to 0110 over sleep */
+	s3c_pm_debug_smdkled(3 << 1, 0xf);
+
+	/* issue the standby signal into the pm unit. Note, we
+	 * issue a write-buffer drain just in case */
+
+	tmp = 0;
+
+	asm("b 1f\n\t"
+	    ".align 5\n\t"
+	    "1:\n\t"
+	    "mcr p15, 0, %0, c7, c10, 5\n\t"
+	    "mcr p15, 0, %0, c7, c10, 4\n\t"
+	    "mcr p15, 0, %0, c7, c0, 4" :: "r" (tmp));
+
+	/* we should never get past here */
+
+	panic("sleep resumed to originator?");
+}
+
+static void s3c64xx_pm_prepare(void)
+{
+	/* store address of resume. */
+	__raw_writel(virt_to_phys(s3c_cpu_resume), S3C64XX_INFORM0);
+
+	/* ensure previous wakeup state is cleared before sleeping */
+	__raw_writel(__raw_readl(S3C64XX_WAKEUP_STAT), S3C64XX_WAKEUP_STAT);
+}
+
+static int s3c64xx_pm_init(void)
+{
+	pm_cpu_prep = s3c64xx_pm_prepare;
+	pm_cpu_sleep = s3c64xx_cpu_suspend;
+	pm_uart_udivslot = 1;
+	return 0;
+}
+
+arch_initcall(s3c64xx_pm_init);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/s3c6400-clock.c linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/s3c6400-clock.c
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/s3c6400-clock.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/s3c6400-clock.c	2009-05-10 22:27:59.000000000 +0200
@@ -24,6 +24,7 @@
 
 #include <mach/hardware.h>
 #include <mach/map.h>
+#include <mach/cpu.h>
 
 #include <plat/cpu-freq.h>
 
@@ -88,6 +89,80 @@
 	.sources	= &clk_src_apll,
 };
 
+static u32 clk_arm_div_mask(void)
+{
+	if (cpu_is_s3c6400())
+		return S3C6400_CLKDIV0_ARM_MASK;
+
+	if (cpu_is_s3c6410())
+		return S3C6410_CLKDIV0_ARM_MASK;
+
+	return 0;
+}
+
+static unsigned long s3c64xx_clk_arm_get_rate(struct clk *clk)
+{
+	unsigned long rate = clk_get_rate(clk->parent);
+	u32 val;
+
+	val = __raw_readl(S3C_CLK_DIV0);
+	val &= clk_arm_div_mask();
+
+	return rate / (val + 1);
+}
+
+static unsigned long s3c64xx_clk_arm_round_rate(struct clk *clk,
+						unsigned long rate)
+{
+	unsigned long parent = clk_get_rate(clk->parent);
+	int div;
+	int max = clk_arm_div_mask() + 1;
+
+	if (parent < rate)
+		return parent;
+
+	div = parent / rate;
+
+	if (div < 1)
+		div = 1;
+	if (div > max)
+		div = max;
+
+	return parent / div;
+}
+
+static int s3c64xx_clk_arm_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int div;
+	u32 val;
+	unsigned long flags;
+
+	div = (clk_get_rate(clk->parent) / rate) - 1;
+
+	if (div > clk_arm_div_mask())
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	val = __raw_readl(S3C_CLK_DIV0);
+	val &= ~clk_arm_div_mask();
+	val |= div;
+
+	__raw_writel(val, S3C_CLK_DIV0);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static struct clk clk_arm = {
+	.name		= "armclk",
+	.id		= -1,
+	.parent		= &clk_mout_apll.clk,
+	.round_rate	= &s3c64xx_clk_arm_round_rate,
+	.get_rate	= s3c64xx_clk_arm_get_rate,
+	.set_rate	= s3c64xx_clk_arm_set_rate,
+};
+
 struct clk clk_fout_epll = {
 	.name		= "fout_epll",
 	.id		= -1,
@@ -239,10 +314,12 @@
 
 	rate = clk_round_rate(clk, rate);
 	div = clk_get_rate(clk->parent) / rate;
+	if (div > 16)
+		return -EINVAL;
 
 	val = __raw_readl(reg);
-	val &= ~sclk->mask;
-	val |= (rate - 1) << sclk->shift;
+	val &= ~(0xf << sclk->divider_shift);
+	val |= (div - 1) << sclk->divider_shift;
 	__raw_writel(val, reg);
 
 	return 0;
@@ -282,7 +359,7 @@
 	if (rate > parent_rate)
 		rate = parent_rate;
 	else {
-		div = rate / parent_rate;
+		div = parent_rate / rate;
 
 		if (div == 0)
 			div = 1;
@@ -351,7 +428,7 @@
 
 static struct clksrc_clk clk_usbhost = {
 	.clk	= {
-		.name		= "usb-host-bus",
+		.name		= "usb-bus-host",
 		.id		= -1,
 		.ctrlbit        = S3C_CLKCON_SCLK_UHOST,
 		.enable		= s3c64xx_sclk_ctrl,
@@ -518,6 +595,55 @@
 	.reg_divider	= S3C_CLK_DIV2,
 };
 
+static struct clk *clkset_camera_list[] = {
+	&clk_h2,
+};
+
+static struct clk_sources clkset_camera = {
+	.sources	= clkset_camera_list,
+	.nr_sources	= ARRAY_SIZE(clkset_camera_list),
+};
+
+static struct clksrc_clk clk_camera = {
+	.clk	= {
+		.name		= "camera",
+		.id		= -1,
+		.ctrlbit        = S3C_CLKCON_SCLK_CAM,
+		.enable		= s3c64xx_sclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+		.get_rate	= s3c64xx_getrate_clksrc,
+		.set_rate	= s3c64xx_setrate_clksrc,
+		.round_rate	= s3c64xx_roundrate_clksrc,
+	},
+	.shift		= 0,
+	.mask		= 0,
+	.sources	= &clkset_camera,
+	.divider_shift	= S3C6400_CLKDIV0_CAM_SHIFT,
+	.reg_divider	= S3C_CLK_DIV0,
+};
+
+static struct clk *clkset_camif_list[] = {
+	&clk_h,
+};
+
+static struct clk_sources clkset_camif = {
+	.sources	= clkset_camif_list,
+	.nr_sources	= ARRAY_SIZE(clkset_camif_list),
+};
+
+static struct clksrc_clk clk_camif = {
+	.clk	= {
+		.name		= "camif",
+		.id		= -1,
+		.ctrlbit        = S3C_CLKCON_HCLK_CAMIF,
+		.enable		= s3c64xx_hclk_ctrl,
+		.set_parent	= s3c64xx_setparent_clksrc,
+	},
+	.shift		= 0,
+	.mask		= 0,
+	.sources	= &clkset_camif,
+};
+
 /* Clock initialisation code */
 
 static struct clksrc_clk *init_parents[] = {
@@ -534,6 +660,8 @@
 	&clk_audio0,
 	&clk_audio1,
 	&clk_irda,
+	&clk_camif,
+	&clk_camera,
 };
 
 static void __init_or_cpufreq s3c6400_set_clksrc(struct clksrc_clk *clk)
@@ -606,6 +734,7 @@
 	clk_fout_epll.rate = epll;
 	clk_fout_apll.rate = apll;
 
+	clk_h2.rate = hclk2;
 	clk_h.rate = hclk;
 	clk_p.rate = pclk;
 	clk_f.rate = fclk;
@@ -633,6 +762,9 @@
 	&clk_audio0.clk,
 	&clk_audio1.clk,
 	&clk_irda.clk,
+	&clk_camera.clk,
+	&clk_camif.clk,
+	&clk_arm,
 };
 
 void __init s3c6400_register_clocks(void)
@@ -650,6 +782,5 @@
 		}
 	}
 
-	clk_mpll.parent = &clk_mout_mpll.clk;
 	clk_epll.parent = &clk_mout_epll.clk;
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/sleep.S linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/sleep.S
--- linux-2.6.29-rc3.owrt/arch/arm/plat-s3c64xx/sleep.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/arch/arm/plat-s3c64xx/sleep.S	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,143 @@
+/* linux/0arch/arm/plat-s3c64xx/sleep.S
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * S3C64XX CPU sleep code
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/map.h>
+
+#undef S3C64XX_VA_GPIO
+#define S3C64XX_VA_GPIO (0x0)
+
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-n.h>
+
+#define LL_UART (S3C_PA_UART + (0x400 * CONFIG_S3C_LOWLEVEL_UART_PORT))
+
+	.text
+
+	/* s3c_cpu_save
+	 *
+	 * Save enough processor state to allow the restart of the pm.c
+	 * code after resume.
+	 *
+	 * entry:
+	 *	r0 = pointer to the save block
+	 * exit:
+	 *	r0 = exit code: 1 => stored data
+	 *			0 => resumed from sleep
+	*/
+
+ENTRY(s3c_cpu_save)
+	stmfd	sp!, { r4 - r12, lr }
+
+	mrc	p15, 0, r4, c13, c0, 0	@ FCSE/PID
+	mrc	p15, 0, r5, c3, c0, 0	@ Domain ID
+	mrc	p15, 0, r6, c2, c0, 0	@ Translation Table BASE0
+	mrc	p15, 0, r7, c2, c0, 1	@ Translation Table BASE1
+	mrc	p15, 0, r8, c2, c0, 2	@ Translation Table Control
+	mrc	p15, 0, r9, c1, c0, 0	@ Control register
+	mrc	p15, 0, r10, c1, c0, 1	@ Auxiliary control register
+	mrc	p15, 0, r11, c1, c0, 2	@ Co-processor access controls
+
+	stmia	r0, { r4 - r13 }	@ Save CP registers and SP
+	mov	r0, #0
+	ldmfd	sp, { r4 - r12, pc }	@ return, not disturbing SP
+
+	@@ return to the caller, after the MMU is turned on.
+	@@ restore the last bits of the stack and return.
+resume_with_mmu:
+	mov	r0, #1
+	ldmfd	sp!, { r4 - r12, pc }	@ return, from sp from s3c_cpu_save
+
+	.data
+
+	/* the next bit is code, but it requires easy access to the
+	 * s3c_sleep_save_phys data before the MMU is switched on, so
+	 * we store the code that needs this variable in the .data where
+	 * the value can be written to (the .text segment is RO).
+	*/
+
+	.global	s3c_sleep_save_phys
+s3c_sleep_save_phys:
+	.word	0
+
+	/* Sleep magic, the word before the resume entry point so that the
+	 * bootloader can check for a resumeable image. */
+
+	.word	0x2bedf00d
+
+	/* s3c_cpu_reusme
+	 *
+	 * This is the entry point, stored by whatever method the bootloader
+	 * requires to get the kernel runnign again. This code expects to be
+	 * entered with no caches live and the MMU disabled. It will then
+	 * restore the MMU and other basic CP registers saved and restart
+	 * the kernel C code to finish the resume code.
+	*/
+
+ENTRY(s3c_cpu_resume)
+	msr	cpsr_c, #PSR_I_BIT | PSR_F_BIT | SVC_MODE
+	ldr	r2, =LL_UART		/* for debug */
+
+#ifdef CONFIG_S3C_PM_DEBUG_LED_SMDK
+	/* Initialise the GPIO state if we are debugging via the SMDK LEDs,
+	 * as the uboot version supplied resets these to inputs during the
+	 * resume checks.
+	*/
+
+	ldr	r3, =S3C64XX_PA_GPIO
+	ldr	r0, [ r3, #S3C64XX_GPNCON ]
+	bic	r0, r0, #(S3C64XX_GPN_CONMASK(12) | S3C64XX_GPN_CONMASK(13) | \
+			  S3C64XX_GPN_CONMASK(14) | S3C64XX_GPN_CONMASK(15))
+	orr	r0, r0, #(S3C64XX_GPN_OUTPUT(12) | S3C64XX_GPN_OUTPUT(13) | \
+			  S3C64XX_GPN_OUTPUT(14) | S3C64XX_GPN_OUTPUT(15))
+	str	r0, [ r3, #S3C64XX_GPNCON ]
+
+	ldr	r0, [ r3, #S3C64XX_GPNDAT ]
+	bic	r0, r0, #0xf << 12			@ GPN12..15
+	orr	r0, r0, #1 << 15			@ GPN15
+	str	r0, [ r3, #S3C64XX_GPNDAT ]
+#endif
+
+	/* __v6_setup from arch/arm/mm/proc-v6.S, ensure that the caches
+	 * are thoroughly cleaned just in case the bootloader didn't do it
+	 * for us. */
+	mov	r0, #0
+	mcr	p15, 0, r0, c7, c14, 0		@ clean+invalidate D cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate I cache
+	mcr	p15, 0, r0, c7, c15, 0		@ clean+invalidate cache
+	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+	@@mcr	p15, 0, r0, c8, c7, 0		@ invalidate I + D TLBs
+	@@mcr	p15, 0, r0, c7, c7, 0		@ Invalidate I + D caches
+
+	ldr	r0, s3c_sleep_save_phys
+	ldmia	r0, { r4 - r13 }
+
+	mcr	p15, 0, r4, c13, c0, 0	@ FCSE/PID
+	mcr	p15, 0, r5, c3, c0, 0	@ Domain ID
+	mcr	p15, 0, r6, c2, c0, 0	@ Translation Table BASE0
+	mcr	p15, 0, r7, c2, c0, 1	@ Translation Table BASE1
+	mcr	p15, 0, r8, c2, c0, 2	@ Translation Table Control
+	mcr	p15, 0, r10, c1, c0, 1	@ Auxiliary control register
+
+	mov	r0, #0			@ restore copro access controls
+	mcr	p15, 0, r11, c1, c0, 2	@ Co-processor access controls
+	mcr 	p15, 0, r0, c7, c5, 4
+
+	ldr	r2, =resume_with_mmu
+	mcr	p15, 0, r9, c1, c0, 0		/* turn mmu back on */
+	nop
+	mov	pc, r2				/* jump back */
+
+	.end
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/arch/arm/tools/mach-types linux-2.6.29-rc3.owrt.om/arch/arm/tools/mach-types
--- linux-2.6.29-rc3.owrt/arch/arm/tools/mach-types	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/arch/arm/tools/mach-types	2009-05-10 22:27:59.000000000 +0200
@@ -1994,3 +1994,5 @@
 blaze			MACH_BLAZE		BLAZE			2004
 linkstation_ls_hgl	MACH_LINKSTATION_LS_HGL	LINKSTATION_LS_HGL	2005
 htcvenus		MACH_HTCVENUS		HTCVENUS		2006
+om_3d7k			MACH_OM_3D7K		OM_3D7K			2120
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/build linux-2.6.29-rc3.owrt.om/build
--- linux-2.6.29-rc3.owrt/build	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/build	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# Kernel building helper script (C)2008 Openmoko, Inc
+# Andy Green <andy@openmoko.org>
+#
+# Licensed under GPLv3 or later
+#
+#
+# you need to run this from the top level source dir, but it creates all
+# object files into a subdir given in the first argument, eg
+#
+# ./build GTA02
+#
+# this radically speeds up swapping between build contexts.  Note the config
+# for each build lives in the subdir.
+
+PARALLEL=16
+
+if [ -z "$1" ] ; then
+	echo "Specify the build subdir, eg, GTA02 which contains the .config"
+	echo "and will hold the object files"
+	exit 1
+fi
+
+mkdir -p $1
+
+if [ -z "$CROSS_COMPILE" ]; then
+    export CROSS_COMPILE=/usr/local/openmoko/arm/bin/arm-angstrom-linux-gnueabi-
+fi
+make O=$1 ARCH=arm silentoldconfig
+
+#
+# figure out what we are building
+#
+
+PRODUCT=
+
+if [ ! -z "`grep CONFIG_MACH_NEO1973_GTA01=y $1/.config`" ] ; then
+	START=30008000
+	PRODUCT=GTA01
+fi
+
+if [ ! -z "`grep CONFIG_MACH_NEO1973_GTA02=y $1/.config`" ] ; then
+	START=30008000
+	PRODUCT=GTA02
+fi
+
+if [ ! -z "`grep CONFIG_MACH_OM_3D7K=y $1/.config`" ] ; then
+        START=50008000
+        PRODUCT=OM_3D7K
+fi
+
+if [ ! -z "`grep CONFIG_MACH_SMDK6410=y $1/.config`" ] ; then
+        START=50008000
+        PRODUCT=SMDK6410
+fi
+
+if [ ! -z "`grep CONFIG_MACH_M800=y $1/.config`" ] ; then
+	START=30008000
+	PRODUCT=M800
+fi
+
+if [ -z "$PRODUCT" ] ; then
+	echo "Unable to figure out what we are building from the config"
+	exit 1
+fi
+
+#
+# check that we are in a valid branch
+#
+
+if git branch | head -n1 | grep -q "* (no branch)"; then
+	cat <<EOF 1>&2
+There is no branch in the local copy of the repository right now!
+Hint: type git-branch, make sure you are in a valid branch and then try again
+EOF
+   exit 1
+fi;
+
+#
+# get the branch and head hash for the version we are building to
+# allow source tracability
+#
+
+VERSION=
+if [ -d .git ] ; then
+ HEAD=`git show --pretty=oneline | head -n1 | cut -d' ' -f1 | cut -b1-16`
+ BRANCH=`git branch | grep ^\* | cut -d' ' -f2 | sed s/-hist//g`
+ VERSION=-$PRODUCT\_$BRANCH
+fi
+
+
+echo $MKIMAGECMD
+
+#
+# actually make it
+#
+
+if make -j$PARALLEL O=$1 ARCH=arm CONFIG_DEBUG_SECTION_MISMATCH=y EXTRAVERSION=$VERSION; then
+
+	#
+	# if the build is happy, postprocess it by strip and with U-Boot header wrapper
+	# you can get mkimage from U-Boot or Qi build
+	#
+
+	${CROSS_COMPILE}objcopy -O binary -R .note -R .comment -S $1/arch/arm/boot/compressed/vmlinux $1/linux.bin
+	mkimage -A arm -O linux -T kernel -C none -a $START -e $START -n "OM $PRODUCT $BRANCH""_$HEAD" -d $1/linux.bin $1/uImage-$PRODUCT.bin
+
+	# we can see if it is an "moredrivers" build by looking for USB Eth gadget
+	# if it is then keep a stamped copy of last build
+
+	if [ ! -z "`grep CONFIG_USB_USBNET=y $1/.config`" ] ; then
+		rm -f $1/uImage-moredrivers-$PRODUCT*.bin $1/modules-$PRODUCT*.tar.gz
+		cp $1/uImage-$PRODUCT.bin $1/uImage-moredrivers$VERSION-$HEAD.bin
+		rm -rf $1/staging
+		mkdir -p $1/staging
+		if [ ! -z "$2" ] ; then
+			make O=$1 ARCH=arm modules_install INSTALL_MOD_PATH=staging
+			cd $1/staging
+			tar czf ../modules$VERSION-$HEAD.tar.gz .
+			cd ../..
+		fi
+	fi
+	exit 0
+else
+	exit 1
+fi
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/dfu-kern linux-2.6.29-rc3.owrt.om/dfu-kern
--- linux-2.6.29-rc3.owrt/dfu-kern	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/dfu-kern	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,16 @@
+#!/bin/bash
+
+if [ -z "$1" ] ; then
+	echo "Usage: $0 <DEVICE>    eg, $0 GTA02"
+	exit 1
+fi
+
+NAME=`echo $1 | cut -d'-' -f1`
+
+../../dfu-util/src/dfu-util -a 3 -d 0x1d50:0x5119 -D $1/uImage-$NAME.bin
+if [ $? -eq 1 ] ; then
+../../dfu-util/src/dfu-util -a 3 -d 0x1d50:0x5120 -D $1/uImage-$NAME.bin
+../../dfu-util/src/dfu-util -a 3 -d 0x1d50:0x5119 -D $1/uImage-$NAME.bin
+fi
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/Documentation/arm/Samsung-S3C24XX/Suspend.txt linux-2.6.29-rc3.owrt.om/Documentation/arm/Samsung-S3C24XX/Suspend.txt
--- linux-2.6.29-rc3.owrt/Documentation/arm/Samsung-S3C24XX/Suspend.txt	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/Documentation/arm/Samsung-S3C24XX/Suspend.txt	2009-05-10 22:27:59.000000000 +0200
@@ -40,13 +40,13 @@
 Machine Support
 ---------------
 
-  The machine specific functions must call the s3c2410_pm_init() function
+  The machine specific functions must call the s3c_pm_init() function
   to say that its bootloader is capable of resuming. This can be as
   simple as adding the following to the machine's definition:
 
-  INITMACHINE(s3c2410_pm_init)
+  INITMACHINE(s3c_pm_init)
 
-  A board can do its own setup before calling s3c2410_pm_init, if it
+  A board can do its own setup before calling s3c_pm_init, if it
   needs to setup anything else for power management support.
 
   There is currently no support for over-riding the default method of
@@ -74,7 +74,7 @@
 
 	enable_irq_wake(IRQ_EINT0);
 
-	s3c2410_pm_init();
+	s3c_pm_init();
 }
 
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6000_drv.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6000_drv.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6000_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6000_drv.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,3128 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/*
+ * This driver is a pseudo ethernet driver to access the Atheros AR6000
+ * WLAN Device
+ */
+static const char athId[] __attribute__ ((unused)) = "$Id: //depot/sw/releases/olca2.0-GPL/host/os/linux/ar6000_drv.c#2 $";
+
+#include "ar6000_drv.h"
+#include "htc.h"
+
+MODULE_LICENSE("GPL and additional rights");
+
+#ifndef REORG_APTC_HEURISTICS
+#undef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+#endif /* REORG_APTC_HEURISTICS */
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+#define APTC_TRAFFIC_SAMPLING_INTERVAL     100  /* msec */
+#define APTC_UPPER_THROUGHPUT_THRESHOLD    3000 /* Kbps */
+#define APTC_LOWER_THROUGHPUT_THRESHOLD    2000 /* Kbps */
+
+typedef struct aptc_traffic_record {
+    A_BOOL timerScheduled;
+    struct timeval samplingTS;
+    unsigned long bytesReceived;
+    unsigned long bytesTransmitted;
+} APTC_TRAFFIC_RECORD;
+
+A_TIMER aptcTimer;
+APTC_TRAFFIC_RECORD aptcTR;
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+int bmienable = 0;
+unsigned int bypasswmi = 0;
+unsigned int debuglevel = 0;
+int tspecCompliance = 1;
+unsigned int busspeedlow = 0;
+unsigned int onebitmode = 0;
+unsigned int skipflash = 0;
+unsigned int wmitimeout = 2;
+unsigned int wlanNodeCaching = 1;
+unsigned int enableuartprint = 0;
+unsigned int logWmiRawMsgs = 0;
+unsigned int enabletimerwar = 0;
+unsigned int mbox_yield_limit = 99;
+int reduce_credit_dribble = 1 + HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF;
+int allow_trace_signal = 0;
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+unsigned int testmode =0;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param(bmienable, int, 0644);
+module_param(bypasswmi, int, 0644);
+module_param(debuglevel, int, 0644);
+module_param(tspecCompliance, int, 0644);
+module_param(onebitmode, int, 0644);
+module_param(busspeedlow, int, 0644);
+module_param(skipflash, int, 0644);
+module_param(wmitimeout, int, 0644);
+module_param(wlanNodeCaching, int, 0644);
+module_param(logWmiRawMsgs, int, 0644);
+module_param(enableuartprint, int, 0644);
+module_param(enabletimerwar, int, 0644);
+module_param(mbox_yield_limit, int, 0644);
+module_param(reduce_credit_dribble, int, 0644);
+module_param(allow_trace_signal, int, 0644);
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+module_param(testmode, int, 0644);
+#endif
+#else
+
+#define __user
+/* for linux 2.4 and lower */
+MODULE_PARM(bmienable,"i");
+MODULE_PARM(bypasswmi,"i");
+MODULE_PARM(debuglevel, "i");
+MODULE_PARM(onebitmode,"i");
+MODULE_PARM(busspeedlow, "i");
+MODULE_PARM(skipflash, "i");
+MODULE_PARM(wmitimeout, "i");
+MODULE_PARM(wlanNodeCaching, "i");
+MODULE_PARM(enableuartprint,"i");
+MODULE_PARM(logWmiRawMsgs, "i");
+MODULE_PARM(enabletimerwar,"i");
+MODULE_PARM(mbox_yield_limit,"i");
+MODULE_PARM(reduce_credit_dribble,"i");
+MODULE_PARM(allow_trace_signal,"i");
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+MODULE_PARM(testmode, "i");
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+/* in 2.6.10 and later this is now a pointer to a uint */
+unsigned int _mboxnum = HTC_MAILBOX_NUM_MAX;
+#define mboxnum &_mboxnum
+#else
+unsigned int mboxnum = HTC_MAILBOX_NUM_MAX;
+#endif
+
+#ifdef CONFIG_AR6000_WLAN_RESET
+unsigned int resetok = 1;
+#else
+unsigned int resetok = 0;
+#endif
+
+#ifdef DEBUG
+A_UINT32 g_dbg_flags = DBG_DEFAULTS;
+unsigned int debugflags = 0;
+int debugdriver = 1;
+unsigned int debughtc = 128;
+unsigned int debugbmi = 1;
+unsigned int debughif = 2;
+unsigned int txcreditsavailable[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int txcreditsconsumed[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int txcreditintrenable[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int txcreditintrenableaggregate[HTC_MAILBOX_NUM_MAX] = {0};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param(debugflags, int, 0644);
+module_param(debugdriver, int, 0644);
+module_param(debughtc, int, 0644);
+module_param(debugbmi, int, 0644);
+module_param(debughif, int, 0644);
+module_param(resetok, int, 0644);
+module_param_array(txcreditsavailable, int, mboxnum, 0644);
+module_param_array(txcreditsconsumed, int, mboxnum, 0644);
+module_param_array(txcreditintrenable, int, mboxnum, 0644);
+module_param_array(txcreditintrenableaggregate, int, mboxnum, 0644);
+#else
+/* linux 2.4 and lower */
+MODULE_PARM(debugflags,"i");
+MODULE_PARM(debugdriver, "i");
+MODULE_PARM(debughtc, "i");
+MODULE_PARM(debugbmi, "i");
+MODULE_PARM(debughif, "i");
+MODULE_PARM(resetok, "i");
+MODULE_PARM(txcreditsavailable, "0-3i");
+MODULE_PARM(txcreditsconsumed, "0-3i");
+MODULE_PARM(txcreditintrenable, "0-3i");
+MODULE_PARM(txcreditintrenableaggregate, "0-3i");
+#endif
+
+#endif /* DEBUG */
+
+unsigned int tx_attempt[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int tx_post[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int tx_complete[HTC_MAILBOX_NUM_MAX] = {0};
+unsigned int hifBusRequestNumMax = 40;
+unsigned int war23838_disabled = 0;
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+unsigned int enableAPTCHeuristics = 1;
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param_array(tx_attempt, int, mboxnum, 0644);
+module_param_array(tx_post, int, mboxnum, 0644);
+module_param_array(tx_complete, int, mboxnum, 0644);
+module_param(hifBusRequestNumMax, int, 0644);
+module_param(war23838_disabled, int, 0644);
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+module_param(enableAPTCHeuristics, int, 0644);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+#else
+MODULE_PARM(tx_attempt, "0-3i");
+MODULE_PARM(tx_post, "0-3i");
+MODULE_PARM(tx_complete, "0-3i");
+MODULE_PARM(hifBusRequestNumMax, "i");
+MODULE_PARM(war23838_disabled, "i");
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+MODULE_PARM(enableAPTCHeuristics, "i");
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+#endif
+
+#ifdef BLOCK_TX_PATH_FLAG
+int blocktx = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+module_param(blocktx, int, 0644);
+#else
+MODULE_PARM(blocktx, "i");
+#endif
+#endif /* BLOCK_TX_PATH_FLAG */
+
+// TODO move to arsoft_c
+USER_RSSI_THOLD rssi_map[12];
+
+int reconnect_flag = 0;
+
+DECLARE_WAIT_QUEUE_HEAD(ar6000_scan_queue);
+
+/* Function declarations */
+static int ar6000_init_module(void);
+static void ar6000_cleanup_module(void);
+
+int ar6000_init(struct net_device *dev);
+static int ar6000_open(struct net_device *dev);
+static int ar6000_close(struct net_device *dev);
+static void ar6000_init_control_info(AR_SOFTC_T *ar);
+static int ar6000_data_tx(struct sk_buff *skb, struct net_device *dev);
+
+static void ar6000_destroy(struct net_device *dev, unsigned int unregister);
+static void ar6000_detect_error(unsigned long ptr);
+static struct net_device_stats *ar6000_get_stats(struct net_device *dev);
+static struct iw_statistics *ar6000_get_iwstats(struct net_device * dev);
+
+/*
+ * HTC service connection handlers
+ */
+static void ar6000_avail_ev(HTC_HANDLE HTCHandle);
+
+static void ar6000_unavail_ev(void *Instance);
+
+static void ar6000_target_failure(void *Instance, A_STATUS Status);
+
+static void ar6000_rx(void *Context, HTC_PACKET *pPacket);
+
+static void ar6000_rx_refill(void *Context,HTC_ENDPOINT_ID Endpoint);
+
+static void ar6000_tx_complete(void *Context, HTC_PACKET *pPacket);
+
+static void ar6000_tx_queue_full(void *Context, HTC_ENDPOINT_ID Endpoint);
+
+static void ar6000_tx_queue_avail(void *Context, HTC_ENDPOINT_ID Endpoint);
+
+/*
+ * Static variables
+ */
+
+static struct net_device *ar6000_devices[MAX_AR6000];
+extern struct iw_handler_def ath_iw_handler_def;
+DECLARE_WAIT_QUEUE_HEAD(arEvent);
+static void ar6000_cookie_init(AR_SOFTC_T *ar);
+static void ar6000_cookie_cleanup(AR_SOFTC_T *ar);
+static void ar6000_free_cookie(AR_SOFTC_T *ar, struct ar_cookie * cookie);
+static struct ar_cookie *ar6000_alloc_cookie(AR_SOFTC_T *ar);
+static void ar6000_TxDataCleanup(AR_SOFTC_T *ar);
+
+#ifdef USER_KEYS
+static A_STATUS ar6000_reinstall_keys(AR_SOFTC_T *ar,A_UINT8 key_op_ctrl);
+#endif
+
+
+static struct ar_cookie s_ar_cookie_mem[MAX_COOKIE_NUM];
+
+#define HOST_INTEREST_ITEM_ADDRESS(ar, item)    \
+((ar->arTargetType == TARGET_TYPE_AR6001) ?     \
+   AR6001_HOST_INTEREST_ITEM_ADDRESS(item) :    \
+   AR6002_HOST_INTEREST_ITEM_ADDRESS(item))
+
+
+/* Debug log support */
+
+/*
+ * Flag to govern whether the debug logs should be parsed in the kernel
+ * or reported to the application.
+ */
+#ifdef DEBUG
+#define REPORT_DEBUG_LOGS_TO_APP
+#endif
+
+A_STATUS
+ar6000_set_host_app_area(AR_SOFTC_T *ar)
+{
+    A_UINT32 address, data;
+    struct host_app_area_s host_app_area;
+
+    /* Fetch the address of the host_app_area_s instance in the host interest area */
+    address = HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest);
+    if (ar6000_ReadRegDiag(ar->arHifDevice, &address, &data) != A_OK) {
+        return A_ERROR;
+    }
+    address = data;
+    host_app_area.wmi_protocol_ver = WMI_PROTOCOL_VERSION;
+    if (ar6000_WriteDataDiag(ar->arHifDevice, address,
+                             (A_UCHAR *)&host_app_area,
+                             sizeof(struct host_app_area_s)) != A_OK)
+    {
+        return A_ERROR;
+    }
+
+    return A_OK;
+}
+
+A_UINT32
+dbglog_get_debug_hdr_ptr(AR_SOFTC_T *ar)
+{
+    A_UINT32 param;
+    A_UINT32 address;
+    A_STATUS status;
+
+    address = HOST_INTEREST_ITEM_ADDRESS(ar, hi_dbglog_hdr);
+    if ((status = ar6000_ReadDataDiag(ar->arHifDevice, address,
+                                      (A_UCHAR *)&param, 4)) != A_OK)
+    {
+        param = 0;
+    }
+
+    return param;
+}
+
+/*
+ * The dbglog module has been initialized. Its ok to access the relevant
+ * data stuctures over the diagnostic window.
+ */
+void
+ar6000_dbglog_init_done(AR_SOFTC_T *ar)
+{
+    ar->dbglog_init_done = TRUE;
+}
+
+A_UINT32
+dbglog_get_debug_fragment(A_INT8 *datap, A_UINT32 len, A_UINT32 limit)
+{
+    A_INT32 *buffer;
+    A_UINT32 count;
+    A_UINT32 numargs;
+    A_UINT32 length;
+    A_UINT32 fraglen;
+
+    count = fraglen = 0;
+    buffer = (A_INT32 *)datap;
+    length = (limit >> 2);
+
+    if (len <= limit) {
+        fraglen = len;
+    } else {
+        while (count < length) {
+            numargs = DBGLOG_GET_NUMARGS(buffer[count]);
+            fraglen = (count << 2);
+            count += numargs + 1;
+        }
+    }
+
+    return fraglen;
+}
+
+void
+dbglog_parse_debug_logs(A_INT8 *datap, A_UINT32 len)
+{
+    A_INT32 *buffer;
+    A_UINT32 count;
+    A_UINT32 timestamp;
+    A_UINT32 debugid;
+    A_UINT32 moduleid;
+    A_UINT32 numargs;
+    A_UINT32 length;
+
+    count = 0;
+    buffer = (A_INT32 *)datap;
+    length = (len >> 2);
+    while (count < length) {
+        debugid = DBGLOG_GET_DBGID(buffer[count]);
+        moduleid = DBGLOG_GET_MODULEID(buffer[count]);
+        numargs = DBGLOG_GET_NUMARGS(buffer[count]);
+        timestamp = DBGLOG_GET_TIMESTAMP(buffer[count]);
+        switch (numargs) {
+            case 0:
+            AR_DEBUG_PRINTF("%d %d (%d)\n", moduleid, debugid, timestamp);
+            break;
+
+            case 1:
+            AR_DEBUG_PRINTF("%d %d (%d): 0x%x\n", moduleid, debugid,
+                            timestamp, buffer[count+1]);
+            break;
+
+            case 2:
+            AR_DEBUG_PRINTF("%d %d (%d): 0x%x, 0x%x\n", moduleid, debugid,
+                            timestamp, buffer[count+1], buffer[count+2]);
+            break;
+
+            default:
+            AR_DEBUG_PRINTF("Invalid args: %d\n", numargs);
+        }
+        count += numargs + 1;
+    }
+}
+
+int
+ar6000_dbglog_get_debug_logs(AR_SOFTC_T *ar)
+{
+    struct dbglog_hdr_s debug_hdr;
+    struct dbglog_buf_s debug_buf;
+    A_UINT32 address;
+    A_UINT32 length;
+    A_UINT32 dropped;
+    A_UINT32 firstbuf;
+    A_UINT32 debug_hdr_ptr;
+
+    if (!ar->dbglog_init_done) return A_ERROR;
+
+#ifndef CONFIG_AR6000_WLAN_DEBUG
+    return 0;
+#endif
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (ar->dbgLogFetchInProgress) {
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        return A_EBUSY;
+    }
+
+        /* block out others */
+    ar->dbgLogFetchInProgress = TRUE;
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    debug_hdr_ptr = dbglog_get_debug_hdr_ptr(ar);
+    printk("debug_hdr_ptr: 0x%x\n", debug_hdr_ptr);
+
+    /* Get the contents of the ring buffer */
+    if (debug_hdr_ptr) {
+        address = debug_hdr_ptr;
+        length = sizeof(struct dbglog_hdr_s);
+        ar6000_ReadDataDiag(ar->arHifDevice, address,
+                            (A_UCHAR *)&debug_hdr, length);
+        address = (A_UINT32)debug_hdr.dbuf;
+        firstbuf = address;
+        dropped = debug_hdr.dropped;
+        length = sizeof(struct dbglog_buf_s);
+        ar6000_ReadDataDiag(ar->arHifDevice, address,
+                            (A_UCHAR *)&debug_buf, length);
+
+        do {
+            address = (A_UINT32)debug_buf.buffer;
+            length = debug_buf.length;
+            if ((length) && (debug_buf.length <= debug_buf.bufsize)) {
+                /* Rewind the index if it is about to overrun the buffer */
+                if (ar->log_cnt > (DBGLOG_HOST_LOG_BUFFER_SIZE - length)) {
+                    ar->log_cnt = 0;
+                }
+                if(A_OK != ar6000_ReadDataDiag(ar->arHifDevice, address,
+                                    (A_UCHAR *)&ar->log_buffer[ar->log_cnt], length))
+                {
+                    break;
+                }
+                ar6000_dbglog_event(ar, dropped, &ar->log_buffer[ar->log_cnt], length);
+                ar->log_cnt += length;
+            } else {
+                AR_DEBUG_PRINTF("Length: %d (Total size: %d)\n",
+                                debug_buf.length, debug_buf.bufsize);
+            }
+
+            address = (A_UINT32)debug_buf.next;
+            length = sizeof(struct dbglog_buf_s);
+            if(A_OK != ar6000_ReadDataDiag(ar->arHifDevice, address,
+                                (A_UCHAR *)&debug_buf, length))
+            {
+                break;
+            }
+
+        } while (address != firstbuf);
+    }
+
+    ar->dbgLogFetchInProgress = FALSE;
+
+    return A_OK;
+}
+
+void
+ar6000_dbglog_event(AR_SOFTC_T *ar, A_UINT32 dropped,
+                    A_INT8 *buffer, A_UINT32 length)
+{
+#ifdef REPORT_DEBUG_LOGS_TO_APP
+    #define MAX_WIRELESS_EVENT_SIZE 252
+    /*
+     * Break it up into chunks of MAX_WIRELESS_EVENT_SIZE bytes of messages.
+     * There seems to be a limitation on the length of message that could be
+     * transmitted to the user app via this mechanism.
+     */
+    A_UINT32 send, sent;
+
+    sent = 0;
+    send = dbglog_get_debug_fragment(&buffer[sent], length - sent,
+                                     MAX_WIRELESS_EVENT_SIZE);
+    while (send) {
+        ar6000_send_event_to_app(ar, WMIX_DBGLOG_EVENTID, &buffer[sent], send);
+        sent += send;
+        send = dbglog_get_debug_fragment(&buffer[sent], length - sent,
+                                         MAX_WIRELESS_EVENT_SIZE);
+    }
+#else
+    AR_DEBUG_PRINTF("Dropped logs: 0x%x\nDebug info length: %d\n",
+                    dropped, length);
+
+    /* Interpret the debug logs */
+    dbglog_parse_debug_logs(buffer, length);
+#endif /* REPORT_DEBUG_LOGS_TO_APP */
+}
+
+
+
+static int __init
+ar6000_init_module(void)
+{
+    static int probed = 0;
+    A_STATUS status;
+    HTC_INIT_INFO initInfo;
+
+    A_MEMZERO(&initInfo,sizeof(initInfo));
+    initInfo.AddInstance = ar6000_avail_ev;
+    initInfo.DeleteInstance = ar6000_unavail_ev;
+    initInfo.TargetFailure = ar6000_target_failure;
+
+
+#ifdef DEBUG
+    /* Set the debug flags if specified at load time */
+    if(debugflags != 0)
+    {
+        g_dbg_flags = debugflags;
+    }
+#endif
+
+    if (probed) {
+        return -ENODEV;
+    }
+    probed++;
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+    memset(&aptcTR, 0, sizeof(APTC_TRAFFIC_RECORD));
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+    ar6000_gpio_init();
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+    status = HTCInit(&initInfo);
+    if(status != A_OK)
+        return -ENODEV;
+
+    return 0;
+}
+
+static void __exit
+ar6000_cleanup_module(void)
+{
+    int i = 0;
+    struct net_device *ar6000_netdev;
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+    /* Delete the Adaptive Power Control timer */
+    if (timer_pending(&aptcTimer)) {
+        del_timer_sync(&aptcTimer);
+    }
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+    for (i=0; i < MAX_AR6000; i++) {
+        if (ar6000_devices[i] != NULL) {
+            ar6000_netdev = ar6000_devices[i];
+            ar6000_devices[i] = NULL;
+            ar6000_destroy(ar6000_netdev, 1);
+        }
+    }
+
+        /* shutting down HTC will cause the HIF layer to detach from the
+         * underlying bus driver which will cause the subsequent deletion of
+         * all HIF and HTC instances */
+    HTCShutDown();
+
+    AR_DEBUG_PRINTF("ar6000_cleanup: success\n");
+}
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+void
+aptcTimerHandler(unsigned long arg)
+{
+    A_UINT32 numbytes;
+    A_UINT32 throughput;
+    AR_SOFTC_T *ar;
+    A_STATUS status;
+
+    ar = (AR_SOFTC_T *)arg;
+    A_ASSERT(ar != NULL);
+    A_ASSERT(!timer_pending(&aptcTimer));
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    /* Get the number of bytes transferred */
+    numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;
+    aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;
+
+    /* Calculate and decide based on throughput thresholds */
+    throughput = ((numbytes * 8)/APTC_TRAFFIC_SAMPLING_INTERVAL); /* Kbps */
+    if (throughput < APTC_LOWER_THROUGHPUT_THRESHOLD) {
+        /* Enable Sleep and delete the timer */
+        A_ASSERT(ar->arWmiReady == TRUE);
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        status = wmi_powermode_cmd(ar->arWmi, REC_POWER);
+        AR6000_SPIN_LOCK(&ar->arLock, 0);
+        A_ASSERT(status == A_OK);
+        aptcTR.timerScheduled = FALSE;
+    } else {
+        A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+}
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+
+
+/* set HTC block size, assume BMI is already initialized */
+A_STATUS ar6000_SetHTCBlockSize(AR_SOFTC_T *ar)
+{
+    A_STATUS status;
+    A_UINT32 blocksizes[HTC_MAILBOX_NUM_MAX];
+
+    do {
+            /* get the block sizes */
+        status = HIFConfigureDevice(ar->arHifDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    blocksizes, sizeof(blocksizes));
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF("Failed to get block size info from HIF layer...\n");
+            break;
+        }
+            /* note: we actually get the block size for mailbox 1, for SDIO the block
+             * size on mailbox 0 is artificially set to 1 */
+            /* must be a power of 2 */
+        A_ASSERT((blocksizes[1] & (blocksizes[1] - 1)) == 0);
+
+            /* set the host interest area for the block size */
+        status = BMIWriteMemory(ar->arHifDevice,
+                                HOST_INTEREST_ITEM_ADDRESS(ar, hi_mbox_io_block_sz),
+                                (A_UCHAR *)&blocksizes[1],
+                                4);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF("BMIWriteMemory for IO block size failed \n");
+            break;
+        }
+
+        AR_DEBUG_PRINTF("Block Size Set: %d (target address:0x%X)\n",
+                blocksizes[1], HOST_INTEREST_ITEM_ADDRESS(ar, hi_mbox_io_block_sz));
+
+            /* set the host interest area for the mbox ISR yield limit */
+        status = BMIWriteMemory(ar->arHifDevice,
+                                HOST_INTEREST_ITEM_ADDRESS(ar, hi_mbox_isr_yield_limit),
+                                (A_UCHAR *)&mbox_yield_limit,
+                                4);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF("BMIWriteMemory for yield limit failed \n");
+            break;
+        }
+
+    } while (FALSE);
+
+    return status;
+}
+
+static void free_raw_buffers(AR_SOFTC_T *ar)
+{
+    int i, j;
+
+    for (i = 0; i != HTC_RAW_STREAM_NUM_MAX; i++) {
+	for (j = 0; j != RAW_HTC_READ_BUFFERS_NUM; j++)
+	    kfree(ar->raw_htc_read_buffer[i][j]);
+	for (j = 0; j != RAW_HTC_WRITE_BUFFERS_NUM; j++)
+	    kfree(ar->raw_htc_write_buffer[i][j]);
+    }
+}
+
+static int alloc_raw_buffers(AR_SOFTC_T *ar)
+{
+    int i, j;
+    raw_htc_buffer *b;
+
+    for (i = 0; i != HTC_RAW_STREAM_NUM_MAX; i++) {
+	for (j = 0; j != RAW_HTC_READ_BUFFERS_NUM; j++) {
+	    b = kzalloc(sizeof(*b), GFP_KERNEL);
+	    if (!b)
+		return -ENOMEM;
+	    ar->raw_htc_read_buffer[i][j] = b;
+	}
+	for (j = 0; j != RAW_HTC_WRITE_BUFFERS_NUM; j++) {
+	    b = kzalloc(sizeof(*b), GFP_KERNEL);
+	    if (!b)
+		return -ENOMEM;
+	    ar->raw_htc_write_buffer[i][j] = b;
+	}
+    }
+    return 0;
+}
+
+/*
+ * HTC Event handlers
+ */
+static void
+ar6000_avail_ev(HTC_HANDLE HTCHandle)
+{
+    int i;
+    struct net_device *dev;
+    AR_SOFTC_T *ar;
+    int device_index = 0;
+
+    AR_DEBUG_PRINTF("ar6000_available\n");
+
+    for (i=0; i < MAX_AR6000; i++) {
+        if (ar6000_devices[i] == NULL) {
+            break;
+        }
+    }
+
+    if (i == MAX_AR6000) {
+        AR_DEBUG_PRINTF("ar6000_available: max devices reached\n");
+        return;
+    }
+
+    /* Save this. It gives a bit better readability especially since */
+    /* we use another local "i" variable below.                      */
+    device_index = i;
+
+    A_ASSERT(HTCHandle != NULL);
+
+    dev = alloc_etherdev(sizeof(AR_SOFTC_T));
+    if (dev == NULL) {
+        AR_DEBUG_PRINTF("ar6000_available: can't alloc etherdev\n");
+        return;
+    }
+
+    ether_setup(dev);
+
+    if (netdev_priv(dev) == NULL) {
+        printk(KERN_CRIT "ar6000_available: Could not allocate memory\n");
+        return;
+    }
+
+    A_MEMZERO(netdev_priv(dev), sizeof(AR_SOFTC_T));
+
+    ar                       = (AR_SOFTC_T *)netdev_priv(dev);
+    ar->arNetDev             = dev;
+    ar->arHtcTarget          = HTCHandle;
+    ar->arHifDevice          = HTCGetHifDevice(HTCHandle);
+    ar->arWlanState          = WLAN_ENABLED;
+    ar->arRadioSwitch        = WLAN_ENABLED;
+    ar->arDeviceIndex        = device_index;
+
+    A_INIT_TIMER(&ar->arHBChallengeResp.timer, ar6000_detect_error, dev);
+    ar->arHBChallengeResp.seqNum = 0;
+    ar->arHBChallengeResp.outstanding = FALSE;
+    ar->arHBChallengeResp.missCnt = 0;
+    ar->arHBChallengeResp.frequency = AR6000_HB_CHALLENGE_RESP_FREQ_DEFAULT;
+    ar->arHBChallengeResp.missThres = AR6000_HB_CHALLENGE_RESP_MISS_THRES_DEFAULT;
+
+    ar6000_init_control_info(ar);
+    init_waitqueue_head(&arEvent);
+    sema_init(&ar->arSem, 1);
+
+    if (alloc_raw_buffers(ar)) {
+	free_raw_buffers(ar);
+	/*
+	 * @@@ Clean up our own mess, but for anything else, cheerfully mimick
+	 * the beautiful error non-handling of the rest of this function.
+	 */
+	return;
+    }
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+    A_INIT_TIMER(&aptcTimer, aptcTimerHandler, ar);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+    /*
+     * If requested, perform some magic which requires no cooperation from
+     * the Target.  It causes the Target to ignore flash and execute to the
+     * OS from ROM.
+     *
+     * This is intended to support recovery from a corrupted flash on Targets
+     * that support flash.
+     */
+    if (skipflash)
+    {
+        ar6000_reset_device_skipflash(ar->arHifDevice);
+            }
+
+    BMIInit();
+    {
+        struct bmi_target_info targ_info;
+
+        if (BMIGetTargetInfo(ar->arHifDevice, &targ_info) != A_OK) {
+            return;
+        }
+
+        ar->arVersion.target_ver = targ_info.target_ver;
+        ar->arTargetType = targ_info.target_type;
+    }
+
+    if (enableuartprint) {
+        A_UINT32 param;
+        param = 1;
+        if (BMIWriteMemory(ar->arHifDevice,
+                           HOST_INTEREST_ITEM_ADDRESS(ar, hi_serial_enable),
+                           (A_UCHAR *)&param,
+                           4)!= A_OK)
+        {
+             AR_DEBUG_PRINTF("BMIWriteMemory for enableuartprint failed \n");
+             return ;
+        }
+        AR_DEBUG_PRINTF("Serial console prints enabled\n");
+    }
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+    if(testmode) {
+        ar->arTargetMode = AR6000_TCMD_MODE;
+    }else {
+        ar->arTargetMode = AR6000_WLAN_MODE;
+    }
+#endif
+    if (enabletimerwar) {
+        A_UINT32 param;
+
+        if (BMIReadMemory(ar->arHifDevice,
+            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),
+            (A_UCHAR *)&param,
+            4)!= A_OK)
+        {
+            AR_DEBUG_PRINTF("BMIReadMemory for enabletimerwar failed \n");
+            return;
+        }
+
+        param |= HI_OPTION_TIMER_WAR;
+
+        if (BMIWriteMemory(ar->arHifDevice,
+            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),
+            (A_UCHAR *)&param,
+            4) != A_OK)
+        {
+            AR_DEBUG_PRINTF("BMIWriteMemory for enabletimerwar failed \n");
+            return;
+        }
+        AR_DEBUG_PRINTF("Timer WAR enabled\n");
+    }
+
+
+        /* since BMIInit is called in the driver layer, we have to set the block
+         * size here for the target */
+
+    if (A_FAILED(ar6000_SetHTCBlockSize(ar))) {
+        return;
+    }
+
+    spin_lock_init(&ar->arLock);
+
+    /* Don't install the init function if BMI is requested */
+    if(!bmienable)
+    {
+        dev->init = ar6000_init;
+    } else {
+        AR_DEBUG_PRINTF(" BMI enabled \n");
+    }
+
+    dev->open = &ar6000_open;
+    dev->stop = &ar6000_close;
+    dev->hard_start_xmit = &ar6000_data_tx;
+    dev->get_stats = &ar6000_get_stats;
+
+    /* dev->tx_timeout = ar6000_tx_timeout; */
+    dev->do_ioctl = &ar6000_ioctl;
+    dev->watchdog_timeo = AR6000_TX_TIMEOUT;
+    ar6000_ioctl_iwsetup(&ath_iw_handler_def);
+    dev->wireless_handlers = &ath_iw_handler_def;
+    ath_iw_handler_def.get_wireless_stats = ar6000_get_iwstats; /*Displayed via proc fs */
+
+    /*
+     * We need the OS to provide us with more headroom in order to
+     * perform dix to 802.3, WMI header encap, and the HTC header
+     */
+    dev->hard_header_len = ETH_HLEN + sizeof(ATH_LLC_SNAP_HDR) +
+        sizeof(WMI_DATA_HDR) + HTC_HEADER_LEN;
+
+    /* This runs the init function */
+    SET_NETDEV_DEV(dev, HIFGetOSDevice(ar->arHifDevice));
+    if (register_netdev(dev)) {
+        AR_DEBUG_PRINTF("ar6000_avail: register_netdev failed\n");
+        ar6000_destroy(dev, 0);
+        return;
+    }
+
+    HTCSetInstance(ar->arHtcTarget, ar);
+
+    /* We only register the device in the global list if we succeed. */
+    /* If the device is in the global list, it will be destroyed     */
+    /* when the module is unloaded.                                  */
+    ar6000_devices[device_index] = dev;
+
+    AR_DEBUG_PRINTF("ar6000_avail: name=%s htcTarget=0x%x, dev=0x%x (%d), ar=0x%x\n",
+                    dev->name, (A_UINT32)HTCHandle, (A_UINT32)dev, device_index,
+                    (A_UINT32)ar);
+}
+
+static void ar6000_target_failure(void *Instance, A_STATUS Status)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Instance;
+    WMI_TARGET_ERROR_REPORT_EVENT errEvent;
+    static A_BOOL sip = FALSE;
+
+    if (Status != A_OK) {
+        if (timer_pending(&ar->arHBChallengeResp.timer)) {
+            A_UNTIMEOUT(&ar->arHBChallengeResp.timer);
+        }
+
+        /* try dumping target assertion information (if any) */
+        ar6000_dump_target_assert_info(ar->arHifDevice,ar->arTargetType);
+
+        /*
+         * Fetch the logs from the target via the diagnostic
+         * window.
+         */
+        ar6000_dbglog_get_debug_logs(ar);
+
+        /* Report the error only once */
+        if (!sip) {
+            sip = TRUE;
+            errEvent.errorVal = WMI_TARGET_COM_ERR |
+                                WMI_TARGET_FATAL_ERR;
+#ifdef SEND_EVENT_TO_APP
+            ar6000_send_event_to_app(ar, WMI_ERROR_REPORT_EVENTID,
+                                     (A_UINT8 *)&errEvent,
+                                     sizeof(WMI_TARGET_ERROR_REPORT_EVENT));
+#endif
+        }
+    }
+}
+
+static void
+ar6000_unavail_ev(void *Instance)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Instance;
+        /* NULL out it's entry in the global list */
+    ar6000_devices[ar->arDeviceIndex] = NULL;
+    ar6000_destroy(ar->arNetDev, 1);
+}
+
+/*
+ * We need to differentiate between the surprise and planned removal of the
+ * device because of the following consideration:
+ * - In case of surprise removal, the hcd already frees up the pending
+ *   for the device and hence there is no need to unregister the function
+ *   driver inorder to get these requests. For planned removal, the function
+ *   driver has to explictly unregister itself to have the hcd return all the
+ *   pending requests before the data structures for the devices are freed up.
+ *   Note that as per the current implementation, the function driver will
+ *   end up releasing all the devices since there is no API to selectively
+ *   release a particular device.
+ * - Certain commands issued to the target can be skipped for surprise
+ *   removal since they will anyway not go through.
+ */
+static void
+ar6000_destroy(struct net_device *dev, unsigned int unregister)
+{
+    AR_SOFTC_T *ar;
+
+    AR_DEBUG_PRINTF("+ar6000_destroy \n");
+
+    if((dev == NULL) || ((ar = netdev_priv(dev)) == NULL))
+    {
+        AR_DEBUG_PRINTF("%s(): Failed to get device structure.\n", __func__);
+        return;
+    }
+
+    /* Clear the tx counters */
+    memset(tx_attempt, 0, sizeof(tx_attempt));
+    memset(tx_post, 0, sizeof(tx_post));
+    memset(tx_complete, 0, sizeof(tx_complete));
+
+    /* Free up the device data structure */
+    if (unregister) {
+	unregister_netdev(dev);
+    } else {
+	ar6000_close(dev);
+    }
+
+    free_raw_buffers(ar);
+
+#ifndef free_netdev
+    kfree(dev);
+#else
+    free_netdev(dev);
+#endif
+
+    AR_DEBUG_PRINTF("-ar6000_destroy \n");
+}
+
+static void ar6000_detect_error(unsigned long ptr)
+{
+    struct net_device *dev = (struct net_device *)ptr;
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_TARGET_ERROR_REPORT_EVENT errEvent;
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (ar->arHBChallengeResp.outstanding) {
+        ar->arHBChallengeResp.missCnt++;
+    } else {
+        ar->arHBChallengeResp.missCnt = 0;
+    }
+
+    if (ar->arHBChallengeResp.missCnt > ar->arHBChallengeResp.missThres) {
+        /* Send Error Detect event to the application layer and do not reschedule the error detection module timer */
+        ar->arHBChallengeResp.missCnt = 0;
+        ar->arHBChallengeResp.seqNum = 0;
+        errEvent.errorVal = WMI_TARGET_COM_ERR | WMI_TARGET_FATAL_ERR;
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+#ifdef SEND_EVENT_TO_APP
+        ar6000_send_event_to_app(ar, WMI_ERROR_REPORT_EVENTID,
+                                 (A_UINT8 *)&errEvent,
+                                 sizeof(WMI_TARGET_ERROR_REPORT_EVENT));
+#endif
+        return;
+    }
+
+    /* Generate the sequence number for the next challenge */
+    ar->arHBChallengeResp.seqNum++;
+    ar->arHBChallengeResp.outstanding = TRUE;
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    /* Send the challenge on the control channel */
+    if (wmi_get_challenge_resp_cmd(ar->arWmi, ar->arHBChallengeResp.seqNum, DRV_HB_CHALLENGE) != A_OK) {
+        AR_DEBUG_PRINTF("Unable to send heart beat challenge\n");
+    }
+
+
+    /* Reschedule the timer for the next challenge */
+    A_TIMEOUT_MS(&ar->arHBChallengeResp.timer, ar->arHBChallengeResp.frequency * 1000, 0);
+}
+
+void ar6000_init_profile_info(AR_SOFTC_T *ar)
+{
+    ar->arSsidLen            = 0;
+    A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+    ar->arNetworkType        = INFRA_NETWORK;
+    ar->arDot11AuthMode      = OPEN_AUTH;
+    ar->arAuthMode           = NONE_AUTH;
+    ar->arPairwiseCrypto     = NONE_CRYPT;
+    ar->arPairwiseCryptoLen  = 0;
+    ar->arGroupCrypto        = NONE_CRYPT;
+    ar->arGroupCryptoLen     = 0;
+    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));
+    A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));
+    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));
+    ar->arBssChannel = 0;
+}
+
+static void
+ar6000_init_control_info(AR_SOFTC_T *ar)
+{
+    ar->arWmiEnabled         = FALSE;
+    ar6000_init_profile_info(ar);
+    ar->arDefTxKeyIndex      = 0;
+    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));
+    ar->arChannelHint        = 0;
+    ar->arListenInterval     = MAX_LISTEN_INTERVAL;
+    ar->arVersion.host_ver   = AR6K_SW_VERSION;
+    ar->arRssi               = 0;
+    ar->arTxPwr              = 0;
+    ar->arTxPwrSet           = FALSE;
+    ar->arSkipScan           = 0;
+    ar->arBeaconInterval     = 0;
+    ar->arBitRate            = 0;
+    ar->arMaxRetries         = 0;
+    ar->arWmmEnabled         = TRUE;
+}
+
+static int
+ar6000_open(struct net_device *dev)
+{
+    /* Wake up the queues */
+    netif_start_queue(dev);
+
+    return 0;
+}
+
+static int
+ar6000_close(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = netdev_priv(dev);
+
+    /* Stop the transmit queues */
+    netif_stop_queue(dev);
+
+    /* Disable the target and the interrupts associated with it */
+    if (ar->arWmiReady == TRUE)
+    {
+        if (!bypasswmi)
+        {
+            if (ar->arConnected == TRUE || ar->arConnectPending == TRUE)
+            {
+                AR_DEBUG_PRINTF("%s(): Disconnect\n", __func__);
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                ar6000_init_profile_info(ar);
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                wmi_disconnect_cmd(ar->arWmi);
+            }
+
+            ar6000_dbglog_get_debug_logs(ar);
+            ar->arWmiReady  = FALSE;
+            ar->arConnected = FALSE;
+            ar->arConnectPending = FALSE;
+            wmi_shutdown(ar->arWmi);
+            ar->arWmiEnabled = FALSE;
+            ar->arWmi = NULL;
+            ar->arWlanState = WLAN_ENABLED;
+#ifdef USER_KEYS
+            ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;
+            ar->user_key_ctrl      = 0;
+#endif
+        }
+
+         AR_DEBUG_PRINTF("%s(): WMI stopped\n", __func__);
+    }
+    else
+    {
+        AR_DEBUG_PRINTF("%s(): WMI not ready 0x%08x 0x%08x\n",
+            __func__, (unsigned int) ar, (unsigned int) ar->arWmi);
+
+        /* Shut down WMI if we have started it */
+        if(ar->arWmiEnabled == TRUE)
+        {
+            AR_DEBUG_PRINTF("%s(): Shut down WMI\n", __func__);
+            wmi_shutdown(ar->arWmi);
+            ar->arWmiEnabled = FALSE;
+            ar->arWmi = NULL;
+        }
+    }
+
+    /* stop HTC */
+    HTCStop(ar->arHtcTarget);
+
+    /* set the instance to NULL so we do not get called back on remove incase we
+     * we're explicity destroyed by module unload */
+    HTCSetInstance(ar->arHtcTarget, NULL);
+
+    if (resetok) {
+        /* try to reset the device if we can
+         * The driver may have been configure NOT to reset the target during
+         * a debug session */
+        AR_DEBUG_PRINTF(" Attempting to reset target on instance destroy.... \n");
+        ar6000_reset_device(ar->arHifDevice, ar->arTargetType);
+    } else {
+        AR_DEBUG_PRINTF(" Host does not want target reset. \n");
+    }
+
+       /* Done with cookies */
+    ar6000_cookie_cleanup(ar);
+
+    /* Cleanup BMI */
+    BMIInit();
+
+    return 0;
+}
+
+/* connect to a service */
+static A_STATUS ar6000_connectservice(AR_SOFTC_T               *ar,
+                                      HTC_SERVICE_CONNECT_REQ  *pConnect,
+                                      WMI_PRI_STREAM_ID        WmiStreamID,
+                                      char                     *pDesc)
+{
+    A_STATUS                 status;
+    HTC_SERVICE_CONNECT_RESP response;
+
+    do {
+
+        A_MEMZERO(&response,sizeof(response));
+
+        status = HTCConnectService(ar->arHtcTarget,
+                                   pConnect,
+                                   &response);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(" Failed to connect to %s service status:%d \n", pDesc, status);
+            break;
+        }
+
+        if (WmiStreamID == WMI_NOT_MAPPED) {
+                /* done */
+            break;
+        }
+
+            /* set endpoint mapping for the WMI stream in the driver layer */
+        arSetWMIStream2EndpointIDMap(ar,WmiStreamID,response.Endpoint);
+
+    } while (FALSE);
+
+    return status;
+}
+
+static void ar6000_TxDataCleanup(AR_SOFTC_T *ar)
+{
+        /* flush all the data (non-control) streams
+         * we only flush packets that are tagged as data, we leave any control packets that
+         * were in the TX queues alone */
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arWMIStream2EndpointID(ar,WMI_BEST_EFFORT_PRI),
+                     AR6K_DATA_PKT_TAG);
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arWMIStream2EndpointID(ar,WMI_LOW_PRI),
+                     AR6K_DATA_PKT_TAG);
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arWMIStream2EndpointID(ar,WMI_HIGH_PRI),
+                     AR6K_DATA_PKT_TAG);
+    HTCFlushEndpoint(ar->arHtcTarget,
+                     arWMIStream2EndpointID(ar,WMI_HIGHEST_PRI),
+                     AR6K_DATA_PKT_TAG);
+}
+
+/* This function does one time initialization for the lifetime of the device */
+int ar6000_init(struct net_device *dev)
+{
+    AR_SOFTC_T *ar;
+    A_STATUS    status;
+    A_INT32     timeleft;
+
+    if((ar = netdev_priv(dev)) == NULL)
+    {
+        return(-EIO);
+    }
+
+    /* Do we need to finish the BMI phase */
+    if(BMIDone(ar->arHifDevice) != A_OK)
+    {
+        return -EIO;
+    }
+
+    if (!bypasswmi)
+    {
+#if 0 /* TBDXXX */
+        if (ar->arVersion.host_ver != ar->arVersion.target_ver) {
+            A_PRINTF("WARNING: Host version 0x%x does not match Target "
+                    " version 0x%x!\n",
+                    ar->arVersion.host_ver, ar->arVersion.target_ver);
+        }
+#endif
+
+        /* Indicate that WMI is enabled (although not ready yet) */
+        ar->arWmiEnabled = TRUE;
+        if ((ar->arWmi = wmi_init((void *) ar)) == NULL)
+        {
+            AR_DEBUG_PRINTF("%s() Failed to initialize WMI.\n", __func__);
+            return(-EIO);
+        }
+
+        AR_DEBUG_PRINTF("%s() Got WMI @ 0x%08x.\n", __func__,
+            (unsigned int) ar->arWmi);
+    }
+
+    do {
+        HTC_SERVICE_CONNECT_REQ connect;
+
+            /* the reason we have to wait for the target here is that the driver layer
+             * has to init BMI in order to set the host block size,
+             */
+        status = HTCWaitTarget(ar->arHtcTarget);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        A_MEMZERO(&connect,sizeof(connect));
+            /* meta data is unused for now */
+        connect.pMetaData = NULL;
+        connect.MetaDataLength = 0;
+            /* these fields are the same for all service endpoints */
+        connect.EpCallbacks.pContext = ar;
+        connect.EpCallbacks.EpTxComplete = ar6000_tx_complete;
+        connect.EpCallbacks.EpRecv = ar6000_rx;
+        connect.EpCallbacks.EpRecvRefill = ar6000_rx_refill;
+        connect.EpCallbacks.EpSendFull = ar6000_tx_queue_full;
+        connect.EpCallbacks.EpSendAvail = ar6000_tx_queue_avail;
+            /* set the max queue depth so that our ar6000_tx_queue_full handler gets called.
+             * Linux has the peculiarity of not providing flow control between the
+             * NIC and the network stack. There is no API to indicate that a TX packet
+             * was sent which could provide some back pressure to the network stack.
+             * Under linux you would have to wait till the network stack consumed all sk_buffs
+             * before any back-flow kicked in. Which isn't very friendly.
+             * So we have to manage this ourselves */
+        connect.MaxSendQueueDepth = 32;
+
+            /* connect to control service */
+        connect.ServiceID = WMI_CONTROL_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       WMI_CONTROL_PRI,
+                                       "WMI CONTROL");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* for the remaining data services set the connection flag to reduce dribbling,
+             * if configured to do so */
+        if (reduce_credit_dribble) {
+            connect.ConnectionFlags |= HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE;
+            /* the credit dribble trigger threshold is (reduce_credit_dribble - 1) for a value
+             * of 0-3 */
+            connect.ConnectionFlags &= ~HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;
+            connect.ConnectionFlags |=
+                        ((A_UINT16)reduce_credit_dribble - 1) & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;
+        }
+            /* connect to best-effort service */
+        connect.ServiceID = WMI_DATA_BE_SVC;
+
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       WMI_BEST_EFFORT_PRI,
+                                       "WMI DATA BE");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* connect to back-ground
+             * map this to WMI LOW_PRI */
+        connect.ServiceID = WMI_DATA_BK_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       WMI_LOW_PRI,
+                                       "WMI DATA BK");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* connect to Video service, map this to
+             * to HI PRI */
+        connect.ServiceID = WMI_DATA_VI_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       WMI_HIGH_PRI,
+                                       "WMI DATA VI");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* connect to VO service, this is currently not
+             * mapped to a WMI priority stream due to historical reasons.
+             * WMI originally defined 3 priorities over 3 mailboxes
+             * We can change this when WMI is reworked so that priorities are not
+             * dependent on mailboxes */
+        connect.ServiceID = WMI_DATA_VO_SVC;
+        status = ar6000_connectservice(ar,
+                                       &connect,
+                                       WMI_HIGHEST_PRI,
+                                       "WMI DATA VO");
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        A_ASSERT(arWMIStream2EndpointID(ar,WMI_CONTROL_PRI) != 0);
+        A_ASSERT(arWMIStream2EndpointID(ar,WMI_BEST_EFFORT_PRI) != 0);
+        A_ASSERT(arWMIStream2EndpointID(ar,WMI_LOW_PRI) != 0);
+        A_ASSERT(arWMIStream2EndpointID(ar,WMI_HIGH_PRI) != 0);
+        A_ASSERT(arWMIStream2EndpointID(ar,WMI_HIGHEST_PRI) != 0);
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        return (-EIO);
+    }
+
+    /*
+     * give our connected endpoints some buffers
+     */
+    ar6000_rx_refill(ar, arWMIStream2EndpointID(ar,WMI_CONTROL_PRI));
+
+    ar6000_rx_refill(ar, arWMIStream2EndpointID(ar,WMI_BEST_EFFORT_PRI));
+
+    /*
+     * We will post the receive buffers only for SPE testing and so we are
+     * making it conditional on the 'bypasswmi' flag.
+     */
+    if (bypasswmi) {
+        ar6000_rx_refill(ar,arWMIStream2EndpointID(ar,WMI_LOW_PRI));
+        ar6000_rx_refill(ar,arWMIStream2EndpointID(ar,WMI_HIGH_PRI));
+    }
+
+        /* setup credit distribution */
+    ar6000_setup_credit_dist(ar->arHtcTarget, &ar->arCreditStateInfo);
+
+    /* Since cookies are used for HTC transports, they should be */
+    /* initialized prior to enabling HTC.                        */
+    ar6000_cookie_init(ar);
+
+    /* start HTC */
+    status = HTCStart(ar->arHtcTarget);
+
+    if (status != A_OK) {
+        if (ar->arWmiEnabled == TRUE) {
+            wmi_shutdown(ar->arWmi);
+            ar->arWmiEnabled = FALSE;
+            ar->arWmi = NULL;
+        }
+        ar6000_cookie_cleanup(ar);
+        return -EIO;
+    }
+
+    if (!bypasswmi) {
+        /* Wait for Wmi event to be ready */
+        timeleft = wait_event_interruptible_timeout(arEvent,
+            (ar->arWmiReady == TRUE), wmitimeout * HZ);
+
+        if(!timeleft || signal_pending(current))
+        {
+            AR_DEBUG_PRINTF("WMI is not ready or wait was interrupted\n");
+#if defined(DWSIM) /* TBDXXX */
+            AR_DEBUG_PRINTF(".....but proceed anyway.\n");
+#else
+            return -EIO;
+#endif
+        }
+
+        AR_DEBUG_PRINTF("%s() WMI is ready\n", __func__);
+
+        /* Communicate the wmi protocol verision to the target */
+        if ((ar6000_set_host_app_area(ar)) != A_OK) {
+            AR_DEBUG_PRINTF("Unable to set the host app area\n");
+        }
+    }
+
+    ar->arNumDataEndPts = 1;
+
+    return(0);
+}
+
+
+void
+ar6000_bitrate_rx(void *devt, A_INT32 rateKbps)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arBitRate = rateKbps;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_ratemask_rx(void *devt, A_UINT16 ratemask)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arRateMask = ratemask;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_txPwr_rx(void *devt, A_UINT8 txPwr)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arTxPwr = txPwr;
+    wake_up(&arEvent);
+}
+
+
+void
+ar6000_channelList_rx(void *devt, A_INT8 numChan, A_UINT16 *chanList)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    A_MEMCPY(ar->arChannelList, chanList, numChan * sizeof (A_UINT16));
+    ar->arNumChannels = numChan;
+
+    wake_up(&arEvent);
+}
+
+A_UINT8
+ar6000_ibss_map_epid(struct sk_buff *skb, struct net_device *dev, A_UINT32 * mapNo)
+{
+    AR_SOFTC_T      *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_UINT8         *datap;
+    ATH_MAC_HDR     *macHdr;
+    A_UINT32         i, eptMap;
+
+    (*mapNo) = 0;
+    datap = A_NETBUF_DATA(skb);
+    macHdr = (ATH_MAC_HDR *)(datap + sizeof(WMI_DATA_HDR));
+    if (IEEE80211_IS_MULTICAST(macHdr->dstMac)) {
+        return ENDPOINT_2;
+    }
+
+    eptMap = -1;
+    for (i = 0; i < ar->arNodeNum; i ++) {
+        if (IEEE80211_ADDR_EQ(macHdr->dstMac, ar->arNodeMap[i].macAddress)) {
+            (*mapNo) = i + 1;
+            ar->arNodeMap[i].txPending ++;
+            return ar->arNodeMap[i].epId;
+        }
+
+        if ((eptMap == -1) && !ar->arNodeMap[i].txPending) {
+            eptMap = i;
+        }
+    }
+
+    if (eptMap == -1) {
+        eptMap = ar->arNodeNum;
+        ar->arNodeNum ++;
+        A_ASSERT(ar->arNodeNum <= MAX_NODE_NUM);
+    }
+
+    A_MEMCPY(ar->arNodeMap[eptMap].macAddress, macHdr->dstMac, IEEE80211_ADDR_LEN);
+
+    for (i = ENDPOINT_2; i <= ENDPOINT_5; i ++) {
+        if (!ar->arTxPending[i]) {
+            ar->arNodeMap[eptMap].epId = i;
+            break;
+        }
+        // No free endpoint is available, start redistribution on the inuse endpoints.
+        if (i == ENDPOINT_5) {
+            ar->arNodeMap[eptMap].epId = ar->arNexEpId;
+            ar->arNexEpId ++;
+            if (ar->arNexEpId > ENDPOINT_5) {
+                ar->arNexEpId = ENDPOINT_2;
+            }
+        }
+    }
+
+    (*mapNo) = eptMap + 1;
+    ar->arNodeMap[eptMap].txPending ++;
+
+    return ar->arNodeMap[eptMap].epId;
+}
+
+#ifdef DEBUG
+static void ar6000_dump_skb(struct sk_buff *skb)
+{
+   u_char *ch;
+   for (ch = A_NETBUF_DATA(skb);
+        (A_UINT32)ch < ((A_UINT32)A_NETBUF_DATA(skb) +
+        A_NETBUF_LEN(skb)); ch++)
+    {
+         AR_DEBUG_PRINTF("%2.2x ", *ch);
+    }
+    AR_DEBUG_PRINTF("\n");
+}
+#endif
+
+static int
+ar6000_data_tx(struct sk_buff *skb, struct net_device *dev)
+{
+    AR_SOFTC_T        *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_PRI_STREAM_ID streamID = WMI_NOT_MAPPED;
+    A_UINT32          mapNo = 0;
+    int               len;
+    struct ar_cookie *cookie;
+    A_BOOL            checkAdHocPsMapping = FALSE;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,13)
+    skb->list = NULL;
+#endif
+
+    AR_DEBUG2_PRINTF("ar6000_data_tx start - skb=0x%x, data=0x%x, len=0x%x\n",
+                     (A_UINT32)skb, (A_UINT32)A_NETBUF_DATA(skb),
+                     A_NETBUF_LEN(skb));
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+     /* TCMD doesnt support any data, free the buf and return */
+    if(ar->arTargetMode == AR6000_TCMD_MODE) {
+        A_NETBUF_FREE(skb);
+        return 0;
+    }
+#endif
+    do {
+
+        if (ar->arWmiReady == FALSE && bypasswmi == 0) {
+            break;
+        }
+
+#ifdef BLOCK_TX_PATH_FLAG
+        if (blocktx) {
+            break;
+        }
+#endif /* BLOCK_TX_PATH_FLAG */
+
+        if (ar->arWmiEnabled) {
+            if (A_NETBUF_HEADROOM(skb) < dev->hard_header_len) {
+                struct sk_buff  *newbuf;
+                /*
+                 * We really should have gotten enough headroom but sometimes
+                 * we still get packets with not enough headroom.  Copy the packet.
+                 */
+                len = A_NETBUF_LEN(skb);
+                newbuf = A_NETBUF_ALLOC(len);
+                if (newbuf == NULL) {
+                    break;
+                }
+                A_NETBUF_PUT(newbuf, len);
+                A_MEMCPY(A_NETBUF_DATA(newbuf), A_NETBUF_DATA(skb), len);
+                A_NETBUF_FREE(skb);
+                skb = newbuf;
+                /* fall through and assemble header */
+            }
+
+            if (wmi_dix_2_dot3(ar->arWmi, skb) != A_OK) {
+                AR_DEBUG_PRINTF("ar6000_data_tx - wmi_dix_2_dot3 failed\n");
+                break;
+            }
+
+            if (wmi_data_hdr_add(ar->arWmi, skb, DATA_MSGTYPE) != A_OK) {
+                AR_DEBUG_PRINTF("ar6000_data_tx - wmi_data_hdr_add failed\n");
+                break;
+            }
+
+            if ((ar->arNetworkType == ADHOC_NETWORK) &&
+                ar->arIbssPsEnable && ar->arConnected) {
+                    /* flag to check adhoc mapping once we take the lock below: */
+                checkAdHocPsMapping = TRUE;
+
+            } else {
+                    /* get the stream mapping */
+                if (ar->arWmmEnabled) {
+                    streamID = wmi_get_stream_id(ar->arWmi,
+                                    wmi_implicit_create_pstream(ar->arWmi, skb, UPLINK_TRAFFIC, UNDEFINED_PRI));
+                } else {
+                    streamID = WMI_BEST_EFFORT_PRI;
+                }
+            }
+
+        } else {
+            struct iphdr    *ipHdr;
+            /*
+             * the endpoint is directly based on the TOS field in the IP
+             * header **** only for testing ******
+             */
+            ipHdr = A_NETBUF_DATA(skb) + sizeof(ATH_MAC_HDR);
+                /* here we map the TOS field to an endpoint number, this is for
+                 * the endpointping test application */
+            streamID = IP_TOS_TO_WMI_PRI(ipHdr->tos);
+        }
+
+    } while (FALSE);
+
+        /* did we succeed ? */
+    if ((streamID == WMI_NOT_MAPPED) && !checkAdHocPsMapping) {
+            /* cleanup and exit */
+        A_NETBUF_FREE(skb);
+        AR6000_STAT_INC(ar, tx_dropped);
+        AR6000_STAT_INC(ar, tx_aborted_errors);
+        return 0;
+    }
+
+    cookie = NULL;
+
+        /* take the lock to protect driver data */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    do {
+
+        if (checkAdHocPsMapping) {
+            streamID = ar6000_ibss_map_epid(skb, dev, &mapNo);
+        }
+
+        A_ASSERT(streamID != WMI_NOT_MAPPED);
+
+            /* validate that the endpoint is connected */
+        if (arWMIStream2EndpointID(ar,streamID) == 0) {
+            AR_DEBUG_PRINTF("Stream %d is NOT mapped!\n",streamID);
+            break;
+        }
+            /* allocate resource for this packet */
+        cookie = ar6000_alloc_cookie(ar);
+
+        if (cookie != NULL) {
+                /* update counts while the lock is held */
+            ar->arTxPending[streamID]++;
+            ar->arTotalTxDataPending++;
+        }
+
+    } while (FALSE);
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    if (cookie != NULL) {
+        cookie->arc_bp[0] = (A_UINT32)skb;
+        cookie->arc_bp[1] = mapNo;
+        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,
+                               cookie,
+                               A_NETBUF_DATA(skb),
+                               A_NETBUF_LEN(skb),
+                               arWMIStream2EndpointID(ar,streamID),
+                               AR6K_DATA_PKT_TAG);
+
+#ifdef DEBUG
+        if (debugdriver >= 3) {
+            ar6000_dump_skb(skb);
+        }
+#endif
+            /* HTC interface is asynchronous, if this fails, cleanup will happen in
+             * the ar6000_tx_complete callback */
+        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);
+    } else {
+            /* no packet to send, cleanup */
+        A_NETBUF_FREE(skb);
+        AR6000_STAT_INC(ar, tx_dropped);
+        AR6000_STAT_INC(ar, tx_aborted_errors);
+    }
+
+    return 0;
+}
+
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+static void
+tvsub(register struct timeval *out, register struct timeval *in)
+{
+    if((out->tv_usec -= in->tv_usec) < 0) {
+        out->tv_sec--;
+        out->tv_usec += 1000000;
+    }
+    out->tv_sec -= in->tv_sec;
+}
+
+void
+applyAPTCHeuristics(AR_SOFTC_T *ar)
+{
+    A_UINT32 duration;
+    A_UINT32 numbytes;
+    A_UINT32 throughput;
+    struct timeval ts;
+    A_STATUS status;
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if ((enableAPTCHeuristics) && (!aptcTR.timerScheduled)) {
+        do_gettimeofday(&ts);
+        tvsub(&ts, &aptcTR.samplingTS);
+        duration = ts.tv_sec * 1000 + ts.tv_usec / 1000; /* ms */
+        numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;
+
+        if (duration > APTC_TRAFFIC_SAMPLING_INTERVAL) {
+            /* Initialize the time stamp and byte count */
+            aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;
+            do_gettimeofday(&aptcTR.samplingTS);
+
+            /* Calculate and decide based on throughput thresholds */
+            throughput = ((numbytes * 8) / duration);
+            if (throughput > APTC_UPPER_THROUGHPUT_THRESHOLD) {
+                /* Disable Sleep and schedule a timer */
+                A_ASSERT(ar->arWmiReady == TRUE);
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                status = wmi_powermode_cmd(ar->arWmi, MAX_PERF_POWER);
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);
+                aptcTR.timerScheduled = TRUE;
+            }
+        }
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+}
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+static void
+ar6000_tx_queue_full(void *Context, HTC_ENDPOINT_ID Endpoint)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *) Context;
+
+    if (Endpoint == arWMIStream2EndpointID(ar,WMI_CONTROL_PRI)) {
+        if (!bypasswmi) {
+                /* under normal WMI if this is getting full, then something is running rampant
+                 * the host should not be exhausting the WMI queue with too many commands
+                 * the only exception to this is during testing using endpointping */
+
+            AR6000_SPIN_LOCK(&ar->arLock, 0);
+                /* set flag to handle subsequent messages */
+            ar->arWMIControlEpFull = TRUE;
+            AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            AR_DEBUG_PRINTF("WMI Control Endpoint is FULL!!! \n");
+        }
+    } else {
+        /* one of the data endpoints queues is getting full..need to stop network stack
+         * the queue will resume after credits received */
+        netif_stop_queue(ar->arNetDev);
+    }
+}
+
+static void
+ar6000_tx_queue_avail(void *Context, HTC_ENDPOINT_ID Endpoint)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Context;
+
+    if (Endpoint == arWMIStream2EndpointID(ar,WMI_CONTROL_PRI)) {
+        /* FIXME: what do for it?  */
+    } else {
+        /* Wake up interface, rescheduling prevented.  */
+        if (ar->arConnected == TRUE || bypasswmi)
+            netif_wake_queue(ar->arNetDev);
+    }
+}
+
+static void
+ar6000_tx_complete(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T     *ar = (AR_SOFTC_T *)Context;
+    void           *cookie = (void *)pPacket->pPktContext;
+    struct sk_buff *skb = NULL;
+    A_UINT32        mapNo = 0;
+    A_STATUS        status;
+    struct ar_cookie * ar_cookie;
+    WMI_PRI_STREAM_ID streamID;
+    A_BOOL          wakeEvent = FALSE;
+
+    status = pPacket->Status;
+    ar_cookie = (struct ar_cookie *)cookie;
+    skb = (struct sk_buff *)ar_cookie->arc_bp[0];
+    streamID = arEndpoint2WMIStreamID(ar,pPacket->Endpoint);
+    mapNo = ar_cookie->arc_bp[1];
+
+    A_ASSERT(skb);
+    A_ASSERT(pPacket->pBuffer == A_NETBUF_DATA(skb));
+
+    if (A_SUCCESS(status)) {
+        A_ASSERT(pPacket->ActualLength == A_NETBUF_LEN(skb));
+    }
+
+    AR_DEBUG2_PRINTF("ar6000_tx_complete skb=0x%x data=0x%x len=0x%x sid=%d ",
+                     (A_UINT32)skb, (A_UINT32)pPacket->pBuffer,
+                     pPacket->ActualLength,
+                     streamID);
+
+        /* lock the driver as we update internal state */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    ar->arTxPending[streamID]--;
+
+    if ((streamID != WMI_CONTROL_PRI) || bypasswmi) {
+        ar->arTotalTxDataPending--;
+    }
+
+    if (streamID == WMI_CONTROL_PRI)
+    {
+        if (ar->arWMIControlEpFull) {
+                /* since this packet completed, the WMI EP is no longer full */
+            ar->arWMIControlEpFull = FALSE;
+        }
+
+        if (ar->arTxPending[streamID] == 0) {
+            wakeEvent = TRUE;
+        }
+    }
+
+    if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF("%s() -TX ERROR, status: 0x%x\n", __func__,
+                        status);
+        AR6000_STAT_INC(ar, tx_errors);
+    } else {
+        AR_DEBUG2_PRINTF("OK\n");
+        AR6000_STAT_INC(ar, tx_packets);
+        ar->arNetStats.tx_bytes += A_NETBUF_LEN(skb);
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+        aptcTR.bytesTransmitted += a_netbuf_to_len(skb);
+        applyAPTCHeuristics(ar);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+    }
+
+    // TODO this needs to be looked at
+    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable
+        && (streamID != WMI_CONTROL_PRI) && mapNo)
+    {
+        mapNo --;
+        ar->arNodeMap[mapNo].txPending --;
+
+        if (!ar->arNodeMap[mapNo].txPending && (mapNo == (ar->arNodeNum - 1))) {
+            A_UINT32 i;
+            for (i = ar->arNodeNum; i > 0; i --) {
+                if (!ar->arNodeMap[i - 1].txPending) {
+                    A_MEMZERO(&ar->arNodeMap[i - 1], sizeof(struct ar_node_mapping));
+                    ar->arNodeNum --;
+                } else {
+                    break;
+                }
+            }
+        }
+    }
+
+    /* Freeing a cookie should not be contingent on either of */
+    /* these flags, just if we have a cookie or not.           */
+    /* Can we even get here without a cookie? Fix later.       */
+    if (ar->arWmiReady == TRUE || (bypasswmi))
+    {
+        ar6000_free_cookie(ar, cookie);
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    /* lock is released, we can freely call other kernel APIs */
+
+        /* this indirectly frees the HTC_PACKET */
+    A_NETBUF_FREE(skb);
+
+    if (wakeEvent) {
+        wake_up(&arEvent);
+    }
+}
+
+/*
+ * Receive event handler.  This is called by HTC when a packet is received
+ */
+int pktcount;
+static void
+ar6000_rx(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)Context;
+    struct sk_buff *skb = (struct sk_buff *)pPacket->pPktContext;
+    int minHdrLen;
+    A_STATUS        status = pPacket->Status;
+    WMI_PRI_STREAM_ID streamID = arEndpoint2WMIStreamID(ar,pPacket->Endpoint);
+    HTC_ENDPOINT_ID   ept = pPacket->Endpoint;
+
+    A_ASSERT((status != A_OK) || (pPacket->pBuffer == (A_NETBUF_DATA(skb) + HTC_HEADER_LEN)));
+
+    AR_DEBUG2_PRINTF("ar6000_rx ar=0x%x sid=%d, skb=0x%x, data=0x%x, len=0x%x ",
+                    (A_UINT32)ar, streamID, (A_UINT32)skb, (A_UINT32)pPacket->pBuffer,
+                    pPacket->ActualLength);
+    if (status != A_OK) {
+        AR_DEBUG2_PRINTF("ERR\n");
+    } else {
+        AR_DEBUG2_PRINTF("OK\n");
+    }
+
+        /* take lock to protect buffer counts
+         * and adaptive power throughput state */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    ar->arRxBuffers[streamID]--;
+
+    if (A_SUCCESS(status)) {
+        AR6000_STAT_INC(ar, rx_packets);
+        ar->arNetStats.rx_bytes += pPacket->ActualLength;
+#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL
+        aptcTR.bytesReceived += a_netbuf_to_len(skb);
+        applyAPTCHeuristics(ar);
+#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */
+
+        A_NETBUF_PUT(skb, pPacket->ActualLength +  HTC_HEADER_LEN);
+        A_NETBUF_PULL(skb, HTC_HEADER_LEN);
+
+#ifdef DEBUG
+        if (debugdriver >= 2) {
+            ar6000_dump_skb(skb);
+        }
+#endif /* DEBUG */
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    if (status != A_OK) {
+        AR6000_STAT_INC(ar, rx_errors);
+        A_NETBUF_FREE(skb);
+    } else if (ar->arWmiEnabled == TRUE) {
+        if (streamID == WMI_CONTROL_PRI) {
+           /*
+            * this is a wmi control msg
+            */
+            wmi_control_rx(ar->arWmi, skb);
+        } else {
+            WMI_DATA_HDR *dhdr = (WMI_DATA_HDR *)A_NETBUF_DATA(skb);
+            if (WMI_DATA_HDR_IS_MSG_TYPE(dhdr, CNTL_MSGTYPE)) {
+                /*
+                 * this is a wmi control msg
+                 */
+                /* strip off WMI hdr */
+                wmi_data_hdr_remove(ar->arWmi, skb);
+                wmi_control_rx(ar->arWmi, skb);
+            } else {
+                /*
+                 * this is a wmi data packet
+                 */
+                minHdrLen = sizeof (WMI_DATA_HDR) + sizeof(ATH_MAC_HDR) +
+                            sizeof(ATH_LLC_SNAP_HDR);
+
+                if ((pPacket->ActualLength < minHdrLen) ||
+                    (pPacket->ActualLength > AR6000_BUFFER_SIZE))
+                {
+                    /*
+                     * packet is too short or too long
+                     */
+                    AR_DEBUG_PRINTF("TOO SHORT or TOO LONG\n");
+                    AR6000_STAT_INC(ar, rx_errors);
+                    AR6000_STAT_INC(ar, rx_length_errors);
+                    A_NETBUF_FREE(skb);
+                } else {
+                    if (ar->arWmmEnabled) {
+                        wmi_implicit_create_pstream(ar->arWmi, skb,
+                            DNLINK_TRAFFIC, UNDEFINED_PRI);
+                    }
+#if 0
+                    /* Access RSSI values here */
+                    AR_DEBUG_PRINTF("RSSI %d\n",
+                        ((WMI_DATA_HDR *) A_NETBUF_DATA(skb))->rssi);
+#endif
+                    wmi_data_hdr_remove(ar->arWmi, skb);
+                    wmi_dot3_2_dix(ar->arWmi, skb);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                    /*
+                     * extra push and memcpy, for eth_type_trans() of 2.4 kernel
+                     * will pull out hard_header_len bytes of the skb.
+                     */
+                    A_NETBUF_PUSH(skb, sizeof(WMI_DATA_HDR) + sizeof(ATH_LLC_SNAP_HDR) + HTC_HEADER_LEN);
+                    A_MEMCPY(A_NETBUF_DATA(skb), A_NETBUF_DATA(skb) + sizeof(WMI_DATA_HDR) +
+                             sizeof(ATH_LLC_SNAP_HDR) + HTC_HEADER_LEN, sizeof(ATH_MAC_HDR));
+#endif
+                    if ((ar->arNetDev->flags & IFF_UP) == IFF_UP)
+                    {
+                        skb->dev = ar->arNetDev;
+                        skb->protocol = eth_type_trans(skb, ar->arNetDev);
+                        netif_rx(skb);
+                    }
+                    else
+                    {
+                        A_NETBUF_FREE(skb);
+                    }
+                }
+            }
+        }
+    } else {
+        if ((ar->arNetDev->flags & IFF_UP) == IFF_UP)
+        {
+            skb->dev = ar->arNetDev;
+            skb->protocol = eth_type_trans(skb, ar->arNetDev);
+            netif_rx(skb);
+        }
+        else
+        {
+            A_NETBUF_FREE(skb);
+        }
+    }
+
+    if (status != A_ECANCELED) {
+        /*
+         * HTC provides A_ECANCELED status when it doesn't want to be refilled
+         * (probably due to a shutdown)
+         */
+        ar6000_rx_refill(Context, ept);
+    }
+
+
+}
+
+static void
+ar6000_rx_refill(void *Context, HTC_ENDPOINT_ID Endpoint)
+{
+    AR_SOFTC_T  *ar = (AR_SOFTC_T *)Context;
+    void        *osBuf;
+    int         RxBuffers;
+    int         buffersToRefill;
+    HTC_PACKET  *pPacket;
+    WMI_PRI_STREAM_ID streamId = arEndpoint2WMIStreamID(ar,Endpoint);
+
+    buffersToRefill = (int)AR6000_MAX_RX_BUFFERS -
+                                    (int)ar->arRxBuffers[streamId];
+
+    if (buffersToRefill <= 0) {
+            /* fast return, nothing to fill */
+        return;
+    }
+
+    AR_DEBUG2_PRINTF("ar6000_rx_refill: providing htc with %d buffers at eid=%d\n",
+                    buffersToRefill, Endpoint);
+
+    for (RxBuffers = 0; RxBuffers < buffersToRefill; RxBuffers++) {
+        osBuf = A_NETBUF_ALLOC(AR6000_BUFFER_SIZE);
+        if (NULL == osBuf) {
+            break;
+        }
+            /* the HTC packet wrapper is at the head of the reserved area
+             * in the skb */
+        pPacket = (HTC_PACKET *)(A_NETBUF_HEAD(osBuf));
+            /* set re-fill info */
+        SET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),AR6000_BUFFER_SIZE,Endpoint);
+            /* add this packet */
+        HTCAddReceivePkt(ar->arHtcTarget, pPacket);
+    }
+
+        /* update count */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+    ar->arRxBuffers[streamId] += RxBuffers;
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+}
+
+static struct net_device_stats *
+ar6000_get_stats(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    return &ar->arNetStats;
+}
+
+static struct iw_statistics *
+ar6000_get_iwstats(struct net_device * dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    struct iw_statistics * pIwStats = &ar->arIwStats;
+
+    if ((ar->arWmiReady == FALSE)
+    /*
+     * The in_atomic function is used to determine if the scheduling is
+     * allowed in the current context or not. This was introduced in 2.6
+     * From what I have read on the differences between 2.4 and 2.6, the
+     * 2.4 kernel did not support preemption and so this check might not
+     * be required for 2.4 kernels.
+     */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        || (in_atomic())
+#endif
+       )
+    {
+        pIwStats->status = 0;
+        pIwStats->qual.qual = 0;
+        pIwStats->qual.level =0;
+        pIwStats->qual.noise = 0;
+        pIwStats->discard.code =0;
+        pIwStats->discard.retries=0;
+        pIwStats->miss.beacon =0;
+        return pIwStats;
+    }
+    if (down_interruptible(&ar->arSem)) {
+        pIwStats->status = 0;
+        return pIwStats;
+    }
+
+
+    ar->statsUpdatePending = TRUE;
+
+    if(wmi_get_stats_cmd(ar->arWmi) != A_OK) {
+        up(&ar->arSem);
+        pIwStats->status = 0;
+        return pIwStats;
+    }
+
+    wait_event_interruptible_timeout(arEvent, ar->statsUpdatePending == FALSE, wmitimeout * HZ);
+
+    if (signal_pending(current)) {
+        AR_DEBUG_PRINTF("ar6000 : WMI get stats timeout \n");
+        up(&ar->arSem);
+        pIwStats->status = 0;
+        return pIwStats;
+    }
+    pIwStats->status = 1 ;
+    pIwStats->qual.qual = pStats->cs_aveBeacon_rssi;
+    pIwStats->qual.level =pStats->cs_aveBeacon_rssi + 161;  /* noise is -95 dBm */
+    pIwStats->qual.noise = pStats->noise_floor_calibation;
+    pIwStats->discard.code = pStats->rx_decrypt_err;
+    pIwStats->discard.retries = pStats->tx_retry_cnt;
+    pIwStats->miss.beacon = pStats->cs_bmiss_cnt;
+    up(&ar->arSem);
+    return pIwStats;
+}
+
+void
+ar6000_ready_event(void *devt, A_UINT8 *datap, A_UINT8 phyCap)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+    struct net_device *dev = ar->arNetDev;
+
+    ar->arWmiReady = TRUE;
+    wake_up(&arEvent);
+    A_MEMCPY(dev->dev_addr, datap, AR6000_ETH_ADDR_LEN);
+    AR_DEBUG_PRINTF("mac address = %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+        dev->dev_addr[0], dev->dev_addr[1],
+        dev->dev_addr[2], dev->dev_addr[3],
+        dev->dev_addr[4], dev->dev_addr[5]);
+
+    ar->arPhyCapability = phyCap;
+}
+
+A_UINT8
+ar6000_iptos_to_userPriority(A_UINT8 *pkt)
+{
+    struct iphdr *ipHdr = (struct iphdr *)pkt;
+    A_UINT8 userPriority;
+
+    /*
+     * IP Tos format :
+     *      (Refer Pg 57 WMM-test-plan-v1.2)
+     * IP-TOS - 8bits
+     *          : DSCP(6-bits) ECN(2-bits)
+     *          : DSCP - P2 P1 P0 X X X
+     *              where (P2 P1 P0) form 802.1D
+     */
+    userPriority = ipHdr->tos >> 5;
+    return (userPriority & 0x7);
+}
+
+void
+ar6000_connect_event(AR_SOFTC_T *ar, A_UINT16 channel, A_UINT8 *bssid,
+                     A_UINT16 listenInterval, A_UINT16 beaconInterval,
+                     NETWORK_TYPE networkType, A_UINT8 beaconIeLen,
+                     A_UINT8 assocReqLen, A_UINT8 assocRespLen,
+                     A_UINT8 *assocInfo)
+{
+    union iwreq_data wrqu;
+    int i, beacon_ie_pos, assoc_resp_ie_pos, assoc_req_ie_pos;
+    static const char *tag1 = "ASSOCINFO(ReqIEs=";
+    static const char *tag2 = "ASSOCRESPIE=";
+    static const char *beaconIetag = "BEACONIE=";
+    char buf[WMI_CONTROL_MSG_MAX_LEN * 2 + sizeof(tag1)];
+    char *pos;
+    A_UINT8 key_op_ctrl;
+
+    A_MEMCPY(ar->arBssid, bssid, sizeof(ar->arBssid));
+    ar->arBssChannel = channel;
+
+    A_PRINTF("AR6000 connected event on freq %d ", channel);
+    A_PRINTF("with bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x "
+            " listenInterval=%d, beaconInterval = %d, beaconIeLen = %d assocReqLen=%d"
+            " assocRespLen =%d\n",
+             bssid[0], bssid[1], bssid[2],
+             bssid[3], bssid[4], bssid[5],
+             listenInterval, beaconInterval,
+             beaconIeLen, assocReqLen, assocRespLen);
+    if (networkType & ADHOC_NETWORK) {
+        if (networkType & ADHOC_CREATOR) {
+            A_PRINTF("Network: Adhoc (Creator)\n");
+        } else {
+            A_PRINTF("Network: Adhoc (Joiner)\n");
+        }
+    } else {
+        A_PRINTF("Network: Infrastructure\n");
+    }
+
+    if (beaconIeLen && (sizeof(buf) > (9 + beaconIeLen * 2))) {
+        AR_DEBUG_PRINTF("\nBeaconIEs= ");
+
+        beacon_ie_pos = 0;
+        A_MEMZERO(buf, sizeof(buf));
+        sprintf(buf, "%s", beaconIetag);
+        pos = buf + 9;
+        for (i = beacon_ie_pos; i < beacon_ie_pos + beaconIeLen; i++) {
+            AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+            sprintf(pos, "%2.2x", assocInfo[i]);
+            pos += 2;
+        }
+        AR_DEBUG_PRINTF("\n");
+
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+
+    if (assocRespLen && (sizeof(buf) > (12 + (assocRespLen * 2))))
+    {
+        assoc_resp_ie_pos = beaconIeLen + assocReqLen +
+                            sizeof(A_UINT16)  +  /* capinfo*/
+                            sizeof(A_UINT16)  +  /* status Code */
+                            sizeof(A_UINT16)  ;  /* associd */
+        A_MEMZERO(buf, sizeof(buf));
+        sprintf(buf, "%s", tag2);
+        pos = buf + 12;
+        AR_DEBUG_PRINTF("\nAssocRespIEs= ");
+        /*
+         * The Association Response Frame w.o. the WLAN header is delivered to
+         * the host, so skip over to the IEs
+         */
+        for (i = assoc_resp_ie_pos; i < assoc_resp_ie_pos + assocRespLen - 6; i++)
+        {
+            AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+            sprintf(pos, "%2.2x", assocInfo[i]);
+            pos += 2;
+        }
+        AR_DEBUG_PRINTF("\n");
+
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+
+    if (assocReqLen && (sizeof(buf) > (17 + (assocReqLen * 2)))) {
+        /*
+         * assoc Request includes capability and listen interval. Skip these.
+         */
+        assoc_req_ie_pos =  beaconIeLen +
+                            sizeof(A_UINT16)  +  /* capinfo*/
+                            sizeof(A_UINT16);    /* listen interval */
+
+        A_MEMZERO(buf, sizeof(buf));
+        sprintf(buf, "%s", tag1);
+        pos = buf + 17;
+        AR_DEBUG_PRINTF("AssocReqIEs= ");
+        for (i = assoc_req_ie_pos; i < assoc_req_ie_pos + assocReqLen - 4; i++) {
+            AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+            sprintf(pos, "%2.2x", assocInfo[i]);
+            pos += 2;;
+        }
+        AR_DEBUG_PRINTF("\n");
+
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+
+#ifdef USER_KEYS
+    if (ar->user_savedkeys_stat == USER_SAVEDKEYS_STAT_RUN &&
+        ar->user_saved_keys.keyOk == TRUE)
+    {
+
+        key_op_ctrl = KEY_OP_VALID_MASK & ~KEY_OP_INIT_TSC;
+        if (ar->user_key_ctrl & AR6000_USER_SETKEYS_RSC_UNCHANGED) {
+            key_op_ctrl &= ~KEY_OP_INIT_RSC;
+        } else {
+            key_op_ctrl |= KEY_OP_INIT_RSC;
+        }
+        ar6000_reinstall_keys(ar, key_op_ctrl);
+    }
+#endif /* USER_KEYS */
+
+        /* flush data queues */
+    ar6000_TxDataCleanup(ar);
+
+    netif_start_queue(ar->arNetDev);
+
+    if ((OPEN_AUTH == ar->arDot11AuthMode) &&
+        (NONE_AUTH == ar->arAuthMode)      &&
+        (WEP_CRYPT == ar->arPairwiseCrypto))
+    {
+        if (!ar->arConnected) {
+            ar6000_install_static_wep_keys(ar);
+        }
+    }
+
+    ar->arConnected  = TRUE;
+    ar->arConnectPending = FALSE;
+
+    reconnect_flag = 0;
+
+    A_MEMZERO(&wrqu, sizeof(wrqu));
+    A_MEMCPY(wrqu.addr.sa_data, bssid, IEEE80211_ADDR_LEN);
+    wrqu.addr.sa_family = ARPHRD_ETHER;
+    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);
+    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable) {
+        A_MEMZERO(ar->arNodeMap, sizeof(ar->arNodeMap));
+        ar->arNodeNum = 0;
+        ar->arNexEpId = ENDPOINT_2;
+    }
+
+}
+
+void ar6000_set_numdataendpts(AR_SOFTC_T *ar, A_UINT32 num)
+{
+    A_ASSERT(num <= (HTC_MAILBOX_NUM_MAX - 1));
+    ar->arNumDataEndPts = num;
+}
+
+void
+ar6000_disconnect_event(AR_SOFTC_T *ar, A_UINT8 reason, A_UINT8 *bssid,
+                        A_UINT8 assocRespLen, A_UINT8 *assocInfo, A_UINT16 protocolReasonStatus)
+{
+    A_UINT8 i;
+
+    A_PRINTF("AR6000 disconnected");
+    if (bssid[0] || bssid[1] || bssid[2] || bssid[3] || bssid[4] || bssid[5]) {
+        A_PRINTF(" from %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ",
+                 bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);
+    }
+    A_PRINTF("\n");
+
+    AR_DEBUG_PRINTF("\nDisconnect Reason is %d", reason);
+    AR_DEBUG_PRINTF("\nProtocol Reason/Status Code is %d", protocolReasonStatus);
+    AR_DEBUG_PRINTF("\nAssocResp Frame = %s",
+                    assocRespLen ? " " : "NULL");
+    for (i = 0; i < assocRespLen; i++) {
+        if (!(i % 0x10)) {
+            AR_DEBUG_PRINTF("\n");
+        }
+        AR_DEBUG_PRINTF("%2.2x ", assocInfo[i]);
+    }
+    AR_DEBUG_PRINTF("\n");
+    /*
+     * If the event is due to disconnect cmd from the host, only they the target
+     * would stop trying to connect. Under any other condition, target would
+     * keep trying to connect.
+     *
+     */
+    if( reason == DISCONNECT_CMD)
+    {
+        ar->arConnectPending = FALSE;
+    } else {
+        ar->arConnectPending = TRUE;
+        if (((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x11)) ||
+            ((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x0) && (reconnect_flag == 1))) {
+            ar->arConnected = TRUE;
+            return;
+        }
+    }
+    ar->arConnected = FALSE;
+
+    if( (reason != CSERV_DISCONNECT) || (reconnect_flag != 1) ) {
+        reconnect_flag = 0;
+    }
+
+#ifdef USER_KEYS
+    if (reason != CSERV_DISCONNECT)
+    {
+        ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;
+        ar->user_key_ctrl      = 0;
+    }
+#endif /* USER_KEYS */
+
+    netif_stop_queue(ar->arNetDev);
+    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));
+    ar->arBssChannel = 0;
+    ar->arBeaconInterval = 0;
+
+    ar6000_TxDataCleanup(ar);
+}
+
+void
+ar6000_regDomain_event(AR_SOFTC_T *ar, A_UINT32 regCode)
+{
+    A_PRINTF("AR6000 Reg Code = 0x%x\n", regCode);
+    ar->arRegCode = regCode;
+}
+
+void
+ar6000_neighborReport_event(AR_SOFTC_T *ar, int numAps, WMI_NEIGHBOR_INFO *info)
+{
+    static const char *tag = "PRE-AUTH";
+    char buf[128];
+    union iwreq_data wrqu;
+    int i;
+
+    AR_DEBUG_PRINTF("AR6000 Neighbor Report Event\n");
+    for (i=0; i < numAps; info++, i++) {
+        AR_DEBUG_PRINTF("bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ",
+            info->bssid[0], info->bssid[1], info->bssid[2],
+            info->bssid[3], info->bssid[4], info->bssid[5]);
+        if (info->bssFlags & WMI_PREAUTH_CAPABLE_BSS) {
+            AR_DEBUG_PRINTF("preauth-cap");
+        }
+        if (info->bssFlags & WMI_PMKID_VALID_BSS) {
+            AR_DEBUG_PRINTF(" pmkid-valid\n");
+            continue;           /* we skip bss if the pmkid is already valid */
+        }
+        AR_DEBUG_PRINTF("\n");
+        snprintf(buf, sizeof(buf), "%s%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
+                 tag,
+                 info->bssid[0], info->bssid[1], info->bssid[2],
+                 info->bssid[3], info->bssid[4], info->bssid[5],
+                 i, info->bssFlags);
+        A_MEMZERO(&wrqu, sizeof(wrqu));
+        wrqu.data.length = strlen(buf);
+        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+    }
+}
+
+void
+ar6000_tkip_micerr_event(AR_SOFTC_T *ar, A_UINT8 keyid, A_BOOL ismcast)
+{
+    static const char *tag = "MLME-MICHAELMICFAILURE.indication";
+    char buf[128];
+    union iwreq_data wrqu;
+
+    A_PRINTF("AR6000 TKIP MIC error received for keyid %d %scast\n",
+             keyid, ismcast ? "multi": "uni");
+    snprintf(buf, sizeof(buf), "%s(keyid=%d %scat)", tag, keyid,
+             ismcast ? "multi" : "uni");
+    memset(&wrqu, 0, sizeof(wrqu));
+    wrqu.data.length = strlen(buf);
+    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+}
+
+void
+ar6000_scanComplete_event(AR_SOFTC_T *ar, A_STATUS status)
+{
+	AR_DEBUG_PRINTF("AR6000 scan complete: %d\n", status);
+
+	ar->scan_complete = 1;
+	wake_up_interruptible(&ar6000_scan_queue);
+}
+
+void
+ar6000_targetStats_event(AR_SOFTC_T *ar,  WMI_TARGET_STATS *pTarget)
+{
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    A_UINT8 ac;
+
+    /*A_PRINTF("AR6000 updating target stats\n");*/
+    pStats->tx_packets          += pTarget->txrxStats.tx_stats.tx_packets;
+    pStats->tx_bytes            += pTarget->txrxStats.tx_stats.tx_bytes;
+    pStats->tx_unicast_pkts     += pTarget->txrxStats.tx_stats.tx_unicast_pkts;
+    pStats->tx_unicast_bytes    += pTarget->txrxStats.tx_stats.tx_unicast_bytes;
+    pStats->tx_multicast_pkts   += pTarget->txrxStats.tx_stats.tx_multicast_pkts;
+    pStats->tx_multicast_bytes  += pTarget->txrxStats.tx_stats.tx_multicast_bytes;
+    pStats->tx_broadcast_pkts   += pTarget->txrxStats.tx_stats.tx_broadcast_pkts;
+    pStats->tx_broadcast_bytes  += pTarget->txrxStats.tx_stats.tx_broadcast_bytes;
+    pStats->tx_rts_success_cnt  += pTarget->txrxStats.tx_stats.tx_rts_success_cnt;
+    for(ac = 0; ac < WMM_NUM_AC; ac++)
+        pStats->tx_packet_per_ac[ac] += pTarget->txrxStats.tx_stats.tx_packet_per_ac[ac];
+    pStats->tx_errors           += pTarget->txrxStats.tx_stats.tx_errors;
+    pStats->tx_failed_cnt       += pTarget->txrxStats.tx_stats.tx_failed_cnt;
+    pStats->tx_retry_cnt        += pTarget->txrxStats.tx_stats.tx_retry_cnt;
+    pStats->tx_rts_fail_cnt     += pTarget->txrxStats.tx_stats.tx_rts_fail_cnt;
+    pStats->tx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.tx_stats.tx_unicast_rate);
+
+    pStats->rx_packets          += pTarget->txrxStats.rx_stats.rx_packets;
+    pStats->rx_bytes            += pTarget->txrxStats.rx_stats.rx_bytes;
+    pStats->rx_unicast_pkts     += pTarget->txrxStats.rx_stats.rx_unicast_pkts;
+    pStats->rx_unicast_bytes    += pTarget->txrxStats.rx_stats.rx_unicast_bytes;
+    pStats->rx_multicast_pkts   += pTarget->txrxStats.rx_stats.rx_multicast_pkts;
+    pStats->rx_multicast_bytes  += pTarget->txrxStats.rx_stats.rx_multicast_bytes;
+    pStats->rx_broadcast_pkts   += pTarget->txrxStats.rx_stats.rx_broadcast_pkts;
+    pStats->rx_broadcast_bytes  += pTarget->txrxStats.rx_stats.rx_broadcast_bytes;
+    pStats->rx_fragment_pkt     += pTarget->txrxStats.rx_stats.rx_fragment_pkt;
+    pStats->rx_errors           += pTarget->txrxStats.rx_stats.rx_errors;
+    pStats->rx_crcerr           += pTarget->txrxStats.rx_stats.rx_crcerr;
+    pStats->rx_key_cache_miss   += pTarget->txrxStats.rx_stats.rx_key_cache_miss;
+    pStats->rx_decrypt_err      += pTarget->txrxStats.rx_stats.rx_decrypt_err;
+    pStats->rx_duplicate_frames += pTarget->txrxStats.rx_stats.rx_duplicate_frames;
+    pStats->rx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.rx_stats.rx_unicast_rate);
+
+
+    pStats->tkip_local_mic_failure
+                                += pTarget->txrxStats.tkipCcmpStats.tkip_local_mic_failure;
+    pStats->tkip_counter_measures_invoked
+                                += pTarget->txrxStats.tkipCcmpStats.tkip_counter_measures_invoked;
+    pStats->tkip_replays        += pTarget->txrxStats.tkipCcmpStats.tkip_replays;
+    pStats->tkip_format_errors  += pTarget->txrxStats.tkipCcmpStats.tkip_format_errors;
+    pStats->ccmp_format_errors  += pTarget->txrxStats.tkipCcmpStats.ccmp_format_errors;
+    pStats->ccmp_replays        += pTarget->txrxStats.tkipCcmpStats.ccmp_replays;
+
+
+    pStats->power_save_failure_cnt += pTarget->pmStats.power_save_failure_cnt;
+    pStats->noise_floor_calibation = pTarget->noise_floor_calibation;
+
+    pStats->cs_bmiss_cnt        += pTarget->cservStats.cs_bmiss_cnt;
+    pStats->cs_lowRssi_cnt      += pTarget->cservStats.cs_lowRssi_cnt;
+    pStats->cs_connect_cnt      += pTarget->cservStats.cs_connect_cnt;
+    pStats->cs_disconnect_cnt   += pTarget->cservStats.cs_disconnect_cnt;
+    pStats->cs_aveBeacon_snr    = pTarget->cservStats.cs_aveBeacon_snr;
+    pStats->cs_aveBeacon_rssi   = pTarget->cservStats.cs_aveBeacon_rssi;
+    pStats->cs_lastRoam_msec    = pTarget->cservStats.cs_lastRoam_msec;
+    pStats->cs_snr              = pTarget->cservStats.cs_snr;
+    pStats->cs_rssi             = pTarget->cservStats.cs_rssi;
+
+    pStats->lq_val              = pTarget->lqVal;
+
+    pStats->wow_num_pkts_dropped += pTarget->wowStats.wow_num_pkts_dropped;
+    pStats->wow_num_host_pkt_wakeups += pTarget->wowStats.wow_num_host_pkt_wakeups;
+    pStats->wow_num_host_event_wakeups += pTarget->wowStats.wow_num_host_event_wakeups;
+    pStats->wow_num_events_discarded += pTarget->wowStats.wow_num_events_discarded;
+
+    ar->statsUpdatePending = FALSE;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_rssiThreshold_event(AR_SOFTC_T *ar,  WMI_RSSI_THRESHOLD_VAL newThreshold, A_INT16 rssi)
+{
+    USER_RSSI_THOLD userRssiThold;
+
+    userRssiThold.tag = rssi_map[newThreshold].tag;
+    userRssiThold.rssi = rssi;
+    AR_DEBUG2_PRINTF("rssi Threshold range = %d tag = %d  rssi = %d\n", newThreshold, userRssiThold.tag, rssi);
+#ifdef SEND_EVENT_TO_APP
+    ar6000_send_event_to_app(ar, WMI_RSSI_THRESHOLD_EVENTID,(A_UINT8 *)&userRssiThold, sizeof(USER_RSSI_THOLD));
+#endif
+}
+
+
+void
+ar6000_hbChallengeResp_event(AR_SOFTC_T *ar, A_UINT32 cookie, A_UINT32 source)
+{
+    if (source == APP_HB_CHALLENGE) {
+        /* Report it to the app in case it wants a positive acknowledgement */
+#ifdef SEND_EVENT_TO_APP
+        ar6000_send_event_to_app(ar, WMIX_HB_CHALLENGE_RESP_EVENTID,
+                                 (A_UINT8 *)&cookie, sizeof(cookie));
+#endif
+    } else {
+        /* This would ignore the replys that come in after their due time */
+        if (cookie == ar->arHBChallengeResp.seqNum) {
+            ar->arHBChallengeResp.outstanding = FALSE;
+        }
+    }
+}
+
+
+void
+ar6000_reportError_event(AR_SOFTC_T *ar, WMI_TARGET_ERROR_VAL errorVal)
+{
+    char    *errString[] = {
+                [WMI_TARGET_PM_ERR_FAIL]    "WMI_TARGET_PM_ERR_FAIL",
+                [WMI_TARGET_KEY_NOT_FOUND]  "WMI_TARGET_KEY_NOT_FOUND",
+                [WMI_TARGET_DECRYPTION_ERR] "WMI_TARGET_DECRYPTION_ERR",
+                [WMI_TARGET_BMISS]          "WMI_TARGET_BMISS",
+                [WMI_PSDISABLE_NODE_JOIN]   "WMI_PSDISABLE_NODE_JOIN"
+                };
+
+    A_PRINTF("AR6000 Error on Target. Error = 0x%x\n", errorVal);
+
+    /* One error is reported at a time, and errorval is a bitmask */
+    if(errorVal & (errorVal - 1))
+       return;
+
+    A_PRINTF("AR6000 Error type = ");
+    switch(errorVal)
+    {
+        case WMI_TARGET_PM_ERR_FAIL:
+        case WMI_TARGET_KEY_NOT_FOUND:
+        case WMI_TARGET_DECRYPTION_ERR:
+        case WMI_TARGET_BMISS:
+        case WMI_PSDISABLE_NODE_JOIN:
+            A_PRINTF("%s\n", errString[errorVal]);
+            break;
+        default:
+            A_PRINTF("INVALID\n");
+            break;
+    }
+
+}
+
+
+void
+ar6000_cac_event(AR_SOFTC_T *ar, A_UINT8 ac, A_UINT8 cacIndication,
+                 A_UINT8 statusCode, A_UINT8 *tspecSuggestion)
+{
+    WMM_TSPEC_IE    *tspecIe;
+
+    /*
+     * This is the TSPEC IE suggestion from AP.
+     * Suggestion provided by AP under some error
+     * cases, could be helpful for the host app.
+     * Check documentation.
+     */
+    tspecIe = (WMM_TSPEC_IE *)tspecSuggestion;
+
+    /*
+     * What do we do, if we get TSPEC rejection? One thought
+     * that comes to mind is implictly delete the pstream...
+     */
+    A_PRINTF("AR6000 CAC notification. "
+                "AC = %d, cacIndication = 0x%x, statusCode = 0x%x\n",
+                 ac, cacIndication, statusCode);
+}
+
+#define AR6000_PRINT_BSSID(_pBss)  do {     \
+        A_PRINTF("%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ",\
+                 (_pBss)[0],(_pBss)[1],(_pBss)[2],(_pBss)[3],\
+                 (_pBss)[4],(_pBss)[5]);  \
+} while(0)
+
+void
+ar6000_roam_tbl_event(AR_SOFTC_T *ar, WMI_TARGET_ROAM_TBL *pTbl)
+{
+    A_UINT8 i;
+
+    A_PRINTF("ROAM TABLE NO OF ENTRIES is %d ROAM MODE is %d\n",
+              pTbl->numEntries, pTbl->roamMode);
+    for (i= 0; i < pTbl->numEntries; i++) {
+        A_PRINTF("[%d]bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x ", i,
+            pTbl->bssRoamInfo[i].bssid[0], pTbl->bssRoamInfo[i].bssid[1],
+            pTbl->bssRoamInfo[i].bssid[2],
+            pTbl->bssRoamInfo[i].bssid[3],
+            pTbl->bssRoamInfo[i].bssid[4],
+            pTbl->bssRoamInfo[i].bssid[5]);
+        A_PRINTF("RSSI %d RSSIDT %d LAST RSSI %d UTIL %d ROAM_UTIL %d"
+                 " BIAS %d\n",
+            pTbl->bssRoamInfo[i].rssi,
+            pTbl->bssRoamInfo[i].rssidt,
+            pTbl->bssRoamInfo[i].last_rssi,
+            pTbl->bssRoamInfo[i].util,
+            pTbl->bssRoamInfo[i].roam_util,
+            pTbl->bssRoamInfo[i].bias);
+    }
+}
+
+void
+ar6000_wow_list_event(struct ar6_softc *ar, A_UINT8 num_filters, WMI_GET_WOW_LIST_REPLY *wow_reply)
+{
+    A_UINT8 i,j;
+
+    /*Each event now contains exactly one filter, see bug 26613*/
+    A_PRINTF("WOW pattern %d of %d patterns\n", wow_reply->this_filter_num,                 wow_reply->num_filters);
+    A_PRINTF("wow mode = %s host mode = %s\n",
+            (wow_reply->wow_mode == 0? "disabled":"enabled"),
+            (wow_reply->host_mode == 1 ? "awake":"asleep"));
+
+
+    /*If there are no patterns, the reply will only contain generic
+      WoW information. Pattern information will exist only if there are
+      patterns present. Bug 26716*/
+
+   /* If this event contains pattern information, display it*/
+    if (wow_reply->this_filter_num) {
+        i=0;
+        A_PRINTF("id=%d size=%d offset=%d\n",
+                    wow_reply->wow_filters[i].wow_filter_id,
+                    wow_reply->wow_filters[i].wow_filter_size,
+                    wow_reply->wow_filters[i].wow_filter_offset);
+       A_PRINTF("wow pattern = ");
+       for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {
+             A_PRINTF("%2.2x",wow_reply->wow_filters[i].wow_filter_pattern[j]);
+        }
+
+        A_PRINTF("\nwow mask = ");
+        for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {
+            A_PRINTF("%2.2x",wow_reply->wow_filters[i].wow_filter_mask[j]);
+        }
+        A_PRINTF("\n");
+    }
+}
+
+/*
+ * Report the Roaming related data collected on the target
+ */
+void
+ar6000_display_roam_time(WMI_TARGET_ROAM_TIME *p)
+{
+    A_PRINTF("Disconnect Data : BSSID: ");
+    AR6000_PRINT_BSSID(p->disassoc_bssid);
+    A_PRINTF(" RSSI %d DISASSOC Time %d NO_TXRX_TIME %d\n",
+             p->disassoc_bss_rssi,p->disassoc_time,
+             p->no_txrx_time);
+    A_PRINTF("Connect Data: BSSID: ");
+    AR6000_PRINT_BSSID(p->assoc_bssid);
+    A_PRINTF(" RSSI %d ASSOC Time %d TXRX_TIME %d\n",
+             p->assoc_bss_rssi,p->assoc_time,
+             p->allow_txrx_time);
+    A_PRINTF("Last Data Tx Time (b4 Disassoc) %d "\
+             "First Data Tx Time (after Assoc) %d\n",
+             p->last_data_txrx_time, p->first_data_txrx_time);
+}
+
+void
+ar6000_roam_data_event(AR_SOFTC_T *ar, WMI_TARGET_ROAM_DATA *p)
+{
+    switch (p->roamDataType) {
+        case ROAM_DATA_TIME:
+            ar6000_display_roam_time(&p->u.roamTime);
+            break;
+        default:
+            break;
+    }
+}
+
+void
+ar6000_bssInfo_event_rx(AR_SOFTC_T *ar, A_UINT8 *datap, int len)
+{
+    struct sk_buff *skb;
+    WMI_BSS_INFO_HDR *bih = (WMI_BSS_INFO_HDR *)datap;
+
+
+    if (!ar->arMgmtFilter) {
+        return;
+    }
+    if (((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_BEACON) &&
+        (bih->frameType != BEACON_FTYPE))  ||
+        ((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_PROBE_RESP) &&
+        (bih->frameType != PROBERESP_FTYPE)))
+    {
+        return;
+    }
+
+    if ((skb = A_NETBUF_ALLOC_RAW(len)) != NULL) {
+
+        A_NETBUF_PUT(skb, len);
+        A_MEMCPY(A_NETBUF_DATA(skb), datap, len);
+        skb->dev = ar->arNetDev;
+	printk("MAC RAW...\n");
+//        skb->mac.raw = A_NETBUF_DATA(skb);
+        skb->ip_summed = CHECKSUM_NONE;
+        skb->pkt_type = PACKET_OTHERHOST;
+        skb->protocol = __constant_htons(0x0019);
+        netif_rx(skb);
+    }
+}
+
+A_UINT32 wmiSendCmdNum;
+
+A_STATUS
+ar6000_control_tx(void *devt, void *osbuf, WMI_PRI_STREAM_ID streamID)
+{
+    AR_SOFTC_T       *ar = (AR_SOFTC_T *)devt;
+    A_STATUS         status = A_OK;
+    struct ar_cookie *cookie = NULL;
+    int i;
+
+        /* take lock to protect ar6000_alloc_cookie() */
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    do {
+
+        AR_DEBUG2_PRINTF("ar_contrstatus = ol_tx: skb=0x%x, len=0x%x, sid=%d\n",
+                         (A_UINT32)osbuf, A_NETBUF_LEN(osbuf), streamID);
+
+        if ((streamID == WMI_CONTROL_PRI) && (ar->arWMIControlEpFull)) {
+                /* control endpoint is full, don't allocate resources, we
+                 * are just going to drop this packet */
+            cookie = NULL;
+            AR_DEBUG_PRINTF(" WMI Control EP full, dropping packet : 0x%X, len:%d \n",
+                    (A_UINT32)osbuf, A_NETBUF_LEN(osbuf));
+        } else {
+            cookie = ar6000_alloc_cookie(ar);
+        }
+
+        if (cookie == NULL) {
+            status = A_NO_MEMORY;
+            break;
+        }
+
+        if(logWmiRawMsgs) {
+            A_PRINTF("WMI cmd send, msgNo %d :", wmiSendCmdNum);
+            for(i = 0; i < a_netbuf_to_len(osbuf); i++)
+                A_PRINTF("%x ", ((A_UINT8 *)a_netbuf_to_data(osbuf))[i]);
+            A_PRINTF("\n");
+        }
+
+        wmiSendCmdNum++;
+
+    } while (FALSE);
+
+    if (cookie != NULL) {
+            /* got a structure to send it out on */
+        ar->arTxPending[streamID]++;
+
+        if (streamID != WMI_CONTROL_PRI) {
+            ar->arTotalTxDataPending++;
+        }
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    if (cookie != NULL) {
+        cookie->arc_bp[0] = (A_UINT32)osbuf;
+        cookie->arc_bp[1] = 0;
+        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,
+                               cookie,
+                               A_NETBUF_DATA(osbuf),
+                               A_NETBUF_LEN(osbuf),
+                               arWMIStream2EndpointID(ar,streamID),
+                               AR6K_CONTROL_PKT_TAG);
+            /* this interface is asynchronous, if there is an error, cleanup will happen in the
+             * TX completion callback */
+        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);
+        status = A_OK;
+    }
+
+    return status;
+}
+
+/* indicate tx activity or inactivity on a WMI stream */
+void ar6000_indicate_tx_activity(void *devt, A_UINT8 TrafficClass, A_BOOL Active)
+{
+    AR_SOFTC_T  *ar = (AR_SOFTC_T *)devt;
+    WMI_PRI_STREAM_ID streamid;
+
+    if (ar->arWmiEnabled) {
+        streamid = wmi_get_stream_id(ar->arWmi, TrafficClass);
+    } else {
+            /* for mbox ping testing, the traffic class is mapped directly as a stream ID,
+             * see handling of AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE in ioctl.c */
+        streamid = (WMI_PRI_STREAM_ID)TrafficClass;
+    }
+
+        /* notify HTC, this may cause credit distribution changes */
+
+    HTCIndicateActivityChange(ar->arHtcTarget,
+                              arWMIStream2EndpointID(ar,streamid),
+                              Active);
+
+}
+
+module_init(ar6000_init_module);
+module_exit(ar6000_cleanup_module);
+
+/* Init cookie queue */
+static void
+ar6000_cookie_init(AR_SOFTC_T *ar)
+{
+    A_UINT32    i;
+
+    ar->arCookieList = NULL;
+    A_MEMZERO(s_ar_cookie_mem, sizeof(s_ar_cookie_mem));
+
+    for (i = 0; i < MAX_COOKIE_NUM; i++) {
+        ar6000_free_cookie(ar, &s_ar_cookie_mem[i]);
+    }
+}
+
+/* cleanup cookie queue */
+static void
+ar6000_cookie_cleanup(AR_SOFTC_T *ar)
+{
+    /* It is gone .... */
+    ar->arCookieList = NULL;
+}
+
+/* Init cookie queue */
+static void
+ar6000_free_cookie(AR_SOFTC_T *ar, struct ar_cookie * cookie)
+{
+    /* Insert first */
+    A_ASSERT(ar != NULL);
+    A_ASSERT(cookie != NULL);
+    cookie->arc_list_next = ar->arCookieList;
+    ar->arCookieList = cookie;
+}
+
+/* cleanup cookie queue */
+static struct ar_cookie *
+ar6000_alloc_cookie(AR_SOFTC_T  *ar)
+{
+    struct ar_cookie   *cookie;
+
+    cookie = ar->arCookieList;
+    if(cookie != NULL)
+    {
+        ar->arCookieList = cookie->arc_list_next;
+    }
+
+    return cookie;
+}
+
+#ifdef SEND_EVENT_TO_APP
+/*
+ * This function is used to send event which come from taget to
+ * the application. The buf which send to application is include
+ * the event ID and event content.
+ */
+#define EVENT_ID_LEN   2
+void ar6000_send_event_to_app(AR_SOFTC_T *ar, A_UINT16 eventId,
+                              A_UINT8 *datap, int len)
+{
+
+#if (WIRELESS_EXT >= 15)
+
+/* note: IWEVCUSTOM only exists in wireless extensions after version 15 */
+
+    char *buf;
+    A_UINT16 size;
+    union iwreq_data wrqu;
+
+    size = len + EVENT_ID_LEN;
+
+    if (size > IW_CUSTOM_MAX) {
+        AR_DEBUG_PRINTF("WMI event ID : 0x%4.4X, len = %d too big for IWEVCUSTOM (max=%d) \n",
+                eventId, size, IW_CUSTOM_MAX);
+        return;
+    }
+
+    buf = A_MALLOC_NOWAIT(size);
+    A_MEMZERO(buf, size);
+    A_MEMCPY(buf, &eventId, EVENT_ID_LEN);
+    A_MEMCPY(buf+EVENT_ID_LEN, datap, len);
+
+    //AR_DEBUG_PRINTF("event ID = %d,len = %d\n",*(A_UINT16*)buf, size);
+    A_MEMZERO(&wrqu, sizeof(wrqu));
+    wrqu.data.length = size;
+    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);
+
+    A_FREE(buf);
+#endif
+
+
+}
+#endif
+
+
+void
+ar6000_tx_retry_err_event(void *devt)
+{
+    AR_DEBUG2_PRINTF("Tx retries reach maximum!\n");
+}
+
+void
+ar6000_snrThresholdEvent_rx(void *devt, WMI_SNR_THRESHOLD_VAL newThreshold, A_UINT8 snr)
+{
+    AR_DEBUG2_PRINTF("snr threshold range %d, snr %d\n", newThreshold, snr);
+}
+
+void
+ar6000_lqThresholdEvent_rx(void *devt, WMI_LQ_THRESHOLD_VAL newThreshold, A_UINT8 lq)
+{
+    AR_DEBUG2_PRINTF("lq threshold range %d, lq %d\n", newThreshold, lq);
+}
+
+
+
+A_UINT32
+a_copy_to_user(void *to, const void *from, A_UINT32 n)
+{
+    return(copy_to_user(to, from, n));
+}
+
+A_UINT32
+a_copy_from_user(void *to, const void *from, A_UINT32 n)
+{
+    return(copy_from_user(to, from, n));
+}
+
+
+A_STATUS
+ar6000_get_driver_cfg(struct net_device *dev,
+                        A_UINT16 cfgParam,
+                        void *result)
+{
+
+    A_STATUS    ret = 0;
+
+    switch(cfgParam)
+    {
+        case AR6000_DRIVER_CFG_GET_WLANNODECACHING:
+           *((A_UINT32 *)result) = wlanNodeCaching;
+           break;
+        case AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS:
+           *((A_UINT32 *)result) = logWmiRawMsgs;
+            break;
+        default:
+           ret = EINVAL;
+           break;
+    }
+
+    return ret;
+}
+
+void
+ar6000_keepalive_rx(void *devt, A_UINT8 configured)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+
+    ar->arKeepaliveConfigured = configured;
+    wake_up(&arEvent);
+}
+
+void
+ar6000_pmkid_list_event(void *devt, A_UINT8 numPMKID, WMI_PMKID *pmkidList)
+{
+    A_UINT8 i, j;
+
+    A_PRINTF("Number of Cached PMKIDs is %d\n", numPMKID);
+
+    for (i = 0; i < numPMKID; i++) {
+        A_PRINTF("\nPMKID %d ", i);
+            for (j = 0; j < WMI_PMKID_LEN; j++) {
+                A_PRINTF("%2.2x", pmkidList->pmkid[j]);
+            }
+        pmkidList++;
+    }
+}
+
+#ifdef USER_KEYS
+static A_STATUS
+
+ar6000_reinstall_keys(AR_SOFTC_T *ar, A_UINT8 key_op_ctrl)
+{
+    A_STATUS status = A_OK;
+    struct ieee80211req_key *uik = &ar->user_saved_keys.ucast_ik;
+    struct ieee80211req_key *bik = &ar->user_saved_keys.bcast_ik;
+    CRYPTO_TYPE  keyType = ar->user_saved_keys.keyType;
+
+    if (IEEE80211_CIPHER_CCKM_KRK != uik->ik_type) {
+        if (NONE_CRYPT == keyType) {
+            goto _reinstall_keys_out;
+        }
+
+        if (uik->ik_keylen) {
+            status = wmi_addKey_cmd(ar->arWmi, uik->ik_keyix,
+                    ar->user_saved_keys.keyType, PAIRWISE_USAGE,
+                    uik->ik_keylen, (A_UINT8 *)&uik->ik_keyrsc,
+                    uik->ik_keydata, key_op_ctrl, SYNC_BEFORE_WMIFLAG);
+        }
+
+    } else {
+        status = wmi_add_krk_cmd(ar->arWmi, uik->ik_keydata);
+    }
+
+    if (IEEE80211_CIPHER_CCKM_KRK != bik->ik_type) {
+        if (NONE_CRYPT == keyType) {
+            goto _reinstall_keys_out;
+        }
+
+        if (bik->ik_keylen) {
+            status = wmi_addKey_cmd(ar->arWmi, bik->ik_keyix,
+                    ar->user_saved_keys.keyType, GROUP_USAGE,
+                    bik->ik_keylen, (A_UINT8 *)&bik->ik_keyrsc,
+                    bik->ik_keydata, key_op_ctrl, NO_SYNC_WMIFLAG);
+        }
+    } else {
+        status = wmi_add_krk_cmd(ar->arWmi, bik->ik_keydata);
+    }
+
+_reinstall_keys_out:
+    ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;
+    ar->user_key_ctrl      = 0;
+
+    return status;
+}
+#endif /* USER_KEYS */
+
+
+void
+ar6000_dset_open_req(
+    void *context,
+    A_UINT32 id,
+    A_UINT32 targHandle,
+    A_UINT32 targReplyFn,
+    A_UINT32 targReplyArg)
+{
+}
+
+void
+ar6000_dset_close(
+    void *context,
+    A_UINT32 access_cookie)
+{
+    return;
+}
+
+void
+ar6000_dset_data_req(
+   void *context,
+   A_UINT32 accessCookie,
+   A_UINT32 offset,
+   A_UINT32 length,
+   A_UINT32 targBuf,
+   A_UINT32 targReplyFn,
+   A_UINT32 targReplyArg)
+{
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6000_drv.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6000_drv.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6000_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6000_drv.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,360 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _AR6000_H_
+#define _AR6000_H_
+
+#include <linux/version.h>
+
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/skbuff.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/iw_handler.h>
+#include <linux/if_arp.h>
+#include <linux/ip.h>
+#include <linux/semaphore.h>
+#include <linux/wireless.h>
+#include <linux/module.h>
+#include <asm/io.h>
+
+#include <a_config.h>
+#include <athdefs.h>
+#include "a_types.h"
+#include "a_osapi.h"
+#include "htc_api.h"
+#include "wmi.h"
+#include "a_drv.h"
+#include "bmi.h"
+#include <ieee80211.h>
+#include <ieee80211_ioctl.h>
+#include <wlan_api.h>
+#include <wmi_api.h>
+#include "gpio_api.h"
+#include "gpio.h"
+#include <host_version.h>
+#include <linux/rtnetlink.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include "AR6Khwreg.h"
+#include "ar6000_api.h"
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+#include <testcmd.h>
+#endif
+
+#include "targaddrs.h"
+#include "dbglog_api.h"
+#include "ar6000_diag.h"
+#include "common_drv.h"
+
+#ifndef  __dev_put
+#define  __dev_put(dev) dev_put(dev)
+#endif
+
+#ifdef USER_KEYS
+
+#define USER_SAVEDKEYS_STAT_INIT     0
+#define USER_SAVEDKEYS_STAT_RUN      1
+
+// TODO this needs to move into the AR_SOFTC struct
+struct USER_SAVEDKEYS {
+    struct ieee80211req_key   ucast_ik;
+    struct ieee80211req_key   bcast_ik;
+    CRYPTO_TYPE               keyType;
+    A_BOOL                    keyOk;
+};
+#endif
+
+#define DBG_INFO		0x00000001
+#define DBG_ERROR		0x00000002
+#define DBG_WARNING		0x00000004
+#define DBG_SDIO		0x00000008
+#define DBG_HIF			0x00000010
+#define DBG_HTC			0x00000020
+#define DBG_WMI			0x00000040
+#define DBG_WMI2		0x00000080
+#define DBG_DRIVER		0x00000100
+
+#define DBG_DEFAULTS	(DBG_ERROR|DBG_WARNING)
+
+
+#ifdef DEBUG
+#define AR_DEBUG_PRINTF(args...)        if (debugdriver) A_PRINTF(args);
+#define AR_DEBUG2_PRINTF(args...)        if (debugdriver >= 2) A_PRINTF(args);
+extern int debugdriver;
+#else
+#define AR_DEBUG_PRINTF(args...)
+#define AR_DEBUG2_PRINTF(args...)
+#endif
+
+A_STATUS ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+A_STATUS ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define	MAX_AR6000                        1
+#define AR6000_MAX_RX_BUFFERS             16
+#define AR6000_BUFFER_SIZE                1664
+#define AR6000_TX_TIMEOUT                 10
+#define	AR6000_ETH_ADDR_LEN               6
+#define	AR6000_MAX_ENDPOINTS              4
+#define MAX_NODE_NUM                      15
+#define MAX_COOKIE_NUM                    150
+#define AR6000_HB_CHALLENGE_RESP_FREQ_DEFAULT        1
+#define AR6000_HB_CHALLENGE_RESP_MISS_THRES_DEFAULT  1
+
+enum {
+    DRV_HB_CHALLENGE = 0,
+    APP_HB_CHALLENGE
+};
+
+/* HTC RAW streams */
+typedef enum _HTC_RAW_STREAM_ID {
+    HTC_RAW_STREAM_NOT_MAPPED = -1,
+    HTC_RAW_STREAM_0 = 0,
+    HTC_RAW_STREAM_1 = 1,
+    HTC_RAW_STREAM_2 = 2,
+    HTC_RAW_STREAM_3 = 3,
+    HTC_RAW_STREAM_NUM_MAX
+} HTC_RAW_STREAM_ID;
+
+#define RAW_HTC_READ_BUFFERS_NUM    4
+#define RAW_HTC_WRITE_BUFFERS_NUM   4
+
+typedef struct {
+    int currPtr;
+    int length;
+    unsigned char data[AR6000_BUFFER_SIZE];
+    HTC_PACKET    HTCPacket;
+} raw_htc_buffer;
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+/*
+ *  add TCMD_MODE besides wmi and bypasswmi
+ *  in TCMD_MODE, only few TCMD releated wmi commands
+ *  counld be hanlder
+ */
+enum {
+    AR6000_WMI_MODE = 0,
+    AR6000_BYPASS_MODE,
+    AR6000_TCMD_MODE,
+    AR6000_WLAN_MODE
+};
+#endif /* CONFIG_HOST_TCMD_SUPPORT */
+
+struct ar_wep_key {
+    A_UINT8                 arKeyIndex;
+    A_UINT8                 arKeyLen;
+    A_UINT8                 arKey[64];
+} ;
+
+struct ar_node_mapping {
+    A_UINT8                 macAddress[6];
+    A_UINT8                 epId;
+    A_UINT8                 txPending;
+};
+
+struct ar_cookie {
+    A_UINT32               arc_bp[2];    /* Must be first field */
+    HTC_PACKET             HtcPkt;       /* HTC packet wrapper */
+    struct ar_cookie *arc_list_next;
+};
+
+struct ar_hb_chlng_resp {
+    A_TIMER                 timer;
+    A_UINT32                frequency;
+    A_UINT32                seqNum;
+    A_BOOL                  outstanding;
+    A_UINT8                 missCnt;
+    A_UINT8                 missThres;
+};
+
+typedef struct ar6_softc {
+    struct net_device       *arNetDev;    /* net_device pointer */
+    void                    *arWmi;
+    int                     arTxPending[WMI_PRI_MAX_COUNT];
+    int                     arTotalTxDataPending;
+    A_UINT8                 arNumDataEndPts;
+    A_BOOL                  arWmiEnabled;
+    A_BOOL                  arWmiReady;
+    A_BOOL                  arConnected;
+    A_BOOL                  arRadioSwitch;
+    HTC_HANDLE              arHtcTarget;
+    void                    *arHifDevice;
+    spinlock_t              arLock;
+    struct semaphore        arSem;
+    int                     arRxBuffers[WMI_PRI_MAX_COUNT];
+    int                     arSsidLen;
+    u_char                  arSsid[32];
+    A_UINT8                 arNetworkType;
+    A_UINT8                 arDot11AuthMode;
+    A_UINT8                 arAuthMode;
+    A_UINT8                 arPairwiseCrypto;
+    A_UINT8                 arPairwiseCryptoLen;
+    A_UINT8                 arGroupCrypto;
+    A_UINT8                 arGroupCryptoLen;
+    A_UINT8                 arDefTxKeyIndex;
+    struct ar_wep_key       arWepKeyList[WMI_MAX_KEY_INDEX + 1];
+    A_UINT8                 arBssid[6];
+    A_UINT8                 arReqBssid[6];
+    A_UINT16                arChannelHint;
+    A_UINT16                arBssChannel;
+    A_UINT16                arListenInterval;
+    struct ar6000_version   arVersion;
+    A_UINT32                arTargetType;
+    A_INT8                  arRssi;
+    A_UINT8                 arTxPwr;
+    A_BOOL                  arTxPwrSet;
+    A_INT32                 arBitRate;
+    struct net_device_stats arNetStats;
+    struct iw_statistics 	arIwStats;
+    A_INT8                  arNumChannels;
+    A_UINT16                arChannelList[32];
+    A_UINT32                arRegCode;
+    A_BOOL                  statsUpdatePending;
+    TARGET_STATS            arTargetStats;
+    A_INT8                  arMaxRetries;
+    A_UINT8                 arPhyCapability;
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+    A_UINT8                 tcmdRxReport;
+    A_UINT32                tcmdRxTotalPkt;
+    A_INT32                 tcmdRxRssi;
+    A_UINT32                tcmdPm;
+   A_UINT32                 arTargetMode;
+#endif
+    AR6000_WLAN_STATE       arWlanState;
+    struct ar_node_mapping  arNodeMap[MAX_NODE_NUM];
+    A_UINT8                 arIbssPsEnable;
+    A_UINT8                 arNodeNum;
+    A_UINT8                 arNexEpId;
+    struct ar_cookie        *arCookieList;
+    A_UINT16                arRateMask;
+    A_UINT8                 arSkipScan;
+    A_UINT16                arBeaconInterval;
+    A_BOOL                  arConnectPending;
+    A_BOOL                  arWmmEnabled;
+    struct ar_hb_chlng_resp arHBChallengeResp;
+    A_UINT8                 arKeepaliveConfigured;
+    A_UINT32                arMgmtFilter;
+    HTC_ENDPOINT_ID         arWmi2EpMapping[WMI_PRI_MAX_COUNT];
+    WMI_PRI_STREAM_ID       arEp2WmiMapping[ENDPOINT_MAX];
+#ifdef HTC_RAW_INTERFACE
+    HTC_ENDPOINT_ID         arRaw2EpMapping[HTC_RAW_STREAM_NUM_MAX];
+    HTC_RAW_STREAM_ID       arEp2RawMapping[ENDPOINT_MAX];
+    struct semaphore        raw_htc_read_sem[HTC_RAW_STREAM_NUM_MAX];
+    struct semaphore        raw_htc_write_sem[HTC_RAW_STREAM_NUM_MAX];
+    wait_queue_head_t       raw_htc_read_queue[HTC_RAW_STREAM_NUM_MAX];
+    wait_queue_head_t       raw_htc_write_queue[HTC_RAW_STREAM_NUM_MAX];
+    raw_htc_buffer          *raw_htc_read_buffer[HTC_RAW_STREAM_NUM_MAX][RAW_HTC_READ_BUFFERS_NUM];
+    raw_htc_buffer          *raw_htc_write_buffer[HTC_RAW_STREAM_NUM_MAX][RAW_HTC_WRITE_BUFFERS_NUM];
+    A_BOOL                  write_buffer_available[HTC_RAW_STREAM_NUM_MAX];
+    A_BOOL                  read_buffer_available[HTC_RAW_STREAM_NUM_MAX];
+#endif
+    A_BOOL                  arRawIfInit;
+    int                     arDeviceIndex;
+    COMMON_CREDIT_STATE_INFO arCreditStateInfo;
+    A_BOOL                  arWMIControlEpFull;
+    A_BOOL                  dbgLogFetchInProgress;
+    A_UCHAR                 log_buffer[DBGLOG_HOST_LOG_BUFFER_SIZE];
+    A_UINT32                log_cnt;
+    A_UINT32                dbglog_init_done;
+    A_UINT32                arConnectCtrlFlags;
+	A_UINT32                scan_complete;
+#ifdef USER_KEYS
+    A_INT32                 user_savedkeys_stat;
+    A_UINT32                user_key_ctrl;
+    struct USER_SAVEDKEYS   user_saved_keys;
+#endif
+} AR_SOFTC_T;
+
+
+#define arWMIStream2EndpointID(ar,wmi)          (ar)->arWmi2EpMapping[(wmi)]
+#define arSetWMIStream2EndpointIDMap(ar,wmi,ep)  \
+{  (ar)->arWmi2EpMapping[(wmi)] = (ep); \
+   (ar)->arEp2WmiMapping[(ep)] = (wmi); }
+#define arEndpoint2WMIStreamID(ar,ep)           (ar)->arEp2WmiMapping[(ep)]
+
+#define arRawIfEnabled(ar) (ar)->arRawIfInit
+#define arRawStream2EndpointID(ar,raw)          (ar)->arRaw2EpMapping[(raw)]
+#define arSetRawStream2EndpointIDMap(ar,raw,ep)  \
+{  (ar)->arRaw2EpMapping[(raw)] = (ep); \
+   (ar)->arEp2RawMapping[(ep)] = (raw); }
+#define arEndpoint2RawStreamID(ar,ep)           (ar)->arEp2RawMapping[(ep)]
+
+struct ar_giwscan_param {
+    char    *current_ev;
+    char    *end_buf;
+    A_BOOL  firstPass;
+};
+
+#define AR6000_STAT_INC(ar, stat)       (ar->arNetStats.stat++)
+
+#define AR6000_SPIN_LOCK(lock, param)   do {                            \
+    if (irqs_disabled()) {                                              \
+        AR_DEBUG_PRINTF("IRQs disabled:AR6000_LOCK\n");                 \
+    }                                                                   \
+    spin_lock_bh(lock);                                                 \
+} while (0)
+
+#define AR6000_SPIN_UNLOCK(lock, param) do {                            \
+    if (irqs_disabled()) {                                              \
+        AR_DEBUG_PRINTF("IRQs disabled: AR6000_UNLOCK\n");              \
+    }                                                                   \
+    spin_unlock_bh(lock);                                               \
+} while (0)
+
+int ar6000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+int ar6000_ioctl_dispatcher(struct net_device *dev, struct ifreq *rq, int cmd);
+void ar6000_ioctl_iwsetup(struct iw_handler_def *def);
+void ar6000_gpio_init(void);
+void ar6000_init_profile_info(AR_SOFTC_T *ar);
+void ar6000_install_static_wep_keys(AR_SOFTC_T *ar);
+int ar6000_init(struct net_device *dev);
+int ar6000_dbglog_get_debug_logs(AR_SOFTC_T *ar);
+A_STATUS ar6000_SetHTCBlockSize(AR_SOFTC_T *ar);
+
+#ifdef HTC_RAW_INTERFACE
+
+#ifndef __user
+#define __user
+#endif
+
+int ar6000_htc_raw_open(AR_SOFTC_T *ar);
+int ar6000_htc_raw_close(AR_SOFTC_T *ar);
+ssize_t ar6000_htc_raw_read(AR_SOFTC_T *ar,
+                            HTC_RAW_STREAM_ID StreamID,
+                            char __user *buffer, size_t count);
+ssize_t ar6000_htc_raw_write(AR_SOFTC_T *ar,
+                             HTC_RAW_STREAM_ID StreamID,
+                             char __user *buffer, size_t count);
+
+#endif /* HTC_RAW_INTERFACE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _AR6000_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6000_raw_if.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6000_raw_if.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6000_raw_if.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6000_raw_if.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,440 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "ar6000_drv.h"
+
+#ifdef HTC_RAW_INTERFACE
+
+static void
+ar6000_htc_raw_read_cb(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T        *ar = (AR_SOFTC_T *)Context;
+    raw_htc_buffer    *busy;
+    HTC_RAW_STREAM_ID streamID;
+
+    busy = (raw_htc_buffer *)pPacket->pPktContext;
+    A_ASSERT(busy != NULL);
+
+    if (pPacket->Status == A_ECANCELED) {
+        /*
+         * HTC provides A_ECANCELED status when it doesn't want to be refilled
+         * (probably due to a shutdown)
+         */
+        return;
+    }
+
+    streamID = arEndpoint2RawStreamID(ar,pPacket->Endpoint);
+    A_ASSERT(streamID != HTC_RAW_STREAM_NOT_MAPPED);
+
+#ifdef CF
+   if (down_trylock(&ar->raw_htc_read_sem[streamID])) {
+#else
+    if (down_interruptible(&ar->raw_htc_read_sem[streamID])) {
+#endif /* CF */
+        AR_DEBUG2_PRINTF("Unable to down the semaphore\n");
+    }
+
+    A_ASSERT((pPacket->Status != A_OK) ||
+             (pPacket->pBuffer == (busy->data + HTC_HEADER_LEN)));
+
+    busy->length = pPacket->ActualLength + HTC_HEADER_LEN;
+    busy->currPtr = HTC_HEADER_LEN;
+    ar->read_buffer_available[streamID] = TRUE;
+    //AR_DEBUG_PRINTF("raw read cb:  0x%X 0x%X \n", busy->currPtr,busy->length);
+    up(&ar->raw_htc_read_sem[streamID]);
+
+    /* Signal the waiting process */
+    AR_DEBUG2_PRINTF("Waking up the StreamID(%d) read process\n", streamID);
+    wake_up_interruptible(&ar->raw_htc_read_queue[streamID]);
+}
+
+static void
+ar6000_htc_raw_write_cb(void *Context, HTC_PACKET *pPacket)
+{
+    AR_SOFTC_T          *ar = (AR_SOFTC_T  *)Context;
+    raw_htc_buffer      *free;
+    HTC_RAW_STREAM_ID   streamID;
+
+    free = (raw_htc_buffer *)pPacket->pPktContext;
+    A_ASSERT(free != NULL);
+
+    if (pPacket->Status == A_ECANCELED) {
+        /*
+         * HTC provides A_ECANCELED status when it doesn't want to be refilled
+         * (probably due to a shutdown)
+         */
+        return;
+    }
+
+    streamID = arEndpoint2RawStreamID(ar,pPacket->Endpoint);
+    A_ASSERT(streamID != HTC_RAW_STREAM_NOT_MAPPED);
+
+#ifdef CF
+    if (down_trylock(&ar->raw_htc_write_sem[streamID])) {
+#else
+    if (down_interruptible(&ar->raw_htc_write_sem[streamID])) {
+#endif
+        AR_DEBUG2_PRINTF("Unable to down the semaphore\n");
+    }
+
+    A_ASSERT(pPacket->pBuffer == (free->data + HTC_HEADER_LEN));
+
+    free->length = 0;
+    ar->write_buffer_available[streamID] = TRUE;
+    up(&ar->raw_htc_write_sem[streamID]);
+
+    /* Signal the waiting process */
+    AR_DEBUG2_PRINTF("Waking up the StreamID(%d) write process\n", streamID);
+    wake_up_interruptible(&ar->raw_htc_write_queue[streamID]);
+}
+
+/* connect to a service */
+static A_STATUS ar6000_connect_raw_service(AR_SOFTC_T        *ar,
+                                           HTC_RAW_STREAM_ID StreamID)
+{
+    A_STATUS                 status;
+    HTC_SERVICE_CONNECT_RESP response;
+    A_UINT8                  streamNo;
+    HTC_SERVICE_CONNECT_REQ  connect;
+
+    do {
+
+        A_MEMZERO(&connect,sizeof(connect));
+            /* pass the stream ID as meta data to the RAW streams service */
+        streamNo = (A_UINT8)StreamID;
+        connect.pMetaData = &streamNo;
+        connect.MetaDataLength = sizeof(A_UINT8);
+            /* these fields are the same for all endpoints */
+        connect.EpCallbacks.pContext = ar;
+        connect.EpCallbacks.EpTxComplete = ar6000_htc_raw_write_cb;
+        connect.EpCallbacks.EpRecv = ar6000_htc_raw_read_cb;
+            /* simple interface, we don't need these optional callbacks */
+        connect.EpCallbacks.EpRecvRefill = NULL;
+        connect.EpCallbacks.EpSendFull = NULL;
+        connect.EpCallbacks.EpSendAvail = NULL;
+        connect.MaxSendQueueDepth = RAW_HTC_WRITE_BUFFERS_NUM;
+
+            /* connect to the raw streams service, we may be able to get 1 or more
+             * connections, depending on WHAT is running on the target */
+        connect.ServiceID = HTC_RAW_STREAMS_SVC;
+
+        A_MEMZERO(&response,sizeof(response));
+
+            /* try to connect to the raw stream, it is okay if this fails with
+             * status HTC_SERVICE_NO_MORE_EP */
+        status = HTCConnectService(ar->arHtcTarget,
+                                   &connect,
+                                   &response);
+
+        if (A_FAILED(status)) {
+            if (response.ConnectRespCode == HTC_SERVICE_NO_MORE_EP) {
+                AR_DEBUG_PRINTF("HTC RAW , No more streams allowed \n");
+                status = A_OK;
+            }
+            break;
+        }
+
+            /* set endpoint mapping for the RAW HTC streams */
+        arSetRawStream2EndpointIDMap(ar,StreamID,response.Endpoint);
+
+        AR_DEBUG_PRINTF("HTC RAW : stream ID: %d, endpoint: %d\n",
+                        StreamID, arRawStream2EndpointID(ar,StreamID));
+
+    } while (FALSE);
+
+    return status;
+}
+
+int ar6000_htc_raw_open(AR_SOFTC_T *ar)
+{
+    A_STATUS status;
+    int streamID, endPt, count2;
+    raw_htc_buffer *buffer;
+    HTC_SERVICE_ID servicepriority;
+
+    A_ASSERT(ar->arHtcTarget != NULL);
+
+        /* wait for target */
+    status = HTCWaitTarget(ar->arHtcTarget);
+
+    if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF("HTCWaitTarget failed (%d)\n", status);
+        return -ENODEV;
+    }
+
+    for (endPt = 0; endPt < ENDPOINT_MAX; endPt++) {
+        ar->arEp2RawMapping[endPt] = HTC_RAW_STREAM_NOT_MAPPED;
+    }
+
+    for (streamID = HTC_RAW_STREAM_0; streamID < HTC_RAW_STREAM_NUM_MAX; streamID++) {
+        /* Initialize the data structures */
+        init_MUTEX(&ar->raw_htc_read_sem[streamID]);
+        init_MUTEX(&ar->raw_htc_write_sem[streamID]);
+        init_waitqueue_head(&ar->raw_htc_read_queue[streamID]);
+        init_waitqueue_head(&ar->raw_htc_write_queue[streamID]);
+
+            /* try to connect to the raw service */
+        status = ar6000_connect_raw_service(ar,streamID);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (arRawStream2EndpointID(ar,streamID) == 0) {
+            break;
+        }
+
+        for (count2 = 0; count2 < RAW_HTC_READ_BUFFERS_NUM; count2 ++) {
+            /* Initialize the receive buffers */
+            buffer = ar->raw_htc_write_buffer[streamID][count2];
+            memset(buffer, 0, sizeof(raw_htc_buffer));
+            buffer = ar->raw_htc_read_buffer[streamID][count2];
+            memset(buffer, 0, sizeof(raw_htc_buffer));
+
+            SET_HTC_PACKET_INFO_RX_REFILL(&buffer->HTCPacket,
+                                          buffer,
+                                          buffer->data,
+                                          AR6000_BUFFER_SIZE,
+                                          arRawStream2EndpointID(ar,streamID));
+
+            /* Queue buffers to HTC for receive */
+            if ((status = HTCAddReceivePkt(ar->arHtcTarget, &buffer->HTCPacket)) != A_OK)
+            {
+                BMIInit();
+                return -EIO;
+            }
+        }
+
+        for (count2 = 0; count2 < RAW_HTC_WRITE_BUFFERS_NUM; count2 ++) {
+            /* Initialize the receive buffers */
+            buffer = ar->raw_htc_write_buffer[streamID][count2];
+            memset(buffer, 0, sizeof(raw_htc_buffer));
+        }
+
+        ar->read_buffer_available[streamID] = FALSE;
+        ar->write_buffer_available[streamID] = TRUE;
+    }
+
+    if (A_FAILED(status)) {
+        return -EIO;
+    }
+
+    AR_DEBUG_PRINTF("HTC RAW, number of streams the target supports: %d \n", streamID);
+
+    servicepriority = HTC_RAW_STREAMS_SVC;  /* only 1 */
+
+        /* set callbacks and priority list */
+    HTCSetCreditDistribution(ar->arHtcTarget,
+                             ar,
+                             NULL,  /* use default */
+                             NULL,  /* use default */
+                             &servicepriority,
+                             1);
+
+    /* Start the HTC component */
+    if ((status = HTCStart(ar->arHtcTarget)) != A_OK) {
+        BMIInit();
+        return -EIO;
+    }
+
+    (ar)->arRawIfInit = TRUE;
+
+    return 0;
+}
+
+int ar6000_htc_raw_close(AR_SOFTC_T *ar)
+{
+    A_PRINTF("ar6000_htc_raw_close called \n");
+    HTCStop(ar->arHtcTarget);
+
+        /* reset the device */
+    ar6000_reset_device(ar->arHifDevice, ar->arTargetType);
+    /* Initialize the BMI component */
+    BMIInit();
+
+    return 0;
+}
+
+raw_htc_buffer *
+get_filled_buffer(AR_SOFTC_T *ar, HTC_RAW_STREAM_ID StreamID)
+{
+    int count;
+    raw_htc_buffer *busy;
+
+    /* Check for data */
+    for (count = 0; count < RAW_HTC_READ_BUFFERS_NUM; count ++) {
+        busy = ar->raw_htc_read_buffer[StreamID][count];
+        if (busy->length) {
+            break;
+        }
+    }
+    if (busy->length) {
+        ar->read_buffer_available[StreamID] = TRUE;
+    } else {
+        ar->read_buffer_available[StreamID] = FALSE;
+    }
+
+    return busy;
+}
+
+ssize_t ar6000_htc_raw_read(AR_SOFTC_T *ar, HTC_RAW_STREAM_ID StreamID,
+                            char __user *buffer, size_t length)
+{
+    int readPtr;
+    raw_htc_buffer *busy;
+
+    if (arRawStream2EndpointID(ar,StreamID) == 0) {
+        AR_DEBUG_PRINTF("StreamID(%d) not connected! \n", StreamID);
+        return -EFAULT;
+    }
+
+    if (down_interruptible(&ar->raw_htc_read_sem[StreamID])) {
+        return -ERESTARTSYS;
+    }
+
+    busy = get_filled_buffer(ar,StreamID);
+    while (!ar->read_buffer_available[StreamID]) {
+        up(&ar->raw_htc_read_sem[StreamID]);
+
+        /* Wait for the data */
+        AR_DEBUG2_PRINTF("Sleeping StreamID(%d) read process\n", StreamID);
+        if (wait_event_interruptible(ar->raw_htc_read_queue[StreamID],
+                                     ar->read_buffer_available[StreamID]))
+        {
+            return -EINTR;
+        }
+        if (down_interruptible(&ar->raw_htc_read_sem[StreamID])) {
+            return -ERESTARTSYS;
+        }
+        busy = get_filled_buffer(ar,StreamID);
+    }
+
+    /* Read the data */
+    readPtr = busy->currPtr;
+    if (length > busy->length - HTC_HEADER_LEN) {
+        length = busy->length - HTC_HEADER_LEN;
+    }
+    if (copy_to_user(buffer, &busy->data[readPtr], length)) {
+        up(&ar->raw_htc_read_sem[StreamID]);
+        return -EFAULT;
+    }
+
+    busy->currPtr += length;
+
+    //AR_DEBUG_PRINTF("raw read ioctl:  currPTR : 0x%X 0x%X \n", busy->currPtr,busy->length);
+
+    if (busy->currPtr == busy->length)
+    {
+        busy->currPtr = 0;
+        busy->length = 0;
+        HTC_PACKET_RESET_RX(&busy->HTCPacket);
+        //AR_DEBUG_PRINTF("raw read ioctl:  ep for packet:%d \n", busy->HTCPacket.Endpoint);
+        HTCAddReceivePkt(ar->arHtcTarget, &busy->HTCPacket);
+    }
+    ar->read_buffer_available[StreamID] = FALSE;
+    up(&ar->raw_htc_read_sem[StreamID]);
+
+    return length;
+}
+
+static raw_htc_buffer *
+get_free_buffer(AR_SOFTC_T *ar, HTC_ENDPOINT_ID StreamID)
+{
+    int count;
+    raw_htc_buffer *free;
+
+    free = NULL;
+    for (count = 0; count < RAW_HTC_WRITE_BUFFERS_NUM; count ++) {
+        free = ar->raw_htc_write_buffer[StreamID][count];
+        if (free->length == 0) {
+            break;
+        }
+    }
+    if (!free->length) {
+        ar->write_buffer_available[StreamID] = TRUE;
+    } else {
+        ar->write_buffer_available[StreamID] = FALSE;
+    }
+
+    return free;
+}
+
+ssize_t ar6000_htc_raw_write(AR_SOFTC_T *ar, HTC_RAW_STREAM_ID StreamID,
+                     char __user *buffer, size_t length)
+{
+    int writePtr;
+    raw_htc_buffer *free;
+
+    if (arRawStream2EndpointID(ar,StreamID) == 0) {
+        AR_DEBUG_PRINTF("StreamID(%d) not connected! \n", StreamID);
+        return -EFAULT;
+    }
+
+    if (down_interruptible(&ar->raw_htc_write_sem[StreamID])) {
+        return -ERESTARTSYS;
+    }
+
+    /* Search for a free buffer */
+    free = get_free_buffer(ar,StreamID);
+
+    /* Check if there is space to write else wait */
+    while (!ar->write_buffer_available[StreamID]) {
+        up(&ar->raw_htc_write_sem[StreamID]);
+
+        /* Wait for buffer to become free */
+        AR_DEBUG2_PRINTF("Sleeping StreamID(%d) write process\n", StreamID);
+        if (wait_event_interruptible(ar->raw_htc_write_queue[StreamID],
+                                     ar->write_buffer_available[StreamID]))
+        {
+            return -EINTR;
+        }
+        if (down_interruptible(&ar->raw_htc_write_sem[StreamID])) {
+            return -ERESTARTSYS;
+        }
+        free = get_free_buffer(ar,StreamID);
+    }
+
+    /* Send the data */
+    writePtr = HTC_HEADER_LEN;
+    if (length > (AR6000_BUFFER_SIZE - HTC_HEADER_LEN)) {
+        length = AR6000_BUFFER_SIZE - HTC_HEADER_LEN;
+    }
+
+    if (copy_from_user(&free->data[writePtr], buffer, length)) {
+        up(&ar->raw_htc_read_sem[StreamID]);
+        return -EFAULT;
+    }
+
+    free->length = length;
+
+    SET_HTC_PACKET_INFO_TX(&free->HTCPacket,
+                           free,
+                           &free->data[writePtr],
+                           length,
+                           arRawStream2EndpointID(ar,StreamID),
+                           AR6K_DATA_PKT_TAG);
+
+    HTCSendPkt(ar->arHtcTarget,&free->HTCPacket);
+
+    ar->write_buffer_available[StreamID] = FALSE;
+    up(&ar->raw_htc_write_sem[StreamID]);
+
+    return length;
+}
+#endif /* HTC_RAW_INTERFACE */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6xapi_linux.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6xapi_linux.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ar6xapi_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ar6xapi_linux.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,128 @@
+#ifndef _AR6XAPI_LINUX_H
+#define _AR6XAPI_LINUX_H
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ar6_softc;
+
+void ar6000_ready_event(void *devt, A_UINT8 *datap, A_UINT8 phyCap);
+A_UINT8 ar6000_iptos_to_userPriority(A_UINT8 *pkt);
+A_STATUS ar6000_control_tx(void *devt, void *osbuf, WMI_PRI_STREAM_ID streamID);
+void ar6000_connect_event(struct ar6_softc *ar, A_UINT16 channel,
+                          A_UINT8 *bssid, A_UINT16 listenInterval,
+                          A_UINT16 beaconInterval, NETWORK_TYPE networkType,
+                          A_UINT8 beaconIeLen, A_UINT8 assocReqLen,
+                          A_UINT8 assocRespLen,A_UINT8 *assocInfo);
+void ar6000_disconnect_event(struct ar6_softc *ar, A_UINT8 reason,
+                             A_UINT8 *bssid, A_UINT8 assocRespLen,
+                             A_UINT8 *assocInfo, A_UINT16 protocolReasonStatus);
+void ar6000_tkip_micerr_event(struct ar6_softc *ar, A_UINT8 keyid,
+                              A_BOOL ismcast);
+void ar6000_bitrate_rx(void *devt, A_INT32 rateKbps);
+void ar6000_channelList_rx(void *devt, A_INT8 numChan, A_UINT16 *chanList);
+void ar6000_regDomain_event(struct ar6_softc *ar, A_UINT32 regCode);
+void ar6000_txPwr_rx(void *devt, A_UINT8 txPwr);
+void ar6000_keepalive_rx(void *devt, A_UINT8 configured);
+void ar6000_neighborReport_event(struct ar6_softc *ar, int numAps,
+                                 WMI_NEIGHBOR_INFO *info);
+void ar6000_set_numdataendpts(struct ar6_softc *ar, A_UINT32 num);
+void ar6000_scanComplete_event(struct ar6_softc *ar, A_STATUS status);
+void ar6000_targetStats_event(struct ar6_softc *ar,  WMI_TARGET_STATS *pStats);
+void ar6000_rssiThreshold_event(struct ar6_softc *ar,
+                                WMI_RSSI_THRESHOLD_VAL newThreshold,
+                                A_INT16 rssi);
+void ar6000_reportError_event(struct ar6_softc *, WMI_TARGET_ERROR_VAL errorVal);
+void ar6000_cac_event(struct ar6_softc *ar, A_UINT8 ac, A_UINT8 cac_indication,
+                                A_UINT8 statusCode, A_UINT8 *tspecSuggestion);
+void ar6000_hbChallengeResp_event(struct ar6_softc *, A_UINT32 cookie, A_UINT32 source);
+void
+ar6000_roam_tbl_event(struct ar6_softc *ar, WMI_TARGET_ROAM_TBL *pTbl);
+
+void
+ar6000_roam_data_event(struct ar6_softc *ar, WMI_TARGET_ROAM_DATA *p);
+
+void
+ar6000_wow_list_event(struct ar6_softc *ar, A_UINT8 num_filters,
+                      WMI_GET_WOW_LIST_REPLY *wow_reply);
+
+void ar6000_pmkid_list_event(void *devt, A_UINT8 numPMKID,
+                             WMI_PMKID *pmkidList);
+
+void ar6000_gpio_intr_rx(A_UINT32 intr_mask, A_UINT32 input_values);
+void ar6000_gpio_data_rx(A_UINT32 reg_id, A_UINT32 value);
+void ar6000_gpio_ack_rx(void);
+
+void ar6000_dbglog_init_done(struct ar6_softc *ar);
+
+#ifdef SEND_EVENT_TO_APP
+void ar6000_send_event_to_app(struct ar6_softc *ar, A_UINT16 eventId, A_UINT8 *datap, int len);
+#endif
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+void ar6000_tcmd_rx_report_event(void *devt, A_UINT8 * results, int len);
+#endif
+
+void ar6000_tx_retry_err_event(void *devt);
+
+void ar6000_snrThresholdEvent_rx(void *devt,
+                                 WMI_SNR_THRESHOLD_VAL newThreshold,
+                                 A_UINT8 snr);
+
+void ar6000_lqThresholdEvent_rx(void *devt, WMI_LQ_THRESHOLD_VAL range, A_UINT8 lqVal);
+
+
+void ar6000_ratemask_rx(void *devt, A_UINT16 ratemask);
+
+A_STATUS ar6000_get_driver_cfg(struct net_device *dev,
+                                A_UINT16 cfgParam,
+                                void *result);
+void ar6000_bssInfo_event_rx(struct ar6_softc *ar, A_UINT8 *data, int len);
+
+void ar6000_dbglog_event(struct ar6_softc *ar, A_UINT32 dropped,
+                         A_INT8 *buffer, A_UINT32 length);
+
+int ar6000_dbglog_get_debug_logs(struct ar6_softc *ar);
+
+void ar6000_indicate_tx_activity(void *devt, A_UINT8 trafficClass, A_BOOL Active);
+
+void ar6000_dset_open_req(void *devt,
+                          A_UINT32 id,
+                          A_UINT32 targ_handle,
+                          A_UINT32 targ_reply_fn,
+                          A_UINT32 targ_reply_arg);
+void ar6000_dset_close(void *devt, A_UINT32 access_cookie);
+void ar6000_dset_data_req(void *devt,
+                          A_UINT32 access_cookie,
+                          A_UINT32 offset,
+                          A_UINT32 length,
+                          A_UINT32 targ_buf,
+                          A_UINT32 targ_reply_fn,
+                          A_UINT32 targ_reply_arg);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/athdrv_linux.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/athdrv_linux.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/athdrv_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/athdrv_linux.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,993 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _ATHDRV_LINUX_H
+#define _ATHDRV_LINUX_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * There are two types of ioctl's here: Standard ioctls and
+ * eXtended ioctls.  All extended ioctls (XIOCTL) are multiplexed
+ * off of the single ioctl command, AR6000_IOCTL_EXTENDED.  The
+ * arguments for every XIOCTL starts with a 32-bit command word
+ * that is used to select which extended ioctl is in use.  After
+ * the command word are command-specific arguments.
+ */
+
+/* Linux standard Wireless Extensions, private ioctl interfaces */
+#define IEEE80211_IOCTL_SETPARAM             (SIOCIWFIRSTPRIV+0)
+#define IEEE80211_IOCTL_GETPARAM             (SIOCIWFIRSTPRIV+1)
+#define IEEE80211_IOCTL_SETKEY               (SIOCIWFIRSTPRIV+2)
+#define IEEE80211_IOCTL_SETWMMPARAMS         (SIOCIWFIRSTPRIV+3)
+#define IEEE80211_IOCTL_DELKEY               (SIOCIWFIRSTPRIV+4)
+#define IEEE80211_IOCTL_GETWMMPARAMS         (SIOCIWFIRSTPRIV+5)
+#define IEEE80211_IOCTL_SETOPTIE             (SIOCIWFIRSTPRIV+6)
+#define IEEE80211_IOCTL_SETMLME              (SIOCIWFIRSTPRIV+7)
+//#define IEEE80211_IOCTL_GETOPTIE             (SIOCIWFIRSTPRIV+7)
+#define IEEE80211_IOCTL_ADDPMKID             (SIOCIWFIRSTPRIV+8)
+//#define IEEE80211_IOCTL_SETAUTHALG           (SIOCIWFIRSTPRIV+10)
+#define IEEE80211_IOCTL_LASTONE              (SIOCIWFIRSTPRIV+9)
+
+
+
+/*                      ====WMI Ioctls====                                    */
+/*
+ *
+ * Many ioctls simply provide WMI services to application code:
+ * an application makes such an ioctl call with a set of arguments
+ * that are packaged into the corresponding WMI message, and sent
+ * to the Target.
+ */
+
+#define AR6000_IOCTL_WMI_GETREV              (SIOCIWFIRSTPRIV+10)
+/*
+ * arguments:
+ *   ar6000_version *revision
+ */
+
+#define AR6000_IOCTL_WMI_SETPWR              (SIOCIWFIRSTPRIV+11)
+/*
+ * arguments:
+ *   WMI_POWER_MODE_CMD pwrModeCmd (see include/wmi.h)
+ * uses: WMI_SET_POWER_MODE_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SETSCAN             (SIOCIWFIRSTPRIV+12)
+/*
+ * arguments:
+ *   WMI_SCAN_PARAMS_CMD scanParams (see include/wmi.h)
+ * uses: WMI_SET_SCAN_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SETLISTENINT        (SIOCIWFIRSTPRIV+13)
+/*
+ * arguments:
+ *   UINT32 listenInterval
+ * uses: WMI_SET_LISTEN_INT_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SETBSSFILTER        (SIOCIWFIRSTPRIV+14)
+/*
+ * arguments:
+ *   WMI_BSS_FILTER filter (see include/wmi.h)
+ * uses: WMI_SET_BSS_FILTER_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_CHANNELPARAMS   (SIOCIWFIRSTPRIV+16)
+/*
+ * arguments:
+ *   WMI_CHANNEL_PARAMS_CMD chParams
+ * uses: WMI_SET_CHANNEL_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_PROBEDSSID      (SIOCIWFIRSTPRIV+17)
+/*
+ * arguments:
+ *   WMI_PROBED_SSID_CMD probedSsids (see include/wmi.h)
+ * uses: WMI_SETPROBED_SSID_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_PMPARAMS        (SIOCIWFIRSTPRIV+18)
+/*
+ * arguments:
+ *   WMI_POWER_PARAMS_CMD powerParams (see include/wmi.h)
+ * uses: WMI_SET_POWER_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_BADAP           (SIOCIWFIRSTPRIV+19)
+/*
+ * arguments:
+ *   WMI_ADD_BAD_AP_CMD badAPs (see include/wmi.h)
+ * uses: WMI_ADD_BAD_AP_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_GET_QOS_QUEUE       (SIOCIWFIRSTPRIV+20)
+/*
+ * arguments:
+ *   ar6000_queuereq queueRequest (see below)
+ */
+
+#define AR6000_IOCTL_WMI_CREATE_QOS          (SIOCIWFIRSTPRIV+21)
+/*
+ * arguments:
+ *   WMI_CREATE_PSTREAM createPstreamCmd (see include/wmi.h)
+ * uses: WMI_CREATE_PSTREAM_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_DELETE_QOS          (SIOCIWFIRSTPRIV+22)
+/*
+ * arguments:
+ *   WMI_DELETE_PSTREAM_CMD deletePstreamCmd (see include/wmi.h)
+ * uses: WMI_DELETE_PSTREAM_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_SNRTHRESHOLD   (SIOCIWFIRSTPRIV+23)
+/*
+ * arguments:
+ *   WMI_SNR_THRESHOLD_PARAMS_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_SNR_THRESHOLD_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_ERROR_REPORT_BITMASK (SIOCIWFIRSTPRIV+24)
+/*
+ * arguments:
+ *   WMI_TARGET_ERROR_REPORT_BITMASK errorReportBitMask (see include/wmi.h)
+ * uses: WMI_TARGET_ERROR_REPORT_BITMASK_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_GET_TARGET_STATS    (SIOCIWFIRSTPRIV+25)
+/*
+ * arguments:
+ *   TARGET_STATS *targetStats (see below)
+ * uses: WMI_GET_STATISTICS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_ASSOC_INFO      (SIOCIWFIRSTPRIV+26)
+/*
+ * arguments:
+ *   WMI_SET_ASSOC_INFO_CMD setAssocInfoCmd
+ * uses: WMI_SET_ASSOC_INFO_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_ACCESS_PARAMS   (SIOCIWFIRSTPRIV+27)
+/*
+ * arguments:
+ *   WMI_SET_ACCESS_PARAMS_CMD setAccessParams (see include/wmi.h)
+ * uses: WMI_SET_ACCESS_PARAMS_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_BMISS_TIME      (SIOCIWFIRSTPRIV+28)
+/*
+ * arguments:
+ *   UINT32 beaconMissTime
+ * uses: WMI_SET_BMISS_TIME_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_DISC_TIMEOUT    (SIOCIWFIRSTPRIV+29)
+/*
+ * arguments:
+ *   WMI_DISC_TIMEOUT_CMD disconnectTimeoutCmd (see include/wmi.h)
+ * uses: WMI_SET_DISC_TIMEOUT_CMDID
+ */
+
+#define AR6000_IOCTL_WMI_SET_IBSS_PM_CAPS    (SIOCIWFIRSTPRIV+30)
+/*
+ * arguments:
+ *   WMI_IBSS_PM_CAPS_CMD ibssPowerMgmtCapsCmd
+ * uses: WMI_SET_IBSS_PM_CAPS_CMDID
+ */
+
+/*
+ * There is a very small space available for driver-private
+ * wireless ioctls.  In order to circumvent this limitation,
+ * we multiplex a bunch of ioctls (XIOCTLs) on top of a
+ * single AR6000_IOCTL_EXTENDED ioctl.
+ */
+#define AR6000_IOCTL_EXTENDED                (SIOCIWFIRSTPRIV+31)
+
+
+/*                         ====BMI Extended Ioctls====                        */
+
+#define AR6000_XIOCTL_BMI_DONE                                  1
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_DONE)
+ * uses: BMI_DONE
+ */
+
+#define AR6000_XIOCTL_BMI_READ_MEMORY                           2
+/*
+ * arguments:
+ *   union {
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_READ_MEMORY)
+ *       UINT32 address
+ *       UINT32 length
+ *     }
+ *     char results[length]
+ *   }
+ * uses: BMI_READ_MEMORY
+ */
+
+#define AR6000_XIOCTL_BMI_WRITE_MEMORY                          3
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_WRITE_MEMORY)
+ *   UINT32 address
+ *   UINT32 length
+ *   char data[length]
+ * uses: BMI_WRITE_MEMORY
+ */
+
+#define AR6000_XIOCTL_BMI_EXECUTE                               4
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_EXECUTE)
+ *   UINT32 TargetAddress
+ *   UINT32 parameter
+ * uses: BMI_EXECUTE
+ */
+
+#define AR6000_XIOCTL_BMI_SET_APP_START                         5
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_SET_APP_START)
+ *   UINT32 TargetAddress
+ * uses: BMI_SET_APP_START
+ */
+
+#define AR6000_XIOCTL_BMI_READ_SOC_REGISTER                     6
+/*
+ * arguments:
+ *   union {
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_READ_SOC_REGISTER)
+ *       UINT32 TargetAddress, 32-bit aligned
+ *     }
+ *     UINT32 result
+ *   }
+ * uses: BMI_READ_SOC_REGISTER
+ */
+
+#define AR6000_XIOCTL_BMI_WRITE_SOC_REGISTER                    7
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_WRITE_SOC_REGISTER)
+ *       UINT32 TargetAddress, 32-bit aligned
+ *       UINT32 newValue
+ *     }
+ * uses: BMI_WRITE_SOC_REGISTER
+ */
+
+#define AR6000_XIOCTL_BMI_TEST                                  8
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_BMI_TEST)
+ *   UINT32 address
+ *   UINT32 length
+ *   UINT32 count
+ */
+
+
+
+/* Historical Host-side DataSet support */
+#define AR6000_XIOCTL_UNUSED9                                   9
+#define AR6000_XIOCTL_UNUSED10                                  10
+#define AR6000_XIOCTL_UNUSED11                                  11
+
+/*                      ====Misc Extended Ioctls====                          */
+
+#define AR6000_XIOCTL_FORCE_TARGET_RESET                        12
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_FORCE_TARGET_RESET)
+ */
+
+
+#ifdef HTC_RAW_INTERFACE
+/* HTC Raw Interface Ioctls */
+#define AR6000_XIOCTL_HTC_RAW_OPEN                              13
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_HTC_RAW_OPEN)
+ */
+
+#define AR6000_XIOCTL_HTC_RAW_CLOSE                             14
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_HTC_RAW_CLOSE)
+ */
+
+#define AR6000_XIOCTL_HTC_RAW_READ                              15
+/*
+ * arguments:
+ *   union {
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_HTC_RAW_READ)
+ *       UINT32 mailboxID
+ *       UINT32 length
+ *     }
+ *     results[length]
+ *   }
+ */
+
+#define AR6000_XIOCTL_HTC_RAW_WRITE                             16
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_HTC_RAW_WRITE)
+ *   UINT32 mailboxID
+ *   UINT32 length
+ *   char buffer[length]
+ */
+#endif /* HTC_RAW_INTERFACE */
+
+#define AR6000_XIOCTL_CHECK_TARGET_READY                        17
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_CHECK_TARGET_READY)
+ */
+
+
+
+/*                ====GPIO (General Purpose I/O) Extended Ioctls====          */
+
+#define AR6000_XIOCTL_GPIO_OUTPUT_SET                           18
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_OUTPUT_SET)
+ *   ar6000_gpio_output_set_cmd_s (see below)
+ * uses: WMIX_GPIO_OUTPUT_SET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_INPUT_GET                            19
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_INPUT_GET)
+ * uses: WMIX_GPIO_INPUT_GET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_REGISTER_SET                         20
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_REGISTER_SET)
+ *   ar6000_gpio_register_cmd_s (see below)
+ * uses: WMIX_GPIO_REGISTER_SET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_REGISTER_GET                         21
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_REGISTER_GET)
+ *   ar6000_gpio_register_cmd_s (see below)
+ * uses: WMIX_GPIO_REGISTER_GET_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_INTR_ACK                             22
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_INTR_ACK)
+ *   ar6000_cpio_intr_ack_cmd_s (see below)
+ * uses: WMIX_GPIO_INTR_ACK_CMDID
+ */
+
+#define AR6000_XIOCTL_GPIO_INTR_WAIT                            23
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_GPIO_INTR_WAIT)
+ */
+
+
+
+/*                    ====more wireless commands====                          */
+
+#define AR6000_XIOCTL_SET_ADHOC_BSSID                           24
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_ADHOC_BSSID)
+ *   WMI_SET_ADHOC_BSSID_CMD setAdHocBssidCmd (see include/wmi.h)
+ */
+
+#define AR6000_XIOCTL_SET_OPT_MODE                              25
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_OPT_MODE)
+ *   WMI_SET_OPT_MODE_CMD setOptModeCmd (see include/wmi.h)
+ * uses: WMI_SET_OPT_MODE_CMDID
+ */
+
+#define AR6000_XIOCTL_OPT_SEND_FRAME                            26
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_OPT_SEND_FRAME)
+ *   WMI_OPT_TX_FRAME_CMD optTxFrameCmd (see include/wmi.h)
+ * uses: WMI_OPT_TX_FRAME_CMDID
+ */
+
+#define AR6000_XIOCTL_SET_ADHOC_BEACON_INTVAL                   27
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_ADHOC_BEACON_INTVAL)
+ *   WMI_BEACON_INT_CMD beaconIntCmd (see include/wmi.h)
+ * uses: WMI_SET_BEACON_INT_CMDID
+ */
+
+
+#define IEEE80211_IOCTL_SETAUTHALG                              28
+
+
+#define AR6000_XIOCTL_SET_VOICE_PKT_SIZE                        29
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_VOICE_PKT_SIZE)
+ *   WMI_SET_VOICE_PKT_SIZE_CMD setVoicePktSizeCmd (see include/wmi.h)
+ * uses: WMI_SET_VOICE_PKT_SIZE_CMDID
+ */
+
+
+#define AR6000_XIOCTL_SET_MAX_SP                                30
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_SET_MAX_SP)
+ *   WMI_SET_MAX_SP_LEN_CMD maxSPLen(see include/wmi.h)
+ * uses: WMI_SET_MAX_SP_LEN_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_GET_ROAM_TBL                          31
+
+#define AR6000_XIOCTL_WMI_SET_ROAM_CTRL                         32
+
+#define AR6000_XIOCTRL_WMI_SET_POWERSAVE_TIMERS                 33
+
+
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTRL_WMI_SET_POWERSAVE_TIMERS)
+ *   WMI_SET_POWERSAVE_TIMERS_CMD powerSaveTimers(see include/wmi.h)
+ *   WMI_SET_POWERSAVE_TIMERS_CMDID
+ */
+
+#define AR6000_XIOCTRL_WMI_GET_POWER_MODE                        34
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTRL_WMI_GET_POWER_MODE)
+ */
+
+#define AR6000_XIOCTRL_WMI_SET_WLAN_STATE                       35
+typedef enum {
+    WLAN_DISABLED,
+    WLAN_ENABLED
+} AR6000_WLAN_STATE;
+/*
+ * arguments:
+ * enable/disable
+ */
+
+#define AR6000_XIOCTL_WMI_GET_ROAM_DATA                         36
+
+#define AR6000_XIOCTL_WMI_SETRETRYLIMITS                37
+/*
+ * arguments:
+ *   WMI_SET_RETRY_LIMITS_CMD ibssSetRetryLimitsCmd
+ * uses: WMI_SET_RETRY_LIMITS_CMDID
+ */
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+/*       ====extended commands for radio test ====                          */
+
+#define AR6000_XIOCTL_TCMD_CONT_TX                      38
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TCMD_CONT_TX)
+ *   WMI_TCMD_CONT_TX_CMD contTxCmd (see include/wmi.h)
+ * uses: WMI_TCMD_CONT_TX_CMDID
+ */
+
+#define AR6000_XIOCTL_TCMD_CONT_RX                      39
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TCMD_CONT_RX)
+ *   WMI_TCMD_CONT_RX_CMD rxCmd (see include/wmi.h)
+ * uses: WMI_TCMD_CONT_RX_CMDID
+ */
+
+#define AR6000_XIOCTL_TCMD_PM                           40
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TCMD_PM)
+ *   WMI_TCMD_PM_CMD pmCmd (see include/wmi.h)
+ * uses: WMI_TCMD_PM_CMDID
+ */
+
+#endif /* CONFIG_HOST_TCMD_SUPPORT */
+
+#define AR6000_XIOCTL_WMI_STARTSCAN                     41
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_STARTSCAN)
+ *   UINT8  scanType
+ *   UINT8  scanConnected
+ *   A_BOOL forceFgScan
+ * uses: WMI_START_SCAN_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SETFIXRATES                   42
+
+#define AR6000_XIOCTL_WMI_GETFIXRATES                   43
+
+
+#define AR6000_XIOCTL_WMI_SET_RSSITHRESHOLD             44
+/*
+ * arguments:
+ *   WMI_RSSI_THRESHOLD_PARAMS_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_RSSI_THRESHOLD_PARAMS_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_CLR_RSSISNR                   45
+/*
+ * arguments:
+ *   WMI_CLR_RSSISNR_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_CLR_RSSISNR_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_LQTHRESHOLD               46
+/*
+ * arguments:
+ *   WMI_LQ_THRESHOLD_PARAMS_CMD thresholdParams (see include/wmi.h)
+ * uses: WMI_LQ_THRESHOLD_PARAMS_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_RTS                        47
+/*
+ * arguments:
+ *   WMI_SET_RTS_MODE_CMD (see include/wmi.h)
+ * uses: WMI_SET_RTS_MODE_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_LPREAMBLE                 48
+
+#define AR6000_XIOCTL_WMI_SET_AUTHMODE                  49
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_SET_AUTHMODE)
+ *   UINT8  mode
+ * uses: WMI_SET_RECONNECT_AUTH_MODE_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_SET_REASSOCMODE               50
+
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_SET_WMM)
+ *   UINT8  mode
+ * uses: WMI_SET_WMM_CMDID
+ */
+#define AR6000_XIOCTL_WMI_SET_WMM                       51
+
+/*
+ * arguments:
+ * UINT32 cmd (AR6000_XIOCTL_WMI_SET_HB_CHALLENGE_RESP_PARAMS)
+ * UINT32 frequency
+ * UINT8  threshold
+ */
+#define AR6000_XIOCTL_WMI_SET_HB_CHALLENGE_RESP_PARAMS  52
+
+/*
+ * arguments:
+ * UINT32 cmd (AR6000_XIOCTL_WMI_GET_HB_CHALLENGE_RESP)
+ * UINT32 cookie
+ */
+#define AR6000_XIOCTL_WMI_GET_HB_CHALLENGE_RESP         53
+
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_WMI_GET_RD)
+ *   UINT32 regDomain
+ */
+#define AR6000_XIOCTL_WMI_GET_RD                        54
+
+#define AR6000_XIOCTL_DIAG_READ                         55
+
+#define AR6000_XIOCTL_DIAG_WRITE                        56
+
+/*
+ * arguments cmd (AR6000_XIOCTL_SET_TXOP)
+ * WMI_TXOP_CFG  txopEnable
+ */
+#define AR6000_XIOCTL_WMI_SET_TXOP                      57
+
+#ifdef USER_KEYS
+/*
+ * arguments:
+ * UINT32 cmd (AR6000_XIOCTL_USER_SETKEYS)
+ * UINT32 keyOpCtrl
+ * uses AR6000_USER_SETKEYS_INFO
+ */
+#define AR6000_XIOCTL_USER_SETKEYS                      58
+#endif /* USER_KEYS */
+
+#define AR6000_XIOCTL_WMI_SET_KEEPALIVE                 59
+/*
+ * arguments:
+ *   UINT8 cmd (AR6000_XIOCTL_WMI_SET_KEEPALIVE)
+ *   UINT8 keepaliveInterval
+ * uses: WMI_SET_KEEPALIVE_CMDID
+ */
+
+#define AR6000_XIOCTL_WMI_GET_KEEPALIVE                 60
+/*
+ * arguments:
+ *   UINT8 cmd (AR6000_XIOCTL_WMI_GET_KEEPALIVE)
+ *   UINT8 keepaliveInterval
+ *   A_BOOL configured
+ * uses: WMI_GET_KEEPALIVE_CMDID
+ */
+
+/*               ====ROM Patching Extended Ioctls====                       */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_INSTALL              61
+/*
+ * arguments:
+ *     union {
+ *       struct {
+ *         UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_INSTALL)
+ *         UINT32 ROM Address
+ *         UINT32 RAM Address
+ *         UINT32 number of bytes
+ *         UINT32 activate? (0 or 1)
+ *       }
+ *       A_UINT32 resulting rompatch ID
+ *     }
+ * uses: BMI_ROMPATCH_INSTALL
+ */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_UNINSTALL            62
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_UNINSTALL)
+ *       UINT32 rompatch ID
+ *     }
+ * uses: BMI_ROMPATCH_UNINSTALL
+ */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE             63
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE)
+ *       UINT32 rompatch count
+ *       UINT32 rompatch IDs[rompatch count]
+ *     }
+ * uses: BMI_ROMPATCH_ACTIVATE
+ */
+
+#define AR6000_XIOCTL_BMI_ROMPATCH_DEACTIVATE           64
+/*
+ * arguments:
+ *     struct {
+ *       UINT32 cmd (AR6000_XIOCTL_BMI_ROMPATCH_DEACTIVATE)
+ *       UINT32 rompatch count
+ *       UINT32 rompatch IDs[rompatch count]
+ *     }
+ * uses: BMI_ROMPATCH_DEACTIVATE
+ */
+
+#define AR6000_XIOCTL_WMI_SET_APPIE             65
+/*
+ * arguments:
+ *      struct {
+ *          UINT32 cmd (AR6000_XIOCTL_WMI_SET_APPIE)
+ *          UINT32  app_frmtype;
+ *          UINT32  app_buflen;
+ *          UINT8   app_buf[];
+ *      }
+ */
+#define AR6000_XIOCTL_WMI_SET_MGMT_FRM_RX_FILTER    66
+/*
+ * arguments:
+ *      A_UINT32 filter_type;
+ */
+
+#define AR6000_XIOCTL_DBGLOG_CFG_MODULE             67
+
+#define AR6000_XIOCTL_DBGLOG_GET_DEBUG_LOGS         68
+
+#define AR6000_XIOCTL_WMI_SET_WSC_STATUS    		70
+/*
+ * arguments:
+ *      A_UINT32 wsc_status;
+ *            (WSC_REG_INACTIVE or WSC_REG_ACTIVE)
+ */
+
+/*
+ * arguments:
+ *      struct {
+ *          A_UINT8 streamType;
+ *          A_UINT8 status;
+ *      }
+ * uses: WMI_SET_BT_STATUS_CMDID
+ */
+#define AR6000_XIOCTL_WMI_SET_BT_STATUS             71
+
+/*
+ * arguments:
+ *      struct {
+ *           A_UINT8 paramType;
+ *           union {
+ *               A_UINT8 noSCOPkts;
+ *               BT_PARAMS_A2DP a2dpParams;
+ *               BT_COEX_REGS regs;
+ *           };
+ *      }
+ * uses: WMI_SET_BT_PARAM_CMDID
+ */
+#define AR6000_XIOCTL_WMI_SET_BT_PARAMS             72
+
+#define AR6000_XIOCTL_WMI_SET_HOST_SLEEP_MODE       73
+#define AR6000_XIOCTL_WMI_SET_WOW_MODE              74
+#define AR6000_XIOCTL_WMI_GET_WOW_LIST              75
+#define AR6000_XIOCTL_WMI_ADD_WOW_PATTERN           76
+#define AR6000_XIOCTL_WMI_DEL_WOW_PATTERN           77
+
+
+
+#define AR6000_XIOCTL_TARGET_INFO                   78
+/*
+ * arguments:
+ *   UINT32 cmd (AR6000_XIOCTL_TARGET_INFO)
+ *   A_UINT32 TargetVersion (returned)
+ *   A_UINT32 TargetType    (returned)
+ * (See also bmi_msg.h target_ver and target_type)
+ */
+
+#define AR6000_XIOCTL_DUMP_HTC_CREDIT_STATE         79
+/*
+ * arguments:
+ *      none
+ */
+
+#define AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE       80
+/*
+ * This ioctl is used to emulate traffic activity
+ * timeouts.  Activity/inactivity will trigger the driver
+ * to re-balance credits.
+ *
+ * arguments:
+ *      ar6000_traffic_activity_change
+ */
+
+#define AR6000_XIOCTL_WMI_SET_CONNECT_CTRL_FLAGS    81
+/*
+ * This ioctl is used to set the connect control flags
+ *
+ * arguments:
+ *      A_UINT32 connectCtrlFlags
+ */
+
+#define AR6000_XIOCTL_WMI_SET_AKMP_PARAMS              82
+/*
+ * This IOCTL sets any Authentication,Key Management and Protection
+ * related parameters. This is used along with the information set in
+ * Connect Command.
+ * Currently this enables Multiple PMKIDs to an AP.
+ *
+ * arguments:
+ *      struct {
+ *          A_UINT32    akmpInfo;
+ *      }
+ * uses: WMI_SET_AKMP_PARAMS_CMD
+ */
+
+#define AR6000_XIOCTL_WMI_GET_PMKID_LIST            83
+
+#define AR6000_XIOCTL_WMI_SET_PMKID_LIST            84
+/*
+ * This IOCTL is used to set a list of PMKIDs. This list of
+ * PMKIDs is used in the [Re]AssocReq Frame. This list is used
+ * only if the MultiPMKID option is enabled via the
+ * AR6000_XIOCTL_WMI_SET_AKMP_PARAMS  IOCTL.
+ *
+ * arguments:
+ *      struct {
+ *          A_UINT32    numPMKID;
+ *          WMI_PMKID   pmkidList[WMI_MAX_PMKID_CACHE];
+ *      }
+ * uses: WMI_SET_PMKIDLIST_CMD
+ */
+
+/* Historical DSETPATCH support for INI patches */
+#define AR6000_XIOCTL_UNUSED90                      90
+
+
+
+/* used by AR6000_IOCTL_WMI_GETREV */
+struct ar6000_version {
+    A_UINT32        host_ver;
+    A_UINT32        target_ver;
+};
+
+/* used by AR6000_IOCTL_WMI_GET_QOS_QUEUE */
+struct ar6000_queuereq {
+    A_UINT8         trafficClass;
+    A_UINT16        activeTsids;
+};
+
+/* used by AR6000_IOCTL_WMI_GET_TARGET_STATS */
+typedef struct targetStats_t {
+    A_UINT64    tx_packets;
+    A_UINT64    tx_bytes;
+    A_UINT64    tx_unicast_pkts;
+    A_UINT64    tx_unicast_bytes;
+    A_UINT64    tx_multicast_pkts;
+    A_UINT64    tx_multicast_bytes;
+    A_UINT64    tx_broadcast_pkts;
+    A_UINT64    tx_broadcast_bytes;
+    A_UINT64    tx_rts_success_cnt;
+    A_UINT64    tx_packet_per_ac[4];
+
+    A_UINT64    tx_errors;
+    A_UINT64    tx_failed_cnt;
+    A_UINT64    tx_retry_cnt;
+    A_UINT64    tx_rts_fail_cnt;
+    A_INT32     tx_unicast_rate;
+    A_UINT64    rx_packets;
+    A_UINT64    rx_bytes;
+    A_UINT64    rx_unicast_pkts;
+    A_UINT64    rx_unicast_bytes;
+    A_UINT64    rx_multicast_pkts;
+    A_UINT64    rx_multicast_bytes;
+    A_UINT64    rx_broadcast_pkts;
+    A_UINT64    rx_broadcast_bytes;
+    A_UINT64    rx_fragment_pkt;
+
+    A_UINT64    rx_errors;
+    A_UINT64    rx_crcerr;
+    A_UINT64    rx_key_cache_miss;
+    A_UINT64    rx_decrypt_err;
+    A_UINT64    rx_duplicate_frames;
+    A_INT32     rx_unicast_rate;
+
+    A_UINT64    tkip_local_mic_failure;
+    A_UINT64    tkip_counter_measures_invoked;
+    A_UINT64    tkip_replays;
+    A_UINT64    tkip_format_errors;
+    A_UINT64    ccmp_format_errors;
+    A_UINT64    ccmp_replays;
+
+    A_UINT64    power_save_failure_cnt;
+    A_INT16     noise_floor_calibation;
+
+    A_UINT64    cs_bmiss_cnt;
+    A_UINT64    cs_lowRssi_cnt;
+    A_UINT64    cs_connect_cnt;
+    A_UINT64    cs_disconnect_cnt;
+    A_UINT8     cs_aveBeacon_snr;
+    A_INT16     cs_aveBeacon_rssi;
+    A_UINT8     cs_lastRoam_msec;
+    A_UINT8     cs_snr;
+    A_INT16     cs_rssi;
+
+    A_UINT32    lq_val;
+
+    A_UINT32    wow_num_pkts_dropped;
+    A_UINT8     wow_num_host_pkt_wakeups;
+    A_UINT8     wow_num_host_event_wakeups;
+    A_UINT16    wow_num_events_discarded;
+
+}TARGET_STATS;
+
+typedef struct targetStats_cmd_t {
+    TARGET_STATS targetStats;
+    int clearStats;
+} TARGET_STATS_CMD;
+
+/* used by AR6000_XIOCTL_USER_SETKEYS */
+
+/*
+ * Setting this bit to 1 doesnot initialize the RSC on the firmware
+ */
+#define AR6000_XIOCTL_USER_SETKEYS_RSC_CTRL    1
+#define AR6000_USER_SETKEYS_RSC_UNCHANGED     0x00000002
+
+typedef struct {
+    A_UINT32  keyOpCtrl;  /* Bit Map of Key Mgmt Ctrl Flags */
+} AR6000_USER_SETKEYS_INFO;
+
+
+/* used by AR6000_XIOCTL_GPIO_OUTPUT_SET */
+struct ar6000_gpio_output_set_cmd_s {
+    A_UINT32 set_mask;
+    A_UINT32 clear_mask;
+    A_UINT32 enable_mask;
+    A_UINT32 disable_mask;
+};
+
+/*
+ * used by AR6000_XIOCTL_GPIO_REGISTER_GET and AR6000_XIOCTL_GPIO_REGISTER_SET
+ */
+struct ar6000_gpio_register_cmd_s {
+    A_UINT32 gpioreg_id;
+    A_UINT32 value;
+};
+
+/* used by AR6000_XIOCTL_GPIO_INTR_ACK */
+struct ar6000_gpio_intr_ack_cmd_s {
+    A_UINT32 ack_mask;
+};
+
+/* used by AR6000_XIOCTL_GPIO_INTR_WAIT */
+struct ar6000_gpio_intr_wait_cmd_s {
+    A_UINT32 intr_mask;
+    A_UINT32 input_values;
+};
+
+/* used by the AR6000_XIOCTL_DBGLOG_CFG_MODULE */
+typedef struct ar6000_dbglog_module_config_s {
+    A_UINT32 valid;
+    A_UINT16 mmask;
+    A_UINT16 tsr;
+    A_BOOL   rep;
+    A_UINT16 size;
+} DBGLOG_MODULE_CONFIG;
+
+typedef struct user_rssi_thold_t {
+    A_INT16     tag;
+    A_INT16     rssi;
+} USER_RSSI_THOLD;
+
+typedef struct user_rssi_params_t {
+    A_UINT8            weight;
+    A_UINT32           pollTime;
+    USER_RSSI_THOLD    tholds[12];
+} USER_RSSI_PARAMS;
+
+/*
+ * Host driver may have some config parameters. Typically, these
+ * config params are one time config parameters. These could
+ * correspond to any of the underlying modules. Host driver exposes
+ * an api for the underlying modules to get this config.
+ */
+#define AR6000_DRIVER_CFG_BASE                  0x8000
+
+/* Should driver perform wlan node caching? */
+#define AR6000_DRIVER_CFG_GET_WLANNODECACHING   0x8001
+/*Should we log raw WMI msgs */
+#define AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS      0x8002
+
+/* used by AR6000_XIOCTL_DIAG_READ & AR6000_XIOCTL_DIAG_WRITE */
+struct ar6000_diag_window_cmd_s {
+    unsigned int addr;
+    unsigned int value;
+};
+
+
+struct ar6000_traffic_activity_change {
+    A_UINT32    StreamID;   /* stream ID to indicate activity change */
+    A_UINT32    Active;     /* active (1) or inactive (0) */
+};
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/athtypes_linux.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/athtypes_linux.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/athtypes_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/athtypes_linux.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/os/linux/include/athtypes_linux.h#1 $
+ *
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _ATHTYPES_LINUX_H_
+#define _ATHTYPES_LINUX_H_
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#endif
+
+typedef int8_t      A_INT8;
+typedef int16_t     A_INT16;
+typedef int32_t     A_INT32;
+typedef int64_t     A_INT64;
+
+typedef u_int8_t     A_UINT8;
+typedef u_int16_t    A_UINT16;
+typedef u_int32_t    A_UINT32;
+typedef u_int64_t    A_UINT64;
+
+typedef int             A_BOOL;
+typedef char            A_CHAR;
+typedef unsigned char   A_UCHAR;
+typedef unsigned long   A_ATH_TIMER;
+
+
+#endif /* _ATHTYPES_LINUX_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/config_linux.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/config_linux.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/config_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/config_linux.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _CONFIG_LINUX_H_
+#define _CONFIG_LINUX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Host-side GPIO support is optional.
+ * If run-time access to GPIO pins is not required, then
+ * this should be changed to #undef.
+ */
+#define CONFIG_HOST_GPIO_SUPPORT
+
+/*
+ * Host side Test Command support
+ */
+#define CONFIG_HOST_TCMD_SUPPORT
+
+#define USE_4BYTE_REGISTER_ACCESS
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/debug_linux.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/debug_linux.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/debug_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/debug_linux.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _DEBUG_LINUX_H_
+#define _DEBUG_LINUX_H_
+
+#define DBG_DEFAULTS	(DBG_ERROR|DBG_WARNING)
+
+extern A_UINT32 g_dbg_flags;
+
+#define DBGFMT  "%s() : "
+#define DBGARG  __func__
+#define DBGFN	A_PRINTF
+
+/* ------- Debug related stuff ------- */
+enum {
+    ATH_DEBUG_SEND = 0x0001,
+    ATH_DEBUG_RECV = 0x0002,
+    ATH_DEBUG_SYNC = 0x0004,
+    ATH_DEBUG_DUMP = 0x0008,
+    ATH_DEBUG_IRQ  = 0x0010,
+    ATH_DEBUG_TRC  = 0x0020,
+    ATH_DEBUG_WARN = 0x0040,
+    ATH_DEBUG_ERR  = 0x0080,
+    ATH_LOG_INF	   = 0x0100,
+    ATH_DEBUG_BMI  = 0x0110,
+    ATH_DEBUG_WMI  = 0x0120,
+    ATH_DEBUG_HIF  = 0x0140,
+    ATH_DEBUG_HTC  = 0x0180,
+    ATH_DEBUG_WLAN = 0x1000,
+    ATH_LOG_ERR	   = 0x1010,
+    ATH_DEBUG_ANY  = 0xFFFF,
+};
+
+#ifdef DEBUG
+
+#define A_DPRINTF(f, a) \
+	if(g_dbg_flags & (f)) \
+	{	\
+		DBGFN a ; \
+	}
+
+
+// TODO FIX usage of A_PRINTF!
+#define AR_DEBUG_LVL_CHECK(lvl) (debughtc & (lvl))
+#define AR_DEBUG_PRINTBUF(buffer, length, desc) do {   \
+    if (debughtc & ATH_DEBUG_DUMP) {             \
+        DebugDumpBytes(buffer, length,desc);               \
+    }                                            \
+} while(0)
+#define PRINTX_ARG(arg...) arg
+#define AR_DEBUG_PRINTF(flags, args) do {        \
+    if (debughtc & (flags)) {                    \
+        A_PRINTF(KERN_ALERT PRINTX_ARG args);    \
+    }                                            \
+} while (0)
+#define AR_DEBUG_ASSERT(test) do {               \
+    if (!(test)) {                               \
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Debug Assert Caught, File %s, Line: %d, Test:%s \n",__FILE__, __LINE__,#test));         \
+    }                                            \
+} while(0)
+extern int debughtc;
+#else
+#define AR_DEBUG_PRINTF(flags, args)
+#define AR_DEBUG_PRINTBUF(buffer, length, desc)
+#define AR_DEBUG_ASSERT(test)
+#define AR_DEBUG_LVL_CHECK(lvl) 0
+#define A_DPRINTF(f, a)
+#endif
+
+#endif /* _DEBUG_LINUX_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ioctl.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ioctl.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/ioctl.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,2540 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "ar6000_drv.h"
+
+static A_UINT8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+static A_UINT8 null_mac[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
+extern USER_RSSI_THOLD rssi_map[12];
+extern unsigned int wmitimeout;
+extern A_WAITQUEUE_HEAD arEvent;
+extern int tspecCompliance;
+extern int bmienable;
+extern int bypasswmi;
+
+static int
+ar6000_ioctl_get_roam_tbl(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if(wmi_get_roam_tbl_cmd(ar->arWmi) != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_get_roam_data(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    /* currently assume only roam times are required */
+    if(wmi_get_roam_data_cmd(ar->arWmi, ROAM_DATA_TIME) != A_OK) {
+        return -EIO;
+    }
+
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_set_roam_ctrl(struct net_device *dev, char *userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_ROAM_CTRL_CMD cmd;
+    A_UINT8 size = sizeof(cmd);
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if (cmd.roamCtrlType == WMI_SET_HOST_BIAS) {
+        if (cmd.info.bssBiasInfo.numBss > 1) {
+            size += (cmd.info.bssBiasInfo.numBss - 1) * sizeof(WMI_BSS_BIAS);
+        }
+    }
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if(wmi_set_roam_ctrl_cmd(ar->arWmi, &cmd, size) != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_set_powersave_timers(struct net_device *dev, char *userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_POWERSAVE_TIMERS_POLICY_CMD cmd;
+    A_UINT8 size = sizeof(cmd);
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if (copy_from_user(&cmd, userdata, size)) {
+        return -EFAULT;
+    }
+
+    if(wmi_set_powersave_timers_cmd(ar->arWmi, &cmd, size) != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_set_wmm(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_WMM_CMD cmd;
+    A_STATUS ret;
+
+    if ((dev->flags & IFF_UP) != IFF_UP) {
+        return -EIO;
+    }
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, (char *)((unsigned int*)rq->ifr_data + 1),
+                                sizeof(cmd)))
+    {
+        return -EFAULT;
+    }
+
+    if (cmd.status == WMI_WMM_ENABLED) {
+        ar->arWmmEnabled = TRUE;
+    } else {
+        ar->arWmmEnabled = FALSE;
+    }
+
+    ret = wmi_set_wmm_cmd(ar->arWmi, cmd.status);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_set_txop(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_WMM_TXOP_CMD cmd;
+    A_STATUS ret;
+
+    if ((dev->flags & IFF_UP) != IFF_UP) {
+        return -EIO;
+    }
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, (char *)((unsigned int*)rq->ifr_data + 1),
+                                sizeof(cmd)))
+    {
+        return -EFAULT;
+    }
+
+    ret = wmi_set_wmm_txop(ar->arWmi, cmd.txopEnable);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_get_rd(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_STATUS ret = 0;
+
+    if ((dev->flags & IFF_UP) != IFF_UP || ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if(copy_to_user((char *)((unsigned int*)rq->ifr_data + 1),
+                            &ar->arRegCode, sizeof(ar->arRegCode)))
+        ret = -EFAULT;
+
+    return ret;
+}
+
+
+/* Get power mode command */
+static int
+ar6000_ioctl_get_power_mode(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_POWER_MODE_CMD power_mode;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    power_mode.powerMode = wmi_get_power_mode_cmd(ar->arWmi);
+    if (copy_to_user(rq->ifr_data, &power_mode, sizeof(WMI_POWER_MODE_CMD))) {
+        ret = -EFAULT;
+    }
+
+    return ret;
+}
+
+
+static int
+ar6000_ioctl_set_channelParams(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_CHANNEL_PARAMS_CMD cmd, *cmdp;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (cmd.numChannels > 1) {
+        cmdp = A_MALLOC(130);
+        if (copy_from_user(cmdp, rq->ifr_data,
+                           sizeof (*cmdp) +
+                           ((cmd.numChannels - 1) * sizeof(A_UINT16))))
+        {
+            kfree(cmdp);
+            return -EFAULT;
+        }
+    } else {
+        cmdp = &cmd;
+    }
+
+    if ((ar->arPhyCapability == WMI_11G_CAPABILITY) &&
+        ((cmdp->phyMode == WMI_11A_MODE) || (cmdp->phyMode == WMI_11AG_MODE)))
+    {
+        ret = -EINVAL;
+    }
+
+    if (!ret &&
+        (wmi_set_channelParams_cmd(ar->arWmi, cmdp->scanParam, cmdp->phyMode,
+                                   cmdp->numChannels, cmdp->channelList)
+         != A_OK))
+    {
+        ret = -EIO;
+    }
+
+    if (cmd.numChannels > 1) {
+        kfree(cmdp);
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_snr_threshold(struct net_device *dev, struct ifreq *rq)
+{
+
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SNR_THRESHOLD_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if( wmi_set_snr_threshold_params(ar->arWmi, &cmd) != A_OK ) {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_rssi_threshold(struct net_device *dev, struct ifreq *rq)
+{
+#define SWAP_THOLD(thold1, thold2) do { \
+    USER_RSSI_THOLD tmpThold;           \
+    tmpThold.tag = thold1.tag;          \
+    tmpThold.rssi = thold1.rssi;        \
+    thold1.tag = thold2.tag;            \
+    thold1.rssi = thold2.rssi;          \
+    thold2.tag = tmpThold.tag;          \
+    thold2.rssi = tmpThold.rssi;        \
+} while (0)
+
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_RSSI_THRESHOLD_PARAMS_CMD cmd;
+    USER_RSSI_PARAMS rssiParams;
+    A_INT32 i, j;
+
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user((char *)&rssiParams, (char *)((unsigned int *)rq->ifr_data + 1), sizeof(USER_RSSI_PARAMS))) {
+        return -EFAULT;
+    }
+    cmd.weight = rssiParams.weight;
+    cmd.pollTime = rssiParams.pollTime;
+
+    A_MEMCPY(rssi_map, &rssiParams.tholds, sizeof(rssi_map));
+    /*
+     *  only 6 elements, so use bubble sorting, in ascending order
+     */
+    for (i = 5; i > 0; i--) {
+        for (j = 0; j < i; j++) { /* above tholds */
+            if (rssi_map[j+1].rssi < rssi_map[j].rssi) {
+                SWAP_THOLD(rssi_map[j+1], rssi_map[j]);
+            } else if (rssi_map[j+1].rssi == rssi_map[j].rssi) {
+                return EFAULT;
+            }
+        }
+    }
+    for (i = 11; i > 6; i--) {
+        for (j = 6; j < i; j++) { /* below tholds */
+            if (rssi_map[j+1].rssi < rssi_map[j].rssi) {
+                SWAP_THOLD(rssi_map[j+1], rssi_map[j]);
+            } else if (rssi_map[j+1].rssi == rssi_map[j].rssi) {
+                return EFAULT;
+            }
+        }
+    }
+
+#ifdef DEBUG
+    for (i = 0; i < 12; i++) {
+        AR_DEBUG2_PRINTF("thold[%d].tag: %d, thold[%d].rssi: %d \n",
+                i, rssi_map[i].tag, i, rssi_map[i].rssi);
+    }
+#endif
+    cmd.thresholdAbove1_Val = rssi_map[0].rssi;
+    cmd.thresholdAbove2_Val = rssi_map[1].rssi;
+    cmd.thresholdAbove3_Val = rssi_map[2].rssi;
+    cmd.thresholdAbove4_Val = rssi_map[3].rssi;
+    cmd.thresholdAbove5_Val = rssi_map[4].rssi;
+    cmd.thresholdAbove6_Val = rssi_map[5].rssi;
+    cmd.thresholdBelow1_Val = rssi_map[6].rssi;
+    cmd.thresholdBelow2_Val = rssi_map[7].rssi;
+    cmd.thresholdBelow3_Val = rssi_map[8].rssi;
+    cmd.thresholdBelow4_Val = rssi_map[9].rssi;
+    cmd.thresholdBelow5_Val = rssi_map[10].rssi;
+    cmd.thresholdBelow6_Val = rssi_map[11].rssi;
+
+    if( wmi_set_rssi_threshold_params(ar->arWmi, &cmd) != A_OK ) {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_lq_threshold(struct net_device *dev, struct ifreq *rq)
+{
+
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_LQ_THRESHOLD_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, (char *)((unsigned int *)rq->ifr_data + 1), sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if( wmi_set_lq_threshold_params(ar->arWmi, &cmd) != A_OK ) {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+
+static int
+ar6000_ioctl_set_probedSsid(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_PROBED_SSID_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_probedSsid_cmd(ar->arWmi, cmd.entryIndex, cmd.flag, cmd.ssidLength,
+                                  cmd.ssid) != A_OK)
+    {
+        ret = -EIO;
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_badAp(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_ADD_BAD_AP_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (cmd.badApIndex > WMI_MAX_BAD_AP_INDEX) {
+        return -EIO;
+    }
+
+    if (A_MEMCMP(cmd.bssid, null_mac, AR6000_ETH_ADDR_LEN) == 0) {
+        /*
+         * This is a delete badAP.
+         */
+        if (wmi_deleteBadAp_cmd(ar->arWmi, cmd.badApIndex) != A_OK) {
+            ret = -EIO;
+        }
+    } else {
+        if (wmi_addBadAp_cmd(ar->arWmi, cmd.badApIndex, cmd.bssid) != A_OK) {
+            ret = -EIO;
+        }
+    }
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_create_qos(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_CREATE_PSTREAM_CMD cmd;
+    A_STATUS ret;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    ret = wmi_verify_tspec_params(&cmd, tspecCompliance);
+    if (ret == A_OK)
+        ret = wmi_create_pstream_cmd(ar->arWmi, &cmd);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_delete_qos(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_DELETE_PSTREAM_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    ret = wmi_delete_pstream_cmd(ar->arWmi, cmd.trafficClass, cmd.tsid);
+
+    switch (ret) {
+        case A_OK:
+            return 0;
+        case A_EBUSY :
+            return -EBUSY;
+        case A_NO_MEMORY:
+            return -ENOMEM;
+        case A_EINVAL:
+        default:
+            return -EFAULT;
+    }
+}
+
+static int
+ar6000_ioctl_get_qos_queue(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct ar6000_queuereq qreq;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if( copy_from_user(&qreq, rq->ifr_data,
+                  sizeof(struct ar6000_queuereq)))
+        return -EFAULT;
+
+    qreq.activeTsids = wmi_get_mapped_qos_queue(ar->arWmi, qreq.trafficClass);
+
+    if (copy_to_user(rq->ifr_data, &qreq,
+                 sizeof(struct ar6000_queuereq)))
+    {
+        ret = -EFAULT;
+    }
+
+    return ret;
+}
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+static A_STATUS
+ar6000_ioctl_tcmd_get_rx_report(struct net_device *dev,
+                                 struct ifreq *rq, A_UINT8 *data, A_UINT32 len)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_UINT32    buf[2];
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    ar->tcmdRxReport = 0;
+    if (wmi_test_cmd(ar->arWmi, data, len) != A_OK) {
+        up(&ar->arSem);
+        return -EIO;
+    }
+
+    wait_event_interruptible_timeout(arEvent, ar->tcmdRxReport != 0, wmitimeout * HZ);
+
+    if (signal_pending(current)) {
+        ret = -EINTR;
+    }
+
+    buf[0] = ar->tcmdRxTotalPkt;
+    buf[1] = ar->tcmdRxRssi;
+    if (!ret && copy_to_user(rq->ifr_data, buf, sizeof(buf))) {
+        ret = -EFAULT;
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+void
+ar6000_tcmd_rx_report_event(void *devt, A_UINT8 * results, int len)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)devt;
+    TCMD_CONT_RX * rx_rep = (TCMD_CONT_RX *)results;
+
+    ar->tcmdRxTotalPkt = rx_rep->u.report.totalPkt;
+    ar->tcmdRxRssi = rx_rep->u.report.rssiInDBm;
+    ar->tcmdRxReport = 1;
+
+    wake_up(&arEvent);
+}
+#endif /* CONFIG_HOST_TCMD_SUPPORT*/
+
+static int
+ar6000_ioctl_set_error_report_bitmask(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_TARGET_ERROR_REPORT_BITMASK cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    ret = wmi_set_error_report_bitmask(ar->arWmi, cmd.bitmask);
+
+    return  (ret==0 ? ret : -EINVAL);
+}
+
+static int
+ar6000_clear_target_stats(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+       return -EIO;
+    }
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+    A_MEMZERO(pStats, sizeof(TARGET_STATS));
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+    return ret;
+}
+
+static int
+ar6000_ioctl_get_target_stats(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    TARGET_STATS_CMD cmd;
+    TARGET_STATS *pStats = &ar->arTargetStats;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+
+    ar->statsUpdatePending = TRUE;
+
+    if(wmi_get_stats_cmd(ar->arWmi) != A_OK) {
+        up(&ar->arSem);
+        return -EIO;
+    }
+
+    wait_event_interruptible_timeout(arEvent, ar->statsUpdatePending == FALSE, wmitimeout * HZ);
+
+    if (signal_pending(current)) {
+        ret = -EINTR;
+    }
+
+    if (!ret && copy_to_user(rq->ifr_data, pStats, sizeof(*pStats))) {
+        ret = -EFAULT;
+    }
+
+    if (cmd.clearStats == 1) {
+        ret = ar6000_clear_target_stats(dev);
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+static int
+ar6000_ioctl_set_access_params(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_ACCESS_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_access_params_cmd(ar->arWmi, cmd.txop, cmd.eCWmin, cmd.eCWmax,
+                                  cmd.aifsn) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+static int
+ar6000_ioctl_set_disconnect_timeout(struct net_device *dev, struct ifreq *rq)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_DISC_TIMEOUT_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, rq->ifr_data, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_disctimeout_cmd(ar->arWmi, cmd.disconnectTimeout) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+static int
+ar6000_xioctl_set_voice_pkt_size(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_VOICE_PKT_SIZE_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_voice_pkt_size_cmd(ar->arWmi, cmd.voicePktSize) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+
+    return (ret);
+}
+
+static int
+ar6000_xioctl_set_max_sp_len(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_MAX_SP_LEN_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_max_sp_len_cmd(ar->arWmi, cmd.maxSPLen) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+
+static int
+ar6000_xioctl_set_bt_status_cmd(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_BT_STATUS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_bt_status_cmd(ar->arWmi, cmd.streamType, cmd.status) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+static int
+ar6000_xioctl_set_bt_params_cmd(struct net_device *dev, char * userdata)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    WMI_SET_BT_PARAMS_CMD cmd;
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (copy_from_user(&cmd, userdata, sizeof(cmd))) {
+        return -EFAULT;
+    }
+
+    if (wmi_set_bt_params_cmd(ar->arWmi, &cmd) == A_OK)
+    {
+        ret = 0;
+    } else {
+        ret = -EINVAL;
+    }
+
+    return (ret);
+}
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+struct ar6000_gpio_intr_wait_cmd_s  gpio_intr_results;
+/* gpio_reg_results and gpio_data_available are protected by arSem */
+static struct ar6000_gpio_register_cmd_s gpio_reg_results;
+static A_BOOL gpio_data_available; /* Requested GPIO data available */
+static A_BOOL gpio_intr_available; /* GPIO interrupt info available */
+static A_BOOL gpio_ack_received;   /* GPIO ack was received */
+
+/* Host-side initialization for General Purpose I/O support */
+void ar6000_gpio_init(void)
+{
+    gpio_intr_available = FALSE;
+    gpio_data_available = FALSE;
+    gpio_ack_received   = FALSE;
+}
+
+/*
+ * Called when a GPIO interrupt is received from the Target.
+ * intr_values shows which GPIO pins have interrupted.
+ * input_values shows a recent value of GPIO pins.
+ */
+void
+ar6000_gpio_intr_rx(A_UINT32 intr_mask, A_UINT32 input_values)
+{
+    gpio_intr_results.intr_mask = intr_mask;
+    gpio_intr_results.input_values = input_values;
+    *((volatile A_BOOL *)&gpio_intr_available) = TRUE;
+    wake_up(&arEvent);
+}
+
+/*
+ * This is called when a response is received from the Target
+ * for a previous or ar6000_gpio_input_get or ar6000_gpio_register_get
+ * call.
+ */
+void
+ar6000_gpio_data_rx(A_UINT32 reg_id, A_UINT32 value)
+{
+    gpio_reg_results.gpioreg_id = reg_id;
+    gpio_reg_results.value = value;
+    *((volatile A_BOOL *)&gpio_data_available) = TRUE;
+    wake_up(&arEvent);
+}
+
+/*
+ * This is called when an acknowledgement is received from the Target
+ * for a previous or ar6000_gpio_output_set or ar6000_gpio_register_set
+ * call.
+ */
+void
+ar6000_gpio_ack_rx(void)
+{
+    gpio_ack_received = TRUE;
+    wake_up(&arEvent);
+}
+
+A_STATUS
+ar6000_gpio_output_set(struct net_device *dev,
+                       A_UINT32 set_mask,
+                       A_UINT32 clear_mask,
+                       A_UINT32 enable_mask,
+                       A_UINT32 disable_mask)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    gpio_ack_received = FALSE;
+    return wmi_gpio_output_set(ar->arWmi,
+                set_mask, clear_mask, enable_mask, disable_mask);
+}
+
+static A_STATUS
+ar6000_gpio_input_get(struct net_device *dev)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    *((volatile A_BOOL *)&gpio_data_available) = FALSE;
+    return wmi_gpio_input_get(ar->arWmi);
+}
+
+static A_STATUS
+ar6000_gpio_register_set(struct net_device *dev,
+                         A_UINT32 gpioreg_id,
+                         A_UINT32 value)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    gpio_ack_received = FALSE;
+    return wmi_gpio_register_set(ar->arWmi, gpioreg_id, value);
+}
+
+static A_STATUS
+ar6000_gpio_register_get(struct net_device *dev,
+                         A_UINT32 gpioreg_id)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    *((volatile A_BOOL *)&gpio_data_available) = FALSE;
+    return wmi_gpio_register_get(ar->arWmi, gpioreg_id);
+}
+
+static A_STATUS
+ar6000_gpio_intr_ack(struct net_device *dev,
+                     A_UINT32 ack_mask)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    gpio_intr_available = FALSE;
+    return wmi_gpio_intr_ack(ar->arWmi, ack_mask);
+}
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+int ar6000_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    HIF_DEVICE *hifDevice = ar->arHifDevice;
+    int ret, param, param2;
+    unsigned int address = 0;
+    unsigned int length = 0;
+    unsigned char *buffer;
+    char *userdata;
+    A_UINT32 connectCtrlFlags;
+
+
+    static WMI_SCAN_PARAMS_CMD scParams = {0, 0, 0, 0, 0,
+                                           WMI_SHORTSCANRATIO_DEFAULT,
+                                           DEFAULT_SCAN_CTRL_FLAGS,
+                                           0};
+    WMI_SET_AKMP_PARAMS_CMD  akmpParams;
+    WMI_SET_PMKID_LIST_CMD   pmkidInfo;
+
+    if (cmd == AR6000_IOCTL_EXTENDED)
+    {
+        /*
+         * This allows for many more wireless ioctls than would otherwise
+         * be available.  Applications embed the actual ioctl command in
+         * the first word of the parameter block, and use the command
+         * AR6000_IOCTL_EXTENDED_CMD on the ioctl call.
+         */
+        get_user(cmd, (int *)rq->ifr_data);
+        userdata = (char *)(((unsigned int *)rq->ifr_data)+1);
+    }
+    else
+    {
+        userdata = (char *)rq->ifr_data;
+    }
+
+    if ((ar->arWlanState == WLAN_DISABLED) &&
+        ((cmd != AR6000_XIOCTRL_WMI_SET_WLAN_STATE) &&
+         (cmd != AR6000_XIOCTL_DIAG_READ) &&
+         (cmd != AR6000_XIOCTL_DIAG_WRITE)))
+    {
+        return -EIO;
+    }
+
+    ret = 0;
+    switch(cmd)
+    {
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+        case AR6000_XIOCTL_TCMD_CONT_TX:
+            {
+                TCMD_CONT_TX txCmd;
+
+                if (ar->tcmdPm == TCMD_PM_SLEEP) {
+                    A_PRINTF("Can NOT send tx tcmd when target is asleep! \n");
+                    return -EFAULT;
+                }
+
+                if(copy_from_user(&txCmd, userdata, sizeof(TCMD_CONT_TX)))
+                    return -EFAULT;
+                wmi_test_cmd(ar->arWmi,(A_UINT8 *)&txCmd, sizeof(TCMD_CONT_TX));
+            }
+            break;
+        case AR6000_XIOCTL_TCMD_CONT_RX:
+            {
+                TCMD_CONT_RX rxCmd;
+
+                if (ar->tcmdPm == TCMD_PM_SLEEP) {
+                    A_PRINTF("Can NOT send rx tcmd when target is asleep! \n");
+                    return -EFAULT;
+                }
+                if(copy_from_user(&rxCmd, userdata, sizeof(TCMD_CONT_RX)))
+                    return -EFAULT;
+                switch(rxCmd.act)
+                {
+                    case TCMD_CONT_RX_PROMIS:
+                    case TCMD_CONT_RX_FILTER:
+                    case TCMD_CONT_RX_SETMAC:
+                         wmi_test_cmd(ar->arWmi,(A_UINT8 *)&rxCmd,
+                                                sizeof(TCMD_CONT_RX));
+                         break;
+                    case TCMD_CONT_RX_REPORT:
+                         ar6000_ioctl_tcmd_get_rx_report(dev, rq,
+                         (A_UINT8 *)&rxCmd, sizeof(TCMD_CONT_RX));
+                         break;
+                    default:
+                         A_PRINTF("Unknown Cont Rx mode: %d\n",rxCmd.act);
+                         return -EINVAL;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_TCMD_PM:
+            {
+                TCMD_PM pmCmd;
+
+                if(copy_from_user(&pmCmd, userdata, sizeof(TCMD_PM)))
+                    return -EFAULT;
+                ar->tcmdPm = pmCmd.mode;
+                wmi_test_cmd(ar->arWmi, (A_UINT8*)&pmCmd, sizeof(TCMD_PM));
+            }
+            break;
+#endif /* CONFIG_HOST_TCMD_SUPPORT */
+
+        case AR6000_XIOCTL_BMI_DONE:
+            if(bmienable)
+            {
+                ret = ar6000_init(dev);
+            }
+            else
+            {
+                ret = BMIDone(hifDevice);
+            }
+            break;
+
+        case AR6000_XIOCTL_BMI_READ_MEMORY:
+            get_user(address, (unsigned int *)userdata);
+            get_user(length, (unsigned int *)userdata + 1);
+            AR_DEBUG_PRINTF("Read Memory (address: 0x%x, length: %d)\n",
+                             address, length);
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                ret = BMIReadMemory(hifDevice, address, buffer, length);
+                if (copy_to_user(rq->ifr_data, buffer, length)) {
+                    ret = -EFAULT;
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+            break;
+
+        case AR6000_XIOCTL_BMI_WRITE_MEMORY:
+            get_user(address, (unsigned int *)userdata);
+            get_user(length, (unsigned int *)userdata + 1);
+            AR_DEBUG_PRINTF("Write Memory (address: 0x%x, length: %d)\n",
+                             address, length);
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                if (copy_from_user(buffer, &userdata[sizeof(address) +
+                                   sizeof(length)], length))
+                {
+                    ret = -EFAULT;
+                } else {
+                    ret = BMIWriteMemory(hifDevice, address, buffer, length);
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+            break;
+
+        case AR6000_XIOCTL_BMI_TEST:
+           AR_DEBUG_PRINTF("No longer supported\n");
+           ret = -EOPNOTSUPP;
+           break;
+
+        case AR6000_XIOCTL_BMI_EXECUTE:
+            get_user(address, (unsigned int *)userdata);
+            get_user(param, (unsigned int *)userdata + 1);
+            AR_DEBUG_PRINTF("Execute (address: 0x%x, param: %d)\n",
+                             address, param);
+            ret = BMIExecute(hifDevice, address, &param);
+            put_user(param, (unsigned int *)rq->ifr_data); /* return value */
+            break;
+
+        case AR6000_XIOCTL_BMI_SET_APP_START:
+            get_user(address, (unsigned int *)userdata);
+            AR_DEBUG_PRINTF("Set App Start (address: 0x%x)\n", address);
+            ret = BMISetAppStart(hifDevice, address);
+            break;
+
+        case AR6000_XIOCTL_BMI_READ_SOC_REGISTER:
+            get_user(address, (unsigned int *)userdata);
+            ret = BMIReadSOCRegister(hifDevice, address, &param);
+            put_user(param, (unsigned int *)rq->ifr_data); /* return value */
+            break;
+
+        case AR6000_XIOCTL_BMI_WRITE_SOC_REGISTER:
+            get_user(address, (unsigned int *)userdata);
+            get_user(param, (unsigned int *)userdata + 1);
+            ret = BMIWriteSOCRegister(hifDevice, address, param);
+            break;
+
+#ifdef HTC_RAW_INTERFACE
+        case AR6000_XIOCTL_HTC_RAW_OPEN:
+            ret = A_OK;
+            if (!arRawIfEnabled(ar)) {
+                /* make sure block size is set in case the target was reset since last
+                  * BMI phase (i.e. flashup downloads) */
+                ret = ar6000_SetHTCBlockSize(ar);
+                if (A_FAILED(ret)) {
+                    break;
+                }
+                /* Terminate the BMI phase */
+                ret = BMIDone(hifDevice);
+                if (ret == A_OK) {
+                    ret = ar6000_htc_raw_open(ar);
+                }
+            }
+            break;
+
+        case AR6000_XIOCTL_HTC_RAW_CLOSE:
+            if (arRawIfEnabled(ar)) {
+                ret = ar6000_htc_raw_close(ar);
+                arRawIfEnabled(ar) = FALSE;
+            } else {
+                ret = A_ERROR;
+            }
+            break;
+
+        case AR6000_XIOCTL_HTC_RAW_READ:
+            if (arRawIfEnabled(ar)) {
+                unsigned int streamID;
+                get_user(streamID, (unsigned int *)userdata);
+                get_user(length, (unsigned int *)userdata + 1);
+                buffer = rq->ifr_data + sizeof(length);
+                ret = ar6000_htc_raw_read(ar, (HTC_RAW_STREAM_ID)streamID,
+                                          buffer, length);
+                put_user(ret, (unsigned int *)rq->ifr_data);
+            } else {
+                ret = A_ERROR;
+            }
+            break;
+
+        case AR6000_XIOCTL_HTC_RAW_WRITE:
+            if (arRawIfEnabled(ar)) {
+                unsigned int streamID;
+                get_user(streamID, (unsigned int *)userdata);
+                get_user(length, (unsigned int *)userdata + 1);
+                buffer = userdata + sizeof(streamID) + sizeof(length);
+                ret = ar6000_htc_raw_write(ar, (HTC_RAW_STREAM_ID)streamID,
+                                           buffer, length);
+                put_user(ret, (unsigned int *)rq->ifr_data);
+            } else {
+                ret = A_ERROR;
+            }
+            break;
+#endif /* HTC_RAW_INTERFACE */
+
+        case AR6000_IOCTL_WMI_GETREV:
+        {
+            if (copy_to_user(rq->ifr_data, &ar->arVersion,
+                             sizeof(ar->arVersion)))
+            {
+                ret = -EFAULT;
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETPWR:
+        {
+            WMI_POWER_MODE_CMD pwrModeCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&pwrModeCmd, userdata,
+                                   sizeof(pwrModeCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_powermode_cmd(ar->arWmi, pwrModeCmd.powerMode)
+                       != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_IBSS_PM_CAPS:
+        {
+            WMI_IBSS_PM_CAPS_CMD ibssPmCaps;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&ibssPmCaps, userdata,
+                                   sizeof(ibssPmCaps)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_ibsspmcaps_cmd(ar->arWmi, ibssPmCaps.power_saving, ibssPmCaps.ttl,
+                    ibssPmCaps.atim_windows, ibssPmCaps.timeout_value) != A_OK)
+                {
+                    ret = -EIO;
+                }
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                ar->arIbssPsEnable = ibssPmCaps.power_saving;
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_PMPARAMS:
+        {
+            WMI_POWER_PARAMS_CMD pmParams;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&pmParams, userdata,
+                                      sizeof(pmParams)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_pmparams_cmd(ar->arWmi, pmParams.idle_period,
+                                     pmParams.pspoll_number,
+                                     pmParams.dtim_policy) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETSCAN:
+        {
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&scParams, userdata,
+                                      sizeof(scParams)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (CAN_SCAN_IN_CONNECT(scParams.scanCtrlFlags)) {
+                    ar->arSkipScan = FALSE;
+                } else {
+                    ar->arSkipScan = TRUE;
+                }
+
+                if (wmi_scanparams_cmd(ar->arWmi, scParams.fg_start_period,
+                                       scParams.fg_end_period,
+                                       scParams.bg_period,
+                                       scParams.minact_chdwell_time,
+                                       scParams.maxact_chdwell_time,
+                                       scParams.pas_chdwell_time,
+                                       scParams.shortScanRatio,
+                                       scParams.scanCtrlFlags,
+                                       scParams.max_dfsch_act_time) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETLISTENINT:
+        {
+            WMI_LISTEN_INT_CMD listenCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&listenCmd, userdata,
+                                      sizeof(listenCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                    if (wmi_listeninterval_cmd(ar->arWmi, listenCmd.listenInterval, listenCmd.numBeacons) != A_OK) {
+                        ret = -EIO;
+                    } else {
+                        AR6000_SPIN_LOCK(&ar->arLock, 0);
+                        ar->arListenInterval = param;
+                        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                    }
+
+                }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_BMISS_TIME:
+        {
+            WMI_BMISS_TIME_CMD bmissCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&bmissCmd, userdata,
+                                      sizeof(bmissCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_bmisstime_cmd(ar->arWmi, bmissCmd.bmissTime, bmissCmd.numBeacons) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SETBSSFILTER:
+        {
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+
+                get_user(param, (unsigned char *)userdata);
+                get_user(param2, (unsigned int *)(userdata + 1));
+		printk("SETBSSFILTER: filter 0x%x, mask: 0x%x\n", param, param2);
+                if (wmi_bssfilter_cmd(ar->arWmi, param, param2) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_SNRTHRESHOLD:
+        {
+            ret = ar6000_ioctl_set_snr_threshold(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_RSSITHRESHOLD:
+        {
+            ret = ar6000_ioctl_set_rssi_threshold(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_CLR_RSSISNR:
+        {
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            }
+            ret = wmi_clr_rssi_snr(ar->arWmi);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_LQTHRESHOLD:
+        {
+            ret = ar6000_ioctl_set_lq_threshold(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_LPREAMBLE:
+        {
+            WMI_SET_LPREAMBLE_CMD setLpreambleCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setLpreambleCmd, userdata,
+                                   sizeof(setLpreambleCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_lpreamble_cmd(ar->arWmi, setLpreambleCmd.status)
+                       != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_RTS:
+        {
+            WMI_SET_RTS_CMD rtsCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&rtsCmd, userdata,
+                                   sizeof(rtsCmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_rts_cmd(ar->arWmi, rtsCmd.threshold)
+                       != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_WMM:
+        {
+            ret = ar6000_ioctl_set_wmm(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_TXOP:
+        {
+            ret = ar6000_ioctl_set_txop(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_GET_RD:
+        {
+            ret = ar6000_ioctl_get_rd(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_CHANNELPARAMS:
+        {
+            ret = ar6000_ioctl_set_channelParams(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_PROBEDSSID:
+        {
+            ret = ar6000_ioctl_set_probedSsid(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_BADAP:
+        {
+            ret = ar6000_ioctl_set_badAp(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_CREATE_QOS:
+        {
+            ret = ar6000_ioctl_create_qos(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_DELETE_QOS:
+        {
+            ret = ar6000_ioctl_delete_qos(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_GET_QOS_QUEUE:
+        {
+            ret = ar6000_ioctl_get_qos_queue(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_GET_TARGET_STATS:
+        {
+            ret = ar6000_ioctl_get_target_stats(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_ERROR_REPORT_BITMASK:
+        {
+            ret = ar6000_ioctl_set_error_report_bitmask(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_ASSOC_INFO:
+        {
+            WMI_SET_ASSOC_INFO_CMD cmd;
+            A_UINT8 assocInfo[WMI_MAX_ASSOC_INFO_LEN];
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+                get_user(cmd.ieType, userdata);
+                if (cmd.ieType >= WMI_MAX_ASSOC_INFO_TYPE) {
+                    ret = -EIO;
+                } else {
+                    get_user(cmd.bufferSize, userdata + 1);
+                    if (cmd.bufferSize > WMI_MAX_ASSOC_INFO_LEN) {
+                        ret = -EFAULT;
+                        break;
+                    }
+                    if (copy_from_user(assocInfo, userdata + 2,
+                                       cmd.bufferSize))
+                    {
+                        ret = -EFAULT;
+                    } else {
+                        if (wmi_associnfo_cmd(ar->arWmi, cmd.ieType,
+                                                 cmd.bufferSize,
+                                                 assocInfo) != A_OK)
+                        {
+                            ret = -EIO;
+                        }
+                    }
+                }
+            }
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_ACCESS_PARAMS:
+        {
+            ret = ar6000_ioctl_set_access_params(dev, rq);
+            break;
+        }
+        case AR6000_IOCTL_WMI_SET_DISC_TIMEOUT:
+        {
+            ret = ar6000_ioctl_set_disconnect_timeout(dev, rq);
+            break;
+        }
+        case AR6000_XIOCTL_FORCE_TARGET_RESET:
+        {
+            if (ar->arHtcTarget)
+            {
+//                HTCForceReset(htcTarget);
+            }
+            else
+            {
+                AR_DEBUG_PRINTF("ar6000_ioctl cannot attempt reset.\n");
+            }
+            break;
+        }
+        case AR6000_XIOCTL_TARGET_INFO:
+        case AR6000_XIOCTL_CHECK_TARGET_READY: /* backwards compatibility */
+        {
+            /* If we made it to here, then the Target exists and is ready. */
+
+            if (cmd == AR6000_XIOCTL_TARGET_INFO) {
+                if (copy_to_user((A_UINT32 *)rq->ifr_data, &ar->arVersion.target_ver,
+                                 sizeof(ar->arVersion.target_ver)))
+                {
+                    ret = -EFAULT;
+                }
+                if (copy_to_user(((A_UINT32 *)rq->ifr_data)+1, &ar->arTargetType,
+                                 sizeof(ar->arTargetType)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_HB_CHALLENGE_RESP_PARAMS:
+        {
+            WMI_SET_HB_CHALLENGE_RESP_PARAMS_CMD hbparam;
+
+            if (copy_from_user(&hbparam, userdata, sizeof(hbparam)))
+            {
+                ret = -EFAULT;
+            } else {
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                /* Start a cyclic timer with the parameters provided. */
+                if (hbparam.frequency) {
+                    ar->arHBChallengeResp.frequency = hbparam.frequency;
+                }
+                if (hbparam.threshold) {
+                    ar->arHBChallengeResp.missThres = hbparam.threshold;
+                }
+
+                /* Delete the pending timer and start a new one */
+                if (timer_pending(&ar->arHBChallengeResp.timer)) {
+                    A_UNTIMEOUT(&ar->arHBChallengeResp.timer);
+                }
+                A_TIMEOUT_MS(&ar->arHBChallengeResp.timer, ar->arHBChallengeResp.frequency * 1000, 0);
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_GET_HB_CHALLENGE_RESP:
+        {
+            A_UINT32 cookie;
+
+            if (copy_from_user(&cookie, userdata, sizeof(cookie))) {
+                return -EFAULT;
+            }
+
+            /* Send the challenge on the control channel */
+            if (wmi_get_challenge_resp_cmd(ar->arWmi, cookie, APP_HB_CHALLENGE) != A_OK) {
+                return -EIO;
+            }
+            break;
+        }
+#ifdef USER_KEYS
+        case AR6000_XIOCTL_USER_SETKEYS:
+        {
+
+            ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_RUN;
+
+            if (copy_from_user(&ar->user_key_ctrl, userdata,
+                               sizeof(ar->user_key_ctrl)))
+            {
+                return -EFAULT;
+            }
+
+            A_PRINTF("ar6000 USER set key %x\n", ar->user_key_ctrl);
+            break;
+        }
+#endif /* USER_KEYS */
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+        case AR6000_XIOCTL_GPIO_OUTPUT_SET:
+        {
+            struct ar6000_gpio_output_set_cmd_s gpio_output_set_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_output_set_cmd, userdata,
+                                sizeof(gpio_output_set_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_output_set(dev,
+                                             gpio_output_set_cmd.set_mask,
+                                             gpio_output_set_cmd.clear_mask,
+                                             gpio_output_set_cmd.enable_mask,
+                                             gpio_output_set_cmd.disable_mask);
+                if (ret != A_OK) {
+                    ret = EIO;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_INPUT_GET:
+        {
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            ret = ar6000_gpio_input_get(dev);
+            if (ret != A_OK) {
+                up(&ar->arSem);
+                return -EIO;
+            }
+
+            /* Wait for Target to respond. */
+            wait_event_interruptible(arEvent, gpio_data_available);
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            } else {
+                A_ASSERT(gpio_reg_results.gpioreg_id == GPIO_ID_NONE);
+
+                if (copy_to_user(userdata, &gpio_reg_results.value,
+                                 sizeof(gpio_reg_results.value)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_REGISTER_SET:
+        {
+            struct ar6000_gpio_register_cmd_s gpio_register_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_register_cmd, userdata,
+                                sizeof(gpio_register_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_register_set(dev,
+                                               gpio_register_cmd.gpioreg_id,
+                                               gpio_register_cmd.value);
+                if (ret != A_OK) {
+                    ret = EIO;
+                }
+
+                /* Wait for acknowledgement from Target */
+                wait_event_interruptible(arEvent, gpio_ack_received);
+                if (signal_pending(current)) {
+                    ret = -EINTR;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_REGISTER_GET:
+        {
+            struct ar6000_gpio_register_cmd_s gpio_register_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_register_cmd, userdata,
+                                sizeof(gpio_register_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_register_get(dev, gpio_register_cmd.gpioreg_id);
+                if (ret != A_OK) {
+                    up(&ar->arSem);
+                    return -EIO;
+                }
+
+                /* Wait for Target to respond. */
+                wait_event_interruptible(arEvent, gpio_data_available);
+                if (signal_pending(current)) {
+                    ret = -EINTR;
+                } else {
+                    A_ASSERT(gpio_register_cmd.gpioreg_id == gpio_reg_results.gpioreg_id);
+                    if (copy_to_user(userdata, &gpio_reg_results,
+                                     sizeof(gpio_reg_results)))
+                    {
+                        ret = -EFAULT;
+                    }
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_INTR_ACK:
+        {
+            struct ar6000_gpio_intr_ack_cmd_s gpio_intr_ack_cmd;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+
+            if (copy_from_user(&gpio_intr_ack_cmd, userdata,
+                                sizeof(gpio_intr_ack_cmd)))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = ar6000_gpio_intr_ack(dev, gpio_intr_ack_cmd.ack_mask);
+                if (ret != A_OK) {
+                    ret = EIO;
+                }
+            }
+            up(&ar->arSem);
+            break;
+        }
+        case AR6000_XIOCTL_GPIO_INTR_WAIT:
+        {
+            /* Wait for Target to report an interrupt. */
+            dev_hold(dev);
+            rtnl_unlock();
+            wait_event_interruptible(arEvent, gpio_intr_available);
+            rtnl_lock();
+            __dev_put(dev);
+
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            } else {
+                if (copy_to_user(userdata, &gpio_intr_results,
+                                 sizeof(gpio_intr_results)))
+                {
+                    ret = -EFAULT;
+                }
+            }
+            break;
+        }
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+        case AR6000_XIOCTL_DBGLOG_CFG_MODULE:
+        {
+            struct ar6000_dbglog_module_config_s config;
+
+            if (copy_from_user(&config, userdata, sizeof(config))) {
+                return -EFAULT;
+            }
+
+            /* Send the challenge on the control channel */
+            if (wmi_config_debug_module_cmd(ar->arWmi, config.mmask,
+                                            config.tsr, config.rep,
+                                            config.size, config.valid) != A_OK)
+            {
+                return -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_DBGLOG_GET_DEBUG_LOGS:
+        {
+            /* Send the challenge on the control channel */
+            if (ar6000_dbglog_get_debug_logs(ar) != A_OK)
+            {
+                return -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_ADHOC_BSSID:
+        {
+            WMI_SET_ADHOC_BSSID_CMD adhocBssid;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&adhocBssid, userdata,
+                                      sizeof(adhocBssid)))
+            {
+                ret = -EFAULT;
+            } else if (A_MEMCMP(adhocBssid.bssid, bcast_mac,
+                                AR6000_ETH_ADDR_LEN) == 0)
+            {
+                ret = -EFAULT;
+            } else {
+
+                A_MEMCPY(ar->arReqBssid, adhocBssid.bssid, sizeof(ar->arReqBssid));
+        }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_OPT_MODE:
+        {
+        WMI_SET_OPT_MODE_CMD optModeCmd;
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&optModeCmd, userdata,
+                                      sizeof(optModeCmd)))
+            {
+                ret = -EFAULT;
+            } else if (ar->arConnected && optModeCmd.optMode == SPECIAL_ON) {
+                ret = -EFAULT;
+
+            } else if (wmi_set_opt_mode_cmd(ar->arWmi, optModeCmd.optMode)
+                       != A_OK)
+            {
+                ret = -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_OPT_SEND_FRAME:
+        {
+        WMI_OPT_TX_FRAME_CMD optTxFrmCmd;
+            A_UINT8 data[MAX_OPT_DATA_LEN];
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&optTxFrmCmd, userdata,
+                                      sizeof(optTxFrmCmd)))
+            {
+                ret = -EFAULT;
+            } else if (copy_from_user(data,
+                                      userdata+sizeof(WMI_OPT_TX_FRAME_CMD)-1,
+                                      optTxFrmCmd.optIEDataLen))
+            {
+                ret = -EFAULT;
+            } else {
+                ret = wmi_opt_tx_frame_cmd(ar->arWmi,
+                                           optTxFrmCmd.frmType,
+                                           optTxFrmCmd.dstAddr,
+                                           optTxFrmCmd.bssid,
+                                           optTxFrmCmd.optIEDataLen,
+                                           data);
+            }
+
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SETRETRYLIMITS:
+        {
+            WMI_SET_RETRY_LIMITS_CMD setRetryParams;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setRetryParams, userdata,
+                                      sizeof(setRetryParams)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_retry_limits_cmd(ar->arWmi, setRetryParams.frameType,
+                                          setRetryParams.trafficClass,
+                                          setRetryParams.maxRetries,
+                                          setRetryParams.enableNotify) != A_OK)
+                {
+                    ret = -EIO;
+                }
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                ar->arMaxRetries = setRetryParams.maxRetries;
+                AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_ADHOC_BEACON_INTVAL:
+        {
+            WMI_BEACON_INT_CMD bIntvlCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&bIntvlCmd, userdata,
+                       sizeof(bIntvlCmd)))
+            {
+                ret = -EFAULT;
+            } else if (wmi_set_adhoc_bconIntvl_cmd(ar->arWmi, bIntvlCmd.beaconInterval)
+                        != A_OK)
+            {
+                ret = -EIO;
+            }
+            break;
+        }
+        case IEEE80211_IOCTL_SETAUTHALG:
+        {
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+            struct ieee80211req_authalg req;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&req, userdata,
+                       sizeof(struct ieee80211req_authalg)))
+            {
+                ret = -EFAULT;
+            } else if (req.auth_alg == AUTH_ALG_OPEN_SYSTEM) {
+                ar->arDot11AuthMode  = OPEN_AUTH;
+                ar->arPairwiseCrypto  = NONE_CRYPT;
+                ar->arGroupCrypto     = NONE_CRYPT;
+            } else if (req.auth_alg == AUTH_ALG_LEAP) {
+                ar->arDot11AuthMode   = LEAP_AUTH;
+            } else {
+                ret = -EIO;
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_SET_VOICE_PKT_SIZE:
+            ret = ar6000_xioctl_set_voice_pkt_size(dev, userdata);
+            break;
+
+        case AR6000_XIOCTL_SET_MAX_SP:
+            ret = ar6000_xioctl_set_max_sp_len(dev, userdata);
+            break;
+
+        case AR6000_XIOCTL_WMI_GET_ROAM_TBL:
+            ret = ar6000_ioctl_get_roam_tbl(dev, rq);
+            break;
+        case AR6000_XIOCTL_WMI_SET_ROAM_CTRL:
+            ret = ar6000_ioctl_set_roam_ctrl(dev, userdata);
+            break;
+        case AR6000_XIOCTRL_WMI_SET_POWERSAVE_TIMERS:
+            ret = ar6000_ioctl_set_powersave_timers(dev, userdata);
+            break;
+        case AR6000_XIOCTRL_WMI_GET_POWER_MODE:
+            ret = ar6000_ioctl_get_power_mode(dev, rq);
+            break;
+        case AR6000_XIOCTRL_WMI_SET_WLAN_STATE:
+            get_user(ar->arWlanState, (unsigned int *)userdata);
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+                break;
+            }
+
+            if (ar->arWlanState == WLAN_ENABLED) {
+                /* Enable foreground scanning */
+                if (wmi_scanparams_cmd(ar->arWmi, scParams.fg_start_period,
+                                       scParams.fg_end_period,
+                                       scParams.bg_period,
+                                       scParams.minact_chdwell_time,
+                                       scParams.maxact_chdwell_time,
+                                       scParams.pas_chdwell_time,
+                                       scParams.shortScanRatio,
+                                       scParams.scanCtrlFlags,
+                                       scParams.max_dfsch_act_time) != A_OK)
+                {
+                    ret = -EIO;
+                }
+                if (ar->arSsidLen) {
+                    ar->arConnectPending = TRUE;
+                    if (wmi_connect_cmd(ar->arWmi, ar->arNetworkType,
+                                        ar->arDot11AuthMode, ar->arAuthMode,
+                                        ar->arPairwiseCrypto,
+                                        ar->arPairwiseCryptoLen,
+                                        ar->arGroupCrypto, ar->arGroupCryptoLen,
+                                        ar->arSsidLen, ar->arSsid,
+                                        ar->arReqBssid, ar->arChannelHint,
+                                        ar->arConnectCtrlFlags) != A_OK)
+                    {
+                        ret = -EIO;
+                        ar->arConnectPending = FALSE;
+                    }
+                }
+            } else {
+                /* Disconnect from the AP and disable foreground scanning */
+                AR6000_SPIN_LOCK(&ar->arLock, 0);
+                if (ar->arConnected == TRUE || ar->arConnectPending == TRUE) {
+                    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                    wmi_disconnect_cmd(ar->arWmi);
+                } else {
+                    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+                }
+
+                if (wmi_scanparams_cmd(ar->arWmi, 0xFFFF, 0, 0, 0, 0, 0, 0, 0xFF, 0) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_GET_ROAM_DATA:
+            ret = ar6000_ioctl_get_roam_data(dev, rq);
+            break;
+        case AR6000_XIOCTL_WMI_SET_BT_STATUS:
+            ret = ar6000_xioctl_set_bt_status_cmd(dev, userdata);
+            break;
+        case AR6000_XIOCTL_WMI_SET_BT_PARAMS:
+            ret = ar6000_xioctl_set_bt_params_cmd(dev, userdata);
+            break;
+        case AR6000_XIOCTL_WMI_STARTSCAN:
+        {
+            WMI_START_SCAN_CMD setStartScanCmd;
+
+            if (ar->arWmiReady == FALSE) {
+                    ret = -EIO;
+                } else if (copy_from_user(&setStartScanCmd, userdata,
+                                          sizeof(setStartScanCmd)))
+                {
+                    ret = -EFAULT;
+                } else {
+                    if (wmi_startscan_cmd(ar->arWmi, setStartScanCmd.scanType,
+                                    setStartScanCmd.forceFgScan,
+                                    setStartScanCmd.isLegacy,
+                                    setStartScanCmd.homeDwellTime,
+                                    setStartScanCmd.forceScanInterval) != A_OK)
+                    {
+                        ret = -EIO;
+                    }
+                }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SETFIXRATES:
+        {
+            WMI_FIX_RATES_CMD setFixRatesCmd;
+            A_STATUS returnStatus;
+
+            if (ar->arWmiReady == FALSE) {
+                    ret = -EIO;
+                } else if (copy_from_user(&setFixRatesCmd, userdata,
+                                          sizeof(setFixRatesCmd)))
+                {
+                    ret = -EFAULT;
+                } else {
+                    returnStatus = wmi_set_fixrates_cmd(ar->arWmi, setFixRatesCmd.fixRateMask);
+                    if (returnStatus == A_EINVAL)
+                    {
+                        ret = -EINVAL;
+                    }
+                    else if(returnStatus != A_OK) {
+                        ret = -EIO;
+                    }
+                }
+            break;
+        }
+
+        case AR6000_XIOCTL_WMI_GETFIXRATES:
+        {
+            WMI_FIX_RATES_CMD getFixRatesCmd;
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+            int ret = 0;
+
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+            /* Used copy_from_user/copy_to_user to access user space data */
+            if (copy_from_user(&getFixRatesCmd, userdata, sizeof(getFixRatesCmd))) {
+                ret = -EFAULT;
+            } else {
+                ar->arRateMask = 0xFFFF;
+
+                if (wmi_get_ratemask_cmd(ar->arWmi) != A_OK) {
+                    up(&ar->arSem);
+                    return -EIO;
+                }
+
+                wait_event_interruptible_timeout(arEvent, ar->arRateMask != 0xFFFF, wmitimeout * HZ);
+
+                if (signal_pending(current)) {
+                    ret = -EINTR;
+                }
+
+                if (!ret) {
+                    getFixRatesCmd.fixRateMask = ar->arRateMask;
+                }
+
+                if(copy_to_user(userdata, &getFixRatesCmd, sizeof(getFixRatesCmd))) {
+                   ret = -EFAULT;
+                }
+
+                up(&ar->arSem);
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_AUTHMODE:
+        {
+            WMI_SET_AUTH_MODE_CMD setAuthMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setAuthMode, userdata,
+                                      sizeof(setAuthMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_authmode_cmd(ar->arWmi, setAuthMode.mode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_REASSOCMODE:
+        {
+            WMI_SET_REASSOC_MODE_CMD setReassocMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setReassocMode, userdata,
+                                      sizeof(setReassocMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_reassocmode_cmd(ar->arWmi, setReassocMode.mode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_DIAG_READ:
+        {
+            A_UINT32 addr, data;
+            get_user(addr, (unsigned int *)userdata);
+            if (ar6000_ReadRegDiag(ar->arHifDevice, &addr, &data) != A_OK) {
+                ret = -EIO;
+            }
+            put_user(data, (unsigned int *)userdata + 1);
+            break;
+        }
+        case AR6000_XIOCTL_DIAG_WRITE:
+        {
+            A_UINT32 addr, data;
+            get_user(addr, (unsigned int *)userdata);
+            get_user(data, (unsigned int *)userdata + 1);
+            if (ar6000_WriteRegDiag(ar->arHifDevice, &addr, &data) != A_OK) {
+                ret = -EIO;
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_KEEPALIVE:
+        {
+             WMI_SET_KEEPALIVE_CMD setKeepAlive;
+             if (ar->arWmiReady == FALSE) {
+                 return -EIO;
+             } else if (copy_from_user(&setKeepAlive, userdata,
+                        sizeof(setKeepAlive))){
+                 ret = -EFAULT;
+             } else {
+                 if (wmi_set_keepalive_cmd(ar->arWmi, setKeepAlive.keepaliveInterval) != A_OK) {
+                     ret = -EIO;
+               }
+             }
+             break;
+        }
+        case AR6000_XIOCTL_WMI_GET_KEEPALIVE:
+        {
+            AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+            WMI_GET_KEEPALIVE_CMD getKeepAlive;
+            int ret = 0;
+            if (ar->arWmiReady == FALSE) {
+               return -EIO;
+            }
+            if (down_interruptible(&ar->arSem)) {
+                return -ERESTARTSYS;
+            }
+            if (copy_from_user(&getKeepAlive, userdata,sizeof(getKeepAlive))) {
+               ret = -EFAULT;
+            } else {
+            getKeepAlive.keepaliveInterval = wmi_get_keepalive_cmd(ar->arWmi);
+            ar->arKeepaliveConfigured = 0xFF;
+            if (wmi_get_keepalive_configured(ar->arWmi) != A_OK){
+                up(&ar->arSem);
+                return -EIO;
+            }
+            wait_event_interruptible_timeout(arEvent, ar->arKeepaliveConfigured != 0xFF, wmitimeout * HZ);
+            if (signal_pending(current)) {
+                ret = -EINTR;
+            }
+
+            if (!ret) {
+                getKeepAlive.configured = ar->arKeepaliveConfigured;
+            }
+            if (copy_to_user(userdata, &getKeepAlive, sizeof(getKeepAlive))) {
+               ret = -EFAULT;
+            }
+            up(&ar->arSem);
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_APPIE:
+        {
+            WMI_SET_APPIE_CMD appIEcmd;
+            A_UINT8           appIeInfo[IEEE80211_APPIE_FRAME_MAX_LEN];
+            A_UINT32            fType,ieLen;
+
+	    if (ar->arWmiReady == FALSE) {
+		    return -EIO;
+	    }
+	    get_user(fType, (A_UINT32 *)userdata);
+	    appIEcmd.mgmtFrmType = fType;
+	    if (appIEcmd.mgmtFrmType >= IEEE80211_APPIE_NUM_OF_FRAME) {
+		    ret = -EIO;
+	    } else {
+		    get_user(ieLen, (A_UINT32 *)(userdata + 4));
+		    appIEcmd.ieLen = ieLen;
+		    if (appIEcmd.ieLen > IEEE80211_APPIE_FRAME_MAX_LEN) {
+			    ret = -EIO;
+			    break;
+		    }
+		    if (copy_from_user(appIeInfo, userdata + 8, appIEcmd.ieLen)) {
+			    ret = -EFAULT;
+		    } else {
+			    if (wmi_set_appie_cmd(ar->arWmi, appIEcmd.mgmtFrmType,
+						  appIEcmd.ieLen,  appIeInfo) != A_OK)
+			    {
+				    ret = -EIO;
+			    }
+		    }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_MGMT_FRM_RX_FILTER:
+        {
+            WMI_BSS_FILTER_CMD cmd;
+            A_UINT32    filterType;
+
+            if (copy_from_user(&filterType, userdata, sizeof(A_UINT32)))
+            {
+                return -EFAULT;
+            }
+            if (filterType & (IEEE80211_FILTER_TYPE_BEACON |
+                                    IEEE80211_FILTER_TYPE_PROBE_RESP))
+            {
+                cmd.bssFilter = ALL_BSS_FILTER;
+            } else {
+                cmd.bssFilter = NONE_BSS_FILTER;
+            }
+            if (wmi_bssfilter_cmd(ar->arWmi, cmd.bssFilter, 0) != A_OK) {
+                ret = -EIO;
+            }
+
+            AR6000_SPIN_LOCK(&ar->arLock, 0);
+            ar->arMgmtFilter = filterType;
+            AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_WSC_STATUS:
+        {
+            A_UINT32    wsc_status;
+
+            if (copy_from_user(&wsc_status, userdata, sizeof(A_UINT32)))
+            {
+                return -EFAULT;
+            }
+            if (wmi_set_wsc_status_cmd(ar->arWmi, wsc_status) != A_OK) {
+                ret = -EIO;
+            }
+            break;
+        }
+        case AR6000_XIOCTL_BMI_ROMPATCH_INSTALL:
+        {
+            A_UINT32 ROM_addr;
+            A_UINT32 RAM_addr;
+            A_UINT32 nbytes;
+            A_UINT32 do_activate;
+            A_UINT32 rompatch_id;
+
+            get_user(ROM_addr, (A_UINT32 *)userdata);
+            get_user(RAM_addr, (A_UINT32 *)userdata + 1);
+            get_user(nbytes, (A_UINT32 *)userdata + 2);
+            get_user(do_activate, (A_UINT32 *)userdata + 3);
+            AR_DEBUG_PRINTF("Install rompatch from ROM: 0x%x to RAM: 0x%x  length: %d\n",
+                             ROM_addr, RAM_addr, nbytes);
+            ret = BMIrompatchInstall(hifDevice, ROM_addr, RAM_addr,
+                                        nbytes, do_activate, &rompatch_id);
+            if (ret == A_OK) {
+                put_user(rompatch_id, (unsigned int *)rq->ifr_data); /* return value */
+            }
+            break;
+        }
+
+        case AR6000_XIOCTL_BMI_ROMPATCH_UNINSTALL:
+        {
+            A_UINT32 rompatch_id;
+
+            get_user(rompatch_id, (A_UINT32 *)userdata);
+            AR_DEBUG_PRINTF("UNinstall rompatch_id %d\n", rompatch_id);
+            ret = BMIrompatchUninstall(hifDevice, rompatch_id);
+            break;
+        }
+
+        case AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE:
+        case AR6000_XIOCTL_BMI_ROMPATCH_DEACTIVATE:
+        {
+            A_UINT32 rompatch_count;
+
+            get_user(rompatch_count, (A_UINT32 *)userdata);
+            AR_DEBUG_PRINTF("Change rompatch activation count=%d\n", rompatch_count);
+            length = sizeof(A_UINT32) * rompatch_count;
+            if ((buffer = (unsigned char *)A_MALLOC(length)) != NULL) {
+                A_MEMZERO(buffer, length);
+                if (copy_from_user(buffer, &userdata[sizeof(rompatch_count)], length))
+                {
+                    ret = -EFAULT;
+                } else {
+                    if (cmd == AR6000_XIOCTL_BMI_ROMPATCH_ACTIVATE) {
+                        ret = BMIrompatchActivate(hifDevice, rompatch_count, (A_UINT32 *)buffer);
+                    } else {
+                        ret = BMIrompatchDeactivate(hifDevice, rompatch_count, (A_UINT32 *)buffer);
+                    }
+                }
+                A_FREE(buffer);
+            } else {
+                ret = -ENOMEM;
+            }
+
+            break;
+        }
+
+        case AR6000_XIOCTL_WMI_SET_HOST_SLEEP_MODE:
+        {
+            WMI_SET_HOST_SLEEP_MODE_CMD setHostSleepMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setHostSleepMode, userdata,
+                                      sizeof(setHostSleepMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_host_sleep_mode_cmd(ar->arWmi,
+                                &setHostSleepMode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_SET_WOW_MODE:
+        {
+            WMI_SET_WOW_MODE_CMD setWowMode;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&setWowMode, userdata,
+                                      sizeof(setWowMode)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_wow_mode_cmd(ar->arWmi,
+                                &setWowMode) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_GET_WOW_LIST:
+        {
+            WMI_GET_WOW_LIST_CMD getWowList;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&getWowList, userdata,
+                                      sizeof(getWowList)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_get_wow_list_cmd(ar->arWmi,
+                                &getWowList) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_WMI_ADD_WOW_PATTERN:
+        {
+#define WOW_PATTERN_SIZE 64
+#define WOW_MASK_SIZE 64
+
+            WMI_ADD_WOW_PATTERN_CMD cmd;
+            A_UINT8 mask_data[WOW_PATTERN_SIZE]={0};
+            A_UINT8 pattern_data[WOW_PATTERN_SIZE]={0};
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+
+                if(copy_from_user(&cmd, userdata,
+                            sizeof(WMI_ADD_WOW_PATTERN_CMD)))
+                      return -EFAULT;
+                if (copy_from_user(pattern_data,
+                                      userdata + 3,
+                                      cmd.filter_size)){
+                        ret = -EFAULT;
+                        break;
+                }
+                if (copy_from_user(mask_data,
+                                      (userdata + 3 + cmd.filter_size),
+                                      cmd.filter_size)){
+                        ret = -EFAULT;
+                        break;
+                } else {
+                    if (wmi_add_wow_pattern_cmd(ar->arWmi,
+                                &cmd, pattern_data, mask_data, cmd.filter_size) != A_OK){
+                        ret = -EIO;
+                    }
+                }
+            }
+#undef WOW_PATTERN_SIZE
+#undef WOW_MASK_SIZE
+            break;
+        }
+        case AR6000_XIOCTL_WMI_DEL_WOW_PATTERN:
+        {
+            WMI_DEL_WOW_PATTERN_CMD delWowPattern;
+
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&delWowPattern, userdata,
+                                      sizeof(delWowPattern)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_del_wow_pattern_cmd(ar->arWmi,
+                                &delWowPattern) != A_OK)
+                {
+                    ret = -EIO;
+                }
+            }
+            break;
+        }
+        case AR6000_XIOCTL_DUMP_HTC_CREDIT_STATE:
+            if (ar->arHtcTarget != NULL) {
+                HTCDumpCreditStates(ar->arHtcTarget);
+            }
+            break;
+        case AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE:
+            if (ar->arHtcTarget != NULL) {
+                struct ar6000_traffic_activity_change data;
+
+                if (copy_from_user(&data, userdata, sizeof(data)))
+                {
+                    return -EFAULT;
+                }
+                    /* note, this is used for testing (mbox ping testing), indicate activity
+                     * change using the stream ID as the traffic class */
+                ar6000_indicate_tx_activity(ar,
+                                            (A_UINT8)data.StreamID,
+                                            data.Active ? TRUE : FALSE);
+            }
+            break;
+        case AR6000_XIOCTL_WMI_SET_CONNECT_CTRL_FLAGS:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&connectCtrlFlags, userdata,
+                                      sizeof(connectCtrlFlags)))
+            {
+                ret = -EFAULT;
+            } else {
+                ar->arConnectCtrlFlags = connectCtrlFlags;
+            }
+            break;
+        case AR6000_XIOCTL_WMI_SET_AKMP_PARAMS:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else if (copy_from_user(&akmpParams, userdata,
+                                      sizeof(WMI_SET_AKMP_PARAMS_CMD)))
+            {
+                ret = -EFAULT;
+            } else {
+                if (wmi_set_akmp_params_cmd(ar->arWmi, &akmpParams) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_SET_PMKID_LIST:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else {
+                if (copy_from_user(&pmkidInfo.numPMKID, userdata,
+                                      sizeof(pmkidInfo.numPMKID)))
+                {
+                    ret = -EFAULT;
+                    break;
+                }
+                if (copy_from_user(&pmkidInfo.pmkidList,
+                                   userdata + sizeof(pmkidInfo.numPMKID),
+                                   pmkidInfo.numPMKID * sizeof(WMI_PMKID)))
+                {
+                    ret = -EFAULT;
+                    break;
+                }
+                if (wmi_set_pmkid_list_cmd(ar->arWmi, &pmkidInfo) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        case AR6000_XIOCTL_WMI_GET_PMKID_LIST:
+            if (ar->arWmiReady == FALSE) {
+                ret = -EIO;
+            } else  {
+                if (wmi_get_pmkid_list_cmd(ar->arWmi) != A_OK) {
+                    ret = -EIO;
+                }
+            }
+            break;
+        default:
+            ret = -EOPNOTSUPP;
+    }
+    return ret;
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/netbuf.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/netbuf.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/netbuf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/netbuf.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,225 @@
+
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/skbuff.h>
+#include <a_config.h>
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+#include "htc_packet.h"
+
+#define AR6000_DATA_OFFSET    64
+
+void a_netbuf_enqueue(A_NETBUF_QUEUE_T *q, void *pkt)
+{
+    skb_queue_tail((struct sk_buff_head *) q, (struct sk_buff *) pkt);
+}
+
+void a_netbuf_prequeue(A_NETBUF_QUEUE_T *q, void *pkt)
+{
+    skb_queue_head((struct sk_buff_head *) q, (struct sk_buff *) pkt);
+}
+
+void *a_netbuf_dequeue(A_NETBUF_QUEUE_T *q)
+{
+    return((void *) skb_dequeue((struct sk_buff_head *) q));
+}
+
+int a_netbuf_queue_size(A_NETBUF_QUEUE_T *q)
+{
+    return(skb_queue_len((struct sk_buff_head *) q));
+}
+
+int a_netbuf_queue_empty(A_NETBUF_QUEUE_T *q)
+{
+    return(skb_queue_empty((struct sk_buff_head *) q));
+}
+
+void a_netbuf_queue_init(A_NETBUF_QUEUE_T *q)
+{
+    skb_queue_head_init((struct sk_buff_head *) q);
+}
+
+void *
+a_netbuf_alloc(int size)
+{
+    struct sk_buff *skb;
+    skb = dev_alloc_skb(AR6000_DATA_OFFSET + sizeof(HTC_PACKET) + size);
+    skb_reserve(skb, AR6000_DATA_OFFSET + sizeof(HTC_PACKET));
+    return ((void *)skb);
+}
+
+/*
+ * Allocate an SKB w.o. any encapsulation requirement.
+ */
+void *
+a_netbuf_alloc_raw(int size)
+{
+    struct sk_buff *skb;
+
+    skb = dev_alloc_skb(size);
+
+    return ((void *)skb);
+}
+
+void
+a_netbuf_free(void *bufPtr)
+{
+    struct sk_buff *skb = (struct sk_buff *)bufPtr;
+
+    dev_kfree_skb(skb);
+}
+
+A_UINT32
+a_netbuf_to_len(void *bufPtr)
+{
+    return (((struct sk_buff *)bufPtr)->len);
+}
+
+void *
+a_netbuf_to_data(void *bufPtr)
+{
+    return (((struct sk_buff *)bufPtr)->data);
+}
+
+/*
+ * Add len # of bytes to the beginning of the network buffer
+ * pointed to by bufPtr
+ */
+A_STATUS
+a_netbuf_push(void *bufPtr, A_INT32 len)
+{
+    skb_push((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Add len # of bytes to the beginning of the network buffer
+ * pointed to by bufPtr and also fill with data
+ */
+A_STATUS
+a_netbuf_push_data(void *bufPtr, char *srcPtr, A_INT32 len)
+{
+    skb_push((struct sk_buff *) bufPtr, len);
+    A_MEMCPY(((struct sk_buff *)bufPtr)->data, srcPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Add len # of bytes to the end of the network buffer
+ * pointed to by bufPtr
+ */
+A_STATUS
+a_netbuf_put(void *bufPtr, A_INT32 len)
+{
+    skb_put((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Add len # of bytes to the end of the network buffer
+ * pointed to by bufPtr and also fill with data
+ */
+A_STATUS
+a_netbuf_put_data(void *bufPtr, char *srcPtr, A_INT32 len)
+{
+    char *start = ((struct sk_buff *)bufPtr)->data +
+        ((struct sk_buff *)bufPtr)->len;
+    skb_put((struct sk_buff *)bufPtr, len);
+    A_MEMCPY(start, srcPtr, len);
+
+    return A_OK;
+}
+
+
+/*
+ * Trim the network buffer pointed to by bufPtr to len # of bytes
+ */
+A_STATUS
+a_netbuf_setlen(void *bufPtr, A_INT32 len)
+{
+    skb_trim((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Chop of len # of bytes from the end of the buffer.
+ */
+A_STATUS
+a_netbuf_trim(void *bufPtr, A_INT32 len)
+{
+    skb_trim((struct sk_buff *)bufPtr, ((struct sk_buff *)bufPtr)->len - len);
+
+    return A_OK;
+}
+
+/*
+ * Chop of len # of bytes from the end of the buffer and return the data.
+ */
+A_STATUS
+a_netbuf_trim_data(void *bufPtr, char *dstPtr, A_INT32 len)
+{
+    char *start = ((struct sk_buff *)bufPtr)->data +
+        (((struct sk_buff *)bufPtr)->len - len);
+
+    A_MEMCPY(dstPtr, start, len);
+    skb_trim((struct sk_buff *)bufPtr, ((struct sk_buff *)bufPtr)->len - len);
+
+    return A_OK;
+}
+
+
+/*
+ * Returns the number of bytes available to a a_netbuf_push()
+ */
+A_INT32
+a_netbuf_headroom(void *bufPtr)
+{
+    return (skb_headroom((struct sk_buff *)bufPtr));
+}
+
+/*
+ * Removes specified number of bytes from the beginning of the buffer
+ */
+A_STATUS
+a_netbuf_pull(void *bufPtr, A_INT32 len)
+{
+    skb_pull((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
+/*
+ * Removes specified number of bytes from the beginning of the buffer
+ * and return the data
+ */
+A_STATUS
+a_netbuf_pull_data(void *bufPtr, char *dstPtr, A_INT32 len)
+{
+    A_MEMCPY(dstPtr, ((struct sk_buff *)bufPtr)->data, len);
+    skb_pull((struct sk_buff *)bufPtr, len);
+
+    return A_OK;
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/osapi_linux.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/osapi_linux.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/osapi_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/osapi_linux.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,319 @@
+/*
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/os/linux/include/osapi_linux.h#1 $
+ *
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _OSAPI_LINUX_H_
+#define _OSAPI_LINUX_H_
+
+#ifdef __KERNEL__
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#include <linux/jiffies.h>
+#endif
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#ifdef KERNEL_2_4
+#include <asm/arch/irq.h>
+#include <asm/irq.h>
+#endif
+
+#ifdef __GNUC__
+#define __ATTRIB_PACK           __attribute__ ((packed))
+#define __ATTRIB_PRINTF         __attribute__ ((format (printf, 1, 2)))
+#define __ATTRIB_NORETURN       __attribute__ ((noreturn))
+#ifndef INLINE
+#define INLINE                  __inline__
+#endif
+#else /* Not GCC */
+#define __ATTRIB_PACK
+#define __ATTRIB_PRINTF
+#define __ATTRIB_NORETURN
+#ifndef INLINE
+#define INLINE                  __inline
+#endif
+#endif /* End __GNUC__ */
+
+#define PREPACK
+#define POSTPACK                __ATTRIB_PACK
+
+/*
+ * Endianes macros
+ */
+#define A_BE2CPU8(x)       ntohb(x)
+#define A_BE2CPU16(x)      ntohs(x)
+#define A_BE2CPU32(x)      ntohl(x)
+
+#define A_LE2CPU8(x)       (x)
+#define A_LE2CPU16(x)      (x)
+#define A_LE2CPU32(x)      (x)
+
+#define A_CPU2BE8(x)       htonb(x)
+#define A_CPU2BE16(x)      htons(x)
+#define A_CPU2BE32(x)      htonl(x)
+
+#define A_MEMCPY(dst, src, len)         memcpy((A_UINT8 *)(dst), (src), (len))
+#define A_MEMZERO(addr, len)            memset(addr, 0, len)
+#define A_MEMCMP(addr1, addr2, len)     memcmp((addr1), (addr2), (len))
+#define A_MALLOC(size)                  kmalloc((size), GFP_KERNEL)
+#define A_MALLOC_NOWAIT(size)           kmalloc((size), GFP_ATOMIC)
+#define A_FREE(addr)                    kfree(addr)
+#define A_PRINTF(args...)               printk(args)
+
+/* Mutual Exclusion */
+typedef spinlock_t                      A_MUTEX_T;
+#define A_MUTEX_INIT(mutex)             spin_lock_init(mutex)
+#define A_MUTEX_LOCK(mutex)             spin_lock_bh(mutex)
+#define A_MUTEX_UNLOCK(mutex)           spin_unlock_bh(mutex)
+#define A_IS_MUTEX_VALID(mutex)         TRUE  /* okay to return true, since A_MUTEX_DELETE does nothing */
+#define A_MUTEX_DELETE(mutex)           /* spin locks are not kernel resources so nothing to free.. */
+
+/* Get current time in ms adding a constant offset (in ms) */
+#define A_GET_MS(offset)    \
+	(jiffies + ((offset) / 1000) * HZ)
+
+/*
+ * Timer Functions
+ */
+#define A_MDELAY(msecs)                 mdelay(msecs)
+typedef struct timer_list               A_TIMER;
+
+#define A_INIT_TIMER(pTimer, pFunction, pArg) do {              \
+    init_timer(pTimer);                                         \
+    (pTimer)->function = (pFunction);                           \
+    (pTimer)->data   = (unsigned long)(pArg);                   \
+} while (0)
+
+/*
+ * Start a Timer that elapses after 'periodMSec' milli-seconds
+ * Support is provided for a one-shot timer. The 'repeatFlag' is
+ * ignored.
+ */
+#define A_TIMEOUT_MS(pTimer, periodMSec, repeatFlag) do {                   \
+    if (repeatFlag) {                                                       \
+        printk("\n" __FILE__ ":%d: Timer Repeat requested\n",__LINE__);     \
+        panic("Timer Repeat");                                              \
+    }                                                                       \
+    mod_timer((pTimer), jiffies + HZ * (periodMSec) / 1000);                \
+} while (0)
+
+/*
+ * Cancel the Timer.
+ */
+#define A_UNTIMEOUT(pTimer) do {                                \
+    del_timer((pTimer));                                        \
+} while (0)
+
+#define A_DELETE_TIMER(pTimer) do {                             \
+} while (0)
+
+/*
+ * Wait Queue related functions
+ */
+typedef wait_queue_head_t               A_WAITQUEUE_HEAD;
+#define A_INIT_WAITQUEUE_HEAD(head)     init_waitqueue_head(head)
+#ifndef wait_event_interruptible_timeout
+#define __wait_event_interruptible_timeout(wq, condition, ret)          \
+do {                                                                    \
+        wait_queue_t __wait;                                            \
+        init_waitqueue_entry(&__wait, current);                         \
+                                                                        \
+        add_wait_queue(&wq, &__wait);                                   \
+        for (;;) {                                                      \
+                set_current_state(TASK_INTERRUPTIBLE);                  \
+                if (condition)                                          \
+                        break;                                          \
+                if (!signal_pending(current)) {                         \
+                        ret = schedule_timeout(ret);                    \
+                        if (!ret)                                       \
+                                break;                                  \
+                        continue;                                       \
+                }                                                       \
+                ret = -ERESTARTSYS;                                     \
+                break;                                                  \
+        }                                                               \
+        current->state = TASK_RUNNING;                                  \
+        remove_wait_queue(&wq, &__wait);                                \
+} while (0)
+
+#define wait_event_interruptible_timeout(wq, condition, timeout)        \
+({                                                                      \
+        long __ret = timeout;                                           \
+        if (!(condition))                                               \
+                __wait_event_interruptible_timeout(wq, condition, __ret); \
+        __ret;                                                          \
+})
+#endif /* wait_event_interruptible_timeout */
+
+#define A_WAIT_EVENT_INTERRUPTIBLE_TIMEOUT(head, condition, timeout) do { \
+    wait_event_interruptible_timeout(head, condition, timeout); \
+} while (0)
+
+#define A_WAKE_UP(head)                 wake_up(head)
+
+#ifdef DEBUG
+#define A_ASSERT(expr)  \
+    if (!(expr)) {   \
+        printk(KERN_ALERT "\n" __FILE__ ":%d: Assertion " #expr " failed!\n",__LINE__); \
+        panic(#expr); \
+    }
+
+#else
+#define A_ASSERT(expr)
+#endif /* DEBUG */
+
+/*
+ * Initialization of the network buffer subsystem
+ */
+#define A_NETBUF_INIT()
+
+/*
+ * Network buffer queue support
+ */
+typedef struct sk_buff_head A_NETBUF_QUEUE_T;
+
+#define A_NETBUF_QUEUE_INIT(q)  \
+    a_netbuf_queue_init(q)
+
+#define A_NETBUF_ENQUEUE(q, pkt) \
+    a_netbuf_enqueue((q), (pkt))
+#define A_NETBUF_PREQUEUE(q, pkt) \
+    a_netbuf_prequeue((q), (pkt))
+#define A_NETBUF_DEQUEUE(q) \
+    (a_netbuf_dequeue(q))
+#define A_NETBUF_QUEUE_SIZE(q)  \
+    a_netbuf_queue_size(q)
+#define A_NETBUF_QUEUE_EMPTY(q) \
+    a_netbuf_queue_empty(q)
+
+/*
+ * Network buffer support
+ */
+#define A_NETBUF_ALLOC(size) \
+    a_netbuf_alloc(size)
+#define A_NETBUF_ALLOC_RAW(size) \
+    a_netbuf_alloc_raw(size)
+#define A_NETBUF_FREE(bufPtr) \
+    a_netbuf_free(bufPtr)
+#define A_NETBUF_DATA(bufPtr) \
+    a_netbuf_to_data(bufPtr)
+#define A_NETBUF_LEN(bufPtr) \
+    a_netbuf_to_len(bufPtr)
+#define A_NETBUF_PUSH(bufPtr, len) \
+    a_netbuf_push(bufPtr, len)
+#define A_NETBUF_PUT(bufPtr, len) \
+    a_netbuf_put(bufPtr, len)
+#define A_NETBUF_TRIM(bufPtr,len) \
+    a_netbuf_trim(bufPtr, len)
+#define A_NETBUF_PULL(bufPtr, len) \
+    a_netbuf_pull(bufPtr, len)
+#define A_NETBUF_HEADROOM(bufPtr)\
+    a_netbuf_headroom(bufPtr)
+#define A_NETBUF_SETLEN(bufPtr,len) \
+    a_netbuf_setlen(bufPtr, len)
+
+/* Add data to end of a buffer  */
+#define A_NETBUF_PUT_DATA(bufPtr, srcPtr,  len) \
+    a_netbuf_put_data(bufPtr, srcPtr, len)
+
+/* Add data to start of the  buffer */
+#define A_NETBUF_PUSH_DATA(bufPtr, srcPtr,  len) \
+    a_netbuf_push_data(bufPtr, srcPtr, len)
+
+/* Remove data at start of the buffer */
+#define A_NETBUF_PULL_DATA(bufPtr, dstPtr, len) \
+    a_netbuf_pull_data(bufPtr, dstPtr, len)
+
+/* Remove data from the end of the buffer */
+#define A_NETBUF_TRIM_DATA(bufPtr, dstPtr, len) \
+    a_netbuf_trim_data(bufPtr, dstPtr, len)
+
+/* View data as "size" contiguous bytes of type "t" */
+#define A_NETBUF_VIEW_DATA(bufPtr, t, size) \
+    (t )( ((struct skbuf *)(bufPtr))->data)
+
+/* return the beginning of the headroom for the buffer */
+#define A_NETBUF_HEAD(bufPtr) \
+        ((((struct sk_buff *)(bufPtr))->head))
+
+/*
+ * OS specific network buffer access routines
+ */
+void *a_netbuf_alloc(int size);
+void *a_netbuf_alloc_raw(int size);
+void a_netbuf_free(void *bufPtr);
+void *a_netbuf_to_data(void *bufPtr);
+A_UINT32 a_netbuf_to_len(void *bufPtr);
+A_STATUS a_netbuf_push(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_push_data(void *bufPtr, char *srcPtr, A_INT32 len);
+A_STATUS a_netbuf_put(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_put_data(void *bufPtr, char *srcPtr, A_INT32 len);
+A_STATUS a_netbuf_pull(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_pull_data(void *bufPtr, char *dstPtr, A_INT32 len);
+A_STATUS a_netbuf_trim(void *bufPtr, A_INT32 len);
+A_STATUS a_netbuf_trim_data(void *bufPtr, char *dstPtr, A_INT32 len);
+A_STATUS a_netbuf_setlen(void *bufPtr, A_INT32 len);
+A_INT32 a_netbuf_headroom(void *bufPtr);
+void a_netbuf_enqueue(A_NETBUF_QUEUE_T *q, void *pkt);
+void a_netbuf_prequeue(A_NETBUF_QUEUE_T *q, void *pkt);
+void *a_netbuf_dequeue(A_NETBUF_QUEUE_T *q);
+int a_netbuf_queue_size(A_NETBUF_QUEUE_T *q);
+int a_netbuf_queue_empty(A_NETBUF_QUEUE_T *q);
+int a_netbuf_queue_empty(A_NETBUF_QUEUE_T *q);
+void a_netbuf_queue_init(A_NETBUF_QUEUE_T *q);
+
+/*
+ * Kernel v.s User space functions
+ */
+A_UINT32 a_copy_to_user(void *to, const void *from, A_UINT32 n);
+A_UINT32 a_copy_from_user(void *to, const void *from, A_UINT32 n);
+
+#else /* __KERNEL__ */
+
+#ifdef __GNUC__
+#define __ATTRIB_PACK           __attribute__ ((packed))
+#define __ATTRIB_PRINTF         __attribute__ ((format (printf, 1, 2)))
+#define __ATTRIB_NORETURN       __attribute__ ((noreturn))
+#ifndef INLINE
+#define INLINE                  __inline__
+#endif
+#else /* Not GCC */
+#define __ATTRIB_PACK
+#define __ATTRIB_PRINTF
+#define __ATTRIB_NORETURN
+#ifndef INLINE
+#define INLINE                  __inline
+#endif
+#endif /* End __GNUC__ */
+
+#define PREPACK
+#define POSTPACK                __ATTRIB_PACK
+
+#endif /* __KERNEL__ */
+
+#endif /* _OSAPI_LINUX_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/wireless_ext.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/wireless_ext.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/ar6000/wireless_ext.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/ar6000/wireless_ext.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1979 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "ar6000_drv.h"
+
+static A_UINT8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+static void ar6000_set_quality(struct iw_quality *iq, A_INT8 rssi);
+extern unsigned int wmitimeout;
+extern A_WAITQUEUE_HEAD arEvent;
+extern wait_queue_head_t ar6000_scan_queue;
+
+/*
+ * Encode a WPA or RSN information element as a custom
+ * element using the hostap format.
+ */
+static u_int
+encode_ie(void *buf, size_t bufsize,
+    const u_int8_t *ie, size_t ielen,
+    const char *leader, size_t leader_len)
+{
+    u_int8_t *p;
+    int i;
+
+    if (bufsize < leader_len)
+        return 0;
+    p = buf;
+    memcpy(p, leader, leader_len);
+    bufsize -= leader_len;
+    p += leader_len;
+    for (i = 0; i < ielen && bufsize > 2; i++)
+        p += sprintf(p, "%02x", ie[i]);
+    return (i == ielen ? p - (u_int8_t *)buf : 0);
+}
+
+void
+ar6000_scan_node(void *arg, bss_t *ni)
+{
+    struct iw_event iwe;
+#if WIRELESS_EXT > 14
+    char buf[64*2 + 30];
+#endif
+    struct ar_giwscan_param *param;
+    A_CHAR *current_ev;
+    A_CHAR *end_buf;
+    struct ieee80211_common_ie  *cie;
+	struct iw_request_info info;
+
+	info.cmd = 0;
+	info.flags = 0;
+
+    param = (struct ar_giwscan_param *)arg;
+
+    if (param->current_ev >= param->end_buf) {
+        return;
+    }
+    if ((param->firstPass == TRUE) &&
+        ((ni->ni_cie.ie_wpa == NULL) && (ni->ni_cie.ie_rsn == NULL))) {
+        /*
+         * Only forward wpa bss's in first pass
+         */
+        return;
+    }
+
+     if ((param->firstPass == FALSE) &&
+        ((ni->ni_cie.ie_wpa != NULL) || (ni->ni_cie.ie_rsn != NULL))) {
+        /*
+         * Only forward non-wpa bss's in 2nd pass
+         */
+        return;
+    }
+
+    current_ev = param->current_ev;
+    end_buf = param->end_buf;
+
+    cie = &ni->ni_cie;
+
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = SIOCGIWAP;
+    iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+    A_MEMCPY(iwe.u.ap_addr.sa_data, ni->ni_macaddr, 6);
+    current_ev = iwe_stream_add_event(&info, current_ev, end_buf, &iwe,
+                                      IW_EV_ADDR_LEN);
+
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = SIOCGIWESSID;
+    iwe.u.data.flags = 1;
+    iwe.u.data.length = cie->ie_ssid[1];
+    current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe,
+                                      &cie->ie_ssid[2]);
+
+    if (cie->ie_capInfo & (IEEE80211_CAPINFO_ESS|IEEE80211_CAPINFO_IBSS)) {
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = SIOCGIWMODE;
+        iwe.u.mode = cie->ie_capInfo & IEEE80211_CAPINFO_ESS ?
+                IW_MODE_MASTER : IW_MODE_ADHOC;
+        current_ev = iwe_stream_add_event(&info, current_ev, end_buf, &iwe,
+                                          IW_EV_UINT_LEN);
+    }
+
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = SIOCGIWFREQ;
+    iwe.u.freq.m = cie->ie_chan * 100000;
+    iwe.u.freq.e = 1;
+    current_ev = iwe_stream_add_event(&info, current_ev, end_buf, &iwe,
+                                      IW_EV_FREQ_LEN);
+
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = IWEVQUAL;
+    ar6000_set_quality(&iwe.u.qual, ni->ni_snr);
+    current_ev = iwe_stream_add_event(&info, current_ev, end_buf, &iwe,
+                                      IW_EV_QUAL_LEN);
+
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = SIOCGIWENCODE;
+    if (cie->ie_capInfo & IEEE80211_CAPINFO_PRIVACY) {
+        iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+    } else {
+        iwe.u.data.flags = IW_ENCODE_DISABLED;
+    }
+    iwe.u.data.length = 0;
+    current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe, "");
+
+    A_MEMZERO(&iwe, sizeof(iwe));
+    iwe.cmd = IWEVCUSTOM;
+    snprintf(buf, sizeof(buf), "bcn_int=%d", cie->ie_beaconInt);
+    iwe.u.data.length = strlen(buf);
+    current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe, buf);
+
+    if (cie->ie_wpa != NULL) {
+        static const char wpa_leader[] = "wpa_ie=";
+
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = IWEVCUSTOM;
+        iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_wpa,
+                                      cie->ie_wpa[1]+2,
+                                      wpa_leader, sizeof(wpa_leader)-1);
+
+        if (iwe.u.data.length != 0) {
+            current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe,
+									   buf);
+        }
+    }
+
+    if (cie->ie_rsn != NULL && cie->ie_rsn[0] == IEEE80211_ELEMID_RSN) {
+        static const char rsn_leader[] = "rsn_ie=";
+
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = IWEVCUSTOM;
+        iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_rsn,
+                                      cie->ie_rsn[1]+2,
+                                      rsn_leader, sizeof(rsn_leader)-1);
+
+        if (iwe.u.data.length != 0) {
+            current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe,
+									   buf);
+        }
+    }
+
+    if (cie->ie_wmm != NULL) {
+        static const char wmm_leader[] = "wmm_ie=";
+
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = IWEVCUSTOM;
+        iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_wmm,
+                                      cie->ie_wmm[1]+2,
+                                      wmm_leader, sizeof(wmm_leader)-1);
+        if (iwe.u.data.length != 0) {
+            current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe,
+									   buf);
+        }
+    }
+
+    if (cie->ie_ath != NULL) {
+        static const char ath_leader[] = "ath_ie=";
+
+        A_MEMZERO(&iwe, sizeof(iwe));
+        iwe.cmd = IWEVCUSTOM;
+        iwe.u.data.length = encode_ie(buf, sizeof(buf), cie->ie_ath,
+                                      cie->ie_ath[1]+2,
+                                      ath_leader, sizeof(ath_leader)-1);
+        if (iwe.u.data.length != 0) {
+            current_ev = iwe_stream_add_point(&info, current_ev, end_buf, &iwe,
+									   buf);
+        }
+    }
+
+    param->current_ev = current_ev;
+}
+
+int
+ar6000_ioctl_giwscan(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_point *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct ar_giwscan_param param;
+    int i;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    param.current_ev = extra;
+    param.end_buf = extra + IW_SCAN_MAX_DATA;
+    param.firstPass = TRUE;
+
+    /*
+     * Do two passes to insure WPA scan candidates
+     * are sorted to the front.  This is a hack to deal with
+     * the wireless extensions capping scan results at
+     * IW_SCAN_MAX_DATA bytes.  In densely populated environments
+     * it's easy to overflow this buffer (especially with WPA/RSN
+     * information elements).  Note this sorting hack does not
+     * guarantee we won't overflow anyway.
+     */
+    for (i = 0; i < 2; i++) {
+        /*
+         * Translate data to WE format.
+         */
+        wmi_iterate_nodes(ar->arWmi, ar6000_scan_node, &param);
+        param.firstPass = FALSE;
+        if (param.current_ev >= param.end_buf) {
+            data->length = param.current_ev - extra;
+            return -E2BIG;
+        }
+    }
+
+    data->length = param.current_ev - extra;
+    return 0;
+}
+
+extern int reconnect_flag;
+/* SIOCSIWESSID */
+static int
+ar6000_ioctl_siwessid(struct net_device *dev,
+                     struct iw_request_info *info,
+                     struct iw_point *data, char *ssid)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_STATUS status;
+    A_UINT8     arNetworkType;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    /*
+     * iwconfig passes a string with length excluding any trailing NUL.
+     * FIXME: we should be able to set an ESSID of 32 bytes, yet things fall
+     * over badly if we do. So we limit the ESSID to 31 bytes.
+     */
+    if (data->flags && (!data->length || data->length >= sizeof(ar->arSsid))) {
+        /*
+         * ssid is invalid
+         */
+        return -EINVAL;
+    }
+    /* Added for bug 25178, return an IOCTL error instead of target returning
+       Illegal parameter error when either the BSSID or channel is missing
+       and we cannot scan during connect.
+     */
+    if (data->flags) {
+        if (ar->arSkipScan == TRUE &&
+            (ar->arChannelHint == 0 ||
+             (!ar->arReqBssid[0] && !ar->arReqBssid[1] && !ar->arReqBssid[2] &&
+              !ar->arReqBssid[3] && !ar->arReqBssid[4] && !ar->arReqBssid[5])))
+        {
+            return -EINVAL;
+        }
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+
+    if (ar->arTxPending[WMI_CONTROL_PRI]) {
+        /*
+         * sleep until the command queue drains
+         */
+        wait_event_interruptible_timeout(arEvent,
+            ar->arTxPending[WMI_CONTROL_PRI] == 0, wmitimeout * HZ);
+        if (signal_pending(current)) {
+            return -EINTR;
+        }
+    }
+
+    if (!data->flags) {
+        arNetworkType = ar->arNetworkType;
+        ar6000_init_profile_info(ar);
+        ar->arNetworkType = arNetworkType;
+    }
+
+    /*
+     * The original logic here prevented a disconnect if issuing an "essid off"
+     * if no ESSID was set, presumably to prevent sending multiple disconnects
+     * to the WMI.
+     *
+     * Unfortunately, this also meant that no disconnect was sent when we were
+     * already connected, but the profile has been changed since (which also
+     * clears the ESSID as a reminder that the WMI needs updating.)
+     *
+     * The "1 ||" makes sure we always disconnect or reconnect. The WMI doesn't
+     * seem to mind being sent multiple disconnects.
+     */
+    if (1 || (ar->arSsidLen) || (!data->flags))
+    {
+        if ((!data->flags) ||
+            (A_MEMCMP(ar->arSsid, ssid, ar->arSsidLen) != 0) ||
+            (ar->arSsidLen != (data->length)))
+        {
+            /*
+             * SSID set previously or essid off has been issued.
+             *
+             * Disconnect Command is issued in two cases after wmi is ready
+             * (1) ssid is different from the previous setting
+             * (2) essid off has been issued
+             *
+             */
+            if (ar->arWmiReady == TRUE) {
+                reconnect_flag = 0;
+                status = wmi_disconnect_cmd(ar->arWmi);
+                A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+                ar->arSsidLen = 0;
+                if (ar->arSkipScan == FALSE) {
+                    A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));
+                }
+                if (!data->flags) {
+                    up(&ar->arSem);
+                    return 0;
+                }
+            } else {
+                 up(&ar->arSem);
+            }
+        }
+        else
+        {
+            /*
+             * SSID is same, so we assume profile hasn't changed.
+             * If the interface is up and wmi is ready, we issue
+             * a reconnect cmd. Issue a reconnect only we are already
+             * connected.
+             */
+            if((ar->arConnected == TRUE) && (ar->arWmiReady == TRUE))
+            {
+                reconnect_flag = TRUE;
+                status = wmi_reconnect_cmd(ar->arWmi,ar->arReqBssid,
+                                           ar->arChannelHint);
+                up(&ar->arSem);
+                if (status != A_OK) {
+                    return -EIO;
+                }
+                return 0;
+            }
+            else{
+                /*
+                 * Dont return if connect is pending.
+                 */
+                if(!(ar->arConnectPending)) {
+                    up(&ar->arSem);
+                    return 0;
+                }
+            }
+        }
+    }
+
+    ar->arSsidLen = data->length;
+    A_MEMCPY(ar->arSsid, ssid, ar->arSsidLen);
+
+    /* The ssid length check prevents second "essid off" from the user,
+       to be treated as a connect cmd. The second "essid off" is ignored.
+    */
+    if((ar->arWmiReady == TRUE) && (ar->arSsidLen > 0) )
+    {
+        AR6000_SPIN_LOCK(&ar->arLock, 0);
+        if (SHARED_AUTH == ar->arDot11AuthMode) {
+            ar6000_install_static_wep_keys(ar);
+        }
+        AR_DEBUG_PRINTF("Connect called with authmode %d dot11 auth %d"\
+                        " PW crypto %d PW crypto Len %d GRP crypto %d"\
+                        " GRP crypto Len %d\n",
+                        ar->arAuthMode, ar->arDot11AuthMode,
+                        ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,
+                        ar->arGroupCrypto, ar->arGroupCryptoLen);
+        reconnect_flag = 0;
+        AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+        status = wmi_connect_cmd(ar->arWmi, ar->arNetworkType,
+                                 ar->arDot11AuthMode, ar->arAuthMode,
+                                 ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,
+                                 ar->arGroupCrypto,ar->arGroupCryptoLen,
+                                 ar->arSsidLen, ar->arSsid,
+                                 ar->arReqBssid, ar->arChannelHint,
+                                 ar->arConnectCtrlFlags);
+
+
+        up(&ar->arSem);
+
+        if (status != A_OK) {
+            return -EIO;
+        }
+        ar->arConnectPending = TRUE;
+    }else{
+      up(&ar->arSem);
+    }
+    return 0;
+}
+
+/* SIOCGIWESSID */
+static int
+ar6000_ioctl_giwessid(struct net_device *dev,
+                     struct iw_request_info *info,
+                     struct iw_point *data, char *essid)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    data->flags = 1;
+    data->length = ar->arSsidLen;
+    A_MEMCPY(essid, ar->arSsid, ar->arSsidLen);
+
+    return 0;
+}
+
+
+void ar6000_install_static_wep_keys(AR_SOFTC_T *ar)
+{
+    A_UINT8 index;
+    A_UINT8 keyUsage;
+
+    for (index = WMI_MIN_KEY_INDEX; index <= WMI_MAX_KEY_INDEX; index++) {
+        if (ar->arWepKeyList[index].arKeyLen) {
+            keyUsage = GROUP_USAGE;
+            if (index == ar->arDefTxKeyIndex) {
+                keyUsage |= TX_USAGE;
+            }
+            wmi_addKey_cmd(ar->arWmi,
+                           index,
+                           WEP_CRYPT,
+                           keyUsage,
+                           ar->arWepKeyList[index].arKeyLen,
+                           NULL,
+                           ar->arWepKeyList[index].arKey, KEY_OP_INIT_VAL,
+                           NO_SYNC_WMIFLAG);
+        }
+    }
+}
+
+int
+ar6000_ioctl_delkey(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    return 0;
+}
+
+int
+ar6000_ioctl_setmlme(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct ieee80211req_mlme *mlme = (struct ieee80211req_mlme *)extra;
+
+    if ((ar->arWmiReady == FALSE) || (ar->arConnected != TRUE))
+		return -EIO;
+
+    switch (mlme->im_op) {
+        case IEEE80211_MLME_DISASSOC:
+        case IEEE80211_MLME_DEAUTH:
+            /* Not Supported */
+            break;
+        default:
+            break;
+    }
+    return 0;
+}
+
+
+int
+ar6000_ioctl_setwmmparams(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+int
+ar6000_ioctl_getwmmparams(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+int ar6000_ioctl_setoptie(struct net_device *dev, struct iw_request_info *info,
+			  struct iw_point *data, char *extra)
+{
+	/* The target generates the WPA/RSN IE */
+	return 0;
+}
+
+int
+ar6000_ioctl_setauthalg(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct ieee80211req_authalg *req = (struct ieee80211req_authalg *)extra;
+    int ret = 0;
+
+
+    AR6000_SPIN_LOCK(&ar->arLock, 0);
+
+    if (req->auth_alg == AUTH_ALG_OPEN_SYSTEM) {
+        ar->arDot11AuthMode  = OPEN_AUTH;
+    } else if (req->auth_alg == AUTH_ALG_LEAP) {
+        ar->arDot11AuthMode   = LEAP_AUTH;
+        ar->arPairwiseCrypto  = WEP_CRYPT;
+        ar->arGroupCrypto     = WEP_CRYPT;
+    } else {
+        ret = -EIO;
+    }
+
+    AR6000_SPIN_UNLOCK(&ar->arLock, 0);
+
+    return ret;
+}
+static int
+ar6000_ioctl_addpmkid(struct net_device *dev, struct iw_request_info *info,
+             void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct ieee80211req_addpmkid  *req = (struct ieee80211req_addpmkid *)extra;
+    A_STATUS status;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    AR_DEBUG_PRINTF("Add pmkid for %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x en=%d\n",
+                    req->pi_bssid[0], req->pi_bssid[1], req->pi_bssid[2],
+                    req->pi_bssid[3], req->pi_bssid[4], req->pi_bssid[5],
+                    req->pi_enable);
+
+    status = wmi_setPmkid_cmd(ar->arWmi, req->pi_bssid, req->pi_pmkid,
+                              req->pi_enable);
+
+    if (status != A_OK) {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCSIWRATE
+ */
+int
+ar6000_ioctl_siwrate(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_UINT32  kbps;
+
+    if (rrq->fixed) {
+        kbps = rrq->value / 1000;           /* rrq->value is in bps */
+    } else {
+        kbps = -1;                          /* -1 indicates auto rate */
+    }
+    if(kbps != -1 && wmi_validate_bitrate(ar->arWmi, kbps) == A_EINVAL)
+    {
+        AR_DEBUG_PRINTF("BitRate is not Valid %d\n", kbps);
+        return -EINVAL;
+    }
+    ar->arBitRate = kbps;
+    if(ar->arWmiReady == TRUE)
+    {
+        if (wmi_set_bitrate_cmd(ar->arWmi, kbps) != A_OK) {
+            return -EINVAL;
+        }
+    }
+    return 0;
+}
+
+/*
+ * SIOCGIWRATE
+ */
+int
+ar6000_ioctl_giwrate(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    int ret = 0;
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    if(ar->arWmiReady == TRUE)
+    {
+        ar->arBitRate = 0xFFFF;
+        if (wmi_get_bitrate_cmd(ar->arWmi) != A_OK) {
+            up(&ar->arSem);
+            return -EIO;
+        }
+        wait_event_interruptible_timeout(arEvent, ar->arBitRate != 0xFFFF, wmitimeout * HZ);
+        if (signal_pending(current)) {
+            ret = -EINTR;
+        }
+    }
+    /* If the interface is down or wmi is not ready or the target is not
+       connected - return the value stored in the device structure */
+    if (!ret) {
+        if (ar->arBitRate == -1) {
+            rrq->fixed = TRUE;
+            rrq->value = 0;
+        } else {
+            rrq->value = ar->arBitRate * 1000;
+        }
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+/*
+ * SIOCSIWTXPOW
+ */
+static int
+ar6000_ioctl_siwtxpow(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_UINT8 dbM;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arRadioSwitch == WLAN_ENABLED
+	&& rrq->disabled) {
+	    if (wmi_switch_radio(ar->arWmi, WLAN_DISABLED) < 0)
+		    return -EIO;
+	    ar->arRadioSwitch = WLAN_DISABLED;
+    } else if (ar->arRadioSwitch == WLAN_DISABLED
+	       && !rrq->disabled) {
+	    if (wmi_switch_radio(ar->arWmi, WLAN_ENABLED) < 0)
+		    return -EIO;
+	    ar->arRadioSwitch = WLAN_ENABLED;
+    }
+
+    if (rrq->fixed) {
+        if (rrq->flags != IW_TXPOW_DBM) {
+            return -EOPNOTSUPP;
+        }
+        ar->arTxPwr= dbM = rrq->value;
+        ar->arTxPwrSet = TRUE;
+    } else {
+        ar->arTxPwr = dbM = 0;
+        ar->arTxPwrSet = FALSE;
+    }
+    if(ar->arWmiReady == TRUE)
+    {
+        AR_DEBUG_PRINTF("Set tx pwr cmd %d dbM\n", dbM);
+        wmi_set_txPwr_cmd(ar->arWmi, dbM);
+    }
+    return 0;
+}
+
+/*
+ * SIOCGIWTXPOW
+ */
+int
+ar6000_ioctl_giwtxpow(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    int ret = 0;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arRadioSwitch == WLAN_DISABLED) {
+	    rrq->disabled = 1;
+	    return 0;
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    if((ar->arWmiReady == TRUE) && (ar->arConnected == TRUE))
+    {
+        ar->arTxPwr = 0;
+
+        if (wmi_get_txPwr_cmd(ar->arWmi) != A_OK) {
+            up(&ar->arSem);
+            return -EIO;
+        }
+
+        wait_event_interruptible_timeout(arEvent, ar->arTxPwr != 0, wmitimeout * HZ);
+
+        if (signal_pending(current)) {
+            ret = -EINTR;
+         }
+    }
+   /* If the interace is down or wmi is not ready or target is not connected
+      then return value stored in the device structure */
+
+    if (!ret) {
+         if (ar->arTxPwrSet == TRUE) {
+            rrq->fixed = TRUE;
+        }
+        rrq->value = ar->arTxPwr;
+        rrq->flags = IW_TXPOW_DBM;
+    }
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+/*
+ * SIOCSIWRETRY
+ * since iwconfig only provides us with one max retry value, we use it
+ * to apply to data frames of the BE traffic class.
+ */
+static int
+ar6000_ioctl_siwretry(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (rrq->disabled) {
+        return -EOPNOTSUPP;
+    }
+
+    if ((rrq->flags & IW_RETRY_TYPE) != IW_RETRY_LIMIT) {
+        return -EOPNOTSUPP;
+    }
+
+    if ( !(rrq->value >= WMI_MIN_RETRIES) || !(rrq->value <= WMI_MAX_RETRIES)) {
+            return - EINVAL;
+    }
+    if(ar->arWmiReady == TRUE)
+    {
+        if (wmi_set_retry_limits_cmd(ar->arWmi, DATA_FRAMETYPE, WMM_AC_BE,
+                                     rrq->value, 0) != A_OK){
+            return -EINVAL;
+        }
+    }
+    ar->arMaxRetries = rrq->value;
+    return 0;
+}
+
+/*
+ * SIOCGIWRETRY
+ */
+static int
+ar6000_ioctl_giwretry(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_param *rrq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    rrq->disabled = 0;
+    switch (rrq->flags & IW_RETRY_TYPE) {
+    case IW_RETRY_LIFETIME:
+        return -EOPNOTSUPP;
+        break;
+    case IW_RETRY_LIMIT:
+        rrq->flags = IW_RETRY_LIMIT;
+        switch (rrq->flags & IW_RETRY_MODIFIER) {
+        case IW_RETRY_MIN:
+            rrq->flags |= IW_RETRY_MIN;
+            rrq->value = WMI_MIN_RETRIES;
+            break;
+        case IW_RETRY_MAX:
+            rrq->flags |= IW_RETRY_MAX;
+            rrq->value = ar->arMaxRetries;
+            break;
+        }
+        break;
+    }
+    return 0;
+}
+
+/*
+ * SIOCSIWENCODE
+ */
+static int
+ar6000_ioctl_siwencode(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *keybuf)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    int index;
+    A_INT32 auth = ar->arDot11AuthMode;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    index = erq->flags & IW_ENCODE_INDEX;
+
+    if (index && (((index - 1) < WMI_MIN_KEY_INDEX) ||
+                  ((index - 1) > WMI_MAX_KEY_INDEX)))
+    {
+        return -EIO;
+    }
+
+    if (erq->flags & IW_ENCODE_DISABLED) {
+        /*
+         * Encryption disabled
+         */
+        if (index) {
+            /*
+             * If key index was specified then clear the specified key
+             */
+            index--;
+            A_MEMZERO(ar->arWepKeyList[index].arKey,
+                      sizeof(ar->arWepKeyList[index].arKey));
+            ar->arWepKeyList[index].arKeyLen = 0;
+        }
+        ar->arDot11AuthMode       = OPEN_AUTH;
+        ar->arPairwiseCrypto      = NONE_CRYPT;
+        ar->arGroupCrypto         = NONE_CRYPT;
+        ar->arAuthMode            = NONE_AUTH;
+    } else {
+        /*
+         * Enabling WEP encryption
+         */
+        if (index) {
+            index--;                /* keyindex is off base 1 in iwconfig */
+        }
+
+        if (erq->flags & IW_ENCODE_OPEN) {
+            auth = OPEN_AUTH;
+        } else if (erq->flags & IW_ENCODE_RESTRICTED) {
+            auth = SHARED_AUTH;
+        }
+
+        if (erq->length) {
+            if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(erq->length)) {
+                return -EIO;
+            }
+
+            A_MEMZERO(ar->arWepKeyList[index].arKey,
+                      sizeof(ar->arWepKeyList[index].arKey));
+            A_MEMCPY(ar->arWepKeyList[index].arKey, keybuf, erq->length);
+            ar->arWepKeyList[index].arKeyLen = erq->length;
+        } else {
+            if (ar->arWepKeyList[index].arKeyLen == 0) {
+                return -EIO;
+            }
+            ar->arDefTxKeyIndex = index;
+        }
+
+        ar->arPairwiseCrypto      = WEP_CRYPT;
+        ar->arGroupCrypto         = WEP_CRYPT;
+        ar->arDot11AuthMode       = auth;
+        ar->arAuthMode            = NONE_AUTH;
+    }
+
+    /*
+     * profile has changed.  Erase ssid to signal change
+     */
+    A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+    ar->arSsidLen = 0;
+
+    return 0;
+}
+
+static int
+ar6000_ioctl_giwencode(struct net_device *dev,
+              struct iw_request_info *info,
+              struct iw_point *erq, char *key)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    A_UINT8 keyIndex;
+    struct ar_wep_key *wk;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arPairwiseCrypto == NONE_CRYPT) {
+        erq->length = 0;
+        erq->flags = IW_ENCODE_DISABLED;
+    } else {
+        /* get the keyIndex */
+        keyIndex = erq->flags & IW_ENCODE_INDEX;
+        if (0 == keyIndex) {
+            keyIndex = ar->arDefTxKeyIndex;
+        } else if ((keyIndex - 1 < WMI_MIN_KEY_INDEX) ||
+                   (keyIndex - 1 > WMI_MAX_KEY_INDEX))
+        {
+            keyIndex = WMI_MIN_KEY_INDEX;
+        } else {
+            keyIndex--;
+        }
+        erq->flags = keyIndex + 1;
+        erq->flags |= IW_ENCODE_ENABLED;
+        wk = &ar->arWepKeyList[keyIndex];
+        if (erq->length > wk->arKeyLen) {
+            erq->length = wk->arKeyLen;
+        }
+        if (wk->arKeyLen) {
+            A_MEMCPY(key, wk->arKey, erq->length);
+        }
+        if (ar->arDot11AuthMode == OPEN_AUTH) {
+            erq->flags |= IW_ENCODE_OPEN;
+        } else if (ar->arDot11AuthMode == SHARED_AUTH) {
+            erq->flags |= IW_ENCODE_RESTRICTED;
+        }
+    }
+
+    return 0;
+}
+
+static int ar6000_ioctl_siwpower(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+	WMI_POWER_MODE power_mode;
+
+	if (wrqu->power.disabled)
+		power_mode = MAX_PERF_POWER;
+	else
+		power_mode = REC_POWER;
+
+	if (wmi_powermode_cmd(ar->arWmi, power_mode) < 0)
+		return -EIO;
+
+	return 0;
+}
+
+static int ar6000_ioctl_giwpower(struct net_device *dev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu, char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+	/*
+	 * FIXME:
+	 * https://docs.openmoko.org/trac/ticket/2267
+	 * When starting wpa_supplicant the kernel oopses.
+	 * The following condition avoids the oops.
+	 * Remove this comment to bless this solution.
+	 */
+	if (ar->arWlanState == WLAN_DISABLED || ar->arWmiReady == FALSE)
+		return -EIO;
+
+	return wmi_get_power_mode_cmd(ar->arWmi);
+}
+
+static int ar6000_ioctl_siwgenie(struct net_device *dev,
+				 struct iw_request_info *info,
+				 struct iw_point *dwrq,
+				 char *extra)
+{
+	/* The target does that for us */
+	return 0;
+}
+
+static int ar6000_ioctl_giwgenie(struct net_device *dev,
+				 struct iw_request_info *info,
+				 struct iw_point *dwrq,
+				 char *extra)
+{
+	return 0;
+}
+
+static int ar6000_ioctl_siwauth(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_param *param,
+				char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+	int reset = 0;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+		if (param->value & IW_AUTH_WPA_VERSION_DISABLED) {
+			ar->arAuthMode = NONE_AUTH;
+		}
+		if (param->value & IW_AUTH_WPA_VERSION_WPA) {
+			ar->arAuthMode = WPA_AUTH;
+		}
+		if (param->value & IW_AUTH_WPA_VERSION_WPA2) {
+			ar->arAuthMode = WPA2_AUTH;
+		}
+
+		reset = 1;
+		break;
+	case IW_AUTH_CIPHER_PAIRWISE:
+		if (param->value & IW_AUTH_CIPHER_NONE) {
+			ar->arPairwiseCrypto = NONE_CRYPT;
+		}
+		if (param->value & IW_AUTH_CIPHER_WEP40) {
+			ar->arPairwiseCrypto = WEP_CRYPT;
+		}
+		if (param->value & IW_AUTH_CIPHER_TKIP) {
+			ar->arPairwiseCrypto = TKIP_CRYPT;
+		}
+		if (param->value & IW_AUTH_CIPHER_CCMP) {
+			ar->arPairwiseCrypto = AES_CRYPT;
+		}
+
+		reset = 1;
+		break;
+	case IW_AUTH_CIPHER_GROUP:
+		if (param->value & IW_AUTH_CIPHER_NONE) {
+			ar->arGroupCrypto = NONE_CRYPT;
+		}
+		if (param->value & IW_AUTH_CIPHER_WEP40) {
+			ar->arGroupCrypto = WEP_CRYPT;
+		}
+		if (param->value & IW_AUTH_CIPHER_TKIP) {
+			ar->arGroupCrypto = TKIP_CRYPT;
+		}
+		if (param->value & IW_AUTH_CIPHER_CCMP) {
+			ar->arGroupCrypto = AES_CRYPT;
+		}
+
+		reset = 1;
+		break;
+	case IW_AUTH_KEY_MGMT:
+		if (param->value & IW_AUTH_KEY_MGMT_PSK) {
+			if (ar->arAuthMode == WPA_AUTH) {
+				ar->arAuthMode = WPA_PSK_AUTH;
+			} else if (ar->arAuthMode == WPA2_AUTH) {
+				ar->arAuthMode = WPA2_PSK_AUTH;
+			}
+
+			reset = 1;
+		}
+		break;
+
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		if (ar->arWmiReady == FALSE) {
+			return -EIO;
+		}
+		wmi_set_tkip_countermeasures_cmd(ar->arWmi, param->value);
+		break;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			ar->arDot11AuthMode  = OPEN_AUTH;
+		}
+		if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+			ar->arDot11AuthMode  = SHARED_AUTH;
+		}
+		if (param->value & IW_AUTH_ALG_LEAP) {
+			ar->arDot11AuthMode   = LEAP_AUTH;
+			ar->arPairwiseCrypto  = WEP_CRYPT;
+			ar->arGroupCrypto     = WEP_CRYPT;
+		}
+
+		reset = 1;
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		reset = 1;
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		break;
+
+	default:
+		printk("%s(): Unknown flag 0x%x\n", __FUNCTION__, param->flags);
+		return -EOPNOTSUPP;
+	}
+
+	if (reset) {
+		A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+		ar->arSsidLen = 0;
+	}
+
+	return 0;
+}
+
+static int ar6000_ioctl_giwauth(struct net_device *dev,
+				struct iw_request_info *info,
+				struct iw_param *dwrq,
+				char *extra)
+{
+	return 0;
+}
+
+static int ar6000_ioctl_siwencodeext(struct net_device *dev,
+				     struct iw_request_info *info,
+				     union iwreq_data *wrqu,
+				     char *extra)
+{
+	AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int alg = ext->alg, idx;
+
+	if (ar->arWlanState == WLAN_DISABLED) {
+		return -EIO;
+	}
+
+	/* Determine and validate the key index */
+	idx = (encoding->flags & IW_ENCODE_INDEX) - 1;
+	if (idx) {
+		if (idx < 0 || idx > 3)
+			return -EINVAL;
+	}
+
+	if ((alg == IW_ENCODE_ALG_TKIP) || (alg == IW_ENCODE_ALG_CCMP)) {
+		struct ieee80211req_key ik;
+		KEY_USAGE key_usage;
+		CRYPTO_TYPE key_type = NONE_CRYPT;
+		int status;
+
+		ar->user_saved_keys.keyOk = FALSE;
+
+		if (alg == IW_ENCODE_ALG_TKIP) {
+			key_type = TKIP_CRYPT;
+			ik.ik_type = IEEE80211_CIPHER_TKIP;
+		} else {
+			key_type = AES_CRYPT;
+			ik.ik_type = IEEE80211_CIPHER_AES_CCM;
+		}
+
+		ik.ik_keyix = idx;
+		ik.ik_keylen = ext->key_len;
+		ik.ik_flags = IEEE80211_KEY_RECV;
+		if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+			ik.ik_flags |= IEEE80211_KEY_XMIT
+				| IEEE80211_KEY_DEFAULT;
+		}
+
+		if (ext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID) {
+			memcpy(&ik.ik_keyrsc, ext->rx_seq, 8);
+		}
+
+		memcpy(ik.ik_keydata, ext->key, ext->key_len);
+
+		ar->user_saved_keys.keyType = key_type;
+		if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+			key_usage = GROUP_USAGE;
+			memset(ik.ik_macaddr, 0, ETH_ALEN);
+			memcpy(&ar->user_saved_keys.bcast_ik, &ik,
+			       sizeof(struct ieee80211req_key));
+		} else {
+			key_usage = PAIRWISE_USAGE;
+			memcpy(ik.ik_macaddr, ext->addr.sa_data, ETH_ALEN);
+			memcpy(&ar->user_saved_keys.ucast_ik, &ik,
+			       sizeof(struct ieee80211req_key));
+		}
+
+		status = wmi_addKey_cmd(ar->arWmi, ik.ik_keyix, key_type,
+					key_usage, ik.ik_keylen,
+					(A_UINT8 *)&ik.ik_keyrsc,
+					ik.ik_keydata,
+					KEY_OP_INIT_VAL, SYNC_BEFORE_WMIFLAG);
+
+		if (status < 0)
+			return -EIO;
+
+		ar->user_saved_keys.keyOk = TRUE;
+
+		return 0;
+
+	} else {
+		/* WEP falls back to SIWENCODE */
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+
+static int ar6000_ioctl_giwencodeext(struct net_device *dev,
+				     struct iw_request_info *info,
+				     struct iw_point *dwrq,
+				     char *extra)
+{
+	return 0;
+}
+
+
+static int
+ar6000_ioctl_setparam(struct net_device *dev,
+                      struct iw_request_info *info,
+                      void *erq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    int *i = (int *)extra;
+    int param = i[0];
+    int value = i[1];
+    int ret = 0;
+    A_BOOL profChanged = FALSE;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (param) {
+        case IEEE80211_PARAM_WPA:
+            switch (value) {
+                case WPA_MODE_WPA1:
+                    ar->arAuthMode = WPA_AUTH;
+                    profChanged    = TRUE;
+                    break;
+                case WPA_MODE_WPA2:
+                    ar->arAuthMode = WPA2_AUTH;
+                    profChanged    = TRUE;
+                    break;
+                case WPA_MODE_NONE:
+                    ar->arAuthMode = NONE_AUTH;
+                    profChanged    = TRUE;
+                    break;
+	    default:
+		    printk("IEEE80211_PARAM_WPA: Unknown value %d\n", value);
+            }
+            break;
+        case IEEE80211_PARAM_AUTHMODE:
+            switch(value) {
+                case IEEE80211_AUTH_WPA_PSK:
+                    if (WPA_AUTH == ar->arAuthMode) {
+                        ar->arAuthMode = WPA_PSK_AUTH;
+                        profChanged    = TRUE;
+                    } else if (WPA2_AUTH == ar->arAuthMode) {
+                        ar->arAuthMode = WPA2_PSK_AUTH;
+                        profChanged    = TRUE;
+                    } else {
+                        AR_DEBUG_PRINTF("Error -  Setting PSK mode when WPA "\
+                                        "param was set to %d\n",
+                                        ar->arAuthMode);
+                        ret = -1;
+                    }
+                    break;
+                case IEEE80211_AUTH_WPA_CCKM:
+                    if (WPA2_AUTH == ar->arAuthMode) {
+                        ar->arAuthMode = WPA2_AUTH_CCKM;
+                    } else {
+                        ar->arAuthMode = WPA_AUTH_CCKM;
+                    }
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_UCASTCIPHER:
+            switch (value) {
+                case IEEE80211_CIPHER_AES_CCM:
+                    ar->arPairwiseCrypto = AES_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+                case IEEE80211_CIPHER_TKIP:
+                    ar->arPairwiseCrypto = TKIP_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+                case IEEE80211_CIPHER_WEP:
+                    ar->arPairwiseCrypto = WEP_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+                case IEEE80211_CIPHER_NONE:
+                    ar->arPairwiseCrypto = NONE_CRYPT;
+                    profChanged          = TRUE;
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_UCASTKEYLEN:
+            if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(value)) {
+                ret = -EIO;
+            } else {
+                ar->arPairwiseCryptoLen = value;
+            }
+            break;
+        case IEEE80211_PARAM_MCASTCIPHER:
+            switch (value) {
+                case IEEE80211_CIPHER_AES_CCM:
+                    ar->arGroupCrypto = AES_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+                case IEEE80211_CIPHER_TKIP:
+                    ar->arGroupCrypto = TKIP_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+                case IEEE80211_CIPHER_WEP:
+                    ar->arGroupCrypto = WEP_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+                case IEEE80211_CIPHER_NONE:
+                    ar->arGroupCrypto = NONE_CRYPT;
+                    profChanged       = TRUE;
+                    break;
+            }
+            break;
+        case IEEE80211_PARAM_MCASTKEYLEN:
+            if (!IEEE80211_IS_VALID_WEP_CIPHER_LEN(value)) {
+                ret = -EIO;
+            } else {
+                ar->arGroupCryptoLen = value;
+            }
+            break;
+        case IEEE80211_PARAM_COUNTERMEASURES:
+            if (ar->arWmiReady == FALSE) {
+                return -EIO;
+            }
+            wmi_set_tkip_countermeasures_cmd(ar->arWmi, value);
+            break;
+        default:
+            break;
+    }
+
+    if (profChanged == TRUE) {
+        /*
+         * profile has changed.  Erase ssid to signal change
+         */
+	A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));
+	ar->arSsidLen = 0;
+    }
+
+    return ret;
+}
+
+int
+ar6000_ioctl_getparam(struct net_device *dev, struct iw_request_info *info,
+            void *w, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+int
+ar6000_ioctl_setkey(struct net_device *dev, struct iw_request_info *info,
+		    void *w, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct ieee80211req_key *ik = (struct ieee80211req_key *)extra;
+    KEY_USAGE keyUsage;
+    A_STATUS status;
+    CRYPTO_TYPE keyType = NONE_CRYPT;
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    ar->user_saved_keys.keyOk = FALSE;
+
+    if ( 0 == memcmp(ik->ik_macaddr, "\x00\x00\x00\x00\x00\x00",
+                     IEEE80211_ADDR_LEN)) {
+        keyUsage = GROUP_USAGE;
+        A_MEMCPY(&ar->user_saved_keys.bcast_ik, ik,
+                 sizeof(struct ieee80211req_key));
+    } else {
+        keyUsage = PAIRWISE_USAGE;
+        A_MEMCPY(&ar->user_saved_keys.ucast_ik, ik,
+                 sizeof(struct ieee80211req_key));
+    }
+
+    switch (ik->ik_type) {
+        case IEEE80211_CIPHER_WEP:
+            keyType = WEP_CRYPT;
+            break;
+        case IEEE80211_CIPHER_TKIP:
+            keyType = TKIP_CRYPT;
+            break;
+        case IEEE80211_CIPHER_AES_CCM:
+            keyType = AES_CRYPT;
+            break;
+        default:
+            break;
+    }
+    ar->user_saved_keys.keyType = keyType;
+
+    if (IEEE80211_CIPHER_CCKM_KRK != ik->ik_type) {
+        if (NONE_CRYPT == keyType) {
+            return -EIO;
+        }
+
+        status = wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, keyType, keyUsage,
+                                ik->ik_keylen, (A_UINT8 *)&ik->ik_keyrsc,
+                                ik->ik_keydata, KEY_OP_INIT_VAL,
+                                SYNC_BEFORE_WMIFLAG);
+
+        if (status != A_OK) {
+            return -EIO;
+        }
+    } else {
+        status = wmi_add_krk_cmd(ar->arWmi, ik->ik_keydata);
+    }
+
+    ar->user_saved_keys.keyOk = TRUE;
+
+    return 0;
+}
+
+
+/*
+ * SIOCGIWNAME
+ */
+int
+ar6000_ioctl_giwname(struct net_device *dev,
+           struct iw_request_info *info,
+           char *name, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (ar->arPhyCapability) {
+    case (WMI_11A_CAPABILITY):
+        strncpy(name, "AR6000 802.11a", IFNAMSIZ);
+        break;
+    case (WMI_11G_CAPABILITY):
+        strncpy(name, "AR6000 802.11g", IFNAMSIZ);
+        break;
+    case (WMI_11AG_CAPABILITY):
+        strncpy(name, "AR6000 802.11ag", IFNAMSIZ);
+        break;
+    default:
+        strncpy(name, "AR6000 802.11", IFNAMSIZ);
+        break;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCSIWFREQ
+ */
+int
+ar6000_ioctl_siwfreq(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_freq *freq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    /*
+     * We support limiting the channels via wmiconfig.
+     *
+     * We use this command to configure the channel hint for the connect cmd
+     * so it is possible the target will end up connecting to a different
+     * channel.
+     */
+    if (freq->e > 1) {
+        return -EINVAL;
+    } else if (freq->e == 1) {
+        ar->arChannelHint = freq->m / 100000;
+    } else {
+        ar->arChannelHint = wlan_ieee2freq(freq->m);
+    }
+
+    A_PRINTF("channel hint set to %d\n", ar->arChannelHint);
+    return 0;
+}
+
+/*
+ * SIOCGIWFREQ
+ */
+int
+ar6000_ioctl_giwfreq(struct net_device *dev,
+                struct iw_request_info *info,
+                struct iw_freq *freq, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arConnected != TRUE) {
+        return -EINVAL;
+    }
+
+    freq->m = ar->arBssChannel * 100000;
+    freq->e = 1;
+
+    return 0;
+}
+
+/*
+ * SIOCSIWMODE
+ */
+int
+ar6000_ioctl_siwmode(struct net_device *dev,
+            struct iw_request_info *info,
+            __u32 *mode, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (*mode) {
+    case IW_MODE_INFRA:
+        ar->arNetworkType = INFRA_NETWORK;
+        break;
+    case IW_MODE_ADHOC:
+        ar->arNetworkType = ADHOC_NETWORK;
+        break;
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCGIWMODE
+ */
+int
+ar6000_ioctl_giwmode(struct net_device *dev,
+            struct iw_request_info *info,
+            __u32 *mode, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    switch (ar->arNetworkType) {
+    case INFRA_NETWORK:
+        *mode = IW_MODE_INFRA;
+        break;
+    case ADHOC_NETWORK:
+        *mode = IW_MODE_ADHOC;
+        break;
+    default:
+        return -EIO;
+    }
+    return 0;
+}
+
+/*
+ * SIOCSIWSENS
+ */
+int
+ar6000_ioctl_siwsens(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *sens, char *extra)
+{
+    return 0;
+}
+
+/*
+ * SIOCGIWSENS
+ */
+int
+ar6000_ioctl_giwsens(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_param *sens, char *extra)
+{
+    sens->value = 0;
+    sens->fixed = 1;
+
+    return 0;
+}
+
+/*
+ * SIOCGIWRANGE
+ */
+int
+ar6000_ioctl_giwrange(struct net_device *dev,
+             struct iw_request_info *info,
+             struct iw_point *data, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    struct iw_range *range = (struct iw_range *) extra;
+    int i, ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (down_interruptible(&ar->arSem)) {
+        return -ERESTARTSYS;
+    }
+    ar->arNumChannels = -1;
+    A_MEMZERO(ar->arChannelList, sizeof (ar->arChannelList));
+
+    if (wmi_get_channelList_cmd(ar->arWmi) != A_OK) {
+        up(&ar->arSem);
+        return -EIO;
+    }
+
+    wait_event_interruptible_timeout(arEvent, ar->arNumChannels != -1, wmitimeout * HZ);
+
+    if (signal_pending(current)) {
+        up(&ar->arSem);
+        return -EINTR;
+    }
+
+    data->length = sizeof(struct iw_range);
+    A_MEMZERO(range, sizeof(struct iw_range));
+
+    range->txpower_capa = IW_TXPOW_DBM;
+
+    range->min_pmp = 1 * 1024;
+    range->max_pmp = 65535 * 1024;
+    range->min_pmt = 1 * 1024;
+    range->max_pmt = 1000 * 1024;
+    range->pmp_flags = IW_POWER_PERIOD;
+    range->pmt_flags = IW_POWER_TIMEOUT;
+    range->pm_capa = 0;
+
+    range->we_version_compiled = WIRELESS_EXT;
+    range->we_version_source = 13;
+
+    range->retry_capa = IW_RETRY_LIMIT;
+    range->retry_flags = IW_RETRY_LIMIT;
+    range->min_retry = 0;
+    range->max_retry = 255;
+
+    range->num_frequency = range->num_channels = ar->arNumChannels;
+    for (i = 0; i < ar->arNumChannels; i++) {
+        range->freq[i].i = wlan_freq2ieee(ar->arChannelList[i]);
+        range->freq[i].m = ar->arChannelList[i] * 100000;
+        range->freq[i].e = 1;
+         /*
+         * Linux supports max of 32 channels, bail out once you
+         * reach the max.
+         */
+        if (i == IW_MAX_FREQUENCIES) {
+            break;
+        }
+    }
+
+    /* Max quality is max field value minus noise floor */
+    range->max_qual.qual  = 0xff - 161;
+
+    /*
+     * In order to use dBm measurements, 'level' must be lower
+     * than any possible measurement (see iw_print_stats() in
+     * wireless tools).  It's unclear how this is meant to be
+     * done, but setting zero in these values forces dBm and
+     * the actual numbers are not used.
+     */
+    range->max_qual.level = 0;
+    range->max_qual.noise = 0;
+
+    range->sensitivity = 3;
+
+    range->max_encoding_tokens = 4;
+    /* XXX query driver to find out supported key sizes */
+    range->num_encoding_sizes = 3;
+    range->encoding_size[0] = 5;        /* 40-bit */
+    range->encoding_size[1] = 13;       /* 104-bit */
+    range->encoding_size[2] = 16;       /* 128-bit */
+
+    range->num_bitrates = 0;
+
+    /* estimated maximum TCP throughput values (bps) */
+    range->throughput = 22000000;
+
+    range->min_rts = 0;
+    range->max_rts = 2347;
+    range->min_frag = 256;
+    range->max_frag = 2346;
+
+    up(&ar->arSem);
+
+    return ret;
+}
+
+
+/*
+ * SIOCSIWAP
+ * This ioctl is used to set the desired bssid for the connect command.
+ */
+int
+ar6000_ioctl_siwap(struct net_device *dev,
+              struct iw_request_info *info,
+              struct sockaddr *ap_addr, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ap_addr->sa_family != ARPHRD_ETHER) {
+        return -EIO;
+    }
+
+    if (A_MEMCMP(&ap_addr->sa_data, bcast_mac, AR6000_ETH_ADDR_LEN) == 0) {
+        A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));
+    } else {
+        A_MEMCPY(ar->arReqBssid, &ap_addr->sa_data,  sizeof(ar->arReqBssid));
+    }
+
+    return 0;
+}
+
+/*
+ * SIOCGIWAP
+ */
+int
+ar6000_ioctl_giwap(struct net_device *dev,
+              struct iw_request_info *info,
+              struct sockaddr *ap_addr, char *extra)
+{
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    if (ar->arConnected != TRUE) {
+        return -EINVAL;
+    }
+
+    A_MEMCPY(&ap_addr->sa_data, ar->arBssid, sizeof(ar->arBssid));
+    ap_addr->sa_family = ARPHRD_ETHER;
+
+    return 0;
+}
+
+/*
+ * SIOCGIWAPLIST
+ */
+int
+ar6000_ioctl_iwaplist(struct net_device *dev,
+            struct iw_request_info *info,
+            struct iw_point *data, char *extra)
+{
+    return -EIO;            /* for now */
+}
+
+/*
+ * SIOCSIWSCAN
+ */
+int
+ar6000_ioctl_siwscan(struct net_device *dev,
+                     struct iw_request_info *info,
+                     struct iw_point *data, char *extra)
+{
+#define ACT_DWELLTIME_DEFAULT   105
+#define HOME_TXDRAIN_TIME       100
+#define SCAN_INT                HOME_TXDRAIN_TIME + ACT_DWELLTIME_DEFAULT
+    AR_SOFTC_T *ar = (AR_SOFTC_T *)netdev_priv(dev);
+    int ret = 0;
+
+    if (ar->arWmiReady == FALSE) {
+        return -EIO;
+    }
+
+    if (ar->arWlanState == WLAN_DISABLED) {
+        return -EIO;
+    }
+
+    /* We ask for everything from the target */
+    if (wmi_bssfilter_cmd(ar->arWmi, ALL_BSS_FILTER, 0) != A_OK) {
+	    printk("Couldn't set filtering\n");
+	    ret = -EIO;
+    }
+
+    if (wmi_startscan_cmd(ar->arWmi, WMI_LONG_SCAN, FALSE, FALSE, \
+                          HOME_TXDRAIN_TIME, SCAN_INT) != A_OK) {
+        ret = -EIO;
+    }
+
+    ar->scan_complete = 0;
+    wait_event_interruptible_timeout(ar6000_scan_queue, ar->scan_complete,
+				     5 * HZ);
+
+    if (wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0) != A_OK) {
+	    printk("Couldn't set filtering\n");
+	    ret = -EIO;
+    }
+
+    return ret;
+#undef  ACT_DWELLTIME_DEFAULT
+#undef HOME_TXDRAIN_TIME
+#undef SCAN_INT
+}
+
+
+/*
+ * Units are in db above the noise floor. That means the
+ * rssi values reported in the tx/rx descriptors in the
+ * driver are the SNR expressed in db.
+ *
+ * If you assume that the noise floor is -95, which is an
+ * excellent assumption 99.5 % of the time, then you can
+ * derive the absolute signal level (i.e. -95 + rssi).
+ * There are some other slight factors to take into account
+ * depending on whether the rssi measurement is from 11b,
+ * 11g, or 11a.   These differences are at most 2db and
+ * can be documented.
+ *
+ * NB: various calculations are based on the orinoco/wavelan
+ *     drivers for compatibility
+ */
+static void
+ar6000_set_quality(struct iw_quality *iq, A_INT8 rssi)
+{
+    if (rssi < 0) {
+        iq->qual = 0;
+    } else {
+        iq->qual = rssi;
+    }
+
+    /* NB: max is 94 because noise is hardcoded to 161 */
+    if (iq->qual > 94)
+        iq->qual = 94;
+
+    iq->noise = 161;        /* -95dBm */
+    iq->level = iq->noise + iq->qual;
+    iq->updated = 7;
+}
+
+
+/* Structures to export the Wireless Handlers */
+static const iw_handler ath_handlers[] = {
+    (iw_handler) NULL,                          /* SIOCSIWCOMMIT */
+    (iw_handler) ar6000_ioctl_giwname,          /* SIOCGIWNAME */
+    (iw_handler) NULL,                          /* SIOCSIWNWID */
+    (iw_handler) NULL,                          /* SIOCGIWNWID */
+    (iw_handler) ar6000_ioctl_siwfreq,          /* SIOCSIWFREQ */
+    (iw_handler) ar6000_ioctl_giwfreq,          /* SIOCGIWFREQ */
+    (iw_handler) ar6000_ioctl_siwmode,          /* SIOCSIWMODE */
+    (iw_handler) ar6000_ioctl_giwmode,          /* SIOCGIWMODE */
+    (iw_handler) ar6000_ioctl_siwsens,          /* SIOCSIWSENS */
+    (iw_handler) ar6000_ioctl_giwsens,          /* SIOCGIWSENS */
+    (iw_handler) NULL /* not _used */,          /* SIOCSIWRANGE */
+    (iw_handler) ar6000_ioctl_giwrange,         /* SIOCGIWRANGE */
+    (iw_handler) NULL /* not used */,           /* SIOCSIWPRIV */
+    (iw_handler) NULL /* kernel code */,        /* SIOCGIWPRIV */
+    (iw_handler) NULL /* not used */,           /* SIOCSIWSTATS */
+    (iw_handler) NULL /* kernel code */,        /* SIOCGIWSTATS */
+    (iw_handler) NULL,                          /* SIOCSIWSPY */
+    (iw_handler) NULL,                          /* SIOCGIWSPY */
+    (iw_handler) NULL,                          /* SIOCSIWTHRSPY */
+    (iw_handler) NULL,                          /* SIOCGIWTHRSPY */
+    (iw_handler) ar6000_ioctl_siwap,            /* SIOCSIWAP */
+    (iw_handler) ar6000_ioctl_giwap,            /* SIOCGIWAP */
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) ar6000_ioctl_iwaplist,         /* SIOCGIWAPLIST */
+    (iw_handler) ar6000_ioctl_siwscan,          /* SIOCSIWSCAN */
+    (iw_handler) ar6000_ioctl_giwscan,          /* SIOCGIWSCAN */
+    (iw_handler) ar6000_ioctl_siwessid,         /* SIOCSIWESSID */
+    (iw_handler) ar6000_ioctl_giwessid,         /* SIOCGIWESSID */
+    (iw_handler) NULL,                          /* SIOCSIWNICKN */
+    (iw_handler) NULL,                          /* SIOCGIWNICKN */
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) NULL,                          /* -- hole -- */
+    (iw_handler) ar6000_ioctl_siwrate,          /* SIOCSIWRATE */
+    (iw_handler) ar6000_ioctl_giwrate,          /* SIOCGIWRATE */
+    (iw_handler) NULL,           /* SIOCSIWRTS */
+    (iw_handler) NULL,           /* SIOCGIWRTS */
+    (iw_handler) NULL,          /* SIOCSIWFRAG */
+    (iw_handler) NULL,          /* SIOCGIWFRAG */
+    (iw_handler) ar6000_ioctl_siwtxpow,         /* SIOCSIWTXPOW */
+    (iw_handler) ar6000_ioctl_giwtxpow,         /* SIOCGIWTXPOW */
+    (iw_handler) ar6000_ioctl_siwretry,         /* SIOCSIWRETRY */
+    (iw_handler) ar6000_ioctl_giwretry,         /* SIOCGIWRETRY */
+    (iw_handler) ar6000_ioctl_siwencode,        /* SIOCSIWENCODE */
+    (iw_handler) ar6000_ioctl_giwencode,        /* SIOCGIWENCODE */
+    (iw_handler) ar6000_ioctl_siwpower,         /* SIOCSIWPOWER */
+    (iw_handler) ar6000_ioctl_giwpower,         /* SIOCGIWPOWER */
+    (iw_handler) NULL,	/* -- hole -- */
+    (iw_handler) NULL,	/* -- hole -- */
+    (iw_handler) ar6000_ioctl_siwgenie,	/* SIOCSIWGENIE */
+    (iw_handler) ar6000_ioctl_giwgenie,	/* SIOCGIWGENIE */
+    (iw_handler) ar6000_ioctl_siwauth,	/* SIOCSIWAUTH */
+    (iw_handler) ar6000_ioctl_giwauth,	/* SIOCGIWAUTH */
+    (iw_handler) ar6000_ioctl_siwencodeext,/* SIOCSIWENCODEEXT */
+    (iw_handler) ar6000_ioctl_giwencodeext,/* SIOCGIWENCODEEXT */
+    (iw_handler) NULL,		/* SIOCSIWPMKSA */
+};
+
+static const iw_handler ath_priv_handlers[] = {
+    (iw_handler) ar6000_ioctl_setparam,         /* SIOCWFIRSTPRIV+0 */
+    (iw_handler) ar6000_ioctl_getparam,         /* SIOCWFIRSTPRIV+1 */
+    (iw_handler) ar6000_ioctl_setkey,           /* SIOCWFIRSTPRIV+2 */
+    (iw_handler) ar6000_ioctl_setwmmparams,     /* SIOCWFIRSTPRIV+3 */
+    (iw_handler) ar6000_ioctl_delkey,           /* SIOCWFIRSTPRIV+4 */
+    (iw_handler) ar6000_ioctl_getwmmparams,     /* SIOCWFIRSTPRIV+5 */
+    (iw_handler) ar6000_ioctl_setoptie,         /* SIOCWFIRSTPRIV+6 */
+    (iw_handler) ar6000_ioctl_setmlme,          /* SIOCWFIRSTPRIV+7 */
+    (iw_handler) ar6000_ioctl_addpmkid,         /* SIOCWFIRSTPRIV+8 */
+};
+
+#define IW_PRIV_TYPE_KEY \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_key))
+#define IW_PRIV_TYPE_DELKEY \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_del_key))
+#define IW_PRIV_TYPE_MLME \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_mlme))
+#define IW_PRIV_TYPE_ADDPMKID \
+    (IW_PRIV_TYPE_BYTE | sizeof(struct ieee80211req_addpmkid))
+
+static const struct iw_priv_args ar6000_priv_args[] = {
+    { IEEE80211_IOCTL_SETKEY,
+      IW_PRIV_TYPE_KEY | IW_PRIV_SIZE_FIXED, 0,       "setkey"},
+    { IEEE80211_IOCTL_DELKEY,
+      IW_PRIV_TYPE_DELKEY | IW_PRIV_SIZE_FIXED, 0,    "delkey"},
+    { IEEE80211_IOCTL_SETPARAM,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0,   "setparam"},
+    { IEEE80211_IOCTL_GETPARAM,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,      "getparam"},
+    { IEEE80211_IOCTL_SETWMMPARAMS,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 4, 0,   "setwmmparams"},
+    { IEEE80211_IOCTL_GETWMMPARAMS,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 3,
+      IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,      "getwmmparams"},
+    { IEEE80211_IOCTL_SETOPTIE,
+      IW_PRIV_TYPE_BYTE, 0,       "setie"},
+    { IEEE80211_IOCTL_SETMLME,
+      IW_PRIV_TYPE_MLME, 0,       "setmlme"},
+    { IEEE80211_IOCTL_ADDPMKID,
+      IW_PRIV_TYPE_ADDPMKID | IW_PRIV_SIZE_FIXED, 0,  "addpmkid"},
+};
+
+void ar6000_ioctl_iwsetup(struct iw_handler_def *def)
+{
+    def->private_args = (struct iw_priv_args *)ar6000_priv_args;
+    def->num_private_args = ARRAY_SIZE(ar6000_priv_args);
+}
+
+struct iw_handler_def ath_iw_handler_def = {
+    .standard         = (iw_handler *)ath_handlers,
+    .num_standard     = ARRAY_SIZE(ath_handlers),
+    .private          = (iw_handler *)ath_priv_handlers,
+    .num_private      = ARRAY_SIZE(ath_priv_handlers),
+};
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/bmi/bmi.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/bmi/bmi.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/bmi/bmi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/bmi/bmi.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,657 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "hif.h"
+#include "bmi.h"
+#include "htc_api.h"
+#include "bmi_internal.h"
+
+/*
+Although we had envisioned BMI to run on top of HTC, this is not what the
+final implementation boiled down to on dragon. Its a part of BSP and does
+not use the HTC protocol either. On the host side, however, we were still
+living with the original idea. I think the time has come to accept the truth
+and separate it from HTC which has been carrying BMI's burden all this while.
+It shall make HTC state machine relatively simpler
+*/
+
+/* APIs visible to the driver */
+void
+BMIInit(void)
+{
+    bmiDone = FALSE;
+}
+
+A_STATUS
+BMIDone(HIF_DEVICE *device)
+{
+    A_STATUS status;
+    A_UINT32 cid;
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF (ATH_DEBUG_BMI, ("BMIDone skipped\n"));
+        return A_OK;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Done: Enter (device: 0x%p)\n", device));
+    bmiDone = TRUE;
+    cid = BMI_DONE;
+
+    status = bmiBufferSend(device, (A_UCHAR *)&cid, sizeof(cid));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Done: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIGetTargetInfo(HIF_DEVICE *device, struct bmi_target_info *targ_info)
+{
+    A_STATUS status;
+    A_UINT32 cid;
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Get Target Info: Enter (device: 0x%p)\n", device));
+    cid = BMI_GET_TARGET_INFO;
+
+    status = bmiBufferSend(device, (A_UCHAR *)&cid, sizeof(cid));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, (A_UCHAR *)&targ_info->target_ver,
+                                                sizeof(targ_info->target_ver));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Version from the device\n"));
+        return A_ERROR;
+    }
+
+    if (targ_info->target_ver == TARGET_VERSION_SENTINAL) {
+        /* Determine how many bytes are in the Target's targ_info */
+        status = bmiBufferReceive(device, (A_UCHAR *)&targ_info->target_info_byte_count,
+                                            sizeof(targ_info->target_info_byte_count));
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Info Byte Count from the device\n"));
+            return A_ERROR;
+        }
+
+        /*
+         * The Target's targ_info doesn't match the Host's targ_info.
+         * We need to do some backwards compatibility work to make this OK.
+         */
+        A_ASSERT(targ_info->target_info_byte_count == sizeof(*targ_info));
+
+        /* Read the remainder of the targ_info */
+        status = bmiBufferReceive(device,
+                        ((A_UCHAR *)targ_info)+sizeof(targ_info->target_info_byte_count),
+                        sizeof(*targ_info)-sizeof(targ_info->target_info_byte_count));
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read Target Info (%d bytes) from the device\n",
+                        					targ_info->target_info_byte_count));
+            return A_ERROR;
+        }
+    } else {
+        /*
+         * Target must be an AR6001 whose firmware does not
+         * support BMI_GET_TARGET_INFO.  Construct the data
+         * that it would have sent.
+         */
+        targ_info->target_info_byte_count = sizeof(targ_info);
+        targ_info->target_type = TARGET_TYPE_AR6001;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Get Target Info: Exit (ver: 0x%x type: 0x%x)\n",
+        							targ_info->target_ver, targ_info->target_type));
+    printk("BMI Get Target Info: Exit (ver: 0x%x type: 0x%x)\n",
+	   targ_info->target_ver, targ_info->target_type);
+
+    return A_OK;
+}
+
+A_STATUS
+BMIReadMemory(HIF_DEVICE *device,
+              A_UINT32 address,
+              A_UCHAR *buffer,
+              A_UINT32 length)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    A_UINT32 remaining, rxlen;
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length)];
+    memset (&data, 0, BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       			("BMI Read Memory: Enter (device: 0x%p, address: 0x%x, length: %d)\n",
+        			device, address, length));
+
+    cid = BMI_READ_MEMORY;
+
+    remaining = length;
+
+    while (remaining)
+    {
+        rxlen = (remaining < BMI_DATASZ_MAX) ? remaining : BMI_DATASZ_MAX;
+        offset = 0;
+        A_MEMCPY(&data[offset], &cid, sizeof(cid));
+        offset += sizeof(cid);
+        A_MEMCPY(&data[offset], &address, sizeof(address));
+        offset += sizeof(address);
+        A_MEMCPY(&data[offset], &rxlen, sizeof(rxlen));
+        offset += sizeof(length);
+
+        status = bmiBufferSend(device, data, offset);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+            return A_ERROR;
+        }
+        status = bmiBufferReceive(device, data, rxlen);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+            return A_ERROR;
+        }
+        A_MEMCPY(&buffer[length - remaining], data, rxlen);
+        remaining -= rxlen; address += rxlen;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read Memory: Exit\n"));
+    return A_OK;
+}
+
+A_STATUS
+BMIWriteMemory(HIF_DEVICE *device,
+               A_UINT32 address,
+               A_UCHAR *buffer,
+               A_UINT32 length)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    A_UINT32 remaining, txlen;
+    const A_UINT32 header = sizeof(cid) + sizeof(address) + sizeof(length);
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(address) + sizeof(length)];
+	memset (&data, 0, header);
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI Write Memory: Enter (device: 0x%p, address: 0x%x, length: %d)\n",
+         device, address, length));
+
+    cid = BMI_WRITE_MEMORY;
+
+    remaining = length;
+    while (remaining)
+    {
+        txlen = (remaining < (BMI_DATASZ_MAX - header)) ?
+                                       remaining : (BMI_DATASZ_MAX - header);
+        offset = 0;
+        A_MEMCPY(&data[offset], &cid, sizeof(cid));
+        offset += sizeof(cid);
+        A_MEMCPY(&data[offset], &address, sizeof(address));
+        offset += sizeof(address);
+        A_MEMCPY(&data[offset], &txlen, sizeof(txlen));
+        offset += sizeof(txlen);
+        A_MEMCPY(&data[offset], &buffer[length - remaining], txlen);
+        offset += txlen;
+        status = bmiBufferSend(device, data, offset);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+            return A_ERROR;
+        }
+        remaining -= txlen; address += txlen;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Write Memory: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIExecute(HIF_DEVICE *device,
+           A_UINT32 address,
+           A_UINT32 *param)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address) + sizeof(*param)];
+    memset (&data, 0, sizeof(cid) + sizeof(address) + sizeof(*param));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       ("BMI Execute: Enter (device: 0x%p, address: 0x%x, param: %d)\n",
+        device, address, *param));
+
+    cid = BMI_EXECUTE;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    A_MEMCPY(&data[offset], param, sizeof(*param));
+    offset += sizeof(*param);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, data, sizeof(*param));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+        return A_ERROR;
+    }
+
+    A_MEMCPY(param, data, sizeof(*param));
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Execute: Exit (param: %d)\n", *param));
+    return A_OK;
+}
+
+A_STATUS
+BMISetAppStart(HIF_DEVICE *device,
+               A_UINT32 address)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address)];
+    memset (&data, 0, sizeof(cid) + sizeof(address));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       ("BMI Set App Start: Enter (device: 0x%p, address: 0x%x)\n",
+        device, address));
+
+    cid = BMI_SET_APP_START;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Set App Start: Exit\n"));
+    return A_OK;
+}
+
+A_STATUS
+BMIReadSOCRegister(HIF_DEVICE *device,
+                   A_UINT32 address,
+                   A_UINT32 *param)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address)];
+    memset (&data, 0, sizeof(cid) + sizeof(address));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+       ("BMI Read SOC Register: Enter (device: 0x%p, address: 0x%x)\n",
+       device, address));
+
+    cid = BMI_READ_SOC_REGISTER;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, data, sizeof(*param));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+        return A_ERROR;
+    }
+    A_MEMCPY(param, data, sizeof(*param));
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read SOC Register: Exit (value: %d)\n", *param));
+    return A_OK;
+}
+
+A_STATUS
+BMIWriteSOCRegister(HIF_DEVICE *device,
+                    A_UINT32 address,
+                    A_UINT32 param)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(address) + sizeof(param)];
+
+    memset (&data, 0, sizeof(cid) + sizeof(address) + sizeof(param));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+     ("BMI Write SOC Register: Enter (device: 0x%p, address: 0x%x, param: %d)\n",
+     device, address, param));
+
+    cid = BMI_WRITE_SOC_REGISTER;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &address, sizeof(address));
+    offset += sizeof(address);
+    A_MEMCPY(&data[offset], &param, sizeof(param));
+    offset += sizeof(param);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Read SOC Register: Exit\n"));
+    return A_OK;
+}
+
+A_STATUS
+BMIrompatchInstall(HIF_DEVICE *device,
+                   A_UINT32 ROM_addr,
+                   A_UINT32 RAM_addr,
+                   A_UINT32 nbytes,
+                   A_UINT32 do_activate,
+                   A_UINT32 *rompatch_id)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(ROM_addr) + sizeof(RAM_addr) +
+                                sizeof(nbytes) + sizeof(do_activate)];
+
+	memset (&data, 0, sizeof(cid) + sizeof(ROM_addr) + sizeof(RAM_addr) +
+                      sizeof(nbytes) + sizeof(do_activate));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI rompatch Install: Enter (device: 0x%p, ROMaddr: 0x%x, RAMaddr: 0x%x length: %d activate: %d)\n",
+         device, ROM_addr, RAM_addr, nbytes, do_activate));
+
+    cid = BMI_ROMPATCH_INSTALL;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &ROM_addr, sizeof(ROM_addr));
+    offset += sizeof(ROM_addr);
+    A_MEMCPY(&data[offset], &RAM_addr, sizeof(RAM_addr));
+    offset += sizeof(RAM_addr);
+    A_MEMCPY(&data[offset], &nbytes, sizeof(nbytes));
+    offset += sizeof(nbytes);
+    A_MEMCPY(&data[offset], &do_activate, sizeof(do_activate));
+    offset += sizeof(do_activate);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    status = bmiBufferReceive(device, (A_UCHAR *)rompatch_id, sizeof(*rompatch_id));
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read from the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI rompatch Install: (rompatch_id=%d)\n", *rompatch_id));
+    return A_OK;
+}
+
+A_STATUS
+BMIrompatchUninstall(HIF_DEVICE *device,
+                     A_UINT32 rompatch_id)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[sizeof(cid) + sizeof(rompatch_id)];
+    memset (&data, 0, sizeof(cid) + sizeof(rompatch_id));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI rompatch Uninstall: Enter (device: 0x%p, rompatch_id: %d)\n",
+         								 device, rompatch_id));
+
+    cid = BMI_ROMPATCH_UNINSTALL;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &rompatch_id, sizeof(rompatch_id));
+    offset += sizeof(rompatch_id);
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI rompatch UNinstall: (rompatch_id=0x%x)\n", rompatch_id));
+    return A_OK;
+}
+
+static A_STATUS
+_BMIrompatchChangeActivation(HIF_DEVICE *device,
+                             A_UINT32 rompatch_count,
+                             A_UINT32 *rompatch_list,
+                             A_UINT32 do_activate)
+{
+    A_UINT32 cid;
+    A_STATUS status;
+    A_UINT32 offset;
+    static A_UCHAR data[BMI_DATASZ_MAX + sizeof(cid) + sizeof(rompatch_count)];
+    A_UINT32 length;
+
+	memset (&data, 0, BMI_DATASZ_MAX + sizeof(cid) + sizeof(rompatch_count));
+
+    if (bmiDone) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Command disallowed\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI,
+         ("BMI Change rompatch Activation: Enter (device: 0x%p, count: %d)\n",
+           device, rompatch_count));
+
+    cid = do_activate ? BMI_ROMPATCH_ACTIVATE : BMI_ROMPATCH_DEACTIVATE;
+
+    offset = 0;
+    A_MEMCPY(&data[offset], &cid, sizeof(cid));
+    offset += sizeof(cid);
+    A_MEMCPY(&data[offset], &rompatch_count, sizeof(rompatch_count));
+    offset += sizeof(rompatch_count);
+    length = rompatch_count * sizeof(*rompatch_list);
+    A_MEMCPY(&data[offset], rompatch_list, length);
+    offset += length;
+    status = bmiBufferSend(device, data, offset);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to write to the device\n"));
+        return A_ERROR;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Change rompatch Activation: Exit\n"));
+
+    return A_OK;
+}
+
+A_STATUS
+BMIrompatchActivate(HIF_DEVICE *device,
+                    A_UINT32 rompatch_count,
+                    A_UINT32 *rompatch_list)
+{
+    return _BMIrompatchChangeActivation(device, rompatch_count, rompatch_list, 1);
+}
+
+A_STATUS
+BMIrompatchDeactivate(HIF_DEVICE *device,
+                      A_UINT32 rompatch_count,
+                      A_UINT32 *rompatch_list)
+{
+    return _BMIrompatchChangeActivation(device, rompatch_count, rompatch_list, 0);
+}
+
+/* BMI Access routines */
+A_STATUS
+bmiBufferSend(HIF_DEVICE *device,
+              A_UCHAR *buffer,
+              A_UINT32 length)
+{
+    A_STATUS status;
+    A_UINT32 timeout;
+    A_UINT32 address;
+    static A_UINT32 cmdCredits;
+    A_UINT32 mboxAddress[HTC_MAILBOX_NUM_MAX];
+
+    HIFConfigureDevice(device, HIF_DEVICE_GET_MBOX_ADDR,
+                       &mboxAddress, sizeof(mboxAddress));
+
+    cmdCredits = 0;
+    timeout = BMI_COMMUNICATION_TIMEOUT;
+
+    while(timeout-- && !cmdCredits) {
+        /* Read the counter register to get the command credits */
+        address = COUNT_DEC_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 4;
+        /* hit the credit counter with a 4-byte access, the first byte read will hit the counter and cause
+         * a decrement, while the remaining 3 bytes has no effect.  The rationale behind this is to
+         * make all HIF accesses 4-byte aligned */
+        status = HIFReadWrite(device, address, (A_UINT8 *)&cmdCredits, 4,
+            HIF_RD_SYNC_BYTE_INC, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to decrement the command credit count register\n"));
+            return A_ERROR;
+        }
+        /* the counter is only 8=bits, ignore anything in the upper 3 bytes */
+        cmdCredits &= 0xFF;
+    }
+
+    if (cmdCredits) {
+        address = mboxAddress[ENDPOINT1];
+        status = HIFReadWrite(device, address, buffer, length,
+            HIF_WR_SYNC_BYTE_INC, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to send the BMI data to the device\n"));
+            return A_ERROR;
+        }
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("BMI Communication timeout\n"));
+        return A_ERROR;
+    }
+
+    return status;
+}
+
+A_STATUS
+bmiBufferReceive(HIF_DEVICE *device,
+                 A_UCHAR *buffer,
+                 A_UINT32 length)
+{
+    A_STATUS status;
+    A_UINT32 address;
+    A_UINT32 timeout;
+    static A_UINT32 cmdCredits;
+    A_UINT32 mboxAddress[HTC_MAILBOX_NUM_MAX];
+
+    HIFConfigureDevice(device, HIF_DEVICE_GET_MBOX_ADDR,
+                       &mboxAddress, sizeof(mboxAddress));
+
+    cmdCredits = 0;
+    timeout = BMI_COMMUNICATION_TIMEOUT;
+    while(timeout-- && !cmdCredits) {
+        /* Read the counter register to get the command credits */
+        address = COUNT_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 1;
+        /* read the counter using a 4-byte read.  Since the counter is NOT auto-decrementing,
+         * we can read this counter multiple times using a non-incrementing address mode.
+         * The rationale here is to make all HIF accesses a multiple of 4 bytes */
+        status = HIFReadWrite(device, address, (A_UINT8 *)&cmdCredits, sizeof(cmdCredits),
+            HIF_RD_SYNC_BYTE_FIX, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read the command credit count register\n"));
+            return A_ERROR;
+        }
+            /* we did a 4-byte read to the same count register so mask off upper bytes */
+        cmdCredits &= 0xFF;
+        status = A_ERROR;
+    }
+
+    if (cmdCredits) {
+        address = mboxAddress[ENDPOINT1];
+        status = HIFReadWrite(device, address, buffer, length,
+            HIF_RD_SYNC_BYTE_INC, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to read the BMI data from the device\n"));
+            return A_ERROR;
+        }
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_BMI, ("BMI Communication timeout\n"));
+        return A_ERROR;
+    }
+
+    return status;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/bmi/bmi_internal.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/bmi/bmi_internal.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/bmi/bmi_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/bmi/bmi_internal.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,45 @@
+#ifndef BMI_INTERNAL_H
+#define BMI_INTERNAL_H
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+#include "a_debug.h"
+#include "AR6Khwreg.h"
+#include "bmi_msg.h"
+
+#define BMI_COMMUNICATION_TIMEOUT       100000
+
+/* ------ Global Variable Declarations ------- */
+A_BOOL bmiDone;
+
+A_STATUS
+bmiBufferSend(HIF_DEVICE *device,
+              A_UCHAR *buffer,
+              A_UINT32 length);
+
+A_STATUS
+bmiBufferReceive(HIF_DEVICE *device,
+                 A_UCHAR *buffer,
+                 A_UINT32 length);
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/hif/hif2.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/hif/hif2.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/hif/hif2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/hif/hif2.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,768 @@
+/*
+ * hif2.c - HIF layer re-implementation for the Linux SDIO stack
+ *
+ * Copyright (C) 2008, 2009 by OpenMoko, Inc.
+ * Written by Werner Almesberger <werner@openmoko.org>
+ * All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation;
+ *
+ * Based on:
+ *
+ * @abstract: HIF layer reference implementation for Atheros SDIO stack
+ * @notice: Copyright (c) 2004-2006 Atheros Communications Inc.
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_ids.h>
+
+#include "athdefs.h"
+#include "a_types.h"
+#include "hif.h"
+
+
+/* @@@ Hack - this wants cleaning up */
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+
+#include <mach/gta02-pm-wlan.h>
+
+#else /* CONFIG_MACH_NEO1973_GTA02 */
+
+#define	gta02_wlan_query_rfkill_lock()  1
+#define	gta02_wlan_set_rfkill_cb(cb, hif) ((void) cb)
+#define	gta02_wlan_query_rfkill_unlock()
+#define	gta02_wlan_clear_rfkill_cb()
+
+#endif /* !CONFIG_MACH_NEO1973_GTA02 */
+
+
+/*
+ * KNOWN BUGS:
+ *
+ * - HIF_DEVICE_IRQ_ASYNC_SYNC doesn't work yet (gets MMC errors)
+ * - latency can reach hundreds of ms, probably because of scheduling delays
+ * - packets go through about three queues before finally hitting the network
+ */
+
+/*
+ * Differences from Atheros' HIFs:
+ *
+ * - synchronous and asynchronous requests may get reordered with respect to
+ *   each other, e.g., if HIFReadWrite returns for an asynchronous request and
+ *   then HIFReadWrite is called for a synchronous request, the synchronous
+ *   request may be executed before the asynchronous request.
+ *
+ * - request queue locking seems unnecessarily complex in the Atheros HIFs.
+ *
+ * - Atheros mask interrupts by calling sdio_claim_irq/sdio_release_irq, which
+ *   can cause quite a bit of overhead. This HIF has its own light-weight
+ *   interrupt masking.
+ *
+ * - Atheros call deviceInsertedHandler from a thread spawned off the probe or
+ *   device insertion function. The original explanation for the Atheros SDIO
+ *   stack said that this is done because a delay is needed to let the chip
+ *   complete initialization. There is indeed a one second delay in the thread.
+ *
+ *   The Atheros Linux SDIO HIF removes the delay and only retains the thread.
+ *   Experimentally removing the thread didn't show any conflicts, so let's get
+ *   rid of it for good.
+ *
+ * - The Atheros SDIO stack with Samuel's driver sets SDIO_CCCR_POWER in
+ *   SDIO_POWER_EMPC. Atheros' Linux SDIO code apparently doesn't. We don't
+ *   either, and this seems to work fine.
+ *   @@@ Need to check this with Atheros.
+ */
+
+
+#define MBOXES			4
+
+#define HIF_MBOX_BLOCK_SIZE	128
+#define	HIF_MBOX_BASE_ADDR	0x800
+#define	HIF_MBOX_WIDTH		0x800
+#define	HIF_MBOX_START_ADDR(mbox) \
+    (HIF_MBOX_BASE_ADDR+(mbox)*HIF_MBOX_WIDTH)
+
+
+struct hif_device {
+	void *htc_handle;
+	struct sdio_func *func;
+
+	/*
+	 * @@@ our sweet little bit of bogosity - the mechanism that lets us
+	 * use the SDIO stack from softirqs. This really wants to use skbs.
+	 */
+	struct list_head queue;
+	spinlock_t queue_lock;
+	struct task_struct *io_task;
+	wait_queue_head_t wait;
+
+	/*
+	 * activate_lock protects "active" and the activation/deactivation
+	 * process itself.
+	 *
+	 * Relation to other locks: The SDIO function can be claimed while
+	 * activate_lock is being held, but trying to acquire activate_lock
+	 * while having ownership of the SDIO function could cause a deadlock.
+	 */
+	int active;
+	struct mutex activate_lock;
+};
+
+struct hif_request {
+	struct list_head list;
+	struct sdio_func *func;
+	int (*read)(struct sdio_func *func,
+	    void *dst, unsigned int addr, int count);
+	int (*write)(struct sdio_func *func,
+	    unsigned int addr, void *src, int count);
+	void *buf;
+	unsigned long addr;
+	int len;
+	A_STATUS (*completion)(void *context, A_STATUS status);
+	void *context;
+};
+
+
+static HTC_CALLBACKS htcCallbacks;
+
+/*
+ * shutdown_lock prevents recursion through HIFShutDownDevice
+ */
+static DEFINE_MUTEX(shutdown_lock);
+
+
+/* ----- Request processing ------------------------------------------------ */
+
+
+static A_STATUS process_request(struct hif_request *req)
+{
+	int ret;
+	A_STATUS status;
+
+	dev_dbg(&req->func->dev, "process_request(req %p)\n", req);
+	sdio_claim_host(req->func);
+	if (req->read) {
+		ret = req->read(req->func, req->buf, req->addr, req->len);
+	} else {
+		ret = req->write(req->func, req->addr, req->buf, req->len);
+	}
+	sdio_release_host(req->func);
+	status = ret ? A_ERROR : A_OK;
+	if (req->completion)
+		req->completion(req->context, status);
+	kfree(req);
+	return status;
+}
+
+
+static void enqueue_request(struct hif_device *hif, struct hif_request *req)
+{
+	unsigned long flags;
+
+	dev_dbg(&req->func->dev, "enqueue_request(req %p)\n", req);
+	spin_lock_irqsave(&hif->queue_lock, flags);
+	list_add_tail(&req->list, &hif->queue);
+	spin_unlock_irqrestore(&hif->queue_lock, flags);
+	wake_up(&hif->wait);
+}
+
+
+static struct hif_request *dequeue_request(struct hif_device *hif)
+{
+	struct hif_request *req;
+	unsigned long flags;
+
+	spin_lock_irqsave(&hif->queue_lock, flags);
+	if (list_empty(&hif->queue))
+		req = NULL;
+	else {
+		req = list_first_entry(&hif->queue,
+		    struct hif_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&hif->queue_lock, flags);
+	return req;
+}
+
+
+static void wait_queue_empty(struct hif_device *hif)
+{
+	unsigned long flags;
+	int empty;
+
+	while (1) {
+		spin_lock_irqsave(&hif->queue_lock, flags);
+		empty = list_empty(&hif->queue);
+		spin_unlock_irqrestore(&hif->queue_lock, flags);
+		if (empty)
+			break;
+		else
+			yield();
+	}
+}
+
+
+static int io(void *data)
+{
+	struct hif_device *hif = data;
+	struct sched_param param = { .sched_priority = 2 };
+		/* one priority level slower than ksdioirqd (which is at 1) */
+	DEFINE_WAIT(wait);
+	struct hif_request *req;
+
+	sched_setscheduler(current, SCHED_FIFO, &param);
+
+	while (1) {
+		while (1) {
+			/*
+			 * Since we never use signals here, one might think
+			 * that this ought to be TASK_UNINTERRUPTIBLE. However,
+			 * such a task would increase the load average and,
+			 * worse, it would trigger the softlockup check.
+			 */
+			prepare_to_wait(&hif->wait, &wait, TASK_INTERRUPTIBLE);
+			if (kthread_should_stop()) {
+				finish_wait(&hif->wait, &wait);
+				return 0;
+			}
+			req = dequeue_request(hif);
+			if (req)
+				break;
+			schedule();
+		}
+		finish_wait(&hif->wait, &wait);
+
+		(void) process_request(req);
+	}
+	return 0;
+}
+
+
+A_STATUS HIFReadWrite(HIF_DEVICE *hif, A_UINT32 address, A_UCHAR *buffer,
+    A_UINT32 length, A_UINT32 request, void *context)
+{
+	struct device *dev = HIFGetOSDevice(hif);
+	struct hif_request *req;
+
+	dev_dbg(dev, "HIFReadWrite(device %p, address 0x%x, buffer %p, "
+	    "length %d, request 0x%x, context %p)\n",
+	    hif, address, buffer, length, request, context);
+
+	BUG_ON(!(request & (HIF_SYNCHRONOUS | HIF_ASYNCHRONOUS)));
+	BUG_ON(!(request & (HIF_BYTE_BASIS | HIF_BLOCK_BASIS)));
+	BUG_ON(!(request & (HIF_READ | HIF_WRITE)));
+	BUG_ON(!(request & HIF_EXTENDED_IO));
+
+	if (address >= HIF_MBOX_START_ADDR(0) &&
+	    address < HIF_MBOX_START_ADDR(MBOXES+1)) {
+		BUG_ON(length > HIF_MBOX_WIDTH);
+		/* Adjust the address so that the last byte falls on the EOM
+		   address. */
+		address += HIF_MBOX_WIDTH-length;
+	}
+
+	req = kzalloc(sizeof(*req), GFP_ATOMIC);
+	if (!req) {
+		if (request & HIF_ASYNCHRONOUS)
+			htcCallbacks.rwCompletionHandler(context, A_ERROR);
+		return A_ERROR;
+	}
+
+	req->func = hif->func;
+	req->addr = address;
+	req->buf = buffer;
+	req->len = length;
+
+	if (request & HIF_READ) {
+		if (request & HIF_FIXED_ADDRESS)
+			req->read = sdio_readsb;
+		else
+			req->read = sdio_memcpy_fromio;
+	} else {
+		if (request & HIF_FIXED_ADDRESS)
+			req->write = sdio_writesb;
+		else
+			req->write = sdio_memcpy_toio;
+	}
+
+	if (!(request & HIF_ASYNCHRONOUS))
+		return process_request(req);
+
+	req->completion = htcCallbacks.rwCompletionHandler;
+	req->context = context;
+	enqueue_request(hif, req);
+
+	return A_OK;
+}
+
+
+/* ----- Interrupt handling ------------------------------------------------ */
+
+/*
+ * Volatile ought to be good enough to make gcc do the right thing on S3C24xx.
+ * No need to use atomic or put barriers, keeping the code more readable.
+ *
+ * Warning: this story changes if going SMP/SMT.
+ */
+
+static volatile int masked = 1;
+static volatile int pending;
+static volatile int in_interrupt;
+
+
+static void ar6000_do_irq(struct sdio_func *func)
+{
+	HIF_DEVICE *hif = sdio_get_drvdata(func);
+	struct device *dev = HIFGetOSDevice(hif);
+	A_STATUS status;
+
+	dev_dbg(dev, "ar6000_do_irq -> %p\n", htcCallbacks.dsrHandler);
+
+	status = htcCallbacks.dsrHandler(hif->htc_handle);
+	BUG_ON(status != A_OK);
+}
+
+
+static void sdio_ar6000_irq(struct sdio_func *func)
+{
+	HIF_DEVICE *hif = sdio_get_drvdata(func);
+	struct device *dev = HIFGetOSDevice(hif);
+
+	dev_dbg(dev, "sdio_ar6000_irq\n");
+
+	in_interrupt = 1;
+	if (masked) {
+		in_interrupt = 0;
+		pending++;
+		return;
+	}
+	/*
+	 * @@@ This is ugly. If we don't drop the lock, we'll deadlock when
+	 * the handler tries to do SDIO. So there are four choices:
+	 *
+	 * 1) Break the call chain by calling the callback from a workqueue.
+	 *    Ugh.
+	 * 2) Make process_request aware that we already have the lock.
+	 * 3) Drop the lock. Which is ugly but should be safe as long as we're
+	 *    making sure the device doesn't go away.
+	 * 4) Change the AR6k driver such that it only issues asynchronous
+	 *    quests when called from an interrupt.
+	 *
+	 * Solution 2) is probably the best for now. Will try it later.
+	 */
+	sdio_release_host(func);
+	ar6000_do_irq(func);
+	sdio_claim_host(func);
+	in_interrupt = 0;
+}
+
+
+void HIFAckInterrupt(HIF_DEVICE *hif)
+{
+	struct device *dev = HIFGetOSDevice(hif);
+
+	dev_dbg(dev, "HIFAckInterrupt\n");
+	/* do nothing */
+}
+
+
+void HIFUnMaskInterrupt(HIF_DEVICE *hif)
+{
+	struct device *dev = HIFGetOSDevice(hif);
+
+	dev_dbg(dev, "HIFUnMaskInterrupt\n");
+	do {
+		masked = 1;
+		if (pending) {
+			pending = 0;
+			ar6000_do_irq(hif->func);
+			/* We may take an interrupt before unmasking and thus
+			   get it pending. In this case, we just loop back. */
+		}
+		masked = 0;
+	}
+	while (pending);
+}
+
+
+void HIFMaskInterrupt(HIF_DEVICE *hif)
+{
+	struct device *dev = HIFGetOSDevice(hif);
+
+	dev_dbg(dev, "HIFMaskInterrupt\n");
+	/*
+	 * Since sdio_ar6000_irq can also be called from a process context, we
+	 * may conceivably end up racing with it. Thus, we need to wait until
+	 * we can be sure that no concurrent interrupt processing is going on
+	 * before we return.
+	 *
+	 * Note: this may be a bit on the paranoid side - the callers may
+	 * actually be nice enough to disable scheduling. Check later.
+	 */
+	masked = 1;
+	while (in_interrupt)
+		yield();
+}
+
+
+/* ----- HIF API glue functions -------------------------------------------- */
+
+
+struct device *HIFGetOSDevice(HIF_DEVICE *hif)
+{
+	return &hif->func->dev;
+}
+
+
+void HIFSetHandle(void *hif_handle, void *handle)
+{
+	HIF_DEVICE *hif = (HIF_DEVICE *) hif_handle;
+
+	hif->htc_handle = handle;
+}
+
+
+/* ----- Device configuration (HIF side) ----------------------------------- */
+
+
+A_STATUS HIFConfigureDevice(HIF_DEVICE *hif,
+    HIF_DEVICE_CONFIG_OPCODE opcode, void *config, A_UINT32 configLen)
+{
+	struct device *dev = HIFGetOSDevice(hif);
+	HIF_DEVICE_IRQ_PROCESSING_MODE *ipm_cfg = config;
+	A_UINT32 *mbs_cfg = config;
+	int i;
+
+	dev_dbg(dev, "HIFConfigureDevice\n");
+
+	switch (opcode) {
+	case HIF_DEVICE_GET_MBOX_BLOCK_SIZE:
+		for (i = 0; i != MBOXES; i++)
+			mbs_cfg[i] = HIF_MBOX_BLOCK_SIZE;
+		break;
+	case HIF_DEVICE_GET_MBOX_ADDR:
+		for (i = 0; i != MBOXES; i++)
+			mbs_cfg[i] = HIF_MBOX_START_ADDR(i);
+		break;
+	case HIF_DEVICE_GET_IRQ_PROC_MODE:
+		*ipm_cfg = HIF_DEVICE_IRQ_SYNC_ONLY;
+//		*ipm_cfg = HIF_DEVICE_IRQ_ASYNC_SYNC;
+		break;
+	default:
+		return A_ERROR;
+	}
+	return A_OK;
+}
+
+
+/* ----- Device probe and removal (Linux side) ----------------------------- */
+
+
+static int ar6000_do_activate(struct hif_device *hif)
+{
+	struct sdio_func *func = hif->func;
+	struct device *dev = &func->dev;
+	int ret;
+
+	dev_dbg(dev, "ar6000_do_activate\n");
+
+	sdio_claim_host(func);
+	sdio_enable_func(func);
+
+	INIT_LIST_HEAD(&hif->queue);
+	init_waitqueue_head(&hif->wait);
+	spin_lock_init(&hif->queue_lock);
+
+	ret = sdio_set_block_size(func, HIF_MBOX_BLOCK_SIZE);
+	if (ret < 0) {
+		dev_err(dev, "sdio_set_block_size returns %d\n", ret);
+		goto out_enabled;
+	}
+	ret = sdio_claim_irq(func, sdio_ar6000_irq);
+	if (ret) {
+		dev_err(dev, "sdio_claim_irq returns %d\n", ret);
+		goto out_enabled;
+	}
+	/* Set SDIO_BUS_CD_DISABLE in SDIO_CCCR_IF ? */
+#if 0
+	sdio_f0_writeb(func, SDIO_CCCR_CAP_E4MI, SDIO_CCCR_CAPS, &ret);
+	if (ret) {
+		dev_err(dev, "sdio_f0_writeb(SDIO_CCCR_CAPS) returns %d\n",
+		    ret);
+		goto out_got_irq;
+	}
+#else
+	if (0) /* avoid warning */
+		goto out_got_irq;
+#endif
+
+	sdio_release_host(func);
+
+	hif->io_task = kthread_run(io, hif, "ar6000_io");
+	ret = IS_ERR(hif->io_task);
+	if (ret) {
+		dev_err(dev, "kthread_run(ar6000_io): %d\n", ret);
+		goto out_func_ready;
+	}
+
+	ret = htcCallbacks.deviceInsertedHandler(hif);
+	if (ret == A_OK)
+		return 0;
+
+	dev_err(dev, "deviceInsertedHandler: %d\n", ret);
+
+	ret = kthread_stop(hif->io_task);
+	if (ret)
+		dev_err(dev, "kthread_stop (ar6000_io): %d\n", ret);
+
+out_func_ready:
+	sdio_claim_host(func);
+
+out_got_irq:
+	sdio_release_irq(func);
+
+out_enabled:
+	sdio_disable_func(func);
+	sdio_release_host(func);
+
+	return ret;
+}
+
+
+static void ar6000_do_deactivate(struct hif_device *hif)
+{
+	struct sdio_func *func = hif->func;
+	struct device *dev = &func->dev;
+	int ret;
+
+	dev_dbg(dev, "ar6000_do_deactivate\n");
+	if (!hif->active)
+		return;
+
+	if (mutex_trylock(&shutdown_lock)) {
+		/*
+		 * Funny, Atheros' HIF does this call, but this just puts us in
+		 * a recursion through HTCShutDown/HIFShutDown if unloading the
+		 * module.
+		 *
+		 * However, we need it for suspend/resume. See the comment at
+		 * HIFShutDown, below.
+		 */
+		ret = htcCallbacks.deviceRemovedHandler(hif->htc_handle, A_OK);
+		if (ret != A_OK)
+			dev_err(dev, "deviceRemovedHandler: %d\n", ret);
+		mutex_unlock(&shutdown_lock);
+	}
+	wait_queue_empty(hif);
+	ret = kthread_stop(hif->io_task);
+	if (ret)
+		dev_err(dev, "kthread_stop (ar6000_io): %d\n", ret);
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+}
+
+
+static int ar6000_activate(struct hif_device *hif)
+{
+	int ret = 0;
+
+	dev_dbg(&hif->func->dev, "ar6000_activate\n");
+	mutex_lock(&hif->activate_lock);
+	if (!hif->active) {
+		ret = ar6000_do_activate(hif);
+		if (ret) {
+			printk(KERN_ERR "%s: Failed to activate %d\n",
+				__func__, ret);
+			goto out;
+		}
+		hif->active = 1;
+	}
+out:
+	mutex_unlock(&hif->activate_lock);
+	return ret;
+}
+
+
+static void ar6000_deactivate(struct hif_device *hif)
+{
+	dev_dbg(&hif->func->dev, "ar6000_deactivate\n");
+	mutex_lock(&hif->activate_lock);
+	if (hif->active) {
+		ar6000_do_deactivate(hif);
+		hif->active = 0;
+	}
+	mutex_unlock(&hif->activate_lock);
+}
+
+
+static int ar6000_rfkill_cb(void *data, int on)
+{
+	struct hif_device *hif = data;
+	struct sdio_func *func = hif->func;
+	struct device *dev = &func->dev;
+
+	dev_dbg(dev, "ar6000_rfkill_cb: on %d\n", on);
+	if (on)
+		return ar6000_activate(hif);
+	ar6000_deactivate(hif);
+	return 0;
+}
+
+
+static int sdio_ar6000_probe(struct sdio_func *func,
+    const struct sdio_device_id *id)
+{
+	struct device *dev = &func->dev;
+	struct hif_device *hif;
+	int ret = 0;
+
+	dev_dbg(dev, "sdio_ar6000_probe\n");
+	BUG_ON(!htcCallbacks.deviceInsertedHandler);
+
+	hif = kzalloc(sizeof(*hif), GFP_KERNEL);
+	if (!hif)
+		return -ENOMEM;
+
+	sdio_set_drvdata(func, hif);
+	hif->func = func;
+	mutex_init(&hif->activate_lock);
+	hif->active = 0;
+
+	if (gta02_wlan_query_rfkill_lock())
+		ret = ar6000_activate(hif);
+	if (!ret) {
+		gta02_wlan_set_rfkill_cb(ar6000_rfkill_cb, hif);
+		return 0;
+	}
+	gta02_wlan_query_rfkill_unlock();
+	sdio_set_drvdata(func, NULL);
+	kfree(hif);
+	return ret;
+}
+
+
+static void sdio_ar6000_remove(struct sdio_func *func)
+{
+	struct device *dev = &func->dev;
+	HIF_DEVICE *hif = sdio_get_drvdata(func);
+
+	dev_dbg(dev, "sdio_ar6000_remove\n");
+	gta02_wlan_clear_rfkill_cb();
+	ar6000_deactivate(hif);
+	sdio_set_drvdata(func, NULL);
+	kfree(hif);
+}
+
+
+/* ----- Device registration/unregistration (called by HIF) ---------------- */
+
+
+#define ATHEROS_SDIO_DEVICE(id, offset) \
+    SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_##id | (offset))
+
+static const struct sdio_device_id sdio_ar6000_ids[] = {
+	{ ATHEROS_SDIO_DEVICE(AR6002, 0)	},
+	{ ATHEROS_SDIO_DEVICE(AR6002, 0x1)	},
+	{ ATHEROS_SDIO_DEVICE(AR6001, 0x8)	},
+	{ ATHEROS_SDIO_DEVICE(AR6001, 0x9)	},
+	{ ATHEROS_SDIO_DEVICE(AR6001, 0xa)	},
+	{ ATHEROS_SDIO_DEVICE(AR6001, 0xb)	},
+	{ /* end: all zeroes */			},
+};
+
+MODULE_DEVICE_TABLE(sdio, sdio_ar6000_ids);
+
+
+static struct sdio_driver sdio_ar6000_driver = {
+	.probe		= sdio_ar6000_probe,
+	.remove		= sdio_ar6000_remove,
+	.name		= "sdio_ar6000",
+	.id_table	= sdio_ar6000_ids,
+};
+
+
+int HIFInit(HTC_CALLBACKS *callbacks)
+{
+	int ret;
+
+	BUG_ON(!callbacks);
+
+	printk(KERN_DEBUG "HIFInit\n");
+	htcCallbacks = *callbacks;
+
+	ret = sdio_register_driver(&sdio_ar6000_driver);
+	if (ret) {
+		printk(KERN_ERR
+		    "sdio_register_driver(sdio_ar6000_driver): %d\n", ret);
+		return A_ERROR;
+	}
+
+	return 0;
+}
+
+
+/*
+ * We have four possible call chains here:
+ *
+ * System shutdown/reboot:
+ *
+ *   kernel_restart_prepare ...> device_shutdown ... > s3cmci_shutdown ->
+ *     mmc_remove_host ..> sdio_bus_remove -> sdio_ar6000_remove ->
+ *     ar6000_deactivate -> ar6000_do_deactivate ->
+ *     deviceRemovedHandler (HTCTargetRemovedHandler) -> HIFShutDownDevice
+ *
+ *   This is roughly the same sequence as suspend, described below.
+ *
+ * Module removal:
+ *
+ *   sys_delete_module -> ar6000_cleanup_module -> HTCShutDown ->
+ *     HIFShutDownDevice -> sdio_unregister_driver ...> sdio_bus_remove ->
+ *     sdio_ar6000_remove -> ar6000_deactivate -> ar6000_do_deactivate
+ *
+ *   In this case, HIFShutDownDevice must call sdio_unregister_driver to
+ *   notify the driver about its removal. ar6000_do_deactivate must not call
+ *   deviceRemovedHandler, because that would loop back into HIFShutDownDevice.
+ *
+ * Suspend:
+ *
+ *   device_suspend ...> s3cmci_suspend ...> sdio_bus_remove ->
+ *     sdio_ar6000_remove -> ar6000_deactivate -> ar6000_do_deactivate ->
+ *     deviceRemovedHandler (HTCTargetRemovedHandler) -> HIFShutDownDevice
+ *
+ *   We must call deviceRemovedHandler to inform the ar6k stack that the device
+ *   has been removed. Since HTCTargetRemovedHandler calls back into
+ *   HIFShutDownDevice, we must also prevent the call to
+ *   sdio_unregister_driver, or we'd end up recursing into the SDIO stack,
+ *   eventually deadlocking somewhere.
+ *
+ * rfkill:
+ *
+ *   rfkill_state_store -> rfkill_toggle_radio -> gta02_wlan_toggle_radio ->
+ *   ar6000_rfkill_cb -> ar6000_deactivate -> ar6000_do_deactivate ->
+ *     deviceRemovedHandler (HTCTargetRemovedHandler) -> HIFShutDownDevice
+ *
+ *   This is similar to suspend - only the entry point changes.
+ */
+
+void HIFShutDownDevice(HIF_DEVICE *hif)
+{
+	/* Beware, HTCShutDown calls us with hif == NULL ! */
+	if (mutex_trylock(&shutdown_lock)) {
+		sdio_unregister_driver(&sdio_ar6000_driver);
+		mutex_unlock(&shutdown_lock);
+	}
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/hif/hif.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/hif/hif.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/hif/hif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/hif/hif.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,824 @@
+/*
+ * @file: hif.c
+ *
+ * @abstract: HIF layer reference implementation for Atheros SDIO stack
+ *
+ * @notice: Copyright (c) 2004-2006 Atheros Communications Inc.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "hif_internal.h"
+
+/* ------ Static Variables ------ */
+
+/* ------ Global Variable Declarations ------- */
+SD_PNP_INFO Ids[] = {
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0xB,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0xA,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0x9,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6001_BASE | 0x8,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6002_BASE | 0x0,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+        .SDIO_ManufacturerID = MANUFACTURER_ID_AR6002_BASE | 0x1,
+        .SDIO_ManufacturerCode = MANUFACTURER_CODE,
+        .SDIO_FunctionClass = FUNCTION_CLASS,
+        .SDIO_FunctionNo = 1
+    },
+    {
+    }                      //list is null termintaed
+};
+
+TARGET_FUNCTION_CONTEXT FunctionContext = {
+    .function.Version    = CT_SDIO_STACK_VERSION_CODE,
+    .function.pName      = "sdio_wlan",
+    .function.MaxDevices = 1,
+    .function.NumDevices = 0,
+    .function.pIds       = Ids,
+    .function.pProbe     = hifDeviceInserted,
+    .function.pRemove    = hifDeviceRemoved,
+    .function.pSuspend   = NULL,
+    .function.pResume    = NULL,
+    .function.pWake      = NULL,
+    .function.pContext   = &FunctionContext,
+};
+
+HIF_DEVICE hifDevice[HIF_MAX_DEVICES];
+HTC_CALLBACKS htcCallbacks;
+BUS_REQUEST busRequest[BUS_REQUEST_MAX_NUM];
+static BUS_REQUEST *s_busRequestFreeQueue = NULL;
+OS_CRITICALSECTION lock;
+extern A_UINT32 onebitmode;
+extern A_UINT32 busspeedlow;
+
+#ifdef DEBUG
+extern A_UINT32 debughif;
+#define ATH_DEBUG_ERROR 1
+#define ATH_DEBUG_WARN  2
+#define ATH_DEBUG_TRACE 3
+#define _AR_DEBUG_PRINTX_ARG(arg...) arg
+#define AR_DEBUG_PRINTF(lvl, args)\
+    {if (lvl <= debughif)\
+        A_PRINTF(KERN_ALERT _AR_DEBUG_PRINTX_ARG args);\
+    }
+#else
+#define AR_DEBUG_PRINTF(lvl, args)
+#endif
+
+static BUS_REQUEST *hifAllocateBusRequest(void);
+static void hifFreeBusRequest(BUS_REQUEST *busrequest);
+static THREAD_RETURN insert_helper_func(POSKERNEL_HELPER pHelper);
+static void ResetAllCards(void);
+
+/* ------ Functions ------ */
+int HIFInit(HTC_CALLBACKS *callbacks)
+{
+    SDIO_STATUS status;
+    DBG_ASSERT(callbacks != NULL);
+
+    /* Store the callback and event handlers */
+    htcCallbacks.deviceInsertedHandler = callbacks->deviceInsertedHandler;
+    htcCallbacks.deviceRemovedHandler = callbacks->deviceRemovedHandler;
+    htcCallbacks.deviceSuspendHandler = callbacks->deviceSuspendHandler;
+    htcCallbacks.deviceResumeHandler = callbacks->deviceResumeHandler;
+    htcCallbacks.deviceWakeupHandler = callbacks->deviceWakeupHandler;
+    htcCallbacks.rwCompletionHandler = callbacks->rwCompletionHandler;
+    htcCallbacks.dsrHandler = callbacks->dsrHandler;
+
+    CriticalSectionInit(&lock);
+
+    /* Register with bus driver core */
+    status = SDIO_RegisterFunction(&FunctionContext.function);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+
+    return(0);
+}
+
+A_STATUS
+HIFReadWrite(HIF_DEVICE *device,
+             A_UINT32 address,
+             A_UCHAR *buffer,
+             A_UINT32 length,
+             A_UINT32 request,
+             void *context)
+{
+    A_UINT8 rw;
+    A_UINT8 mode;
+    A_UINT8 funcNo;
+    A_UINT8 opcode;
+    A_UINT16 count;
+    SDREQUEST *sdrequest;
+    SDIO_STATUS sdiostatus;
+    BUS_REQUEST *busrequest;
+    A_STATUS    status = A_OK;
+
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device: %p\n", device));
+
+    do {
+        busrequest = hifAllocateBusRequest();
+        if (busrequest == NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("HIF Unable to allocate bus request\n"));
+            status = A_NO_RESOURCE;
+            break;
+        }
+
+        sdrequest = busrequest->request;
+        busrequest->context = context;
+
+        sdrequest->pDataBuffer = buffer;
+        if (request & HIF_SYNCHRONOUS) {
+            sdrequest->Flags = SDREQ_FLAGS_RESP_SDIO_R5 | SDREQ_FLAGS_DATA_TRANS;
+            sdrequest->pCompleteContext = NULL;
+            sdrequest->pCompletion = NULL;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Execution mode: Synchronous\n"));
+        } else if (request & HIF_ASYNCHRONOUS) {
+            sdrequest->Flags = SDREQ_FLAGS_RESP_SDIO_R5 | SDREQ_FLAGS_DATA_TRANS |
+                               SDREQ_FLAGS_TRANS_ASYNC;
+            sdrequest->pCompleteContext = busrequest;
+            sdrequest->pCompletion = hifRWCompletionHandler;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Execution mode: Asynchronous\n"));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid execution mode: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        if (request & HIF_EXTENDED_IO) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Command type: CMD53\n"));
+            sdrequest->Command = CMD53;
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid command type: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        if (request & HIF_BLOCK_BASIS) {
+            mode = CMD53_BLOCK_BASIS;
+            sdrequest->BlockLen = HIF_MBOX_BLOCK_SIZE;
+            sdrequest->BlockCount = length / HIF_MBOX_BLOCK_SIZE;
+            count = sdrequest->BlockCount;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                            ("Block mode (BlockLen: %d, BlockCount: %d)\n",
+                            sdrequest->BlockLen, sdrequest->BlockCount));
+        } else if (request & HIF_BYTE_BASIS) {
+            mode = CMD53_BYTE_BASIS;
+            sdrequest->BlockLen = length;
+            sdrequest->BlockCount = 1;
+            count = sdrequest->BlockLen;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                            ("Byte mode (BlockLen: %d, BlockCount: %d)\n",
+                            sdrequest->BlockLen, sdrequest->BlockCount));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid data mode: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+#if 0
+        /* useful for checking register accesses */
+        if (length & 0x3) {
+            A_PRINTF(KERN_ALERT"HIF (%s) is not a multiple of 4 bytes, addr:0x%X, len:%d\n",
+                                request & HIF_WRITE ? "write":"read", address, length);
+        }
+#endif
+
+        if ((address >= HIF_MBOX_START_ADDR(0)) &&
+            (address <= HIF_MBOX_END_ADDR(3)))
+        {
+
+            DBG_ASSERT(length <= HIF_MBOX_WIDTH);
+
+            /*
+             * Mailbox write. Adjust the address so that the last byte
+             * falls on the EOM address.
+             */
+            address += (HIF_MBOX_WIDTH - length);
+        }
+
+
+
+        if (request & HIF_WRITE) {
+            rw = CMD53_WRITE;
+            sdrequest->Flags |= SDREQ_FLAGS_DATA_WRITE;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Direction: Write\n"));
+        } else if (request & HIF_READ) {
+            rw = CMD53_READ;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Direction: Read\n"));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid direction: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        if (request & HIF_FIXED_ADDRESS) {
+            opcode = CMD53_FIXED_ADDRESS;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Address mode: Fixed\n"));
+        } else if (request & HIF_INCREMENTAL_ADDRESS) {
+            opcode = CMD53_INCR_ADDRESS;
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Address mode: Incremental\n"));
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Invalid address mode: 0x%08x\n", request));
+            status = A_EINVAL;
+            break;
+        }
+
+        funcNo = SDDEVICE_GET_SDIO_FUNCNO(device->handle);
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Function number: %d\n", funcNo));
+        SDIO_SET_CMD53_ARG(sdrequest->Argument, rw, funcNo,
+                           mode, opcode, address, count);
+
+        /* Send the command out */
+        sdiostatus = SDDEVICE_CALL_REQUEST_FUNC(device->handle, sdrequest);
+
+        if (!SDIO_SUCCESS(sdiostatus)) {
+            status = A_ERROR;
+        }
+
+    } while (FALSE);
+
+    if (A_FAILED(status) || (request & HIF_SYNCHRONOUS)) {
+        if (busrequest != NULL) {
+            hifFreeBusRequest(busrequest);
+        }
+    }
+
+    if (A_FAILED(status) && (request & HIF_ASYNCHRONOUS)) {
+            /* call back async handler on failure */
+        htcCallbacks.rwCompletionHandler(context, status);
+    }
+
+    return status;
+}
+
+A_STATUS
+HIFConfigureDevice(HIF_DEVICE *device, HIF_DEVICE_CONFIG_OPCODE opcode,
+                   void *config, A_UINT32 configLen)
+{
+    A_UINT32 count;
+
+    switch(opcode) {
+        case HIF_DEVICE_GET_MBOX_BLOCK_SIZE:
+            ((A_UINT32 *)config)[0] = HIF_MBOX0_BLOCK_SIZE;
+            ((A_UINT32 *)config)[1] = HIF_MBOX1_BLOCK_SIZE;
+            ((A_UINT32 *)config)[2] = HIF_MBOX2_BLOCK_SIZE;
+            ((A_UINT32 *)config)[3] = HIF_MBOX3_BLOCK_SIZE;
+            break;
+
+        case HIF_DEVICE_GET_MBOX_ADDR:
+            for (count = 0; count < 4; count ++) {
+                ((A_UINT32 *)config)[count] = HIF_MBOX_START_ADDR(count);
+            }
+            break;
+        case HIF_DEVICE_GET_IRQ_PROC_MODE:
+                /* the SDIO stack allows the interrupts to be processed either way, ASYNC or SYNC */
+            *((HIF_DEVICE_IRQ_PROCESSING_MODE *)config) = HIF_DEVICE_IRQ_ASYNC_SYNC;
+            break;
+        default:
+            AR_DEBUG_PRINTF(ATH_DEBUG_WARN,
+                            ("Unsupported configuration opcode: %d\n", opcode));
+            return A_ERROR;
+    }
+
+    return A_OK;
+}
+
+void
+HIFShutDownDevice(HIF_DEVICE *device)
+{
+    A_UINT8 data;
+    A_UINT32 count;
+    SDIO_STATUS status;
+    SDCONFIG_BUS_MODE_DATA busSettings;
+    SDCONFIG_FUNC_ENABLE_DISABLE_DATA fData;
+
+    if (device != NULL) {
+        DBG_ASSERT(device->handle != NULL);
+
+        /* Remove the allocated current if any */
+        status = SDLIB_IssueConfig(device->handle,
+                                   SDCONFIG_FUNC_FREE_SLOT_CURRENT, NULL, 0);
+        DBG_ASSERT(SDIO_SUCCESS(status));
+
+        /* Disable the card */
+        fData.EnableFlags = SDCONFIG_DISABLE_FUNC;
+        fData.TimeOut = 1;
+        status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_ENABLE_DISABLE,
+                                   &fData, sizeof(fData));
+        DBG_ASSERT(SDIO_SUCCESS(status));
+
+        /* Perform a soft I/O reset */
+        data = SDIO_IO_RESET;
+        status = SDLIB_IssueCMD52(device->handle, 0, SDIO_IO_ABORT_REG,
+                                  &data, 1, 1);
+        DBG_ASSERT(SDIO_SUCCESS(status));
+
+        /*
+         * WAR - Codetelligence driver does not seem to shutdown correctly in 1
+         * bit mode. By default it configures the HC in the 4 bit. Its later in
+         * our driver that we switch to 1 bit mode. If we try to shutdown, the
+         * driver hangs so we revert to 4 bit mode, to be transparent to the
+         * underlying bus driver.
+         */
+        if (onebitmode) {
+            ZERO_OBJECT(busSettings);
+            busSettings.BusModeFlags = SDDEVICE_GET_BUSMODE_FLAGS(device->handle);
+            SDCONFIG_SET_BUS_WIDTH(busSettings.BusModeFlags,
+                                   SDCONFIG_BUS_WIDTH_4_BIT);
+
+            /* Issue config request to change the bus width to 4 bit */
+            status = SDLIB_IssueConfig(device->handle, SDCONFIG_BUS_MODE_CTRL,
+                                       &busSettings,
+                                       sizeof(SDCONFIG_BUS_MODE_DATA));
+            DBG_ASSERT(SDIO_SUCCESS(status));
+        }
+
+        /* Free the bus requests */
+        for (count = 0; count < BUS_REQUEST_MAX_NUM; count ++) {
+            SDDeviceFreeRequest(device->handle, busRequest[count].request);
+        }
+        /* Clean up the queue */
+        s_busRequestFreeQueue = NULL;
+    } else {
+            /* since we are unloading the driver anyways, reset all cards in case the SDIO card
+             * is externally powered and we are unloading the SDIO stack.  This avoids the problem when
+             * the SDIO stack is reloaded and attempts are made to re-enumerate a card that is already
+             * enumerated */
+        ResetAllCards();
+        /* Unregister with bus driver core */
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Unregistering with the bus driver\n"));
+        status = SDIO_UnregisterFunction(&FunctionContext.function);
+        DBG_ASSERT(SDIO_SUCCESS(status));
+    }
+}
+
+void
+hifRWCompletionHandler(SDREQUEST *request)
+{
+    A_STATUS status;
+    void *context;
+    BUS_REQUEST *busrequest;
+
+    if (SDIO_SUCCESS(request->Status)) {
+        status = A_OK;
+    } else {
+        status = A_ERROR;
+    }
+
+    DBG_ASSERT(status == A_OK);
+    busrequest = (BUS_REQUEST *) request->pCompleteContext;
+    context = (void *) busrequest->context;
+        /* free the request before calling the callback, in case the
+         * callback submits another request, this guarantees that
+         * there is at least 1 free request available everytime the callback
+         * is invoked */
+    hifFreeBusRequest(busrequest);
+    htcCallbacks.rwCompletionHandler(context, status);
+}
+
+void
+hifIRQHandler(void *context)
+{
+    A_STATUS status;
+    HIF_DEVICE *device;
+
+    device = (HIF_DEVICE *)context;
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device: %p\n", device));
+    status = htcCallbacks.dsrHandler(device->htc_handle);
+    DBG_ASSERT(status == A_OK);
+}
+
+BOOL
+hifDeviceInserted(SDFUNCTION *function, SDDEVICE *handle)
+{
+    BOOL enabled;
+    A_UINT8 data;
+    A_UINT32 count;
+    HIF_DEVICE *device;
+    SDIO_STATUS status;
+    A_UINT16 maxBlocks;
+    A_UINT16 maxBlockSize;
+    SDCONFIG_BUS_MODE_DATA busSettings;
+    SDCONFIG_FUNC_ENABLE_DISABLE_DATA fData;
+    TARGET_FUNCTION_CONTEXT *functionContext;
+    SDCONFIG_FUNC_SLOT_CURRENT_DATA slotCurrent;
+    SD_BUSCLOCK_RATE                currentBusClock;
+
+    DBG_ASSERT(function != NULL);
+    DBG_ASSERT(handle != NULL);
+
+    device = addHifDevice(handle);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device: %p\n", device));
+    functionContext =  (TARGET_FUNCTION_CONTEXT *)function->pContext;
+
+    /*
+     * Issue commands to get the manufacturer ID and stuff and compare it
+     * against the rev Id derived from the ID registered during the
+     * initialization process. Report the device only in the case there
+     * is a match. In the case od SDIO, the bus driver has already queried
+     * these details so we just need to use their data structures to get the
+     * relevant values. Infact, the driver has already matched it against
+     * the Ids that we registered with it so we dont need to the step here.
+     */
+
+    /* Configure the SDIO Bus Width */
+    if (onebitmode) {
+        data = SDIO_BUS_WIDTH_1_BIT;
+        status = SDLIB_IssueCMD52(handle, 0, SDIO_BUS_IF_REG, &data, 1, 1);
+        if (!SDIO_SUCCESS(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Unable to set the bus width to 1 bit\n"));
+            return FALSE;
+        }
+    }
+
+    /* Get current bus flags */
+    ZERO_OBJECT(busSettings);
+
+    busSettings.BusModeFlags = SDDEVICE_GET_BUSMODE_FLAGS(handle);
+    if (onebitmode) {
+        SDCONFIG_SET_BUS_WIDTH(busSettings.BusModeFlags,
+                               SDCONFIG_BUS_WIDTH_1_BIT);
+    }
+
+        /* get the current operating clock, the bus driver sets us up based
+         * on what our CIS reports and what the host controller can handle
+         * we can use this to determine whether we want to drop our clock rate
+         * down */
+    currentBusClock = SDDEVICE_GET_OPER_CLOCK(handle);
+    busSettings.ClockRate = currentBusClock;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("HIF currently running at: %d \n",currentBusClock));
+
+        /* see if HIF wants to run at a lower clock speed, we may already be
+         * at that lower clock speed */
+    if (currentBusClock > (SDIO_CLOCK_FREQUENCY_DEFAULT >> busspeedlow)) {
+        busSettings.ClockRate = SDIO_CLOCK_FREQUENCY_DEFAULT >> busspeedlow;
+        AR_DEBUG_PRINTF(ATH_DEBUG_WARN,
+                        ("HIF overriding clock to %d \n",busSettings.ClockRate));
+    }
+
+    /* Issue config request to override clock rate */
+    status = SDLIB_IssueConfig(handle, SDCONFIG_FUNC_CHANGE_BUS_MODE, &busSettings,
+                               sizeof(SDCONFIG_BUS_MODE_DATA));
+    if (!SDIO_SUCCESS(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                        ("Unable to configure the host clock\n"));
+        return FALSE;
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Configured clock: %d, Maximum clock: %d\n",
+                        busSettings.ActualClockRate,
+                        SDDEVICE_GET_MAX_CLOCK(handle)));
+    }
+
+    /*
+     * Check if the target supports block mode. This result of this check
+     * can be used to implement the HIFReadWrite API.
+     */
+    if (SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE(handle)) {
+        /* Limit block size to operational block limit or card function
+           capability */
+        maxBlockSize = min(SDDEVICE_GET_OPER_BLOCK_LEN(handle),
+                           SDDEVICE_GET_SDIO_FUNC_MAXBLKSIZE(handle));
+
+        /* check if the card support multi-block transfers */
+        if (!(SDDEVICE_GET_SDIOCARD_CAPS(handle) & SDIO_CAPS_MULTI_BLOCK)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Byte basis only\n"));
+
+            /* Limit block size to max byte basis */
+            maxBlockSize =  min(maxBlockSize,
+                                (A_UINT16)SDIO_MAX_LENGTH_BYTE_BASIS);
+            maxBlocks = 1;
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Multi-block capable\n"));
+            maxBlocks = SDDEVICE_GET_OPER_BLOCKS(handle);
+            status = SDLIB_SetFunctionBlockSize(handle, HIF_MBOX_BLOCK_SIZE);
+            if (!SDIO_SUCCESS(status)) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                                ("Failed to set block size. Err:%d\n", status));
+                return FALSE;
+            }
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Bytes Per Block: %d bytes, Block Count:%d \n",
+                        maxBlockSize, maxBlocks));
+    } else {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                        ("Function does not support Block Mode!\n"));
+        return FALSE;
+    }
+
+    /* Allocate the slot current */
+    status = SDLIB_GetDefaultOpCurrent(handle, &slotCurrent.SlotCurrent);
+    if (SDIO_SUCCESS(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Allocating Slot current: %d mA\n",
+                                slotCurrent.SlotCurrent));
+        status = SDLIB_IssueConfig(handle, SDCONFIG_FUNC_ALLOC_SLOT_CURRENT,
+                                   &slotCurrent, sizeof(slotCurrent));
+        if (!SDIO_SUCCESS(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                            ("Failed to allocate slot current %d\n", status));
+            return FALSE;
+        }
+    }
+
+    /* Enable the dragon function */
+    count = 0;
+    enabled = FALSE;
+    fData.TimeOut = 1;
+    fData.EnableFlags = SDCONFIG_ENABLE_FUNC;
+    while ((count++ < SDWLAN_ENABLE_DISABLE_TIMEOUT) && !enabled)
+    {
+        /* Enable dragon */
+        status = SDLIB_IssueConfig(handle, SDCONFIG_FUNC_ENABLE_DISABLE,
+                                   &fData, sizeof(fData));
+        if (!SDIO_SUCCESS(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                            ("Attempting to enable the card again\n"));
+            continue;
+        }
+
+        /* Mark the status as enabled */
+        enabled = TRUE;
+    }
+
+    /* Check if we were succesful in enabling the target */
+    if (!enabled) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERROR,
+                        ("Failed to communicate with the target\n"));
+        return FALSE;
+    }
+
+    /* Allocate the bus requests to be used later */
+    A_MEMZERO(busRequest, sizeof(busRequest));
+    for (count = 0; count < BUS_REQUEST_MAX_NUM; count ++) {
+        if ((busRequest[count].request = SDDeviceAllocRequest(handle)) == NULL){
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERROR, ("Unable to allocate memory\n"));
+            /* TODO: Free the memory that has already been allocated */
+            return FALSE;
+        }
+        hifFreeBusRequest(&busRequest[count]);
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                ("0x%08x = busRequest[%d].request = 0x%08x\n",
+				(unsigned int) &busRequest[count], count,
+				(unsigned int) busRequest[count].request));
+    }
+
+        /* Schedule a worker to handle device inserted, this is a temporary workaround
+         * to fix a deadlock if the device fails to intialize in the insertion handler
+         * The failure causes the instance to shutdown the HIF layer and unregister the
+         * function driver within the busdriver probe context which can deadlock
+         *
+         * NOTE: we cannot use the default work queue because that would block
+         * SD bus request processing for all synchronous I/O. We must use a kernel
+         * thread that is creating using the helper library.
+         * */
+
+    if (SDIO_SUCCESS(SDLIB_OSCreateHelper(&device->insert_helper,
+                         insert_helper_func,
+                         device))) {
+        device->helper_started = TRUE;
+    }
+
+    return TRUE;
+}
+
+static THREAD_RETURN insert_helper_func(POSKERNEL_HELPER pHelper)
+{
+
+    /*
+     * Adding a wait of around a second before we issue the very first
+     * command to dragon. During the process of loading/unloading the
+     * driver repeatedly it was observed that we get a data timeout
+     * while accessing function 1 registers in the chip. The theory at
+     * this point is that some initialization delay in dragon is
+     * causing the SDIO state in dragon core to be not ready even after
+     * the ready bit indicates that function 1 is ready. Accomodating
+     * for this behavior by adding some delay in the driver before it
+     * issues the first command after switching on dragon. Need to
+     * investigate this a bit more - TODO
+     */
+
+    A_MDELAY(1000);
+        /* Inform HTC */
+    if ((htcCallbacks.deviceInsertedHandler(SD_GET_OS_HELPER_CONTEXT(pHelper))) != A_OK) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRACE, ("Device rejected\n"));
+    }
+
+    return 0;
+}
+
+void
+HIFAckInterrupt(HIF_DEVICE *device)
+{
+    SDIO_STATUS status;
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    /* Acknowledge our function IRQ */
+    status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_ACK_IRQ,
+                               NULL, 0);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+}
+
+void
+HIFUnMaskInterrupt(HIF_DEVICE *device)
+{
+    SDIO_STATUS status;
+
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    /* Register the IRQ Handler */
+    SDDEVICE_SET_IRQ_HANDLER(device->handle, hifIRQHandler, device);
+
+    /* Unmask our function IRQ */
+    status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_UNMASK_IRQ,
+                               NULL, 0);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+}
+
+void HIFMaskInterrupt(HIF_DEVICE *device)
+{
+    SDIO_STATUS status;
+    DBG_ASSERT(device != NULL);
+    DBG_ASSERT(device->handle != NULL);
+
+    /* Mask our function IRQ */
+    status = SDLIB_IssueConfig(device->handle, SDCONFIG_FUNC_MASK_IRQ,
+                               NULL, 0);
+    DBG_ASSERT(SDIO_SUCCESS(status));
+
+    /* Unregister the IRQ Handler */
+    SDDEVICE_SET_IRQ_HANDLER(device->handle, NULL, NULL);
+}
+
+static BUS_REQUEST *hifAllocateBusRequest(void)
+{
+    BUS_REQUEST *busrequest;
+
+    /* Acquire lock */
+    CriticalSectionAcquire(&lock);
+
+    /* Remove first in list */
+    if((busrequest = s_busRequestFreeQueue) != NULL)
+    {
+        s_busRequestFreeQueue = busrequest->next;
+    }
+
+    /* Release lock */
+    CriticalSectionRelease(&lock);
+
+    return busrequest;
+}
+
+static void
+hifFreeBusRequest(BUS_REQUEST *busrequest)
+{
+    DBG_ASSERT(busrequest != NULL);
+
+    /* Acquire lock */
+    CriticalSectionAcquire(&lock);
+
+    /* Insert first in list */
+    busrequest->next = s_busRequestFreeQueue;
+    s_busRequestFreeQueue = busrequest;
+
+    /* Release lock */
+    CriticalSectionRelease(&lock);
+}
+
+void
+hifDeviceRemoved(SDFUNCTION *function, SDDEVICE *handle)
+{
+    A_STATUS status;
+    HIF_DEVICE *device;
+    DBG_ASSERT(function != NULL);
+    DBG_ASSERT(handle != NULL);
+
+    device = getHifDevice(handle);
+    status = htcCallbacks.deviceRemovedHandler(device->htc_handle, A_OK);
+
+        /* cleanup the helper thread */
+    if (device->helper_started) {
+        SDLIB_OSDeleteHelper(&device->insert_helper);
+        device->helper_started = FALSE;
+    }
+
+    delHifDevice(handle);
+    DBG_ASSERT(status == A_OK);
+}
+
+HIF_DEVICE *
+addHifDevice(SDDEVICE *handle)
+{
+    DBG_ASSERT(handle != NULL);
+    hifDevice[0].handle = handle;
+    return &hifDevice[0];
+}
+
+HIF_DEVICE *
+getHifDevice(SDDEVICE *handle)
+{
+    DBG_ASSERT(handle != NULL);
+    return &hifDevice[0];
+}
+
+void
+delHifDevice(SDDEVICE *handle)
+{
+    DBG_ASSERT(handle != NULL);
+    hifDevice[0].handle = NULL;
+}
+
+struct device*
+HIFGetOSDevice(HIF_DEVICE *device)
+{
+    return &device->handle->Device->dev;
+}
+
+static void ResetAllCards(void)
+{
+    UINT8       data;
+    SDIO_STATUS status;
+    int         i;
+
+    data = SDIO_IO_RESET;
+
+    /* set the I/O CARD reset bit:
+     * NOTE: we are exploiting a "feature" of the SDIO core that resets the core when you
+     * set the RES bit in the SDIO_IO_ABORT register.  This bit however "normally" resets the
+     * I/O functions leaving the SDIO core in the same state (as per SDIO spec).
+     * In this design, this reset can be used to reset the SDIO core itself */
+    for (i = 0; i < HIF_MAX_DEVICES; i++) {
+        if (hifDevice[i].handle != NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_TRACE,
+                        ("Issuing I/O Card reset for instance: %d \n",i));
+                /* set the I/O Card reset bit */
+            status = SDLIB_IssueCMD52(hifDevice[i].handle,
+                                      0,                    /* function 0 space */
+                                      SDIO_IO_ABORT_REG,
+                                      &data,
+                                      1,                    /* 1 byte */
+                                      TRUE);                /* write */
+        }
+    }
+
+}
+
+void HIFSetHandle(void *hif_handle, void *handle)
+{
+    HIF_DEVICE *device = (HIF_DEVICE *) hif_handle;
+
+    device->htc_handle = handle;
+
+    return;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/hif/hif_internal.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/hif/hif_internal.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/hif/hif_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/hif/hif_internal.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,102 @@
+/*
+ * @file: hif_internal.h
+ *
+ * @abstract: internal header file for hif layer
+ *
+ * @notice: Copyright (c) 2004-2006 Atheros Communications Inc.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include <linux/sdio/ctsystem.h>
+#include <linux/sdio/sdio_busdriver.h>
+#include <linux/sdio/_sdio_defs.h>
+#include <linux/sdio/sdio_lib.h>
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+#include "hif.h"
+
+#define MANUFACTURER_ID_AR6001_BASE        0x100
+#define MANUFACTURER_ID_AR6002_BASE        0x200
+#define FUNCTION_CLASS                     0x0
+#define MANUFACTURER_CODE                  0x271
+
+#define BUS_REQUEST_MAX_NUM                64
+
+#define SDIO_CLOCK_FREQUENCY_DEFAULT       25000000
+#define SDWLAN_ENABLE_DISABLE_TIMEOUT      20
+#define FLAGS_CARD_ENAB                    0x02
+#define FLAGS_CARD_IRQ_UNMSK               0x04
+
+#define HIF_MBOX_BLOCK_SIZE                128
+#define HIF_MBOX_BASE_ADDR                 0x800
+#define HIF_MBOX_WIDTH                     0x800
+#define HIF_MBOX0_BLOCK_SIZE               1
+#define HIF_MBOX1_BLOCK_SIZE               HIF_MBOX_BLOCK_SIZE
+#define HIF_MBOX2_BLOCK_SIZE               HIF_MBOX_BLOCK_SIZE
+#define HIF_MBOX3_BLOCK_SIZE               HIF_MBOX_BLOCK_SIZE
+
+#define HIF_MBOX_START_ADDR(mbox)                        \
+    HIF_MBOX_BASE_ADDR + mbox * HIF_MBOX_WIDTH
+
+#define HIF_MBOX_END_ADDR(mbox)	                         \
+    HIF_MBOX_START_ADDR(mbox) + HIF_MBOX_WIDTH - 1
+
+struct hif_device {
+    SDDEVICE *handle;
+    void *htc_handle;
+    OSKERNEL_HELPER insert_helper;
+    BOOL  helper_started;
+};
+
+typedef struct target_function_context {
+    SDFUNCTION           function; /* function description of the bus driver */
+    OS_SEMAPHORE         instanceSem; /* instance lock. Unused */
+    SDLIST               instanceList; /* list of instances. Unused */
+} TARGET_FUNCTION_CONTEXT;
+
+typedef struct bus_request {
+    struct bus_request *next;
+    SDREQUEST *request;
+    void *context;
+} BUS_REQUEST;
+
+BOOL
+hifDeviceInserted(SDFUNCTION *function, SDDEVICE *device);
+
+void
+hifDeviceRemoved(SDFUNCTION *function, SDDEVICE *device);
+
+SDREQUEST *
+hifAllocateDeviceRequest(SDDEVICE *device);
+
+void
+hifFreeDeviceRequest(SDREQUEST *request);
+
+void
+hifRWCompletionHandler(SDREQUEST *request);
+
+void
+hifIRQHandler(void *context);
+
+HIF_DEVICE *
+addHifDevice(SDDEVICE *handle);
+
+HIF_DEVICE *
+getHifDevice(SDDEVICE *handle);
+
+void
+delHifDevice(SDDEVICE *handle);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/ar6k.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/ar6k.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/ar6k.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/ar6k.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,991 @@
+/*
+ * AR6K device layer that handles register level I/O
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "AR6Khwreg.h"
+#include "a_osapi.h"
+#include "a_debug.h"
+#include "hif.h"
+#include "htc_packet.h"
+#include "ar6k.h"
+
+#define MAILBOX_FOR_BLOCK_SIZE 1
+
+extern A_UINT32 resetok;
+
+static A_STATUS DevEnableInterrupts(AR6K_DEVICE *pDev);
+static A_STATUS DevDisableInterrupts(AR6K_DEVICE *pDev);
+
+#define LOCK_AR6K(p)      A_MUTEX_LOCK(&(p)->Lock);
+#define UNLOCK_AR6K(p)    A_MUTEX_UNLOCK(&(p)->Lock);
+
+void AR6KFreeIOPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket)
+{
+    LOCK_AR6K(pDev);
+    HTC_PACKET_ENQUEUE(&pDev->RegisterIOList,pPacket);
+    UNLOCK_AR6K(pDev);
+}
+
+HTC_PACKET *AR6KAllocIOPacket(AR6K_DEVICE *pDev)
+{
+    HTC_PACKET *pPacket;
+
+    LOCK_AR6K(pDev);
+    pPacket = HTC_PACKET_DEQUEUE(&pDev->RegisterIOList);
+    UNLOCK_AR6K(pDev);
+
+    return pPacket;
+}
+
+A_STATUS DevSetup(AR6K_DEVICE *pDev)
+{
+    A_UINT32 mailboxaddrs[AR6K_MAILBOXES];
+    A_UINT32 blocksizes[AR6K_MAILBOXES];
+    A_STATUS status = A_OK;
+    int      i;
+
+    AR_DEBUG_ASSERT(AR6K_IRQ_PROC_REGS_SIZE == 16);
+    AR_DEBUG_ASSERT(AR6K_IRQ_ENABLE_REGS_SIZE == 4);
+
+    do {
+            /* give a handle to HIF for this target */
+        HIFSetHandle(pDev->HIFDevice, (void *)pDev);
+            /* initialize our free list of IO packets */
+        INIT_HTC_PACKET_QUEUE(&pDev->RegisterIOList);
+        A_MUTEX_INIT(&pDev->Lock);
+
+            /* get the addresses for all 4 mailboxes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_ADDR,
+                                    mailboxaddrs, sizeof(mailboxaddrs));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* carve up register I/O packets (these are for ASYNC register I/O ) */
+        for (i = 0; i < AR6K_MAX_REG_IO_BUFFERS; i++) {
+            HTC_PACKET *pIOPacket;
+            pIOPacket = &pDev->RegIOBuffers[i].HtcPacket;
+            SET_HTC_PACKET_INFO_RX_REFILL(pIOPacket,
+                                          pDev,
+                                          pDev->RegIOBuffers[i].Buffer,
+                                          AR6K_REG_IO_BUFFER_SIZE,
+                                          0); /* don't care */
+            AR6KFreeIOPacket(pDev,pIOPacket);
+        }
+
+            /* get the address of the mailbox we are using */
+        pDev->MailboxAddress = mailboxaddrs[HTC_MAILBOX];
+
+            /* get the block sizes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    blocksizes, sizeof(blocksizes));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* note: we actually get the block size of a mailbox other than 0, for SDIO the block
+             * size on mailbox 0 is artificially set to 1.  So we use the block size that is set
+             * for the other 3 mailboxes */
+        pDev->BlockSize = blocksizes[MAILBOX_FOR_BLOCK_SIZE];
+            /* must be a power of 2 */
+        AR_DEBUG_ASSERT((pDev->BlockSize & (pDev->BlockSize - 1)) == 0);
+
+            /* assemble mask, used for padding to a block */
+        pDev->BlockMask = pDev->BlockSize - 1;
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("BlockSize: %d, MailboxAddress:0x%X \n",
+                    pDev->BlockSize, pDev->MailboxAddress));
+
+        pDev->GetPendingEventsFunc = NULL;
+            /* see if the HIF layer implements the get pending events function  */
+        HIFConfigureDevice(pDev->HIFDevice,
+                           HIF_DEVICE_GET_PENDING_EVENTS_FUNC,
+                           &pDev->GetPendingEventsFunc,
+                           sizeof(pDev->GetPendingEventsFunc));
+
+            /* assume we can process HIF interrupt events asynchronously */
+        pDev->HifIRQProcessingMode = HIF_DEVICE_IRQ_ASYNC_SYNC;
+
+            /* see if the HIF layer overrides this assumption */
+        HIFConfigureDevice(pDev->HIFDevice,
+                           HIF_DEVICE_GET_IRQ_PROC_MODE,
+                           &pDev->HifIRQProcessingMode,
+                           sizeof(pDev->HifIRQProcessingMode));
+
+        switch (pDev->HifIRQProcessingMode) {
+            case HIF_DEVICE_IRQ_SYNC_ONLY:
+                AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF Interrupt processing is SYNC ONLY\n"));
+                break;
+            case HIF_DEVICE_IRQ_ASYNC_SYNC:
+                AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF Interrupt processing is ASYNC and SYNC\n"));
+                break;
+            default:
+                AR_DEBUG_ASSERT(FALSE);
+        }
+
+        pDev->HifMaskUmaskRecvEvent = NULL;
+
+            /* see if the HIF layer implements the mask/unmask recv events function  */
+        HIFConfigureDevice(pDev->HIFDevice,
+                           HIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC,
+                           &pDev->HifMaskUmaskRecvEvent,
+                           sizeof(pDev->HifMaskUmaskRecvEvent));
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("HIF special overrides : 0x%X , 0x%X\n",
+                 (A_UINT32)pDev->GetPendingEventsFunc, (A_UINT32)pDev->HifMaskUmaskRecvEvent));
+
+        status = DevDisableInterrupts(pDev);
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+            /* make sure handle is cleared */
+        HIFSetHandle(pDev->HIFDevice, NULL);
+    }
+
+    return status;
+
+}
+
+static A_STATUS DevEnableInterrupts(AR6K_DEVICE *pDev)
+{
+    A_STATUS                  status;
+    AR6K_IRQ_ENABLE_REGISTERS regs;
+
+    LOCK_AR6K(pDev);
+
+        /* Enable all the interrupts except for the dragon interrupt */
+    pDev->IrqEnableRegisters.int_status_enable = INT_STATUS_ENABLE_ERROR_SET(0x01) |
+                                      INT_STATUS_ENABLE_CPU_SET(0x01) |
+                                      INT_STATUS_ENABLE_COUNTER_SET(0x01);
+
+    if (NULL == pDev->GetPendingEventsFunc) {
+        pDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    } else {
+        /* The HIF layer provided us with a pending events function which means that
+         * the detection of pending mbox messages is handled in the HIF layer.
+         * This is the case for the SPI2 interface.
+         * In the normal case we enable MBOX interrupts, for the case
+         * with HIFs that offer this mechanism, we keep these interrupts
+         * masked */
+        pDev->IrqEnableRegisters.int_status_enable &= ~INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    }
+
+
+    /* Set up the CPU Interrupt Status Register */
+    pDev->IrqEnableRegisters.cpu_int_status_enable = CPU_INT_STATUS_ENABLE_BIT_SET(0x00);
+
+    /* Set up the Error Interrupt Status Register */
+    pDev->IrqEnableRegisters.error_status_enable =
+                                  ERROR_STATUS_ENABLE_RX_UNDERFLOW_SET(0x01) |
+                                  ERROR_STATUS_ENABLE_TX_OVERFLOW_SET(0x01);
+
+    /* Set up the Counter Interrupt Status Register (only for debug interrupt to catch fatal errors) */
+    pDev->IrqEnableRegisters.counter_int_status_enable =
+        COUNTER_INT_STATUS_ENABLE_BIT_SET(AR6K_TARGET_DEBUG_INTR_MASK);
+
+        /* copy into our temp area */
+    A_MEMCPY(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);
+
+    UNLOCK_AR6K(pDev);
+
+        /* always synchronous */
+    status = HIFReadWrite(pDev->HIFDevice,
+                          INT_STATUS_ENABLE_ADDRESS,
+                          &regs.int_status_enable,
+                          AR6K_IRQ_ENABLE_REGS_SIZE,
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        /* Can't write it for some reason */
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                        ("Failed to update interrupt control registers err: %d\n", status));
+
+    }
+
+    return status;
+}
+
+static A_STATUS DevDisableInterrupts(AR6K_DEVICE *pDev)
+{
+    AR6K_IRQ_ENABLE_REGISTERS regs;
+
+    LOCK_AR6K(pDev);
+        /* Disable all interrupts */
+    pDev->IrqEnableRegisters.int_status_enable = 0;
+    pDev->IrqEnableRegisters.cpu_int_status_enable = 0;
+    pDev->IrqEnableRegisters.error_status_enable = 0;
+    pDev->IrqEnableRegisters.counter_int_status_enable = 0;
+        /* copy into our temp area */
+    A_MEMCPY(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);
+
+    UNLOCK_AR6K(pDev);
+
+        /* always synchronous */
+    return HIFReadWrite(pDev->HIFDevice,
+                        INT_STATUS_ENABLE_ADDRESS,
+                        &regs.int_status_enable,
+                        AR6K_IRQ_ENABLE_REGS_SIZE,
+                        HIF_WR_SYNC_BYTE_INC,
+                        NULL);
+}
+
+/* enable device interrupts */
+A_STATUS DevUnmaskInterrupts(AR6K_DEVICE *pDev)
+{
+        /* Unmask the host controller interrupts */
+    HIFUnMaskInterrupt(pDev->HIFDevice);
+
+    return DevEnableInterrupts(pDev);
+}
+
+/* disable all device interrupts */
+A_STATUS DevMaskInterrupts(AR6K_DEVICE *pDev)
+{
+    A_STATUS status;
+
+    status = DevDisableInterrupts(pDev);
+
+    if (A_SUCCESS(status)) {
+            /* Disable the interrupt at the HIF layer */
+        HIFMaskInterrupt(pDev->HIFDevice);
+    }
+
+    return status;
+}
+
+/* callback when our fetch to enable/disable completes */
+static void DevDoEnableDisableRecvAsyncHandler(void *Context, HTC_PACKET *pPacket)
+{
+    AR6K_DEVICE *pDev = (AR6K_DEVICE *)Context;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevDoEnableDisableRecvAsyncHandler: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+    if (A_FAILED(pPacket->Status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" Failed to disable receiver, status:%d \n", pPacket->Status));
+    }
+        /* free this IO packet */
+    AR6KFreeIOPacket(pDev,pPacket);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevDoEnableDisableRecvAsyncHandler \n"));
+}
+
+/* disable packet reception (used in case the host runs out of buffers)
+ * this is the "override" method when the HIF reports another methods to
+ * disable recv events */
+static A_STATUS DevDoEnableDisableRecvOverride(AR6K_DEVICE *pDev, A_BOOL EnableRecv, A_BOOL AsyncMode)
+{
+    A_STATUS                  status = A_OK;
+    HTC_PACKET                *pIOPacket = NULL;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC,("DevDoEnableDisableRecvOverride: Enable:%d Mode:%d\n",
+            EnableRecv,AsyncMode));
+
+    do {
+
+        if (AsyncMode) {
+
+            pIOPacket = AR6KAllocIOPacket(pDev);
+
+            if (NULL == pIOPacket) {
+                status = A_NO_MEMORY;
+                AR_DEBUG_ASSERT(FALSE);
+                break;
+            }
+
+                /* stick in our completion routine when the I/O operation completes */
+            pIOPacket->Completion = DevDoEnableDisableRecvAsyncHandler;
+            pIOPacket->pContext = pDev;
+
+                /* call the HIF layer override and do this asynchronously */
+            status = pDev->HifMaskUmaskRecvEvent(pDev->HIFDevice,
+                                                 EnableRecv ? HIF_UNMASK_RECV : HIF_MASK_RECV,
+                                                 pIOPacket);
+            break;
+        }
+
+            /* if we get here we are doing it synchronously */
+        status = pDev->HifMaskUmaskRecvEvent(pDev->HIFDevice,
+                                             EnableRecv ? HIF_UNMASK_RECV : HIF_MASK_RECV,
+                                             NULL);
+
+    } while (FALSE);
+
+    if (A_FAILED(status) && (pIOPacket != NULL)) {
+        AR6KFreeIOPacket(pDev,pIOPacket);
+    }
+
+    return status;
+}
+
+/* disable packet reception (used in case the host runs out of buffers)
+ * this is the "normal" method using the interrupt enable registers through
+ * the host I/F */
+static A_STATUS DevDoEnableDisableRecvNormal(AR6K_DEVICE *pDev, A_BOOL EnableRecv, A_BOOL AsyncMode)
+{
+    A_STATUS                  status = A_OK;
+    HTC_PACKET                *pIOPacket = NULL;
+    AR6K_IRQ_ENABLE_REGISTERS regs;
+
+        /* take the lock to protect interrupt enable shadows */
+    LOCK_AR6K(pDev);
+
+    if (EnableRecv) {
+        pDev->IrqEnableRegisters.int_status_enable |= INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    } else {
+        pDev->IrqEnableRegisters.int_status_enable &= ~INT_STATUS_ENABLE_MBOX_DATA_SET(0x01);
+    }
+
+        /* copy into our temp area */
+    A_MEMCPY(&regs,&pDev->IrqEnableRegisters,AR6K_IRQ_ENABLE_REGS_SIZE);
+    UNLOCK_AR6K(pDev);
+
+    do {
+
+        if (AsyncMode) {
+
+            pIOPacket = AR6KAllocIOPacket(pDev);
+
+            if (NULL == pIOPacket) {
+                status = A_NO_MEMORY;
+                AR_DEBUG_ASSERT(FALSE);
+                break;
+            }
+
+                /* copy values to write to our async I/O buffer */
+            A_MEMCPY(pIOPacket->pBuffer,&regs,AR6K_IRQ_ENABLE_REGS_SIZE);
+
+                /* stick in our completion routine when the I/O operation completes */
+            pIOPacket->Completion = DevDoEnableDisableRecvAsyncHandler;
+            pIOPacket->pContext = pDev;
+
+                /* write it out asynchronously */
+            HIFReadWrite(pDev->HIFDevice,
+                         INT_STATUS_ENABLE_ADDRESS,
+                         pIOPacket->pBuffer,
+                         AR6K_IRQ_ENABLE_REGS_SIZE,
+                         HIF_WR_ASYNC_BYTE_INC,
+                         pIOPacket);
+            break;
+        }
+
+        /* if we get here we are doing it synchronously */
+
+        status = HIFReadWrite(pDev->HIFDevice,
+                              INT_STATUS_ENABLE_ADDRESS,
+                              &regs.int_status_enable,
+                              AR6K_IRQ_ENABLE_REGS_SIZE,
+                              HIF_WR_SYNC_BYTE_INC,
+                              NULL);
+
+    } while (FALSE);
+
+    if (A_FAILED(status) && (pIOPacket != NULL)) {
+        AR6KFreeIOPacket(pDev,pIOPacket);
+    }
+
+    return status;
+}
+
+
+A_STATUS DevStopRecv(AR6K_DEVICE *pDev, A_BOOL AsyncMode)
+{
+    if (NULL == pDev->HifMaskUmaskRecvEvent) {
+        return DevDoEnableDisableRecvNormal(pDev,FALSE,AsyncMode);
+    } else {
+        return DevDoEnableDisableRecvOverride(pDev,FALSE,AsyncMode);
+    }
+}
+
+A_STATUS DevEnableRecv(AR6K_DEVICE *pDev, A_BOOL AsyncMode)
+{
+    if (NULL == pDev->HifMaskUmaskRecvEvent) {
+        return DevDoEnableDisableRecvNormal(pDev,TRUE,AsyncMode);
+    } else {
+        return DevDoEnableDisableRecvOverride(pDev,TRUE,AsyncMode);
+    }
+}
+
+void DevDumpRegisters(AR6K_IRQ_PROC_REGISTERS   *pIrqProcRegs,
+                      AR6K_IRQ_ENABLE_REGISTERS *pIrqEnableRegs)
+{
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_DUMP, ("\n<------- Register Table -------->\n"));
+
+    if (pIrqProcRegs != NULL) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Int Status:               0x%x\n",pIrqProcRegs->host_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("CPU Int Status:            0x%x\n",pIrqProcRegs->cpu_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Error Int Status:          0x%x\n",pIrqProcRegs->error_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Counter Int Status:        0x%x\n",pIrqProcRegs->counter_int_status));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Mbox Frame:                0x%x\n",pIrqProcRegs->mbox_frame));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Rx Lookahead Valid:        0x%x\n",pIrqProcRegs->rx_lookahead_valid));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Rx Lookahead 0:            0x%x\n",pIrqProcRegs->rx_lookahead[0]));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Rx Lookahead 1:            0x%x\n",pIrqProcRegs->rx_lookahead[1]));
+    }
+
+    if (pIrqEnableRegs != NULL) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Int Status Enable:         0x%x\n",pIrqEnableRegs->int_status_enable));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP,
+            ("Counter Int Status Enable: 0x%x\n",pIrqEnableRegs->counter_int_status_enable));
+        AR_DEBUG_PRINTF(ATH_DEBUG_DUMP, ("<------------------------------->\n"));
+    }
+}
+
+
+#ifdef MBOXHW_UNIT_TEST
+
+
+/* This is a mailbox hardware unit test that must be called in a schedulable context
+ * This test is very simple, it will send a list of buffers with a counting pattern
+ * and the target will invert the data and send the message back
+ *
+ * the unit test has the following constraints:
+ *
+ * The target has at least 8 buffers of 256 bytes each. The host will send
+ * the following pattern of buffers in rapid succession :
+ *
+ * 1 buffer - 128 bytes
+ * 1 buffer - 256 bytes
+ * 1 buffer - 512 bytes
+ * 1 buffer - 1024 bytes
+ *
+ * The host will send the buffers to one mailbox and wait for buffers to be reflected
+ * back from the same mailbox. The target sends the buffers FIFO order.
+ * Once the final buffer has been received for a mailbox, the next mailbox is tested.
+ *
+ *
+ * Note:  To simplifythe test , we assume that the chosen buffer sizes
+ *        will fall on a nice block pad
+ *
+ * It is expected that higher-order tests will be written to stress the mailboxes using
+ * a message-based protocol (with some performance timming) that can create more
+ * randomness in the packets sent over mailboxes.
+ *
+ * */
+
+#define A_ROUND_UP_PWR2(x, align)    (((int) (x) + ((align)-1)) & ~((align)-1))
+
+#define BUFFER_BLOCK_PAD 128
+
+#if 0
+#define BUFFER1 128
+#define BUFFER2 256
+#define BUFFER3 512
+#define BUFFER4 1024
+#endif
+
+#if 1
+#define BUFFER1 80
+#define BUFFER2 200
+#define BUFFER3 444
+#define BUFFER4 800
+#endif
+
+#define TOTAL_BYTES (A_ROUND_UP_PWR2(BUFFER1,BUFFER_BLOCK_PAD) + \
+                     A_ROUND_UP_PWR2(BUFFER2,BUFFER_BLOCK_PAD) + \
+                     A_ROUND_UP_PWR2(BUFFER3,BUFFER_BLOCK_PAD) + \
+                     A_ROUND_UP_PWR2(BUFFER4,BUFFER_BLOCK_PAD) )
+
+#define TEST_BYTES (BUFFER1 +  BUFFER2 + BUFFER3 + BUFFER4)
+
+#define TEST_CREDITS_RECV_TIMEOUT 100
+
+static A_UINT8  g_Buffer[TOTAL_BYTES];
+static A_UINT32 g_MailboxAddrs[AR6K_MAILBOXES];
+static A_UINT32 g_BlockSizes[AR6K_MAILBOXES];
+
+#define BUFFER_PROC_LIST_DEPTH 4
+
+typedef struct _BUFFER_PROC_LIST{
+    A_UINT8  *pBuffer;
+    A_UINT32 length;
+}BUFFER_PROC_LIST;
+
+
+#define PUSH_BUFF_PROC_ENTRY(pList,len,pCurrpos) \
+{                                                   \
+    (pList)->pBuffer = (pCurrpos);                  \
+    (pList)->length = (len);                        \
+    (pCurrpos) += (len);                            \
+    (pList)++;                                      \
+}
+
+/* a simple and crude way to send different "message" sizes */
+static void AssembleBufferList(BUFFER_PROC_LIST *pList)
+{
+    A_UINT8 *pBuffer = g_Buffer;
+
+#if BUFFER_PROC_LIST_DEPTH < 4
+#error "Buffer processing list depth is not deep enough!!"
+#endif
+
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER1,pBuffer);
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER2,pBuffer);
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER3,pBuffer);
+    PUSH_BUFF_PROC_ENTRY(pList,BUFFER4,pBuffer);
+
+}
+
+#define FILL_ZERO     TRUE
+#define FILL_COUNTING FALSE
+static void InitBuffers(A_BOOL Zero)
+{
+    A_UINT16 *pBuffer16 = (A_UINT16 *)g_Buffer;
+    int      i;
+
+        /* fill buffer with 16 bit counting pattern or zeros */
+    for (i = 0; i <  (TOTAL_BYTES / 2) ; i++) {
+        if (!Zero) {
+            pBuffer16[i] = (A_UINT16)i;
+        } else {
+            pBuffer16[i] = 0;
+        }
+    }
+}
+
+
+static A_BOOL CheckOneBuffer(A_UINT16 *pBuffer16, int Length)
+{
+    int      i;
+    A_UINT16 startCount;
+    A_BOOL   success = TRUE;
+
+        /* get the starting count */
+    startCount = pBuffer16[0];
+        /* invert it, this is the expected value */
+    startCount = ~startCount;
+        /* scan the buffer and verify */
+    for (i = 0; i < (Length / 2) ; i++,startCount++) {
+            /* target will invert all the data */
+        if ((A_UINT16)pBuffer16[i] != (A_UINT16)~startCount) {
+            success = FALSE;
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Invalid Data Got:0x%X, Expecting:0x%X (offset:%d, total:%d) \n",
+                        pBuffer16[i], ((A_UINT16)~startCount), i, Length));
+             AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("0x%X 0x%X 0x%X 0x%X \n",
+                        pBuffer16[i], pBuffer16[i + 1], pBuffer16[i + 2],pBuffer16[i+3]));
+            break;
+        }
+    }
+
+    return success;
+}
+
+static A_BOOL CheckBuffers(void)
+{
+    int      i;
+    A_BOOL   success = TRUE;
+    BUFFER_PROC_LIST checkList[BUFFER_PROC_LIST_DEPTH];
+
+        /* assemble the list */
+    AssembleBufferList(checkList);
+
+        /* scan the buffers and verify */
+    for (i = 0; i < BUFFER_PROC_LIST_DEPTH ; i++) {
+        success = CheckOneBuffer((A_UINT16 *)checkList[i].pBuffer, checkList[i].length);
+        if (!success) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Buffer : 0x%X, Length:%d failed verify \n",
+                        (A_UINT32)checkList[i].pBuffer, checkList[i].length));
+            break;
+        }
+    }
+
+    return success;
+}
+
+    /* find the end marker for the last buffer we will be sending */
+static A_UINT16 GetEndMarker(void)
+{
+    A_UINT8  *pBuffer;
+    BUFFER_PROC_LIST checkList[BUFFER_PROC_LIST_DEPTH];
+
+        /* fill up buffers with the normal counting pattern */
+    InitBuffers(FILL_COUNTING);
+
+        /* assemble the list we will be sending down */
+    AssembleBufferList(checkList);
+        /* point to the last 2 bytes of the last buffer */
+    pBuffer = &(checkList[BUFFER_PROC_LIST_DEPTH - 1].pBuffer[(checkList[BUFFER_PROC_LIST_DEPTH - 1].length) - 2]);
+
+        /* the last count in the last buffer is the marker */
+    return (A_UINT16)pBuffer[0] | ((A_UINT16)pBuffer[1] << 8);
+}
+
+#define ATH_PRINT_OUT_ZONE ATH_DEBUG_ERR
+
+/* send the ordered buffers to the target */
+static A_STATUS SendBuffers(AR6K_DEVICE *pDev, int mbox)
+{
+    A_STATUS         status = A_OK;
+    A_UINT32         request = HIF_WR_SYNC_BLOCK_INC;
+    BUFFER_PROC_LIST sendList[BUFFER_PROC_LIST_DEPTH];
+    int              i;
+    int              totalBytes = 0;
+    int              paddedLength;
+    int              totalwPadding = 0;
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Sending buffers on mailbox : %d \n",mbox));
+
+        /* fill buffer with counting pattern */
+    InitBuffers(FILL_COUNTING);
+
+        /* assemble the order in which we send */
+    AssembleBufferList(sendList);
+
+    for (i = 0; i < BUFFER_PROC_LIST_DEPTH; i++) {
+
+            /* we are doing block transfers, so we need to pad everything to a block size */
+        paddedLength = (sendList[i].length + (g_BlockSizes[mbox] - 1)) &
+                       (~(g_BlockSizes[mbox] - 1));
+
+            /* send each buffer synchronously */
+        status = HIFReadWrite(pDev->HIFDevice,
+                              g_MailboxAddrs[mbox],
+                              sendList[i].pBuffer,
+                              paddedLength,
+                              request,
+                              NULL);
+        if (status != A_OK) {
+            break;
+        }
+        totalBytes += sendList[i].length;
+        totalwPadding += paddedLength;
+    }
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Sent %d bytes (%d padded bytes) to mailbox : %d \n",totalBytes,totalwPadding,mbox));
+
+    return status;
+}
+
+/* poll the mailbox credit counter until we get a credit or timeout */
+static A_STATUS GetCredits(AR6K_DEVICE *pDev, int mbox, int *pCredits)
+{
+    A_STATUS status = A_OK;
+    int      timeout = TEST_CREDITS_RECV_TIMEOUT;
+    A_UINT8  credits = 0;
+    A_UINT32 address;
+
+    while (TRUE) {
+
+            /* Read the counter register to get credits, this auto-decrements  */
+        address = COUNT_DEC_ADDRESS + (AR6K_MAILBOXES + mbox) * 4;
+        status = HIFReadWrite(pDev->HIFDevice, address, &credits, sizeof(credits),
+                              HIF_RD_SYNC_BYTE_FIX, NULL);
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                ("Unable to decrement the command credit count register (mbox=%d)\n",mbox));
+            status = A_ERROR;
+            break;
+        }
+
+        if (credits) {
+            break;
+        }
+
+        timeout--;
+
+        if (timeout <= 0) {
+              AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" Timeout reading credit registers (mbox=%d, address:0x%X) \n",mbox,address));
+            status = A_ERROR;
+            break;
+        }
+
+         /* delay a little, target may not be ready */
+         msleep(1000);
+
+    }
+
+    if (status == A_OK) {
+        *pCredits = credits;
+    }
+
+    return status;
+}
+
+
+/* wait for the buffers to come back */
+static A_STATUS RecvBuffers(AR6K_DEVICE *pDev, int mbox)
+{
+    A_STATUS         status = A_OK;
+    A_UINT32         request = HIF_RD_SYNC_BLOCK_INC;
+    BUFFER_PROC_LIST recvList[BUFFER_PROC_LIST_DEPTH];
+    int              curBuffer;
+    int              credits;
+    int              i;
+    int              totalBytes = 0;
+    int              paddedLength;
+    int              totalwPadding = 0;
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Waiting for buffers on mailbox : %d \n",mbox));
+
+        /* zero the buffers */
+    InitBuffers(FILL_ZERO);
+
+        /* assemble the order in which we should receive */
+    AssembleBufferList(recvList);
+
+    curBuffer = 0;
+
+    while (curBuffer < BUFFER_PROC_LIST_DEPTH) {
+
+            /* get number of buffers that have been completed, this blocks
+             * until we get at least 1 credit or it times out */
+        status = GetCredits(pDev, mbox, &credits);
+
+        if (status != A_OK) {
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Got %d messages on mailbox : %d \n",credits, mbox));
+
+            /* get all the buffers that are sitting on the queue */
+        for (i = 0; i < credits; i++) {
+            AR_DEBUG_ASSERT(curBuffer < BUFFER_PROC_LIST_DEPTH);
+                /* recv the current buffer synchronously, the buffers should come back in
+                 * order... with padding applied by the target */
+            paddedLength = (recvList[curBuffer].length + (g_BlockSizes[mbox] - 1)) &
+                       (~(g_BlockSizes[mbox] - 1));
+
+            status = HIFReadWrite(pDev->HIFDevice,
+                                  g_MailboxAddrs[mbox],
+                                  recvList[curBuffer].pBuffer,
+                                  paddedLength,
+                                  request,
+                                  NULL);
+            if (status != A_OK) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to read %d bytes on mailbox:%d : address:0x%X \n",
+                        recvList[curBuffer].length, mbox, g_MailboxAddrs[mbox]));
+                break;
+            }
+
+            totalwPadding += paddedLength;
+            totalBytes += recvList[curBuffer].length;
+            curBuffer++;
+        }
+
+        if (status != A_OK) {
+            break;
+        }
+            /* go back and get some more */
+        credits = 0;
+    }
+
+    if (totalBytes != TEST_BYTES) {
+        AR_DEBUG_ASSERT(FALSE);
+    }  else {
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Got all buffers on mbox:%d total recv :%d (w/Padding : %d) \n",
+            mbox, totalBytes, totalwPadding));
+    }
+
+    return status;
+
+
+}
+
+static A_STATUS DoOneMboxHWTest(AR6K_DEVICE *pDev, int mbox)
+{
+    A_STATUS status;
+
+    do {
+            /* send out buffers */
+        status = SendBuffers(pDev,mbox);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Sending buffers Failed : %d mbox:%d\n",status,mbox));
+            break;
+        }
+
+            /* go get them, this will block */
+        status =  RecvBuffers(pDev, mbox);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Recv buffers Failed : %d mbox:%d\n",status,mbox));
+            break;
+        }
+
+            /* check the returned data patterns */
+        if (!CheckBuffers()) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Buffer Verify Failed : mbox:%d\n",mbox));
+            status = A_ERROR;
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" Send/Recv success! mailbox : %d \n",mbox));
+
+    }  while (FALSE);
+
+    return status;
+}
+
+/* here is where the test starts */
+A_STATUS DoMboxHWTest(AR6K_DEVICE *pDev)
+{
+    int      i;
+    A_STATUS status;
+    int      credits = 0;
+    A_UINT8  params[4];
+    int      numBufs;
+    int      bufferSize;
+    A_UINT16 temp;
+
+
+    AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest START -  \n"));
+
+    do {
+            /* get the addresses for all 4 mailboxes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_ADDR,
+                                    g_MailboxAddrs, sizeof(g_MailboxAddrs));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* get the block sizes */
+        status = HIFConfigureDevice(pDev->HIFDevice, HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+                                    g_BlockSizes, sizeof(g_BlockSizes));
+
+        if (status != A_OK) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* note, the HIF layer usually reports mbox 0 to have a block size of
+             * 1, but our test wants to run in block-mode for all mailboxes, so we treat all mailboxes
+             * the same. */
+        g_BlockSizes[0] = g_BlockSizes[1];
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Block Size to use: %d \n",g_BlockSizes[0]));
+
+        if (g_BlockSizes[1] > BUFFER_BLOCK_PAD) {
+            AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("%d Block size is too large for buffer pad %d\n",
+                g_BlockSizes[1], BUFFER_BLOCK_PAD));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Waiting for target.... \n"));
+
+            /* the target lets us know it is ready by giving us 1 credit on
+             * mailbox 0 */
+        status = GetCredits(pDev, 0, &credits);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to wait for target ready \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Target is ready ...\n"));
+
+            /* read the first 4 scratch registers */
+        status = HIFReadWrite(pDev->HIFDevice,
+                              SCRATCH_ADDRESS,
+                              params,
+                              4,
+                              HIF_RD_SYNC_BYTE_INC,
+                              NULL);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to wait get parameters \n"));
+            break;
+        }
+
+        numBufs = params[0];
+        bufferSize = (int)(((A_UINT16)params[2] << 8) | (A_UINT16)params[1]);
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE,
+            ("Target parameters: bufs per mailbox:%d, buffer size:%d bytes (total space: %d, minimum required space (w/padding): %d) \n",
+            numBufs, bufferSize, (numBufs * bufferSize), TOTAL_BYTES));
+
+        if ((numBufs * bufferSize) < TOTAL_BYTES) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Not Enough buffer space to run test! need:%d, got:%d \n",
+                TOTAL_BYTES, (numBufs*bufferSize)));
+            status = A_ERROR;
+            break;
+        }
+
+        temp = GetEndMarker();
+
+        status = HIFReadWrite(pDev->HIFDevice,
+                              SCRATCH_ADDRESS + 4,
+                              (A_UINT8 *)&temp,
+                              2,
+                              HIF_WR_SYNC_BYTE_INC,
+                              NULL);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to write end marker \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("End Marker: 0x%X \n",temp));
+
+        temp = (A_UINT16)g_BlockSizes[1];
+            /* convert to a mask */
+        temp = temp - 1;
+        status = HIFReadWrite(pDev->HIFDevice,
+                              SCRATCH_ADDRESS + 6,
+                              (A_UINT8 *)&temp,
+                              2,
+                              HIF_WR_SYNC_BYTE_INC,
+                              NULL);
+
+        if (status != A_OK) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Failed to write block mask \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, ("Set Block Mask: 0x%X \n",temp));
+
+            /* execute the test on each mailbox */
+        for (i = 0; i < AR6K_MAILBOXES; i++) {
+            status = DoOneMboxHWTest(pDev, i);
+            if (status != A_OK) {
+                break;
+            }
+        }
+
+    } while (FALSE);
+
+    if (status == A_OK) {
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest DONE - SUCCESS! -  \n"));
+    } else {
+        AR_DEBUG_PRINTF(ATH_PRINT_OUT_ZONE, (" DoMboxHWTest DONE - FAILED! -  \n"));
+    }
+        /* don't let HTC_Start continue, the target is actually not running any HTC code */
+    return A_ERROR;
+}
+#endif
+
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/ar6k_events.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/ar6k_events.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/ar6k_events.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/ar6k_events.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,638 @@
+/*
+ * AR6K Driver layer event handling (i.e. interrupts, message polling)
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "AR6Khwreg.h"
+#include "a_osapi.h"
+#include "a_debug.h"
+#include "hif.h"
+#include "htc_packet.h"
+#include "ar6k.h"
+
+extern void AR6KFreeIOPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket);
+extern HTC_PACKET *AR6KAllocIOPacket(AR6K_DEVICE *pDev);
+
+static A_STATUS DevServiceDebugInterrupt(AR6K_DEVICE *pDev);
+
+#define DELAY_PER_INTERVAL_MS 10  /* 10 MS delay per polling interval */
+
+/* completion routine for ALL HIF layer async I/O */
+A_STATUS DevRWCompletionHandler(void *context, A_STATUS status)
+{
+    HTC_PACKET *pPacket = (HTC_PACKET *)context;
+
+    COMPLETE_HTC_PACKET(pPacket,status);
+
+    return A_OK;
+}
+
+/* mailbox recv message polling */
+A_STATUS DevPollMboxMsgRecv(AR6K_DEVICE *pDev,
+                            A_UINT32    *pLookAhead,
+                            int          TimeoutMS)
+{
+    A_STATUS status = A_OK;
+    int      timeout = TimeoutMS/DELAY_PER_INTERVAL_MS;
+
+    AR_DEBUG_ASSERT(timeout > 0);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+DevPollMboxMsgRecv \n"));
+
+    while (TRUE) {
+
+        if (pDev->GetPendingEventsFunc != NULL)
+		{
+
+            HIF_PENDING_EVENTS_INFO events;
+
+            /* the HIF layer uses a special mechanism to get events, do this
+             * synchronously */
+            status = pDev->GetPendingEventsFunc(pDev->HIFDevice,
+                                            &events,
+                                            NULL);
+            if (A_FAILED(status))
+			{
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to get pending events \n"));
+				break;
+            }
+
+            if (events.Events & HIF_RECV_MSG_AVAIL)
+			{
+                    /*  there is a message available, the lookahead should be valid now */
+                *pLookAhead = events.LookAhead;
+
+                break;
+            }
+        }
+		else
+		{
+
+                /* this is the standard HIF way.... */
+                /* load the register table */
+            status = HIFReadWrite(pDev->HIFDevice,
+                                  HOST_INT_STATUS_ADDRESS,
+                                  (A_UINT8 *)&pDev->IrqProcRegisters,
+                                  AR6K_IRQ_PROC_REGS_SIZE,
+                                  HIF_RD_SYNC_BYTE_INC,
+                                  NULL);
+
+            if (A_FAILED(status))
+			{
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Failed to read register table \n"));
+                break;
+            }
+
+                /* check for MBOX data and valid lookahead */
+            if (pDev->IrqProcRegisters.host_int_status & (1 << HTC_MAILBOX))
+			{
+                if (pDev->IrqProcRegisters.rx_lookahead_valid & (1 << HTC_MAILBOX))
+				{
+                    /* mailbox has a message and the look ahead is valid */
+                    *pLookAhead = pDev->IrqProcRegisters.rx_lookahead[HTC_MAILBOX];
+                    break;
+                }
+            }
+
+        }
+
+        timeout--;
+
+        if (timeout <= 0)
+		{
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" Timeout waiting for recv message \n"));
+            status = A_ERROR;
+
+                /* check if the target asserted */
+            if ( pDev->IrqProcRegisters.counter_int_status & AR6K_TARGET_DEBUG_INTR_MASK) {
+                    /* target signaled an assert, process this pending interrupt
+                     * this will call the target failure handler */
+                DevServiceDebugInterrupt(pDev);
+            }
+
+            break;
+        }
+
+            /* delay a little  */
+         msleep(DELAY_PER_INTERVAL_MS);
+         AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("  Retry Mbox Poll : %d \n",timeout));
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-DevPollMboxMsgRecv \n"));
+
+    return status;
+}
+
+static A_STATUS DevServiceCPUInterrupt(AR6K_DEVICE *pDev)
+{
+    A_STATUS status;
+    A_UINT8  cpu_int_status;
+    A_UINT8  regBuffer[4];
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("CPU Interrupt\n"));
+    cpu_int_status = pDev->IrqProcRegisters.cpu_int_status &
+                     pDev->IrqEnableRegisters.cpu_int_status_enable;
+    AR_DEBUG_ASSERT(cpu_int_status);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    ("Valid interrupt source(s) in CPU_INT_STATUS: 0x%x\n",
+                    cpu_int_status));
+
+        /* Clear the interrupt */
+    pDev->IrqProcRegisters.cpu_int_status &= ~cpu_int_status; /* W1C */
+
+        /* set up the register transfer buffer to hit the register 4 times , this is done
+         * to make the access 4-byte aligned to mitigate issues with host bus interconnects that
+         * restrict bus transfer lengths to be a multiple of 4-bytes */
+
+        /* set W1C value to clear the interrupt, this hits the register first */
+    regBuffer[0] = cpu_int_status;
+        /* the remaining 4 values are set to zero which have no-effect  */
+    regBuffer[1] = 0;
+    regBuffer[2] = 0;
+    regBuffer[3] = 0;
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          CPU_INT_STATUS_ADDRESS,
+                          regBuffer,
+                          4,
+                          HIF_WR_SYNC_BYTE_FIX,
+                          NULL);
+
+    AR_DEBUG_ASSERT(status == A_OK);
+    return status;
+}
+
+
+static A_STATUS DevServiceErrorInterrupt(AR6K_DEVICE *pDev)
+{
+    A_STATUS status;
+    A_UINT8  error_int_status;
+    A_UINT8  regBuffer[4];
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Error Interrupt\n"));
+    error_int_status = pDev->IrqProcRegisters.error_int_status & 0x0F;
+    AR_DEBUG_ASSERT(error_int_status);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    ("Valid interrupt source(s) in ERROR_INT_STATUS: 0x%x\n",
+                    error_int_status));
+
+    if (ERROR_INT_STATUS_WAKEUP_GET(error_int_status)) {
+        /* Wakeup */
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Error : Wakeup\n"));
+    }
+
+    if (ERROR_INT_STATUS_RX_UNDERFLOW_GET(error_int_status)) {
+        /* Rx Underflow */
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Error : Rx Underflow\n"));
+    }
+
+    if (ERROR_INT_STATUS_TX_OVERFLOW_GET(error_int_status)) {
+        /* Tx Overflow */
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Error : Tx Overflow\n"));
+    }
+
+        /* Clear the interrupt */
+    pDev->IrqProcRegisters.error_int_status &= ~error_int_status; /* W1C */
+
+        /* set up the register transfer buffer to hit the register 4 times , this is done
+         * to make the access 4-byte aligned to mitigate issues with host bus interconnects that
+         * restrict bus transfer lengths to be a multiple of 4-bytes */
+
+        /* set W1C value to clear the interrupt, this hits the register first */
+    regBuffer[0] = error_int_status;
+        /* the remaining 4 values are set to zero which have no-effect  */
+    regBuffer[1] = 0;
+    regBuffer[2] = 0;
+    regBuffer[3] = 0;
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          ERROR_INT_STATUS_ADDRESS,
+                          regBuffer,
+                          4,
+                          HIF_WR_SYNC_BYTE_FIX,
+                          NULL);
+
+    AR_DEBUG_ASSERT(status == A_OK);
+    return status;
+}
+
+static A_STATUS DevServiceDebugInterrupt(AR6K_DEVICE *pDev)
+{
+    A_UINT32 dummy;
+    A_STATUS status;
+
+    /* Send a target failure event to the application */
+    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Target debug interrupt\n"));
+
+    if (pDev->TargetFailureCallback != NULL) {
+        pDev->TargetFailureCallback(pDev->HTCContext);
+    }
+
+    /* clear the interrupt , the debug error interrupt is
+     * counter 0 */
+        /* read counter to clear interrupt */
+    status = HIFReadWrite(pDev->HIFDevice,
+                          COUNT_DEC_ADDRESS,
+                          (A_UINT8 *)&dummy,
+                          4,
+                          HIF_RD_SYNC_BYTE_INC,
+                          NULL);
+
+    AR_DEBUG_ASSERT(status == A_OK);
+    return status;
+}
+
+static A_STATUS DevServiceCounterInterrupt(AR6K_DEVICE *pDev)
+{
+    A_UINT8 counter_int_status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ, ("Counter Interrupt\n"));
+
+    counter_int_status = pDev->IrqProcRegisters.counter_int_status &
+                         pDev->IrqEnableRegisters.counter_int_status_enable;
+
+    AR_DEBUG_ASSERT(counter_int_status);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    ("Valid interrupt source(s) in COUNTER_INT_STATUS: 0x%x\n",
+                    counter_int_status));
+
+    /* Check if the debug interrupt is pending */
+    if (counter_int_status & AR6K_TARGET_DEBUG_INTR_MASK) {
+        return DevServiceDebugInterrupt(pDev);
+    }
+
+    return A_OK;
+}
+
+/* callback when our fetch to get interrupt status registers completes */
+static void DevGetEventAsyncHandler(void *Context, HTC_PACKET *pPacket)
+{
+    AR6K_DEVICE *pDev = (AR6K_DEVICE *)Context;
+    A_UINT32    lookAhead = 0;
+    A_BOOL      otherInts = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevGetEventAsyncHandler: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+    do {
+
+        if (A_FAILED(pPacket->Status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    (" GetEvents I/O request failed, status:%d \n", pPacket->Status));
+            /* bail out, don't unmask HIF interrupt */
+            break;
+        }
+
+        if (pDev->GetPendingEventsFunc != NULL) {
+                /* the HIF layer collected the information for us */
+            HIF_PENDING_EVENTS_INFO *pEvents = (HIF_PENDING_EVENTS_INFO *)pPacket->pBuffer;
+            if (pEvents->Events & HIF_RECV_MSG_AVAIL) {
+                lookAhead = pEvents->LookAhead;
+                if (0 == lookAhead) {
+                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" DevGetEventAsyncHandler1, lookAhead is zero! \n"));
+                }
+            }
+            if (pEvents->Events & HIF_OTHER_EVENTS) {
+                otherInts = TRUE;
+            }
+        } else {
+                /* standard interrupt table handling.... */
+            AR6K_IRQ_PROC_REGISTERS *pReg = (AR6K_IRQ_PROC_REGISTERS *)pPacket->pBuffer;
+            A_UINT8                 host_int_status;
+
+            host_int_status = pReg->host_int_status & pDev->IrqEnableRegisters.int_status_enable;
+
+            if (host_int_status & (1 << HTC_MAILBOX)) {
+                host_int_status &= ~(1 << HTC_MAILBOX);
+                if (pReg->rx_lookahead_valid & (1 << HTC_MAILBOX)) {
+                        /* mailbox has a message and the look ahead is valid */
+                    lookAhead = pReg->rx_lookahead[HTC_MAILBOX];
+                    if (0 == lookAhead) {
+                        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" DevGetEventAsyncHandler2, lookAhead is zero! \n"));
+                    }
+                }
+            }
+
+            if (host_int_status) {
+                    /* there are other interrupts to handle */
+                otherInts = TRUE;
+            }
+        }
+
+        if (otherInts || (lookAhead == 0)) {
+            /* if there are other interrupts to process, we cannot do this in the async handler so
+             * ack the interrupt which will cause our sync handler to run again
+             * if however there are no more messages, we can now ack the interrupt  */
+            AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                (" Acking interrupt from DevGetEventAsyncHandler (otherints:%d, lookahead:0x%X)\n",
+                otherInts, lookAhead));
+            HIFAckInterrupt(pDev->HIFDevice);
+        } else {
+            AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                    (" DevGetEventAsyncHandler : detected another message, lookahead :0x%X \n",
+                    lookAhead));
+                /* lookahead is non-zero and there are no other interrupts to service,
+                 * go get the next message */
+            pDev->MessagePendingCallback(pDev->HTCContext, lookAhead, NULL);
+        }
+
+    } while (FALSE);
+
+        /* free this IO packet */
+    AR6KFreeIOPacket(pDev,pPacket);
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevGetEventAsyncHandler \n"));
+}
+
+/* called by the HTC layer when it wants us to check if the device has any more pending
+ * recv messages, this starts off a series of async requests to read interrupt registers  */
+A_STATUS DevCheckPendingRecvMsgsAsync(void *context)
+{
+    AR6K_DEVICE  *pDev = (AR6K_DEVICE *)context;
+    A_STATUS      status = A_OK;
+    HTC_PACKET   *pIOPacket;
+
+    /* this is called in an ASYNC only context, we may NOT block, sleep or call any apis that can
+     * cause us to switch contexts */
+
+   AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevCheckPendingRecvMsgsAsync: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+   do {
+
+        if (HIF_DEVICE_IRQ_SYNC_ONLY == pDev->HifIRQProcessingMode) {
+                /* break the async processing chain right here, no need to continue.
+                 * The DevDsrHandler() will handle things in a loop when things are driven
+                 * synchronously  */
+            break;
+        }
+            /* first allocate one of our HTC packets we created for async I/O
+             * we reuse HTC packet definitions so that we can use the completion mechanism
+             * in DevRWCompletionHandler() */
+        pIOPacket = AR6KAllocIOPacket(pDev);
+
+        if (NULL == pIOPacket) {
+                /* there should be only 1 asynchronous request out at a time to read these registers
+                 * so this should actually never happen */
+            status = A_NO_MEMORY;
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* stick in our completion routine when the I/O operation completes */
+        pIOPacket->Completion = DevGetEventAsyncHandler;
+        pIOPacket->pContext = pDev;
+
+        if (pDev->GetPendingEventsFunc) {
+                /* HIF layer has it's own mechanism, pass the IO to it.. */
+            status = pDev->GetPendingEventsFunc(pDev->HIFDevice,
+                                                (HIF_PENDING_EVENTS_INFO *)pIOPacket->pBuffer,
+                                                pIOPacket);
+
+        } else {
+                /* standard way, read the interrupt register table asynchronously again */
+            status = HIFReadWrite(pDev->HIFDevice,
+                                  HOST_INT_STATUS_ADDRESS,
+                                  pIOPacket->pBuffer,
+                                  AR6K_IRQ_PROC_REGS_SIZE,
+                                  HIF_RD_ASYNC_BYTE_INC,
+                                  pIOPacket);
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Async IO issued to get interrupt status...\n"));
+   } while (FALSE);
+
+   AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevCheckPendingRecvMsgsAsync \n"));
+
+   return status;
+}
+
+/* process pending interrupts synchronously */
+static A_STATUS ProcessPendingIRQs(AR6K_DEVICE *pDev, A_BOOL *pDone, A_BOOL *pASyncProcessing)
+{
+    A_STATUS    status = A_OK;
+    A_UINT8     host_int_status = 0;
+    A_UINT32    lookAhead = 0;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+ProcessPendingIRQs: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+    /*** NOTE: the HIF implementation guarantees that the context of this call allows
+     *         us to perform SYNCHRONOUS I/O, that is we can block, sleep or call any API that
+     *         can block or switch thread/task ontexts.
+     *         This is a fully schedulable context.
+     * */
+    do {
+
+        if (pDev->GetPendingEventsFunc != NULL) {
+            HIF_PENDING_EVENTS_INFO events;
+
+                /* the HIF layer uses a special mechanism to get events
+                 * get this synchronously  */
+            status = pDev->GetPendingEventsFunc(pDev->HIFDevice,
+                                                &events,
+                                                NULL);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+            if (events.Events & HIF_RECV_MSG_AVAIL) {
+                lookAhead = events.LookAhead;
+                if (0 == lookAhead) {
+                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" ProcessPendingIRQs1 lookAhead is zero! \n"));
+                }
+            }
+
+            if (!(events.Events & HIF_OTHER_EVENTS) ||
+                !(pDev->IrqEnableRegisters.int_status_enable & OTHER_INTS_ENABLED)) {
+                    /* no need to read the register table, no other interesting interrupts.
+                     * Some interfaces (like SPI) can shadow interrupt sources without
+                     * requiring the host to do a full table read */
+                break;
+            }
+
+            /* otherwise fall through and read the register table */
+        }
+
+        /*
+         * Read the first 28 bytes of the HTC register table. This will yield us
+         * the value of different int status registers and the lookahead
+         * registers.
+         *    length = sizeof(int_status) + sizeof(cpu_int_status) +
+         *             sizeof(error_int_status) + sizeof(counter_int_status) +
+         *             sizeof(mbox_frame) + sizeof(rx_lookahead_valid) +
+         *             sizeof(hole) +  sizeof(rx_lookahead) +
+         *             sizeof(int_status_enable) + sizeof(cpu_int_status_enable) +
+         *             sizeof(error_status_enable) +
+         *             sizeof(counter_int_status_enable);
+         *
+        */
+        status = HIFReadWrite(pDev->HIFDevice,
+                              HOST_INT_STATUS_ADDRESS,
+                              (A_UINT8 *)&pDev->IrqProcRegisters,
+                              AR6K_IRQ_PROC_REGS_SIZE,
+                              HIF_RD_SYNC_BYTE_INC,
+                              NULL);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_IRQ)) {
+            DevDumpRegisters(&pDev->IrqProcRegisters,
+                             &pDev->IrqEnableRegisters);
+        }
+
+            /* Update only those registers that are enabled */
+        host_int_status = pDev->IrqProcRegisters.host_int_status &
+                          pDev->IrqEnableRegisters.int_status_enable;
+
+        if (NULL == pDev->GetPendingEventsFunc) {
+                /* only look at mailbox status if the HIF layer did not provide this function,
+                 * on some HIF interfaces reading the RX lookahead is not valid to do */
+            if (host_int_status & (1 << HTC_MAILBOX)) {
+                    /* mask out pending mailbox value, we use "lookAhead" as the real flag for
+                     * mailbox processing below */
+                host_int_status &= ~(1 << HTC_MAILBOX);
+                if (pDev->IrqProcRegisters.rx_lookahead_valid & (1 << HTC_MAILBOX)) {
+                        /* mailbox has a message and the look ahead is valid */
+                    lookAhead = pDev->IrqProcRegisters.rx_lookahead[HTC_MAILBOX];
+                    if (0 == lookAhead) {
+                        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" ProcessPendingIRQs2, lookAhead is zero! \n"));
+                    }
+                }
+            }
+        } else {
+                /* not valid to check if the HIF has another mechanism for reading mailbox pending status*/
+            host_int_status &= ~(1 << HTC_MAILBOX);
+        }
+
+    } while (FALSE);
+
+
+    do {
+
+            /* did the interrupt status fetches succeed? */
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if ((0 == host_int_status) && (0 == lookAhead)) {
+                /* nothing to process, the caller can use this to break out of a loop */
+            *pDone = TRUE;
+            break;
+        }
+
+        if (lookAhead != 0) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("Pending mailbox message, LookAhead: 0x%X\n",lookAhead));
+                /* Mailbox Interrupt, the HTC layer may issue async requests to empty the
+                 * mailbox...
+                 * When emptying the recv mailbox we use the async handler above called from the
+                 * completion routine of the callers read request. This can improve performance
+                 * by reducing context switching when we rapidly pull packets */
+            status = pDev->MessagePendingCallback(pDev->HTCContext, lookAhead, pASyncProcessing);
+            if (A_FAILED(status)) {
+                break;
+            }
+        }
+
+            /* now handle the rest of them */
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,
+                            (" Valid interrupt source(s) for OTHER interrupts: 0x%x\n",
+                            host_int_status));
+
+        if (HOST_INT_STATUS_CPU_GET(host_int_status)) {
+                /* CPU Interrupt */
+            status = DevServiceCPUInterrupt(pDev);
+            if (A_FAILED(status)){
+                break;
+            }
+        }
+
+        if (HOST_INT_STATUS_ERROR_GET(host_int_status)) {
+                /* Error Interrupt */
+            status = DevServiceErrorInterrupt(pDev);
+            if (A_FAILED(status)){
+                break;
+            }
+        }
+
+        if (HOST_INT_STATUS_COUNTER_GET(host_int_status)) {
+                /* Counter Interrupt */
+            status = DevServiceCounterInterrupt(pDev);
+            if (A_FAILED(status)){
+                break;
+            }
+        }
+
+    } while (FALSE);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-ProcessPendingIRQs: (done:%d, async:%d) status=%d \n",
+                *pDone, *pASyncProcessing, status));
+
+    return status;
+}
+
+
+/* Synchronousinterrupt handler, this handler kicks off all interrupt processing.*/
+A_STATUS DevDsrHandler(void *context)
+{
+    AR6K_DEVICE *pDev = (AR6K_DEVICE *)context;
+    A_STATUS    status = A_OK;
+    A_BOOL      done = FALSE;
+    A_BOOL      asyncProc = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("+DevDsrHandler: (dev: 0x%X)\n", (A_UINT32)pDev));
+
+
+    while (!done) {
+        status = ProcessPendingIRQs(pDev, &done, &asyncProc);
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (HIF_DEVICE_IRQ_SYNC_ONLY == pDev->HifIRQProcessingMode) {
+            /* the HIF layer does not allow async IRQ processing, override the asyncProc flag */
+            asyncProc = FALSE;
+            /* this will cause us to re-enter ProcessPendingIRQ() and re-read interrupt status registers.
+             * this has a nice side effect of blocking us until all async read requests are completed.
+             * This behavior is required on some HIF implementations that do not allow ASYNC
+             * processing in interrupt handlers (like Windows CE) */
+        }
+
+        if (asyncProc) {
+                /* the function performed some async I/O for performance, we
+                   need to exit the ISR immediately, the check below will prevent the interrupt from being
+                   Ack'd while we handle it asynchronously */
+            break;
+        }
+
+    }
+
+    if (A_SUCCESS(status) && !asyncProc) {
+            /* Ack the interrupt only if :
+             *  1. we did not get any errors in processing interrupts
+             *  2. there are no outstanding async processing requests */
+        AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,(" Acking interrupt from DevDsrHandler \n"));
+        HIFAckInterrupt(pDev->HIFDevice);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_IRQ,("-DevDsrHandler \n"));
+    return A_OK;
+}
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/ar6k.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/ar6k.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/ar6k.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/ar6k.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,191 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef AR6K_H_
+#define AR6K_H_
+
+#define AR6K_MAILBOXES 4
+
+/* HTC runs over mailbox 0 */
+#define HTC_MAILBOX          0
+
+#define AR6K_TARGET_DEBUG_INTR_MASK     0x01
+
+#define OTHER_INTS_ENABLED (INT_STATUS_ENABLE_ERROR_MASK |   \
+                            INT_STATUS_ENABLE_CPU_MASK   |   \
+                            INT_STATUS_ENABLE_COUNTER_MASK)
+
+//#define MBOXHW_UNIT_TEST 1
+
+#include "athstartpack.h"
+typedef PREPACK struct _AR6K_IRQ_PROC_REGISTERS {
+    A_UINT8                      host_int_status;
+    A_UINT8                      cpu_int_status;
+    A_UINT8                      error_int_status;
+    A_UINT8                      counter_int_status;
+    A_UINT8                      mbox_frame;
+    A_UINT8                      rx_lookahead_valid;
+    A_UINT8                      hole[2];
+    A_UINT32                     rx_lookahead[2];
+} POSTPACK AR6K_IRQ_PROC_REGISTERS;
+
+#define AR6K_IRQ_PROC_REGS_SIZE sizeof(AR6K_IRQ_PROC_REGISTERS)
+
+
+
+typedef PREPACK struct _AR6K_IRQ_ENABLE_REGISTERS {
+    A_UINT8                      int_status_enable;
+    A_UINT8                      cpu_int_status_enable;
+    A_UINT8                      error_status_enable;
+    A_UINT8                      counter_int_status_enable;
+} POSTPACK AR6K_IRQ_ENABLE_REGISTERS;
+
+#include "athendpack.h"
+
+#define AR6K_IRQ_ENABLE_REGS_SIZE sizeof(AR6K_IRQ_ENABLE_REGISTERS)
+
+#define AR6K_REG_IO_BUFFER_SIZE     32
+#define AR6K_MAX_REG_IO_BUFFERS     8
+
+/* buffers for ASYNC I/O */
+typedef struct AR6K_ASYNC_REG_IO_BUFFER {
+    HTC_PACKET    HtcPacket;   /* we use an HTC packet as a wrapper for our async register-based I/O */
+    A_UINT8       Buffer[AR6K_REG_IO_BUFFER_SIZE];
+} AR6K_ASYNC_REG_IO_BUFFER;
+
+typedef struct _AR6K_DEVICE {
+    A_MUTEX_T                   Lock;
+    AR6K_IRQ_PROC_REGISTERS     IrqProcRegisters;
+    AR6K_IRQ_ENABLE_REGISTERS   IrqEnableRegisters;
+    void                        *HIFDevice;
+    A_UINT32                    BlockSize;
+    A_UINT32                    BlockMask;
+    A_UINT32                    MailboxAddress;
+    HIF_PENDING_EVENTS_FUNC     GetPendingEventsFunc;
+    void                        *HTCContext;
+    HTC_PACKET_QUEUE            RegisterIOList;
+    AR6K_ASYNC_REG_IO_BUFFER    RegIOBuffers[AR6K_MAX_REG_IO_BUFFERS];
+    void                        (*TargetFailureCallback)(void *Context);
+    A_STATUS                    (*MessagePendingCallback)(void *Context, A_UINT32 LookAhead, A_BOOL *pAsyncProc);
+    HIF_DEVICE_IRQ_PROCESSING_MODE  HifIRQProcessingMode;
+    HIF_MASK_UNMASK_RECV_EVENT      HifMaskUmaskRecvEvent;
+} AR6K_DEVICE;
+
+#define IS_DEV_IRQ_PROCESSING_ASYNC_ALLOWED(pDev) ((pDev)->HifIRQProcessingMode != HIF_DEVICE_IRQ_SYNC_ONLY)
+
+A_STATUS DevSetup(AR6K_DEVICE *pDev);
+A_STATUS DevUnmaskInterrupts(AR6K_DEVICE *pDev);
+A_STATUS DevMaskInterrupts(AR6K_DEVICE *pDev);
+A_STATUS DevPollMboxMsgRecv(AR6K_DEVICE *pDev,
+                            A_UINT32    *pLookAhead,
+                            int          TimeoutMS);
+A_STATUS DevRWCompletionHandler(void *context, A_STATUS status);
+A_STATUS DevDsrHandler(void *context);
+A_STATUS DevCheckPendingRecvMsgsAsync(void *context);
+void     DevDumpRegisters(AR6K_IRQ_PROC_REGISTERS   *pIrqProcRegs,
+                          AR6K_IRQ_ENABLE_REGISTERS *pIrqEnableRegs);
+
+#define DEV_STOP_RECV_ASYNC TRUE
+#define DEV_STOP_RECV_SYNC  FALSE
+#define DEV_ENABLE_RECV_ASYNC TRUE
+#define DEV_ENABLE_RECV_SYNC  FALSE
+A_STATUS DevStopRecv(AR6K_DEVICE *pDev, A_BOOL ASyncMode);
+A_STATUS DevEnableRecv(AR6K_DEVICE *pDev, A_BOOL ASyncMode);
+
+static INLINE A_STATUS DevSendPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket, A_UINT32 SendLength) {
+    A_UINT32 paddedLength;
+    A_BOOL   sync = (pPacket->Completion == NULL) ? TRUE : FALSE;
+    A_STATUS status;
+
+       /* adjust the length to be a multiple of block size if appropriate */
+    paddedLength = (SendLength + (pDev->BlockMask)) &
+                    (~(pDev->BlockMask));
+#if 0 // BufferLength may not be set in , fix this...
+    if (paddedLength > pPacket->BufferLength) {
+        AR_DEBUG_ASSERT(FALSE);
+        if (pPacket->Completion != NULL) {
+            COMPLETE_HTC_PACKET(pPacket,A_EINVAL);
+        }
+        return A_EINVAL;
+    }
+#endif
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                ("DevSendPacket, Padded Length: %d Mbox:0x%X (mode:%s)\n",
+                paddedLength,
+                pDev->MailboxAddress,
+                sync ? "SYNC" : "ASYNC"));
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          pDev->MailboxAddress,
+                          pPacket->pBuffer,
+                          paddedLength,     /* the padded length */
+                          sync ? HIF_WR_SYNC_BLOCK_INC : HIF_WR_ASYNC_BLOCK_INC,
+                          sync ? NULL : pPacket);  /* pass the packet as the context to the HIF request */
+
+    if (sync) {
+        pPacket->Status = status;
+    }
+
+    return status;
+}
+
+static INLINE A_STATUS DevRecvPacket(AR6K_DEVICE *pDev, HTC_PACKET *pPacket, A_UINT32 RecvLength) {
+    A_UINT32 paddedLength;
+    A_STATUS status;
+    A_BOOL   sync = (pPacket->Completion == NULL) ? TRUE : FALSE;
+
+        /* adjust the length to be a multiple of block size if appropriate */
+    paddedLength = (RecvLength + (pDev->BlockMask)) &
+                    (~(pDev->BlockMask));
+    if (paddedLength > pPacket->BufferLength) {
+        AR_DEBUG_ASSERT(FALSE);
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                ("DevRecvPacket, Not enough space for padlen:%d recvlen:%d bufferlen:%d \n",
+                    paddedLength,RecvLength,pPacket->BufferLength));
+        if (pPacket->Completion != NULL) {
+            COMPLETE_HTC_PACKET(pPacket,A_EINVAL);
+        }
+        return A_EINVAL;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                ("DevRecvPacket, Padded Length: %d Mbox:0x%X (mode:%s)\n",
+                paddedLength,
+                pDev->MailboxAddress,
+                sync ? "SYNC" : "ASYNC"));
+
+    status = HIFReadWrite(pDev->HIFDevice,
+                          pDev->MailboxAddress,
+                          pPacket->pBuffer,
+                          paddedLength,
+                          sync ? HIF_RD_SYNC_BLOCK_INC : HIF_RD_ASYNC_BLOCK_INC,
+                          sync ? NULL : pPacket);  /* pass the packet as the context to the HIF request */
+
+    if (sync) {
+        pPacket->Status = status;
+    }
+
+    return status;
+}
+
+#ifdef MBOXHW_UNIT_TEST
+A_STATUS DoMboxHWTest(AR6K_DEVICE *pDev);
+#endif
+
+#endif /*AR6K_H_*/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,508 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+
+static HTC_INIT_INFO  HTCInitInfo = {NULL,NULL,NULL};
+static A_BOOL         HTCInitialized = FALSE;
+
+static A_STATUS HTCTargetInsertedHandler(void *hif_handle);
+static A_STATUS HTCTargetRemovedHandler(void *handle, A_STATUS status);
+static void HTCReportFailure(void *Context);
+
+/* Initializes the HTC layer */
+A_STATUS HTCInit(HTC_INIT_INFO *pInitInfo)
+{
+    HTC_CALLBACKS htcCallbacks;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCInit: Enter\n"));
+    if (HTCInitialized) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCInit: Exit\n"));
+        return A_OK;
+    }
+
+    A_MEMCPY(&HTCInitInfo,pInitInfo,sizeof(HTC_INIT_INFO));
+
+    A_MEMZERO(&htcCallbacks, sizeof(HTC_CALLBACKS));
+
+        /* setup HIF layer callbacks */
+    htcCallbacks.deviceInsertedHandler = HTCTargetInsertedHandler;
+    htcCallbacks.deviceRemovedHandler = HTCTargetRemovedHandler;
+        /* the device layer handles these */
+    htcCallbacks.rwCompletionHandler = DevRWCompletionHandler;
+    htcCallbacks.dsrHandler = DevDsrHandler;
+    HIFInit(&htcCallbacks);
+    HTCInitialized = TRUE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCInit: Exit\n"));
+    return A_OK;
+}
+
+void HTCFreeControlBuffer(HTC_TARGET *target, HTC_PACKET *pPacket, HTC_PACKET_QUEUE *pList)
+{
+    LOCK_HTC(target);
+    HTC_PACKET_ENQUEUE(pList,pPacket);
+    UNLOCK_HTC(target);
+}
+
+HTC_PACKET *HTCAllocControlBuffer(HTC_TARGET *target,  HTC_PACKET_QUEUE *pList)
+{
+    HTC_PACKET *pPacket;
+
+    LOCK_HTC(target);
+    pPacket = HTC_PACKET_DEQUEUE(pList);
+    UNLOCK_HTC(target);
+
+    return pPacket;
+}
+
+/* cleanup the HTC instance */
+static void HTCCleanup(HTC_TARGET *target)
+{
+    if (A_IS_MUTEX_VALID(&target->HTCLock)) {
+        A_MUTEX_DELETE(&target->HTCLock);
+    }
+
+    if (A_IS_MUTEX_VALID(&target->HTCRxLock)) {
+        A_MUTEX_DELETE(&target->HTCRxLock);
+    }
+
+    if (A_IS_MUTEX_VALID(&target->HTCTxLock)) {
+        A_MUTEX_DELETE(&target->HTCTxLock);
+    }
+        /* free our instance */
+    A_FREE(target);
+}
+
+/* registered target arrival callback from the HIF layer */
+static A_STATUS HTCTargetInsertedHandler(void *hif_handle)
+{
+    HTC_TARGET              *target = NULL;
+    A_STATUS                 status;
+    int                      i;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("htcTargetInserted - Enter\n"));
+
+    do {
+
+            /* allocate target memory */
+        if ((target = (HTC_TARGET *)A_MALLOC(sizeof(HTC_TARGET))) == NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Unable to allocate memory\n"));
+            status = A_ERROR;
+            break;
+        }
+
+        A_MEMZERO(target, sizeof(HTC_TARGET));
+        A_MUTEX_INIT(&target->HTCLock);
+        A_MUTEX_INIT(&target->HTCRxLock);
+        A_MUTEX_INIT(&target->HTCTxLock);
+        INIT_HTC_PACKET_QUEUE(&target->ControlBufferTXFreeList);
+        INIT_HTC_PACKET_QUEUE(&target->ControlBufferRXFreeList);
+
+            /* give device layer the hif device handle */
+        target->Device.HIFDevice = hif_handle;
+            /* give the device layer our context (for event processing)
+             * the device layer will register it's own context with HIF
+             * so we need to set this so we can fetch it in the target remove handler */
+        target->Device.HTCContext = target;
+            /* set device layer target failure callback */
+        target->Device.TargetFailureCallback = HTCReportFailure;
+            /* set device layer recv message pending callback */
+        target->Device.MessagePendingCallback = HTCRecvMessagePendingHandler;
+        target->EpWaitingForBuffers = ENDPOINT_MAX;
+
+            /* setup device layer */
+        status = DevSetup(&target->Device);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* carve up buffers/packets for control messages */
+        for (i = 0; i < NUM_CONTROL_RX_BUFFERS; i++) {
+            HTC_PACKET *pControlPacket;
+            pControlPacket = &target->HTCControlBuffers[i].HtcPacket;
+            SET_HTC_PACKET_INFO_RX_REFILL(pControlPacket,
+                                          target,
+                                          target->HTCControlBuffers[i].Buffer,
+                                          HTC_CONTROL_BUFFER_SIZE,
+                                          ENDPOINT_0);
+            HTC_FREE_CONTROL_RX(target,pControlPacket);
+        }
+
+        for (;i < NUM_CONTROL_BUFFERS;i++) {
+             HTC_PACKET *pControlPacket;
+             pControlPacket = &target->HTCControlBuffers[i].HtcPacket;
+             INIT_HTC_PACKET_INFO(pControlPacket,
+                                  target->HTCControlBuffers[i].Buffer,
+                                  HTC_CONTROL_BUFFER_SIZE);
+             HTC_FREE_CONTROL_TX(target,pControlPacket);
+        }
+
+    } while (FALSE);
+
+    if (A_SUCCESS(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, (" calling AddInstance callback \n"));
+            /* announce ourselves */
+        HTCInitInfo.AddInstance((HTC_HANDLE)target);
+    } else {
+        if (target != NULL) {
+            HTCCleanup(target);
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("htcTargetInserted - Exit\n"));
+
+    return status;
+}
+
+/* registered removal callback from the HIF layer */
+static A_STATUS HTCTargetRemovedHandler(void *handle, A_STATUS status)
+{
+    HTC_TARGET *target;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCTargetRemovedHandler handle:0x%X \n",(A_UINT32)handle));
+
+    if (NULL == handle) {
+            /* this could be NULL in the event that target initialization failed */
+        return A_OK;
+    }
+
+    target = ((AR6K_DEVICE *)handle)->HTCContext;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("   removing target:0x%X instance:0x%X ... \n",
+            (A_UINT32)target, (A_UINT32)target->pInstanceContext));
+
+    if (target->pInstanceContext != NULL) {
+            /* let upper layer know, it needs to call HTCStop() */
+        HTCInitInfo.DeleteInstance(target->pInstanceContext);
+    }
+
+    HIFShutDownDevice(target->Device.HIFDevice);
+
+    HTCCleanup(target);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCTargetRemovedHandler \n"));
+    return A_OK;
+}
+
+/* get the low level HIF device for the caller , the caller may wish to do low level
+ * HIF requests */
+void *HTCGetHifDevice(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    return target->Device.HIFDevice;
+}
+
+/* set the instance block for this HTC handle, so that on removal, the blob can be
+ * returned to the caller */
+void HTCSetInstance(HTC_HANDLE HTCHandle, void *Instance)
+{
+    HTC_TARGET  *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+
+    target->pInstanceContext = Instance;
+}
+
+/* wait for the target to arrive (sends HTC Ready message)
+ * this operation is fully synchronous and the message is polled for */
+A_STATUS HTCWaitTarget(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET              *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_STATUS                 status;
+    HTC_PACKET              *pPacket = NULL;
+    HTC_READY_MSG           *pRdyMsg;
+    HTC_SERVICE_CONNECT_REQ  connect;
+    HTC_SERVICE_CONNECT_RESP resp;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCWaitTarget - Enter (target:0x%X) \n", (A_UINT32)target));
+
+    do {
+
+#ifdef MBOXHW_UNIT_TEST
+
+        status = DoMboxHWTest(&target->Device);
+
+        if (status != A_OK) {
+            break;
+        }
+
+#endif
+
+            /* we should be getting 1 control message that the target is ready */
+        status = HTCWaitforControlMessage(target, &pPacket);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" Target Not Available!!\n"));
+            break;
+        }
+
+            /* we controlled the buffer creation so it has to be properly aligned */
+        pRdyMsg = (HTC_READY_MSG *)pPacket->pBuffer;
+
+        if ((pRdyMsg->MessageID != HTC_MSG_READY_ID) ||
+            (pPacket->ActualLength < sizeof(HTC_READY_MSG))) {
+                /* this message is not valid */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        if (pRdyMsg->CreditCount == 0 || pRdyMsg->CreditSize == 0) {
+              /* this message is not valid */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        target->TargetCredits = pRdyMsg->CreditCount;
+        target->TargetCreditSize = pRdyMsg->CreditSize;
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, (" Target Ready: credits: %d credit size: %d\n",
+                target->TargetCredits, target->TargetCreditSize));
+
+            /* setup our pseudo HTC control endpoint connection */
+        A_MEMZERO(&connect,sizeof(connect));
+        A_MEMZERO(&resp,sizeof(resp));
+        connect.EpCallbacks.pContext = target;
+        connect.EpCallbacks.EpTxComplete = HTCControlTxComplete;
+        connect.EpCallbacks.EpRecv = HTCControlRecv;
+        connect.EpCallbacks.EpRecvRefill = NULL;  /* not needed */
+        connect.EpCallbacks.EpSendFull = NULL;    /* not needed */
+        connect.EpCallbacks.EpSendAvail = NULL;   /* not needed */
+        connect.MaxSendQueueDepth = NUM_CONTROL_BUFFERS;
+        connect.ServiceID = HTC_CTRL_RSVD_SVC;
+
+            /* connect fake service */
+        status = HTCConnectService((HTC_HANDLE)target,
+                                   &connect,
+                                   &resp);
+
+        if (!A_FAILED(status)) {
+            break;
+        }
+
+    } while (FALSE);
+
+    if (pPacket != NULL) {
+        HTC_FREE_CONTROL_RX(target,pPacket);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCWaitTarget - Exit\n"));
+
+    return status;
+}
+
+
+
+/* Start HTC, enable interrupts and let the target know host has finished setup */
+A_STATUS HTCStart(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_PACKET *pPacket;
+    A_STATUS   status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCStart Enter\n"));
+
+        /* now that we are starting, push control receive buffers into the
+         * HTC control endpoint */
+
+    while (1) {
+        pPacket = HTC_ALLOC_CONTROL_RX(target);
+        if (NULL == pPacket) {
+            break;
+        }
+        HTCAddReceivePkt((HTC_HANDLE)target,pPacket);
+    }
+
+    do {
+
+        AR_DEBUG_ASSERT(target->InitCredits != NULL);
+        AR_DEBUG_ASSERT(target->EpCreditDistributionListHead != NULL);
+        AR_DEBUG_ASSERT(target->EpCreditDistributionListHead->pNext != NULL);
+
+            /* call init credits callback to do the distribution ,
+             * NOTE: the first entry in the distribution list is ENDPOINT_0, so
+             * we pass the start of the list after this one. */
+        target->InitCredits(target->pCredDistContext,
+                            target->EpCreditDistributionListHead->pNext,
+                            target->TargetCredits);
+
+        if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_TRC)) {
+            DumpCreditDistStates(target);
+        }
+
+            /* the caller is done connecting to services, so we can indicate to the
+            * target that the setup phase is complete */
+        status = HTCSendSetupComplete(target);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* unmask interrupts */
+        status = DevUnmaskInterrupts(&target->Device);
+
+        if (A_FAILED(status)) {
+            HTCStop(target);
+        }
+
+    } while (FALSE);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("HTCStart Exit\n"));
+    return status;
+}
+
+
+/* stop HTC communications, i.e. stop interrupt reception, and flush all queued buffers */
+void HTCStop(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCStop \n"));
+
+        /* mark that we are shutting down .. */
+    target->HTCStateFlags |= HTC_STATE_STOPPING;
+
+        /* Masking interrupts is a synchronous operation, when this function returns
+         * all pending HIF I/O has completed, we can safely flush the queues */
+    DevMaskInterrupts(&target->Device);
+
+        /* flush all send packets */
+    HTCFlushSendPkts(target);
+        /* flush all recv buffers */
+    HTCFlushRecvBuffers(target);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCStop \n"));
+}
+
+/* undo what was done in HTCInit() */
+void HTCShutDown(void)
+{
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCShutDown: \n"));
+    HTCInitialized = FALSE;
+        /* undo HTCInit */
+    HIFShutDownDevice(NULL);
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCShutDown: \n"));
+}
+
+void HTCDumpCreditStates(HTC_HANDLE HTCHandle)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+
+    LOCK_HTC_TX(target);
+
+    DumpCreditDistStates(target);
+
+    UNLOCK_HTC_TX(target);
+}
+
+/* report a target failure from the device, this is a callback from the device layer
+ * which uses a mechanism to report errors from the target (i.e. special interrupts) */
+static void HTCReportFailure(void *Context)
+{
+    HTC_TARGET *target = (HTC_TARGET *)Context;
+
+    target->TargetFailure = TRUE;
+
+    if ((target->pInstanceContext != NULL) && (HTCInitInfo.TargetFailure != NULL)) {
+            /* let upper layer know, it needs to call HTCStop() */
+        HTCInitInfo.TargetFailure(target->pInstanceContext, A_ERROR);
+    }
+}
+
+void DebugDumpBytes(A_UCHAR *buffer, A_UINT16 length, char *pDescription)
+{
+    A_CHAR stream[60];
+    A_UINT32 i;
+    A_UINT16 offset, count;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("<---------Dumping %d Bytes : %s ------>\n", length, pDescription));
+
+    count = 0;
+    offset = 0;
+    for(i = 0; i < length; i++) {
+        sprintf(stream + offset, "%2.2X ", buffer[i]);
+        count ++;
+        offset += 3;
+
+        if(count == 16) {
+            count = 0;
+            offset = 0;
+            AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("[H]: %s\n", stream));
+            A_MEMZERO(stream, 60);
+        }
+    }
+
+    if(offset != 0) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("[H]: %s\n", stream));
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("<------------------------------------------------->\n"));
+}
+
+A_BOOL HTCGetEndpointStatistics(HTC_HANDLE               HTCHandle,
+                                HTC_ENDPOINT_ID          Endpoint,
+                                HTC_ENDPOINT_STAT_ACTION Action,
+                                HTC_ENDPOINT_STATS       *pStats)
+{
+
+#ifdef HTC_EP_STAT_PROFILING
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_BOOL     clearStats = FALSE;
+    A_BOOL     sample = FALSE;
+
+    switch (Action) {
+        case HTC_EP_STAT_SAMPLE :
+            sample = TRUE;
+            break;
+        case HTC_EP_STAT_SAMPLE_AND_CLEAR :
+            sample = TRUE;
+            clearStats = TRUE;
+            break;
+        case HTC_EP_STAT_CLEAR :
+            clearStats = TRUE;
+            break;
+        default:
+            break;
+    }
+
+    A_ASSERT(Endpoint < ENDPOINT_MAX);
+
+        /* lock out TX and RX while we sample and/or clear */
+    LOCK_HTC_TX(target);
+    LOCK_HTC_RX(target);
+
+    if (sample) {
+        A_ASSERT(pStats != NULL);
+            /* return the stats to the caller */
+        A_MEMCPY(pStats, &target->EndPoint[Endpoint].EndPointStats, sizeof(HTC_ENDPOINT_STATS));
+    }
+
+    if (clearStats) {
+            /* reset stats */
+        A_MEMZERO(&target->EndPoint[Endpoint].EndPointStats, sizeof(HTC_ENDPOINT_STATS));
+    }
+
+    UNLOCK_HTC_RX(target);
+    UNLOCK_HTC_TX(target);
+
+    return TRUE;
+#else
+    return FALSE;
+#endif
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_debug.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_debug.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_debug.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,65 @@
+#ifndef HTC_DEBUG_H_
+#define HTC_DEBUG_H_
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/* ------- Debug related stuff ------- */
+enum {
+    ATH_DEBUG_SEND = 0x0001,
+    ATH_DEBUG_RECV = 0x0002,
+    ATH_DEBUG_SYNC = 0x0004,
+    ATH_DEBUG_DUMP = 0x0008,
+    ATH_DEBUG_IRQ  = 0x0010,
+    ATH_DEBUG_TRC  = 0x0020,
+    ATH_DEBUG_WARN = 0x0040,
+    ATH_DEBUG_ERR  = 0x0080,
+    ATH_DEBUG_ANY  = 0xFFFF,
+};
+
+#ifdef DEBUG
+
+// TODO FIX usage of A_PRINTF!
+#define AR_DEBUG_LVL_CHECK(lvl) (debughtc & (lvl))
+#define AR_DEBUG_PRINTBUF(buffer, length, desc) do {   \
+    if (debughtc & ATH_DEBUG_DUMP) {             \
+        DebugDumpBytes(buffer, length,desc);               \
+    }                                            \
+} while(0)
+#define PRINTX_ARG(arg...) arg
+#define AR_DEBUG_PRINTF(flags, args) do {        \
+    if (debughtc & (flags)) {                    \
+        A_PRINTF(KERN_ALERT PRINTX_ARG args);    \
+    }                                            \
+} while (0)
+#define AR_DEBUG_ASSERT(test) do {               \
+    if (!(test)) {                               \
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("Debug Assert Caught, File %s, Line: %d, Test:%s \n",__FILE__, __LINE__,#test));         \
+    }                                            \
+} while(0)
+extern int debughtc;
+#else
+#define AR_DEBUG_PRINTF(flags, args)
+#define AR_DEBUG_PRINTBUF(buffer, length, desc)
+#define AR_DEBUG_ASSERT(test)
+#define AR_DEBUG_LVL_CHECK(lvl) 0
+#endif
+
+void DebugDumpBytes(A_UCHAR *buffer, A_UINT16 length, char *pDescription);
+
+#endif /*HTC_DEBUG_H_*/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_internal.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_internal.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_internal.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,168 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _HTC_INTERNAL_H_
+#define _HTC_INTERNAL_H_
+
+/* for debugging, uncomment this to capture the last frame header, on frame header
+ * processing errors, the last frame header is dump for comparison */
+//#define HTC_CAPTURE_LAST_FRAME
+
+//#define HTC_EP_STAT_PROFILING
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Header files */
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+#include "a_debug.h"
+#include "htc.h"
+#include "htc_api.h"
+#include "bmi_msg.h"
+#include "hif.h"
+#include "ar6k.h"
+
+/* HTC operational parameters */
+#define HTC_TARGET_RESPONSE_TIMEOUT        2000 /* in ms */
+#define HTC_TARGET_DEBUG_INTR_MASK         0x01
+#define HTC_TARGET_CREDIT_INTR_MASK        0xF0
+
+typedef struct _HTC_ENDPOINT {
+    HTC_SERVICE_ID              ServiceID;      /* service ID this endpoint is bound to
+                                                   non-zero value means this endpoint is in use */
+    HTC_PACKET_QUEUE            TxQueue;        /* HTC frame buffer TX queue */
+    HTC_PACKET_QUEUE            RxBuffers;      /* HTC frame buffer RX list */
+    HTC_ENDPOINT_CREDIT_DIST    CreditDist;     /* credit distribution structure (exposed to driver layer) */
+    HTC_EP_CALLBACKS            EpCallBacks;    /* callbacks associated with this endpoint */
+    int                         MaxTxQueueDepth;   /* max depth of the TX queue before we need to
+                                                      call driver's full handler */
+    int                         CurrentTxQueueDepth; /* current TX queue depth */
+    int                         MaxMsgLength;        /* max length of endpoint message */
+#ifdef HTC_EP_STAT_PROFILING
+    HTC_ENDPOINT_STATS          EndPointStats;  /* endpoint statistics */
+#endif
+} HTC_ENDPOINT;
+
+#ifdef HTC_EP_STAT_PROFILING
+#define INC_HTC_EP_STAT(p,stat,count) (p)->EndPointStats.stat += (count);
+#else
+#define INC_HTC_EP_STAT(p,stat,count)
+#endif
+
+#define HTC_SERVICE_TX_PACKET_TAG  HTC_TX_PACKET_TAG_INTERNAL
+
+#define NUM_CONTROL_BUFFERS     8
+#define NUM_CONTROL_TX_BUFFERS  2
+#define NUM_CONTROL_RX_BUFFERS  (NUM_CONTROL_BUFFERS - NUM_CONTROL_TX_BUFFERS)
+
+#define HTC_CONTROL_BUFFER_SIZE (HTC_MAX_CONTROL_MESSAGE_LENGTH + HTC_HDR_LENGTH)
+
+typedef struct HTC_CONTROL_BUFFER {
+    HTC_PACKET    HtcPacket;
+    A_UINT8       Buffer[HTC_CONTROL_BUFFER_SIZE];
+} HTC_CONTROL_BUFFER;
+
+/* our HTC target state */
+typedef struct _HTC_TARGET {
+    HTC_ENDPOINT                EndPoint[ENDPOINT_MAX];
+    HTC_CONTROL_BUFFER          HTCControlBuffers[NUM_CONTROL_BUFFERS];
+    HTC_ENDPOINT_CREDIT_DIST   *EpCreditDistributionListHead;
+    HTC_PACKET_QUEUE            ControlBufferTXFreeList;
+    HTC_PACKET_QUEUE            ControlBufferRXFreeList;
+    HTC_CREDIT_DIST_CALLBACK    DistributeCredits;
+    HTC_CREDIT_INIT_CALLBACK    InitCredits;
+    void                       *pCredDistContext;
+    int                         TargetCredits;
+    int                         TargetCreditSize;
+    A_MUTEX_T                   HTCLock;
+    A_MUTEX_T                   HTCRxLock;
+    A_MUTEX_T                   HTCTxLock;
+    AR6K_DEVICE                 Device;         /* AR6K - specific state */
+    A_UINT32                    HTCStateFlags;
+    HTC_ENDPOINT_ID             EpWaitingForBuffers;
+    A_BOOL                      TargetFailure;
+    void                       *pInstanceContext;
+#define HTC_STATE_WAIT_BUFFERS  (1 << 0)
+#define HTC_STATE_STOPPING      (1 << 1)
+#ifdef HTC_CAPTURE_LAST_FRAME
+    HTC_FRAME_HDR               LastFrameHdr;  /* useful for debugging */
+    A_UINT8                     LastTrailer[256];
+    A_UINT8                     LastTrailerLength;
+#endif
+} HTC_TARGET;
+
+#define HTC_STOPPING(t) ((t)->HTCStateFlags & HTC_STATE_STOPPING)
+#define LOCK_HTC(t)      A_MUTEX_LOCK(&(t)->HTCLock);
+#define UNLOCK_HTC(t)    A_MUTEX_UNLOCK(&(t)->HTCLock);
+#define LOCK_HTC_RX(t)   A_MUTEX_LOCK(&(t)->HTCRxLock);
+#define UNLOCK_HTC_RX(t) A_MUTEX_UNLOCK(&(t)->HTCRxLock);
+#define LOCK_HTC_TX(t)   A_MUTEX_LOCK(&(t)->HTCTxLock);
+#define UNLOCK_HTC_TX(t) A_MUTEX_UNLOCK(&(t)->HTCTxLock);
+
+#define GET_HTC_TARGET_FROM_HANDLE(hnd) ((HTC_TARGET *)(hnd))
+#define HTC_RECYCLE_RX_PKT(target,p)                \
+{                                                   \
+    HTC_PACKET_RESET_RX(pPacket);                   \
+    HTCAddReceivePkt((HTC_HANDLE)(target),(p));     \
+}
+
+/* internal HTC functions */
+void        HTCControlTxComplete(void *Context, HTC_PACKET *pPacket);
+void        HTCControlRecv(void *Context, HTC_PACKET *pPacket);
+A_STATUS    HTCWaitforControlMessage(HTC_TARGET *target, HTC_PACKET **ppControlPacket);
+HTC_PACKET *HTCAllocControlBuffer(HTC_TARGET *target, HTC_PACKET_QUEUE *pList);
+void        HTCFreeControlBuffer(HTC_TARGET *target, HTC_PACKET *pPacket, HTC_PACKET_QUEUE *pList);
+A_STATUS    HTCIssueSend(HTC_TARGET *target, HTC_PACKET *pPacket, A_UINT8 Flags);
+A_STATUS    HTCIssueRecv(HTC_TARGET *target, HTC_PACKET *pPacket);
+void        HTCRecvCompleteHandler(void *Context, HTC_PACKET *pPacket);
+A_STATUS    HTCRecvMessagePendingHandler(void *Context, A_UINT32 LookAhead, A_BOOL *pAsyncProc);
+void        HTCProcessCreditRpt(HTC_TARGET *target, HTC_CREDIT_REPORT *pRpt, int NumEntries, HTC_ENDPOINT_ID FromEndpoint);
+A_STATUS    HTCSendSetupComplete(HTC_TARGET *target);
+void        HTCFlushRecvBuffers(HTC_TARGET *target);
+void        HTCFlushSendPkts(HTC_TARGET *target);
+void        DumpCreditDist(HTC_ENDPOINT_CREDIT_DIST *pEPDist);
+void        DumpCreditDistStates(HTC_TARGET *target);
+void 		DebugDumpBytes(A_UCHAR *buffer, A_UINT16 length, char *pDescription);
+
+static INLINE HTC_PACKET *HTC_ALLOC_CONTROL_TX(HTC_TARGET *target) {
+    HTC_PACKET *pPacket = HTCAllocControlBuffer(target,&target->ControlBufferTXFreeList);
+    if (pPacket != NULL) {
+            /* set payload pointer area with some headroom */
+        pPacket->pBuffer = pPacket->pBufferStart + HTC_HDR_LENGTH;
+    }
+    return pPacket;
+}
+
+#define HTC_FREE_CONTROL_TX(t,p) HTCFreeControlBuffer((t),(p),&(t)->ControlBufferTXFreeList)
+#define HTC_ALLOC_CONTROL_RX(t)  HTCAllocControlBuffer((t),&(t)->ControlBufferRXFreeList)
+#define HTC_FREE_CONTROL_RX(t,p) \
+{                                                                \
+    HTC_PACKET_RESET_RX(p);                                      \
+    HTCFreeControlBuffer((t),(p),&(t)->ControlBufferRXFreeList); \
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HTC_INTERNAL_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_recv.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_recv.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_recv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_recv.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,703 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+#define HTCIssueRecv(t, p) \
+    DevRecvPacket(&(t)->Device,  \
+                  (p),          \
+                  (p)->ActualLength)
+
+#define DO_RCV_COMPLETION(t,p,e)            \
+{                                           \
+    if ((p)->ActualLength > 0) {            \
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" completing packet 0x%X (%d bytes) on ep : %d \n", \
+            (A_UINT32)(p), (p)->ActualLength, (p)->Endpoint));  \
+        (e)->EpCallBacks.EpRecv((e)->EpCallBacks.pContext,      \
+                                (p));                           \
+    } else {                                                    \
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV, (" recycling empty packet \n"));  \
+        HTC_RECYCLE_RX_PKT((t), (p));                           \
+    }                                                           \
+}
+
+#ifdef HTC_EP_STAT_PROFILING
+#define HTC_RX_STAT_PROFILE(t,ep,lookAhead)            \
+{                                                      \
+    LOCK_HTC_RX((t));                                  \
+    INC_HTC_EP_STAT((ep), RxReceived, 1);              \
+    if ((lookAhead) != 0) {                            \
+        INC_HTC_EP_STAT((ep), RxLookAheads, 1);        \
+    }                                                  \
+    UNLOCK_HTC_RX((t));                                \
+}
+#else
+#define HTC_RX_STAT_PROFILE(t,ep,lookAhead)
+#endif
+
+static INLINE A_STATUS HTCProcessTrailer(HTC_TARGET *target,
+                                         A_UINT8    *pBuffer,
+                                         int         Length,
+                                         A_UINT32   *pNextLookAhead,
+                                         HTC_ENDPOINT_ID FromEndpoint)
+{
+    HTC_RECORD_HDR          *pRecord;
+    A_UINT8                 *pRecordBuf;
+    HTC_LOOKAHEAD_REPORT    *pLookAhead;
+    A_UINT8                 *pOrigBuffer;
+    int                     origLength;
+    A_STATUS                status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCProcessTrailer (length:%d) \n", Length));
+
+    if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+        AR_DEBUG_PRINTBUF(pBuffer,Length,"Recv Trailer");
+    }
+
+    pOrigBuffer = pBuffer;
+    origLength = Length;
+    status = A_OK;
+
+    while (Length > 0) {
+
+        if (Length < sizeof(HTC_RECORD_HDR)) {
+            status = A_EPROTO;
+            break;
+        }
+            /* these are byte aligned structs */
+        pRecord = (HTC_RECORD_HDR *)pBuffer;
+        Length -= sizeof(HTC_RECORD_HDR);
+        pBuffer += sizeof(HTC_RECORD_HDR);
+
+        if (pRecord->Length > Length) {
+                /* no room left in buffer for record */
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" invalid record length: %d (id:%d) buffer has: %d bytes left \n",
+                        pRecord->Length, pRecord->RecordID, Length));
+            status = A_EPROTO;
+            break;
+        }
+            /* start of record follows the header */
+        pRecordBuf = pBuffer;
+
+        switch (pRecord->RecordID) {
+            case HTC_RECORD_CREDITS:
+                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_CREDIT_REPORT));
+                HTCProcessCreditRpt(target,
+                                    (HTC_CREDIT_REPORT *)pRecordBuf,
+                                    pRecord->Length / (sizeof(HTC_CREDIT_REPORT)),
+                                    FromEndpoint);
+                break;
+            case HTC_RECORD_LOOKAHEAD:
+                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_LOOKAHEAD_REPORT));
+                pLookAhead = (HTC_LOOKAHEAD_REPORT *)pRecordBuf;
+                if ((pLookAhead->PreValid == ((~pLookAhead->PostValid) & 0xFF)) &&
+                    (pNextLookAhead != NULL)) {
+
+                    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                                (" LookAhead Report Found (pre valid:0x%X, post valid:0x%X) \n",
+                                pLookAhead->PreValid,
+                                pLookAhead->PostValid));
+
+                        /* look ahead bytes are valid, copy them over */
+                    ((A_UINT8 *)pNextLookAhead)[0] = pLookAhead->LookAhead[0];
+                    ((A_UINT8 *)pNextLookAhead)[1] = pLookAhead->LookAhead[1];
+                    ((A_UINT8 *)pNextLookAhead)[2] = pLookAhead->LookAhead[2];
+                    ((A_UINT8 *)pNextLookAhead)[3] = pLookAhead->LookAhead[3];
+
+                    if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+                        DebugDumpBytes((A_UINT8 *)pNextLookAhead,4,"Next Look Ahead");
+                    }
+                }
+                break;
+            default:
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (" unhandled record: id:%d length:%d \n",
+                        pRecord->RecordID, pRecord->Length));
+                break;
+        }
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* advance buffer past this record for next time around */
+        pBuffer += pRecord->Length;
+        Length -= pRecord->Length;
+    }
+
+    if (A_FAILED(status)) {
+        DebugDumpBytes(pOrigBuffer,origLength,"BAD Recv Trailer");
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCProcessTrailer \n"));
+    return status;
+
+}
+
+/* process a received message (i.e. strip off header, process any trailer data)
+ * note : locks must be released when this function is called */
+static A_STATUS HTCProcessRecvHeader(HTC_TARGET *target, HTC_PACKET *pPacket, A_UINT32 *pNextLookAhead)
+{
+    A_UINT8   temp;
+    A_UINT8   *pBuf;
+    A_STATUS  status = A_OK;
+    A_UINT16  payloadLen;
+    A_UINT32  lookAhead;
+
+    pBuf = pPacket->pBuffer;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCProcessRecvHeader \n"));
+
+    if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+        AR_DEBUG_PRINTBUF(pBuf,pPacket->ActualLength,"HTC Recv PKT");
+    }
+
+    do {
+        /* note, we cannot assume the alignment of pBuffer, so we use the safe macros to
+         * retrieve 16 bit fields */
+        payloadLen = A_GET_UINT16_FIELD(pBuf, HTC_FRAME_HDR, PayloadLen);
+
+        ((A_UINT8 *)&lookAhead)[0] = pBuf[0];
+        ((A_UINT8 *)&lookAhead)[1] = pBuf[1];
+        ((A_UINT8 *)&lookAhead)[2] = pBuf[2];
+        ((A_UINT8 *)&lookAhead)[3] = pBuf[3];
+
+        if (lookAhead != pPacket->HTCReserved) {
+            /* somehow the lookahead that gave us the full read length did not
+             * reflect the actual header in the pending message */
+             AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCProcessRecvHeader, lookahead mismatch! \n"));
+             DebugDumpBytes((A_UINT8 *)&pPacket->HTCReserved,4,"Expected Message LookAhead");
+             DebugDumpBytes(pBuf,sizeof(HTC_FRAME_HDR),"Current Frame Header");
+#ifdef HTC_CAPTURE_LAST_FRAME
+            DebugDumpBytes((A_UINT8 *)&target->LastFrameHdr,sizeof(HTC_FRAME_HDR),"Last Frame Header");
+            if (target->LastTrailerLength != 0) {
+                DebugDumpBytes(target->LastTrailer,
+                               target->LastTrailerLength,
+                               "Last trailer");
+            }
+#endif
+            status = A_EPROTO;
+            break;
+        }
+
+            /* get flags */
+        temp = A_GET_UINT8_FIELD(pBuf, HTC_FRAME_HDR, Flags);
+
+        if (temp & HTC_FLAGS_RECV_TRAILER) {
+            /* this packet has a trailer */
+
+                /* extract the trailer length in control byte 0 */
+            temp = A_GET_UINT8_FIELD(pBuf, HTC_FRAME_HDR, ControlBytes[0]);
+
+            if ((temp < sizeof(HTC_RECORD_HDR)) || (temp > payloadLen)) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCProcessRecvHeader, invalid header (payloadlength should be :%d, CB[0] is:%d) \n",
+                        payloadLen, temp));
+                status = A_EPROTO;
+                break;
+            }
+
+                /* process trailer data that follows HDR + application payload */
+            status = HTCProcessTrailer(target,
+                                       (pBuf + HTC_HDR_LENGTH + payloadLen - temp),
+                                       temp,
+                                       pNextLookAhead,
+                                       pPacket->Endpoint);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+#ifdef HTC_CAPTURE_LAST_FRAME
+            A_MEMCPY(target->LastTrailer, (pBuf + HTC_HDR_LENGTH + payloadLen - temp), temp);
+            target->LastTrailerLength = temp;
+#endif
+                /* trim length by trailer bytes */
+            pPacket->ActualLength -= temp;
+        }
+#ifdef HTC_CAPTURE_LAST_FRAME
+         else {
+            target->LastTrailerLength = 0;
+        }
+#endif
+
+            /* if we get to this point, the packet is good */
+            /* remove header and adjust length */
+        pPacket->pBuffer += HTC_HDR_LENGTH;
+        pPacket->ActualLength -= HTC_HDR_LENGTH;
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+            /* dump the whole packet */
+        DebugDumpBytes(pBuf,pPacket->ActualLength,"BAD HTC Recv PKT");
+    } else {
+#ifdef HTC_CAPTURE_LAST_FRAME
+        A_MEMCPY(&target->LastFrameHdr,pBuf,sizeof(HTC_FRAME_HDR));
+#endif
+        if (AR_DEBUG_LVL_CHECK(ATH_DEBUG_RECV)) {
+            if (pPacket->ActualLength > 0) {
+                AR_DEBUG_PRINTBUF(pPacket->pBuffer,pPacket->ActualLength,"HTC - Application Msg");
+            }
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCProcessRecvHeader \n"));
+    return status;
+}
+
+/* asynchronous completion handler for recv packet fetching, when the device layer
+ * completes a read request, it will call this completion handler */
+void HTCRecvCompleteHandler(void *Context, HTC_PACKET *pPacket)
+{
+    HTC_TARGET      *target = (HTC_TARGET *)Context;
+    HTC_ENDPOINT    *pEndpoint;
+    A_UINT32        nextLookAhead = 0;
+    A_STATUS        status;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("+HTCRecvCompleteHandler (status:%d, ep:%d) \n",
+                pPacket->Status, pPacket->Endpoint));
+
+    AR_DEBUG_ASSERT(pPacket->Endpoint < ENDPOINT_MAX);
+    pEndpoint = &target->EndPoint[pPacket->Endpoint];
+    pPacket->Completion = NULL;
+
+        /* get completion status */
+    status = pPacket->Status;
+
+    do {
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, ("HTCRecvCompleteHandler: request failed (status:%d, ep:%d) \n",
+                pPacket->Status, pPacket->Endpoint));
+            break;
+        }
+            /* process the header for any trailer data */
+        status = HTCProcessRecvHeader(target,pPacket,&nextLookAhead);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+            /* was there a lookahead for the next packet? */
+        if (nextLookAhead != 0) {
+            A_STATUS nextStatus;
+            AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                            ("HTCRecvCompleteHandler - next look ahead was non-zero : 0x%X \n",
+                             nextLookAhead));
+                /* we have another packet, get the next packet fetch started (pipelined) before
+                 * we call into the endpoint's callback, this will start another async request */
+            nextStatus = HTCRecvMessagePendingHandler(target,nextLookAhead,NULL);
+            if (A_EPROTO == nextStatus) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                            ("Next look ahead from recv header was INVALID\n"));
+                DebugDumpBytes((A_UINT8 *)&nextLookAhead,
+                                4,
+                                "BAD lookahead from lookahead report");
+            }
+        } else {
+             AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+            ("HTCRecvCompleteHandler - rechecking for more messages...\n"));
+            /* if we did not get anything on the look-ahead,
+             * call device layer to asynchronously re-check for messages. If we can keep the async
+             * processing going we get better performance.  If there is a pending message we will keep processing
+             * messages asynchronously which should pipeline things nicely */
+            DevCheckPendingRecvMsgsAsync(&target->Device);
+        }
+
+        HTC_RX_STAT_PROFILE(target,pEndpoint,nextLookAhead);
+        DO_RCV_COMPLETION(target,pPacket,pEndpoint);
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                         ("HTCRecvCompleteHandler , message fetch failed (status = %d) \n",
+                         status));
+            /* recyle this packet */
+         HTC_RECYCLE_RX_PKT(target, pPacket);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("-HTCRecvCompleteHandler\n"));
+}
+
+/* synchronously wait for a control message from the target,
+ * This function is used at initialization time ONLY.  At init messages
+ * on ENDPOINT 0 are expected. */
+A_STATUS HTCWaitforControlMessage(HTC_TARGET *target, HTC_PACKET **ppControlPacket)
+{
+    A_STATUS        status;
+    A_UINT32        lookAhead;
+    HTC_PACKET      *pPacket = NULL;
+    HTC_FRAME_HDR   *pHdr;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCWaitforControlMessage \n"));
+
+    do  {
+
+        *ppControlPacket = NULL;
+
+            /* call the polling function to see if we have a message */
+        status = DevPollMboxMsgRecv(&target->Device,
+                                    &lookAhead,
+                                    HTC_TARGET_RESPONSE_TIMEOUT);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV,
+                ("HTCWaitforControlMessage : lookAhead : 0x%X \n", lookAhead));
+
+            /* check the lookahead */
+        pHdr = (HTC_FRAME_HDR *)&lookAhead;
+
+        if (pHdr->EndpointID != ENDPOINT_0) {
+                /* unexpected endpoint number, should be zero */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        if (A_FAILED(status)) {
+                /* bad message */
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+        pPacket = HTC_ALLOC_CONTROL_RX(target);
+
+        if (pPacket == NULL) {
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_NO_MEMORY;
+            break;
+        }
+
+        pPacket->HTCReserved = lookAhead;
+        pPacket->ActualLength = pHdr->PayloadLen + HTC_HDR_LENGTH;
+
+        if (pPacket->ActualLength > pPacket->BufferLength) {
+            AR_DEBUG_ASSERT(FALSE);
+            status = A_EPROTO;
+            break;
+        }
+
+            /* we want synchronous operation */
+        pPacket->Completion = NULL;
+
+            /* get the message from the device, this will block */
+        status = HTCIssueRecv(target, pPacket);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+            /* process receive header */
+        status = HTCProcessRecvHeader(target,pPacket,NULL);
+
+        pPacket->Status = status;
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCWaitforControlMessage, HTCProcessRecvHeader failed (status = %d) \n",
+                     status));
+            break;
+        }
+
+            /* give the caller this control message packet, they are responsible to free */
+        *ppControlPacket = pPacket;
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        if (pPacket != NULL) {
+                /* cleanup buffer on error */
+            HTC_FREE_CONTROL_RX(target,pPacket);
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCWaitforControlMessage \n"));
+
+    return status;
+}
+
+/* callback when device layer or lookahead report parsing detects a pending message */
+A_STATUS HTCRecvMessagePendingHandler(void *Context, A_UINT32 LookAhead, A_BOOL *pAsyncProc)
+{
+    HTC_TARGET      *target = (HTC_TARGET *)Context;
+    A_STATUS         status = A_OK;
+    HTC_PACKET      *pPacket = NULL;
+    HTC_FRAME_HDR   *pHdr;
+    HTC_ENDPOINT    *pEndpoint;
+    A_BOOL          asyncProc = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("+HTCRecvMessagePendingHandler LookAhead:0x%X \n",LookAhead));
+
+    if (IS_DEV_IRQ_PROCESSING_ASYNC_ALLOWED(&target->Device)) {
+            /* We use async mode to get the packets if the device layer supports it.
+             * The device layer interfaces with HIF in which HIF may have restrictions on
+             * how interrupts are processed */
+        asyncProc = TRUE;
+    }
+
+    if (pAsyncProc != NULL) {
+            /* indicate to caller how we decided to process this */
+        *pAsyncProc = asyncProc;
+    }
+
+    while (TRUE) {
+
+        pHdr = (HTC_FRAME_HDR *)&LookAhead;
+
+        if (pHdr->EndpointID >= ENDPOINT_MAX) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Invalid Endpoint in look-ahead: %d \n",pHdr->EndpointID));
+                /* invalid endpoint */
+            status = A_EPROTO;
+            break;
+        }
+
+        if (pHdr->PayloadLen > HTC_MAX_PAYLOAD_LENGTH) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Payload length %d exceeds max HTC : %d !\n",
+                    pHdr->PayloadLen, HTC_MAX_PAYLOAD_LENGTH));
+            status = A_EPROTO;
+            break;
+        }
+
+        pEndpoint = &target->EndPoint[pHdr->EndpointID];
+
+        if (0 == pEndpoint->ServiceID) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("Endpoint %d is not connected !\n",pHdr->EndpointID));
+                /* endpoint isn't even connected */
+            status = A_EPROTO;
+            break;
+        }
+
+            /* lock RX to get a buffer */
+        LOCK_HTC_RX(target);
+
+            /* get a packet from the endpoint recv queue */
+        pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);
+
+        if (NULL == pPacket) {
+                /* check for refill handler */
+            if (pEndpoint->EpCallBacks.EpRecvRefill != NULL) {
+                UNLOCK_HTC_RX(target);
+                    /* call the re-fill handler */
+                pEndpoint->EpCallBacks.EpRecvRefill(pEndpoint->EpCallBacks.pContext,
+                                                    pHdr->EndpointID);
+                LOCK_HTC_RX(target);
+                    /* check if we have more buffers */
+                pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);
+                    /* fall through */
+            }
+        }
+
+        if (NULL == pPacket) {
+                /* this is not an error, we simply need to mark that we are waiting for buffers.*/
+            target->HTCStateFlags |= HTC_STATE_WAIT_BUFFERS;
+            target->EpWaitingForBuffers = pHdr->EndpointID;
+            status = A_NO_MEMORY;
+        }
+
+        UNLOCK_HTC_RX(target);
+
+        if (A_FAILED(status)) {
+                /* no buffers */
+            break;
+        }
+
+        AR_DEBUG_ASSERT(pPacket->Endpoint == pHdr->EndpointID);
+
+            /* make sure this message can fit in the endpoint buffer */
+        if ((pHdr->PayloadLen + HTC_HDR_LENGTH) > pPacket->BufferLength) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("Payload Length Error : header reports payload of: %d, endpoint buffer size: %d \n",
+                    pHdr->PayloadLen, pPacket->BufferLength));
+            status = A_EPROTO;
+            break;
+        }
+
+        pPacket->HTCReserved = LookAhead; /* set expected look ahead */
+            /* set the amount of data to fetch */
+        pPacket->ActualLength = pHdr->PayloadLen + HTC_HDR_LENGTH;
+
+        if (asyncProc) {
+                /* we use async mode to get the packet if the device layer supports it
+                 * set our callback and context */
+            pPacket->Completion = HTCRecvCompleteHandler;
+            pPacket->pContext = target;
+        } else {
+                /* fully synchronous */
+            pPacket->Completion = NULL;
+        }
+
+            /* go fetch the packet */
+        status = HTCIssueRecv(target, pPacket);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        if (asyncProc) {
+                /* we did this asynchronously so we can get out of the loop, the asynch processing
+                 * creates a chain of requests to continue processing pending messages in the
+                 * context of callbacks  */
+            break;
+        }
+
+            /* in the sync case, we process the packet, check lookaheads and then repeat */
+
+        LookAhead = 0;
+        status = HTCProcessRecvHeader(target,pPacket,&LookAhead);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        HTC_RX_STAT_PROFILE(target,pEndpoint,LookAhead);
+        DO_RCV_COMPLETION(target,pPacket,pEndpoint);
+
+        pPacket = NULL;
+
+        if (0 == LookAhead) {
+            break;
+        }
+
+    }
+
+    if (A_NO_MEMORY == status) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                (" Endpoint :%d has no buffers, blocking receiver to prevent overrun.. \n",
+                pHdr->EndpointID));
+            /* try to stop receive at the device layer */
+        DevStopRecv(&target->Device, asyncProc ? DEV_STOP_RECV_ASYNC : DEV_STOP_RECV_SYNC);
+        status = A_OK;
+    } else if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                        ("Failed to get pending message : LookAhead Value: 0x%X (status = %d) \n",
+                        LookAhead, status));
+        if (pPacket != NULL) {
+                /* clean up packet on error */
+            HTC_RECYCLE_RX_PKT(target, pPacket);
+        }
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_RECV,("-HTCRecvMessagePendingHandler \n"));
+
+    return status;
+}
+
+/* Makes a buffer available to the HTC module */
+A_STATUS HTCAddReceivePkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT *pEndpoint;
+    A_BOOL       unblockRecv = FALSE;
+    A_STATUS     status = A_OK;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    ("+- HTCAddReceivePkt: endPointId: %d, buffer: 0x%X, length: %d\n",
+                    pPacket->Endpoint, (A_UINT32)pPacket->pBuffer, pPacket->BufferLength));
+
+    do {
+
+        if (HTC_STOPPING(target)) {
+            status = A_ECANCELED;
+            break;
+        }
+
+        AR_DEBUG_ASSERT(pPacket->Endpoint < ENDPOINT_MAX);
+
+        pEndpoint = &target->EndPoint[pPacket->Endpoint];
+
+        LOCK_HTC_RX(target);
+
+            /* store receive packet */
+        HTC_PACKET_ENQUEUE(&pEndpoint->RxBuffers, pPacket);
+
+            /* check if we are blocked waiting for a new buffer */
+        if (target->HTCStateFlags & HTC_STATE_WAIT_BUFFERS) {
+            if (target->EpWaitingForBuffers == pPacket->Endpoint) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_RECV,(" receiver was blocked on ep:%d, unblocking.. \n",
+                    target->EpWaitingForBuffers));
+                target->HTCStateFlags &= ~HTC_STATE_WAIT_BUFFERS;
+                target->EpWaitingForBuffers = ENDPOINT_MAX;
+                unblockRecv = TRUE;
+            }
+        }
+
+        UNLOCK_HTC_RX(target);
+
+        if (unblockRecv && !HTC_STOPPING(target)) {
+                /* TODO : implement a buffer threshold count? */
+            DevEnableRecv(&target->Device,DEV_ENABLE_RECV_SYNC);
+        }
+
+    } while (FALSE);
+
+    return status;
+}
+
+static void HTCFlushEndpointRX(HTC_TARGET *target, HTC_ENDPOINT *pEndpoint)
+{
+    HTC_PACKET  *pPacket;
+
+    LOCK_HTC_RX(target);
+
+    while (1) {
+        pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->RxBuffers);
+        if (NULL == pPacket) {
+            break;
+        }
+        UNLOCK_HTC_RX(target);
+        pPacket->Status = A_ECANCELED;
+        pPacket->ActualLength = 0;
+        AR_DEBUG_PRINTF(ATH_DEBUG_RECV, ("  Flushing RX packet:0x%X, length:%d, ep:%d \n",
+                (A_UINT32)pPacket, pPacket->BufferLength, pPacket->Endpoint));
+            /* give the packet back */
+        pEndpoint->EpCallBacks.EpRecv(pEndpoint->EpCallBacks.pContext,
+                                      pPacket);
+        LOCK_HTC_RX(target);
+    }
+
+    UNLOCK_HTC_RX(target);
+
+
+}
+
+void HTCFlushRecvBuffers(HTC_TARGET *target)
+{
+    HTC_ENDPOINT    *pEndpoint;
+    int             i;
+
+        /* NOTE: no need to flush endpoint 0, these buffers were
+         * allocated as part of the HTC struct */
+    for (i = ENDPOINT_1; i < ENDPOINT_MAX; i++) {
+        pEndpoint = &target->EndPoint[i];
+        if (pEndpoint->ServiceID == 0) {
+                /* not in use.. */
+            continue;
+        }
+        HTCFlushEndpointRX(target,pEndpoint);
+    }
+
+
+}
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_send.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_send.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_send.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_send.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,538 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+#define DO_EP_TX_COMPLETION(ep,p)                                    \
+{                                                                    \
+    (p)->Completion = NULL;                                          \
+    (ep)->EpCallBacks.EpTxComplete((ep)->EpCallBacks.pContext,(p));  \
+}
+
+
+/* call the distribute credits callback with the distribution */
+#define DO_DISTRIBUTION(t,reason,description,pList) \
+{                                             \
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,           \
+        ("  calling distribute function (%s) (dfn:0x%X, ctxt:0x%X, dist:0x%X) \n", \
+                (description),                                           \
+                (A_UINT32)(t)->DistributeCredits,                        \
+                (A_UINT32)(t)->pCredDistContext,                         \
+                (A_UINT32)pList));                                       \
+    (t)->DistributeCredits((t)->pCredDistContext,                        \
+                           (pList),                                      \
+                           (reason));                                    \
+}
+
+/* our internal send packet completion handler when packets are submited to the AR6K device
+ * layer */
+static void HTCSendPktCompletionHandler(void *Context, HTC_PACKET *pPacket)
+{
+    HTC_TARGET      *target = (HTC_TARGET *)Context;
+    HTC_ENDPOINT    *pEndpoint = &target->EndPoint[pPacket->Endpoint];
+
+
+    if (A_FAILED(pPacket->Status)) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+            ("HTCSendPktCompletionHandler: request failed (status:%d, ep:%d) \n",
+                pPacket->Status, pPacket->Endpoint));
+    }
+        /* first, fixup the head room we allocated */
+    pPacket->pBuffer += HTC_HDR_LENGTH;
+        /* do completion */
+    DO_EP_TX_COMPLETION(pEndpoint,pPacket);
+}
+
+A_STATUS HTCIssueSend(HTC_TARGET *target, HTC_PACKET *pPacket, A_UINT8 SendFlags)
+{
+    A_STATUS status;
+    A_UINT8 *pHdrBuf;
+    A_BOOL   sync = FALSE;
+
+        /* caller always provides headrooom */
+    pPacket->pBuffer -= HTC_HDR_LENGTH;
+    pHdrBuf = pPacket->pBuffer;
+        /* setup frame header */
+    A_SET_UINT16_FIELD(pHdrBuf,HTC_FRAME_HDR,PayloadLen,(A_UINT16)pPacket->ActualLength);
+    A_SET_UINT8_FIELD(pHdrBuf,HTC_FRAME_HDR,Flags,SendFlags);
+    A_SET_UINT8_FIELD(pHdrBuf,HTC_FRAME_HDR,EndpointID, (A_UINT8)pPacket->Endpoint);
+
+    if (pPacket->Completion == NULL) {
+            /* mark that this request was synchronously issued */
+        sync = TRUE;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    ("+-HTCIssueSend: transmit length : %d (%s) \n",
+                    pPacket->ActualLength + HTC_HDR_LENGTH,
+                    sync ? "SYNC" : "ASYNC" ));
+
+        /* send message to device */
+    status = DevSendPacket(&target->Device,
+                           pPacket,
+                           pPacket->ActualLength + HTC_HDR_LENGTH);
+
+    if (sync) {
+            /* use local sync variable.  If this was issued asynchronously, pPacket is no longer
+             * safe to access. */
+        pPacket->pBuffer += HTC_HDR_LENGTH;
+    }
+
+    /* if this request was asynchronous, the packet completion routine will be invoked by
+     * the device layer when the HIF layer completes the request */
+
+    return status;
+}
+
+/* try to send the current packet or a packet at the head of the TX queue,
+ * if there are no credits, the packet remains in the queue. */
+static void HTCTrySend(HTC_TARGET      *target,
+                       HTC_PACKET      *pPacketToSend,
+                       HTC_ENDPOINT_ID ep)
+{
+    HTC_PACKET   *pPacket;
+    HTC_ENDPOINT *pEndpoint;
+    int          creditsRequired;
+    A_UINT8      sendFlags;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,("+HTCTrySend (pPkt:0x%X)\n",(A_UINT32)pPacketToSend));
+
+    pEndpoint = &target->EndPoint[ep];
+
+    LOCK_HTC_TX(target);
+
+    if (pPacketToSend != NULL) {
+        /* caller supplied us a packet to queue to the tail of the HTC TX queue before
+         * we check the tx queue */
+        HTC_PACKET_ENQUEUE(&pEndpoint->TxQueue,pPacketToSend);
+        pEndpoint->CurrentTxQueueDepth++;
+    }
+
+        /* now drain the TX queue for transmission as long as we have enough
+         * credits */
+
+    while (1) {
+
+        if (HTC_QUEUE_EMPTY(&pEndpoint->TxQueue)) {
+                /* nothing in the queue */
+            break;
+        }
+
+        sendFlags = 0;
+
+            /* get packet at head, but don't remove it */
+        pPacket = HTC_GET_PKT_AT_HEAD(&pEndpoint->TxQueue);
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND,(" Got head packet:0x%X , Queue Depth: %d\n",
+                (A_UINT32)pPacket, pEndpoint->CurrentTxQueueDepth));
+
+            /* figure out how many credits this message requires */
+        creditsRequired  = pPacket->ActualLength + HTC_HDR_LENGTH;
+        creditsRequired += target->TargetCreditSize - 1;
+        creditsRequired /= target->TargetCreditSize;
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND,(" Creds Required:%d   Got:%d\n",
+                            creditsRequired, pEndpoint->CreditDist.TxCredits));
+
+        if (pEndpoint->CreditDist.TxCredits < creditsRequired) {
+
+            /* not enough credits */
+
+            if (pPacket->Endpoint == ENDPOINT_0) {
+                    /* leave it in the queue */
+                break;
+            }
+                /* invoke the registered distribution function only if this is not
+                 * endpoint 0, we let the driver layer provide more credits if it can.
+                 * We pass the credit distribution list starting at the endpoint in question
+                 * */
+
+                /* set how many credits we need  */
+            pEndpoint->CreditDist.TxCreditsSeek =
+                                    creditsRequired - pEndpoint->CreditDist.TxCredits;
+            DO_DISTRIBUTION(target,
+                            HTC_CREDIT_DIST_SEEK_CREDITS,
+                            "Seek Credits",
+                            &pEndpoint->CreditDist);
+
+            pEndpoint->CreditDist.TxCreditsSeek = 0;
+
+            if (pEndpoint->CreditDist.TxCredits < creditsRequired) {
+                    /* still not enough credits to send, leave packet in the queue */
+                AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    (" Not enough credits for ep %d leaving packet in queue..\n",
+                    pPacket->Endpoint));
+                break;
+            }
+
+        }
+
+        pEndpoint->CreditDist.TxCredits -= creditsRequired;
+        INC_HTC_EP_STAT(pEndpoint, TxCreditsConsummed, creditsRequired);
+
+            /* check if we need credits */
+        if (pEndpoint->CreditDist.TxCredits < pEndpoint->CreditDist.TxCreditsPerMaxMsg) {
+            sendFlags |= HTC_FLAGS_NEED_CREDIT_UPDATE;
+            INC_HTC_EP_STAT(pEndpoint, TxCreditLowIndications, 1);
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND,(" Host Needs Credits  \n"));
+        }
+
+            /* now we can fully dequeue */
+        pPacket = HTC_PACKET_DEQUEUE(&pEndpoint->TxQueue);
+        pEndpoint->CurrentTxQueueDepth--;
+
+        INC_HTC_EP_STAT(pEndpoint, TxIssued, 1);
+
+        UNLOCK_HTC_TX(target);
+
+        HTCIssueSend(target, pPacket, sendFlags);
+
+        LOCK_HTC_TX(target);
+
+        /* go back and check for more messages */
+    }
+
+    if (pEndpoint->CurrentTxQueueDepth >= pEndpoint->MaxTxQueueDepth) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Endpoint %d, TX queue is full, Depth:%d, Max:%d \n",
+                        ep, pEndpoint->CurrentTxQueueDepth, pEndpoint->MaxTxQueueDepth));
+        UNLOCK_HTC_TX(target);
+            /* queue is now full, let caller know */
+        if (pEndpoint->EpCallBacks.EpSendFull != NULL) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Calling driver's send full callback.... \n"));
+            pEndpoint->EpCallBacks.EpSendFull(pEndpoint->EpCallBacks.pContext, ep);
+        }
+    } else {
+        UNLOCK_HTC_TX(target);
+            /* queue is now available for new packet, let caller know */
+        if (pEndpoint->EpCallBacks.EpSendAvail)
+            pEndpoint->EpCallBacks.EpSendAvail(pEndpoint->EpCallBacks.pContext, ep);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,("-HTCTrySend:  \n"));
+}
+
+/* HTC API - HTCSendPkt */
+A_STATUS HTCSendPkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket)
+{
+    HTC_TARGET      *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT    *pEndpoint;
+    HTC_ENDPOINT_ID ep;
+    A_STATUS        status = A_OK;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND,
+                    ("+HTCSendPkt: Enter endPointId: %d, buffer: 0x%X, length: %d \n",
+                    pPacket->Endpoint, (A_UINT32)pPacket->pBuffer, pPacket->ActualLength));
+
+    ep = pPacket->Endpoint;
+    AR_DEBUG_ASSERT(ep < ENDPOINT_MAX);
+    pEndpoint = &target->EndPoint[ep];
+
+    do {
+
+        if (HTC_STOPPING(target)) {
+            status = A_ECANCELED;
+            pPacket->Status = status;
+            DO_EP_TX_COMPLETION(pEndpoint,pPacket);
+            break;
+        }
+            /* everything sent through this interface is asynchronous */
+            /* fill in HTC completion routines */
+        pPacket->Completion = HTCSendPktCompletionHandler;
+        pPacket->pContext = target;
+
+        HTCTrySend(target, pPacket, ep);
+
+    } while (FALSE);
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("-HTCSendPkt \n"));
+
+    return status;
+}
+
+
+/* check TX queues to drain because of credit distribution update */
+static INLINE void HTCCheckEndpointTxQueues(HTC_TARGET *target)
+{
+    HTC_ENDPOINT                *pEndpoint;
+    HTC_ENDPOINT_CREDIT_DIST    *pDistItem;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("+HTCCheckEndpointTxQueues \n"));
+    pDistItem = target->EpCreditDistributionListHead;
+
+        /* run through the credit distribution list to see
+         * if there are packets queued
+         * NOTE: no locks need to be taken since the distribution list
+         * is not dynamic (cannot be re-ordered) and we are not modifying any state */
+    while (pDistItem != NULL) {
+        pEndpoint = (HTC_ENDPOINT *)pDistItem->pHTCReserved;
+
+        if (pEndpoint->CurrentTxQueueDepth > 0) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_SEND, (" Ep %d has %d credits and %d Packets in TX Queue \n",
+                    pDistItem->Endpoint, pEndpoint->CreditDist.TxCredits, pEndpoint->CurrentTxQueueDepth));
+                /* try to start the stalled queue, this list is ordered by priority.
+                 * Highest priority queue get's processed first, if there are credits available the
+                 * highest priority queue will get a chance to reclaim credits from lower priority
+                 * ones */
+            HTCTrySend(target, NULL, pDistItem->Endpoint);
+        }
+
+        pDistItem = pDistItem->pNext;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("-HTCCheckEndpointTxQueues \n"));
+}
+
+/* process credit reports and call distribution function */
+void HTCProcessCreditRpt(HTC_TARGET *target, HTC_CREDIT_REPORT *pRpt, int NumEntries, HTC_ENDPOINT_ID FromEndpoint)
+{
+    int             i;
+    HTC_ENDPOINT    *pEndpoint;
+    int             totalCredits = 0;
+    A_BOOL          doDist = FALSE;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("+HTCProcessCreditRpt, Credit Report Entries:%d \n", NumEntries));
+
+        /* lock out TX while we update credits */
+    LOCK_HTC_TX(target);
+
+    for (i = 0; i < NumEntries; i++, pRpt++) {
+        if (pRpt->EndpointID >= ENDPOINT_MAX) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+        pEndpoint = &target->EndPoint[pRpt->EndpointID];
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("  Endpoint %d got %d credits \n",
+                pRpt->EndpointID, pRpt->Credits));
+
+
+#ifdef HTC_EP_STAT_PROFILING
+
+        INC_HTC_EP_STAT(pEndpoint, TxCreditRpts, 1);
+        INC_HTC_EP_STAT(pEndpoint, TxCreditsReturned, pRpt->Credits);
+
+        if (FromEndpoint == pRpt->EndpointID) {
+                /* this credit report arrived on the same endpoint indicating it arrived in an RX
+                 * packet */
+            INC_HTC_EP_STAT(pEndpoint, TxCreditsFromRx, pRpt->Credits);
+            INC_HTC_EP_STAT(pEndpoint, TxCreditRptsFromRx, 1);
+        } else if (FromEndpoint == ENDPOINT_0) {
+                /* this credit arrived on endpoint 0 as a NULL message */
+            INC_HTC_EP_STAT(pEndpoint, TxCreditsFromEp0, pRpt->Credits);
+            INC_HTC_EP_STAT(pEndpoint, TxCreditRptsFromEp0, 1);
+        } else {
+                /* arrived on another endpoint */
+            INC_HTC_EP_STAT(pEndpoint, TxCreditsFromOther, pRpt->Credits);
+            INC_HTC_EP_STAT(pEndpoint, TxCreditRptsFromOther, 1);
+        }
+
+#endif
+
+        if (ENDPOINT_0 == pRpt->EndpointID) {
+                /* always give endpoint 0 credits back */
+            pEndpoint->CreditDist.TxCredits += pRpt->Credits;
+        } else {
+                /* for all other endpoints, update credits to distribute, the distribution function
+                 * will handle giving out credits back to the endpoints */
+            pEndpoint->CreditDist.TxCreditsToDist += pRpt->Credits;
+                /* flag that we have to do the distribution */
+            doDist = TRUE;
+        }
+
+        totalCredits += pRpt->Credits;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("  Report indicated %d credits to distribute \n", totalCredits));
+
+    if (doDist) {
+            /* this was a credit return based on a completed send operations
+             * note, this is done with the lock held */
+        DO_DISTRIBUTION(target,
+                        HTC_CREDIT_DIST_SEND_COMPLETE,
+                        "Send Complete",
+                        target->EpCreditDistributionListHead->pNext);
+    }
+
+    UNLOCK_HTC_TX(target);
+
+    if (totalCredits) {
+        HTCCheckEndpointTxQueues(target);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_SEND, ("-HTCProcessCreditRpt \n"));
+}
+
+/* flush endpoint TX queue */
+static void HTCFlushEndpointTX(HTC_TARGET *target, HTC_ENDPOINT *pEndpoint, HTC_TX_TAG Tag)
+{
+    HTC_PACKET          *pPacket;
+    HTC_PACKET_QUEUE    discardQueue;
+
+        /* initialize the discard queue */
+    INIT_HTC_PACKET_QUEUE(&discardQueue);
+
+    LOCK_HTC_TX(target);
+
+        /* interate from the front of the TX queue and flush out packets */
+    ITERATE_OVER_LIST_ALLOW_REMOVE(&pEndpoint->TxQueue, pPacket, HTC_PACKET, ListLink) {
+
+            /* check for removal */
+        if ((HTC_TX_PACKET_TAG_ALL == Tag) || (Tag == pPacket->PktInfo.AsTx.Tag)) {
+                /* remove from queue */
+            HTC_PACKET_REMOVE(pPacket);
+                /* add it to the discard pile */
+            HTC_PACKET_ENQUEUE(&discardQueue, pPacket);
+            pEndpoint->CurrentTxQueueDepth--;
+        }
+
+    } ITERATE_END;
+
+    UNLOCK_HTC_TX(target);
+
+        /* empty the discard queue */
+    while (1) {
+        pPacket = HTC_PACKET_DEQUEUE(&discardQueue);
+        if (NULL == pPacket) {
+            break;
+        }
+        pPacket->Status = A_ECANCELED;
+        AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("  Flushing TX packet:0x%X, length:%d, ep:%d tag:0x%X \n",
+                (A_UINT32)pPacket, pPacket->ActualLength, pPacket->Endpoint, pPacket->PktInfo.AsTx.Tag));
+        DO_EP_TX_COMPLETION(pEndpoint,pPacket);
+    }
+
+}
+
+void DumpCreditDist(HTC_ENDPOINT_CREDIT_DIST *pEPDist)
+{
+#ifdef DEBUG
+    HTC_ENDPOINT *pEndpoint = (HTC_ENDPOINT *)pEPDist->pHTCReserved;
+#endif
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("--- EP : %d  ServiceID: 0x%X    --------------\n",
+                        pEPDist->Endpoint, pEPDist->ServiceID));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" this:0x%X next:0x%X prev:0x%X\n",
+                (A_UINT32)pEPDist, (A_UINT32)pEPDist->pNext, (A_UINT32)pEPDist->pPrev));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" DistFlags          : 0x%X \n", pEPDist->DistFlags));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsNorm      : %d \n", pEPDist->TxCreditsNorm));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsMin       : %d \n", pEPDist->TxCreditsMin));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCredits          : %d \n", pEPDist->TxCredits));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsAssigned  : %d \n", pEPDist->TxCreditsAssigned));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsSeek      : %d \n", pEPDist->TxCreditsSeek));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditSize       : %d \n", pEPDist->TxCreditSize));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsPerMaxMsg : %d \n", pEPDist->TxCreditsPerMaxMsg));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxCreditsToDist    : %d \n", pEPDist->TxCreditsToDist));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, (" TxQueueDepth       : %d \n", pEndpoint->CurrentTxQueueDepth));
+    AR_DEBUG_PRINTF(ATH_DEBUG_ANY, ("----------------------------------------------------\n"));
+}
+
+void DumpCreditDistStates(HTC_TARGET *target)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pEPList = target->EpCreditDistributionListHead;
+
+    while (pEPList != NULL) {
+        DumpCreditDist(pEPList);
+        pEPList = pEPList->pNext;
+    }
+
+    if (target->DistributeCredits != NULL) {
+        DO_DISTRIBUTION(target,
+                        HTC_DUMP_CREDIT_STATE,
+                        "Dump State",
+                        NULL);
+    }
+}
+
+/* flush all send packets from all endpoint queues */
+void HTCFlushSendPkts(HTC_TARGET *target)
+{
+    HTC_ENDPOINT    *pEndpoint;
+    int             i;
+
+    DumpCreditDistStates(target);
+
+    for (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {
+        pEndpoint = &target->EndPoint[i];
+        if (pEndpoint->ServiceID == 0) {
+                /* not in use.. */
+            continue;
+        }
+        HTCFlushEndpointTX(target,pEndpoint,HTC_TX_PACKET_TAG_ALL);
+    }
+
+}
+
+/* HTC API to flush an endpoint's TX queue*/
+void HTCFlushEndpoint(HTC_HANDLE HTCHandle, HTC_ENDPOINT_ID Endpoint, HTC_TX_TAG Tag)
+{
+    HTC_TARGET      *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT    *pEndpoint = &target->EndPoint[Endpoint];
+
+    if (pEndpoint->ServiceID == 0) {
+        AR_DEBUG_ASSERT(FALSE);
+        /* not in use.. */
+        return;
+    }
+
+    HTCFlushEndpointTX(target, pEndpoint, Tag);
+}
+
+/* HTC API to indicate activity to the credit distribution function */
+void HTCIndicateActivityChange(HTC_HANDLE      HTCHandle,
+                               HTC_ENDPOINT_ID Endpoint,
+                               A_BOOL          Active)
+{
+    HTC_TARGET      *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    HTC_ENDPOINT    *pEndpoint = &target->EndPoint[Endpoint];
+    A_BOOL          doDist = FALSE;
+
+    if (pEndpoint->ServiceID == 0) {
+        AR_DEBUG_ASSERT(FALSE);
+        /* not in use.. */
+        return;
+    }
+
+    LOCK_HTC_TX(target);
+
+    if (Active) {
+        if (!(pEndpoint->CreditDist.DistFlags & HTC_EP_ACTIVE)) {
+                /* mark active now */
+            pEndpoint->CreditDist.DistFlags |= HTC_EP_ACTIVE;
+            doDist = TRUE;
+        }
+    } else {
+        if (pEndpoint->CreditDist.DistFlags & HTC_EP_ACTIVE) {
+                /* mark inactive now */
+            pEndpoint->CreditDist.DistFlags &= ~HTC_EP_ACTIVE;
+            doDist = TRUE;
+        }
+    }
+
+    if (doDist) {
+        /* do distribution again based on activity change
+         * note, this is done with the lock held */
+        DO_DISTRIBUTION(target,
+                        HTC_CREDIT_DIST_ACTIVITY_CHANGE,
+                        "Activity Change",
+                        target->EpCreditDistributionListHead->pNext);
+    }
+
+    UNLOCK_HTC_TX(target);
+
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_services.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_services.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/htc/htc_services.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/htc/htc_services.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,403 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "htc_internal.h"
+
+void HTCControlTxComplete(void *Context, HTC_PACKET *pPacket)
+{
+        /* not implemented
+         * we do not send control TX frames during normal runtime, only during setup  */
+    AR_DEBUG_ASSERT(FALSE);
+}
+
+    /* callback when a control message arrives on this endpoint */
+void HTCControlRecv(void *Context, HTC_PACKET *pPacket)
+{
+    AR_DEBUG_ASSERT(pPacket->Endpoint == ENDPOINT_0);
+
+        /* the only control messages we are expecting are NULL messages (credit resports), which should
+         * never get here */
+    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    ("HTCControlRecv, got message with length:%d \n",
+                    pPacket->ActualLength + HTC_HDR_LENGTH));
+
+        /* dump header and message */
+    DebugDumpBytes(pPacket->pBuffer - HTC_HDR_LENGTH,
+                   pPacket->ActualLength + HTC_HDR_LENGTH,
+                   "Unexpected ENDPOINT 0 Message");
+
+    HTC_RECYCLE_RX_PKT((HTC_TARGET*)Context,pPacket);
+}
+
+A_STATUS HTCSendSetupComplete(HTC_TARGET *target)
+{
+    HTC_PACKET             *pSendPacket = NULL;
+    A_STATUS                status;
+    HTC_SETUP_COMPLETE_MSG *pSetupComplete;
+
+    do {
+           /* allocate a packet to send to the target */
+        pSendPacket = HTC_ALLOC_CONTROL_TX(target);
+
+        if (NULL == pSendPacket) {
+            status = A_NO_MEMORY;
+            break;
+        }
+
+            /* assemble setup complete message */
+        pSetupComplete = (HTC_SETUP_COMPLETE_MSG *)pSendPacket->pBuffer;
+        A_MEMZERO(pSetupComplete,sizeof(HTC_SETUP_COMPLETE_MSG));
+        pSetupComplete->MessageID = HTC_MSG_SETUP_COMPLETE_ID;
+
+        SET_HTC_PACKET_INFO_TX(pSendPacket,
+                               NULL,
+                               (A_UINT8 *)pSetupComplete,
+                               sizeof(HTC_SETUP_COMPLETE_MSG),
+                               ENDPOINT_0,
+                               HTC_SERVICE_TX_PACKET_TAG);
+
+            /* we want synchronous operation */
+        pSendPacket->Completion = NULL;
+            /* send the message */
+        status = HTCIssueSend(target,pSendPacket,0);
+
+    } while (FALSE);
+
+    if (pSendPacket != NULL) {
+        HTC_FREE_CONTROL_TX(target,pSendPacket);
+    }
+
+    return status;
+}
+
+
+A_STATUS HTCConnectService(HTC_HANDLE               HTCHandle,
+                           HTC_SERVICE_CONNECT_REQ  *pConnectReq,
+                           HTC_SERVICE_CONNECT_RESP *pConnectResp)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    A_STATUS                            status = A_OK;
+    HTC_PACKET                          *pRecvPacket = NULL;
+    HTC_PACKET                          *pSendPacket = NULL;
+    HTC_CONNECT_SERVICE_RESPONSE_MSG    *pResponseMsg;
+    HTC_CONNECT_SERVICE_MSG             *pConnectMsg;
+    HTC_ENDPOINT_ID                     assignedEndpoint = ENDPOINT_MAX;
+    HTC_ENDPOINT                        *pEndpoint;
+    int                                 maxMsgSize = 0;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("+HTCConnectService, target:0x%X SvcID:0x%X \n",
+               (A_UINT32)target, pConnectReq->ServiceID));
+
+    do {
+
+        AR_DEBUG_ASSERT(pConnectReq->ServiceID != 0);
+
+        if (HTC_CTRL_RSVD_SVC == pConnectReq->ServiceID) {
+                /* special case for pseudo control service */
+            assignedEndpoint = ENDPOINT_0;
+            maxMsgSize = HTC_MAX_CONTROL_MESSAGE_LENGTH;
+        } else {
+                /* allocate a packet to send to the target */
+            pSendPacket = HTC_ALLOC_CONTROL_TX(target);
+
+            if (NULL == pSendPacket) {
+                AR_DEBUG_ASSERT(FALSE);
+                status = A_NO_MEMORY;
+                break;
+            }
+                /* assemble connect service message */
+            pConnectMsg = (HTC_CONNECT_SERVICE_MSG *)pSendPacket->pBuffer;
+            AR_DEBUG_ASSERT(pConnectMsg != NULL);
+            A_MEMZERO(pConnectMsg,sizeof(HTC_CONNECT_SERVICE_MSG));
+            pConnectMsg->MessageID = HTC_MSG_CONNECT_SERVICE_ID;
+            pConnectMsg->ServiceID = pConnectReq->ServiceID;
+            pConnectMsg->ConnectionFlags = pConnectReq->ConnectionFlags;
+                /* check caller if it wants to transfer meta data */
+            if ((pConnectReq->pMetaData != NULL) &&
+                (pConnectReq->MetaDataLength <= HTC_SERVICE_META_DATA_MAX_LENGTH)) {
+                    /* copy meta data into message buffer (after header ) */
+                A_MEMCPY((A_UINT8 *)pConnectMsg + sizeof(HTC_CONNECT_SERVICE_MSG),
+                         pConnectReq->pMetaData,
+                         pConnectReq->MetaDataLength);
+                pConnectMsg->ServiceMetaLength = pConnectReq->MetaDataLength;
+            }
+
+            SET_HTC_PACKET_INFO_TX(pSendPacket,
+                                   NULL,
+                                   (A_UINT8 *)pConnectMsg,
+                                   sizeof(HTC_CONNECT_SERVICE_MSG) + pConnectMsg->ServiceMetaLength,
+                                   ENDPOINT_0,
+                                   HTC_SERVICE_TX_PACKET_TAG);
+
+                /* we want synchronous operation */
+            pSendPacket->Completion = NULL;
+
+            status = HTCIssueSend(target,pSendPacket,0);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+
+                /* wait for response */
+            status = HTCWaitforControlMessage(target, &pRecvPacket);
+
+            if (A_FAILED(status)) {
+                break;
+            }
+                /* we controlled the buffer creation so it has to be properly aligned */
+            pResponseMsg = (HTC_CONNECT_SERVICE_RESPONSE_MSG *)pRecvPacket->pBuffer;
+
+            if ((pResponseMsg->MessageID != HTC_MSG_CONNECT_SERVICE_RESPONSE_ID) ||
+                (pRecvPacket->ActualLength < sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG))) {
+                    /* this message is not valid */
+                AR_DEBUG_ASSERT(FALSE);
+                status = A_EPROTO;
+                break;
+            }
+
+            pConnectResp->ConnectRespCode = pResponseMsg->Status;
+                /* check response status */
+            if (pResponseMsg->Status != HTC_SERVICE_SUCCESS) {
+                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,
+                    (" Target failed service 0x%X connect request (status:%d)\n",
+                                pResponseMsg->ServiceID, pResponseMsg->Status));
+                status = A_EPROTO;
+                break;
+            }
+
+            assignedEndpoint = pResponseMsg->EndpointID;
+            maxMsgSize = pResponseMsg->MaxMsgSize;
+
+            if ((pConnectResp->pMetaData != NULL) &&
+                (pResponseMsg->ServiceMetaLength > 0) &&
+                (pResponseMsg->ServiceMetaLength <= HTC_SERVICE_META_DATA_MAX_LENGTH)) {
+                    /* caller supplied a buffer and the target responded with data */
+                int copyLength = min((int)pConnectResp->BufferLength, (int)pResponseMsg->ServiceMetaLength);
+                    /* copy the meta data */
+                A_MEMCPY(pConnectResp->pMetaData,
+                         ((A_UINT8 *)pResponseMsg) + sizeof(HTC_CONNECT_SERVICE_RESPONSE_MSG),
+                         copyLength);
+                pConnectResp->ActualLength = copyLength;
+            }
+
+        }
+
+            /* the rest of these are parameter checks so set the error status */
+        status = A_EPROTO;
+
+        if (assignedEndpoint >= ENDPOINT_MAX) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+        if (0 == maxMsgSize) {
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+        pEndpoint = &target->EndPoint[assignedEndpoint];
+
+        if (pEndpoint->ServiceID != 0) {
+            /* endpoint already in use! */
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+
+            /* return assigned endpoint to caller */
+        pConnectResp->Endpoint = assignedEndpoint;
+        pConnectResp->MaxMsgLength = maxMsgSize;
+
+            /* setup the endpoint */
+        pEndpoint->ServiceID = pConnectReq->ServiceID; /* this marks the endpoint in use */
+        pEndpoint->MaxTxQueueDepth = pConnectReq->MaxSendQueueDepth;
+        pEndpoint->MaxMsgLength = maxMsgSize;
+            /* copy all the callbacks */
+        pEndpoint->EpCallBacks = pConnectReq->EpCallbacks;
+        INIT_HTC_PACKET_QUEUE(&pEndpoint->RxBuffers);
+        INIT_HTC_PACKET_QUEUE(&pEndpoint->TxQueue);
+            /* set the credit distribution info for this endpoint, this information is
+             * passed back to the credit distribution callback function */
+        pEndpoint->CreditDist.ServiceID = pConnectReq->ServiceID;
+        pEndpoint->CreditDist.pHTCReserved = pEndpoint;
+        pEndpoint->CreditDist.Endpoint = assignedEndpoint;
+        pEndpoint->CreditDist.TxCreditSize = target->TargetCreditSize;
+        pEndpoint->CreditDist.TxCreditsPerMaxMsg = maxMsgSize / target->TargetCreditSize;
+
+        if (0 == pEndpoint->CreditDist.TxCreditsPerMaxMsg) {
+            pEndpoint->CreditDist.TxCreditsPerMaxMsg = 1;
+        }
+
+        status = A_OK;
+
+    } while (FALSE);
+
+    if (pSendPacket != NULL) {
+        HTC_FREE_CONTROL_TX(target,pSendPacket);
+    }
+
+    if (pRecvPacket != NULL) {
+        HTC_FREE_CONTROL_RX(target,pRecvPacket);
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_TRC, ("-HTCConnectService \n"));
+
+    return status;
+}
+
+static void AddToEndpointDistList(HTC_TARGET *target, HTC_ENDPOINT_CREDIT_DIST *pEpDist)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEntry,*pLastEntry;
+
+    if (NULL == target->EpCreditDistributionListHead) {
+        target->EpCreditDistributionListHead = pEpDist;
+        pEpDist->pNext = NULL;
+        pEpDist->pPrev = NULL;
+        return;
+    }
+
+        /* queue to the end of the list, this does not have to be very
+         * fast since this list is built at startup time */
+    pCurEntry = target->EpCreditDistributionListHead;
+
+    while (pCurEntry) {
+        pLastEntry = pCurEntry;
+        pCurEntry = pCurEntry->pNext;
+    }
+
+    pLastEntry->pNext = pEpDist;
+    pEpDist->pPrev = pLastEntry;
+    pEpDist->pNext = NULL;
+}
+
+
+
+/* default credit init callback */
+static void HTCDefaultCreditInit(void                     *Context,
+                                 HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                                 int                      TotalCredits)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    int                      totalEps = 0;
+    int                      creditsPerEndpoint;
+
+    pCurEpDist = pEPList;
+        /* first run through the list and figure out how many endpoints we are dealing with */
+    while (pCurEpDist != NULL) {
+        pCurEpDist = pCurEpDist->pNext;
+        totalEps++;
+    }
+
+        /* even distribution */
+    creditsPerEndpoint = TotalCredits/totalEps;
+
+    pCurEpDist = pEPList;
+        /* run through the list and set minimum and normal credits and
+         * provide the endpoint with some credits to start */
+    while (pCurEpDist != NULL) {
+
+        if (creditsPerEndpoint < pCurEpDist->TxCreditsPerMaxMsg) {
+                /* too many endpoints and not enough credits */
+            AR_DEBUG_ASSERT(FALSE);
+            break;
+        }
+            /* our minimum is set for at least 1 max message */
+        pCurEpDist->TxCreditsMin = pCurEpDist->TxCreditsPerMaxMsg;
+            /* this value is ignored by our credit alg, since we do
+             * not dynamically adjust credits, this is the policy of
+             * the "default" credit distribution, something simple and easy */
+        pCurEpDist->TxCreditsNorm = 0xFFFF;
+            /* give the endpoint minimum credits */
+        pCurEpDist->TxCredits = creditsPerEndpoint;
+        pCurEpDist->TxCreditsAssigned = creditsPerEndpoint;
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+}
+
+/* default credit distribution callback, NOTE, this callback holds the TX lock */
+void HTCDefaultCreditDist(void                     *Context,
+                          HTC_ENDPOINT_CREDIT_DIST *pEPDistList,
+                          HTC_CREDIT_DIST_REASON   Reason)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+
+    if (Reason == HTC_CREDIT_DIST_SEND_COMPLETE) {
+        pCurEpDist = pEPDistList;
+            /* simple distribution */
+        while (pCurEpDist != NULL) {
+            if (pCurEpDist->TxCreditsToDist > 0) {
+                    /* just give the endpoint back the credits */
+                pCurEpDist->TxCredits += pCurEpDist->TxCreditsToDist;
+                pCurEpDist->TxCreditsToDist = 0;
+            }
+            pCurEpDist = pCurEpDist->pNext;
+        }
+    }
+
+    /* note we do not need to handle the other reason codes as this is a very
+     * simple distribution scheme, no need to seek for more credits or handle inactivity */
+}
+
+void HTCSetCreditDistribution(HTC_HANDLE               HTCHandle,
+                              void                     *pCreditDistContext,
+                              HTC_CREDIT_DIST_CALLBACK CreditDistFunc,
+                              HTC_CREDIT_INIT_CALLBACK CreditInitFunc,
+                              HTC_SERVICE_ID           ServicePriorityOrder[],
+                              int                      ListLength)
+{
+    HTC_TARGET *target = GET_HTC_TARGET_FROM_HANDLE(HTCHandle);
+    int i;
+    int ep;
+
+    if (CreditInitFunc != NULL) {
+            /* caller has supplied their own distribution functions */
+        target->InitCredits = CreditInitFunc;
+        AR_DEBUG_ASSERT(CreditDistFunc != NULL);
+        target->DistributeCredits = CreditDistFunc;
+        target->pCredDistContext = pCreditDistContext;
+    } else {
+        /* caller wants HTC to do distribution */
+        /* if caller wants service to handle distributions then
+         * it must set both of these to NULL! */
+        AR_DEBUG_ASSERT(CreditDistFunc == NULL);
+        target->InitCredits = HTCDefaultCreditInit;
+        target->DistributeCredits = HTCDefaultCreditDist;
+        target->pCredDistContext = target;
+    }
+
+        /* always add HTC control endpoint first, we only expose the list after the
+         * first one, this is added for TX queue checking */
+    AddToEndpointDistList(target, &target->EndPoint[ENDPOINT_0].CreditDist);
+
+        /* build the list of credit distribution structures in priority order
+         * supplied by the caller, these will follow endpoint 0 */
+    for (i = 0; i < ListLength; i++) {
+            /* match services with endpoints and add the endpoints to the distribution list
+             * in FIFO order */
+        for (ep = ENDPOINT_1; ep < ENDPOINT_MAX; ep++) {
+            if (target->EndPoint[ep].ServiceID == ServicePriorityOrder[i]) {
+                    /* queue this one to the list */
+                AddToEndpointDistList(target, &target->EndPoint[ep].CreditDist);
+                break;
+            }
+        }
+        AR_DEBUG_ASSERT(ep < ENDPOINT_MAX);
+    }
+
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_config.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_config.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_config.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_config.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,27 @@
+#ifndef _A_CONFIG_H_
+#define _A_CONFIG_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/*
+ * This file contains software configuration options that enables
+ * specific software "features"
+ */
+#include "../ar6000/config_linux.h"
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_debug.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_debug.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_debug.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,41 @@
+#ifndef _A_DEBUG_H_
+#define _A_DEBUG_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include <a_types.h>
+#include <a_osapi.h>
+
+#define DBG_INFO		0x00000001
+#define DBG_ERROR		0x00000002
+#define DBG_WARNING		0x00000004
+#define DBG_SDIO		0x00000008
+#define DBG_HIF			0x00000010
+#define DBG_HTC			0x00000020
+#define DBG_WMI			0x00000040
+#define DBG_WMI2		0x00000080
+#define DBG_DRIVER		0x00000100
+
+#define DBG_DEFAULTS	(DBG_ERROR|DBG_WARNING)
+
+#include "../ar6000/debug_linux.h"
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_drv_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_drv_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_drv_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_drv_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,185 @@
+#ifndef _A_DRV_API_H_
+#define _A_DRV_API_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/****************************************************************************/
+/****************************************************************************/
+/**                                                                        **/
+/** WMI related hooks                                                      **/
+/**                                                                        **/
+/****************************************************************************/
+/****************************************************************************/
+
+#include <ar6000_api.h>
+
+#define A_WMI_CHANNELLIST_RX(devt, numChan, chanList)	\
+	ar6000_channelList_rx((devt), (numChan), (chanList))
+
+#define A_WMI_SET_NUMDATAENDPTS(devt, num)	\
+	ar6000_set_numdataendpts((devt), (num))
+
+#define A_WMI_CONTROL_TX(devt, osbuf, streamID)	\
+	ar6000_control_tx((devt), (osbuf), (streamID))
+
+#define A_WMI_TARGETSTATS_EVENT(devt, pStats)	\
+	ar6000_targetStats_event((devt), (pStats))
+
+#define A_WMI_SCANCOMPLETE_EVENT(devt, status)	\
+	ar6000_scanComplete_event((devt), (status))
+
+#ifdef CONFIG_HOST_DSET_SUPPORT
+
+#define A_WMI_DSET_DATA_REQ(devt, access_cookie, offset, length, targ_buf, targ_reply_fn, targ_reply_arg)	\
+	ar6000_dset_data_req((devt), (access_cookie), (offset), (length), (targ_buf), (targ_reply_fn), (targ_reply_arg))
+
+#define A_WMI_DSET_CLOSE(devt, access_cookie)	\
+	ar6000_dset_close((devt), (access_cookie))
+
+#endif
+
+#define A_WMI_DSET_OPEN_REQ(devt, id, targ_handle, targ_reply_fn, targ_reply_arg) \
+	ar6000_dset_open_req((devt), (id), (targ_handle), (targ_reply_fn), (targ_reply_arg))
+
+#define A_WMI_CONNECT_EVENT(devt, channel, bssid, listenInterval, beaconInterval, networkType, beaconIeLen, assocReqLen, assocRespLen, assocInfo) \
+	ar6000_connect_event((devt), (channel), (bssid), (listenInterval), (beaconInterval), (networkType), (beaconIeLen), (assocReqLen), (assocRespLen), (assocInfo))
+
+#define A_WMI_REGDOMAIN_EVENT(devt, regCode)	\
+	ar6000_regDomain_event((devt), (regCode))
+
+#define A_WMI_NEIGHBORREPORT_EVENT(devt, numAps, info)	\
+	ar6000_neighborReport_event((devt), (numAps), (info))
+
+#define A_WMI_DISCONNECT_EVENT(devt, reason, bssid, assocRespLen, assocInfo, protocolReasonStatus)	\
+	ar6000_disconnect_event((devt), (reason), (bssid), (assocRespLen), (assocInfo), (protocolReasonStatus))
+
+#define A_WMI_TKIP_MICERR_EVENT(devt, keyid, ismcast)	\
+	ar6000_tkip_micerr_event((devt), (keyid), (ismcast))
+
+#define A_WMI_BITRATE_RX(devt, rateKbps)	\
+	ar6000_bitrate_rx((devt), (rateKbps))
+
+#define A_WMI_TXPWR_RX(devt, txPwr)	\
+	ar6000_txPwr_rx((devt), (txPwr))
+
+#define A_WMI_READY_EVENT(devt, datap, phyCap)	\
+	ar6000_ready_event((devt), (datap), (phyCap))
+
+#define A_WMI_DBGLOG_INIT_DONE(ar) \
+        ar6000_dbglog_init_done(ar);
+
+#define A_WMI_RSSI_THRESHOLD_EVENT(devt, newThreshold, rssi)	\
+	ar6000_rssiThreshold_event((devt), (newThreshold), (rssi))
+
+#define A_WMI_REPORT_ERROR_EVENT(devt, errorVal)	\
+	ar6000_reportError_event((devt), (errorVal))
+
+#define A_WMI_ROAM_TABLE_EVENT(devt, pTbl) \
+	ar6000_roam_tbl_event((devt), (pTbl))
+
+#define A_WMI_ROAM_DATA_EVENT(devt, p) \
+	ar6000_roam_data_event((devt), (p))
+
+#define A_WMI_WOW_LIST_EVENT(devt, num_filters, wow_filters)	\
+	ar6000_wow_list_event((devt), (num_filters), (wow_filters))
+
+#define A_WMI_CAC_EVENT(devt, ac, cac_indication, statusCode, tspecSuggestion)  \
+	ar6000_cac_event((devt), (ac), (cac_indication), (statusCode), (tspecSuggestion))
+
+#define A_WMI_IPTOS_TO_USERPRIORITY(pkt)    \
+	ar6000_iptos_to_userPriority((pkt))
+
+#define A_WMI_PMKID_LIST_EVENT(devt, num_pmkid, pmkid_list)	\
+	ar6000_pmkid_list_event((devt), (num_pmkid), (pmkid_list))
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+
+#define A_WMI_GPIO_INTR_RX(intr_mask, input_values) \
+	ar6000_gpio_intr_rx((intr_mask), (input_values))
+
+#define A_WMI_GPIO_DATA_RX(reg_id, value) \
+	ar6000_gpio_data_rx((reg_id), (value))
+
+#define A_WMI_GPIO_ACK_RX() \
+	ar6000_gpio_ack_rx()
+
+#endif
+
+#ifdef SEND_EVENT_TO_APP
+
+#define A_WMI_SEND_EVENT_TO_APP(ar, eventId, datap, len) \
+	ar6000_send_event_to_app((ar), (eventId), (datap), (len))
+
+#else
+
+#define A_WMI_SEND_EVENT_TO_APP(ar, eventId, datap, len)
+
+#endif
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+#define A_WMI_TCMD_RX_REPORT_EVENT(devt, results, len) \
+	ar6000_tcmd_rx_report_event((devt), (results), (len))
+#endif
+
+#define A_WMI_HBCHALLENGERESP_EVENT(devt, cookie, source)    \
+    ar6000_hbChallengeResp_event((devt), (cookie), (source))
+
+#define A_WMI_TX_RETRY_ERR_EVENT(devt) \
+	ar6000_tx_retry_err_event((devt))
+
+#define A_WMI_SNR_THRESHOLD_EVENT_RX(devt, newThreshold, snr) \
+	ar6000_snrThresholdEvent_rx((devt), (newThreshold), (snr))
+
+#define A_WMI_LQ_THRESHOLD_EVENT_RX(devt, range, lqVal) \
+	ar6000_lqThresholdEvent_rx((devt), (range), (lqVal))
+
+#define A_WMI_RATEMASK_RX(devt, ratemask) \
+	ar6000_ratemask_rx((devt), (ratemask))
+
+#define A_WMI_KEEPALIVE_RX(devt, configured)    \
+        ar6000_keepalive_rx((devt), (configured))
+
+#define A_WMI_BSSINFO_EVENT_RX(ar, datp, len)   \
+        ar6000_bssInfo_event_rx((ar), (datap), (len))
+
+#define A_WMI_DBGLOG_EVENT(ar, dropped, buffer, length) \
+        ar6000_dbglog_event((ar), (dropped), (buffer), (length));
+
+#define A_WMI_STREAM_TX_ACTIVE(devt,trafficClass) \
+    ar6000_indicate_tx_activity((devt),(trafficClass), TRUE)
+
+#define A_WMI_STREAM_TX_INACTIVE(devt,trafficClass) \
+    ar6000_indicate_tx_activity((devt),(trafficClass), FALSE)
+
+/****************************************************************************/
+/****************************************************************************/
+/**                                                                        **/
+/** HTC related hooks                                                      **/
+/**                                                                        **/
+/****************************************************************************/
+/****************************************************************************/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_drv.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_drv.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_drv.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef _A_DRV_H_
+#define _A_DRV_H_
+/*
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/a_drv.h#1 $
+ *
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../ar6000/athdrv_linux.h"
+
+#endif /* _ADRV_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_osapi.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_osapi.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_osapi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_osapi.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef _A_OSAPI_H_
+#define _A_OSAPI_H_
+/*
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/a_osapi.h#1 $
+ *
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../ar6000/osapi_linux.h"
+
+#endif /* _OSAPI_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/ar6000_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ar6000_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/ar6000_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ar6000_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,29 @@
+#ifndef _AR6000_API_H_
+#define _AR6000_API_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains the API to access the OS dependent atheros host driver
+ * by the WMI or WLAN generic modules.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/ar6000_api.h#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../ar6000/ar6xapi_linux.h"
+
+#endif /* _AR6000_API_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/ar6000_diag.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ar6000_diag.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/ar6000_diag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ar6000_diag.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef AR6000_DIAG_H_
+#define AR6000_DIAG_H_
+
+
+A_STATUS
+ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+A_STATUS
+ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+
+A_STATUS
+ar6000_ReadDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                    A_UCHAR *data, A_UINT32 length);
+
+A_STATUS
+ar6000_WriteDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                     A_UCHAR *data, A_UINT32 length);
+
+#endif /*AR6000_DIAG_H_*/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6001_regdump.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6001_regdump.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6001_regdump.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6001_regdump.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __AR6000_REGDUMP_H__
+#define __AR6000_REGDUMP_H__
+
+#if !defined(__ASSEMBLER__)
+/*
+ * Target CPU state at the time of failure is reflected
+ * in a register dump, which the Host can fetch through
+ * the diagnostic window.
+ */
+
+struct MIPS_exception_frame_s {
+    A_UINT32 pc;        /* Program Counter */
+    A_UINT32 at;        /* MIPS General Purpose registers */
+    A_UINT32 v0;
+    A_UINT32 v1;
+    A_UINT32 a0;
+    A_UINT32 a1;
+    A_UINT32 a2;
+    A_UINT32 a3;
+    A_UINT32 t0;
+    A_UINT32 t1;
+    A_UINT32 t2;
+    A_UINT32 t3;
+    A_UINT32 t4;
+    A_UINT32 t5;
+    A_UINT32 t6;
+    A_UINT32 t7;
+    A_UINT32 s0;
+    A_UINT32 s1;
+    A_UINT32 s2;
+    A_UINT32 s3;
+    A_UINT32 s4;
+    A_UINT32 s5;
+    A_UINT32 s6;
+    A_UINT32 s7;
+    A_UINT32 t8;
+    A_UINT32 t9;
+    A_UINT32 k0;
+    A_UINT32 k1;
+    A_UINT32 gp;
+    A_UINT32 sp;
+    A_UINT32 s8;
+    A_UINT32 ra;
+    A_UINT32 cause; /* Selected coprocessor regs */
+    A_UINT32 status;
+};
+typedef struct MIPS_exception_frame_s CPU_exception_frame_t;
+
+#endif
+
+/*
+ * Offsets into MIPS_exception_frame structure, for use in assembler code
+ * MUST MATCH C STRUCTURE ABOVE
+ */
+#define RD_pc           0
+#define RD_at           1
+#define RD_v0           2
+#define RD_v1           3
+#define RD_a0           4
+#define RD_a1           5
+#define RD_a2           6
+#define RD_a3           7
+#define RD_t0           8
+#define RD_t1           9
+#define RD_t2           10
+#define RD_t3           11
+#define RD_t4           12
+#define RD_t5           13
+#define RD_t6           14
+#define RD_t7           15
+#define RD_s0           16
+#define RD_s1           17
+#define RD_s2           18
+#define RD_s3           19
+#define RD_s4           20
+#define RD_s5           21
+#define RD_s6           22
+#define RD_s7           23
+#define RD_t8           24
+#define RD_t9           25
+#define RD_k0           26
+#define RD_k1           27
+#define RD_gp           28
+#define RD_sp           29
+#define RD_s8           30
+#define RD_ra           31
+#define RD_cause        32
+#define RD_status       33
+
+#define RD_SIZE         (34*4) /* Space for this number of words */
+
+#endif /* __AR6000_REGDUMP_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6Khwreg.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6Khwreg.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6Khwreg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6Khwreg.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains the definitions for AR6001 registers
+ * that may be directly manipulated by Host software.
+ */
+
+#ifndef __AR6KHWREG_H__
+#define __AR6KHWREG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Host registers */
+#define HOST_INT_STATUS_ADDRESS                  0x00000400
+#define CPU_INT_STATUS_ADDRESS                   0x00000401
+#define ERROR_INT_STATUS_ADDRESS                 0x00000402
+#define INT_STATUS_ENABLE_ADDRESS                0x00000418
+#define CPU_INT_STATUS_ENABLE_ADDRESS            0x00000419
+#define COUNT_ADDRESS                            0x00000420
+#define COUNT_DEC_ADDRESS                        0x00000440
+#define WINDOW_DATA_ADDRESS                      0x00000474
+#define WINDOW_WRITE_ADDR_ADDRESS                0x00000478
+#define WINDOW_READ_ADDR_ADDRESS                 0x0000047c
+
+/* Target addresses */
+#define RESET_CONTROL_ADDRESS                    0x0c000000
+#define MC_REMAP_VALID_ADDRESS                   0x0c004080
+#define MC_REMAP_SIZE_ADDRESS                    0x0c004100
+#define MC_REMAP_COMPARE_ADDRESS                 0x0c004180
+#define MC_REMAP_TARGET_ADDRESS                  0x0c004200
+#define LOCAL_COUNT_ADDRESS                      0x0c014080
+#define LOCAL_SCRATCH_ADDRESS                    0x0c0140c0
+
+
+#define INT_STATUS_ENABLE_ERROR_MSB              7
+#define INT_STATUS_ENABLE_ERROR_LSB              7
+#define INT_STATUS_ENABLE_ERROR_MASK             0x00000080
+#define INT_STATUS_ENABLE_ERROR_GET(x)           (((x) & INT_STATUS_ENABLE_ERROR_MASK) >> INT_STATUS_ENABLE_ERROR_LSB)
+#define INT_STATUS_ENABLE_ERROR_SET(x)           (((x) << INT_STATUS_ENABLE_ERROR_LSB) & INT_STATUS_ENABLE_ERROR_MASK)
+
+#define INT_STATUS_ENABLE_CPU_MSB                6
+#define INT_STATUS_ENABLE_CPU_LSB                6
+#define INT_STATUS_ENABLE_CPU_MASK               0x00000040
+#define INT_STATUS_ENABLE_CPU_GET(x)             (((x) & INT_STATUS_ENABLE_CPU_MASK) >> INT_STATUS_ENABLE_CPU_LSB)
+#define INT_STATUS_ENABLE_CPU_SET(x)             (((x) << INT_STATUS_ENABLE_CPU_LSB) & INT_STATUS_ENABLE_CPU_MASK)
+
+#define INT_STATUS_ENABLE_COUNTER_MSB            4
+#define INT_STATUS_ENABLE_COUNTER_LSB            4
+#define INT_STATUS_ENABLE_COUNTER_MASK           0x00000010
+#define INT_STATUS_ENABLE_COUNTER_GET(x)         (((x) & INT_STATUS_ENABLE_COUNTER_MASK) >> INT_STATUS_ENABLE_COUNTER_LSB)
+#define INT_STATUS_ENABLE_COUNTER_SET(x)         (((x) << INT_STATUS_ENABLE_COUNTER_LSB) & INT_STATUS_ENABLE_COUNTER_MASK)
+
+#define INT_STATUS_ENABLE_MBOX_DATA_MSB          3
+#define INT_STATUS_ENABLE_MBOX_DATA_LSB          0
+#define INT_STATUS_ENABLE_MBOX_DATA_MASK         0x0000000f
+#define INT_STATUS_ENABLE_MBOX_DATA_GET(x)       (((x) & INT_STATUS_ENABLE_MBOX_DATA_MASK) >> INT_STATUS_ENABLE_MBOX_DATA_LSB)
+#define INT_STATUS_ENABLE_MBOX_DATA_SET(x)       (((x) << INT_STATUS_ENABLE_MBOX_DATA_LSB) & INT_STATUS_ENABLE_MBOX_DATA_MASK)
+
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_MSB     1
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB     1
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK    0x00000002
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_GET(x)  (((x) & ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK) >> ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB)
+#define ERROR_STATUS_ENABLE_RX_UNDERFLOW_SET(x)  (((x) << ERROR_STATUS_ENABLE_RX_UNDERFLOW_LSB) & ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK)
+
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_MSB      0
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_LSB      0
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK     0x00000001
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_GET(x)   (((x) & ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK) >> ERROR_STATUS_ENABLE_TX_OVERFLOW_LSB)
+#define ERROR_STATUS_ENABLE_TX_OVERFLOW_SET(x)   (((x) << ERROR_STATUS_ENABLE_TX_OVERFLOW_LSB) & ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK)
+
+
+#define CPU_INT_STATUS_ENABLE_BIT_MSB            7
+#define CPU_INT_STATUS_ENABLE_BIT_LSB            0
+#define CPU_INT_STATUS_ENABLE_BIT_MASK           0x000000ff
+#define CPU_INT_STATUS_ENABLE_BIT_GET(x)         (((x) & CPU_INT_STATUS_ENABLE_BIT_MASK) >> CPU_INT_STATUS_ENABLE_BIT_LSB)
+#define CPU_INT_STATUS_ENABLE_BIT_SET(x)         (((x) << CPU_INT_STATUS_ENABLE_BIT_LSB) & CPU_INT_STATUS_ENABLE_BIT_MASK)
+
+#define COUNTER_INT_STATUS_ENABLE_BIT_MSB        7
+#define COUNTER_INT_STATUS_ENABLE_BIT_LSB        0
+#define COUNTER_INT_STATUS_ENABLE_BIT_MASK       0x000000ff
+#define COUNTER_INT_STATUS_ENABLE_BIT_GET(x)     (((x) & COUNTER_INT_STATUS_ENABLE_BIT_MASK) >> COUNTER_INT_STATUS_ENABLE_BIT_LSB)
+#define COUNTER_INT_STATUS_ENABLE_BIT_SET(x)     (((x) << COUNTER_INT_STATUS_ENABLE_BIT_LSB) & COUNTER_INT_STATUS_ENABLE_BIT_MASK)
+
+#define ERROR_INT_STATUS_WAKEUP_MSB              2
+#define ERROR_INT_STATUS_WAKEUP_LSB              2
+#define ERROR_INT_STATUS_WAKEUP_MASK             0x00000004
+#define ERROR_INT_STATUS_WAKEUP_GET(x)           (((x) & ERROR_INT_STATUS_WAKEUP_MASK) >> ERROR_INT_STATUS_WAKEUP_LSB)
+#define ERROR_INT_STATUS_WAKEUP_SET(x)           (((x) << ERROR_INT_STATUS_WAKEUP_LSB) & ERROR_INT_STATUS_WAKEUP_MASK)
+
+#define ERROR_INT_STATUS_RX_UNDERFLOW_MSB        1
+#define ERROR_INT_STATUS_RX_UNDERFLOW_LSB        1
+#define ERROR_INT_STATUS_RX_UNDERFLOW_MASK       0x00000002
+#define ERROR_INT_STATUS_RX_UNDERFLOW_GET(x)     (((x) & ERROR_INT_STATUS_RX_UNDERFLOW_MASK) >> ERROR_INT_STATUS_RX_UNDERFLOW_LSB)
+#define ERROR_INT_STATUS_RX_UNDERFLOW_SET(x)     (((x) << ERROR_INT_STATUS_RX_UNDERFLOW_LSB) & ERROR_INT_STATUS_RX_UNDERFLOW_MASK)
+
+#define ERROR_INT_STATUS_TX_OVERFLOW_MSB         0
+#define ERROR_INT_STATUS_TX_OVERFLOW_LSB         0
+#define ERROR_INT_STATUS_TX_OVERFLOW_MASK        0x00000001
+#define ERROR_INT_STATUS_TX_OVERFLOW_GET(x)      (((x) & ERROR_INT_STATUS_TX_OVERFLOW_MASK) >> ERROR_INT_STATUS_TX_OVERFLOW_LSB)
+#define ERROR_INT_STATUS_TX_OVERFLOW_SET(x)      (((x) << ERROR_INT_STATUS_TX_OVERFLOW_LSB) & ERROR_INT_STATUS_TX_OVERFLOW_MASK)
+
+#define HOST_INT_STATUS_ERROR_MSB                7
+#define HOST_INT_STATUS_ERROR_LSB                7
+#define HOST_INT_STATUS_ERROR_MASK               0x00000080
+#define HOST_INT_STATUS_ERROR_GET(x)             (((x) & HOST_INT_STATUS_ERROR_MASK) >> HOST_INT_STATUS_ERROR_LSB)
+#define HOST_INT_STATUS_ERROR_SET(x)             (((x) << HOST_INT_STATUS_ERROR_LSB) & HOST_INT_STATUS_ERROR_MASK)
+
+#define HOST_INT_STATUS_CPU_MSB                  6
+#define HOST_INT_STATUS_CPU_LSB                  6
+#define HOST_INT_STATUS_CPU_MASK                 0x00000040
+#define HOST_INT_STATUS_CPU_GET(x)               (((x) & HOST_INT_STATUS_CPU_MASK) >> HOST_INT_STATUS_CPU_LSB)
+#define HOST_INT_STATUS_CPU_SET(x)               (((x) << HOST_INT_STATUS_CPU_LSB) & HOST_INT_STATUS_CPU_MASK)
+
+#define HOST_INT_STATUS_COUNTER_MSB              4
+#define HOST_INT_STATUS_COUNTER_LSB              4
+#define HOST_INT_STATUS_COUNTER_MASK             0x00000010
+#define HOST_INT_STATUS_COUNTER_GET(x)           (((x) & HOST_INT_STATUS_COUNTER_MASK) >> HOST_INT_STATUS_COUNTER_LSB)
+#define HOST_INT_STATUS_COUNTER_SET(x)           (((x) << HOST_INT_STATUS_COUNTER_LSB) & HOST_INT_STATUS_COUNTER_MASK)
+
+#define RESET_CONTROL_WARM_RST_MSB               7
+#define RESET_CONTROL_WARM_RST_LSB               7
+#define RESET_CONTROL_WARM_RST_MASK              0x00000080
+#define RESET_CONTROL_WARM_RST_GET(x)            (((x) & RESET_CONTROL_WARM_RST_MASK) >> RESET_CONTROL_WARM_RST_LSB)
+#define RESET_CONTROL_WARM_RST_SET(x)            (((x) << RESET_CONTROL_WARM_RST_LSB) & RESET_CONTROL_WARM_RST_MASK)
+
+#define RESET_CONTROL_COLD_RST_MSB               8
+#define RESET_CONTROL_COLD_RST_LSB               8
+#define RESET_CONTROL_COLD_RST_MASK              0x00000100
+#define RESET_CONTROL_COLD_RST_GET(x)            (((x) & RESET_CONTROL_COLD_RST_MASK) >> RESET_CONTROL_COLD_RST_LSB)
+#define RESET_CONTROL_COLD_RST_SET(x)            (((x) << RESET_CONTROL_COLD_RST_LSB) & RESET_CONTROL_COLD_RST_MASK)
+
+#define RESET_CAUSE_LAST_MSB                     2
+#define RESET_CAUSE_LAST_LSB                     0
+#define RESET_CAUSE_LAST_MASK                    0x00000007
+#define RESET_CAUSE_LAST_GET(x)                  (((x) & RESET_CAUSE_LAST_MASK) >> RESET_CAUSE_LAST_LSB)
+#define RESET_CAUSE_LAST_SET(x)                  (((x) << RESET_CAUSE_LAST_LSB) & RESET_CAUSE_LAST_MASK)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __AR6KHWREG_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6K_version.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6K_version.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6K_version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6K_version.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,36 @@
+#define __VER_MAJOR_ 2
+#define __VER_MINOR_ 0
+#define __VER_PATCH_ 0
+
+
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * The makear6ksdk script (used for release builds) modifies the following line.
+ */
+#define __BUILD_NUMBER_ 18
+
+
+/* Format of the version number. */
+#define VER_MAJOR_BIT_OFFSET		28
+#define VER_MINOR_BIT_OFFSET		24
+#define VER_PATCH_BIT_OFFSET		16
+#define VER_BUILD_NUM_BIT_OFFSET	0
+
+
+/*
+ * The version has the following format:
+ * Bits 28-31: Major version
+ * Bits 24-27: Minor version
+ * Bits 16-23: Patch version
+ * Bits 0-15:  Build number (automatically generated during build process )
+ * E.g. Build 1.1.3.7 would be represented as 0x11030007.
+ *
+ * DO NOT split the following macro into multiple lines as this may confuse the build scripts.
+ */
+#define AR6K_SW_VERSION 	( ( __VER_MAJOR_ << VER_MAJOR_BIT_OFFSET ) + ( __VER_MINOR_ << VER_MINOR_BIT_OFFSET ) + ( __VER_PATCH_ << VER_PATCH_BIT_OFFSET ) + ( __BUILD_NUMBER_ << VER_BUILD_NUM_BIT_OFFSET ) )
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6K_version.h.NEW linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6K_version.h.NEW
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/AR6K_version.h.NEW	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/AR6K_version.h.NEW	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,36 @@
+#define __VER_MAJOR_ 2
+#define __VER_MINOR_ 0
+#define __VER_PATCH_ 0
+
+
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * The makear6ksdk script (used for release builds) modifies the following line.
+ */
+#define __BUILD_NUMBER_ 18
+
+
+/* Format of the version number. */
+#define VER_MAJOR_BIT_OFFSET		28
+#define VER_MINOR_BIT_OFFSET		24
+#define VER_PATCH_BIT_OFFSET		16
+#define VER_BUILD_NUM_BIT_OFFSET	0
+
+
+/*
+ * The version has the following format:
+ * Bits 28-31: Major version
+ * Bits 24-27: Minor version
+ * Bits 16-23: Patch version
+ * Bits 0-15:  Build number (automatically generated during build process )
+ * E.g. Build 1.1.3.7 would be represented as 0x11030007.
+ *
+ * DO NOT split the following macro into multiple lines as this may confuse the build scripts.
+ */
+#define AR6K_SW_VERSION 	( ( __VER_MAJOR_ << VER_MAJOR_BIT_OFFSET ) + ( __VER_MINOR_ << VER_MINOR_BIT_OFFSET ) + ( __VER_PATCH_ << VER_PATCH_BIT_OFFSET ) + ( __BUILD_NUMBER_ << VER_BUILD_NUM_BIT_OFFSET ) )
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/athdefs.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athdefs.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/athdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athdefs.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,85 @@
+#ifndef __ATHDEFS_H__
+#define __ATHDEFS_H__
+
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains definitions that may be used across both
+ * Host and Target software.  Nothing here is module-dependent
+ * or platform-dependent.
+ */
+
+/*
+ * Generic error codes that can be used by hw, sta, ap, sim, dk
+ * and any other environments. Since these are enums, feel free to
+ * add any more codes that you need.
+ */
+
+typedef enum {
+    A_ERROR = -1,               /* Generic error return */
+    A_OK = 0,                   /* success */
+                                /* Following values start at 1 */
+    A_DEVICE_NOT_FOUND,         /* not able to find PCI device */
+    A_NO_MEMORY,                /* not able to allocate memory, not available */
+    A_MEMORY_NOT_AVAIL,         /* memory region is not free for mapping */
+    A_NO_FREE_DESC,             /* no free descriptors available */
+    A_BAD_ADDRESS,              /* address does not match descriptor */
+    A_WIN_DRIVER_ERROR,         /* used in NT_HW version, if problem at init */
+    A_REGS_NOT_MAPPED,          /* registers not correctly mapped */
+    A_EPERM,                    /* Not superuser */
+    A_EACCES,                   /* Access denied */
+    A_ENOENT,                   /* No such entry, search failed, etc. */
+    A_EEXIST,                   /* The object already exists (can't create) */
+    A_EFAULT,                   /* Bad address fault */
+    A_EBUSY,                    /* Object is busy */
+    A_EINVAL,                   /* Invalid parameter */
+    A_EMSGSIZE,                 /* Inappropriate message buffer length */
+    A_ECANCELED,                /* Operation canceled */
+    A_ENOTSUP,                  /* Operation not supported */
+    A_ECOMM,                    /* Communication error on send */
+    A_EPROTO,                   /* Protocol error */
+    A_ENODEV,                   /* No such device */
+    A_EDEVNOTUP,                /* device is not UP */
+    A_NO_RESOURCE,              /* No resources for requested operation */
+    A_HARDWARE,                 /* Hardware failure */
+    A_PENDING,                  /* Asynchronous routine; will send up results la
+ter (typically in callback) */
+    A_EBADCHANNEL,              /* The channel cannot be used */
+    A_DECRYPT_ERROR,            /* Decryption error */
+    A_PHY_ERROR,                /* RX PHY error */
+    A_CONSUMED                  /* Object was consumed */
+} A_STATUS;
+
+#define A_SUCCESS(x)        (x == A_OK)
+#define A_FAILED(x)         (!A_SUCCESS(x))
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+/*
+ * The following definition is WLAN specific definition
+ */
+typedef enum {
+    MODE_11A = 0,   /* 11a Mode */
+    MODE_11G = 1,   /* 11g + 11b Mode */
+    MODE_11B = 2,   /* 11b Mode */
+    MODE_11GONLY = 3, /* 11g only Mode */
+    MODE_UNKNOWN = 4,
+    MODE_MAX = 4
+} WLAN_PHY_MODE;
+
+typedef enum {
+    WLAN_11A_CAPABILITY   = 1,
+    WLAN_11G_CAPABILITY   = 2,
+    WLAN_11AG_CAPABILITY  = 3,
+}WLAN_CAPABILITY;
+
+#endif /* __ATHDEFS_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/athdrv.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athdrv.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/athdrv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athdrv.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _ATHDRV_H_
+#define _ATHDRV_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ATHDRV_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/athendpack.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athendpack.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/athendpack.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athendpack.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,41 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * @file: athendpack.h
+ *
+ * @abstract: end compiler-specific structure packing
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#ifdef VXWORKS
+#endif /* VXWORKS */
+
+#ifdef LINUX
+#endif /* LINUX */
+
+#ifdef QNX
+#endif /* QNX */
+
+#ifdef INTEGRITY
+#include "integrity/athendpack_integrity.h"
+#endif /* INTEGRITY */
+
+#ifdef NUCLEUS
+#endif /* NUCLEUS */
+
+#ifdef UNDER_CE
+#include "../os/wince/include/athendpack_wince.h"
+#endif /* WINCE */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/athstartpack.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athstartpack.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/athstartpack.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/athstartpack.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,42 @@
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * @file: athstartpack.h
+ *
+ * @abstract: start compiler-specific structure packing
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef VXWORKS
+#endif /* VXWORKS */
+
+#ifdef LINUX
+#endif /* LINUX */
+
+#ifdef QNX
+#endif /* QNX */
+
+#ifdef INTEGRITY
+#include "integrity/athstartpack_integrity.h"
+#endif /* INTEGRITY */
+
+#ifdef NUCLEUS
+#endif /* NUCLEUS */
+
+#ifdef UNDER_CE
+#include "../os/wince/include/athstartpack_wince.h"
+#endif /* WINCE */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_types.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_types.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/a_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/a_types.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef _A_TYPES_H_
+#define _A_TYPES_H_
+/*
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/a_types.h#1 $
+ *
+ * This file contains the definitions of the basic atheros data types.
+ * It is used to map the data types in atheros files to a platform specific
+ * type.
+ *
+ * Copyright 2003-2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "../ar6000/athtypes_linux.h"
+
+#endif /* _ATHTYPES_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/bmi.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/bmi.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/bmi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/bmi.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,100 @@
+#ifndef _BMI_H_
+#define _BMI_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * BMI declarations and prototypes
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Header files */
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "hif.h"
+#include "a_osapi.h"
+#include "bmi_msg.h"
+
+void
+BMIInit(void);
+
+A_STATUS
+BMIDone(HIF_DEVICE *device);
+
+A_STATUS
+BMIGetTargetInfo(HIF_DEVICE *device, struct bmi_target_info *targ_info);
+
+A_STATUS
+BMIReadMemory(HIF_DEVICE *device,
+              A_UINT32 address,
+              A_UCHAR *buffer,
+              A_UINT32 length);
+
+A_STATUS
+BMIWriteMemory(HIF_DEVICE *device,
+               A_UINT32 address,
+               A_UCHAR *buffer,
+               A_UINT32 length);
+
+A_STATUS
+BMIExecute(HIF_DEVICE *device,
+           A_UINT32 address,
+           A_UINT32 *param);
+
+A_STATUS
+BMISetAppStart(HIF_DEVICE *device,
+               A_UINT32 address);
+
+A_STATUS
+BMIReadSOCRegister(HIF_DEVICE *device,
+                   A_UINT32 address,
+                   A_UINT32 *param);
+
+A_STATUS
+BMIWriteSOCRegister(HIF_DEVICE *device,
+                    A_UINT32 address,
+                    A_UINT32 param);
+
+A_STATUS
+BMIrompatchInstall(HIF_DEVICE *device,
+                   A_UINT32 ROM_addr,
+                   A_UINT32 RAM_addr,
+                   A_UINT32 nbytes,
+                   A_UINT32 do_activate,
+                   A_UINT32 *patch_id);
+
+A_STATUS
+BMIrompatchUninstall(HIF_DEVICE *device,
+                     A_UINT32 rompatch_id);
+
+A_STATUS
+BMIrompatchActivate(HIF_DEVICE *device,
+                    A_UINT32 rompatch_count,
+                    A_UINT32 *rompatch_list);
+
+A_STATUS
+BMIrompatchDeactivate(HIF_DEVICE *device,
+                      A_UINT32 rompatch_count,
+                      A_UINT32 *rompatch_list);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _BMI_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/bmi_msg.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/bmi_msg.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/bmi_msg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/bmi_msg.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,199 @@
+#ifndef __BMI_MSG_H__
+#define __BMI_MSG_H__
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/*
+ * Bootloader Messaging Interface (BMI)
+ *
+ * BMI is a very simple messaging interface used during initialization
+ * to read memory, write memory, execute code, and to define an
+ * application entry PC.
+ *
+ * It is used to download an application to AR6K, to provide
+ * patches to code that is already resident on AR6K, and generally
+ * to examine and modify state.  The Host has an opportunity to use
+ * BMI only once during bootup.  Once the Host issues a BMI_DONE
+ * command, this opportunity ends.
+ *
+ * The Host writes BMI requests to mailbox0, and reads BMI responses
+ * from mailbox0.   BMI requests all begin with a command
+ * (see below for specific commands), and are followed by
+ * command-specific data.
+ *
+ * Flow control:
+ * The Host can only issue a command once the Target gives it a
+ * "BMI Command Credit", using AR6K Counter #4.  As soon as the
+ * Target has completed a command, it issues another BMI Command
+ * Credit (so the Host can issue the next command).
+ *
+ * BMI handles all required Target-side cache flushing.
+ */
+
+
+/* Maximum data size used for BMI transfers */
+#define BMI_DATASZ_MAX                     32
+
+/* BMI Commands */
+
+#define BMI_NO_COMMAND                      0
+
+#define BMI_DONE                            1
+        /*
+         * Semantics: Host is done using BMI
+         * Request format:
+         *    A_UINT32      command (BMI_DONE)
+         * Response format: none
+         */
+
+#define BMI_READ_MEMORY                     2
+        /*
+         * Semantics: Host reads AR6K memory
+         * Request format:
+         *    A_UINT32      command (BMI_READ_MEMORY)
+         *    A_UINT32      address
+         *    A_UINT32      length, at most BMI_DATASZ_MAX
+         * Response format:
+         *    A_UINT8       data[length]
+         */
+
+#define BMI_WRITE_MEMORY                    3
+        /*
+         * Semantics: Host writes AR6K memory
+         * Request format:
+         *    A_UINT32       command (BMI_WRITE_MEMORY)
+         *    A_UINT32      address
+         *    A_UINT32      length, at most BMI_DATASZ_MAX
+         *    A_UINT8       data[length]
+         * Response format: none
+         */
+
+#define BMI_EXECUTE                         4
+        /*
+         * Semantics: Causes AR6K to execute code
+         * Request format:
+         *    A_UINT32      command (BMI_EXECUTE)
+         *    A_UINT32      address
+         *    A_UINT32      parameter
+         * Response format:
+         *    A_UINT32      return value
+         */
+
+#define BMI_SET_APP_START                   5
+        /*
+         * Semantics: Set Target application starting address
+         * Request format:
+         *    A_UINT32      command (BMI_SET_APP_START)
+         *    A_UINT32      address
+         * Response format: none
+         */
+
+#define BMI_READ_SOC_REGISTER               6
+        /*
+         * Semantics: Read a 32-bit Target SOC register.
+         * Request format:
+         *    A_UINT32      command (BMI_READ_REGISTER)
+         *    A_UINT32      address
+         * Response format:
+         *    A_UINT32      value
+         */
+
+#define BMI_WRITE_SOC_REGISTER              7
+        /*
+         * Semantics: Write a 32-bit Target SOC register.
+         * Request format:
+         *    A_UINT32      command (BMI_WRITE_REGISTER)
+         *    A_UINT32      address
+         *    A_UINT32      value
+         *
+         * Response format: none
+         */
+
+#define BMI_GET_TARGET_ID                  8
+#define BMI_GET_TARGET_INFO                8
+        /*
+         * Semantics: Fetch the 4-byte Target information
+         * Request format:
+         *    A_UINT32      command (BMI_GET_TARGET_ID/INFO)
+         * Response format1 (old firmware):
+         *    A_UINT32      TargetVersionID
+         * Response format2 (newer firmware):
+         *    A_UINT32      TARGET_VERSION_SENTINAL
+         *    struct bmi_target_info;
+         */
+
+struct bmi_target_info {
+    A_UINT32 target_info_byte_count; /* size of this structure */
+    A_UINT32 target_ver;             /* Target Version ID */
+    A_UINT32 target_type;            /* Target type */
+};
+#define TARGET_VERSION_SENTINAL 0xffffffff
+#define TARGET_TYPE_AR6001 1
+#define TARGET_TYPE_AR6002 2
+
+
+#define BMI_ROMPATCH_INSTALL               9
+        /*
+         * Semantics: Install a ROM Patch.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_INSTALL)
+         *    A_UINT32      Target ROM Address
+         *    A_UINT32      Target RAM Address
+         *    A_UINT32      Size, in bytes
+         *    A_UINT32      Activate? 1-->activate;
+         *                            0-->install but do not activate
+         * Response format:
+         *    A_UINT32      PatchID
+         */
+
+#define BMI_ROMPATCH_UNINSTALL             10
+        /*
+         * Semantics: Uninstall a previously-installed ROM Patch,
+         * automatically deactivating, if necessary.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_UNINSTALL)
+         *    A_UINT32      PatchID
+         *
+         * Response format: none
+         */
+
+#define BMI_ROMPATCH_ACTIVATE              11
+        /*
+         * Semantics: Activate a list of previously-installed ROM Patches.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_ACTIVATE)
+         *    A_UINT32      rompatch_count
+         *    A_UINT32      PatchID[rompatch_count]
+         *
+         * Response format: none
+         */
+
+#define BMI_ROMPATCH_DEACTIVATE            12
+        /*
+         * Semantics: Deactivate a list of active ROM Patches.
+         * Request format:
+         *    A_UINT32      command (BMI_ROMPATCH_DEACTIVATE)
+         *    A_UINT32      rompatch_count
+         *    A_UINT32      PatchID[rompatch_count]
+         *
+         * Response format: none
+         */
+
+
+#endif /* __BMI_MSG_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/common_drv.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/common_drv.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/common_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/common_drv.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,61 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+
+#ifndef COMMON_DRV_H_
+#define COMMON_DRV_H_
+
+#include "hif.h"
+#include "htc_packet.h"
+
+
+
+/* structure that is the state information for the default credit distribution callback
+ * drivers should instantiate (zero-init as well) this structure in their driver instance
+ * and pass it as a context to the HTC credit distribution functions */
+typedef struct _COMMON_CREDIT_STATE_INFO {
+    int TotalAvailableCredits;      /* total credits in the system at startup */
+    int CurrentFreeCredits;         /* credits available in the pool that have not been
+                                       given out to endpoints */
+    HTC_ENDPOINT_CREDIT_DIST *pLowestPriEpDist;  /* pointer to the lowest priority endpoint dist struct */
+} COMMON_CREDIT_STATE_INFO;
+
+
+/* HTC TX packet tagging definitions */
+#define AR6K_CONTROL_PKT_TAG    HTC_TX_PACKET_TAG_USER_DEFINED
+#define AR6K_DATA_PKT_TAG       (AR6K_CONTROL_PKT_TAG + 1)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* OS-independent APIs */
+A_STATUS ar6000_setup_credit_dist(HTC_HANDLE HTCHandle, COMMON_CREDIT_STATE_INFO *pCredInfo);
+A_STATUS ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+A_STATUS ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data);
+A_STATUS ar6000_ReadDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,  A_UCHAR *data, A_UINT32 length);
+A_STATUS ar6000_reset_device(HIF_DEVICE *hifDevice, A_UINT32 TargetType);
+void ar6000_dump_target_assert_info(HIF_DEVICE *hifDevice, A_UINT32 TargetType);
+A_STATUS ar6000_reset_device_skipflash(HIF_DEVICE *hifDevice);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*COMMON_DRV_H_*/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dbglog_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dbglog_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dbglog_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dbglog_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,46 @@
+#ifndef _DBGLOG_API_H_
+#define _DBGLOG_API_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * This file contains host side debug primitives.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "dbglog.h"
+
+#define DBGLOG_HOST_LOG_BUFFER_SIZE            DBGLOG_LOG_BUFFER_SIZE
+
+#define DBGLOG_GET_DBGID(arg) \
+    ((arg & DBGLOG_DBGID_MASK) >> DBGLOG_DBGID_OFFSET)
+
+#define DBGLOG_GET_MODULEID(arg) \
+    ((arg & DBGLOG_MODULEID_MASK) >> DBGLOG_MODULEID_OFFSET)
+
+#define DBGLOG_GET_NUMARGS(arg) \
+    ((arg & DBGLOG_NUM_ARGS_MASK) >> DBGLOG_NUM_ARGS_OFFSET)
+
+#define DBGLOG_GET_TIMESTAMP(arg) \
+    ((arg & DBGLOG_TIMESTAMP_MASK) >> DBGLOG_TIMESTAMP_OFFSET)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DBGLOG_API_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dbglog.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dbglog.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dbglog.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dbglog.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains the definitions and data structures associated with
+ * the log based debug mechanism.
+ *
+ */
+
+#ifndef _DBGLOG_H_
+#define _DBGLOG_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DBGLOG_TIMESTAMP_OFFSET          0
+#define DBGLOG_TIMESTAMP_MASK            0x0000FFFF /* Bit 0-15. Contains bit
+                                                       8-23 of the LF0 timer */
+#define DBGLOG_DBGID_OFFSET              16
+#define DBGLOG_DBGID_MASK                0x03FF0000 /* Bit 16-25 */
+#define DBGLOG_DBGID_NUM_MAX             256 /* Upper limit is width of mask */
+
+#define DBGLOG_MODULEID_OFFSET           26
+#define DBGLOG_MODULEID_MASK             0x3C000000 /* Bit 26-29 */
+#define DBGLOG_MODULEID_NUM_MAX          16 /* Upper limit is width of mask */
+
+/*
+ * Please ensure that the definition of any new module intrduced is captured
+ * between the DBGLOG_MODULEID_START and DBGLOG_MODULEID_END defines. The
+ * structure is required for the parser to correctly pick up the values for
+ * different modules.
+ */
+#define DBGLOG_MODULEID_START
+#define DBGLOG_MODULEID_INF                   0
+#define DBGLOG_MODULEID_WMI                   1
+#define DBGLOG_MODULEID_CSERV                 2
+#define DBGLOG_MODULEID_PM                    3
+#define DBGLOG_MODULEID_TXRX_MGMTBUF          4
+#define DBGLOG_MODULEID_TXRX_TXBUF            5
+#define DBGLOG_MODULEID_TXRX_RXBUF            6
+#define DBGLOG_MODULEID_WOW                   7
+#define DBGLOG_MODULEID_WHAL                  8
+#define DBGLOG_MODULEID_END
+
+#define DBGLOG_NUM_ARGS_OFFSET             30
+#define DBGLOG_NUM_ARGS_MASK               0xC0000000 /* Bit 30-31 */
+#define DBGLOG_NUM_ARGS_MAX                2 /* Upper limit is width of mask */
+
+#define DBGLOG_MODULE_LOG_ENABLE_OFFSET    0
+#define DBGLOG_MODULE_LOG_ENABLE_MASK      0x0000FFFF
+
+#define DBGLOG_REPORTING_ENABLED_OFFSET    16
+#define DBGLOG_REPORTING_ENABLED_MASK      0x00010000
+
+#define DBGLOG_TIMESTAMP_RESOLUTION_OFFSET 17
+#define DBGLOG_TIMESTAMP_RESOLUTION_MASK   0x000E0000
+
+#define DBGLOG_REPORT_SIZE_OFFSET          20
+#define DBGLOG_REPORT_SIZE_MASK            0x3FF00000
+
+#define DBGLOG_LOG_BUFFER_SIZE             1500
+#define DBGLOG_DBGID_DEFINITION_LEN_MAX    64
+
+struct dbglog_buf_s {
+    struct dbglog_buf_s *next;
+    A_INT8              *buffer;
+    A_UINT32             bufsize;
+    A_UINT32             length;
+    A_UINT32             count;
+    A_UINT32             free;
+};
+
+struct dbglog_hdr_s {
+    struct dbglog_buf_s *dbuf;
+    A_UINT32             dropped;
+};
+
+struct dbglog_config_s {
+    A_UINT32                    cfgvalid; /* Mask with valid config bits */
+    union {
+        /* TODO: Take care of endianness */
+        struct {
+            A_UINT32            mmask:16; /* Mask of modules with logging on */
+            A_UINT32            rep:1; /* Reporting enabled or not */
+            A_UINT32            tsr:3; /* Time stamp resolution. Def: 1 ms */
+            A_UINT32            size:10; /* Report size in number of messages */
+            A_UINT32            reserved:2;
+        } dbglog_config;
+
+        A_UINT32                value;
+    } u;
+};
+
+#define cfgmmask                   u.dbglog_config.mmask
+#define cfgrep                     u.dbglog_config.rep
+#define cfgtsr                     u.dbglog_config.tsr
+#define cfgsize                    u.dbglog_config.size
+#define cfgvalue                   u.value
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DBGLOG_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dbglog_id.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dbglog_id.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dbglog_id.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dbglog_id.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,307 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains the definitions of the debug identifiers for different
+ * modules.
+ *
+ */
+
+#ifndef _DBGLOG_ID_H_
+#define _DBGLOG_ID_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The nomenclature for the debug identifiers is MODULE_DESCRIPTION.
+ * Please ensure that the definition of any new debugid introduced is captured
+ * between the <MODULE>_DBGID_DEFINITION_START and
+ * <MODULE>_DBGID_DEFINITION_END defines. The structure is required for the
+ * parser to correctly pick up the values for different debug identifiers.
+ */
+
+/* INF debug identifier definitions */
+#define INF_DBGID_DEFINITION_START
+#define INF_ASSERTION_FAILED                          1
+#define INF_TARGET_ID                                 2
+#define INF_DBGID_DEFINITION_END
+
+/* WMI debug identifier definitions */
+#define WMI_DBGID_DEFINITION_START
+#define WMI_CMD_RX_XTND_PKT_TOO_SHORT                 1
+#define WMI_EXTENDED_CMD_NOT_HANDLED                  2
+#define WMI_CMD_RX_PKT_TOO_SHORT                      3
+#define WMI_CALLING_WMI_EXTENSION_FN                  4
+#define WMI_CMD_NOT_HANDLED                           5
+#define WMI_IN_SYNC                                   6
+#define WMI_TARGET_WMI_SYNC_CMD                       7
+#define WMI_SET_SNR_THRESHOLD_PARAMS                  8
+#define WMI_SET_RSSI_THRESHOLD_PARAMS                 9
+#define WMI_SET_LQ_TRESHOLD_PARAMS                   10
+#define WMI_TARGET_CREATE_PSTREAM_CMD                11
+#define WMI_WI_DTM_INUSE                             12
+#define WMI_TARGET_DELETE_PSTREAM_CMD                13
+#define WMI_TARGET_IMPLICIT_DELETE_PSTREAM_CMD       14
+#define WMI_TARGET_GET_BIT_RATE_CMD                  15
+#define WMI_GET_RATE_MASK_CMD_FIX_RATE_MASK_IS       16
+#define WMI_TARGET_GET_AVAILABLE_CHANNELS_CMD        17
+#define WMI_TARGET_GET_TX_PWR_CMD                    18
+#define WMI_FREE_EVBUF_WMIBUF                        19
+#define WMI_FREE_EVBUF_DATABUF                       20
+#define WMI_FREE_EVBUF_BADFLAG                       21
+#define WMI_HTC_RX_ERROR_DATA_PACKET                 22
+#define WMI_HTC_RX_SYNC_PAUSING_FOR_MBOX             23
+#define WMI_INCORRECT_WMI_DATA_HDR_DROPPING_PKT      24
+#define WMI_SENDING_READY_EVENT                      25
+#define WMI_SETPOWER_MDOE_TO_MAXPERF                 26
+#define WMI_SETPOWER_MDOE_TO_REC                     27
+#define WMI_BSSINFO_EVENT_FROM                       28
+#define WMI_TARGET_GET_STATS_CMD                     29
+#define WMI_SENDING_SCAN_COMPLETE_EVENT              30
+#define WMI_SENDING_RSSI_INDB_THRESHOLD_EVENT        31
+#define WMI_SENDING_RSSI_INDBM_THRESHOLD_EVENT       32
+#define WMI_SENDING_LINK_QUALITY_THRESHOLD_EVENT     33
+#define WMI_SENDING_ERROR_REPORT_EVENT               34
+#define WMI_SENDING_CAC_EVENT                        35
+#define WMI_TARGET_GET_ROAM_TABLE_CMD                36
+#define WMI_TARGET_GET_ROAM_DATA_CMD                 37
+#define WMI_SENDING_GPIO_INTR_EVENT                  38
+#define WMI_SENDING_GPIO_ACK_EVENT                   39
+#define WMI_SENDING_GPIO_DATA_EVENT                  40
+#define WMI_CMD_RX                                   41
+#define WMI_CMD_RX_XTND                              42
+#define WMI_EVENT_SEND                               43
+#define WMI_EVENT_SEND_XTND                          44
+#define WMI_DBGID_DEFINITION_END
+
+/* CSERV debug identifier definitions */
+#define CSERV_DBGID_DEFINITION_START
+#define CSERV_BEGIN_SCAN1                             1
+#define CSERV_BEGIN_SCAN2                             2
+#define CSERV_END_SCAN1                               3
+#define CSERV_END_SCAN2                               4
+#define CSERV_CHAN_SCAN_START                         5
+#define CSERV_CHAN_SCAN_STOP                          6
+#define CSERV_CHANNEL_OPPPORTUNITY                    7
+#define CSERV_NC_TIMEOUT                              8
+#define CSERV_BACK_HOME                              10
+#define CSERV_CHMGR_CH_CALLBACK1                     11
+#define CSERV_CHMGR_CH_CALLBACK2                     12
+#define CSERV_CHMGR_CH_CALLBACK3                     13
+#define CSERV_SET_SCAN_PARAMS1                       14
+#define CSERV_SET_SCAN_PARAMS2                       15
+#define CSERV_SET_SCAN_PARAMS3                       16
+#define CSERV_SET_SCAN_PARAMS4                       17
+#define CSERV_ABORT_SCAN                             18
+#define CSERV_NEWSTATE                               19
+#define CSERV_MINCHMGR_OP_END                        20
+#define CSERV_CHMGR_OP_END                           21
+#define CSERV_DISCONNECT_TIMEOUT                     22
+#define CSERV_ROAM_TIMEOUT                           23
+#define CSERV_FORCE_SCAN1                            24
+#define CSERV_FORCE_SCAN2                            25
+#define CSERV_FORCE_SCAN3                            26
+#define CSERV_UTIL_TIMEOUT                           27
+#define CSERV_RSSIPOLLER                             28
+#define CSERV_RETRY_CONNECT_TIMEOUT                  29
+#define CSERV_RSSIINDBMPOLLER                        30
+#define CSERV_BGSCAN_ENABLE                          31
+#define CSERV_BGSCAN_DISABLE                         32
+#define CSERV_WLAN_START_SCAN_CMD1                   33
+#define CSERV_WLAN_START_SCAN_CMD2                   34
+#define CSERV_WLAN_START_SCAN_CMD3                   35
+#define CSERV_START_SCAN_CMD                         36
+#define CSERV_START_FORCE_SCAN                       37
+#define CSERV_NEXT_CHAN                              38
+#define CSERV_SET_REGCODE                            39
+#define CSERV_START_ADHOC                            40
+#define CSERV_ADHOC_AT_HOME                          41
+#define CSERV_OPT_AT_HOME                            42
+#define CSERV_WLAN_CONNECT_CMD                       43
+#define CSERV_WLAN_RECONNECT_CMD                     44
+#define CSERV_WLAN_DISCONNECT_CMD                    45
+#define CSERV_BSS_CHANGE_CHANNEL                     46
+#define CSERV_BEACON_RX                              47
+#define CSERV_KEEPALIVE_CHECK                        48
+#define CSERV_RC_BEGIN_SCAN                          49
+#define CSERV_RC_SCAN_START                          50
+#define CSERV_RC_SCAN_STOP                           51
+#define CSERV_RC_NEXT                                52
+#define CSERV_RC_SCAN_END                            53
+#define CSERV_PROBE_CALLBACK                         54
+#define CSERV_ROAM1                                  55
+#define CSERV_ROAM2                                  56
+#define CSERV_ROAM3                                  57
+#define CSERV_CONNECT_EVENT                          58
+#define CSERV_DISCONNECT_EVENT                       59
+#define CSERV_BMISS_HANDLER1                         60
+#define CSERV_BMISS_HANDLER2                         61
+#define CSERV_BMISS_HANDLER3                         62
+#define CSERV_LOWRSSI_HANDLER                        63
+#define CSERV_WLAN_SET_PMKID_CMD                     64
+#define CSERV_RECONNECT_REQUEST                      65
+#define CSERV_KEYSPLUMBED_EVENT                      66
+#define CSERV_NEW_REG                                67
+#define CSERV_SET_RSSI_THOLD                         68
+#define CSERV_RSSITHRESHOLDCHECK                     69
+#define CSERV_RSSIINDBMTHRESHOLDCHECK                70
+#define CSERV_WLAN_SET_OPT_CMD1                      71
+#define CSERV_WLAN_SET_OPT_CMD2                      72
+#define CSERV_WLAN_SET_OPT_CMD3                      73
+#define CSERV_WLAN_SET_OPT_CMD4                      74
+#define CSERV_SCAN_CONNECT_STOP                      75
+#define CSERV_BMISS_HANDLER4                         76
+#define CSERV_INITIALIZE_TIMER                       77
+#define CSERV_ARM_TIMER                              78
+#define CSERV_DISARM_TIMER                           79
+#define CSERV_UNINITIALIZE_TIMER                     80
+#define CSERV_DISCONNECT_EVENT2                      81
+#define CSERV_SCAN_CONNECT_START                     82
+#define CSERV_BSSINFO_MEMORY_ALLOC_FAILED            83
+#define CSERV_SET_SCAN_PARAMS5                       84
+#define CSERV_DBGID_DEFINITION_END
+
+/* TXRX debug identifier definitions */
+#define TXRX_TXBUF_DBGID_DEFINITION_START
+#define TXRX_TXBUF_ALLOCATE_BUF                      1
+#define TXRX_TXBUF_QUEUE_BUF_TO_MBOX                 2
+#define TXRX_TXBUF_QUEUE_BUF_TO_TXQ                  3
+#define TXRX_TXBUF_TXQ_DEPTH                         4
+#define TXRX_TXBUF_IBSS_QUEUE_TO_SFQ                 5
+#define TXRX_TXBUF_IBSS_QUEUE_TO_TXQ_FRM_SFQ         6
+#define TXRX_TXBUF_INITIALIZE_TIMER                  7
+#define TXRX_TXBUF_ARM_TIMER                         8
+#define TXRX_TXBUF_DISARM_TIMER                      9
+#define TXRX_TXBUF_UNINITIALIZE_TIMER                10
+#define TXRX_TXBUF_DBGID_DEFINITION_END
+
+#define TXRX_RXBUF_DBGID_DEFINITION_START
+#define TXRX_RXBUF_ALLOCATE_BUF                      1
+#define TXRX_RXBUF_QUEUE_TO_HOST                     2
+#define TXRX_RXBUF_QUEUE_TO_WLAN                     3
+#define TXRX_RXBUF_ZERO_LEN_BUF                      4
+#define TXRX_RXBUF_QUEUE_TO_HOST_LASTBUF_IN_RXCHAIN  5
+#define TXRX_RXBUF_LASTBUF_IN_RXCHAIN_ZEROBUF        6
+#define TXRX_RXBUF_QUEUE_EMPTY_QUEUE_TO_WLAN         7
+#define TXRX_RXBUF_SEND_TO_RECV_MGMT                 8
+#define TXRX_RXBUF_SEND_TO_IEEE_LAYER                9
+#define TXRX_RXBUF_DBGID_DEFINITION_END
+
+#define TXRX_MGMTBUF_DBGID_DEFINITION_START
+#define TXRX_MGMTBUF_ALLOCATE_BUF                    1
+#define TXRX_MGMTBUF_ALLOCATE_SM_BUF                 2
+#define TXRX_MGMTBUF_ALLOCATE_RMBUF                  3
+#define TXRX_MGMTBUF_GET_BUF                         4
+#define TXRX_MGMTBUF_GET_SM_BUF                      5
+#define TXRX_MGMTBUF_QUEUE_BUF_TO_TXQ                6
+#define TXRX_MGMTBUF_REAPED_BUF                      7
+#define TXRX_MGMTBUF_REAPED_SM_BUF                   8
+#define TXRX_MGMTBUF_WAIT_FOR_TXQ_DRAIN              9
+#define TXRX_MGMTBUF_WAIT_FOR_TXQ_SFQ_DRAIN          10
+#define TXRX_MGMTBUF_ENQUEUE_INTO_SFQ                11
+#define TXRX_MGMTBUF_DEQUEUE_FROM_SFQ                12
+#define TXRX_MGMTBUF_PAUSE_TXQ                       13
+#define TXRX_MGMTBUF_RESUME_TXQ                      14
+#define TXRX_MGMTBUF_WAIT_FORTXQ_DRAIN_TIMEOUT       15
+#define TXRX_MGMTBUF_DRAINQ                          16
+#define TXRX_MGMTBUF_INDICATE_Q_DRAINED              17
+#define TXRX_MGMTBUF_DBGID_DEFINITION_END
+
+/* PM (Power Module) debug identifier definitions */
+#define PM_DBGID_DEFINITION_START
+#define PM_INIT                                      1
+#define PM_ENABLE                                    2
+#define PM_SET_STATE                                 3
+#define PM_SET_POWERMODE                             4
+#define PM_CONN_NOTIFY                               5
+#define PM_REF_COUNT_NEGATIVE                        6
+#define PM_APSD_ENABLE                               7
+#define PM_UPDATE_APSD_STATE                         8
+#define PM_CHAN_OP_REQ                               9
+#define PM_SET_MY_BEACON_POLICY                      10
+#define PM_SET_ALL_BEACON_POLICY                     11
+#define PM_SET_PM_PARAMS1                            12
+#define PM_SET_PM_PARAMS2                            13
+#define PM_ADHOC_SET_PM_CAPS_FAIL                    14
+#define PM_ADHOC_UNKNOWN_IBSS_ATTRIB_ID              15
+#define PM_DBGID_DEFINITION_END
+
+/* Wake on Wireless debug identifier definitions */
+#define WOW_DBGID_DEFINITION_START
+#define WOW_INIT                                        1
+#define WOW_GET_CONFIG_DSET                             2
+#define WOW_NO_CONFIG_DSET                              3
+#define WOW_INVALID_CONFIG_DSET                         4
+#define WOW_USE_DEFAULT_CONFIG                          5
+#define WOW_SETUP_GPIO                                  6
+#define WOW_INIT_DONE                                   7
+#define WOW_SET_GPIO_PIN                                8
+#define WOW_CLEAR_GPIO_PIN                              9
+#define WOW_SET_WOW_MODE_CMD                            10
+#define WOW_SET_HOST_MODE_CMD                           11
+#define WOW_ADD_WOW_PATTERN_CMD                         12
+#define WOW_NEW_WOW_PATTERN_AT_INDEX                    13
+#define WOW_DEL_WOW_PATTERN_CMD                         14
+#define WOW_LIST_CONTAINS_PATTERNS                      15
+#define WOW_GET_WOW_LIST_CMD                            16
+#define WOW_INVALID_FILTER_ID                           17
+#define WOW_INVALID_FILTER_LISTID                       18
+#define WOW_NO_VALID_FILTER_AT_ID                       19
+#define WOW_NO_VALID_LIST_AT_ID                         20
+#define WOW_NUM_PATTERNS_EXCEEDED                       21
+#define WOW_NUM_LISTS_EXCEEDED                          22
+#define WOW_GET_WOW_STATS                               23
+#define WOW_CLEAR_WOW_STATS                             24
+#define WOW_WAKEUP_HOST                                 25
+#define WOW_EVENT_WAKEUP_HOST                           26
+#define WOW_EVENT_DISCARD                               27
+#define WOW_PATTERN_MATCH                               28
+#define WOW_PATTERN_NOT_MATCH                           29
+#define WOW_PATTERN_NOT_MATCH_OFFSET                    30
+#define WOW_DISABLED_HOST_ASLEEP                        31
+#define WOW_ENABLED_HOST_ASLEEP_NO_PATTERNS             32
+#define WOW_ENABLED_HOST_ASLEEP_NO_MATCH_FOUND          33
+#define WOW_DBGID_DEFINITION_END
+
+/* WHAL debug identifier definitions */
+#define WHAL_DBGID_DEFINITION_START
+#define WHAL_ERROR_ANI_CONTROL                      1
+#define WHAL_ERROR_CHIP_TEST1                       2
+#define WHAL_ERROR_CHIP_TEST2                       3
+#define WHAL_ERROR_EEPROM_CHECKSUM                  4
+#define WHAL_ERROR_EEPROM_MACADDR                   5
+#define WHAL_ERROR_INTERRUPT_HIU                    6
+#define WHAL_ERROR_KEYCACHE_RESET                   7
+#define WHAL_ERROR_KEYCACHE_SET                     8
+#define WHAL_ERROR_KEYCACHE_TYPE                    9
+#define WHAL_ERROR_KEYCACHE_TKIPENTRY              10
+#define WHAL_ERROR_KEYCACHE_WEPLENGTH              11
+#define WHAL_ERROR_PHY_INVALID_CHANNEL             12
+#define WHAL_ERROR_POWER_AWAKE                     13
+#define WHAL_ERROR_POWER_SET                       14
+#define WHAL_ERROR_RECV_STOPDMA                    15
+#define WHAL_ERROR_RECV_STOPPCU                    16
+#define WHAL_ERROR_RESET_CHANNF1                   17
+#define WHAL_ERROR_RESET_CHANNF2                   18
+#define WHAL_ERROR_RESET_PM                        19
+#define WHAL_ERROR_RESET_OFFSETCAL                 20
+#define WHAL_ERROR_RESET_RFGRANT                   21
+#define WHAL_ERROR_RESET_RXFRAME                   22
+#define WHAL_ERROR_RESET_STOPDMA                   23
+#define WHAL_ERROR_RESET_RECOVER                   24
+#define WHAL_ERROR_XMIT_COMPUTE                    25
+#define WHAL_ERROR_XMIT_NOQUEUE                    26
+#define WHAL_ERROR_XMIT_ACTIVEQUEUE                27
+#define WHAL_ERROR_XMIT_BADTYPE                    28
+#define WHAL_DBGID_DEFINITION_END
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DBGLOG_ID_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dl_list.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dl_list.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dl_list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dl_list.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+ *
+ * Double-link list definitions (adapted from Atheros SDIO stack)
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+#ifndef __DL_LIST_H___
+#define __DL_LIST_H___
+
+#define A_CONTAINING_STRUCT(address, struct_type, field_name)\
+            ((struct_type *)((A_UINT32)(address) - (A_UINT32)(&((struct_type *)0)->field_name)))
+
+/* list functions */
+/* pointers for the list */
+typedef struct _DL_LIST {
+    struct _DL_LIST *pPrev;
+    struct _DL_LIST *pNext;
+}DL_LIST, *PDL_LIST;
+/*
+ * DL_LIST_INIT , initialize doubly linked list
+*/
+#define DL_LIST_INIT(pList)\
+    {(pList)->pPrev = pList; (pList)->pNext = pList;}
+
+#define DL_LIST_IS_EMPTY(pList) (((pList)->pPrev == (pList)) && ((pList)->pNext == (pList)))
+#define DL_LIST_GET_ITEM_AT_HEAD(pList) (pList)->pNext
+#define DL_LIST_GET_ITEM_AT_TAIL(pList) (pList)->pPrev
+/*
+ * ITERATE_OVER_LIST pStart is the list, pTemp is a temp list member
+ * NOT: do not use this function if the items in the list are deleted inside the
+ * iteration loop
+*/
+#define ITERATE_OVER_LIST(pStart, pTemp) \
+    for((pTemp) =(pStart)->pNext; pTemp != (pStart); (pTemp) = (pTemp)->pNext)
+
+
+/* safe iterate macro that allows the item to be removed from the list
+ * the iteration continues to the next item in the list
+ */
+#define ITERATE_OVER_LIST_ALLOW_REMOVE(pStart,pItem,st,offset)  \
+{                                                       \
+    PDL_LIST  pTemp;                                     \
+    pTemp = (pStart)->pNext;                            \
+    while (pTemp != (pStart)) {                         \
+        (pItem) = A_CONTAINING_STRUCT(pTemp,st,offset);   \
+         pTemp = pTemp->pNext;                          \
+
+#define ITERATE_END }}
+
+/*
+ * DL_ListInsertTail - insert pAdd to the end of the list
+*/
+static INLINE PDL_LIST DL_ListInsertTail(PDL_LIST pList, PDL_LIST pAdd) {
+        /* insert at tail */
+    pAdd->pPrev = pList->pPrev;
+    pAdd->pNext = pList;
+    pList->pPrev->pNext = pAdd;
+    pList->pPrev = pAdd;
+    return pAdd;
+}
+
+/*
+ * DL_ListInsertHead - insert pAdd into the head of the list
+*/
+static INLINE PDL_LIST DL_ListInsertHead(PDL_LIST pList, PDL_LIST pAdd) {
+        /* insert at head */
+    pAdd->pPrev = pList;
+    pAdd->pNext = pList->pNext;
+    pList->pNext->pPrev = pAdd;
+    pList->pNext = pAdd;
+    return pAdd;
+}
+
+#define DL_ListAdd(pList,pItem) DL_ListInsertHead((pList),(pItem))
+/*
+ * DL_ListRemove - remove pDel from list
+*/
+static INLINE PDL_LIST DL_ListRemove(PDL_LIST pDel) {
+    pDel->pNext->pPrev = pDel->pPrev;
+    pDel->pPrev->pNext = pDel->pNext;
+        /* point back to itself just to be safe, incase remove is called again */
+    pDel->pNext = pDel;
+    pDel->pPrev = pDel;
+    return pDel;
+}
+
+/*
+ * DL_ListRemoveItemFromHead - get a list item from the head
+*/
+static INLINE PDL_LIST DL_ListRemoveItemFromHead(PDL_LIST pList) {
+    PDL_LIST pItem = NULL;
+    if (pList->pNext != pList) {
+        pItem = pList->pNext;
+            /* remove the first item from head */
+        DL_ListRemove(pItem);
+    }
+    return pItem;
+}
+
+#endif /* __DL_LIST_H___ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dset_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dset_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dset_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dset_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/dset_api.h#1 $
+ *
+ * Host-side DataSet API.
+ *
+ */
+
+#ifndef _DSET_API_H_
+#define _DSET_API_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+ * Host-side DataSet support is optional, and is not
+ * currently required for correct operation.  To disable
+ * Host-side DataSet support, set this to 0.
+ */
+#ifndef CONFIG_HOST_DSET_SUPPORT
+#define CONFIG_HOST_DSET_SUPPORT 1
+#endif
+
+/* Called to send a DataSet Open Reply back to the Target. */
+A_STATUS wmi_dset_open_reply(struct wmi_t *wmip,
+                             A_UINT32 status,
+                             A_UINT32 access_cookie,
+                             A_UINT32 size,
+                             A_UINT32 version,
+                             A_UINT32 targ_handle,
+                             A_UINT32 targ_reply_fn,
+                             A_UINT32 targ_reply_arg);
+
+/* Called to send a DataSet Data Reply back to the Target. */
+A_STATUS wmi_dset_data_reply(struct wmi_t *wmip,
+                             A_UINT32 status,
+                             A_UINT8 *host_buf,
+                             A_UINT32 length,
+                             A_UINT32 targ_buf,
+                             A_UINT32 targ_reply_fn,
+                             A_UINT32 targ_reply_arg);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* _DSET_API_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dsetid.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dsetid.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dsetid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dsetid.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __DSETID_H__
+#define __DSETID_H__
+
+/* Well-known DataSet IDs */
+#define DSETID_UNUSED                     0x00000000
+#define DSETID_BOARD_DATA                 0x00000001 /* Cal and board data */
+#define DSETID_REGDB                      0x00000002 /* Regulatory Database */
+#define DSETID_POWER_CONTROL              0x00000003 /* TX Pwr Lim & Ant Gain */
+#define DSETID_USER_CONFIG                0x00000004 /* User Configuration */
+
+#define DSETID_ANALOG_CONTROL_DATA_START  0x00000005
+#define DSETID_ANALOG_CONTROL_DATA_END    0x00000025
+/*
+ * Get DSETID for various reference clock speeds.
+ * For each speed there are three DataSets that correspond
+ * to the three columns of bank6 data (addr, 11a, 11b/g).
+ * This macro returns the dsetid of the first of those
+ * three DataSets.
+ */
+#define ANALOG_CONTROL_DATA_DSETID(refclk) \
+        (DSETID_ANALOG_CONTROL_DATA_START + 3*refclk)
+
+/*
+ * There are TWO STARTUP_PATCH DataSets.
+ * DSETID_STARTUP_PATCH is historical, and was applied before BMI on
+ * earlier systems.  On AR6002, it is applied after BMI, just like
+ * DSETID_STARTUP_PATCH2.
+ */
+#define DSETID_STARTUP_PATCH              0x00000026
+#define DSETID_GPIO_CONFIG_PATCH          0x00000027
+#define DSETID_WLANREGS                   0x00000028 /* override wlan regs */
+#define DSETID_STARTUP_PATCH2             0x00000029
+
+#define DSETID_WOW_CONFIG                 0x00000090 /* WoW Configuration */
+
+/* Add WHAL_INI_DATA_ID to DSETID_INI_DATA for a specific WHAL INI table. */
+#define DSETID_INI_DATA                   0x00000100
+/* Reserved for WHAL INI Tables: 0x100..0x11f */
+#define DSETID_INI_DATA_END               0x0000011f
+
+#define DSETID_VENDOR_START               0x00010000 /* Vendor-defined DataSets */
+
+#define DSETID_INDEX_END                  0xfffffffe /* Reserved to indicate the
+                                                        end of a memory-based
+                                                        DataSet Index */
+#define DSETID_INDEX_FREE                 0xffffffff /* An unused index entry */
+
+/*
+ * PATCH DataSet format:
+ * A list of patches, terminated by a patch with
+ * address=PATCH_END.
+ *
+ * This allows for patches to be stored in flash.
+ */
+struct patch_s {
+    A_UINT32 *address;
+    A_UINT32  data;
+};
+
+/*
+ * Skip some patches.  Can be used to erase a single patch in a
+ * patch DataSet without having to re-write the DataSet.  May
+ * also be used to embed information for use by subsequent
+ * patch code.  The "data" in a PATCH_SKIP tells how many
+ * bytes of length "patch_s" to skip.
+ */
+#define PATCH_SKIP      ((A_UINT32 *)0x00000000)
+
+/*
+ * Execute code at the address specified by "data".
+ * The address of the patch structure is passed as
+ * the one parameter.
+ */
+#define PATCH_CODE_ABS  ((A_UINT32 *)0x00000001)
+
+/*
+ * Same as PATCH_CODE_ABS, but treat "data" as an
+ * offset from the start of the patch word.
+ */
+#define PATCH_CODE_REL  ((A_UINT32 *)0x00000002)
+
+/* Mark the end of this patch DataSet. */
+#define PATCH_END       ((A_UINT32 *)0xffffffff)
+
+/*
+ * A DataSet which contains a Binary Patch to some other DataSet
+ * uses the original dsetid with the DSETID_BPATCH_FLAG bit set.
+ * Such a BPatch DataSet consists of BPatch metadata followed by
+ * the bdiff bytes.  BPatch metadata consists of a single 32-bit
+ * word that contains the size of the BPatched final image.
+ *
+ * To create a suitable bdiff DataSet, use bdiff in host/tools/bdiff
+ * to create "diffs":
+ *  bdiff -q -O -nooldmd5 -nonewmd5 -d ORIGfile NEWfile diffs
+ * Then add BPatch metadata to the start of "diffs".
+ *
+ * NB: There are some implementation-induced restrictions
+ * on which DataSets can be BPatched.
+ */
+#define DSETID_BPATCH_FLAG                0x80000000
+
+#endif /* __DSETID_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/dset_internal.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dset_internal.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/dset_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/dset_internal.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __DSET_INTERNAL_H__
+#define __DSET_INTERNAL_H__
+
+/*
+ * Internal dset definitions, common for DataSet layer.
+ */
+
+#define DSET_TYPE_STANDARD      0
+#define DSET_TYPE_BPATCHED      1
+#define DSET_TYPE_COMPRESSED    2
+
+/* Dataset descriptor */
+
+typedef struct dset_descriptor_s {
+  struct dset_descriptor_s  *next;         /* List link. NULL only at the last
+                                              descriptor */
+  A_UINT16                   id;           /* Dset ID */
+  A_UINT16                   size;         /* Dset size. */
+  void                      *DataPtr;      /* Pointer to raw data for standard
+                                              DataSet or pointer to original
+                                              dset_descriptor for patched
+                                              DataSet */
+  A_UINT32                   data_type;    /* DSET_TYPE_*, above */
+
+  void                      *AuxPtr;       /* Additional data that might
+                                              needed for data_type. For
+                                              example, pointer to patch
+                                              Dataset descriptor for BPatch. */
+} dset_descriptor_t;
+
+#endif /* __DSET_INTERNAL_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/gpio_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/gpio_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/gpio_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/gpio_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,57 @@
+#ifndef _GPIO_API_H_
+#define _GPIO_API_H_
+/*
+ * Copyright 2005 Atheros Communications, Inc.,  All Rights Reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+/*
+ * Host-side General Purpose I/O API.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/gpio_api.h#1 $
+ */
+
+/*
+ * Send a command to the Target in order to change output on GPIO pins.
+ */
+A_STATUS wmi_gpio_output_set(struct wmi_t *wmip,
+                             A_UINT32 set_mask,
+                             A_UINT32 clear_mask,
+                             A_UINT32 enable_mask,
+                             A_UINT32 disable_mask);
+
+/*
+ * Send a command to the Target requesting input state of GPIO pins.
+ */
+A_STATUS wmi_gpio_input_get(struct wmi_t *wmip);
+
+/*
+ * Send a command to the Target to change the value of a GPIO register.
+ */
+A_STATUS wmi_gpio_register_set(struct wmi_t *wmip,
+                               A_UINT32 gpioreg_id,
+                               A_UINT32 value);
+
+/*
+ * Send a command to the Target to fetch the value of a GPIO register.
+ */
+A_STATUS wmi_gpio_register_get(struct wmi_t *wmip, A_UINT32 gpioreg_id);
+
+/*
+ * Send a command to the Target, acknowledging some GPIO interrupts.
+ */
+A_STATUS wmi_gpio_intr_ack(struct wmi_t *wmip, A_UINT32 ack_mask);
+
+#endif /* _GPIO_API_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/gpio.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/gpio.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/gpio.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#if defined(AR6001)
+#define GPIO_PIN_COUNT 18
+#else
+#define GPIO_PIN_COUNT 18
+#endif
+
+/*
+ * Possible values for WMIX_GPIO_SET_REGISTER_CMDID.
+ * NB: These match hardware order, so that addresses can
+ * easily be computed.
+ */
+#define GPIO_ID_OUT             0x00000000
+#define GPIO_ID_OUT_W1TS        0x00000001
+#define GPIO_ID_OUT_W1TC        0x00000002
+#define GPIO_ID_ENABLE          0x00000003
+#define GPIO_ID_ENABLE_W1TS     0x00000004
+#define GPIO_ID_ENABLE_W1TC     0x00000005
+#define GPIO_ID_IN              0x00000006
+#define GPIO_ID_STATUS          0x00000007
+#define GPIO_ID_STATUS_W1TS     0x00000008
+#define GPIO_ID_STATUS_W1TC     0x00000009
+#define GPIO_ID_PIN0            0x0000000a
+#define GPIO_ID_PIN(n)          (GPIO_ID_PIN0+(n))
+
+#define GPIO_LAST_REGISTER_ID   GPIO_ID_PIN(17)
+#define GPIO_ID_NONE            0xffffffff
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/hif.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/hif.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/hif.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/hif.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,296 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ * HIF specific declarations and prototypes
+ */
+
+#ifndef _HIF_H_
+#define _HIF_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Header files */
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+
+typedef struct htc_callbacks HTC_CALLBACKS;
+typedef struct hif_device HIF_DEVICE;
+
+/*
+ * direction - Direction of transfer (HIF_READ/HIF_WRITE).
+ */
+#define HIF_READ                    0x00000001
+#define HIF_WRITE                   0x00000002
+#define HIF_DIR_MASK                (HIF_READ | HIF_WRITE)
+
+/*
+ *     type - An interface may support different kind of read/write commands.
+ *            The command type is divided into a basic and an extended command
+ *            and can be specified using HIF_BASIC_IO/HIF_EXTENDED_IO.
+ */
+#define HIF_BASIC_IO                0x00000004
+#define HIF_EXTENDED_IO             0x00000008
+#define HIF_TYPE_MASK               (HIF_BASIC_IO | HIF_EXTENDED_IO)
+
+/*
+ *     emode - This indicates the whether the command is to be executed in a
+ *             blocking or non-blocking fashion (HIF_SYNCHRONOUS/
+ *             HIF_ASYNCHRONOUS). The read/write data paths in HTC have been
+ *             implemented using the asynchronous mode allowing the the bus
+ *             driver to indicate the completion of operation through the
+ *             registered callback routine. The requirement primarily comes
+ *             from the contexts these operations get called from (a driver's
+ *             transmit context or the ISR context in case of receive).
+ *             Support for both of these modes is essential.
+ */
+#define HIF_SYNCHRONOUS             0x00000010
+#define HIF_ASYNCHRONOUS            0x00000020
+#define HIF_EMODE_MASK              (HIF_SYNCHRONOUS | HIF_ASYNCHRONOUS)
+
+/*
+ *     dmode - An interface may support different kinds of commands based on
+ *             the tradeoff between the amount of data it can carry and the
+ *             setup time. Byte and Block modes are supported (HIF_BYTE_BASIS/
+ *             HIF_BLOCK_BASIS). In case of latter, the data is rounded off
+ *             to the nearest block size by padding. The size of the block is
+ *             configurable at compile time using the HIF_BLOCK_SIZE and is
+ *             negotiated with the target during initialization after the
+ *             dragon interrupts are enabled.
+ */
+#define HIF_BYTE_BASIS              0x00000040
+#define HIF_BLOCK_BASIS             0x00000080
+#define HIF_DMODE_MASK              (HIF_BYTE_BASIS | HIF_BLOCK_BASIS)
+
+/*
+ *     amode - This indicates if the address has to be incremented on dragon
+ *             after every read/write operation (HIF?FIXED_ADDRESS/
+ *             HIF_INCREMENTAL_ADDRESS).
+ */
+#define HIF_FIXED_ADDRESS           0x00000100
+#define HIF_INCREMENTAL_ADDRESS     0x00000200
+#define HIF_AMODE_MASK              (HIF_FIXED_ADDRESS | HIF_INCREMENTAL_ADDRESS)
+
+#define HIF_WR_ASYNC_BYTE_FIX   \
+    (HIF_WRITE | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_WR_ASYNC_BYTE_INC   \
+    (HIF_WRITE | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_WR_ASYNC_BLOCK_INC  \
+    (HIF_WRITE | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_WR_SYNC_BYTE_FIX    \
+    (HIF_WRITE | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_WR_SYNC_BYTE_INC    \
+    (HIF_WRITE | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_WR_SYNC_BLOCK_INC  \
+    (HIF_WRITE | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_SYNC_BYTE_INC    \
+    (HIF_READ | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_SYNC_BYTE_FIX    \
+    (HIF_READ | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_RD_ASYNC_BYTE_FIX   \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_RD_ASYNC_BLOCK_FIX  \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_FIXED_ADDRESS)
+#define HIF_RD_ASYNC_BYTE_INC   \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BYTE_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_ASYNC_BLOCK_INC  \
+    (HIF_READ | HIF_ASYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+#define HIF_RD_SYNC_BLOCK_INC  \
+    (HIF_READ | HIF_SYNCHRONOUS | HIF_EXTENDED_IO | HIF_BLOCK_BASIS | HIF_INCREMENTAL_ADDRESS)
+
+
+typedef enum {
+    HIF_DEVICE_POWER_STATE = 0,
+    HIF_DEVICE_GET_MBOX_BLOCK_SIZE,
+    HIF_DEVICE_GET_MBOX_ADDR,
+    HIF_DEVICE_GET_PENDING_EVENTS_FUNC,
+    HIF_DEVICE_GET_IRQ_PROC_MODE,
+    HIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC,
+} HIF_DEVICE_CONFIG_OPCODE;
+
+/*
+ * HIF CONFIGURE definitions:
+ *
+ *   HIF_DEVICE_GET_MBOX_BLOCK_SIZE
+ *   input : none
+ *   output : array of 4 A_UINT32s
+ *   notes: block size is returned for each mailbox (4)
+ *
+ *   HIF_DEVICE_GET_MBOX_ADDR
+ *   input : none
+ *   output : array of 4 A_UINT32
+ *   notes: address is returned for each mailbox (4) in the array
+ *
+ *   HIF_DEVICE_GET_PENDING_EVENTS_FUNC
+ *   input : none
+ *   output: HIF_PENDING_EVENTS_FUNC function pointer
+ *   notes: this is optional for the HIF layer, if the request is
+ *          not handled then it indicates that the upper layer can use
+ *          the standard device methods to get pending events (IRQs, mailbox messages etc..)
+ *          otherwise it can call the function pointer to check pending events.
+ *
+ *   HIF_DEVICE_GET_IRQ_PROC_MODE
+ *   input : none
+ *   output : HIF_DEVICE_IRQ_PROCESSING_MODE (interrupt processing mode)
+ *   note: the hif layer interfaces with the underlying OS-specific bus driver. The HIF
+ *         layer can report whether IRQ processing is requires synchronous behavior or
+ *         can be processed using asynchronous bus requests (typically faster).
+ *
+ *   HIF_DEVICE_GET_RECV_EVENT_MASK_UNMASK_FUNC
+ *   input :
+ *   output : HIF_MASK_UNMASK_RECV_EVENT function pointer
+ *   notes: this is optional for the HIF layer.  The HIF layer may require a special mechanism
+ *          to mask receive message events.  The upper layer can call this pointer when it needs
+ *          to mask/unmask receive events (in case it runs out of buffers).
+ *
+ *
+ */
+
+typedef enum {
+    HIF_DEVICE_IRQ_SYNC_ONLY,   /* for HIF implementations that require the DSR to process all
+                                   interrupts before returning */
+    HIF_DEVICE_IRQ_ASYNC_SYNC,  /* for HIF implementations that allow DSR to process interrupts
+                                   using ASYNC I/O (that is HIFAckInterrupt can be called at a
+                                   later time */
+} HIF_DEVICE_IRQ_PROCESSING_MODE;
+
+#define HIF_MAX_DEVICES                 1
+
+struct htc_callbacks {
+    A_UCHAR *name;
+    A_UINT32 id;
+    A_STATUS (* deviceInsertedHandler)(void *hif_handle);
+    A_STATUS (* deviceRemovedHandler)(void *htc_handle, A_STATUS status);
+    A_STATUS (* deviceSuspendHandler)(void *htc_handle);
+    A_STATUS (* deviceResumeHandler)(void *htc_handle);
+    A_STATUS (* deviceWakeupHandler)(void *htc_handle);
+    A_STATUS (* rwCompletionHandler)(void *context, A_STATUS status);
+    A_STATUS (* dsrHandler)(void *htc_handle);
+};
+
+
+#define HIF_OTHER_EVENTS     (1 << 0)   /* other interrupts (non-Recv) are pending, host
+                                           needs to read the register table to figure out what */
+#define HIF_RECV_MSG_AVAIL   (1 << 1)   /* pending recv packet */
+
+typedef struct _HIF_PENDING_EVENTS_INFO {
+    A_UINT32 Events;
+    A_UINT32 LookAhead;
+} HIF_PENDING_EVENTS_INFO;
+
+    /* function to get pending events , some HIF modules use special mechanisms
+     * to detect packet available and other interrupts */
+typedef A_STATUS ( *HIF_PENDING_EVENTS_FUNC)(HIF_DEVICE              *device,
+                                             HIF_PENDING_EVENTS_INFO *pEvents,
+                                             void                    *AsyncContext);
+
+#define HIF_MASK_RECV    TRUE
+#define HIF_UNMASK_RECV  FALSE
+    /* function to mask recv events */
+typedef A_STATUS ( *HIF_MASK_UNMASK_RECV_EVENT)(HIF_DEVICE  *device,
+                                                A_BOOL      Mask,
+                                                void        *AsyncContext);
+
+
+/*
+ * This API is used by the HTC layer to initialize the HIF layer and to
+ * register different callback routines. Support for following events has
+ * been captured - DSR, Read/Write completion, Device insertion/removal,
+ * Device suspension/resumption/wakeup. In addition to this, the API is
+ * also used to register the name and the revision of the chip. The latter
+ * can be used to verify the revision of the chip read from the device
+ * before reporting it to HTC.
+ */
+int HIFInit(HTC_CALLBACKS *callbacks);
+
+/*
+ * This API is used to provide the read/write interface over the specific bus
+ * interface.
+ * address - Starting address in the dragon's address space. For mailbox
+ *           writes, it refers to the start of the mbox boundary. It should
+ *           be ensured that the last byte falls on the mailbox's EOM. For
+ *           mailbox reads, it refers to the end of the mbox boundary.
+ * buffer - Pointer to the buffer containg the data to be transmitted or
+ *          received.
+ * length - Amount of data to be transmitted or received.
+ * request - Characterizes the attributes of the command.
+ */
+A_STATUS
+HIFReadWrite(HIF_DEVICE    *device,
+             A_UINT32       address,
+             A_UCHAR       *buffer,
+             A_UINT32       length,
+             A_UINT32       request,
+             void          *context);
+
+/*
+ * This can be initiated from the unload driver context ie when the HTCShutdown
+ * routine is called.
+ */
+void HIFShutDownDevice(HIF_DEVICE *device);
+
+/*
+ * This should translate to an acknowledgment to the bus driver indicating that
+ * the previous interrupt request has been serviced and the all the relevant
+ * sources have been cleared. HTC is ready to process more interrupts.
+ * This should prevent the bus driver from raising an interrupt unless the
+ * previous one has been serviced and acknowledged using the previous API.
+ */
+void HIFAckInterrupt(HIF_DEVICE *device);
+
+void HIFMaskInterrupt(HIF_DEVICE *device);
+
+void HIFUnMaskInterrupt(HIF_DEVICE *device);
+
+/*
+ * This set of functions are to be used by the bus driver to notify
+ * the HIF module about various events.
+ * These are not implemented if the bus driver provides an alternative
+ * way for this notification though callbacks for instance.
+ */
+int HIFInsertEventNotify(void);
+
+int HIFRemoveEventNotify(void);
+
+int HIFIRQEventNotify(void);
+
+int HIFRWCompleteEventNotify(void);
+
+/*
+ * This function associates a opaque handle with the HIF layer
+ * to be used in communication with upper layer i.e. HTC.
+ * This would normaly be a pointer to htc_target data structure.
+ */
+void HIFSetHandle(void *hif_handle, void *handle);
+
+A_STATUS
+HIFConfigureDevice(HIF_DEVICE *device, HIF_DEVICE_CONFIG_OPCODE opcode,
+                   void *config, A_UINT32 configLen);
+
+
+struct device;
+struct device*
+HIFGetOSDevice(HIF_DEVICE *device);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HIF_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/host_version.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/host_version.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/host_version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/host_version.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,49 @@
+#ifndef _HOST_VERSION_H_
+#define _HOST_VERSION_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains version information for the sample host driver for the
+ * AR6000 chip
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/host_version.h#2 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <AR6K_version.h>
+
+/*
+ * The version number is made up of major, minor, patch and build
+ * numbers. These are 16 bit numbers.  The build and release script will
+ * set the build number using a Perforce counter.  Here the build number is
+ * set to 9999 so that builds done without the build-release script are easily
+ * identifiable.
+ */
+
+#define ATH_SW_VER_MAJOR      __VER_MAJOR_
+#define ATH_SW_VER_MINOR      __VER_MINOR_
+#define ATH_SW_VER_PATCH      __VER_PATCH_
+#define ATH_SW_VER_BUILD 9999
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HOST_VERSION_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,439 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef _HTC_API_H_
+#define _HTC_API_H_
+
+#include <htc.h>
+#include <htc_services.h>
+#include "htc_packet.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* TODO.. for BMI */
+#define ENDPOINT1 0
+// TODO -remove me, but we have to fix BMI first
+#define HTC_MAILBOX_NUM_MAX    4
+
+
+/* ------ Endpoint IDS ------ */
+typedef enum
+{
+    ENDPOINT_UNUSED = -1,
+    ENDPOINT_0 = 0,
+    ENDPOINT_1 = 1,
+    ENDPOINT_2 = 2,
+    ENDPOINT_3,
+    ENDPOINT_4,
+    ENDPOINT_5,
+    ENDPOINT_6,
+    ENDPOINT_7,
+    ENDPOINT_8,
+    ENDPOINT_MAX,
+} HTC_ENDPOINT_ID;
+
+/* this is the amount of header room required by users of HTC */
+#define HTC_HEADER_LEN         HTC_HDR_LENGTH
+
+typedef void *HTC_HANDLE;
+
+typedef A_UINT16 HTC_SERVICE_ID;
+
+typedef struct _HTC_INIT_INFO {
+    void   (*AddInstance)(HTC_HANDLE);
+    void   (*DeleteInstance)(void *Instance);
+    void   (*TargetFailure)(void *Instance, A_STATUS Status);
+} HTC_INIT_INFO;
+
+/* per service connection send completion */
+typedef void   (*HTC_EP_SEND_PKT_COMPLETE)(void *,HTC_PACKET *);
+/* per service connection pkt received */
+typedef void   (*HTC_EP_RECV_PKT)(void *,HTC_PACKET *);
+
+/* Optional per service connection receive buffer re-fill callback,
+ * On some OSes (like Linux) packets are allocated from a global pool and indicated up
+ * to the network stack.  The driver never gets the packets back from the OS.  For these OSes
+ * a refill callback can be used to allocate and re-queue buffers into HTC.
+ *
+ * On other OSes, the network stack can call into the driver's OS-specifc "return_packet" handler and
+ * the driver can re-queue these buffers into HTC. In this regard a refill callback is
+ * unnecessary */
+typedef void   (*HTC_EP_RECV_REFILL)(void *, HTC_ENDPOINT_ID Endpoint);
+
+/* Optional per service connection callback when a send queue is full. This can occur if the
+ * host continues queueing up TX packets faster than credits can arrive
+ * To prevent the host (on some Oses like Linux) from continuously queueing packets
+ * and consuming resources, this callback is provided so that that the host
+ * can disable TX in the subsystem (i.e. network stack)
+ * Other OSes require a "per-packet" indication_RAW_STREAM_NUM_MAX for each completed TX packet, this
+ * closed loop mechanism will prevent the network stack from overunning the NIC */
+typedef void (*HTC_EP_SEND_QUEUE_FULL)(void *, HTC_ENDPOINT_ID Endpoint);
+/* Optional per service connection callback when a send queue is available for receive new packet. */
+typedef void (*HTC_EP_SEND_QUEUE_AVAIL)(void *, HTC_ENDPOINT_ID Endpoint);
+
+typedef struct _HTC_EP_CALLBACKS {
+    void                     *pContext;     /* context for each callback */
+    HTC_EP_SEND_PKT_COMPLETE EpTxComplete;  /* tx completion callback for connected endpoint */
+    HTC_EP_RECV_PKT          EpRecv;        /* receive callback for connected endpoint */
+    HTC_EP_RECV_REFILL       EpRecvRefill;  /* OPTIONAL receive re-fill callback for connected endpoint */
+    HTC_EP_SEND_QUEUE_FULL   EpSendFull;    /* OPTIONAL send full callback */
+    HTC_EP_SEND_QUEUE_AVAIL  EpSendAvail;    /* OPTIONAL send available callback */
+} HTC_EP_CALLBACKS;
+
+/* service connection information */
+typedef struct _HTC_SERVICE_CONNECT_REQ {
+    HTC_SERVICE_ID   ServiceID;                 /* service ID to connect to */
+    A_UINT16         ConnectionFlags;           /* connection flags, see htc protocol definition */
+    A_UINT8         *pMetaData;                 /* ptr to optional service-specific meta-data */
+    A_UINT8          MetaDataLength;            /* optional meta data length */
+    HTC_EP_CALLBACKS EpCallbacks;               /* endpoint callbacks */
+    int              MaxSendQueueDepth;         /* maximum depth of any send queue */
+} HTC_SERVICE_CONNECT_REQ;
+
+/* service connection response information */
+typedef struct _HTC_SERVICE_CONNECT_RESP {
+    A_UINT8     *pMetaData;             /* caller supplied buffer to optional meta-data */
+    A_UINT8     BufferLength;           /* length of caller supplied buffer */
+    A_UINT8     ActualLength;           /* actual length of meta data */
+    HTC_ENDPOINT_ID Endpoint;           /* endpoint to communicate over */
+    int         MaxMsgLength;           /* max length of all messages over this endpoint */
+    A_UINT8     ConnectRespCode;        /* connect response code from target */
+} HTC_SERVICE_CONNECT_RESP;
+
+/* endpoint distribution structure */
+typedef struct _HTC_ENDPOINT_CREDIT_DIST {
+    struct _HTC_ENDPOINT_CREDIT_DIST *pNext;
+    struct _HTC_ENDPOINT_CREDIT_DIST *pPrev;
+    HTC_SERVICE_ID      ServiceID;          /* Service ID (set by HTC) */
+    HTC_ENDPOINT_ID     Endpoint;           /* endpoint for this distribution struct (set by HTC) */
+    A_UINT32            DistFlags;          /* distribution flags, distribution function can
+                                               set default activity using SET_EP_ACTIVE() macro */
+    int                 TxCreditsNorm;      /* credits for normal operation, anything above this
+                                               indicates the endpoint is over-subscribed, this field
+                                               is only relevant to the credit distribution function */
+    int                 TxCreditsMin;       /* floor for credit distribution, this field is
+                                               only relevant to the credit distribution function */
+    int                 TxCreditsAssigned;  /* number of credits assigned to this EP, this field
+                                               is only relevant to the credit dist function */
+    int                 TxCredits;          /* current credits available, this field is used by
+                                               HTC to determine whether a message can be sent or
+                                               must be queued */
+    int                 TxCreditsToDist;    /* pending credits to distribute on this endpoint, this
+                                               is set by HTC when credit reports arrive.
+                                               The credit distribution functions sets this to zero
+                                               when it distributes the credits */
+    int                 TxCreditsSeek;      /* this is the number of credits that the current pending TX
+                                               packet needs to transmit.  This is set by HTC when
+                                               and endpoint needs credits in order to transmit */
+    int                 TxCreditSize;       /* size in bytes of each credit (set by HTC) */
+    int                 TxCreditsPerMaxMsg; /* credits required for a maximum sized messages (set by HTC) */
+    void                *pHTCReserved;      /* reserved for HTC use */
+} HTC_ENDPOINT_CREDIT_DIST;
+
+#define HTC_EP_ACTIVE                            (1 << 31)
+
+/* macro to check if an endpoint has gone active, useful for credit
+ * distributions */
+#define IS_EP_ACTIVE(epDist)  ((epDist)->DistFlags & HTC_EP_ACTIVE)
+#define SET_EP_ACTIVE(epDist) (epDist)->DistFlags |= HTC_EP_ACTIVE
+
+    /* credit distibution code that is passed into the distrbution function,
+     * there are mandatory and optional codes that must be handled */
+typedef enum _HTC_CREDIT_DIST_REASON {
+    HTC_CREDIT_DIST_SEND_COMPLETE = 0,     /* credits available as a result of completed
+                                              send operations (MANDATORY) resulting in credit reports */
+    HTC_CREDIT_DIST_ACTIVITY_CHANGE = 1,   /* a change in endpoint activity occured (OPTIONAL) */
+    HTC_CREDIT_DIST_SEEK_CREDITS,          /* an endpoint needs to "seek" credits (OPTIONAL) */
+    HTC_DUMP_CREDIT_STATE                  /* for debugging, dump any state information that is kept by
+                                              the distribution function */
+} HTC_CREDIT_DIST_REASON;
+
+typedef void (*HTC_CREDIT_DIST_CALLBACK)(void                     *Context,
+                                         HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                                         HTC_CREDIT_DIST_REASON   Reason);
+
+typedef void (*HTC_CREDIT_INIT_CALLBACK)(void *Context,
+                                         HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                                         int                      TotalCredits);
+
+    /* endpoint statistics action */
+typedef enum _HTC_ENDPOINT_STAT_ACTION {
+    HTC_EP_STAT_SAMPLE = 0,                /* only read statistics */
+    HTC_EP_STAT_SAMPLE_AND_CLEAR = 1,      /* sample and immediately clear statistics */
+    HTC_EP_STAT_CLEAR                      /* clear only */
+} HTC_ENDPOINT_STAT_ACTION;
+
+    /* endpoint statistics */
+typedef struct _HTC_ENDPOINT_STATS {
+    A_UINT32  TxCreditLowIndications;  /* number of times the host set the credit-low flag in a send message on
+                                        this endpoint */
+    A_UINT32  TxIssued;               /* running count of TX packets issued */
+    A_UINT32  TxCreditRpts;           /* running count of total credit reports received for this endpoint */
+    A_UINT32  TxCreditRptsFromRx;
+    A_UINT32  TxCreditRptsFromOther;
+    A_UINT32  TxCreditRptsFromEp0;
+    A_UINT32  TxCreditsFromRx;        /* count of credits received via Rx packets on this endpoint */
+    A_UINT32  TxCreditsFromOther;     /* count of credits received via another endpoint */
+    A_UINT32  TxCreditsFromEp0;       /* count of credits received via another endpoint */
+    A_UINT32  TxCreditsConsummed;     /* count of consummed credits */
+    A_UINT32  TxCreditsReturned;      /* count of credits returned */
+    A_UINT32  RxReceived;             /* count of RX packets received */
+    A_UINT32  RxLookAheads;           /* count of lookahead records
+                                         found in messages received on this endpoint */
+} HTC_ENDPOINT_STATS;
+
+/* ------ Function Prototypes ------ */
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Initialize HTC
+  @function name: HTCInit
+  @input:  pInfo - initialization information
+  @output:
+  @return: A_OK on success
+  @notes: The caller initializes global HTC state and registers various instance
+          notification callbacks (see HTC_INIT_INFO).
+
+  @example:
+  @see also: HTCShutdown
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCInit(HTC_INIT_INFO *pInfo);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Get the underlying HIF device handle
+  @function name: HTCGetHifDevice
+  @input:  HTCHandle - handle passed into the AddInstance callback
+  @output:
+  @return: opaque HIF device handle usable in HIF API calls.
+  @notes:
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void       *HTCGetHifDevice(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Set the associated instance for the HTC handle
+  @function name: HTCSetInstance
+  @input:  HTCHandle - handle passed into the AddInstance callback
+           Instance - caller supplied instance object
+  @output:
+  @return:
+  @notes:  Caller must set the instance information for the HTC handle in order to receive
+           notifications for instance deletion (DeleteInstance callback is called) and for target
+           failure notification.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCSetInstance(HTC_HANDLE HTCHandle, void *Instance);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Set credit distribution parameters
+  @function name: HTCSetCreditDistribution
+  @input:  HTCHandle - HTC handle
+           pCreditDistCont - caller supplied context to pass into distribution functions
+           CreditDistFunc - Distribution function callback
+           CreditDistInit - Credit Distribution initialization callback
+           ServicePriorityOrder - Array containing list of service IDs, lowest index is highest
+                                  priority
+           ListLength - number of elements in ServicePriorityOrder
+  @output:
+  @return:
+  @notes:  The user can set a custom credit distribution function to handle special requirements
+           for each endpoint.  A default credit distribution routine can be used by setting
+           CreditInitFunc to NULL.  The default credit distribution is only provided for simple
+           "fair" credit distribution without regard to any prioritization.
+
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCSetCreditDistribution(HTC_HANDLE               HTCHandle,
+                                     void                     *pCreditDistContext,
+                                     HTC_CREDIT_DIST_CALLBACK CreditDistFunc,
+                                     HTC_CREDIT_INIT_CALLBACK CreditInitFunc,
+                                     HTC_SERVICE_ID           ServicePriorityOrder[],
+                                     int                      ListLength);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Wait for the target to indicate the HTC layer is ready
+  @function name: HTCWaitTarget
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes:  This API blocks until the target responds with an HTC ready message.
+           The caller should not connect services until the target has indicated it is
+           ready.
+  @example:
+  @see also: HTCConnectService
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCWaitTarget(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Start target service communications
+  @function name: HTCStart
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes: This API indicates to the target that the service connection phase is complete
+          and the target can freely start all connected services.  This API should only be
+          called AFTER all service connections have been made.  TCStart will issue a
+          SETUP_COMPLETE message to the target to indicate that all service connections
+          have been made and the target can start communicating over the endpoints.
+  @example:
+  @see also: HTCConnectService
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCStart(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Add receive packet to HTC
+  @function name: HTCAddReceivePkt
+  @input:  HTCHandle - HTC handle
+           pPacket - HTC receive packet to add
+  @output:
+  @return: A_OK on success
+  @notes:  user must supply HTC packets for capturing incomming HTC frames.  The caller
+           must initialize each HTC packet using the SET_HTC_PACKET_INFO_RX_REFILL()
+           macro.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCAddReceivePkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Connect to an HTC service
+  @function name: HTCConnectService
+  @input:  HTCHandle - HTC handle
+           pReq - connection details
+  @output: pResp - connection response
+  @return:
+  @notes:  Service connections must be performed before HTCStart.  User provides callback handlers
+           for various endpoint events.
+  @example:
+  @see also: HTCStart
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCConnectService(HTC_HANDLE HTCHandle,
+                              HTC_SERVICE_CONNECT_REQ  *pReq,
+                              HTC_SERVICE_CONNECT_RESP *pResp);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Send an HTC packet
+  @function name: HTCSendPkt
+  @input:  HTCHandle - HTC handle
+           pPacket - packet to send
+  @output:
+  @return: A_OK
+  @notes:  Caller must initialize packet using SET_HTC_PACKET_INFO_TX() macro.
+           This interface is fully asynchronous.  On error, HTC SendPkt will
+           call the registered Endpoint callback to cleanup the packet.
+  @example:
+  @see also: HTCFlushEndpoint
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_STATUS    HTCSendPkt(HTC_HANDLE HTCHandle, HTC_PACKET *pPacket);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Stop HTC service communications
+  @function name: HTCStop
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes: HTC communications is halted.  All receive and pending TX packets will
+          be flushed.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCStop(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Shutdown HTC
+  @function name: HTCShutdown
+  @input:
+  @output:
+  @return:
+  @notes:  This cleans up all resources allocated by HTCInit().
+  @example:
+  @see also: HTCInit
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCShutDown(void);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Flush pending TX packets
+  @function name: HTCFlushEndpoint
+  @input:  HTCHandle - HTC handle
+           Endpoint - Endpoint to flush
+           Tag - flush tag
+  @output:
+  @return:
+  @notes:  The Tag parameter is used to selectively flush packets with matching tags.
+           The value of 0 forces all packets to be flush regardless of tag.
+  @example:
+  @see also: HTCSendPkt
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCFlushEndpoint(HTC_HANDLE HTCHandle, HTC_ENDPOINT_ID Endpoint, HTC_TX_TAG Tag);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Dump credit distribution state
+  @function name: HTCDumpCreditStates
+  @input:  HTCHandle - HTC handle
+  @output:
+  @return:
+  @notes:  This dumps all credit distribution information to the debugger
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCDumpCreditStates(HTC_HANDLE HTCHandle);
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Indicate a traffic activity change on an endpoint
+  @function name: HTCIndicateActivityChange
+  @input:  HTCHandle - HTC handle
+           Endpoint - endpoint in which activity has changed
+           Active - TRUE if active, FALSE if it has become inactive
+  @output:
+  @return:
+  @notes:  This triggers the registered credit distribution function to
+           re-adjust credits for active/inactive endpoints.
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+void        HTCIndicateActivityChange(HTC_HANDLE      HTCHandle,
+                                      HTC_ENDPOINT_ID Endpoint,
+                                      A_BOOL          Active);
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+  @desc: Get endpoint statistics
+  @function name: HTCGetEndpointStatistics
+  @input:  HTCHandle - HTC handle
+           Endpoint - Endpoint identifier
+           Action - action to take with statistics
+  @output:
+           pStats - statistics that were sampled (can be NULL if Action is HTC_EP_STAT_CLEAR)
+
+  @return: TRUE if statistics profiling is enabled, otherwise FALSE.
+
+  @notes:  Statistics is a compile-time option and this function may return FALSE
+           if HTC is not compiled with profiling.
+
+           The caller can specify the statistic "action" to take when sampling
+           the statistics.  This includes:
+
+           HTC_EP_STAT_SAMPLE: The pStats structure is filled with the current values.
+           HTC_EP_STAT_SAMPLE_AND_CLEAR: The structure is filled and the current statistics
+                             are cleared.
+           HTC_EP_STAT_CLEA : the statistics are cleared, the called can pass a NULL value for
+                   pStats
+
+  @example:
+  @see also:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
+A_BOOL       HTCGetEndpointStatistics(HTC_HANDLE               HTCHandle,
+                                      HTC_ENDPOINT_ID          Endpoint,
+                                      HTC_ENDPOINT_STAT_ACTION Action,
+                                      HTC_ENDPOINT_STATS       *pStats);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HTC_API_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,190 @@
+/*
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+
+#ifndef __HTC_H__
+#define __HTC_H__
+
+#ifndef ATH_TARGET
+#include "athstartpack.h"
+#endif
+
+#define A_OFFSETOF(type,field) (int)(&(((type *)NULL)->field))
+
+#define ASSEMBLE_UNALIGNED_UINT16(p,highbyte,lowbyte) \
+        (((A_UINT16)(((A_UINT8 *)(p))[(highbyte)])) << 8 | (A_UINT16)(((A_UINT8 *)(p))[(lowbyte)]))
+
+/* alignment independent macros (little-endian) to fetch UINT16s or UINT8s from a
+ * structure using only the type and field name.
+ * Use these macros if there is the potential for unaligned buffer accesses. */
+#define A_GET_UINT16_FIELD(p,type,field) \
+    ASSEMBLE_UNALIGNED_UINT16(p,\
+                              A_OFFSETOF(type,field) + 1, \
+                              A_OFFSETOF(type,field))
+
+#define A_SET_UINT16_FIELD(p,type,field,value) \
+{                                              \
+    ((A_UINT8 *)(p))[A_OFFSETOF(type,field)] = (A_UINT8)(value);        \
+    ((A_UINT8 *)(p))[A_OFFSETOF(type,field) + 1] = (A_UINT8)((value) >> 8); \
+}
+
+#define A_GET_UINT8_FIELD(p,type,field) \
+            ((A_UINT8 *)(p))[A_OFFSETOF(type,field)]
+
+#define A_SET_UINT8_FIELD(p,type,field,value) \
+    ((A_UINT8 *)(p))[A_OFFSETOF(type,field)] = (value)
+
+/****** DANGER DANGER ***************
+ *
+ *   The frame header length and message formats defined herein were
+ *   selected to accommodate optimal alignment for target processing.  This reduces code
+ *   size and improves performance.
+ *
+ *   Any changes to the header length may alter the alignment and cause exceptions
+ *   on the target. When adding to the message structures insure that fields are
+ *   properly aligned.
+ *
+ */
+
+/* HTC frame header */
+typedef PREPACK struct _HTC_FRAME_HDR{
+        /* do not remove or re-arrange these fields, these are minimally required
+         * to take advantage of 4-byte lookaheads in some hardware implementations */
+    A_UINT8   EndpointID;
+    A_UINT8   Flags;
+    A_UINT16  PayloadLen;       /* length of data (including trailer) that follows the header */
+
+    /***** end of 4-byte lookahead ****/
+
+    A_UINT8   ControlBytes[2];
+
+    /* message payload starts after the header */
+
+} POSTPACK HTC_FRAME_HDR;
+
+/* frame header flags */
+#define HTC_FLAGS_NEED_CREDIT_UPDATE (1 << 0)
+#define HTC_FLAGS_RECV_TRAILER       (1 << 1)
+
+
+#define HTC_HDR_LENGTH  (sizeof(HTC_FRAME_HDR))
+#define HTC_MAX_TRAILER_LENGTH   255
+#define HTC_MAX_PAYLOAD_LENGTH   (2048 - sizeof(HTC_FRAME_HDR))
+
+/* HTC control message IDs */
+typedef enum {
+    HTC_MSG_READY_ID = 1,
+    HTC_MSG_CONNECT_SERVICE_ID = 2,
+    HTC_MSG_CONNECT_SERVICE_RESPONSE_ID = 3,
+    HTC_MSG_SETUP_COMPLETE_ID = 4,
+} HTC_MSG_IDS;
+
+#define HTC_MAX_CONTROL_MESSAGE_LENGTH  256
+
+/* base message ID header */
+typedef PREPACK struct {
+    A_UINT16 MessageID;
+} POSTPACK HTC_UNKNOWN_MSG;
+
+/* HTC ready message
+ * direction : target-to-host  */
+typedef PREPACK struct {
+    A_UINT16  MessageID;    /* ID */
+    A_UINT16  CreditCount;  /* number of credits the target can offer */
+    A_UINT16  CreditSize;   /* size of each credit */
+    A_UINT8   MaxEndpoints; /* maximum number of endpoints the target has resources for */
+    A_UINT8   _Pad1;
+} POSTPACK HTC_READY_MSG;
+
+#define HTC_SERVICE_META_DATA_MAX_LENGTH 128
+
+/* connect service
+ * direction : host-to-target */
+typedef PREPACK struct {
+    A_UINT16  MessageID;
+    A_UINT16  ServiceID;           /* service ID of the service to connect to */
+    A_UINT16  ConnectionFlags;     /* connection flags */
+
+#define HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE (1 << 2)  /* reduce credit dribbling when
+                                                             the host needs credits */
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK             (0x3)
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_FOURTH        0x0
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF          0x1
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_THREE_FOURTHS     0x2
+#define HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_UNITY             0x3
+
+    A_UINT8   ServiceMetaLength;   /* length of meta data that follows */
+    A_UINT8   _Pad1;
+
+    /* service-specific meta data starts after the header */
+
+} POSTPACK HTC_CONNECT_SERVICE_MSG;
+
+/* connect response
+ * direction : target-to-host */
+typedef PREPACK struct {
+    A_UINT16  MessageID;
+    A_UINT16  ServiceID;            /* service ID that the connection request was made */
+    A_UINT8   Status;               /* service connection status */
+    A_UINT8   EndpointID;           /* assigned endpoint ID */
+    A_UINT16  MaxMsgSize;           /* maximum expected message size on this endpoint */
+    A_UINT8   ServiceMetaLength;    /* length of meta data that follows */
+    A_UINT8   _Pad1;
+
+    /* service-specific meta data starts after the header */
+
+} POSTPACK HTC_CONNECT_SERVICE_RESPONSE_MSG;
+
+typedef PREPACK struct {
+    A_UINT16  MessageID;
+    /* currently, no other fields */
+} POSTPACK HTC_SETUP_COMPLETE_MSG;
+
+
+/* connect response status codes */
+#define HTC_SERVICE_SUCCESS      0  /* success */
+#define HTC_SERVICE_NOT_FOUND    1  /* service could not be found */
+#define HTC_SERVICE_FAILED       2  /* specific service failed the connect */
+#define HTC_SERVICE_NO_RESOURCES 3  /* no resources (i.e. no more endpoints) */
+#define HTC_SERVICE_NO_MORE_EP   4  /* specific service is not allowing any more
+                                       endpoints */
+
+/* report record IDs */
+typedef enum {
+    HTC_RECORD_NULL  = 0,
+    HTC_RECORD_CREDITS   = 1,
+    HTC_RECORD_LOOKAHEAD = 2,
+} HTC_RPT_IDS;
+
+typedef PREPACK struct {
+    A_UINT8 RecordID;     /* Record ID */
+    A_UINT8 Length;       /* Length of record */
+} POSTPACK HTC_RECORD_HDR;
+
+typedef PREPACK struct {
+    A_UINT8 EndpointID;     /* Endpoint that owns these credits */
+    A_UINT8 Credits;        /* credits to report since last report */
+} POSTPACK HTC_CREDIT_REPORT;
+
+typedef PREPACK struct {
+    A_UINT8 PreValid;         /* pre valid guard */
+    A_UINT8 LookAhead[4];     /* 4 byte lookahead */
+    A_UINT8 PostValid;        /* post valid guard */
+
+   /* NOTE: the LookAhead array is guarded by a PreValid and Post Valid guard bytes.
+    * The PreValid bytes must equal the inverse of the PostValid byte */
+
+} POSTPACK HTC_LOOKAHEAD_REPORT;
+
+#ifndef ATH_TARGET
+#include "athendpack.h"
+#endif
+
+
+#endif /* __HTC_H__ */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc_packet.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc_packet.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc_packet.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc_packet.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,138 @@
+/*
+ *
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifndef HTC_PACKET_H_
+#define HTC_PACKET_H_
+
+
+#include "dl_list.h"
+
+struct _HTC_PACKET;
+
+typedef void (* HTC_PACKET_COMPLETION)(void *,struct _HTC_PACKET *);
+
+typedef A_UINT16 HTC_TX_TAG;
+
+typedef struct _HTC_TX_PACKET_INFO {
+    HTC_TX_TAG    Tag;            /* tag used to selective flush packets */
+} HTC_TX_PACKET_INFO;
+
+#define HTC_TX_PACKET_TAG_ALL          0    /* a tag of zero is reserved and used to flush ALL packets */
+#define HTC_TX_PACKET_TAG_INTERNAL     1                                /* internal tags start here */
+#define HTC_TX_PACKET_TAG_USER_DEFINED (HTC_TX_PACKET_TAG_INTERNAL + 9) /* user-defined tags start here */
+
+typedef struct _HTC_RX_PACKET_INFO {
+    A_UINT32    Unused;          /* for future use and to make compilers happy */
+} HTC_RX_PACKET_INFO;
+
+/* wrapper around endpoint-specific packets */
+typedef struct _HTC_PACKET {
+    DL_LIST         ListLink;       /* double link */
+    void            *pPktContext;   /* caller's per packet specific context */
+
+    A_UINT8         *pBufferStart;  /* the true buffer start , the caller can
+                                       store the real buffer start here.  In
+                                       receive callbacks, the HTC layer sets pBuffer
+                                       to the start of the payload past the header. This
+                                       field allows the caller to reset pBuffer when it
+                                       recycles receive packets back to HTC */
+    /*
+     * Pointer to the start of the buffer. In the transmit
+     * direction this points to the start of the payload. In the
+     * receive direction, however, the buffer when queued up
+     * points to the start of the HTC header but when returned
+     * to the caller points to the start of the payload
+     */
+    A_UINT8         *pBuffer;       /* payload start (RX/TX) */
+    A_UINT32        BufferLength;   /* length of buffer */
+    A_UINT32        ActualLength;   /* actual length of payload */
+    int             Endpoint;       /* endpoint that this packet was sent/recv'd from */
+    A_STATUS        Status;         /* completion status */
+    union {
+        HTC_TX_PACKET_INFO  AsTx;   /* Tx Packet specific info */
+        HTC_RX_PACKET_INFO  AsRx;   /* Rx Packet specific info */
+    } PktInfo;
+
+    /* the following fields are for internal HTC use */
+    HTC_PACKET_COMPLETION Completion;   /* completion */
+    void                  *pContext;    /* HTC private completion context */
+    A_UINT32              HTCReserved;  /* reserved */
+} HTC_PACKET;
+
+
+
+#define COMPLETE_HTC_PACKET(p,status)        \
+{                                            \
+    (p)->Status = (status);                  \
+    (p)->Completion((p)->pContext,(p));      \
+}
+
+#define INIT_HTC_PACKET_INFO(p,b,len)             \
+{                                                 \
+    (p)->pBufferStart = (b);                      \
+    (p)->BufferLength = (len);                    \
+}
+
+/* macro to set an initial RX packet for refilling HTC */
+#define SET_HTC_PACKET_INFO_RX_REFILL(p,c,b,len,ep) \
+{                                                 \
+    (p)->pPktContext = (c);                       \
+    (p)->pBuffer = (b);                           \
+    (p)->pBufferStart = (b);                      \
+    (p)->BufferLength = (len);                    \
+    (p)->Endpoint = (ep);                         \
+}
+
+/* fast macro to recycle an RX packet that will be re-queued to HTC */
+#define HTC_PACKET_RESET_RX(p)              \
+    (p)->pBuffer = (p)->pBufferStart
+
+/* macro to set packet parameters for TX */
+#define SET_HTC_PACKET_INFO_TX(p,c,b,len,ep,tag)  \
+{                                                 \
+    (p)->pPktContext = (c);                       \
+    (p)->pBuffer = (b);                           \
+    (p)->ActualLength = (len);                    \
+    (p)->Endpoint = (ep);                         \
+    (p)->PktInfo.AsTx.Tag = (tag);                \
+}
+
+/* HTC Packet Queueing Macros */
+typedef DL_LIST HTC_PACKET_QUEUE;
+/* initialize queue */
+#define INIT_HTC_PACKET_QUEUE(pQ) DL_LIST_INIT((pQ))
+/* enqueue HTC packet to the tail of the queue */
+#define HTC_PACKET_ENQUEUE(pQ,p)  DL_ListInsertTail((pQ),&(p)->ListLink)
+/* test if a queue is empty */
+#define HTC_QUEUE_EMPTY(pQ)       DL_LIST_IS_EMPTY((pQ))
+/* get packet at head without removing it */
+#define HTC_GET_PKT_AT_HEAD(pQ)   A_CONTAINING_STRUCT((DL_LIST_GET_ITEM_AT_HEAD(pQ)),HTC_PACKET,ListLink);
+/* remove a packet from the current list it is linked to */
+#define HTC_PACKET_REMOVE(p)      DL_ListRemove(&(p)->ListLink)
+
+/* dequeue an HTC packet from the head of the queue */
+static INLINE HTC_PACKET *HTC_PACKET_DEQUEUE(HTC_PACKET_QUEUE *queue) {
+    DL_LIST    *pItem = DL_ListRemoveItemFromHead(queue);
+    if (pItem != NULL) {
+        return A_CONTAINING_STRUCT(pItem, HTC_PACKET, ListLink);
+    }
+    return NULL;
+}
+
+#endif /*HTC_PACKET_H_*/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc_services.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc_services.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/htc_services.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/htc_services.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __HTC_SERVICES_H__
+#define __HTC_SERVICES_H__
+
+/* Current service IDs */
+
+typedef enum {
+    RSVD_SERVICE_GROUP  = 0,
+    WMI_SERVICE_GROUP   = 1,
+
+    HTC_TEST_GROUP = 254,
+    HTC_SERVICE_GROUP_LAST = 255
+}HTC_SERVICE_GROUP_IDS;
+
+#define MAKE_SERVICE_ID(group,index) \
+            (int)(((int)group << 8) | (int)(index))
+
+/* NOTE: service ID of 0x0000 is reserved and should never be used */
+#define HTC_CTRL_RSVD_SVC MAKE_SERVICE_ID(RSVD_SERVICE_GROUP,1)
+#define WMI_CONTROL_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,0)
+#define WMI_DATA_BE_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,1)
+#define WMI_DATA_BK_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,2)
+#define WMI_DATA_VI_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,3)
+#define WMI_DATA_VO_SVC   MAKE_SERVICE_ID(WMI_SERVICE_GROUP,4)
+#define WMI_MAX_SERVICES  5
+
+/* raw stream service (i.e. flash, tcmd, calibration apps) */
+#define HTC_RAW_STREAMS_SVC MAKE_SERVICE_ID(HTC_TEST_GROUP,0)
+
+#endif /*HTC_SERVICES_H_*/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/ieee80211.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ieee80211.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/ieee80211.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ieee80211.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,342 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * Copyright (c) 2006 Atheros Communications, Inc.
+ *
+ * Wireless Network driver for Atheros AR6001
+ * All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _NET80211_IEEE80211_H_
+#define _NET80211_IEEE80211_H_
+
+#include "athstartpack.h"
+
+/*
+ * 802.11 protocol definitions.
+ */
+
+#define IEEE80211_ADDR_LEN  6       /* size of 802.11 address */
+/* is 802.11 address multicast/broadcast? */
+#define IEEE80211_IS_MULTICAST(_a)  (*(_a) & 0x01)
+#define IEEE80211_ADDR_EQ(addr1, addr2)     \
+    (A_MEMCMP(addr1, addr2, IEEE80211_ADDR_LEN) == 0)
+
+#define IEEE80211_KEYBUF_SIZE 16
+#define IEEE80211_MICBUF_SIZE (8+8)  /* space for both tx and rx */
+
+/*
+ * NB: these values are ordered carefully; there are lots of
+ * of implications in any reordering.  In particular beware
+ * that 4 is not used to avoid conflicting with IEEE80211_F_PRIVACY.
+ */
+#define IEEE80211_CIPHER_WEP            0
+#define IEEE80211_CIPHER_TKIP           1
+#define IEEE80211_CIPHER_AES_OCB        2
+#define IEEE80211_CIPHER_AES_CCM        3
+#define IEEE80211_CIPHER_CKIP           5
+#define IEEE80211_CIPHER_CCKM_KRK       6
+#define IEEE80211_CIPHER_NONE           7       /* pseudo value */
+
+#define IEEE80211_CIPHER_MAX            (IEEE80211_CIPHER_NONE+1)
+
+#define IEEE80211_IS_VALID_WEP_CIPHER_LEN(len) \
+        (((len) == 5) || ((len) == 13) || ((len) == 16))
+
+
+
+/*
+ * generic definitions for IEEE 802.11 frames
+ */
+PREPACK struct ieee80211_frame {
+    A_UINT8    i_fc[2];
+    A_UINT8    i_dur[2];
+    A_UINT8    i_addr1[IEEE80211_ADDR_LEN];
+    A_UINT8    i_addr2[IEEE80211_ADDR_LEN];
+    A_UINT8    i_addr3[IEEE80211_ADDR_LEN];
+    A_UINT8    i_seq[2];
+    /* possibly followed by addr4[IEEE80211_ADDR_LEN]; */
+    /* see below */
+} POSTPACK;
+
+#define IEEE80211_FC0_VERSION_MASK          0x03
+#define IEEE80211_FC0_VERSION_SHIFT         0
+#define IEEE80211_FC0_VERSION_0             0x00
+#define IEEE80211_FC0_TYPE_MASK             0x0c
+#define IEEE80211_FC0_TYPE_SHIFT            2
+#define IEEE80211_FC0_TYPE_MGT              0x00
+#define IEEE80211_FC0_TYPE_CTL              0x04
+#define IEEE80211_FC0_TYPE_DATA             0x08
+
+#define IEEE80211_FC0_SUBTYPE_MASK          0xf0
+#define IEEE80211_FC0_SUBTYPE_SHIFT         4
+/* for TYPE_MGT */
+#define IEEE80211_FC0_SUBTYPE_ASSOC_REQ     0x00
+#define IEEE80211_FC0_SUBTYPE_ASSOC_RESP    0x10
+#define IEEE80211_FC0_SUBTYPE_REASSOC_REQ   0x20
+#define IEEE80211_FC0_SUBTYPE_REASSOC_RESP  0x30
+#define IEEE80211_FC0_SUBTYPE_PROBE_REQ     0x40
+#define IEEE80211_FC0_SUBTYPE_PROBE_RESP    0x50
+#define IEEE80211_FC0_SUBTYPE_BEACON        0x80
+#define IEEE80211_FC0_SUBTYPE_ATIM          0x90
+#define IEEE80211_FC0_SUBTYPE_DISASSOC      0xa0
+#define IEEE80211_FC0_SUBTYPE_AUTH          0xb0
+#define IEEE80211_FC0_SUBTYPE_DEAUTH        0xc0
+/* for TYPE_CTL */
+#define IEEE80211_FC0_SUBTYPE_PS_POLL       0xa0
+#define IEEE80211_FC0_SUBTYPE_RTS           0xb0
+#define IEEE80211_FC0_SUBTYPE_CTS           0xc0
+#define IEEE80211_FC0_SUBTYPE_ACK           0xd0
+#define IEEE80211_FC0_SUBTYPE_CF_END        0xe0
+#define IEEE80211_FC0_SUBTYPE_CF_END_ACK    0xf0
+/* for TYPE_DATA (bit combination) */
+#define IEEE80211_FC0_SUBTYPE_DATA          0x00
+#define IEEE80211_FC0_SUBTYPE_CF_ACK        0x10
+#define IEEE80211_FC0_SUBTYPE_CF_POLL       0x20
+#define IEEE80211_FC0_SUBTYPE_CF_ACPL       0x30
+#define IEEE80211_FC0_SUBTYPE_NODATA        0x40
+#define IEEE80211_FC0_SUBTYPE_CFACK         0x50
+#define IEEE80211_FC0_SUBTYPE_CFPOLL        0x60
+#define IEEE80211_FC0_SUBTYPE_CF_ACK_CF_ACK 0x70
+#define IEEE80211_FC0_SUBTYPE_QOS           0x80
+#define IEEE80211_FC0_SUBTYPE_QOS_NULL      0xc0
+
+#define IEEE80211_FC1_DIR_MASK              0x03
+#define IEEE80211_FC1_DIR_NODS              0x00    /* STA->STA */
+#define IEEE80211_FC1_DIR_TODS              0x01    /* STA->AP  */
+#define IEEE80211_FC1_DIR_FROMDS            0x02    /* AP ->STA */
+#define IEEE80211_FC1_DIR_DSTODS            0x03    /* AP ->AP  */
+
+#define IEEE80211_FC1_MORE_FRAG             0x04
+#define IEEE80211_FC1_RETRY                 0x08
+#define IEEE80211_FC1_PWR_MGT               0x10
+#define IEEE80211_FC1_MORE_DATA             0x20
+#define IEEE80211_FC1_WEP                   0x40
+#define IEEE80211_FC1_ORDER                 0x80
+
+#define IEEE80211_SEQ_FRAG_MASK             0x000f
+#define IEEE80211_SEQ_FRAG_SHIFT            0
+#define IEEE80211_SEQ_SEQ_MASK              0xfff0
+#define IEEE80211_SEQ_SEQ_SHIFT             4
+
+#define IEEE80211_NWID_LEN                  32
+
+/*
+ * 802.11 rate set.
+ */
+#define IEEE80211_RATE_SIZE     8       /* 802.11 standard */
+#define IEEE80211_RATE_MAXSIZE  15      /* max rates we'll handle */
+
+#define WMM_NUM_AC                  4   /* 4 AC categories */
+
+#define WMM_PARAM_ACI_M         0x60    /* Mask for ACI field */
+#define WMM_PARAM_ACI_S         5   /* Shift for ACI field */
+#define WMM_PARAM_ACM_M         0x10    /* Mask for ACM bit */
+#define WMM_PARAM_ACM_S         4       /* Shift for ACM bit */
+#define WMM_PARAM_AIFSN_M       0x0f    /* Mask for aifsn field */
+#define WMM_PARAM_LOGCWMIN_M    0x0f    /* Mask for CwMin field (in log) */
+#define WMM_PARAM_LOGCWMAX_M    0xf0    /* Mask for CwMax field (in log) */
+#define WMM_PARAM_LOGCWMAX_S    4   /* Shift for CwMax field */
+
+#define WMM_AC_TO_TID(_ac) (       \
+    ((_ac) == WMM_AC_VO) ? 6 : \
+    ((_ac) == WMM_AC_VI) ? 5 : \
+    ((_ac) == WMM_AC_BK) ? 1 : \
+    0)
+
+#define TID_TO_WMM_AC(_tid) (      \
+    ((_tid) < 1) ? WMM_AC_BE : \
+    ((_tid) < 3) ? WMM_AC_BK : \
+    ((_tid) < 6) ? WMM_AC_VI : \
+    WMM_AC_VO)
+/*
+ * Management information element payloads.
+ */
+
+enum {
+    IEEE80211_ELEMID_SSID       = 0,
+    IEEE80211_ELEMID_RATES      = 1,
+    IEEE80211_ELEMID_FHPARMS    = 2,
+    IEEE80211_ELEMID_DSPARMS    = 3,
+    IEEE80211_ELEMID_CFPARMS    = 4,
+    IEEE80211_ELEMID_TIM        = 5,
+    IEEE80211_ELEMID_IBSSPARMS  = 6,
+    IEEE80211_ELEMID_COUNTRY    = 7,
+    IEEE80211_ELEMID_CHALLENGE  = 16,
+    /* 17-31 reserved for challenge text extension */
+    IEEE80211_ELEMID_PWRCNSTR   = 32,
+    IEEE80211_ELEMID_PWRCAP     = 33,
+    IEEE80211_ELEMID_TPCREQ     = 34,
+    IEEE80211_ELEMID_TPCREP     = 35,
+    IEEE80211_ELEMID_SUPPCHAN   = 36,
+    IEEE80211_ELEMID_CHANSWITCH = 37,
+    IEEE80211_ELEMID_MEASREQ    = 38,
+    IEEE80211_ELEMID_MEASREP    = 39,
+    IEEE80211_ELEMID_QUIET      = 40,
+    IEEE80211_ELEMID_IBSSDFS    = 41,
+    IEEE80211_ELEMID_ERP        = 42,
+    IEEE80211_ELEMID_RSN        = 48,
+    IEEE80211_ELEMID_XRATES     = 50,
+    IEEE80211_ELEMID_TPC        = 150,
+    IEEE80211_ELEMID_CCKM       = 156,
+    IEEE80211_ELEMID_VENDOR     = 221,  /* vendor private */
+};
+
+#define ATH_OUI             0x7f0300        /* Atheros OUI */
+#define ATH_OUI_TYPE        0x01
+#define ATH_OUI_SUBTYPE     0x01
+#define ATH_OUI_VERSION     0x00
+
+#define WPA_OUI             0xf25000
+#define WPA_OUI_TYPE        0x01
+#define WPA_VERSION         1          /* current supported version */
+
+#define WPA_CSE_NULL        0x00
+#define WPA_CSE_WEP40       0x01
+#define WPA_CSE_TKIP        0x02
+#define WPA_CSE_CCMP        0x04
+#define WPA_CSE_WEP104      0x05
+
+#define WPA_ASE_NONE        0x00
+#define WPA_ASE_8021X_UNSPEC    0x01
+#define WPA_ASE_8021X_PSK   0x02
+
+#define RSN_OUI         0xac0f00
+#define RSN_VERSION     1       /* current supported version */
+
+#define RSN_CSE_NULL        0x00
+#define RSN_CSE_WEP40       0x01
+#define RSN_CSE_TKIP        0x02
+#define RSN_CSE_WRAP        0x03
+#define RSN_CSE_CCMP        0x04
+#define RSN_CSE_WEP104      0x05
+
+#define RSN_ASE_NONE        0x00
+#define RSN_ASE_8021X_UNSPEC    0x01
+#define RSN_ASE_8021X_PSK   0x02
+
+#define RSN_CAP_PREAUTH     0x01
+
+#define WMM_OUI         0xf25000
+#define WMM_OUI_TYPE        0x02
+#define WMM_INFO_OUI_SUBTYPE    0x00
+#define WMM_PARAM_OUI_SUBTYPE   0x01
+#define WMM_VERSION     1
+
+/* WMM stream classes */
+#define WMM_NUM_AC  4
+#define WMM_AC_BE   0       /* best effort */
+#define WMM_AC_BK   1       /* background */
+#define WMM_AC_VI   2       /* video */
+#define WMM_AC_VO   3       /* voice */
+
+/* TSPEC related */
+#define ACTION_CATEGORY_CODE_TSPEC                 17
+#define ACTION_CODE_TSPEC_ADDTS                    0
+#define ACTION_CODE_TSPEC_ADDTS_RESP               1
+#define ACTION_CODE_TSPEC_DELTS                    2
+
+typedef enum {
+    TSPEC_STATUS_CODE_ADMISSION_ACCEPTED = 0,
+    TSPEC_STATUS_CODE_ADDTS_INVALID_PARAMS = 0x1,
+    TSPEC_STATUS_CODE_ADDTS_REQUEST_REFUSED = 0x3,
+    TSPEC_STATUS_CODE_UNSPECIFIED_QOS_RELATED_FAILURE = 0xC8,
+    TSPEC_STATUS_CODE_REQUESTED_REFUSED_POLICY_CONFIGURATION = 0xC9,
+    TSPEC_STATUS_CODE_INSUFFCIENT_BANDWIDTH = 0xCA,
+    TSPEC_STATUS_CODE_INVALID_PARAMS = 0xCB,
+    TSPEC_STATUS_CODE_DELTS_SENT    = 0x30,
+    TSPEC_STATUS_CODE_DELTS_RECV    = 0x31,
+} TSPEC_STATUS_CODE;
+
+/*
+ * WMM/802.11e Tspec Element
+ */
+typedef PREPACK struct wmm_tspec_ie_t {
+    A_UINT8     elementId;
+    A_UINT8     len;
+    A_UINT8     oui[3];
+    A_UINT8     ouiType;
+    A_UINT8     ouiSubType;
+    A_UINT8     version;
+    A_UINT16    tsInfo_info;
+    A_UINT8     tsInfo_reserved;
+    A_UINT16    nominalMSDU;
+    A_UINT16    maxMSDU;
+    A_UINT32    minServiceInt;
+    A_UINT32    maxServiceInt;
+    A_UINT32    inactivityInt;
+    A_UINT32    suspensionInt;
+    A_UINT32    serviceStartTime;
+    A_UINT32    minDataRate;
+    A_UINT32    meanDataRate;
+    A_UINT32    peakDataRate;
+    A_UINT32    maxBurstSize;
+    A_UINT32    delayBound;
+    A_UINT32    minPhyRate;
+    A_UINT16    sba;
+    A_UINT16    mediumTime;
+} POSTPACK WMM_TSPEC_IE;
+
+
+/*
+ * BEACON management packets
+ *
+ *  octet timestamp[8]
+ *  octet beacon interval[2]
+ *  octet capability information[2]
+ *  information element
+ *      octet elemid
+ *      octet length
+ *      octet information[length]
+ */
+
+#define IEEE80211_BEACON_INTERVAL(beacon) \
+    ((beacon)[8] | ((beacon)[9] << 8))
+#define IEEE80211_BEACON_CAPABILITY(beacon) \
+    ((beacon)[10] | ((beacon)[11] << 8))
+
+#define IEEE80211_CAPINFO_ESS               0x0001
+#define IEEE80211_CAPINFO_IBSS              0x0002
+#define IEEE80211_CAPINFO_CF_POLLABLE       0x0004
+#define IEEE80211_CAPINFO_CF_POLLREQ        0x0008
+#define IEEE80211_CAPINFO_PRIVACY           0x0010
+#define IEEE80211_CAPINFO_SHORT_PREAMBLE    0x0020
+#define IEEE80211_CAPINFO_PBCC              0x0040
+#define IEEE80211_CAPINFO_CHNL_AGILITY      0x0080
+/* bits 8-9 are reserved */
+#define IEEE80211_CAPINFO_SHORT_SLOTTIME    0x0400
+#define IEEE80211_CAPINFO_APSD              0x0800
+/* bit 12 is reserved */
+#define IEEE80211_CAPINFO_DSSSOFDM          0x2000
+/* bits 14-15 are reserved */
+
+/*
+ * Authentication Modes
+ */
+
+enum ieee80211_authmode {
+    IEEE80211_AUTH_NONE     = 0,
+    IEEE80211_AUTH_OPEN     = 1,
+    IEEE80211_AUTH_SHARED   = 2,
+    IEEE80211_AUTH_8021X    = 3,
+    IEEE80211_AUTH_AUTO     = 4,   /* auto-select/accept */
+    /* NB: these are used only for ioctls */
+    IEEE80211_AUTH_WPA      = 5,  /* WPA/RSN  w/ 802.1x */
+    IEEE80211_AUTH_WPA_PSK  = 6,  /* WPA/RSN  w/ PSK */
+    IEEE80211_AUTH_WPA_CCKM = 7,  /* WPA/RSN IE  w/ CCKM */
+};
+
+#include "athendpack.h"
+
+#endif /* _NET80211_IEEE80211_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/ieee80211_ioctl.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ieee80211_ioctl.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/ieee80211_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ieee80211_ioctl.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/os/linux/include/ieee80211_ioctl.h#1 $
+ */
+
+#ifndef _IEEE80211_IOCTL_H_
+#define _IEEE80211_IOCTL_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Extracted from the MADWIFI net80211/ieee80211_ioctl.h
+ */
+
+/*
+ * WPA/RSN get/set key request.  Specify the key/cipher
+ * type and whether the key is to be used for sending and/or
+ * receiving.  The key index should be set only when working
+ * with global keys (use IEEE80211_KEYIX_NONE for ``no index'').
+ * Otherwise a unicast/pairwise key is specified by the bssid
+ * (on a station) or mac address (on an ap).  They key length
+ * must include any MIC key data; otherwise it should be no
+ more than IEEE80211_KEYBUF_SIZE.
+ */
+struct ieee80211req_key {
+	u_int8_t	ik_type;	/* key/cipher type */
+	u_int8_t	ik_pad;
+	u_int16_t	ik_keyix;	/* key index */
+	u_int8_t	ik_keylen;	/* key length in bytes */
+	u_int8_t	ik_flags;
+#define IEEE80211_KEY_XMIT  0x01
+#define IEEE80211_KEY_RECV  0x02
+#define	IEEE80211_KEY_DEFAULT	0x80	/* default xmit key */
+	u_int8_t	ik_macaddr[IEEE80211_ADDR_LEN];
+	u_int64_t	ik_keyrsc;	/* key receive sequence counter */
+	u_int64_t	ik_keytsc;	/* key transmit sequence counter */
+	u_int8_t	ik_keydata[IEEE80211_KEYBUF_SIZE+IEEE80211_MICBUF_SIZE];
+};
+/*
+ * Delete a key either by index or address.  Set the index
+ * to IEEE80211_KEYIX_NONE when deleting a unicast key.
+ */
+struct ieee80211req_del_key {
+	u_int8_t	idk_keyix;	/* key index */
+	u_int8_t	idk_macaddr[IEEE80211_ADDR_LEN];
+};
+/*
+ * MLME state manipulation request.  IEEE80211_MLME_ASSOC
+ * only makes sense when operating as a station.  The other
+ * requests can be used when operating as a station or an
+ * ap (to effect a station).
+ */
+struct ieee80211req_mlme {
+	u_int8_t	im_op;		/* operation to perform */
+#define	IEEE80211_MLME_ASSOC		1	/* associate station */
+#define	IEEE80211_MLME_DISASSOC		2	/* disassociate station */
+#define	IEEE80211_MLME_DEAUTH		3	/* deauthenticate station */
+#define	IEEE80211_MLME_AUTHORIZE	4	/* authorize station */
+#define	IEEE80211_MLME_UNAUTHORIZE	5	/* unauthorize station */
+	u_int16_t	im_reason;	/* 802.11 reason code */
+	u_int8_t	im_macaddr[IEEE80211_ADDR_LEN];
+};
+
+struct ieee80211req_addpmkid {
+    u_int8_t    pi_bssid[IEEE80211_ADDR_LEN];
+    u_int8_t    pi_enable;
+    u_int8_t    pi_pmkid[16];
+};
+
+#define AUTH_ALG_OPEN_SYSTEM	0x01
+#define AUTH_ALG_SHARED_KEY	0x02
+#define AUTH_ALG_LEAP		0x04
+
+struct ieee80211req_authalg {
+   u_int8_t auth_alg;
+};
+
+/*
+ * Request to add an IE to a Management Frame
+ */
+enum{
+    IEEE80211_APPIE_FRAME_BEACON     = 0,
+    IEEE80211_APPIE_FRAME_PROBE_REQ  = 1,
+    IEEE80211_APPIE_FRAME_PROBE_RESP = 2,
+    IEEE80211_APPIE_FRAME_ASSOC_REQ  = 3,
+    IEEE80211_APPIE_FRAME_ASSOC_RESP = 4,
+    IEEE80211_APPIE_NUM_OF_FRAME     = 5
+};
+
+/*
+ * The Maximum length of the IE that can be added to a Management frame
+ */
+#define IEEE80211_APPIE_FRAME_MAX_LEN  78
+
+struct ieee80211req_getset_appiebuf {
+    u_int32_t app_frmtype; /* management frame type for which buffer is added */
+    u_int32_t app_buflen;  /*application supplied buffer length */
+    u_int8_t  app_buf[];
+};
+
+/*
+ * The following definitions are used by an application to set filter
+ * for receiving management frames
+ */
+enum {
+     IEEE80211_FILTER_TYPE_BEACON      =   0x1,
+     IEEE80211_FILTER_TYPE_PROBE_REQ   =   0x2,
+     IEEE80211_FILTER_TYPE_PROBE_RESP  =   0x4,
+     IEEE80211_FILTER_TYPE_ASSOC_REQ   =   0x8,
+     IEEE80211_FILTER_TYPE_ASSOC_RESP  =   0x10,
+     IEEE80211_FILTER_TYPE_AUTH        =   0x20,
+     IEEE80211_FILTER_TYPE_DEAUTH      =   0x40,
+     IEEE80211_FILTER_TYPE_DISASSOC    =   0x80,
+     IEEE80211_FILTER_TYPE_ALL         =   0xFF  /* used to check the valid filter bits */
+};
+
+struct ieee80211req_set_filter {
+      u_int32_t app_filterype; /* management frame filter type */
+};
+
+enum {
+    IEEE80211_PARAM_AUTHMODE = 3,   /* Authentication Mode */
+    IEEE80211_PARAM_MCASTCIPHER = 5,
+    IEEE80211_PARAM_MCASTKEYLEN = 6,    /* multicast key length */
+    IEEE80211_PARAM_UCASTCIPHER = 8,
+    IEEE80211_PARAM_UCASTKEYLEN = 9,    /* unicast key length */
+	IEEE80211_PARAM_WPA		= 10,	/* WPA mode (0,1,2) */
+	IEEE80211_PARAM_ROAMING		= 12,	/* roaming mode */
+	IEEE80211_PARAM_PRIVACY		= 13,	/* privacy invoked */
+	IEEE80211_PARAM_COUNTERMEASURES	= 14,	/* WPA/TKIP countermeasures */
+	IEEE80211_PARAM_DROPUNENCRYPTED	= 15,	/* discard unencrypted frames */
+};
+
+/*
+ * Values for IEEE80211_PARAM_WPA
+ */
+#define WPA_MODE_WPA1   1
+#define WPA_MODE_WPA2   2
+#define WPA_MODE_AUTO   3
+#define WPA_MODE_NONE   4
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _IEEE80211_IOCTL_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/ieee80211_node.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ieee80211_node.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/ieee80211_node.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ieee80211_node.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,77 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * Copyright (c) 2006 Atheros Communications, Inc.
+ *
+ * Wireless Network driver for Atheros AR6001
+ * All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _IEEE80211_NODE_H_
+#define _IEEE80211_NODE_H_
+
+/*
+ * Node locking definitions.
+ */
+#define IEEE80211_NODE_LOCK_INIT(_nt)   A_MUTEX_INIT(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_LOCK_DESTROY(_nt)
+#define IEEE80211_NODE_LOCK(_nt)        A_MUTEX_LOCK(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_UNLOCK(_nt)      A_MUTEX_UNLOCK(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_LOCK_BH(_nt)     A_MUTEX_LOCK(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_UNLOCK_BH(_nt)   A_MUTEX_UNLOCK(&(_nt)->nt_nodelock)
+#define IEEE80211_NODE_LOCK_ASSERT(_nt)
+
+/*
+ * Node reference counting definitions.
+ *
+ * ieee80211_node_initref   initialize the reference count to 1
+ * ieee80211_node_incref    add a reference
+ * ieee80211_node_decref    remove a reference
+ * ieee80211_node_dectestref    remove a reference and return 1 if this
+ *              is the last reference, otherwise 0
+ * ieee80211_node_refcnt    reference count for printing (only)
+ */
+#define ieee80211_node_initref(_ni)     ((_ni)->ni_refcnt = 1)
+#define ieee80211_node_incref(_ni)      ((_ni)->ni_refcnt++)
+#define ieee80211_node_decref(_ni)      ((_ni)->ni_refcnt--)
+#define ieee80211_node_dectestref(_ni)  (((_ni)->ni_refcnt--) == 0)
+#define ieee80211_node_refcnt(_ni)      ((_ni)->ni_refcnt)
+
+#define IEEE80211_NODE_HASHSIZE 32
+/* simple hash is enough for variation of macaddr */
+#define IEEE80211_NODE_HASH(addr)   \
+    (((const A_UINT8 *)(addr))[IEEE80211_ADDR_LEN - 1] % \
+        IEEE80211_NODE_HASHSIZE)
+
+/*
+ * Table of ieee80211_node instances.  Each ieee80211com
+ * has at least one for holding the scan candidates.
+ * When operating as an access point or in ibss mode there
+ * is a second table for associated stations or neighbors.
+ */
+struct ieee80211_node_table {
+    void                   *nt_wmip;       /* back reference */
+    A_MUTEX_T               nt_nodelock;    /* on node table */
+    struct bss              *nt_node_first; /* information of all nodes */
+    struct bss              *nt_node_last;  /* information of all nodes */
+    struct bss              *nt_hash[IEEE80211_NODE_HASHSIZE];
+    const char              *nt_name;   /* for debugging */
+    A_UINT32                nt_scangen; /* gen# for timeout scan */
+    A_TIMER                 nt_inact_timer;
+    A_UINT8                 isTimerArmed;   /* is the node timer armed */
+};
+
+#define WLAN_NODE_INACT_TIMEOUT_MSEC            10000
+
+#endif /* _IEEE80211_NODE_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/ini_dset.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ini_dset.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/ini_dset.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/ini_dset.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+#ifndef _INI_DSET_H_
+#define _INI_DSET_H_
+
+/*
+ * Each of these represents a WHAL INI table, which consists
+ * of an "address column" followed by 1 or more "value columns".
+ *
+ * Software uses the base WHAL_INI_DATA_ID+column to access a
+ * DataSet that holds a particular column of data.
+ */
+typedef enum {
+    WHAL_INI_DATA_ID_NULL               =0,
+    WHAL_INI_DATA_ID_MODE_SPECIFIC      =1,  /* 2,3 */
+    WHAL_INI_DATA_ID_COMMON             =4,  /* 5 */
+    WHAL_INI_DATA_ID_BB_RFGAIN          =6,  /* 7,8 */
+    WHAL_INI_DATA_ID_ANALOG_BANK1       =9,  /* 10 */
+    WHAL_INI_DATA_ID_ANALOG_BANK2       =11, /* 12 */
+    WHAL_INI_DATA_ID_ANALOG_BANK3       =13, /* 14, 15 */
+    WHAL_INI_DATA_ID_ANALOG_BANK6       =16, /* 17, 18 */
+    WHAL_INI_DATA_ID_ANALOG_BANK7       =19, /* 20 */
+    WHAL_INI_DATA_ID_MODE_OVERRIDES     =21, /* 22,23 */
+    WHAL_INI_DATA_ID_COMMON_OVERRIDES   =24, /* 25 */
+
+    WHAL_INI_DATA_ID_MAX                =25
+} WHAL_INI_DATA_ID;
+
+typedef PREPACK struct {
+    A_UINT16 freqIndex; // 1 - A mode 2 - B or G mode 0 - common
+    A_UINT16 offset;
+    A_UINT32 newValue;
+} POSTPACK INI_DSET_REG_OVERRIDE;
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/regDb.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/regDb.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/regDb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/regDb.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2005 Atheros Communications, Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This module contains the header files for regulatory module,
+ * which include the DB schema and DB values.
+ * $Id:
+ */
+
+#ifndef __REG_DB_H__
+#define __REG_DB_H__
+
+#include "./regulatory/reg_dbschema.h"
+#include "./regulatory/reg_dbvalues.h"
+
+#endif  /* __REG_DB_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/regdump.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/regdump.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/regdump.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/regdump.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,33 @@
+#ifndef __REGDUMP_H__
+#define __REGDUMP_H__
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+#if defined(AR6001)
+#include "AR6001/AR6001_regdump.h"
+#endif
+#if defined(AR6002)
+#include "AR6002/AR6002_regdump.h"
+#endif
+
+#if !defined(__ASSEMBLER__)
+/*
+ * Target CPU state at the time of failure is reflected
+ * in a register dump, which the Host can fetch through
+ * the diagnostic window.
+ */
+struct register_dump_s {
+    A_UINT32 target_id;               /* Target ID */
+    A_UINT32 assline;                 /* Line number (if assertion failure) */
+    A_UINT32 pc;                      /* Program Counter at time of exception */
+    A_UINT32 badvaddr;                /* Virtual address causing exception */
+    CPU_exception_frame_t exc_frame;  /* CPU-specific exception info */
+
+    /* Could copy top of stack here, too.... */
+};
+#endif /* __ASSEMBLER__ */
+#endif /* __REGDUMP_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/targaddrs.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/targaddrs.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/targaddrs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/targaddrs.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __TARGADDRS_H__
+#define __TARGADDRS_H__
+#if defined(AR6001)
+#include "AR6001/addrs.h"
+#endif
+#if defined(AR6002)
+#include "AR6002/addrs.h"
+#endif
+
+/*
+ * AR6K option bits, to enable/disable various features.
+ * By default, all option bits are 0.
+ * These bits can be set in LOCAL_SCRATCH register 0.
+ */
+#define AR6K_OPTION_BMI_DISABLE      0x01 /* Disable BMI comm with Host */
+#define AR6K_OPTION_SERIAL_ENABLE    0x02 /* Enable serial port msgs */
+#define AR6K_OPTION_WDT_DISABLE      0x04 /* WatchDog Timer override */
+#define AR6K_OPTION_SLEEP_DISABLE    0x08 /* Disable system sleep */
+#define AR6K_OPTION_STOP_BOOT        0x10 /* Stop boot processes (for ATE) */
+#define AR6K_OPTION_ENABLE_NOANI     0x20 /* Operate without ANI */
+#define AR6K_OPTION_DSET_DISABLE     0x40 /* Ignore DataSets */
+#define AR6K_OPTION_IGNORE_FLASH     0x80 /* Ignore flash during bootup */
+
+/*
+ * xxx_HOST_INTEREST_ADDRESS is the address in Target RAM of the
+ * host_interest structure.  It must match the address of the _host_interest
+ * symbol (see linker script).
+ *
+ * Host Interest is shared between Host and Target in order to coordinate
+ * between the two, and is intended to remain constant (with additions only
+ * at the end) across software releases.
+ */
+#define AR6001_HOST_INTEREST_ADDRESS     0x80000600
+#define AR6002_HOST_INTEREST_ADDRESS     0x00500400
+
+#define HOST_INTEREST_MAX_SIZE          0x100
+
+#if !defined(__ASSEMBLER__)
+struct register_dump_s;
+struct dbglog_hdr_s;
+
+/*
+ * These are items that the Host may need to access
+ * via BMI or via the Diagnostic Window. The position
+ * of items in this structure must remain constant
+ * across firmware revisions!
+ *
+ * Types for each item must be fixed size across
+ * target and host platforms.
+ *
+ * More items may be added at the end.
+ */
+struct host_interest_s {
+    /*
+     * Pointer to application-defined area, if any.
+     * Set by Target application during startup.
+     */
+    A_UINT32               hi_app_host_interest;                      /* 0x00 */
+
+    /* Pointer to register dump area, valid after Target crash. */
+    A_UINT32               hi_failure_state;                          /* 0x04 */
+
+    /* Pointer to debug logging header */
+    A_UINT32               hi_dbglog_hdr;                             /* 0x08 */
+
+    /* Indicates whether or not flash is present on Target.
+     * NB: flash_is_present indicator is here not just
+     * because it might be of interest to the Host; but
+     * also because it's set early on by Target's startup
+     * asm code and we need it to have a special RAM address
+     * so that it doesn't get reinitialized with the rest
+     * of data.
+     */
+    A_UINT32               hi_flash_is_present;                       /* 0x0c */
+
+    /*
+     * General-purpose flag bits, similar to AR6000_OPTION_* flags.
+     * Can be used by application rather than by OS.
+     */
+    A_UINT32               hi_option_flag;                            /* 0x10 */
+
+    /*
+     * Boolean that determines whether or not to
+     * display messages on the serial port.
+     */
+    A_UINT32               hi_serial_enable;                          /* 0x14 */
+
+    /* Start address of Flash DataSet index, if any */
+    A_UINT32               hi_dset_list_head;                         /* 0x18 */
+
+    /* Override Target application start address */
+    A_UINT32               hi_app_start;                              /* 0x1c */
+
+    /* Clock and voltage tuning */
+    A_UINT32               hi_skip_clock_init;                        /* 0x20 */
+    A_UINT32               hi_core_clock_setting;                     /* 0x24 */
+    A_UINT32               hi_cpu_clock_setting;                      /* 0x28 */
+    A_UINT32               hi_system_sleep_setting;                   /* 0x2c */
+    A_UINT32               hi_xtal_control_setting;                   /* 0x30 */
+    A_UINT32               hi_pll_ctrl_setting_24ghz;                 /* 0x34 */
+    A_UINT32               hi_pll_ctrl_setting_5ghz;                  /* 0x38 */
+    A_UINT32               hi_ref_voltage_trim_setting;               /* 0x3c */
+    A_UINT32               hi_clock_info;                             /* 0x40 */
+
+    /*
+     * Flash configuration overrides, used only
+     * when firmware is not executing from flash.
+     * (When using flash, modify the global variables
+     * with equivalent names.)
+     */
+    A_UINT32               hi_bank0_addr_value;                       /* 0x44 */
+    A_UINT32               hi_bank0_read_value;                       /* 0x48 */
+    A_UINT32               hi_bank0_write_value;                      /* 0x4c */
+    A_UINT32               hi_bank0_config_value;                     /* 0x50 */
+
+    /* Pointer to Board Data  */
+    A_UINT32               hi_board_data;                             /* 0x54 */
+    A_UINT32               hi_board_data_initialized;                 /* 0x58 */
+
+    A_UINT32               hi_dset_RAM_index_table;                   /* 0x5c */
+
+    A_UINT32               hi_desired_baud_rate;                      /* 0x60 */
+    A_UINT32               hi_dbglog_config;                          /* 0x64 */
+    A_UINT32               hi_end_RAM_reserve_sz;                     /* 0x68 */
+    A_UINT32               hi_mbox_io_block_sz;                       /* 0x6c */
+
+    A_UINT32               hi_num_bpatch_streams;                     /* 0x70 */
+    A_UINT32               hi_mbox_isr_yield_limit;                   /* 0x74 */
+
+    A_UINT32               hi_refclk_hz;                              /* 0x78 */
+};
+
+/* Bits defined in hi_option_flag */
+#define HI_OPTION_TIMER_WAR     1 /* not really used */
+
+/*
+ * Intended for use by Host software, this macro returns the Target RAM
+ * address of any item in the host_interest structure.
+ * Example: target_addr = AR6001_HOST_INTEREST_ITEM_ADDRESS(hi_board_data);
+ */
+#define AR6001_HOST_INTEREST_ITEM_ADDRESS(item) \
+    ((A_UINT32)&((((struct host_interest_s *)(AR6001_HOST_INTEREST_ADDRESS))->item)))
+
+#define AR6002_HOST_INTEREST_ITEM_ADDRESS(item) \
+    ((A_UINT32)&((((struct host_interest_s *)(AR6002_HOST_INTEREST_ADDRESS))->item)))
+
+
+#endif /* !__ASSEMBLER__ */
+
+#endif /* __TARGADDRS_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/testcmd.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/testcmd.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/testcmd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/testcmd.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef  TESTCMD_H_
+#define  TESTCMD_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    ZEROES_PATTERN = 0,
+    ONES_PATTERN,
+    REPEATING_10,
+    PN7_PATTERN,
+    PN9_PATTERN,
+    PN15_PATTERN
+}TX_DATA_PATTERN;
+
+/* Continous tx
+   mode : TCMD_CONT_TX_OFF - Disabling continous tx
+          TCMD_CONT_TX_SINE - Enable continuous unmodulated tx
+          TCMD_CONT_TX_FRAME- Enable continuous modulated tx
+   freq : Channel freq in Mhz. (e.g 2412 for channel 1 in 11 g)
+dataRate: 0 - 1 Mbps
+          1 - 2 Mbps
+          2 - 5.5 Mbps
+          3 - 11 Mbps
+          4 - 6 Mbps
+          5 - 9 Mbps
+          6 - 12 Mbps
+          7 - 18 Mbps
+          8 - 24 Mbps
+          9 - 36 Mbps
+         10 - 28 Mbps
+         11 - 54 Mbps
+  txPwr: Tx power in dBm[5 -11] for unmod Tx, [5-14] for mod Tx
+antenna:  1 - one antenna
+          2 - two antenna
+Note : Enable/disable continuous tx test cmd works only when target is awake.
+*/
+
+typedef enum {
+    TCMD_CONT_TX_OFF = 0,
+    TCMD_CONT_TX_SINE,
+    TCMD_CONT_TX_FRAME,
+    TCMD_CONT_TX_TX99,
+    TCMD_CONT_TX_TX100
+} TCMD_CONT_TX_MODE;
+
+typedef PREPACK struct {
+    A_UINT32                 testCmdId;
+    A_UINT32                mode;
+    A_UINT32                freq;
+    A_UINT32                dataRate;
+    A_INT32                 txPwr;
+    A_UINT32                antenna;
+    A_UINT32                enANI;
+    A_UINT32                scramblerOff;
+    A_UINT32                aifsn;
+    A_UINT16                pktSz;
+    A_UINT16                txPattern;
+} POSTPACK TCMD_CONT_TX;
+
+#define TCMD_TXPATTERN_ZERONE                 0x1
+#define TCMD_TXPATTERN_ZERONE_DIS_SCRAMBLE    0x2
+
+/* Continuous Rx
+ act: TCMD_CONT_RX_PROMIS - promiscuous mode (accept all incoming frames)
+      TCMD_CONT_RX_FILTER - filter mode (accept only frames with dest
+                                             address equal specified
+                                             mac address (set via act =3)
+      TCMD_CONT_RX_REPORT  off mode  (disable cont rx mode and get the
+                                          report from the last cont
+                                          Rx test)
+
+     TCMD_CONT_RX_SETMAC - set MacAddr mode (sets the MAC address for the
+                                                 target. This Overrides
+                                                 the default MAC address.)
+
+*/
+typedef enum {
+    TCMD_CONT_RX_PROMIS =0,
+    TCMD_CONT_RX_FILTER,
+    TCMD_CONT_RX_REPORT,
+    TCMD_CONT_RX_SETMAC
+} TCMD_CONT_RX_ACT;
+
+typedef PREPACK struct {
+    A_UINT32         testCmdId;
+    A_UINT32        act;
+    A_UINT32        enANI;
+    PREPACK union {
+        struct PREPACK TCMD_CONT_RX_PARA {
+            A_UINT32    freq;
+            A_UINT32    antenna;
+        } POSTPACK para;
+        struct PREPACK TCMD_CONT_RX_REPORT {
+            A_UINT32    totalPkt;
+            A_INT32    rssiInDBm;
+        } POSTPACK report;
+        struct PREPACK TCMD_CONT_RX_MAC {
+            A_UCHAR    addr[ATH_MAC_LEN];
+        } POSTPACK mac;
+    } POSTPACK u;
+} POSTPACK TCMD_CONT_RX;
+
+/* Force sleep/wake  test cmd
+ mode: TCMD_PM_WAKEUP - Wakeup the target
+       TCMD_PM_SLEEP - Force the target to sleep.
+ */
+typedef enum {
+    TCMD_PM_WAKEUP = 1, /* be consistent with target */
+    TCMD_PM_SLEEP
+} TCMD_PM_MODE;
+
+typedef PREPACK struct {
+	A_UINT32  testCmdId;
+    A_UINT32  mode;
+} POSTPACK TCMD_PM;
+
+typedef enum{
+    TCMD_CONT_TX_ID,
+    TCMD_CONT_RX_ID,
+    TCMD_PM_ID
+   } TCMD_ID;
+
+typedef PREPACK union {
+          TCMD_CONT_TX contTx;
+          TCMD_CONT_RX contRx;
+          TCMD_PM pm ;
+} POSTPACK TEST_CMD;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* TESTCMD_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/wlan_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wlan_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/wlan_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wlan_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,101 @@
+#ifndef _HOST_WLAN_API_H_
+#define _HOST_WLAN_API_H_
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains the API for the host wlan module
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/wlan_api.h#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct ieee80211_node_table;
+struct ieee80211_frame;
+
+struct ieee80211_common_ie {
+    A_UINT16    ie_chan;
+    A_UINT8     *ie_tstamp;
+    A_UINT8     *ie_ssid;
+    A_UINT8     *ie_rates;
+    A_UINT8     *ie_xrates;
+    A_UINT8     *ie_country;
+    A_UINT8     *ie_wpa;
+    A_UINT8     *ie_rsn;
+    A_UINT8     *ie_wmm;
+    A_UINT8     *ie_ath;
+    A_UINT16    ie_capInfo;
+    A_UINT16    ie_beaconInt;
+    A_UINT8     *ie_tim;
+    A_UINT8     *ie_chswitch;
+    A_UINT8     ie_erp;
+    A_UINT8     *ie_wsc;
+};
+
+typedef struct bss {
+    A_UINT8                      ni_macaddr[6];
+    A_UINT8                      ni_snr;
+    A_INT16                      ni_rssi;
+    struct bss                   *ni_list_next;
+    struct bss                   *ni_list_prev;
+    struct bss                   *ni_hash_next;
+    struct bss                   *ni_hash_prev;
+    struct ieee80211_common_ie   ni_cie;
+    A_UINT8                     *ni_buf;
+    struct ieee80211_node_table *ni_table;
+    A_UINT32                     ni_refcnt;
+    int                          ni_scangen;
+    A_UINT32                     ni_tstamp;
+} bss_t;
+
+typedef void wlan_node_iter_func(void *arg, bss_t *);
+
+bss_t *wlan_node_alloc(struct ieee80211_node_table *nt, int wh_size);
+void wlan_node_free(bss_t *ni);
+void wlan_setup_node(struct ieee80211_node_table *nt, bss_t *ni,
+                const A_UINT8 *macaddr);
+bss_t *wlan_find_node(struct ieee80211_node_table *nt, const A_UINT8 *macaddr);
+void wlan_node_reclaim(struct ieee80211_node_table *nt, bss_t *ni);
+void wlan_free_allnodes(struct ieee80211_node_table *nt);
+void wlan_iterate_nodes(struct ieee80211_node_table *nt, wlan_node_iter_func *f,
+                        void *arg);
+
+void wlan_node_table_init(void *wmip, struct ieee80211_node_table *nt);
+void wlan_node_table_reset(struct ieee80211_node_table *nt);
+void wlan_node_table_cleanup(struct ieee80211_node_table *nt);
+
+A_STATUS wlan_parse_beacon(A_UINT8 *buf, int framelen,
+                           struct ieee80211_common_ie *cie);
+
+A_UINT16 wlan_ieee2freq(int chan);
+A_UINT32 wlan_freq2ieee(A_UINT16 freq);
+
+
+bss_t *
+wlan_find_Ssidnode (struct ieee80211_node_table *nt, A_UCHAR *pSsid,
+					A_UINT32 ssidLength, A_BOOL bIsWPA2);
+
+void
+wlan_node_return (struct ieee80211_node_table *nt, bss_t *ni);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _HOST_WLAN_API_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/wlan_dset.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wlan_dset.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/wlan_dset.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wlan_dset.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2007 Atheros Communications, Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ */
+
+#ifndef __WLAN_DSET_H__
+#define __WKAN_DSET_H__
+
+typedef PREPACK struct wow_config_dset {
+
+    A_UINT8 valid_dset;
+    A_UINT8 gpio_enable;
+    A_UINT16 gpio_pin;
+} POSTPACK WOW_CONFIG_DSET;
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/wmi_api.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wmi_api.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/wmi_api.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wmi_api.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,260 @@
+#ifndef _WMI_API_H_
+#define _WMI_API_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains the definitions for the Wireless Module Interface (WMI).
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/include/wmi_api.h#2 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * IP QoS Field definitions according to 802.1p
+ */
+#define BEST_EFFORT_PRI         0
+#define BACKGROUND_PRI          1
+#define EXCELLENT_EFFORT_PRI    3
+#define CONTROLLED_LOAD_PRI     4
+#define VIDEO_PRI               5
+#define VOICE_PRI               6
+#define NETWORK_CONTROL_PRI     7
+#define MAX_NUM_PRI             8
+
+#define UNDEFINED_PRI           (0xff)
+
+/* simple mapping of IP TOS field to a WMI priority stream
+ * this mapping was taken from the original linux driver implementation
+ * The operation maps the following
+ *
+ *  */
+#define IP_TOS_TO_WMI_PRI(tos)  \
+    ((WMI_PRI_STREAM_ID)(((tos) >> 1) & 0x03))
+
+#define WMI_IMPLICIT_PSTREAM_INACTIVITY_INT 5000 /* 5 seconds */
+
+
+struct wmi_t;
+
+void *wmi_init(void *devt);
+
+void wmi_qos_state_init(struct wmi_t *wmip);
+void wmi_shutdown(struct wmi_t *wmip);
+A_UINT16  wmi_get_mapped_qos_queue(struct wmi_t *, A_UINT8);
+A_STATUS wmi_dix_2_dot3(struct wmi_t *wmip, void *osbuf);
+A_STATUS wmi_data_hdr_add(struct wmi_t *wmip, void *osbuf, A_UINT8 msgType);
+A_STATUS wmi_dot3_2_dix(struct wmi_t *wmip, void *osbuf);
+A_STATUS wmi_data_hdr_remove(struct wmi_t *wmip, void *osbuf);
+A_STATUS wmi_syncpoint(struct wmi_t *wmip);
+A_STATUS wmi_syncpoint_reset(struct wmi_t *wmip);
+WMI_PRI_STREAM_ID wmi_get_stream_id(struct wmi_t *wmip, A_UINT8 trafficClass);
+A_UINT8 wmi_implicit_create_pstream(struct wmi_t *wmip, void *osbuf, A_UINT8 dir, A_UINT8 up);
+
+A_STATUS wmi_control_rx(struct wmi_t *wmip, void *osbuf);
+void wmi_iterate_nodes(struct wmi_t *wmip, wlan_node_iter_func *f, void *arg);
+void wmi_free_allnodes(struct wmi_t *wmip);
+bss_t *wmi_find_node(struct wmi_t *wmip, const A_UINT8 *macaddr);
+
+
+typedef enum {
+    NO_SYNC_WMIFLAG = 0,
+    SYNC_BEFORE_WMIFLAG,            /* transmit all queued data before cmd */
+    SYNC_AFTER_WMIFLAG,             /* any new data waits until cmd execs */
+    SYNC_BOTH_WMIFLAG,
+    END_WMIFLAG                     /* end marker */
+} WMI_SYNC_FLAG;
+
+A_STATUS wmi_cmd_send(struct wmi_t *wmip, void *osbuf, WMI_COMMAND_ID cmdId,
+                      WMI_SYNC_FLAG flag);
+A_STATUS wmi_connect_cmd(struct wmi_t *wmip,
+                         NETWORK_TYPE netType,
+                         DOT11_AUTH_MODE dot11AuthMode,
+                         AUTH_MODE authMode,
+                         CRYPTO_TYPE pairwiseCrypto,
+                         A_UINT8 pairwiseCryptoLen,
+                         CRYPTO_TYPE groupCrypto,
+                         A_UINT8 groupCryptoLen,
+                         int ssidLength,
+                         A_UCHAR *ssid,
+                         A_UINT8 *bssid,
+                         A_UINT16 channel,
+                         A_UINT32 ctrl_flags);
+A_STATUS wmi_reconnect_cmd(struct wmi_t *wmip,
+                           A_UINT8 *bssid,
+                           A_UINT16 channel);
+A_STATUS wmi_disconnect_cmd(struct wmi_t *wmip);
+A_STATUS wmi_getrev_cmd(struct wmi_t *wmip);
+A_STATUS wmi_startscan_cmd(struct wmi_t *wmip, WMI_SCAN_TYPE scanType,
+                           A_BOOL forceFgScan, A_BOOL isLegacy,
+                           A_UINT32 homeDwellTime, A_UINT32 forceScanInterval);
+A_STATUS wmi_scanparams_cmd(struct wmi_t *wmip, A_UINT16 fg_start_sec,
+                            A_UINT16 fg_end_sec, A_UINT16 bg_sec,
+                            A_UINT16 minact_chdw_msec,
+                            A_UINT16 maxact_chdw_msec, A_UINT16 pas_chdw_msec,
+                            A_UINT8 shScanRatio, A_UINT8 scanCtrlFlags,
+                            A_UINT32 max_dfsch_act_time);
+A_STATUS wmi_bssfilter_cmd(struct wmi_t *wmip, A_UINT8 filter, A_UINT32 ieMask);
+A_STATUS wmi_probedSsid_cmd(struct wmi_t *wmip, A_UINT8 index, A_UINT8 flag,
+                            A_UINT8 ssidLength, A_UCHAR *ssid);
+A_STATUS wmi_listeninterval_cmd(struct wmi_t *wmip, A_UINT16 listenInterval, A_UINT16 listenBeacons);
+A_STATUS wmi_bmisstime_cmd(struct wmi_t *wmip, A_UINT16 bmisstime, A_UINT16 bmissbeacons);
+A_STATUS wmi_associnfo_cmd(struct wmi_t *wmip, A_UINT8 ieType,
+                           A_UINT8 ieLen, A_UINT8 *ieInfo);
+A_STATUS wmi_powermode_cmd(struct wmi_t *wmip, A_UINT8 powerMode);
+A_STATUS wmi_ibsspmcaps_cmd(struct wmi_t *wmip, A_UINT8 pmEnable, A_UINT8 ttl,
+                            A_UINT16 atim_windows, A_UINT16 timeout_value);
+A_STATUS wmi_pmparams_cmd(struct wmi_t *wmip, A_UINT16 idlePeriod,
+                           A_UINT16 psPollNum, A_UINT16 dtimPolicy);
+A_STATUS wmi_disctimeout_cmd(struct wmi_t *wmip, A_UINT8 timeout);
+A_STATUS wmi_sync_cmd(struct wmi_t *wmip, A_UINT8 syncNumber);
+A_STATUS wmi_create_pstream_cmd(struct wmi_t *wmip, WMI_CREATE_PSTREAM_CMD *pstream);
+A_STATUS wmi_delete_pstream_cmd(struct wmi_t *wmip, A_UINT8 trafficClass, A_UINT8 streamID);
+A_STATUS wmi_set_bitrate_cmd(struct wmi_t *wmip, A_INT32 rate);
+A_STATUS wmi_get_bitrate_cmd(struct wmi_t *wmip);
+A_INT8   wmi_validate_bitrate(struct wmi_t *wmip, A_INT32 rate);
+A_STATUS wmi_get_regDomain_cmd(struct wmi_t *wmip);
+A_STATUS wmi_get_channelList_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_channelParams_cmd(struct wmi_t *wmip, A_UINT8 scanParam,
+                                   WMI_PHY_MODE mode, A_INT8 numChan,
+                                   A_UINT16 *channelList);
+
+A_STATUS wmi_set_snr_threshold_params(struct wmi_t *wmip,
+                                       WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd);
+A_STATUS wmi_set_rssi_threshold_params(struct wmi_t *wmip,
+                                        WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd);
+A_STATUS wmi_clr_rssi_snr(struct wmi_t *wmip);
+A_STATUS wmi_set_lq_threshold_params(struct wmi_t *wmip,
+                                      WMI_LQ_THRESHOLD_PARAMS_CMD *lqCmd);
+A_STATUS wmi_set_rts_cmd(struct wmi_t *wmip, A_UINT16 threshold);
+A_STATUS wmi_set_lpreamble_cmd(struct wmi_t *wmip, A_UINT8 status);
+
+A_STATUS wmi_set_error_report_bitmask(struct wmi_t *wmip, A_UINT32 bitmask);
+
+A_STATUS wmi_get_challenge_resp_cmd(struct wmi_t *wmip, A_UINT32 cookie,
+                                    A_UINT32 source);
+A_STATUS wmi_config_debug_module_cmd(struct wmi_t *wmip, A_UINT16 mmask,
+                                     A_UINT16 tsr, A_BOOL rep, A_UINT16 size,
+                                     A_UINT32 valid);
+A_STATUS wmi_get_stats_cmd(struct wmi_t *wmip);
+A_STATUS wmi_addKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex,
+                        CRYPTO_TYPE keyType, A_UINT8 keyUsage,
+                        A_UINT8 keyLength,A_UINT8 *keyRSC,
+                        A_UINT8 *keyMaterial, A_UINT8 key_op_ctrl,
+                        WMI_SYNC_FLAG sync_flag);
+A_STATUS wmi_add_krk_cmd(struct wmi_t *wmip, A_UINT8 *krk);
+A_STATUS wmi_delete_krk_cmd(struct wmi_t *wmip);
+A_STATUS wmi_deleteKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex);
+A_STATUS wmi_set_akmp_params_cmd(struct wmi_t *wmip,
+                                 WMI_SET_AKMP_PARAMS_CMD *akmpParams);
+A_STATUS wmi_get_pmkid_list_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_pmkid_list_cmd(struct wmi_t *wmip,
+                                WMI_SET_PMKID_LIST_CMD *pmkInfo);
+A_STATUS wmi_set_txPwr_cmd(struct wmi_t *wmip, A_UINT8 dbM);
+A_STATUS wmi_get_txPwr_cmd(struct wmi_t *wmip);
+A_STATUS wmi_switch_radio(struct wmi_t *wmip, A_UINT8 on);
+A_STATUS wmi_addBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex, A_UINT8 *bssid);
+A_STATUS wmi_deleteBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex);
+A_STATUS wmi_set_tkip_countermeasures_cmd(struct wmi_t *wmip, A_BOOL en);
+A_STATUS wmi_setPmkid_cmd(struct wmi_t *wmip, A_UINT8 *bssid, A_UINT8 *pmkId,
+                          A_BOOL set);
+A_STATUS wmi_set_access_params_cmd(struct wmi_t *wmip, A_UINT16 txop,
+                                   A_UINT8 eCWmin, A_UINT8 eCWmax,
+                                   A_UINT8 aifsn);
+A_STATUS wmi_set_retry_limits_cmd(struct wmi_t *wmip, A_UINT8 frameType,
+                                  A_UINT8 trafficClass, A_UINT8 maxRetries,
+                                  A_UINT8 enableNotify);
+
+void wmi_get_current_bssid(struct wmi_t *wmip, A_UINT8 *bssid);
+
+A_STATUS wmi_get_roam_tbl_cmd(struct wmi_t *wmip);
+A_STATUS wmi_get_roam_data_cmd(struct wmi_t *wmip, A_UINT8 roamDataType);
+A_STATUS wmi_set_roam_ctrl_cmd(struct wmi_t *wmip, WMI_SET_ROAM_CTRL_CMD *p,
+                               A_UINT8 size);
+A_STATUS wmi_set_powersave_timers_cmd(struct wmi_t *wmip,
+                            WMI_POWERSAVE_TIMERS_POLICY_CMD *pCmd,
+                            A_UINT8 size);
+
+A_STATUS wmi_set_opt_mode_cmd(struct wmi_t *wmip, A_UINT8 optMode);
+A_STATUS wmi_opt_tx_frame_cmd(struct wmi_t *wmip,
+                              A_UINT8 frmType,
+                              A_UINT8 *dstMacAddr,
+                              A_UINT8 *bssid,
+                              A_UINT16 optIEDataLen,
+                              A_UINT8 *optIEData);
+
+A_STATUS wmi_set_adhoc_bconIntvl_cmd(struct wmi_t *wmip, A_UINT16 intvl);
+A_STATUS wmi_set_voice_pkt_size_cmd(struct wmi_t *wmip, A_UINT16 voicePktSize);
+A_STATUS wmi_set_max_sp_len_cmd(struct wmi_t *wmip, A_UINT8 maxSpLen);
+A_UINT8  convert_userPriority_to_trafficClass(A_UINT8 userPriority);
+A_UINT8 wmi_get_power_mode_cmd(struct wmi_t *wmip);
+A_STATUS wmi_verify_tspec_params(WMI_CREATE_PSTREAM_CMD *pCmd, A_BOOL tspecCompliance);
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+A_STATUS wmi_test_cmd(struct wmi_t *wmip, A_UINT8 *buf, A_UINT32  len);
+#endif
+
+A_STATUS wmi_set_bt_status_cmd(struct wmi_t *wmip, A_UINT8 streamType, A_UINT8 status);
+A_STATUS wmi_set_bt_params_cmd(struct wmi_t *wmip, WMI_SET_BT_PARAMS_CMD* cmd);
+
+
+/*
+ *  This function is used to configure the fix rates mask to the target.
+ */
+A_STATUS wmi_set_fixrates_cmd(struct wmi_t *wmip, A_INT16 fixRatesMask);
+A_STATUS wmi_get_ratemask_cmd(struct wmi_t *wmip);
+
+A_STATUS wmi_set_authmode_cmd(struct wmi_t *wmip, A_UINT8 mode);
+
+A_STATUS wmi_set_reassocmode_cmd(struct wmi_t *wmip, A_UINT8 mode);
+
+A_STATUS wmi_set_wmm_cmd(struct wmi_t *wmip, WMI_WMM_STATUS status);
+A_STATUS wmi_set_wmm_txop(struct wmi_t *wmip, WMI_TXOP_CFG txEnable);
+
+A_STATUS wmi_get_keepalive_configured(struct wmi_t *wmip);
+A_UINT8 wmi_get_keepalive_cmd(struct wmi_t *wmip);
+A_STATUS wmi_set_keepalive_cmd(struct wmi_t *wmip, A_UINT8 keepaliveInterval);
+
+A_STATUS wmi_set_appie_cmd(struct wmi_t *wmip, A_UINT8 mgmtFrmType,
+                           A_UINT8 ieLen,A_UINT8 *ieInfo);
+
+A_STATUS wmi_set_halparam_cmd(struct wmi_t *wmip, A_UINT8 *cmd, A_UINT16 dataLen);
+A_INT32 wmi_get_rate(A_INT8 rateindex);
+
+/*Wake on Wireless WMI commands*/
+A_STATUS wmi_set_host_sleep_mode_cmd(struct wmi_t *wmip, WMI_SET_HOST_SLEEP_MODE_CMD *cmd);
+A_STATUS wmi_set_wow_mode_cmd(struct wmi_t *wmip, WMI_SET_WOW_MODE_CMD *cmd);
+A_STATUS wmi_get_wow_list_cmd(struct wmi_t *wmip, WMI_GET_WOW_LIST_CMD *cmd);
+A_STATUS wmi_add_wow_pattern_cmd(struct wmi_t *wmip,
+                                 WMI_ADD_WOW_PATTERN_CMD *cmd, A_UINT8* pattern, A_UINT8* mask, A_UINT8 pattern_size);
+A_STATUS wmi_del_wow_pattern_cmd(struct wmi_t *wmip,
+                                 WMI_DEL_WOW_PATTERN_CMD *cmd);
+A_STATUS wmi_set_wsc_status_cmd(struct wmi_t *wmip, A_UINT32 status);
+
+bss_t *
+wmi_find_Ssidnode (struct wmi_t *wmip, A_UCHAR *pSsid,
+				   A_UINT32 ssidLength, A_BOOL bIsWPA2);
+
+void
+wmi_node_return (struct wmi_t *wmip, bss_t *bss);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMI_API_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/wmi.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wmi.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/wmi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wmi.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1743 @@
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains the definitions of the WMI protocol specified in the
+ * Wireless Module Interface (WMI).  It includes definitions of all the
+ * commands and events. Commands are messages from the host to the WM.
+ * Events and Replies are messages from the WM to the host.
+ *
+ * Ownership of correctness in regards to WMI commands
+ * belongs to the host driver and the WM is not required to validate
+ * parameters for value, proper range, or any other checking.
+ *
+ */
+
+#ifndef _WMI_H_
+#define _WMI_H_
+
+#ifndef ATH_TARGET
+#include "athstartpack.h"
+#endif
+
+#include "wmix.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define WMI_PROTOCOL_VERSION    0x0002
+#define WMI_PROTOCOL_REVISION   0x0000
+
+#define ATH_MAC_LEN             6               /* length of mac in bytes */
+#define WMI_CMD_MAX_LEN         100
+#define WMI_CONTROL_MSG_MAX_LEN     256
+#define WMI_OPT_CONTROL_MSG_MAX_LEN 1536
+#define IS_ETHERTYPE(_typeOrLen)        ((_typeOrLen) >= 0x0600)
+#define RFC1042OUI      {0x00, 0x00, 0x00}
+
+#define IP_ETHERTYPE 0x0800
+
+#define WMI_IMPLICIT_PSTREAM 0xFF
+#define WMI_MAX_THINSTREAM 15
+
+struct host_app_area_s {
+    A_UINT32 wmi_protocol_ver;
+};
+
+/*
+ * Data Path
+ */
+typedef PREPACK struct {
+    A_UINT8     dstMac[ATH_MAC_LEN];
+    A_UINT8     srcMac[ATH_MAC_LEN];
+    A_UINT16    typeOrLen;
+} POSTPACK ATH_MAC_HDR;
+
+typedef PREPACK struct {
+    A_UINT8     dsap;
+    A_UINT8     ssap;
+    A_UINT8     cntl;
+    A_UINT8     orgCode[3];
+    A_UINT16    etherType;
+} POSTPACK ATH_LLC_SNAP_HDR;
+
+typedef enum {
+    DATA_MSGTYPE = 0x0,
+    CNTL_MSGTYPE,
+    SYNC_MSGTYPE
+} WMI_MSG_TYPE;
+
+
+typedef PREPACK struct {
+    A_INT8      rssi;
+    A_UINT8     info;            /* WMI_MSG_TYPE in lower 2 bits - b1b0 */
+                                 /* UP in next 3 bits - b4b3b2 */
+#define WMI_DATA_HDR_MSG_TYPE_MASK  0x03
+#define WMI_DATA_HDR_MSG_TYPE_SHIFT 0
+#define WMI_DATA_HDR_UP_MASK        0x07
+#define WMI_DATA_HDR_UP_SHIFT       2
+#define WMI_DATA_HDR_IS_MSG_TYPE(h, t)  (((h)->info & (WMI_DATA_HDR_MSG_TYPE_MASK)) == (t))
+} POSTPACK WMI_DATA_HDR;
+
+
+#define WMI_DATA_HDR_SET_MSG_TYPE(h, t) (h)->info = (((h)->info & ~(WMI_DATA_HDR_MSG_TYPE_MASK << WMI_DATA_HDR_MSG_TYPE_SHIFT)) | (t << WMI_DATA_HDR_MSG_TYPE_SHIFT))
+#define WMI_DATA_HDR_SET_UP(h, p) (h)->info = (((h)->info & ~(WMI_DATA_HDR_UP_MASK << WMI_DATA_HDR_UP_SHIFT)) | (p << WMI_DATA_HDR_UP_SHIFT))
+
+/*
+ * Control Path
+ */
+typedef PREPACK struct {
+    A_UINT16    commandId;
+} POSTPACK WMI_CMD_HDR;        /* used for commands and events */
+
+/*
+ * List of Commnands
+ */
+typedef enum {
+    WMI_CONNECT_CMDID           = 0x0001,
+    WMI_RECONNECT_CMDID,
+    WMI_DISCONNECT_CMDID,
+    WMI_SYNCHRONIZE_CMDID,
+    WMI_CREATE_PSTREAM_CMDID,
+    WMI_DELETE_PSTREAM_CMDID,
+    WMI_START_SCAN_CMDID,
+    WMI_SET_SCAN_PARAMS_CMDID,
+    WMI_SET_BSS_FILTER_CMDID,
+    WMI_SET_PROBED_SSID_CMDID,
+    WMI_SET_LISTEN_INT_CMDID,
+    WMI_SET_BMISS_TIME_CMDID,
+    WMI_SET_DISC_TIMEOUT_CMDID,
+    WMI_GET_CHANNEL_LIST_CMDID,
+    WMI_SET_BEACON_INT_CMDID,
+    WMI_GET_STATISTICS_CMDID,
+    WMI_SET_CHANNEL_PARAMS_CMDID,
+    WMI_SET_POWER_MODE_CMDID,
+    WMI_SET_IBSS_PM_CAPS_CMDID,
+    WMI_SET_POWER_PARAMS_CMDID,
+    WMI_SET_POWERSAVE_TIMERS_POLICY_CMDID,
+    WMI_ADD_CIPHER_KEY_CMDID,
+    WMI_DELETE_CIPHER_KEY_CMDID,
+    WMI_ADD_KRK_CMDID,
+    WMI_DELETE_KRK_CMDID,
+    WMI_SET_PMKID_CMDID,
+    WMI_SET_TX_PWR_CMDID,
+    WMI_GET_TX_PWR_CMDID,
+    WMI_SET_ASSOC_INFO_CMDID,
+    WMI_ADD_BAD_AP_CMDID,
+    WMI_DELETE_BAD_AP_CMDID,
+    WMI_SET_TKIP_COUNTERMEASURES_CMDID,
+    WMI_RSSI_THRESHOLD_PARAMS_CMDID,
+    WMI_TARGET_ERROR_REPORT_BITMASK_CMDID,
+    WMI_SET_ACCESS_PARAMS_CMDID,
+    WMI_SET_RETRY_LIMITS_CMDID,
+    WMI_SET_OPT_MODE_CMDID,
+    WMI_OPT_TX_FRAME_CMDID,
+    WMI_SET_VOICE_PKT_SIZE_CMDID,
+    WMI_SET_MAX_SP_LEN_CMDID,
+    WMI_SET_ROAM_CTRL_CMDID,
+    WMI_GET_ROAM_TBL_CMDID,
+    WMI_GET_ROAM_DATA_CMDID,
+    WMI_ENABLE_RM_CMDID,
+    WMI_SET_MAX_OFFHOME_DURATION_CMDID,
+    WMI_EXTENSION_CMDID,                        /* Non-wireless extensions */
+    WMI_SNR_THRESHOLD_PARAMS_CMDID,
+    WMI_LQ_THRESHOLD_PARAMS_CMDID,
+    WMI_SET_LPREAMBLE_CMDID,
+    WMI_SET_RTS_CMDID,
+    WMI_CLR_RSSI_SNR_CMDID,
+    WMI_SET_FIXRATES_CMDID,
+    WMI_GET_FIXRATES_CMDID,
+    WMI_SET_AUTH_MODE_CMDID,
+    WMI_SET_REASSOC_MODE_CMDID,
+    WMI_SET_WMM_CMDID,
+    WMI_SET_WMM_TXOP_CMDID,
+    WMI_TEST_CMDID,
+    WMI_SET_BT_STATUS_CMDID,
+    WMI_SET_BT_PARAMS_CMDID,
+
+    WMI_SET_KEEPALIVE_CMDID,
+    WMI_GET_KEEPALIVE_CMDID,
+    WMI_SET_APPIE_CMDID,
+    WMI_GET_APPIE_CMDID,
+    WMI_SET_WSC_STATUS_CMDID,
+
+    /* Wake on Wireless */
+    WMI_SET_HOST_SLEEP_MODE_CMDID,
+    WMI_SET_WOW_MODE_CMDID,
+    WMI_GET_WOW_LIST_CMDID,
+    WMI_ADD_WOW_PATTERN_CMDID,
+    WMI_DEL_WOW_PATTERN_CMDID,
+    WMI_SET_MAC_ADDRESS_CMDID,
+    WMI_SET_AKMP_PARAMS_CMDID,
+    WMI_SET_PMKID_LIST_CMDID,
+    WMI_GET_PMKID_LIST_CMDID,
+
+    /*
+     * Developer commands starts at 0xF000
+     */
+    WMI_SET_BITRATE_CMDID = 0xF000,
+    WMI_GET_BITRATE_CMDID,
+    WMI_SET_WHALPARAM_CMDID,
+
+} WMI_COMMAND_ID;
+
+/*
+ * Frame Types
+ */
+typedef enum {
+    WMI_FRAME_BEACON        =   0,
+    WMI_FRAME_PROBE_REQ,
+    WMI_FRAME_PROBE_RESP,
+    WMI_FRAME_ASSOC_REQ,
+    WMI_FRAME_ASSOC_RESP,
+    WMI_NUM_MGMT_FRAME
+} WMI_MGMT_FRAME_TYPE;
+
+/*
+ * Connect Command
+ */
+typedef enum {
+    INFRA_NETWORK       = 0x01,
+    ADHOC_NETWORK       = 0x02,
+    ADHOC_CREATOR       = 0x04,
+} NETWORK_TYPE;
+
+typedef enum {
+    OPEN_AUTH           = 0x01,
+    SHARED_AUTH         = 0x02,
+    LEAP_AUTH           = 0x04,  /* different from IEEE_AUTH_MODE definitions */
+} DOT11_AUTH_MODE;
+
+typedef enum {
+    NONE_AUTH           = 0x01,
+    WPA_AUTH            = 0x02,
+    WPA_PSK_AUTH        = 0x03,
+    WPA2_AUTH           = 0x04,
+    WPA2_PSK_AUTH       = 0x05,
+    WPA_AUTH_CCKM       = 0x06,
+    WPA2_AUTH_CCKM      = 0x07,
+} AUTH_MODE;
+
+typedef enum {
+    NONE_CRYPT          = 0x01,
+    WEP_CRYPT           = 0x02,
+    TKIP_CRYPT          = 0x03,
+    AES_CRYPT           = 0x04,
+} CRYPTO_TYPE;
+
+#define WMI_MIN_CRYPTO_TYPE NONE_CRYPT
+#define WMI_MAX_CRYPTO_TYPE (AES_CRYPT + 1)
+
+#define WMI_MIN_KEY_INDEX   0
+#define WMI_MAX_KEY_INDEX   3
+
+#define WMI_MAX_KEY_LEN     32
+
+#define WMI_MAX_SSID_LEN    32
+
+typedef enum {
+    CONNECT_ASSOC_POLICY_USER = 0x0001,
+    CONNECT_SEND_REASSOC = 0x0002,
+    CONNECT_IGNORE_WPAx_GROUP_CIPHER = 0x0004,
+    CONNECT_PROFILE_MATCH_DONE = 0x0008,
+    CONNECT_IGNORE_AAC_BEACON = 0x0010,
+    CONNECT_CSA_FOLLOW_BSS = 0x0020,
+} WMI_CONNECT_CTRL_FLAGS_BITS;
+
+#define DEFAULT_CONNECT_CTRL_FLAGS         (CONNECT_CSA_FOLLOW_BSS)
+
+typedef PREPACK struct {
+    A_UINT8     networkType;
+    A_UINT8     dot11AuthMode;
+    A_UINT8     authMode;
+    A_UINT8     pairwiseCryptoType;
+    A_UINT8     pairwiseCryptoLen;
+    A_UINT8     groupCryptoType;
+    A_UINT8     groupCryptoLen;
+    A_UINT8     ssidLength;
+    A_UCHAR     ssid[WMI_MAX_SSID_LEN];
+    A_UINT16    channel;
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT32    ctrl_flags;
+} POSTPACK WMI_CONNECT_CMD;
+
+/*
+ * WMI_RECONNECT_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT16    channel;                    /* hint */
+    A_UINT8     bssid[ATH_MAC_LEN];         /* mandatory if set */
+} POSTPACK WMI_RECONNECT_CMD;
+
+/*
+ * WMI_ADD_CIPHER_KEY_CMDID
+ */
+typedef enum {
+    PAIRWISE_USAGE      = 0x00,
+    GROUP_USAGE         = 0x01,
+    TX_USAGE            = 0x02,     /* default Tx Key - Static WEP only */
+} KEY_USAGE;
+
+/*
+ * Bit Flag
+ * Bit 0 - Initialise TSC - default is Initialize
+ */
+#define KEY_OP_INIT_TSC       0x01
+#define KEY_OP_INIT_RSC       0x02
+
+#define KEY_OP_INIT_VAL     0x03     /* Default Initialise the TSC & RSC */
+#define KEY_OP_VALID_MASK   0x03
+
+typedef PREPACK struct {
+    A_UINT8     keyIndex;
+    A_UINT8     keyType;
+    A_UINT8     keyUsage;           /* KEY_USAGE */
+    A_UINT8     keyLength;
+    A_UINT8     keyRSC[8];          /* key replay sequence counter */
+    A_UINT8     key[WMI_MAX_KEY_LEN];
+    A_UINT8     key_op_ctrl;       /* Additional Key Control information */
+} POSTPACK WMI_ADD_CIPHER_KEY_CMD;
+
+/*
+ * WMI_DELETE_CIPHER_KEY_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     keyIndex;
+} POSTPACK WMI_DELETE_CIPHER_KEY_CMD;
+
+#define WMI_KRK_LEN     16
+/*
+ * WMI_ADD_KRK_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     krk[WMI_KRK_LEN];
+} POSTPACK WMI_ADD_KRK_CMD;
+
+/*
+ * WMI_SET_TKIP_COUNTERMEASURES_CMDID
+ */
+typedef enum {
+    WMI_TKIP_CM_DISABLE = 0x0,
+    WMI_TKIP_CM_ENABLE  = 0x1,
+} WMI_TKIP_CM_CONTROL;
+
+typedef PREPACK struct {
+    A_UINT8  cm_en;                     /* WMI_TKIP_CM_CONTROL */
+} POSTPACK WMI_SET_TKIP_COUNTERMEASURES_CMD;
+
+/*
+ * WMI_SET_PMKID_CMDID
+ */
+
+#define WMI_PMKID_LEN 16
+
+typedef enum {
+   PMKID_DISABLE = 0,
+   PMKID_ENABLE  = 1,
+} PMKID_ENABLE_FLG;
+
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT8     enable;                 /* PMKID_ENABLE_FLG */
+    A_UINT8     pmkid[WMI_PMKID_LEN];
+} POSTPACK WMI_SET_PMKID_CMD;
+
+/*
+ * WMI_START_SCAN_CMD
+ */
+typedef enum {
+    WMI_LONG_SCAN  = 0,
+    WMI_SHORT_SCAN = 1,
+} WMI_SCAN_TYPE;
+
+typedef PREPACK struct {
+    A_BOOL   forceFgScan;
+    A_BOOL   isLegacy;        /* For Legacy Cisco AP compatibility */
+    A_UINT32 homeDwellTime;   /* Maximum duration in the home channel(milliseconds) */
+    A_UINT32 forceScanInterval;    /* Time interval between scans (milliseconds)*/
+    A_UINT8  scanType;           /* WMI_SCAN_TYPE */
+} POSTPACK WMI_START_SCAN_CMD;
+
+/*
+ * WMI_SET_SCAN_PARAMS_CMDID
+ */
+#define WMI_SHORTSCANRATIO_DEFAULT      3
+typedef enum {
+    CONNECT_SCAN_CTRL_FLAGS = 0x01,    /* set if can scan in the Connect cmd */
+    SCAN_CONNECTED_CTRL_FLAGS = 0x02,  /* set if scan for the SSID it is */
+                                       /* already connected to */
+    ACTIVE_SCAN_CTRL_FLAGS = 0x04,     /* set if enable active scan */
+    ROAM_SCAN_CTRL_FLAGS = 0x08,       /* set if enable roam scan when bmiss and lowrssi */
+    REPORT_BSSINFO_CTRL_FLAGS = 0x10,   /* set if follows customer BSSINFO reporting rule */
+    ENABLE_AUTO_CTRL_FLAGS = 0x20,      /* if disabled, target doesn't
+                                          scan after a disconnect event  */
+    ENABLE_SCAN_ABORT_EVENT = 0x40      /* Scan complete event with canceled status will be generated when a scan is prempted before it gets completed */
+
+} WMI_SCAN_CTRL_FLAGS_BITS;
+
+#define CAN_SCAN_IN_CONNECT(flags)      (flags & CONNECT_SCAN_CTRL_FLAGS)
+#define CAN_SCAN_CONNECTED(flags)       (flags & SCAN_CONNECTED_CTRL_FLAGS)
+#define ENABLE_ACTIVE_SCAN(flags)       (flags & ACTIVE_SCAN_CTRL_FLAGS)
+#define ENABLE_ROAM_SCAN(flags)         (flags & ROAM_SCAN_CTRL_FLAGS)
+#define CONFIG_REPORT_BSSINFO(flags)     (flags & REPORT_BSSINFO_CTRL_FLAGS)
+#define IS_AUTO_SCAN_ENABLED(flags)      (flags & ENABLE_AUTO_CTRL_FLAGS)
+#define SCAN_ABORT_EVENT_ENABLED(flags) (flags & ENABLE_SCAN_ABORT_EVENT)
+
+#define DEFAULT_SCAN_CTRL_FLAGS         (CONNECT_SCAN_CTRL_FLAGS| SCAN_CONNECTED_CTRL_FLAGS| ACTIVE_SCAN_CTRL_FLAGS| ROAM_SCAN_CTRL_FLAGS | ENABLE_AUTO_CTRL_FLAGS)
+
+
+typedef PREPACK struct {
+    A_UINT16    fg_start_period;        /* seconds */
+    A_UINT16    fg_end_period;          /* seconds */
+    A_UINT16    bg_period;              /* seconds */
+    A_UINT16    maxact_chdwell_time;    /* msec */
+    A_UINT16    pas_chdwell_time;       /* msec */
+    A_UINT8     shortScanRatio;         /* how many shorts scan for one long */
+    A_UINT8     scanCtrlFlags;
+    A_UINT16    minact_chdwell_time;    /* msec */
+    A_UINT32    max_dfsch_act_time;  /* msecs */
+} POSTPACK WMI_SCAN_PARAMS_CMD;
+
+/*
+ * WMI_SET_BSS_FILTER_CMDID
+ */
+typedef enum {
+    NONE_BSS_FILTER = 0x0,              /* no beacons forwarded */
+    ALL_BSS_FILTER,                     /* all beacons forwarded */
+    PROFILE_FILTER,                     /* only beacons matching profile */
+    ALL_BUT_PROFILE_FILTER,             /* all but beacons matching profile */
+    CURRENT_BSS_FILTER,                 /* only beacons matching current BSS */
+    ALL_BUT_BSS_FILTER,                 /* all but beacons matching BSS */
+    PROBED_SSID_FILTER,                 /* beacons matching probed ssid */
+    LAST_BSS_FILTER,                    /* marker only */
+} WMI_BSS_FILTER;
+
+typedef PREPACK struct {
+    A_UINT8    bssFilter;                      /* see WMI_BSS_FILTER */
+    A_UINT32   ieMask;
+} POSTPACK WMI_BSS_FILTER_CMD;
+
+/*
+ * WMI_SET_PROBED_SSID_CMDID
+ */
+#define MAX_PROBED_SSID_INDEX   5
+
+typedef enum {
+    DISABLE_SSID_FLAG  = 0,                  /* disables entry */
+    SPECIFIC_SSID_FLAG = 0x01,               /* probes specified ssid */
+    ANY_SSID_FLAG      = 0x02,               /* probes for any ssid */
+} WMI_SSID_FLAG;
+
+typedef PREPACK struct {
+    A_UINT8     entryIndex;                     /* 0 to MAX_PROBED_SSID_INDEX */
+    A_UINT8     flag;                           /* WMI_SSID_FLG */
+    A_UINT8     ssidLength;
+    A_UINT8     ssid[32];
+} POSTPACK WMI_PROBED_SSID_CMD;
+
+/*
+ * WMI_SET_LISTEN_INT_CMDID
+ * The Listen interval is between 15 and 3000 TUs
+ */
+#define MIN_LISTEN_INTERVAL 15
+#define MAX_LISTEN_INTERVAL 5000
+#define MIN_LISTEN_BEACONS 1
+#define MAX_LISTEN_BEACONS 50
+
+typedef PREPACK struct {
+    A_UINT16     listenInterval;
+    A_UINT16     numBeacons;
+} POSTPACK WMI_LISTEN_INT_CMD;
+
+/*
+ * WMI_SET_BEACON_INT_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT16     beaconInterval;
+} POSTPACK WMI_BEACON_INT_CMD;
+
+/*
+ * WMI_SET_BMISS_TIME_CMDID
+ * valid values are between 1000 and 5000 TUs
+ */
+
+#define MIN_BMISS_TIME     1000
+#define MAX_BMISS_TIME     5000
+#define MIN_BMISS_BEACONS  1
+#define MAX_BMISS_BEACONS  50
+
+typedef PREPACK struct {
+    A_UINT16     bmissTime;
+    A_UINT16     numBeacons;
+} POSTPACK WMI_BMISS_TIME_CMD;
+
+/*
+ * WMI_SET_POWER_MODE_CMDID
+ */
+typedef enum {
+    REC_POWER = 0x01,
+    MAX_PERF_POWER,
+} WMI_POWER_MODE;
+
+typedef PREPACK struct {
+    A_UINT8     powerMode;      /* WMI_POWER_MODE */
+} POSTPACK WMI_POWER_MODE_CMD;
+
+/*
+ * WMI_SET_POWER_PARAMS_CMDID
+ */
+typedef enum {
+    IGNORE_DTIM = 0x01,
+    NORMAL_DTIM = 0x02,
+    STICK_DTIM  = 0x03,
+} WMI_DTIM_POLICY;
+
+typedef PREPACK struct {
+    A_UINT16    idle_period;             /* msec */
+    A_UINT16    pspoll_number;
+    A_UINT16    dtim_policy;
+} POSTPACK WMI_POWER_PARAMS_CMD;
+
+typedef PREPACK struct {
+    A_UINT8    power_saving;
+    A_UINT8    ttl; /* number of beacon periods */
+    A_UINT16   atim_windows;          /* msec */
+    A_UINT16   timeout_value;         /* msec */
+} POSTPACK WMI_IBSS_PM_CAPS_CMD;
+
+/*
+ * WMI_SET_POWERSAVE_TIMERS_POLICY_CMDID
+ */
+typedef enum {
+    IGNORE_TIM_ALL_QUEUES_APSD = 0,
+    PROCESS_TIM_ALL_QUEUES_APSD = 1,
+    IGNORE_TIM_SIMULATED_APSD = 2,
+    PROCESS_TIM_SIMULATED_APSD = 3,
+} APSD_TIM_POLICY;
+
+typedef PREPACK struct {
+    A_UINT16    psPollTimeout;          /* msec */
+    A_UINT16    triggerTimeout;         /* msec */
+    A_UINT32    apsdTimPolicy;      /* TIM behavior with  ques APSD enabled. Default is IGNORE_TIM_ALL_QUEUES_APSD */
+    A_UINT32    simulatedAPSDTimPolicy;      /* TIM behavior with  simulated APSD enabled. Default is PROCESS_TIM_SIMULATED_APSD */
+} POSTPACK WMI_POWERSAVE_TIMERS_POLICY_CMD;
+
+/*
+ * WMI_SET_VOICE_PKT_SIZE_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT16    voicePktSize;
+} POSTPACK WMI_SET_VOICE_PKT_SIZE_CMD;
+
+/*
+ * WMI_SET_MAX_SP_LEN_CMDID
+ */
+typedef enum {
+    DELIVER_ALL_PKT = 0x0,
+    DELIVER_2_PKT = 0x1,
+    DELIVER_4_PKT = 0x2,
+    DELIVER_6_PKT = 0x3,
+} APSD_SP_LEN_TYPE;
+
+typedef PREPACK struct {
+    A_UINT8    maxSPLen;
+} POSTPACK WMI_SET_MAX_SP_LEN_CMD;
+
+/*
+ * WMI_SET_DISC_TIMEOUT_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     disconnectTimeout;          /* seconds */
+} POSTPACK WMI_DISC_TIMEOUT_CMD;
+
+typedef enum {
+    UPLINK_TRAFFIC = 0,
+    DNLINK_TRAFFIC = 1,
+    BIDIR_TRAFFIC = 2,
+} DIR_TYPE;
+
+typedef enum {
+    DISABLE_FOR_THIS_AC = 0,
+    ENABLE_FOR_THIS_AC  = 1,
+    ENABLE_FOR_ALL_AC   = 2,
+} VOICEPS_CAP_TYPE;
+
+typedef enum {
+    TRAFFIC_TYPE_APERIODIC = 0,
+    TRAFFIC_TYPE_PERIODIC = 1,
+}TRAFFIC_TYPE;
+
+/*
+ * WMI_CREATE_PSTREAM_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT32        minServiceInt;           /* in milli-sec */
+    A_UINT32        maxServiceInt;           /* in milli-sec */
+    A_UINT32        inactivityInt;           /* in milli-sec */
+    A_UINT32        suspensionInt;           /* in milli-sec */
+    A_UINT32        serviceStartTime;
+    A_UINT32        minDataRate;             /* in bps */
+    A_UINT32        meanDataRate;            /* in bps */
+    A_UINT32        peakDataRate;            /* in bps */
+    A_UINT32        maxBurstSize;
+    A_UINT32        delayBound;
+    A_UINT32        minPhyRate;              /* in bps */
+    A_UINT32        sba;
+    A_UINT32        mediumTime;
+    A_UINT16        nominalMSDU;             /* in octects */
+    A_UINT16        maxMSDU;                 /* in octects */
+    A_UINT8         trafficClass;
+    A_UINT8         trafficType;             /* TRAFFIC_TYPE */
+    A_UINT8         trafficDirection;        /* TRAFFIC_DIR */
+    A_UINT8         voicePSCapability;       /* VOICEPS_CAP_TYPE */
+    A_UINT8         tsid;
+    A_UINT8         userPriority;            /* 802.1D user priority */
+} POSTPACK WMI_CREATE_PSTREAM_CMD;
+
+/*
+ * WMI_DELETE_PSTREAM_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     trafficClass;
+    A_UINT8     tsid;
+} POSTPACK WMI_DELETE_PSTREAM_CMD;
+
+/*
+ * WMI_SET_CHANNEL_PARAMS_CMDID
+ */
+typedef enum {
+    WMI_11A_MODE  = 0x1,
+    WMI_11G_MODE  = 0x2,
+    WMI_11AG_MODE = 0x3,
+    WMI_11B_MODE  = 0x4,
+    WMI_11GONLY_MODE = 0x5,
+} WMI_PHY_MODE;
+
+#define WMI_MAX_CHANNELS        32
+
+typedef PREPACK struct {
+    A_UINT8     reserved1;
+    A_UINT8     scanParam;              /* set if enable scan */
+    A_UINT8     phyMode;                /* see WMI_PHY_MODE */
+    A_UINT8     numChannels;            /* how many channels follow */
+    A_UINT16    channelList[1];         /* channels in Mhz */
+} POSTPACK WMI_CHANNEL_PARAMS_CMD;
+
+
+/*
+ *  WMI_RSSI_THRESHOLD_PARAMS_CMDID
+ *  Setting the polltime to 0 would disable polling.
+ *  Threshold values are in the ascending order, and should agree to:
+ *  (lowThreshold_lowerVal < lowThreshold_upperVal < highThreshold_lowerVal
+ *      < highThreshold_upperVal)
+ */
+
+typedef PREPACK struct WMI_RSSI_THRESHOLD_PARAMS{
+    A_UINT32    pollTime;               /* Polling time as a factor of LI */
+    A_INT16     thresholdAbove1_Val;          /* lowest of upper */
+    A_INT16     thresholdAbove2_Val;
+    A_INT16     thresholdAbove3_Val;
+    A_INT16     thresholdAbove4_Val;
+    A_INT16     thresholdAbove5_Val;
+    A_INT16     thresholdAbove6_Val;          /* highest of upper */
+    A_INT16     thresholdBelow1_Val;         /* lowest of bellow */
+    A_INT16     thresholdBelow2_Val;
+    A_INT16     thresholdBelow3_Val;
+    A_INT16     thresholdBelow4_Val;
+    A_INT16     thresholdBelow5_Val;
+    A_INT16     thresholdBelow6_Val;         /* highest of bellow */
+    A_UINT8     weight;                  /* "alpha" */
+    A_UINT8     reserved[3];
+} POSTPACK  WMI_RSSI_THRESHOLD_PARAMS_CMD;
+
+/*
+ *  WMI_SNR_THRESHOLD_PARAMS_CMDID
+ *  Setting the polltime to 0 would disable polling.
+ */
+
+typedef PREPACK struct WMI_SNR_THRESHOLD_PARAMS{
+    A_UINT32    pollTime;               /* Polling time as a factor of LI */
+    A_UINT8     weight;                  /* "alpha" */
+    A_UINT8     thresholdAbove1_Val;      /* lowest of uppper*/
+    A_UINT8     thresholdAbove2_Val;
+    A_UINT8     thresholdAbove3_Val;
+    A_UINT8     thresholdAbove4_Val;      /* highest of upper */
+    A_UINT8     thresholdBelow1_Val;     /* lowest of bellow */
+    A_UINT8     thresholdBelow2_Val;
+    A_UINT8     thresholdBelow3_Val;
+    A_UINT8     thresholdBelow4_Val;     /* highest of bellow */
+    A_UINT8     reserved[3];
+} POSTPACK WMI_SNR_THRESHOLD_PARAMS_CMD;
+
+/*
+ *  WMI_LQ_THRESHOLD_PARAMS_CMDID
+ */
+typedef PREPACK struct WMI_LQ_THRESHOLD_PARAMS {
+    A_UINT8     enable;
+    A_UINT8     thresholdAbove1_Val;
+    A_UINT8     thresholdAbove2_Val;
+    A_UINT8     thresholdAbove3_Val;
+    A_UINT8     thresholdAbove4_Val;
+    A_UINT8     thresholdBelow1_Val;
+    A_UINT8     thresholdBelow2_Val;
+    A_UINT8     thresholdBelow3_Val;
+    A_UINT8     thresholdBelow4_Val;
+    A_UINT8     reserved[3];
+} POSTPACK  WMI_LQ_THRESHOLD_PARAMS_CMD;
+
+typedef enum {
+    WMI_LPREAMBLE_DISABLED = 0,
+    WMI_LPREAMBLE_ENABLED
+} WMI_LPREAMBLE_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8     status;
+}POSTPACK WMI_SET_LPREAMBLE_CMD;
+
+typedef PREPACK struct {
+    A_UINT16    threshold;
+}POSTPACK WMI_SET_RTS_CMD;
+
+/*
+ *  WMI_TARGET_ERROR_REPORT_BITMASK_CMDID
+ *  Sets the error reporting event bitmask in target. Target clears it
+ *  upon an error. Subsequent errors are counted, but not reported
+ *  via event, unless the bitmask is set again.
+ */
+typedef PREPACK struct {
+    A_UINT32    bitmask;
+} POSTPACK  WMI_TARGET_ERROR_REPORT_BITMASK;
+
+/*
+ * WMI_SET_TX_PWR_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     dbM;                  /* in dbM units */
+} POSTPACK WMI_SET_TX_PWR_CMD, WMI_TX_PWR_REPLY;
+
+/*
+ * WMI_SET_ASSOC_INFO_CMDID
+ *
+ * A maximum of 2 private IEs can be sent in the [Re]Assoc request.
+ * A 3rd one, the CCX version IE can also be set from the host.
+ */
+#define WMI_MAX_ASSOC_INFO_TYPE    2
+#define WMI_CCX_VER_IE             2 /* ieType to set CCX Version IE */
+
+#define WMI_MAX_ASSOC_INFO_LEN     240
+
+typedef PREPACK struct {
+    A_UINT8     ieType;
+    A_UINT8     bufferSize;
+    A_UINT8     assocInfo[1];       /* up to WMI_MAX_ASSOC_INFO_LEN */
+} POSTPACK WMI_SET_ASSOC_INFO_CMD;
+
+
+/*
+ * WMI_GET_TX_PWR_CMDID does not take any parameters
+ */
+
+/*
+ * WMI_ADD_BAD_AP_CMDID
+ */
+#define WMI_MAX_BAD_AP_INDEX      1
+
+typedef PREPACK struct {
+    A_UINT8     badApIndex;         /* 0 to WMI_MAX_BAD_AP_INDEX */
+    A_UINT8     bssid[ATH_MAC_LEN];
+} POSTPACK WMI_ADD_BAD_AP_CMD;
+
+/*
+ * WMI_DELETE_BAD_AP_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     badApIndex;         /* 0 to WMI_MAX_BAD_AP_INDEX */
+} POSTPACK WMI_DELETE_BAD_AP_CMD;
+
+/*
+ * WMI_SET_ACCESS_PARAMS_CMDID
+ */
+#define WMI_DEFAULT_TXOP_ACPARAM    0       /* implies one MSDU */
+#define WMI_DEFAULT_ECWMIN_ACPARAM  4       /* corresponds to CWmin of 15 */
+#define WMI_DEFAULT_ECWMAX_ACPARAM  10      /* corresponds to CWmax of 1023 */
+#define WMI_MAX_CW_ACPARAM          15      /* maximum eCWmin or eCWmax */
+#define WMI_DEFAULT_AIFSN_ACPARAM   2
+#define WMI_MAX_AIFSN_ACPARAM       15
+typedef PREPACK struct {
+    A_UINT16 txop;                      /* in units of 32 usec */
+    A_UINT8  eCWmin;
+    A_UINT8  eCWmax;
+    A_UINT8  aifsn;
+} POSTPACK WMI_SET_ACCESS_PARAMS_CMD;
+
+
+/*
+ * WMI_SET_RETRY_LIMITS_CMDID
+ *
+ * This command is used to customize the number of retries the
+ * wlan device will perform on a given frame.
+ */
+#define WMI_MIN_RETRIES 2
+#define WMI_MAX_RETRIES 13
+typedef enum {
+    MGMT_FRAMETYPE    = 0,
+    CONTROL_FRAMETYPE = 1,
+    DATA_FRAMETYPE    = 2
+} WMI_FRAMETYPE;
+
+typedef PREPACK struct {
+    A_UINT8 frameType;                      /* WMI_FRAMETYPE */
+    A_UINT8 trafficClass;                   /* applies only to DATA_FRAMETYPE */
+    A_UINT8 maxRetries;
+    A_UINT8 enableNotify;
+} POSTPACK WMI_SET_RETRY_LIMITS_CMD;
+
+/*
+ * WMI_SET_ROAM_CTRL_CMDID
+ *
+ * This command is used to influence the Roaming behaviour
+ * Set the host biases of the BSSs before setting the roam mode as bias
+ * based.
+ */
+
+/*
+ * Different types of Roam Control
+ */
+
+typedef enum {
+        WMI_FORCE_ROAM          = 1,      /* Roam to the specified BSSID */
+        WMI_SET_ROAM_MODE       = 2,      /* default ,progd bias, no roam */
+        WMI_SET_HOST_BIAS       = 3,     /* Set the Host Bias */
+        WMI_SET_LOWRSSI_SCAN_PARAMS = 4, /* Set lowrssi Scan parameters */
+} WMI_ROAM_CTRL_TYPE;
+
+#define WMI_MIN_ROAM_CTRL_TYPE WMI_FORCE_ROAM
+#define WMI_MAX_ROAM_CTRL_TYPE WMI_SET_LOWRSSI_SCAN_PARAMS
+
+/*
+ * ROAM MODES
+ */
+
+typedef enum {
+        WMI_DEFAULT_ROAM_MODE   = 1,  /* RSSI based ROAM */
+        WMI_HOST_BIAS_ROAM_MODE = 2, /* HOST BIAS based ROAM */
+        WMI_LOCK_BSS_MODE  = 3  /* Lock to the Current BSS - no Roam */
+} WMI_ROAM_MODE;
+
+/*
+ * BSS HOST BIAS INFO
+ */
+
+typedef PREPACK struct {
+        A_UINT8 bssid[ATH_MAC_LEN];
+        A_INT8  bias;
+} POSTPACK WMI_BSS_BIAS;
+
+typedef PREPACK struct {
+        A_UINT8 numBss;
+        WMI_BSS_BIAS bssBias[1];
+} POSTPACK WMI_BSS_BIAS_INFO;
+
+typedef PREPACK struct WMI_LOWRSSI_SCAN_PARAMS {
+        A_UINT16 lowrssi_scan_period;
+        A_INT16  lowrssi_scan_threshold;
+        A_INT16  lowrssi_roam_threshold;
+        A_UINT8  roam_rssi_floor;
+        A_UINT8  reserved[1];              /* For alignment */
+} POSTPACK WMI_LOWRSSI_SCAN_PARAMS;
+
+typedef PREPACK struct {
+    PREPACK union {
+        A_UINT8 bssid[ATH_MAC_LEN]; /* WMI_FORCE_ROAM */
+        A_UINT8 roamMode;           /* WMI_SET_ROAM_MODE  */
+        WMI_BSS_BIAS_INFO bssBiasInfo; /* WMI_SET_HOST_BIAS */
+        WMI_LOWRSSI_SCAN_PARAMS lrScanParams;
+    } POSTPACK info;
+    A_UINT8   roamCtrlType ;
+} POSTPACK WMI_SET_ROAM_CTRL_CMD;
+
+/*
+ * WMI_ENABLE_RM_CMDID
+ */
+typedef PREPACK struct {
+        A_BOOL enable_radio_measurements;
+} POSTPACK WMI_ENABLE_RM_CMD;
+
+/*
+ * WMI_SET_MAX_OFFHOME_DURATION_CMDID
+ */
+typedef PREPACK struct {
+        A_UINT8 max_offhome_duration;
+} POSTPACK WMI_SET_MAX_OFFHOME_DURATION_CMD;
+
+typedef PREPACK struct {
+    A_UINT32 frequency;
+    A_UINT8  threshold;
+} POSTPACK WMI_SET_HB_CHALLENGE_RESP_PARAMS_CMD;
+
+typedef enum {
+    BT_STREAM_UNDEF = 0,
+    BT_STREAM_SCO,             /* SCO stream */
+    BT_STREAM_A2DP,            /* A2DP stream */
+    BT_STREAM_MAX
+} BT_STREAM_TYPE;
+
+typedef enum {
+    BT_PARAM_SCO = 1,         /* SCO stream parameters */
+    BT_PARAM_A2DP,            /* A2DP stream parameters */
+    BT_PARAM_MISC,            /* miscellaneous parameters */
+    BT_PARAM_REGS,            /* co-existence register parameters */
+    BT_PARAM_MAX
+} BT_PARAM_TYPE;
+
+typedef enum {
+    BT_STATUS_UNDEF = 0,
+    BT_STATUS_START,
+    BT_STATUS_STOP,
+    BT_STATUS_RESUME,
+    BT_STATUS_SUSPEND,
+    BT_STATUS_MAX
+} BT_STREAM_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8 streamType;
+    A_UINT8 status;
+} POSTPACK WMI_SET_BT_STATUS_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 noSCOPkts;
+    A_UINT8 pspollTimeout;
+    A_UINT8 stompbt;
+} POSTPACK BT_PARAMS_SCO;
+
+typedef PREPACK struct {
+    A_UINT32 period;
+    A_UINT32 dutycycle;
+    A_UINT8  stompbt;
+} POSTPACK BT_PARAMS_A2DP;
+
+typedef PREPACK struct {
+    A_UINT32 mode;
+    A_UINT32 scoWghts;
+    A_UINT32 a2dpWghts;
+    A_UINT32 genWghts;
+    A_UINT32 mode2;
+    A_UINT8  setVal;
+} POSTPACK BT_COEX_REGS;
+
+typedef enum {
+    WLAN_PROTECT_POLICY = 1,
+    WLAN_COEX_CTRL_FLAGS
+} BT_PARAMS_MISC_TYPE;
+
+typedef enum {
+    WLAN_PROTECT_PER_STREAM = 0x01,   /* default */
+    WLAN_PROTECT_ANY_TX = 0x02
+} WLAN_PROTECT_FLAGS;
+
+
+#define WLAN_DISABLE_COEX_IN_DISCONNECT   0x01 /* default */
+#define WLAN_KEEP_COEX_IN_DISCONNECT      0x02
+#define WLAN_STOMPBT_IN_DISCONNECT        0x04
+
+#define WLAN_DISABLE_COEX_IN_ROAM         0x10 /* default */
+#define WLAN_KEEP_COEX_IN_ROAM            0x20
+#define WLAN_STOMPBT_IN_ROAM              0x40
+
+#define WLAN_DISABLE_COEX_IN_SCAN        0x100 /* default */
+#define WLAN_KEEP_COEX_IN_SCAN           0x200
+#define WLAN_STOMPBT_IN_SCAN             0x400
+
+#define WLAN_DISABLE_COEX_BT_OFF        0x1000 /* default */
+#define WLAN_KEEP_COEX_BT_OFF           0x2000
+#define WLAN_STOMPBT_BT_OFF             0x4000
+
+typedef PREPACK struct {
+    A_UINT32 period;
+    A_UINT32 dutycycle;
+    A_UINT8  stompbt;
+    A_UINT8  policy;
+} POSTPACK WLAN_PROTECT_POLICY_TYPE;
+
+typedef PREPACK struct {
+    PREPACK union {
+        WLAN_PROTECT_POLICY_TYPE protectParams;
+        A_UINT16 wlanCtrlFlags;
+    } POSTPACK info;
+    A_UINT8 paramType;
+} POSTPACK BT_PARAMS_MISC;
+
+typedef PREPACK struct {
+    PREPACK union {
+        BT_PARAMS_SCO scoParams;
+        BT_PARAMS_A2DP a2dpParams;
+        BT_PARAMS_MISC miscParams;
+        BT_COEX_REGS regs;
+    } POSTPACK info;
+    A_UINT8 paramType;
+} POSTPACK WMI_SET_BT_PARAMS_CMD;
+
+/*
+ * Command Replies
+ */
+
+/*
+ * WMI_GET_CHANNEL_LIST_CMDID reply
+ */
+typedef PREPACK struct {
+    A_UINT8     reserved1;
+    A_UINT8     numChannels;            /* number of channels in reply */
+    A_UINT16    channelList[1];         /* channel in Mhz */
+} POSTPACK WMI_CHANNEL_LIST_REPLY;
+
+typedef enum {
+    A_SUCCEEDED = A_OK,
+    A_FAILED_DELETE_STREAM_DOESNOT_EXIST=250,
+    A_SUCCEEDED_MODIFY_STREAM=251,
+    A_FAILED_INVALID_STREAM = 252,
+    A_FAILED_MAX_THINSTREAMS = 253,
+    A_FAILED_CREATE_REMOVE_PSTREAM_FIRST = 254,
+} PSTREAM_REPLY_STATUS;
+
+/*
+ * List of Events (target to host)
+ */
+typedef enum {
+    WMI_READY_EVENTID           = 0x1001,
+    WMI_CONNECT_EVENTID,
+    WMI_DISCONNECT_EVENTID,
+    WMI_BSSINFO_EVENTID,
+    WMI_CMDERROR_EVENTID,
+    WMI_REGDOMAIN_EVENTID,
+    WMI_PSTREAM_TIMEOUT_EVENTID,
+    WMI_NEIGHBOR_REPORT_EVENTID,
+    WMI_TKIP_MICERR_EVENTID,
+    WMI_SCAN_COMPLETE_EVENTID,
+    WMI_REPORT_STATISTICS_EVENTID,
+    WMI_RSSI_THRESHOLD_EVENTID,
+    WMI_ERROR_REPORT_EVENTID,
+    WMI_OPT_RX_FRAME_EVENTID,
+    WMI_REPORT_ROAM_TBL_EVENTID,
+    WMI_EXTENSION_EVENTID,
+    WMI_CAC_EVENTID,
+    WMI_SNR_THRESHOLD_EVENTID,
+    WMI_LQ_THRESHOLD_EVENTID,
+    WMI_TX_RETRY_ERR_EVENTID,
+    WMI_REPORT_ROAM_DATA_EVENTID,
+    WMI_TEST_EVENTID,
+    WMI_APLIST_EVENTID,
+    WMI_GET_WOW_LIST_EVENTID,
+    WMI_GET_PMKID_LIST_EVENTID
+} WMI_EVENT_ID;
+
+typedef enum {
+    WMI_11A_CAPABILITY   = 1,
+    WMI_11G_CAPABILITY   = 2,
+    WMI_11AG_CAPABILITY  = 3,
+} WMI_PHY_CAPABILITY;
+
+typedef PREPACK struct {
+    A_UINT8     macaddr[ATH_MAC_LEN];
+    A_UINT8     phyCapability;              /* WMI_PHY_CAPABILITY */
+} POSTPACK WMI_READY_EVENT;
+
+/*
+ * Connect Event
+ */
+typedef PREPACK struct {
+    A_UINT16    channel;
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT16    listenInterval;
+    A_UINT16    beaconInterval;
+    A_UINT32    networkType;
+    A_UINT8     beaconIeLen;
+    A_UINT8     assocReqLen;
+    A_UINT8     assocRespLen;
+    A_UINT8     assocInfo[1];
+} POSTPACK WMI_CONNECT_EVENT;
+
+/*
+ * Disconnect Event
+ */
+typedef enum {
+    NO_NETWORK_AVAIL   = 0x01,
+    LOST_LINK          = 0x02,     /* bmiss */
+    DISCONNECT_CMD     = 0x03,
+    BSS_DISCONNECTED   = 0x04,
+    AUTH_FAILED        = 0x05,
+    ASSOC_FAILED       = 0x06,
+    NO_RESOURCES_AVAIL = 0x07,
+    CSERV_DISCONNECT   = 0x08,
+    INVALID_PROFILE    = 0x0a,
+    DOT11H_CHANNEL_SWITCH = 0x0b,
+} WMI_DISCONNECT_REASON;
+
+typedef PREPACK struct {
+    A_UINT16    protocolReasonStatus;  /* reason code, see 802.11 spec. */
+    A_UINT8     bssid[ATH_MAC_LEN];    /* set if known */
+    A_UINT8     disconnectReason ;      /* see WMI_DISCONNECT_REASON */
+    A_UINT8     assocRespLen;
+    A_UINT8     assocInfo[1];
+} POSTPACK WMI_DISCONNECT_EVENT;
+
+/*
+ * BSS Info Event.
+ * Mechanism used to inform host of the presence and characteristic of
+ * wireless networks present.  Consists of bss info header followed by
+ * the beacon or probe-response frame body.  The 802.11 header is not included.
+ */
+typedef enum {
+    BEACON_FTYPE = 0x1,
+    PROBERESP_FTYPE,
+    ACTION_MGMT_FTYPE,
+} WMI_BI_FTYPE;
+
+enum {
+    BSS_ELEMID_CHANSWITCH = 0x01,
+    BSS_ELEMID_ATHEROS = 0x02,
+};
+
+typedef PREPACK struct {
+    A_UINT16    channel;
+    A_UINT8     frameType;          /* see WMI_BI_FTYPE */
+    A_UINT8     snr;
+    A_INT16     rssi;
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT32    ieMask;
+} POSTPACK WMI_BSS_INFO_HDR;
+
+/*
+ * Command Error Event
+ */
+typedef enum {
+    INVALID_PARAM  = 0x01,
+    ILLEGAL_STATE  = 0x02,
+    INTERNAL_ERROR = 0x03,
+} WMI_ERROR_CODE;
+
+typedef PREPACK struct {
+    A_UINT16    commandId;
+    A_UINT8     errorCode;
+} POSTPACK WMI_CMD_ERROR_EVENT;
+
+/*
+ * New Regulatory Domain Event
+ */
+typedef PREPACK struct {
+    A_UINT32    regDomain;
+} POSTPACK WMI_REG_DOMAIN_EVENT;
+
+typedef PREPACK struct {
+    A_UINT8     trafficClass;
+} POSTPACK WMI_PSTREAM_TIMEOUT_EVENT;
+
+/*
+ * The WMI_NEIGHBOR_REPORT Event is generated by the target to inform
+ * the host of BSS's it has found that matches the current profile.
+ * It can be used by the host to cache PMKs and/to initiate pre-authentication
+ * if the BSS supports it.  The first bssid is always the current associated
+ * BSS.
+ * The bssid and bssFlags information repeats according to the number
+ * or APs reported.
+ */
+typedef enum {
+    WMI_DEFAULT_BSS_FLAGS   = 0x00,
+    WMI_PREAUTH_CAPABLE_BSS = 0x01,
+    WMI_PMKID_VALID_BSS     = 0x02,
+} WMI_BSS_FLAGS;
+
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT8     bssFlags;            /* see WMI_BSS_FLAGS */
+} POSTPACK WMI_NEIGHBOR_INFO;
+
+typedef PREPACK struct {
+    A_INT8      numberOfAps;
+    WMI_NEIGHBOR_INFO neighbor[1];
+} POSTPACK WMI_NEIGHBOR_REPORT_EVENT;
+
+/*
+ * TKIP MIC Error Event
+ */
+typedef PREPACK struct {
+    A_UINT8 keyid;
+    A_UINT8 ismcast;
+} POSTPACK WMI_TKIP_MICERR_EVENT;
+
+/*
+ * WMI_SCAN_COMPLETE_EVENTID - no parameters (old), staus parameter (new)
+ */
+typedef PREPACK struct {
+    A_STATUS status;
+} POSTPACK WMI_SCAN_COMPLETE_EVENT;
+
+#define MAX_OPT_DATA_LEN 1400
+
+/*
+ * WMI_SET_ADHOC_BSSID_CMDID
+ */
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+} POSTPACK WMI_SET_ADHOC_BSSID_CMD;
+
+/*
+ * WMI_SET_OPT_MODE_CMDID
+ */
+typedef enum {
+    SPECIAL_OFF,
+    SPECIAL_ON,
+} OPT_MODE_TYPE;
+
+typedef PREPACK struct {
+    A_UINT8     optMode;
+} POSTPACK WMI_SET_OPT_MODE_CMD;
+
+/*
+ * WMI_TX_OPT_FRAME_CMDID
+ */
+typedef enum {
+    OPT_PROBE_REQ   = 0x01,
+    OPT_PROBE_RESP  = 0x02,
+    OPT_CPPP_START  = 0x03,
+    OPT_CPPP_STOP   = 0x04,
+} WMI_OPT_FTYPE;
+
+typedef PREPACK struct {
+    A_UINT16    optIEDataLen;
+    A_UINT8     frmType;
+    A_UINT8     dstAddr[ATH_MAC_LEN];
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT8     reserved;               /* For alignment */
+    A_UINT8     optIEData[1];
+} POSTPACK WMI_OPT_TX_FRAME_CMD;
+
+/*
+ * Special frame receive Event.
+ * Mechanism used to inform host of the receiption of the special frames.
+ * Consists of special frame info header followed by special frame body.
+ * The 802.11 header is not included.
+ */
+typedef PREPACK struct {
+    A_UINT16    channel;
+    A_UINT8     frameType;          /* see WMI_OPT_FTYPE */
+    A_INT8      snr;
+    A_UINT8     srcAddr[ATH_MAC_LEN];
+    A_UINT8     bssid[ATH_MAC_LEN];
+} POSTPACK WMI_OPT_RX_INFO_HDR;
+
+/*
+ * Reporting statistics.
+ */
+typedef PREPACK struct {
+    A_UINT32   tx_packets;
+    A_UINT32   tx_bytes;
+    A_UINT32   tx_unicast_pkts;
+    A_UINT32   tx_unicast_bytes;
+    A_UINT32   tx_multicast_pkts;
+    A_UINT32   tx_multicast_bytes;
+    A_UINT32   tx_broadcast_pkts;
+    A_UINT32   tx_broadcast_bytes;
+    A_UINT32   tx_rts_success_cnt;
+    A_UINT32   tx_packet_per_ac[4];
+    A_UINT32   tx_errors_per_ac[4];
+
+    A_UINT32   tx_errors;
+    A_UINT32   tx_failed_cnt;
+    A_UINT32   tx_retry_cnt;
+    A_UINT32   tx_rts_fail_cnt;
+    A_INT32    tx_unicast_rate;
+}POSTPACK tx_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32   rx_packets;
+    A_UINT32   rx_bytes;
+    A_UINT32   rx_unicast_pkts;
+    A_UINT32   rx_unicast_bytes;
+    A_UINT32   rx_multicast_pkts;
+    A_UINT32   rx_multicast_bytes;
+    A_UINT32   rx_broadcast_pkts;
+    A_UINT32   rx_broadcast_bytes;
+    A_UINT32   rx_fragment_pkt;
+
+    A_UINT32   rx_errors;
+    A_UINT32   rx_crcerr;
+    A_UINT32   rx_key_cache_miss;
+    A_UINT32   rx_decrypt_err;
+    A_UINT32   rx_duplicate_frames;
+    A_INT32    rx_unicast_rate;
+}POSTPACK rx_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32   tkip_local_mic_failure;
+    A_UINT32   tkip_counter_measures_invoked;
+    A_UINT32   tkip_replays;
+    A_UINT32   tkip_format_errors;
+    A_UINT32   ccmp_format_errors;
+    A_UINT32   ccmp_replays;
+}POSTPACK tkip_ccmp_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32   power_save_failure_cnt;
+}POSTPACK pm_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32    cs_bmiss_cnt;
+    A_UINT32    cs_lowRssi_cnt;
+    A_UINT16    cs_connect_cnt;
+    A_UINT16    cs_disconnect_cnt;
+    A_INT16     cs_aveBeacon_rssi;
+    A_UINT16    cs_roam_count;
+    A_UINT16    cs_rssi;
+    A_UINT8     cs_snr;
+    A_UINT8     cs_aveBeacon_snr;
+    A_UINT8     cs_lastRoam_msec;
+} POSTPACK cserv_stats_t;
+
+typedef PREPACK struct {
+    tx_stats_t          tx_stats;
+    rx_stats_t          rx_stats;
+    tkip_ccmp_stats_t   tkipCcmpStats;
+}POSTPACK wlan_net_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32    wow_num_pkts_dropped;
+    A_UINT16    wow_num_events_discarded;
+    A_UINT8     wow_num_host_pkt_wakeups;
+    A_UINT8     wow_num_host_event_wakeups;
+} POSTPACK wlan_wow_stats_t;
+
+typedef PREPACK struct {
+    A_UINT32            lqVal;
+    A_INT32             noise_floor_calibation;
+    pm_stats_t          pmStats;
+    wlan_net_stats_t    txrxStats;
+    wlan_wow_stats_t    wowStats;
+    cserv_stats_t       cservStats;
+} POSTPACK WMI_TARGET_STATS;
+
+/*
+ * WMI_RSSI_THRESHOLD_EVENTID.
+ * Indicate the RSSI events to host. Events are indicated when we breach a
+ * thresold value.
+ */
+typedef enum{
+    WMI_RSSI_THRESHOLD1_ABOVE = 0,
+    WMI_RSSI_THRESHOLD2_ABOVE,
+    WMI_RSSI_THRESHOLD3_ABOVE,
+    WMI_RSSI_THRESHOLD4_ABOVE,
+    WMI_RSSI_THRESHOLD5_ABOVE,
+    WMI_RSSI_THRESHOLD6_ABOVE,
+    WMI_RSSI_THRESHOLD1_BELOW,
+    WMI_RSSI_THRESHOLD2_BELOW,
+    WMI_RSSI_THRESHOLD3_BELOW,
+    WMI_RSSI_THRESHOLD4_BELOW,
+    WMI_RSSI_THRESHOLD5_BELOW,
+    WMI_RSSI_THRESHOLD6_BELOW
+}WMI_RSSI_THRESHOLD_VAL;
+
+typedef PREPACK struct {
+    A_INT16 rssi;
+    A_UINT8 range;
+}POSTPACK WMI_RSSI_THRESHOLD_EVENT;
+
+/*
+ *  WMI_ERROR_REPORT_EVENTID
+ */
+typedef enum{
+    WMI_TARGET_PM_ERR_FAIL      = 0x00000001,
+    WMI_TARGET_KEY_NOT_FOUND    = 0x00000002,
+    WMI_TARGET_DECRYPTION_ERR   = 0x00000004,
+    WMI_TARGET_BMISS            = 0x00000008,
+    WMI_PSDISABLE_NODE_JOIN     = 0x00000010,
+    WMI_TARGET_COM_ERR          = 0x00000020,
+    WMI_TARGET_FATAL_ERR        = 0x00000040
+} WMI_TARGET_ERROR_VAL;
+
+typedef PREPACK struct {
+    A_UINT32 errorVal;
+}POSTPACK  WMI_TARGET_ERROR_REPORT_EVENT;
+
+typedef PREPACK struct {
+    A_UINT8 retrys;
+}POSTPACK  WMI_TX_RETRY_ERR_EVENT;
+
+typedef enum{
+    WMI_SNR_THRESHOLD1_ABOVE = 1,
+    WMI_SNR_THRESHOLD1_BELOW,
+    WMI_SNR_THRESHOLD2_ABOVE,
+    WMI_SNR_THRESHOLD2_BELOW,
+    WMI_SNR_THRESHOLD3_ABOVE,
+    WMI_SNR_THRESHOLD3_BELOW,
+    WMI_SNR_THRESHOLD4_ABOVE,
+    WMI_SNR_THRESHOLD4_BELOW
+} WMI_SNR_THRESHOLD_VAL;
+
+typedef PREPACK struct {
+    A_UINT8 range;  /* WMI_SNR_THRESHOLD_VAL */
+    A_UINT8 snr;
+}POSTPACK  WMI_SNR_THRESHOLD_EVENT;
+
+typedef enum{
+    WMI_LQ_THRESHOLD1_ABOVE = 1,
+    WMI_LQ_THRESHOLD1_BELOW,
+    WMI_LQ_THRESHOLD2_ABOVE,
+    WMI_LQ_THRESHOLD2_BELOW,
+    WMI_LQ_THRESHOLD3_ABOVE,
+    WMI_LQ_THRESHOLD3_BELOW,
+    WMI_LQ_THRESHOLD4_ABOVE,
+    WMI_LQ_THRESHOLD4_BELOW
+} WMI_LQ_THRESHOLD_VAL;
+
+typedef PREPACK struct {
+    A_INT32 lq;
+    A_UINT8 range;  /* WMI_LQ_THRESHOLD_VAL */
+}POSTPACK  WMI_LQ_THRESHOLD_EVENT;
+/*
+ * WMI_REPORT_ROAM_TBL_EVENTID
+ */
+#define MAX_ROAM_TBL_CAND   5
+
+typedef PREPACK struct {
+    A_INT32 roam_util;
+    A_UINT8 bssid[ATH_MAC_LEN];
+    A_INT8  rssi;
+    A_INT8  rssidt;
+    A_INT8  last_rssi;
+    A_INT8  util;
+    A_INT8  bias;
+    A_UINT8 reserved; /* For alignment */
+} POSTPACK WMI_BSS_ROAM_INFO;
+
+
+typedef PREPACK struct {
+    A_UINT16  roamMode;
+    A_UINT16  numEntries;
+    WMI_BSS_ROAM_INFO bssRoamInfo[1];
+} POSTPACK WMI_TARGET_ROAM_TBL;
+
+/*
+ *  WMI_CAC_EVENTID
+ */
+typedef enum {
+    CAC_INDICATION_ADMISSION = 0x00,
+    CAC_INDICATION_ADMISSION_RESP = 0x01,
+    CAC_INDICATION_DELETE = 0x02,
+    CAC_INDICATION_NO_RESP = 0x03,
+}CAC_INDICATION;
+
+#define WMM_TSPEC_IE_LEN   63
+
+typedef PREPACK struct {
+    A_UINT8 ac;
+    A_UINT8 cac_indication;
+    A_UINT8 statusCode;
+    A_UINT8 tspecSuggestion[WMM_TSPEC_IE_LEN];
+}POSTPACK  WMI_CAC_EVENT;
+
+/*
+ * WMI_APLIST_EVENTID
+ */
+
+typedef enum {
+    APLIST_VER1 = 1,
+} APLIST_VER;
+
+typedef PREPACK struct {
+    A_UINT8     bssid[ATH_MAC_LEN];
+    A_UINT16    channel;
+} POSTPACK  WMI_AP_INFO_V1;
+
+typedef PREPACK union {
+    WMI_AP_INFO_V1  apInfoV1;
+} POSTPACK WMI_AP_INFO;
+
+typedef PREPACK struct {
+    A_UINT8     apListVer;
+    A_UINT8     numAP;
+    WMI_AP_INFO apList[1];
+} POSTPACK WMI_APLIST_EVENT;
+
+/*
+ * developer commands
+ */
+
+/*
+ * WMI_SET_BITRATE_CMDID
+ *
+ * Get bit rate cmd uses same definition as set bit rate cmd
+ */
+typedef enum {
+    RATE_AUTO   = -1,
+    RATE_1Mb    = 0,
+    RATE_2Mb    = 1,
+    RATE_5_5Mb  = 2,
+    RATE_11Mb   = 3,
+    RATE_6Mb    = 4,
+    RATE_9Mb    = 5,
+    RATE_12Mb   = 6,
+    RATE_18Mb   = 7,
+    RATE_24Mb   = 8,
+    RATE_36Mb   = 9,
+    RATE_48Mb   = 10,
+    RATE_54Mb   = 11,
+} WMI_BIT_RATE;
+
+typedef PREPACK struct {
+    A_INT8      rateIndex;          /* see WMI_BIT_RATE */
+} POSTPACK WMI_BIT_RATE_CMD, WMI_BIT_RATE_REPLY;
+
+/*
+ * WMI_SET_FIXRATES_CMDID
+ *
+ * Get fix rates cmd uses same definition as set fix rates cmd
+ */
+typedef enum {
+    FIX_RATE_1Mb    = 0x1,
+    FIX_RATE_2Mb    = 0x2,
+    FIX_RATE_5_5Mb  = 0x4,
+    FIX_RATE_11Mb   = 0x8,
+    FIX_RATE_6Mb    = 0x10,
+    FIX_RATE_9Mb    = 0x20,
+    FIX_RATE_12Mb   = 0x40,
+    FIX_RATE_18Mb   = 0x80,
+    FIX_RATE_24Mb   = 0x100,
+    FIX_RATE_36Mb   = 0x200,
+    FIX_RATE_48Mb   = 0x400,
+    FIX_RATE_54Mb   = 0x800,
+} WMI_FIX_RATES_MASK;
+
+typedef PREPACK struct {
+    A_UINT16      fixRateMask;          /* see WMI_BIT_RATE */
+} POSTPACK WMI_FIX_RATES_CMD, WMI_FIX_RATES_REPLY;
+
+/*
+ * WMI_SET_RECONNECT_AUTH_MODE_CMDID
+ *
+ * Set authentication mode
+ */
+typedef enum {
+    RECONN_DO_AUTH = 0x00,
+    RECONN_NOT_AUTH = 0x01
+} WMI_AUTH_MODE;
+
+typedef PREPACK struct {
+    A_UINT8 mode;
+} POSTPACK WMI_SET_AUTH_MODE_CMD;
+
+/*
+ * WMI_SET_REASSOC_MODE_CMDID
+ *
+ * Set authentication mode
+ */
+typedef enum {
+    REASSOC_DO_DISASSOC = 0x00,
+    REASSOC_DONOT_DISASSOC = 0x01
+} WMI_REASSOC_MODE;
+
+typedef PREPACK struct {
+    A_UINT8 mode;
+}POSTPACK WMI_SET_REASSOC_MODE_CMD;
+
+typedef enum {
+    ROAM_DATA_TIME = 1,            /* Get The Roam Time Data */
+} ROAM_DATA_TYPE;
+
+typedef PREPACK struct {
+    A_UINT32        disassoc_time;
+    A_UINT32        no_txrx_time;
+    A_UINT32        assoc_time;
+    A_UINT32        allow_txrx_time;
+    A_UINT32        last_data_txrx_time;
+    A_UINT32        first_data_txrx_time;
+    A_UINT8         disassoc_bssid[ATH_MAC_LEN];
+    A_INT8          disassoc_bss_rssi;
+    A_UINT8         assoc_bssid[ATH_MAC_LEN];
+    A_INT8          assoc_bss_rssi;
+} POSTPACK WMI_TARGET_ROAM_TIME;
+
+typedef PREPACK struct {
+    PREPACK union {
+        WMI_TARGET_ROAM_TIME roamTime;
+    } POSTPACK u;
+    A_UINT8 roamDataType ;
+} POSTPACK WMI_TARGET_ROAM_DATA;
+
+typedef enum {
+    WMI_WMM_DISABLED = 0,
+    WMI_WMM_ENABLED
+} WMI_WMM_STATUS;
+
+typedef PREPACK struct {
+    A_UINT8    status;
+}POSTPACK WMI_SET_WMM_CMD;
+
+typedef enum {
+    WMI_TXOP_DISABLED = 0,
+    WMI_TXOP_ENABLED
+} WMI_TXOP_CFG;
+
+typedef PREPACK struct {
+    A_UINT8    txopEnable;
+}POSTPACK WMI_SET_WMM_TXOP_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 keepaliveInterval;
+} POSTPACK WMI_SET_KEEPALIVE_CMD;
+
+typedef PREPACK struct {
+    A_BOOL configured;
+    A_UINT8 keepaliveInterval;
+} POSTPACK WMI_GET_KEEPALIVE_CMD;
+
+/*
+ * Add Application specified IE to a management frame
+ */
+#define WMI_MAX_IE_LEN  78
+
+typedef PREPACK struct {
+    A_UINT8 mgmtFrmType;  /* one of WMI_MGMT_FRAME_TYPE */
+    A_UINT8 ieLen;    /* Length  of the IE that should be added to the MGMT frame */
+    A_UINT8 ieInfo[1];
+} POSTPACK WMI_SET_APPIE_CMD;
+
+/*
+ * Notify the WSC registration status to the target
+ */
+#define WSC_REG_ACTIVE     1
+#define WSC_REG_INACTIVE   0
+/* Generic Hal Interface for setting hal paramters. */
+/* Add new Set HAL Param cmdIds here for newer params */
+typedef enum {
+   WHAL_SETCABTO_CMDID = 1,
+}WHAL_CMDID;
+
+typedef PREPACK struct {
+    A_UINT8 cabTimeOut;
+} POSTPACK WHAL_SETCABTO_PARAM;
+
+typedef PREPACK struct {
+    A_UINT8  whalCmdId;
+    A_UINT8 data[1];
+} POSTPACK WHAL_PARAMCMD;
+
+
+#define WOW_MAX_FILTER_LISTS 1 /*4*/
+#define WOW_MAX_FILTERS_PER_LIST 4
+#define WOW_PATTERN_SIZE 64
+#define WOW_MASK_SIZE 64
+
+typedef PREPACK struct {
+    A_UINT8 wow_valid_filter;
+    A_UINT8 wow_filter_id;
+    A_UINT8 wow_filter_size;
+    A_UINT8 wow_filter_offset;
+    A_UINT8 wow_filter_mask[WOW_MASK_SIZE];
+    A_UINT8 wow_filter_pattern[WOW_PATTERN_SIZE];
+} POSTPACK WOW_FILTER;
+
+
+typedef PREPACK struct {
+    A_UINT8 wow_valid_list;
+    A_UINT8 wow_list_id;
+    A_UINT8 wow_num_filters;
+    A_UINT8 wow_total_list_size;
+    WOW_FILTER list[WOW_MAX_FILTERS_PER_LIST];
+} POSTPACK WOW_FILTER_LIST;
+
+typedef PREPACK struct {
+    A_BOOL awake;
+    A_BOOL asleep;
+} POSTPACK WMI_SET_HOST_SLEEP_MODE_CMD;
+
+typedef PREPACK struct {
+    A_BOOL enable_wow;
+} POSTPACK WMI_SET_WOW_MODE_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 filter_list_id;
+} POSTPACK WMI_GET_WOW_LIST_CMD;
+
+/*
+ * WMI_GET_WOW_LIST_CMD reply
+ */
+typedef PREPACK struct {
+    A_UINT8     num_filters;     /* number of patterns in reply */
+    A_UINT8     this_filter_num; /*  this is filter # x of total num_filters */
+    A_UINT8     wow_mode;
+    A_UINT8     host_mode;
+    WOW_FILTER  wow_filters[1];
+} POSTPACK WMI_GET_WOW_LIST_REPLY;
+
+typedef PREPACK struct {
+    A_UINT8 filter_list_id;
+    A_UINT8 filter_size;
+    A_UINT8 filter_offset;
+    A_UINT8 filter[1];
+} POSTPACK WMI_ADD_WOW_PATTERN_CMD;
+
+typedef PREPACK struct {
+    A_UINT16 filter_list_id;
+    A_UINT16 filter_id;
+} POSTPACK WMI_DEL_WOW_PATTERN_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 macaddr[ATH_MAC_LEN];
+} POSTPACK WMI_SET_MAC_ADDRESS_CMD;
+
+/*
+ * WMI_SET_AKMP_PARAMS_CMD
+ */
+
+#define WMI_AKMP_MULTI_PMKID_EN   0x000001
+
+typedef PREPACK struct {
+    A_UINT32    akmpInfo;
+} POSTPACK WMI_SET_AKMP_PARAMS_CMD;
+
+typedef PREPACK struct {
+    A_UINT8 pmkid[WMI_PMKID_LEN];
+} POSTPACK WMI_PMKID;
+
+/*
+ * WMI_SET_PMKID_LIST_CMD
+ */
+#define WMI_MAX_PMKID_CACHE   8
+
+typedef PREPACK struct {
+    A_UINT32    numPMKID;
+    WMI_PMKID   pmkidList[WMI_MAX_PMKID_CACHE];
+} POSTPACK WMI_SET_PMKID_LIST_CMD;
+
+/*
+ * WMI_GET_PMKID_LIST_CMD  Reply
+ * Following the Number of PMKIDs is the list of PMKIDs
+ */
+typedef PREPACK struct {
+    A_UINT32    numPMKID;
+    WMI_PMKID   pmkidList[1];
+} POSTPACK WMI_PMKID_LIST_REPLY;
+
+/* index used for priority streams */
+typedef enum {
+    WMI_NOT_MAPPED  = -1,
+    WMI_CONTROL_PRI = 0,
+    WMI_BEST_EFFORT_PRI = 1,
+    WMI_LOW_PRI = 2,
+    WMI_HIGH_PRI = 3,
+    WMI_HIGHEST_PRI,
+    WMI_PRI_MAX_COUNT
+} WMI_PRI_STREAM_ID;
+
+#ifndef ATH_TARGET
+#include "athendpack.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMI_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/include/wmix.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wmix.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/include/wmix.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/include/wmix.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,233 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ * $ATH_LICENSE_HOSTSDK0_C$
+ *
+ * This file contains extensions of the WMI protocol specified in the
+ * Wireless Module Interface (WMI).  It includes definitions of all
+ * extended commands and events.  Extensions include useful commands
+ * that are not directly related to wireless activities.  They may
+ * be hardware-specific, and they might not be supported on all
+ * implementations.
+ *
+ * Extended WMIX commands are encapsulated in a WMI message with
+ * cmd=WMI_EXTENSION_CMD.
+ *
+ */
+
+#ifndef _WMIX_H_
+#define _WMIX_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ATH_TARGET
+#include "athstartpack.h"
+#endif
+
+#include "dbglog.h"
+
+/*
+ * Extended WMI commands are those that are needed during wireless
+ * operation, but which are not really wireless commands.  This allows,
+ * for instance, platform-specific commands.  Extended WMI commands are
+ * embedded in a WMI command message with WMI_COMMAND_ID=WMI_EXTENSION_CMDID.
+ * Extended WMI events are similarly embedded in a WMI event message with
+ * WMI_EVENT_ID=WMI_EXTENSION_EVENTID.
+ */
+typedef PREPACK struct {
+    A_UINT32    commandId;
+} POSTPACK WMIX_CMD_HDR;
+
+typedef enum {
+    WMIX_DSETOPEN_REPLY_CMDID           = 0x2001,
+    WMIX_DSETDATA_REPLY_CMDID,
+    WMIX_GPIO_OUTPUT_SET_CMDID,
+    WMIX_GPIO_INPUT_GET_CMDID,
+    WMIX_GPIO_REGISTER_SET_CMDID,
+    WMIX_GPIO_REGISTER_GET_CMDID,
+    WMIX_GPIO_INTR_ACK_CMDID,
+    WMIX_HB_CHALLENGE_RESP_CMDID,
+    WMIX_DBGLOG_CFG_MODULE_CMDID,
+} WMIX_COMMAND_ID;
+
+typedef enum {
+    WMIX_DSETOPENREQ_EVENTID            = 0x3001,
+    WMIX_DSETCLOSE_EVENTID,
+    WMIX_DSETDATAREQ_EVENTID,
+    WMIX_GPIO_INTR_EVENTID,
+    WMIX_GPIO_DATA_EVENTID,
+    WMIX_GPIO_ACK_EVENTID,
+    WMIX_HB_CHALLENGE_RESP_EVENTID,
+    WMIX_DBGLOG_EVENTID,
+} WMIX_EVENT_ID;
+
+/*
+ * =============DataSet support=================
+ */
+
+/*
+ * WMIX_DSETOPENREQ_EVENTID
+ * DataSet Open Request Event
+ */
+typedef PREPACK struct {
+    A_UINT32 dset_id;
+    A_UINT32 targ_dset_handle;  /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_fn;     /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_arg;    /* echo'ed, not used by Host, */
+} POSTPACK WMIX_DSETOPENREQ_EVENT;
+
+/*
+ * WMIX_DSETCLOSE_EVENTID
+ * DataSet Close Event
+ */
+typedef PREPACK struct {
+    A_UINT32 access_cookie;
+} POSTPACK WMIX_DSETCLOSE_EVENT;
+
+/*
+ * WMIX_DSETDATAREQ_EVENTID
+ * DataSet Data Request Event
+ */
+typedef PREPACK struct {
+    A_UINT32 access_cookie;
+    A_UINT32 offset;
+    A_UINT32 length;
+    A_UINT32 targ_buf;         /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_fn;    /* echo'ed, not used by Host, */
+    A_UINT32 targ_reply_arg;   /* echo'ed, not used by Host, */
+} POSTPACK WMIX_DSETDATAREQ_EVENT;
+
+typedef PREPACK struct {
+    A_UINT32              status;
+    A_UINT32              targ_dset_handle;
+    A_UINT32              targ_reply_fn;
+    A_UINT32              targ_reply_arg;
+    A_UINT32              access_cookie;
+    A_UINT32              size;
+    A_UINT32              version;
+} POSTPACK WMIX_DSETOPEN_REPLY_CMD;
+
+typedef PREPACK struct {
+    A_UINT32              status;
+    A_UINT32              targ_buf;
+    A_UINT32              targ_reply_fn;
+    A_UINT32              targ_reply_arg;
+    A_UINT32              length;
+    A_UINT8               buf[1];
+} POSTPACK WMIX_DSETDATA_REPLY_CMD;
+
+
+/*
+ * =============GPIO support=================
+ * All masks are 18-bit masks with bit N operating on GPIO pin N.
+ */
+
+#include "gpio.h"
+
+/*
+ * Set GPIO pin output state.
+ * In order for output to be driven, a pin must be enabled for output.
+ * This can be done during initialization through the GPIO Configuration
+ * DataSet, or during operation with the enable_mask.
+ *
+ * If a request is made to simultaneously set/clear or set/disable or
+ * clear/disable or disable/enable, results are undefined.
+ */
+typedef PREPACK struct {
+    A_UINT32              set_mask;             /* pins to set */
+    A_UINT32              clear_mask;           /* pins to clear */
+    A_UINT32              enable_mask;          /* pins to enable for output */
+    A_UINT32              disable_mask;         /* pins to disable/tristate */
+} POSTPACK WMIX_GPIO_OUTPUT_SET_CMD;
+
+/*
+ * Set a GPIO register.  For debug/exceptional cases.
+ * Values for gpioreg_id are GPIO_REGISTER_IDs, defined in a
+ * platform-dependent header.
+ */
+typedef PREPACK struct {
+    A_UINT32              gpioreg_id;           /* GPIO register ID */
+    A_UINT32              value;                /* value to write */
+} POSTPACK WMIX_GPIO_REGISTER_SET_CMD;
+
+/* Get a GPIO register.  For debug/exceptional cases. */
+typedef PREPACK struct {
+    A_UINT32              gpioreg_id;           /* GPIO register to read */
+} POSTPACK WMIX_GPIO_REGISTER_GET_CMD;
+
+/*
+ * Host acknowledges and re-arms GPIO interrupts.  A single
+ * message should be used to acknowledge all interrupts that
+ * were delivered in an earlier WMIX_GPIO_INTR_EVENT message.
+ */
+typedef PREPACK struct {
+    A_UINT32              ack_mask;             /* interrupts to acknowledge */
+} POSTPACK WMIX_GPIO_INTR_ACK_CMD;
+
+/*
+ * Target informs Host of GPIO interrupts that have ocurred since the
+ * last WMIX_GIPO_INTR_ACK_CMD was received.  Additional information --
+ * the current GPIO input values is provided -- in order to support
+ * use of a GPIO interrupt as a Data Valid signal for other GPIO pins.
+ */
+typedef PREPACK struct {
+    A_UINT32              intr_mask;            /* pending GPIO interrupts */
+    A_UINT32              input_values;         /* recent GPIO input values */
+} POSTPACK WMIX_GPIO_INTR_EVENT;
+
+/*
+ * Target responds to Host's earlier WMIX_GPIO_INPUT_GET_CMDID request
+ * using a GPIO_DATA_EVENT with
+ *   value set to the mask of GPIO pin inputs and
+ *   reg_id set to GPIO_ID_NONE
+ *
+ *
+ * Target responds to Hosts's earlier WMIX_GPIO_REGISTER_GET_CMDID request
+ * using a GPIO_DATA_EVENT with
+ *   value set to the value of the requested register and
+ *   reg_id identifying the register (reflects the original request)
+ * NB: reg_id supports the future possibility of unsolicited
+ * WMIX_GPIO_DATA_EVENTs (for polling GPIO input), and it may
+ * simplify Host GPIO support.
+ */
+typedef PREPACK struct {
+    A_UINT32              value;
+    A_UINT32              reg_id;
+} POSTPACK WMIX_GPIO_DATA_EVENT;
+
+/*
+ * =============Error Detection support=================
+ */
+
+/*
+ * WMIX_HB_CHALLENGE_RESP_CMDID
+ * Heartbeat Challenge Response command
+ */
+typedef PREPACK struct {
+    A_UINT32              cookie;
+    A_UINT32              source;
+} POSTPACK WMIX_HB_CHALLENGE_RESP_CMD;
+
+/*
+ * WMIX_HB_CHALLENGE_RESP_EVENTID
+ * Heartbeat Challenge Response Event
+ */
+#define WMIX_HB_CHALLENGE_RESP_EVENT WMIX_HB_CHALLENGE_RESP_CMD
+
+typedef PREPACK struct {
+    struct dbglog_config_s config;
+} POSTPACK WMIX_DBGLOG_CFG_MODULE_CMD;
+
+#ifndef ATH_TARGET
+#include "athendpack.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMIX_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/Kconfig linux-2.6.29-rc3.owrt.om/drivers/ar6000/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/ar6000/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,31 @@
+config AR6000_WLAN
+        tristate "AR6000 wireless networking over SDIO"
+	depends on MMC
+        select WIRELESS_EXT
+        default m
+        help
+          good luck.
+
+config AR6000_WLAN_DEBUG
+	bool "Enable retrieval of firmware debugging information"
+	depends on AR6000_WLAN
+	default n
+	help
+	  The AR6k firmware maintains a log of debugging events that
+	  gets flushed to the host on various occasions. Retrieval of
+	  this data is very slow, taking several seconds.
+
+	  If in doubt, say N.
+
+config AR6000_WLAN_RESET
+	bool "Soft-reset when shutting down"
+	depends on AR6000_WLAN
+	default n
+	help
+	  The AR6k module can be explicitly reset when shutting down
+	  the device. This adds a delay of about two seconds to suspend,
+	  module removal, and so on. Since the WLAN SDIO function is
+	  generally disabled soon thereafter anyway, this reset seems
+	  superfluous.
+
+	  If in doubt, say N.
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/Makefile linux-2.6.29-rc3.owrt.om/drivers/ar6000/Makefile
--- linux-2.6.29-rc3.owrt/drivers/ar6000/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,38 @@
+REV ?= 2
+
+PWD := $(shell pwd)
+
+EXTRA_CFLAGS += -I$(src)/include
+
+EXTRA_CFLAGS += -DLINUX -D__KERNEL__ -DHTC_RAW_INTERFACE\
+                -DTCMD -DUSER_KEYS \
+                -DNO_SYNC_FLUSH #\
+                -DMULTIPLE_FRAMES_PER_INTERRUPT -DAR6000REV$(REV) \
+                -DBLOCK_TX_PATH_FLAG \
+		-DSDIO \
+
+EXTRA_CFLAGS += -DKERNEL_2_6
+
+obj-$(CONFIG_AR6000_WLAN) += ar6000.o
+
+ar6000-objs += htc/ar6k.o      		   \
+	       htc/ar6k_events.o 	   \
+               htc/htc_send.o       	   \
+               htc/htc_recv.o       	   \
+               htc/htc_services.o          \
+               htc/htc.o     		   \
+               hif/hif2.o     		   \
+               bmi/bmi.o                   \
+               ar6000/ar6000_drv.o         \
+               ar6000/ar6000_raw_if.o	   \
+               ar6000/netbuf.o		   \
+               ar6000/wireless_ext.o	   \
+               ar6000/ioctl.o		   \
+               miscdrv/common_drv.o	   \
+               miscdrv/credit_dist.o	   \
+               wmi/wmi.o                   \
+               wlan/wlan_node.o            \
+               wlan/wlan_recv_beacon.o     \
+               wlan/wlan_utils.o
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/miscdrv/common_drv.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/miscdrv/common_drv.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/miscdrv/common_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/miscdrv/common_drv.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,467 @@
+
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "AR6Khwreg.h"
+#include "targaddrs.h"
+#include "a_osapi.h"
+#include "hif.h"
+#include "htc_api.h"
+#include "bmi.h"
+#include "bmi_msg.h"
+#include "common_drv.h"
+#include "a_debug.h"
+#include "targaddrs.h"
+
+#define HOST_INTEREST_ITEM_ADDRESS(target, item)    \
+(((TargetType) == TARGET_TYPE_AR6001) ?     \
+   AR6001_HOST_INTEREST_ITEM_ADDRESS(item) :    \
+   AR6002_HOST_INTEREST_ITEM_ADDRESS(item))
+
+
+/* Compile the 4BYTE version of the window register setup routine,
+ * This mitigates host interconnect issues with non-4byte aligned bus requests, some
+ * interconnects use bus adapters that impose strict limitations.
+ * Since diag window access is not intended for performance critical operations, the 4byte mode should
+ * be satisfactory even though it generates 4X the bus activity. */
+
+#ifdef USE_4BYTE_REGISTER_ACCESS
+
+    /* set the window address register (using 4-byte register access ). */
+A_STATUS ar6000_SetAddressWindowRegister(HIF_DEVICE *hifDevice, A_UINT32 RegisterAddr, A_UINT32 Address)
+{
+    A_STATUS status;
+    A_UINT8 addrValue[4];
+    int i;
+
+        /* write bytes 1,2,3 of the register to set the upper address bytes, the LSB is written
+         * last to initiate the access cycle */
+
+    for (i = 1; i <= 3; i++) {
+            /* fill the buffer with the address byte value we want to hit 4 times*/
+        addrValue[0] = ((A_UINT8 *)&Address)[i];
+        addrValue[1] = addrValue[0];
+        addrValue[2] = addrValue[0];
+        addrValue[3] = addrValue[0];
+
+            /* hit each byte of the register address with a 4-byte write operation to the same address,
+             * this is a harmless operation */
+        status = HIFReadWrite(hifDevice,
+                              RegisterAddr+i,
+                              addrValue,
+                              4,
+                              HIF_WR_SYNC_BYTE_FIX,
+                              NULL);
+        if (status != A_OK) {
+            break;
+        }
+    }
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write initial bytes of 0x%x to window reg: 0x%X \n",
+             RegisterAddr, Address));
+        return status;
+    }
+
+        /* write the address register again, this time write the whole 4-byte value.
+         * The effect here is that the LSB write causes the cycle to start, the extra
+         * 3 byte write to bytes 1,2,3 has no effect since we are writing the same values again */
+    status = HIFReadWrite(hifDevice,
+                          RegisterAddr,
+                          (A_UCHAR *)(&Address),
+                          4,
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to window reg: 0x%X \n",
+            RegisterAddr, Address));
+        return status;
+    }
+
+    return A_OK;
+
+
+
+}
+
+
+#else
+
+    /* set the window address register */
+A_STATUS ar6000_SetAddressWindowRegister(HIF_DEVICE *hifDevice, A_UINT32 RegisterAddr, A_UINT32 Address)
+{
+    A_STATUS status;
+
+        /* write bytes 1,2,3 of the register to set the upper address bytes, the LSB is written
+         * last to initiate the access cycle */
+    status = HIFReadWrite(hifDevice,
+                          RegisterAddr+1,  /* write upper 3 bytes */
+                          ((A_UCHAR *)(&Address))+1,
+                          sizeof(A_UINT32)-1,
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write initial bytes of 0x%x to window reg: 0x%X \n",
+             RegisterAddr, Address));
+        return status;
+    }
+
+        /* write the LSB of the register, this initiates the operation */
+    status = HIFReadWrite(hifDevice,
+                          RegisterAddr,
+                          (A_UCHAR *)(&Address),
+                          sizeof(A_UINT8),
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to window reg: 0x%X \n",
+            RegisterAddr, Address));
+        return status;
+    }
+
+    return A_OK;
+}
+
+#endif
+
+/*
+ * Read from the AR6000 through its diagnostic window.
+ * No cooperation from the Target is required for this.
+ */
+A_STATUS
+ar6000_ReadRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data)
+{
+    A_STATUS status;
+
+        /* set window register to start read cycle */
+    status = ar6000_SetAddressWindowRegister(hifDevice,
+                                             WINDOW_READ_ADDR_ADDRESS,
+                                             *address);
+
+    if (status != A_OK) {
+        return status;
+    }
+
+        /* read the data */
+    status = HIFReadWrite(hifDevice,
+                          WINDOW_DATA_ADDRESS,
+                          (A_UCHAR *)data,
+                          sizeof(A_UINT32),
+                          HIF_RD_SYNC_BYTE_INC,
+                          NULL);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot read from WINDOW_DATA_ADDRESS\n"));
+        return status;
+    }
+
+    return status;
+}
+
+
+/*
+ * Write to the AR6000 through its diagnostic window.
+ * No cooperation from the Target is required for this.
+ */
+A_STATUS
+ar6000_WriteRegDiag(HIF_DEVICE *hifDevice, A_UINT32 *address, A_UINT32 *data)
+{
+    A_STATUS status;
+
+        /* set write data */
+    status = HIFReadWrite(hifDevice,
+                          WINDOW_DATA_ADDRESS,
+                          (A_UCHAR *)data,
+                          sizeof(A_UINT32),
+                          HIF_WR_SYNC_BYTE_INC,
+                          NULL);
+    if (status != A_OK) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot write 0x%x to WINDOW_DATA_ADDRESS\n", *data));
+        return status;
+    }
+
+        /* set window register, which starts the write cycle */
+    return ar6000_SetAddressWindowRegister(hifDevice,
+                                           WINDOW_WRITE_ADDR_ADDRESS,
+                                           *address);
+}
+
+A_STATUS
+ar6000_ReadDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                    A_UCHAR *data, A_UINT32 length)
+{
+    A_UINT32 count;
+    A_STATUS status = A_OK;
+
+    for (count = 0; count < length; count += 4, address += 4) {
+        if ((status = ar6000_ReadRegDiag(hifDevice, &address,
+                                         (A_UINT32 *)&data[count])) != A_OK)
+        {
+            break;
+        }
+    }
+
+    return status;
+}
+
+A_STATUS
+ar6000_WriteDataDiag(HIF_DEVICE *hifDevice, A_UINT32 address,
+                     A_UCHAR *data, A_UINT32 length)
+{
+    A_UINT32 count;
+    A_STATUS status = A_OK;
+
+    for (count = 0; count < length; count += 4, address += 4) {
+        if ((status = ar6000_WriteRegDiag(hifDevice, &address,
+                                          (A_UINT32 *)&data[count])) != A_OK)
+        {
+            break;
+        }
+    }
+
+    return status;
+}
+
+A_STATUS
+ar6000_reset_device_skipflash(HIF_DEVICE *hifDevice)
+{
+    int i;
+    struct forceROM_s {
+        A_UINT32 addr;
+        A_UINT32 data;
+    };
+    struct forceROM_s *ForceROM;
+    int szForceROM;
+    A_UINT32 instruction;
+
+    static struct forceROM_s ForceROM_REV2[] = {
+        /* NB: This works for old REV2 ROM (old). */
+        {0x00001ff0, 0x175b0027}, /* jump instruction at 0xa0001ff0 */
+        {0x00001ff4, 0x00000000}, /* nop instruction at 0xa0001ff4 */
+
+        {MC_REMAP_TARGET_ADDRESS, 0x00001ff0}, /* remap to 0xa0001ff0 */
+        {MC_REMAP_COMPARE_ADDRESS, 0x01000040},/* ...from 0xbfc00040 */
+        {MC_REMAP_SIZE_ADDRESS, 0x00000000},   /* ...1 cache line */
+        {MC_REMAP_VALID_ADDRESS, 0x00000001},  /* ...remap is valid */
+
+        {LOCAL_COUNT_ADDRESS+0x10, 0}, /* clear BMI credit counter */
+
+        {RESET_CONTROL_ADDRESS, RESET_CONTROL_WARM_RST_MASK},
+    };
+
+    static struct forceROM_s ForceROM_NEW[] = {
+        /* NB: This works for AR6000 ROM REV3 and beyond.  */
+        {LOCAL_SCRATCH_ADDRESS, AR6K_OPTION_IGNORE_FLASH},
+        {LOCAL_COUNT_ADDRESS+0x10, 0}, /* clear BMI credit counter */
+        {RESET_CONTROL_ADDRESS, RESET_CONTROL_WARM_RST_MASK},
+    };
+
+    /*
+     * Examine a semi-arbitrary instruction that's different
+     * in REV2 and other revisions.
+     * NB: If a Host port does not require simultaneous support
+     * for multiple revisions of Target ROM, this code can be elided.
+     */
+    (void)ar6000_ReadDataDiag(hifDevice, 0x01000040,
+                              (A_UCHAR *)&instruction, 4);
+
+    AR_DEBUG_PRINTF(ATH_LOG_ERR, ("instruction=0x%x\n", instruction));
+
+    if (instruction == 0x3c1aa200) {
+        /* It's an old ROM */
+        ForceROM = ForceROM_REV2;
+        szForceROM = sizeof(ForceROM_REV2)/sizeof(*ForceROM);
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Using OLD method\n"));
+    } else {
+        ForceROM = ForceROM_NEW;
+        szForceROM = sizeof(ForceROM_NEW)/sizeof(*ForceROM);
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Using NEW method\n"));
+    }
+
+    AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Force Target to execute from ROM....\n"));
+    for (i = 0; i < szForceROM; i++)
+    {
+        if (ar6000_WriteRegDiag(hifDevice,
+                                &ForceROM[i].addr,
+                                &ForceROM[i].data) != A_OK)
+        {
+            AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Cannot force Target to execute ROM!\n"));
+            return A_ERROR;
+        }
+    }
+
+    msleep(50); /* delay to allow dragon to come to BMI phase  */
+    return A_OK;
+}
+
+/* reset device */
+A_STATUS ar6000_reset_device(HIF_DEVICE *hifDevice, A_UINT32 TargetType)
+{
+
+#if !defined(DWSIM)
+    A_STATUS status = A_OK;
+    A_UINT32 address;
+    A_UINT32 data;
+
+    do {
+
+        // address = RESET_CONTROL_ADDRESS;
+        data = RESET_CONTROL_COLD_RST_MASK;
+
+          /* Hardcode the address of RESET_CONTROL_ADDRESS based on the target type */
+        if (TargetType == TARGET_TYPE_AR6001) {
+            address = 0x0C000000;
+        } else {
+            if (TargetType == TARGET_TYPE_AR6002) {
+                address = 0x00004000;
+            } else {
+                A_ASSERT(0);
+            }
+        }
+
+        status = ar6000_WriteRegDiag(hifDevice, &address, &data);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        /*
+         * Read back the RESET CAUSE register to ensure that the cold reset
+         * went through.
+         */
+        msleep(2000); /* 2 second delay to allow things to settle down */
+
+
+        // address = RESET_CAUSE_ADDRESS;
+        /* Hardcode the address of RESET_CAUSE_ADDRESS based on the target type */
+        if (TargetType == TARGET_TYPE_AR6001) {
+            address = 0x0C0000CC;
+        } else {
+            if (TargetType == TARGET_TYPE_AR6002) {
+                address = 0x000040C0;
+            } else {
+                A_ASSERT(0);
+            }
+        }
+
+        data = 0;
+        status = ar6000_ReadRegDiag(hifDevice, &address, &data);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Reset Cause readback: 0x%X \n",data));
+        data &= RESET_CAUSE_LAST_MASK;
+        if (data != 2) {
+            AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Unable to cold reset the target \n"));
+        }
+
+    } while (FALSE);
+
+    if (A_FAILED(status)) {
+        AR_DEBUG_PRINTF(ATH_LOG_ERR, ("Failed to reset target \n"));
+    }
+#endif
+    return A_OK;
+}
+
+#define REG_DUMP_COUNT_AR6001   38  /* WORDs, derived from AR6001_regdump.h */
+#define REG_DUMP_COUNT_AR6002   32  /* WORDs, derived from AR6002_regdump.h */
+
+
+#if REG_DUMP_COUNT_AR6001 <= REG_DUMP_COUNT_AR6002
+#define REGISTER_DUMP_LEN_MAX  REG_DUMP_COUNT_AR6002
+#else
+#define REGISTER_DUMP_LEN_MAX  REG_DUMP_COUNT_AR6001
+#endif
+
+void ar6000_dump_target_assert_info(HIF_DEVICE *hifDevice, A_UINT32 TargetType)
+{
+    A_UINT32 address;
+    A_UINT32 regDumpArea = 0;
+    A_STATUS status;
+    A_UINT32 regDumpValues[REGISTER_DUMP_LEN_MAX];
+    A_UINT32 regDumpCount = 0;
+    A_UINT32 i;
+
+    do {
+
+            /* the reg dump pointer is copied to the host interest area */
+        address = HOST_INTEREST_ITEM_ADDRESS(TargetType, hi_failure_state);
+
+        if (TargetType == TARGET_TYPE_AR6001) {
+                /* for AR6001, this is a fixed location because the ptr is actually stuck in cache,
+                 * this may be fixed in later firmware versions */
+            address = 0x18a0;
+            regDumpCount = REG_DUMP_COUNT_AR6001;
+
+        } else  if (TargetType == TARGET_TYPE_AR6002) {
+
+            regDumpCount = REG_DUMP_COUNT_AR6002;
+
+        } else {
+            A_ASSERT(0);
+        }
+
+            /* read RAM location through diagnostic window */
+        status = ar6000_ReadRegDiag(hifDevice, &address, &regDumpArea);
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Failed to get ptr to register dump area \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Location of register dump data: 0x%X \n",regDumpArea));
+
+        if (regDumpArea == 0) {
+                /* no reg dump */
+            break;
+        }
+
+        if (TargetType == TARGET_TYPE_AR6001) {
+            regDumpArea &= 0x0FFFFFFF;  /* convert to physical address in target memory */
+        }
+
+            /* fetch register dump data */
+        status = ar6000_ReadDataDiag(hifDevice,
+                                     regDumpArea,
+                                     (A_UCHAR *)&regDumpValues[0],
+                                     regDumpCount * (sizeof(A_UINT32)));
+
+        if (A_FAILED(status)) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Failed to get register dump \n"));
+            break;
+        }
+
+        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,("AR6K: Register Dump: \n"));
+
+        for (i = 0; i < regDumpCount; i++) {
+            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(" %d :  0x%8.8X \n",i, regDumpValues[i]));
+        }
+
+    } while (FALSE);
+
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/miscdrv/credit_dist.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/miscdrv/credit_dist.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/miscdrv/credit_dist.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/miscdrv/credit_dist.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,346 @@
+
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+#include "a_debug.h"
+#include "htc_api.h"
+#include "common_drv.h"
+
+/********* CREDIT DISTRIBUTION FUNCTIONS ******************************************/
+
+#define NO_VO_SERVICE 1 /* currently WMI only uses 3 data streams, so we leave VO service inactive */
+
+#ifdef NO_VO_SERVICE
+#define DATA_SVCS_USED 3
+#else
+#define DATA_SVCS_USED 4
+#endif
+
+static void RedistributeCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                                HTC_ENDPOINT_CREDIT_DIST *pEPDistList);
+
+static void SeekCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                        HTC_ENDPOINT_CREDIT_DIST *pEPDistList);
+
+/* reduce an ep's credits back to a set limit */
+static INLINE void ReduceCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                                HTC_ENDPOINT_CREDIT_DIST  *pEpDist,
+                                int                       Limit)
+{
+    int credits;
+
+        /* set the new limit */
+    pEpDist->TxCreditsAssigned = Limit;
+
+    if (pEpDist->TxCredits <= Limit) {
+        return;
+    }
+
+        /* figure out how much to take away */
+    credits = pEpDist->TxCredits - Limit;
+        /* take them away */
+    pEpDist->TxCredits -= credits;
+    pCredInfo->CurrentFreeCredits += credits;
+}
+
+/* give an endpoint some credits from the free credit pool */
+#define GiveCredits(pCredInfo,pEpDist,credits)      \
+{                                                   \
+    (pEpDist)->TxCredits += (credits);              \
+    (pEpDist)->TxCreditsAssigned += (credits);      \
+    (pCredInfo)->CurrentFreeCredits -= (credits);   \
+}
+
+
+/* default credit init callback.
+ * This function is called in the context of HTCStart() to setup initial (application-specific)
+ * credit distributions */
+static void ar6000_credit_init(void                     *Context,
+                               HTC_ENDPOINT_CREDIT_DIST *pEPList,
+                               int                      TotalCredits)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    int                      count;
+    COMMON_CREDIT_STATE_INFO *pCredInfo = (COMMON_CREDIT_STATE_INFO *)Context;
+
+    pCredInfo->CurrentFreeCredits = TotalCredits;
+    pCredInfo->TotalAvailableCredits = TotalCredits;
+
+    pCurEpDist = pEPList;
+
+        /* run through the list and initialize */
+    while (pCurEpDist != NULL) {
+
+            /* set minimums for each endpoint */
+        pCurEpDist->TxCreditsMin = pCurEpDist->TxCreditsPerMaxMsg;
+
+        if (pCurEpDist->ServiceID == WMI_CONTROL_SVC) {
+                /* give control service some credits */
+            GiveCredits(pCredInfo,pCurEpDist,pCurEpDist->TxCreditsMin);
+                /* control service is always marked active, it never goes inactive EVER */
+            SET_EP_ACTIVE(pCurEpDist);
+        } else if (pCurEpDist->ServiceID == WMI_DATA_BK_SVC) {
+                /* this is the lowest priority data endpoint, save this off for easy access */
+            pCredInfo->pLowestPriEpDist = pCurEpDist;
+        }
+
+        /* Streams have to be created (explicit | implicit)for all kinds
+         * of traffic. BE endpoints are also inactive in the beginning.
+         * When BE traffic starts it creates implicit streams that
+         * redistributes credits.
+         */
+
+        /* note, all other endpoints have minimums set but are initially given NO credits.
+         * Credits will be distributed as traffic activity demands */
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+    if (pCredInfo->CurrentFreeCredits <= 0) {
+        AR_DEBUG_PRINTF(ATH_LOG_INF, ("Not enough credits (%d) to do credit distributions \n", TotalCredits));
+        A_ASSERT(FALSE);
+        return;
+    }
+
+        /* reset list */
+    pCurEpDist = pEPList;
+        /* now run through the list and set max operating credit limits for everyone */
+    while (pCurEpDist != NULL) {
+        if (pCurEpDist->ServiceID == WMI_CONTROL_SVC) {
+                /* control service max is just 1 max message */
+            pCurEpDist->TxCreditsNorm = pCurEpDist->TxCreditsPerMaxMsg;
+        } else {
+                /* for the remaining data endpoints, we assume that each TxCreditsPerMaxMsg are
+                 * the same.
+                 * We use a simple calculation here, we take the remaining credits and
+                 * determine how many max messages this can cover and then set each endpoint's
+                 * normal value equal to half this amount.
+                 * */
+            count = (pCredInfo->CurrentFreeCredits/pCurEpDist->TxCreditsPerMaxMsg) * pCurEpDist->TxCreditsPerMaxMsg;
+            count = count >> 1;
+            count = max(count,pCurEpDist->TxCreditsPerMaxMsg);
+                /* set normal */
+            pCurEpDist->TxCreditsNorm = count;
+
+        }
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+}
+
+
+/* default credit distribution callback
+ * This callback is invoked whenever endpoints require credit distributions.
+ * A lock is held while this function is invoked, this function shall NOT block.
+ * The pEPDistList is a list of distribution structures in prioritized order as
+ * defined by the call to the HTCSetCreditDistribution() api.
+ *
+ */
+static void ar6000_credit_distribute(void                     *Context,
+                                     HTC_ENDPOINT_CREDIT_DIST *pEPDistList,
+                                     HTC_CREDIT_DIST_REASON   Reason)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    COMMON_CREDIT_STATE_INFO *pCredInfo = (COMMON_CREDIT_STATE_INFO *)Context;
+
+    switch (Reason) {
+        case HTC_CREDIT_DIST_SEND_COMPLETE :
+            pCurEpDist = pEPDistList;
+                /* we are given the start of the endpoint distribution list.
+                 * There may be one or more endpoints to service.
+                 * Run through the list and distribute credits */
+            while (pCurEpDist != NULL) {
+
+                if (pCurEpDist->TxCreditsToDist > 0) {
+                        /* return the credits back to the endpoint */
+                    pCurEpDist->TxCredits += pCurEpDist->TxCreditsToDist;
+                        /* always zero out when we are done */
+                    pCurEpDist->TxCreditsToDist = 0;
+
+                    if (pCurEpDist->TxCredits > pCurEpDist->TxCreditsAssigned) {
+                            /* reduce to the assigned limit, previous credit reductions
+                             * could have caused the limit to change */
+                        ReduceCredits(pCredInfo, pCurEpDist, pCurEpDist->TxCreditsAssigned);
+                    }
+
+                    if (pCurEpDist->TxCredits > pCurEpDist->TxCreditsNorm) {
+                            /* oversubscribed endpoints need to reduce back to normal */
+                        ReduceCredits(pCredInfo, pCurEpDist, pCurEpDist->TxCreditsNorm);
+                    }
+                }
+
+                pCurEpDist = pCurEpDist->pNext;
+            }
+
+            A_ASSERT(pCredInfo->CurrentFreeCredits <= pCredInfo->TotalAvailableCredits);
+
+            break;
+
+        case HTC_CREDIT_DIST_ACTIVITY_CHANGE :
+            RedistributeCredits(pCredInfo,pEPDistList);
+            break;
+        case HTC_CREDIT_DIST_SEEK_CREDITS :
+            SeekCredits(pCredInfo,pEPDistList);
+            break;
+        case HTC_DUMP_CREDIT_STATE :
+            AR_DEBUG_PRINTF(ATH_LOG_INF, ("Credit Distribution, total : %d, free : %d\n",
+            								pCredInfo->TotalAvailableCredits, pCredInfo->CurrentFreeCredits));
+            break;
+        default:
+            break;
+
+    }
+
+}
+
+/* redistribute credits based on activity change */
+static void RedistributeCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                                HTC_ENDPOINT_CREDIT_DIST *pEPDistList)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist = pEPDistList;
+
+        /* walk through the list and remove credits from inactive endpoints */
+    while (pCurEpDist != NULL) {
+
+        if (pCurEpDist->ServiceID != WMI_CONTROL_SVC) {
+            if (!IS_EP_ACTIVE(pCurEpDist)) {
+                    /* EP is inactive, reduce credits back to zero */
+                ReduceCredits(pCredInfo, pCurEpDist, 0);
+            }
+        }
+
+        /* NOTE in the active case, we do not need to do anything further,
+         * when an EP goes active and needs credits, HTC will call into
+         * our distribution function using a reason code of HTC_CREDIT_DIST_SEEK_CREDITS  */
+
+        pCurEpDist = pCurEpDist->pNext;
+    }
+
+    A_ASSERT(pCredInfo->CurrentFreeCredits <= pCredInfo->TotalAvailableCredits);
+
+}
+
+/* HTC has an endpoint that needs credits, pEPDist is the endpoint in question */
+static void SeekCredits(COMMON_CREDIT_STATE_INFO *pCredInfo,
+                        HTC_ENDPOINT_CREDIT_DIST *pEPDist)
+{
+    HTC_ENDPOINT_CREDIT_DIST *pCurEpDist;
+    int                      credits = 0;
+    int                      need;
+
+    do {
+
+        if (pEPDist->ServiceID == WMI_CONTROL_SVC) {
+                /* we never oversubscribe on the control service, this is not
+                 * a high performance path and the target never holds onto control
+                 * credits for too long */
+            break;
+        }
+
+        /* for all other services, we follow a simple algorithm of
+         * 1. checking the free pool for credits
+         * 2. checking lower priority endpoints for credits to take */
+
+        if (pCredInfo->CurrentFreeCredits >= 2 * pEPDist->TxCreditsSeek) {
+                /* try to give more credits than it needs */
+            credits = 2 * pEPDist->TxCreditsSeek;
+        } else {
+                /* give what we can */
+            credits = min(pCredInfo->CurrentFreeCredits,pEPDist->TxCreditsSeek);
+        }
+
+        if (credits >= pEPDist->TxCreditsSeek) {
+                /* we found some to fullfill the seek request */
+            break;
+        }
+
+        /* we don't have enough in the free pool, try taking away from lower priority services
+         *
+         * The rule for taking away credits:
+         *   1. Only take from lower priority endpoints
+         *   2. Only take what is allocated above the minimum (never starve an endpoint completely)
+         *   3. Only take what you need.
+         *
+         * */
+
+            /* starting at the lowest priority */
+        pCurEpDist = pCredInfo->pLowestPriEpDist;
+
+            /* work backwards until we hit the endpoint again */
+        while (pCurEpDist != pEPDist) {
+                /* calculate how many we need so far */
+            need = pEPDist->TxCreditsSeek - pCredInfo->CurrentFreeCredits;
+
+            if ((pCurEpDist->TxCreditsAssigned - need) > pCurEpDist->TxCreditsMin) {
+                    /* the current one has been allocated more than it's minimum and it
+                     * has enough credits assigned above it's minimum to fullfill our need
+                     * try to take away just enough to fullfill our need */
+                ReduceCredits(pCredInfo,
+                              pCurEpDist,
+                              pCurEpDist->TxCreditsAssigned - need);
+
+                if (pCredInfo->CurrentFreeCredits >= pEPDist->TxCreditsSeek) {
+                        /* we have enough */
+                    break;
+                }
+            }
+
+            pCurEpDist = pCurEpDist->pPrev;
+        }
+
+            /* return what we can get */
+        credits = min(pCredInfo->CurrentFreeCredits,pEPDist->TxCreditsSeek);
+
+    } while (FALSE);
+
+        /* did we find some credits? */
+    if (credits) {
+            /* give what we can */
+        GiveCredits(pCredInfo, pEPDist, credits);
+    }
+
+}
+
+/* initialize and setup credit distribution */
+A_STATUS ar6000_setup_credit_dist(HTC_HANDLE HTCHandle, COMMON_CREDIT_STATE_INFO *pCredInfo)
+{
+    HTC_SERVICE_ID servicepriority[5];
+
+    A_MEMZERO(pCredInfo,sizeof(COMMON_CREDIT_STATE_INFO));
+
+    servicepriority[0] = WMI_CONTROL_SVC;  /* highest */
+    servicepriority[1] = WMI_DATA_VO_SVC;
+    servicepriority[2] = WMI_DATA_VI_SVC;
+    servicepriority[3] = WMI_DATA_BE_SVC;
+    servicepriority[4] = WMI_DATA_BK_SVC; /* lowest */
+
+        /* set callbacks and priority list */
+    HTCSetCreditDistribution(HTCHandle,
+                             pCredInfo,
+                             ar6000_credit_distribute,
+                             ar6000_credit_init,
+                             servicepriority,
+                             5);
+
+    return A_OK;
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/wlan/wlan_node.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/wlan/wlan_node.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/wlan/wlan_node.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/wlan/wlan_node.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,371 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * Copyright (c) 2004-2005 Atheros Communications
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wlan/src/wlan_node.c#1 $
+ */
+/*
+ * IEEE 802.11 node handling support.
+ */
+#include <a_config.h>
+#include <athdefs.h>
+#include <a_types.h>
+#include <a_osapi.h>
+#include <a_debug.h>
+#include <ieee80211.h>
+#include <wlan_api.h>
+#include <ieee80211_node.h>
+#include <htc_api.h>
+#include <wmi.h>
+#include <wmi_api.h>
+
+static void wlan_node_timeout(A_ATH_TIMER arg);
+static bss_t * _ieee80211_find_node(struct ieee80211_node_table *nt,
+                                    const A_UINT8 *macaddr);
+
+bss_t *
+wlan_node_alloc(struct ieee80211_node_table *nt, int wh_size)
+{
+    bss_t *ni;
+
+    ni = A_MALLOC_NOWAIT(sizeof(bss_t));
+
+    if (ni != NULL) {
+        ni->ni_buf = A_MALLOC_NOWAIT(wh_size);
+        if (ni->ni_buf == NULL) {
+            A_FREE(ni);
+            ni = NULL;
+            return ni;
+        }
+    } else {
+        return ni;
+    }
+
+    /* Make sure our lists are clean */
+    ni->ni_list_next = NULL;
+    ni->ni_list_prev = NULL;
+    ni->ni_hash_next = NULL;
+    ni->ni_hash_prev = NULL;
+
+    //
+    // ni_scangen never initialized before and during suspend/resume of winmobile, customer (LG/SEMCO) identified
+    // that some junk has been stored in this, due to this scan list didn't properly updated
+    //
+    ni->ni_scangen	 = 0;
+
+    return ni;
+}
+
+void
+wlan_node_free(bss_t *ni)
+{
+    if (ni->ni_buf != NULL) {
+        A_FREE(ni->ni_buf);
+    }
+    A_FREE(ni);
+}
+
+void
+wlan_setup_node(struct ieee80211_node_table *nt, bss_t *ni,
+                const A_UINT8 *macaddr)
+{
+    int hash;
+
+    A_MEMCPY(ni->ni_macaddr, macaddr, IEEE80211_ADDR_LEN);
+    hash = IEEE80211_NODE_HASH(macaddr);
+    ieee80211_node_initref(ni);     /* mark referenced */
+
+    ni->ni_tstamp = A_GET_MS(WLAN_NODE_INACT_TIMEOUT_MSEC);
+    IEEE80211_NODE_LOCK_BH(nt);
+
+    /* Insert at the end of the node list */
+    ni->ni_list_next = NULL;
+    ni->ni_list_prev = nt->nt_node_last;
+    if(nt->nt_node_last != NULL)
+    {
+        nt->nt_node_last->ni_list_next = ni;
+    }
+    nt->nt_node_last = ni;
+    if(nt->nt_node_first == NULL)
+    {
+        nt->nt_node_first = ni;
+    }
+
+    /* Insert into the hash list i.e. the bucket */
+    if((ni->ni_hash_next = nt->nt_hash[hash]) != NULL)
+    {
+        nt->nt_hash[hash]->ni_hash_prev = ni;
+    }
+    ni->ni_hash_prev = NULL;
+    nt->nt_hash[hash] = ni;
+
+    if (!nt->isTimerArmed) {
+        A_TIMEOUT_MS(&nt->nt_inact_timer, WLAN_NODE_INACT_TIMEOUT_MSEC, 0);
+        nt->isTimerArmed = TRUE;
+    }
+
+    IEEE80211_NODE_UNLOCK_BH(nt);
+}
+
+static bss_t *
+_ieee80211_find_node(struct ieee80211_node_table *nt,
+    const A_UINT8 *macaddr)
+{
+    bss_t *ni;
+    int hash;
+
+    IEEE80211_NODE_LOCK_ASSERT(nt);
+
+    hash = IEEE80211_NODE_HASH(macaddr);
+    for(ni = nt->nt_hash[hash]; ni; ni = ni->ni_hash_next) {
+        if (IEEE80211_ADDR_EQ(ni->ni_macaddr, macaddr)) {
+            ieee80211_node_incref(ni);  /* mark referenced */
+            return ni;
+        }
+    }
+    return NULL;
+}
+
+bss_t *
+wlan_find_node(struct ieee80211_node_table *nt, const A_UINT8 *macaddr)
+{
+    bss_t *ni;
+
+    IEEE80211_NODE_LOCK(nt);
+    ni = _ieee80211_find_node(nt, macaddr);
+    IEEE80211_NODE_UNLOCK(nt);
+    return ni;
+}
+
+/*
+ * Reclaim a node.  If this is the last reference count then
+ * do the normal free work.  Otherwise remove it from the node
+ * table and mark it gone by clearing the back-reference.
+ */
+void
+wlan_node_reclaim(struct ieee80211_node_table *nt, bss_t *ni)
+{
+    IEEE80211_NODE_LOCK(nt);
+
+    if(ni->ni_list_prev == NULL)
+    {
+        /* First in list so fix the list head */
+        nt->nt_node_first = ni->ni_list_next;
+    }
+    else
+    {
+        ni->ni_list_prev->ni_list_next = ni->ni_list_next;
+    }
+
+    if(ni->ni_list_next == NULL)
+    {
+        /* Last in list so fix list tail */
+        nt->nt_node_last = ni->ni_list_prev;
+    }
+    else
+    {
+        ni->ni_list_next->ni_list_prev = ni->ni_list_prev;
+    }
+
+    if(ni->ni_hash_prev == NULL)
+    {
+        /* First in list so fix the list head */
+        int hash;
+        hash = IEEE80211_NODE_HASH(ni->ni_macaddr);
+        nt->nt_hash[hash] = ni->ni_hash_next;
+    }
+    else
+    {
+        ni->ni_hash_prev->ni_hash_next = ni->ni_hash_next;
+    }
+
+    if(ni->ni_hash_next != NULL)
+    {
+        ni->ni_hash_next->ni_hash_prev = ni->ni_hash_prev;
+    }
+    wlan_node_free(ni);
+
+    IEEE80211_NODE_UNLOCK(nt);
+}
+
+static void
+wlan_node_dec_free(bss_t *ni)
+{
+    if (ieee80211_node_dectestref(ni)) {
+        wlan_node_free(ni);
+    }
+}
+
+void
+wlan_free_allnodes(struct ieee80211_node_table *nt)
+{
+    bss_t *ni;
+
+    while ((ni = nt->nt_node_first) != NULL) {
+        wlan_node_reclaim(nt, ni);
+    }
+}
+
+void
+wlan_iterate_nodes(struct ieee80211_node_table *nt, wlan_node_iter_func *f,
+                   void *arg)
+{
+    bss_t *ni;
+    A_UINT32 gen;
+
+    gen = ++nt->nt_scangen;
+
+    IEEE80211_NODE_LOCK(nt);
+    for (ni = nt->nt_node_first; ni; ni = ni->ni_list_next) {
+        if (ni->ni_scangen != gen) {
+            ni->ni_scangen = gen;
+            (void) ieee80211_node_incref(ni);
+            (*f)(arg, ni);
+            wlan_node_dec_free(ni);
+        }
+    }
+    IEEE80211_NODE_UNLOCK(nt);
+}
+
+/*
+ * Node table support.
+ */
+void
+wlan_node_table_init(void *wmip, struct ieee80211_node_table *nt)
+{
+    int i;
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN, ("node table = 0x%x\n", (A_UINT32)nt));
+    IEEE80211_NODE_LOCK_INIT(nt);
+
+    nt->nt_node_first = nt->nt_node_last = NULL;
+    for(i = 0; i < IEEE80211_NODE_HASHSIZE; i++)
+    {
+        nt->nt_hash[i] = NULL;
+    }
+    A_INIT_TIMER(&nt->nt_inact_timer, wlan_node_timeout, nt);
+    nt->isTimerArmed = FALSE;
+    nt->nt_wmip = wmip;
+}
+
+static void
+wlan_node_timeout(A_ATH_TIMER arg)
+{
+    struct ieee80211_node_table *nt = (struct ieee80211_node_table *)arg;
+    bss_t *bss, *nextBss;
+    A_UINT8 myBssid[IEEE80211_ADDR_LEN], reArmTimer = FALSE;
+
+    wmi_get_current_bssid(nt->nt_wmip, myBssid);
+
+    bss = nt->nt_node_first;
+    while (bss != NULL)
+    {
+        nextBss = bss->ni_list_next;
+        if (A_MEMCMP(myBssid, bss->ni_macaddr, sizeof(myBssid)) != 0)
+        {
+
+            if (bss->ni_tstamp <= A_GET_MS(0))
+            {
+               /*
+                * free up all but the current bss - if set
+                */
+                wlan_node_reclaim(nt, bss);
+            }
+            else
+            {
+                /*
+                 * Re-arm timer, only when we have a bss other than
+                 * current bss AND it is not aged-out.
+                 */
+                reArmTimer = TRUE;
+            }
+        }
+        bss = nextBss;
+    }
+
+    if(reArmTimer)
+        A_TIMEOUT_MS(&nt->nt_inact_timer, WLAN_NODE_INACT_TIMEOUT_MSEC, 0);
+
+    nt->isTimerArmed = reArmTimer;
+}
+
+void
+wlan_node_table_cleanup(struct ieee80211_node_table *nt)
+{
+    A_UNTIMEOUT(&nt->nt_inact_timer);
+    A_DELETE_TIMER(&nt->nt_inact_timer);
+    wlan_free_allnodes(nt);
+    IEEE80211_NODE_LOCK_DESTROY(nt);
+}
+
+bss_t *
+wlan_find_Ssidnode (struct ieee80211_node_table *nt, A_UCHAR *pSsid,
+					A_UINT32 ssidLength, A_BOOL bIsWPA2)
+{
+    bss_t   *ni = NULL;
+	A_UCHAR *pIESsid = NULL;
+
+    IEEE80211_NODE_LOCK (nt);
+
+    for (ni = nt->nt_node_first; ni; ni = ni->ni_list_next) {
+		pIESsid = ni->ni_cie.ie_ssid;
+		if (pIESsid[1] <= 32) {
+
+			// Step 1 : Check SSID
+			if (0x00 == memcmp (pSsid, &pIESsid[2], ssidLength)) {
+
+				// Step 2 : if SSID matches, check WPA or WPA2
+				if (TRUE == bIsWPA2 && NULL != ni->ni_cie.ie_rsn) {
+					ieee80211_node_incref (ni);  /* mark referenced */
+					IEEE80211_NODE_UNLOCK (nt);
+					return ni;
+				}
+				if (FALSE == bIsWPA2 && NULL != ni->ni_cie.ie_wpa) {
+					ieee80211_node_incref(ni);  /* mark referenced */
+					IEEE80211_NODE_UNLOCK (nt);
+					return ni;
+				}
+			}
+		}
+    }
+
+    IEEE80211_NODE_UNLOCK (nt);
+
+    return NULL;
+}
+
+void
+wlan_node_return (struct ieee80211_node_table *nt, bss_t *ni)
+{
+	IEEE80211_NODE_LOCK (nt);
+	wlan_node_dec_free (ni);
+	IEEE80211_NODE_UNLOCK (nt);
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/wlan/wlan_recv_beacon.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/wlan/wlan_recv_beacon.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/wlan/wlan_recv_beacon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/wlan/wlan_recv_beacon.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,192 @@
+/*-
+ * Copyright (c) 2001 Atsushi Onoe
+ * Copyright (c) 2002-2004 Sam Leffler, Errno Consulting
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/*
+ * IEEE 802.11 input handling.
+ */
+
+#include "a_config.h"
+#include "athdefs.h"
+#include "a_types.h"
+#include "a_osapi.h"
+#include <wmi.h>
+#include <ieee80211.h>
+#include <wlan_api.h>
+
+#define IEEE80211_VERIFY_LENGTH(_len, _minlen) do {         \
+    if ((_len) < (_minlen)) {                   \
+        return A_EINVAL;                         \
+    }                               \
+} while (0)
+
+#define IEEE80211_VERIFY_ELEMENT(__elem, __maxlen) do {         \
+    if ((__elem) == NULL) {                     \
+        return A_EINVAL;                         \
+    }                               \
+    if ((__elem)[1] > (__maxlen)) {                 \
+        return A_EINVAL;                         \
+    }                               \
+} while (0)
+
+
+/* unaligned little endian access */
+#define LE_READ_2(p)                            \
+    ((A_UINT16)                            \
+     ((((A_UINT8 *)(p))[0]      ) | (((A_UINT8 *)(p))[1] <<  8)))
+
+#define LE_READ_4(p)                            \
+    ((A_UINT32)                            \
+     ((((A_UINT8 *)(p))[0]      ) | (((A_UINT8 *)(p))[1] <<  8) | \
+      (((A_UINT8 *)(p))[2] << 16) | (((A_UINT8 *)(p))[3] << 24)))
+
+
+static int __inline
+iswpaoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((WPA_OUI_TYPE<<24)|WPA_OUI);
+}
+
+static int __inline
+iswmmoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((WMM_OUI_TYPE<<24)|WMM_OUI);
+}
+
+static int __inline
+iswmmparam(const A_UINT8 *frm)
+{
+    return frm[1] > 5 && frm[6] == WMM_PARAM_OUI_SUBTYPE;
+}
+
+static int __inline
+iswmminfo(const A_UINT8 *frm)
+{
+    return frm[1] > 5 && frm[6] == WMM_INFO_OUI_SUBTYPE;
+}
+
+static int __inline
+isatherosoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((ATH_OUI_TYPE<<24)|ATH_OUI);
+}
+
+static int __inline
+iswscoui(const A_UINT8 *frm)
+{
+    return frm[1] > 3 && LE_READ_4(frm+2) == ((0x04<<24)|WPA_OUI);
+}
+
+A_STATUS
+wlan_parse_beacon(A_UINT8 *buf, int framelen, struct ieee80211_common_ie *cie)
+{
+    A_UINT8 *frm, *efrm;
+
+    frm = buf;
+    efrm = (A_UINT8 *) (frm + framelen);
+
+    /*
+     * beacon/probe response frame format
+     *  [8] time stamp
+     *  [2] beacon interval
+     *  [2] capability information
+     *  [tlv] ssid
+     *  [tlv] supported rates
+     *  [tlv] country information
+     *  [tlv] parameter set (FH/DS)
+     *  [tlv] erp information
+     *  [tlv] extended supported rates
+     *  [tlv] WMM
+     *  [tlv] WPA or RSN
+     *  [tlv] Atheros Advanced Capabilities
+     */
+    IEEE80211_VERIFY_LENGTH(efrm - frm, 12);
+    A_MEMZERO(cie, sizeof(*cie));
+
+    cie->ie_tstamp = frm; frm += 8;
+    cie->ie_beaconInt = A_LE2CPU16(*(A_UINT16 *)frm);  frm += 2;
+    cie->ie_capInfo = A_LE2CPU16(*(A_UINT16 *)frm);  frm += 2;
+    cie->ie_chan = 0;
+
+    while (frm < efrm) {
+        switch (*frm) {
+        case IEEE80211_ELEMID_SSID:
+            cie->ie_ssid = frm;
+            break;
+        case IEEE80211_ELEMID_RATES:
+            cie->ie_rates = frm;
+            break;
+        case IEEE80211_ELEMID_COUNTRY:
+            cie->ie_country = frm;
+            break;
+        case IEEE80211_ELEMID_FHPARMS:
+            break;
+        case IEEE80211_ELEMID_DSPARMS:
+            cie->ie_chan = frm[2];
+            break;
+        case IEEE80211_ELEMID_TIM:
+            cie->ie_tim = frm;
+            break;
+        case IEEE80211_ELEMID_IBSSPARMS:
+            break;
+        case IEEE80211_ELEMID_XRATES:
+            cie->ie_xrates = frm;
+            break;
+        case IEEE80211_ELEMID_ERP:
+            if (frm[1] != 1) {
+                //A_PRINTF("Discarding ERP Element - Bad Len\n");
+                return A_EINVAL;
+            }
+            cie->ie_erp = frm[2];
+            break;
+        case IEEE80211_ELEMID_RSN:
+            cie->ie_rsn = frm;
+            break;
+        case IEEE80211_ELEMID_VENDOR:
+            if (iswpaoui(frm)) {
+                cie->ie_wpa = frm;
+            } else if (iswmmoui(frm)) {
+                cie->ie_wmm = frm;
+            } else if (isatherosoui(frm)) {
+                cie->ie_ath = frm;
+            } else if(iswscoui(frm)) {
+                cie->ie_wsc = frm;
+            }
+            break;
+        default:
+            break;
+        }
+        frm += frm[1] + 2;
+    }
+    IEEE80211_VERIFY_ELEMENT(cie->ie_rates, IEEE80211_RATE_MAXSIZE);
+    IEEE80211_VERIFY_ELEMENT(cie->ie_ssid, IEEE80211_NWID_LEN);
+
+    return A_OK;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/wlan/wlan_utils.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/wlan/wlan_utils.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/wlan/wlan_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/wlan/wlan_utils.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2004-2005 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This module implements frequently used wlan utilies
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wlan/src/wlan_utils.c#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include <a_config.h>
+#include <athdefs.h>
+#include <a_types.h>
+#include <a_osapi.h>
+
+/*
+ * converts ieee channel number to frequency
+ */
+A_UINT16
+wlan_ieee2freq(int chan)
+{
+    if (chan == 14) {
+        return 2484;
+    }
+    if (chan < 14) {    /* 0-13 */
+        return (2407 + (chan*5));
+    }
+    if (chan < 27) {    /* 15-26 */
+        return (2512 + ((chan-15)*20));
+    }
+    return (5000 + (chan*5));
+}
+
+/*
+ * Converts MHz frequency to IEEE channel number.
+ */
+A_UINT32
+wlan_freq2ieee(A_UINT16 freq)
+{
+    if (freq == 2484)
+        return 14;
+    if (freq < 2484)
+        return (freq - 2407) / 5;
+    if (freq < 5000)
+        return 15 + ((freq - 2512) / 20);
+    return (freq - 5000) / 5;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/wmi/wmi.c linux-2.6.29-rc3.owrt.om/drivers/ar6000/wmi/wmi.c
--- linux-2.6.29-rc3.owrt/drivers/ar6000/wmi/wmi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/wmi/wmi.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,3954 @@
+/*
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This module implements the hardware independent layer of the
+ * Wireless Module Interface (WMI) protocol.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wmi/wmi.c#3 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#include <a_config.h>
+#include <athdefs.h>
+#include <a_types.h>
+#include <a_osapi.h>
+#include "htc.h"
+#include "htc_api.h"
+#include "wmi.h"
+#include <ieee80211.h>
+#include <ieee80211_node.h>
+#include <wlan_api.h>
+#include <wmi_api.h>
+#include "dset_api.h"
+#include "gpio_api.h"
+#include "wmi_host.h"
+#include "a_drv.h"
+#include "a_drv_api.h"
+#include "a_debug.h"
+#include "dbglog_api.h"
+
+static A_STATUS wmi_ready_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS wmi_connect_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_disconnect_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                        int len);
+static A_STATUS wmi_tkip_micerr_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                        int len);
+static A_STATUS wmi_bssInfo_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_opt_frame_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                       int len);
+static A_STATUS wmi_pstream_timeout_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_sync_point(struct wmi_t *wmip);
+
+static A_STATUS wmi_bitrate_reply_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_ratemask_reply_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_channelList_reply_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                         int len);
+static A_STATUS wmi_regDomain_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                       int len);
+static A_STATUS wmi_txPwr_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_neighborReport_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                             int len);
+
+static A_STATUS wmi_dset_open_req_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+#ifdef CONFIG_HOST_DSET_SUPPORT
+static A_STATUS wmi_dset_close_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_dset_data_req_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+
+
+static A_STATUS wmi_scanComplete_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                     int len);
+static A_STATUS wmi_errorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_statsEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_rssiThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_hbChallengeResp_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_reportErrorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_cac_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_roam_tbl_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                      int len);
+static A_STATUS wmi_roam_data_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                      int len);
+static A_STATUS wmi_get_wow_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap,
+                                      int len);
+static A_STATUS
+wmi_get_pmkid_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap, A_UINT32 len);
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+static A_STATUS wmi_gpio_intr_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_gpio_data_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+static A_STATUS wmi_gpio_ack_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+static A_STATUS
+wmi_tcmd_test_report_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+#endif
+
+static A_STATUS
+wmi_txRetryErrEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS
+wmi_snrThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS
+wmi_lqThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_BOOL
+wmi_is_bitrate_index_valid(struct wmi_t *wmip, A_UINT32 rateIndex);
+
+static A_STATUS
+wmi_aplistEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS
+wmi_dbglog_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+static A_STATUS wmi_keepalive_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len);
+
+int wps_enable;
+static const A_INT32 wmi_rateTable[] = {
+    1000,
+    2000,
+    5500,
+    11000,
+    6000,
+    9000,
+    12000,
+    18000,
+    24000,
+    36000,
+    48000,
+    54000,
+    0};
+
+#define MODE_A_SUPPORT_RATE_START       4
+#define MODE_A_SUPPORT_RATE_STOP        11
+
+#define MODE_GONLY_SUPPORT_RATE_START   MODE_A_SUPPORT_RATE_START
+#define MODE_GONLY_SUPPORT_RATE_STOP    MODE_A_SUPPORT_RATE_STOP
+
+#define MODE_B_SUPPORT_RATE_START       0
+#define MODE_B_SUPPORT_RATE_STOP        3
+
+#define MODE_G_SUPPORT_RATE_START       0
+#define MODE_G_SUPPORT_RATE_STOP        11
+
+#define MAX_NUMBER_OF_SUPPORT_RATES     (MODE_G_SUPPORT_RATE_STOP + 1)
+
+/* 802.1d to AC mapping. Refer pg 57 of WMM-test-plan-v1.2 */
+const A_UINT8 up_to_ac[]= {
+                WMM_AC_BE,
+                WMM_AC_BK,
+                WMM_AC_BK,
+                WMM_AC_BE,
+                WMM_AC_VI,
+                WMM_AC_VI,
+                WMM_AC_VO,
+                WMM_AC_VO,
+            };
+
+void *
+wmi_init(void *devt)
+{
+    struct wmi_t *wmip;
+
+    wmip = A_MALLOC(sizeof(struct wmi_t));
+    if (wmip == NULL) {
+        return (NULL);
+    }
+    A_MEMZERO(wmip, sizeof(*wmip));
+    A_MUTEX_INIT(&wmip->wmi_lock);
+    wmip->wmi_devt = devt;
+    wlan_node_table_init(wmip, &wmip->wmi_scan_table);
+    wmi_qos_state_init(wmip);
+    wmip->wmi_powerMode = REC_POWER;
+    wmip->wmi_phyMode = WMI_11G_MODE;
+
+    return (wmip);
+}
+
+void
+wmi_qos_state_init(struct wmi_t *wmip)
+{
+    A_UINT8 i;
+
+    if (wmip == NULL) {
+        return;
+    }
+    LOCK_WMI(wmip);
+
+    /* Initialize QoS States */
+    wmip->wmi_numQoSStream = 0;
+
+    wmip->wmi_fatPipeExists = 0;
+
+    for (i=0; i < WMM_NUM_AC; i++) {
+        wmip->wmi_streamExistsForAC[i]=0;
+    }
+
+        /* Initialize the static Wmi stream Pri to WMM AC mappings Arrays */
+    WMI_INIT_WMISTREAM_AC_MAP(wmip);
+
+    UNLOCK_WMI(wmip);
+
+    A_WMI_SET_NUMDATAENDPTS(wmip->wmi_devt, 1);
+}
+
+void
+wmi_shutdown(struct wmi_t *wmip)
+{
+    if (wmip != NULL) {
+        wlan_node_table_cleanup(&wmip->wmi_scan_table);
+        if (A_IS_MUTEX_VALID(&wmip->wmi_lock)) {
+            A_MUTEX_DELETE(&wmip->wmi_lock);
+        }
+        A_FREE(wmip);
+    }
+}
+
+/*
+ *  performs DIX to 802.3 encapsulation for transmit packets.
+ *  uses passed in buffer.  Returns buffer or NULL if failed.
+ *  Assumes the entire DIX header is contigous and that there is
+ *  enough room in the buffer for a 802.3 mac header and LLC+SNAP headers.
+ */
+A_STATUS
+wmi_dix_2_dot3(struct wmi_t *wmip, void *osbuf)
+{
+    A_UINT8          *datap;
+    A_UINT16         typeorlen;
+    ATH_MAC_HDR      macHdr;
+    ATH_LLC_SNAP_HDR *llcHdr;
+
+    A_ASSERT(osbuf != NULL);
+
+    if (A_NETBUF_HEADROOM(osbuf) <
+        (sizeof(ATH_LLC_SNAP_HDR) + sizeof(WMI_DATA_HDR)))
+    {
+        return A_NO_MEMORY;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    typeorlen = *(A_UINT16 *)(datap + ATH_MAC_LEN + ATH_MAC_LEN);
+
+    if (!IS_ETHERTYPE(A_BE2CPU16(typeorlen))) {
+        /*
+         * packet is already in 802.3 format - return success
+         */
+        A_DPRINTF(DBG_WMI, (DBGFMT "packet already 802.3\n", DBGARG));
+        return (A_OK);
+    }
+
+    /*
+     * Save mac fields and length to be inserted later
+     */
+    A_MEMCPY(macHdr.dstMac, datap, ATH_MAC_LEN);
+    A_MEMCPY(macHdr.srcMac, datap + ATH_MAC_LEN, ATH_MAC_LEN);
+    macHdr.typeOrLen = A_CPU2BE16(A_NETBUF_LEN(osbuf) - sizeof(ATH_MAC_HDR) +
+                                  sizeof(ATH_LLC_SNAP_HDR));
+
+    /*
+     * Make room for LLC+SNAP headers
+     */
+    if (A_NETBUF_PUSH(osbuf, sizeof(ATH_LLC_SNAP_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(datap, &macHdr, sizeof (ATH_MAC_HDR));
+
+    llcHdr = (ATH_LLC_SNAP_HDR *)(datap + sizeof(ATH_MAC_HDR));
+    llcHdr->dsap      = 0xAA;
+    llcHdr->ssap      = 0xAA;
+    llcHdr->cntl      = 0x03;
+    llcHdr->orgCode[0] = 0x0;
+    llcHdr->orgCode[1] = 0x0;
+    llcHdr->orgCode[2] = 0x0;
+    llcHdr->etherType = typeorlen;
+
+    return (A_OK);
+}
+
+/*
+ * Adds a WMI data header
+ * Assumes there is enough room in the buffer to add header.
+ */
+A_STATUS
+wmi_data_hdr_add(struct wmi_t *wmip, void *osbuf, A_UINT8 msgType)
+{
+    WMI_DATA_HDR     *dtHdr;
+
+    A_ASSERT(osbuf != NULL);
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMI_DATA_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    dtHdr = (WMI_DATA_HDR *)A_NETBUF_DATA(osbuf);
+    dtHdr->info = msgType;
+    dtHdr->rssi = 0;
+
+    return (A_OK);
+}
+
+A_UINT8 wmi_implicit_create_pstream(struct wmi_t *wmip, void *osbuf, A_UINT8 dir, A_UINT8 up)
+{
+    A_UINT8         *datap;
+    A_UINT8         trafficClass = WMM_AC_BE, userPriority = up;
+    ATH_LLC_SNAP_HDR *llcHdr;
+    A_UINT16        ipType = IP_ETHERTYPE;
+    WMI_DATA_HDR     *dtHdr;
+    WMI_CREATE_PSTREAM_CMD  cmd;
+    A_BOOL           streamExists = FALSE;
+
+    A_ASSERT(osbuf != NULL);
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    if (up == UNDEFINED_PRI) {
+    llcHdr = (ATH_LLC_SNAP_HDR *)(datap + sizeof(WMI_DATA_HDR) +
+                                  sizeof(ATH_MAC_HDR));
+
+        if (llcHdr->etherType == A_CPU2BE16(ipType)) {
+        /* Extract the endpoint info from the TOS field in the IP header */
+        userPriority = A_WMI_IPTOS_TO_USERPRIORITY(((A_UINT8 *)llcHdr) + sizeof(ATH_LLC_SNAP_HDR));
+        }
+    }
+
+    if (userPriority < MAX_NUM_PRI) {
+        trafficClass = convert_userPriority_to_trafficClass(userPriority);
+    }
+
+    dtHdr = (WMI_DATA_HDR *)datap;
+    if(dir==UPLINK_TRAFFIC)
+        dtHdr->info |= (userPriority & WMI_DATA_HDR_UP_MASK) << WMI_DATA_HDR_UP_SHIFT;  /* lower 3-bits are 802.1d priority */
+
+    LOCK_WMI(wmip);
+    streamExists = wmip->wmi_fatPipeExists;
+    UNLOCK_WMI(wmip);
+
+    if (!(streamExists & (1 << trafficClass))) {
+
+        A_MEMZERO(&cmd, sizeof(cmd));
+	    cmd.trafficClass = trafficClass;
+	    cmd.userPriority = userPriority;
+		cmd.inactivityInt = WMI_IMPLICIT_PSTREAM_INACTIVITY_INT;
+            /* Implicit streams are created with TSID 0xFF */
+        cmd.tsid = WMI_IMPLICIT_PSTREAM;
+        wmi_create_pstream_cmd(wmip, &cmd);
+    }
+
+    return trafficClass;
+}
+
+WMI_PRI_STREAM_ID
+wmi_get_stream_id(struct wmi_t *wmip, A_UINT8 trafficClass)
+{
+    return WMI_ACCESSCATEGORY_WMISTREAM(wmip, trafficClass);
+}
+
+/*
+ *  performs 802.3 to DIX encapsulation for received packets.
+ *  Assumes the entire 802.3 header is contigous.
+ */
+A_STATUS
+wmi_dot3_2_dix(struct wmi_t *wmip, void *osbuf)
+{
+    A_UINT8          *datap;
+    ATH_MAC_HDR      macHdr;
+    ATH_LLC_SNAP_HDR *llcHdr;
+
+    A_ASSERT(osbuf != NULL);
+    datap = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(&macHdr, datap, sizeof(ATH_MAC_HDR));
+    llcHdr = (ATH_LLC_SNAP_HDR *)(datap + sizeof(ATH_MAC_HDR));
+    macHdr.typeOrLen = llcHdr->etherType;
+
+    if (A_NETBUF_PULL(osbuf, sizeof(ATH_LLC_SNAP_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(datap, &macHdr, sizeof (ATH_MAC_HDR));
+
+    return (A_OK);
+}
+
+/*
+ * Removes a WMI data header
+ */
+A_STATUS
+wmi_data_hdr_remove(struct wmi_t *wmip, void *osbuf)
+{
+    A_ASSERT(osbuf != NULL);
+
+    return (A_NETBUF_PULL(osbuf, sizeof(WMI_DATA_HDR)));
+}
+
+void
+wmi_iterate_nodes(struct wmi_t *wmip, wlan_node_iter_func *f, void *arg)
+{
+    wlan_iterate_nodes(&wmip->wmi_scan_table, f, arg);
+}
+
+/*
+ * WMI Extended Event received from Target.
+ */
+A_STATUS
+wmi_control_rx_xtnd(struct wmi_t *wmip, void *osbuf)
+{
+    WMIX_CMD_HDR *cmd;
+    A_UINT16 id;
+    A_UINT8 *datap;
+    A_UINT32 len;
+    A_STATUS status = A_OK;
+
+    if (A_NETBUF_LEN(osbuf) < sizeof(WMIX_CMD_HDR)) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 1\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    cmd = (WMIX_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    id = cmd->commandId;
+
+    if (A_NETBUF_PULL(osbuf, sizeof(WMIX_CMD_HDR)) != A_OK) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 2\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+    len = A_NETBUF_LEN(osbuf);
+
+    switch (id) {
+    case (WMIX_DSETOPENREQ_EVENTID):
+        status = wmi_dset_open_req_rx(wmip, datap, len);
+        break;
+#ifdef CONFIG_HOST_DSET_SUPPORT
+    case (WMIX_DSETCLOSE_EVENTID):
+        status = wmi_dset_close_rx(wmip, datap, len);
+        break;
+    case (WMIX_DSETDATAREQ_EVENTID):
+        status = wmi_dset_data_req_rx(wmip, datap, len);
+        break;
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+    case (WMIX_GPIO_INTR_EVENTID):
+        wmi_gpio_intr_rx(wmip, datap, len);
+        break;
+    case (WMIX_GPIO_DATA_EVENTID):
+        wmi_gpio_data_rx(wmip, datap, len);
+        break;
+    case (WMIX_GPIO_ACK_EVENTID):
+        wmi_gpio_ack_rx(wmip, datap, len);
+        break;
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+    case (WMIX_HB_CHALLENGE_RESP_EVENTID):
+        wmi_hbChallengeResp_rx(wmip, datap, len);
+        break;
+    case (WMIX_DBGLOG_EVENTID):
+        wmi_dbglog_event_rx(wmip, datap, len);
+        break;
+    default:
+        A_DPRINTF(DBG_WMI|DBG_ERROR,
+            (DBGFMT "Unknown id 0x%x\n", DBGARG, id));
+        wmip->wmi_stats.cmd_id_err++;
+        status = A_ERROR;
+        break;
+    }
+
+    return status;
+}
+
+/*
+ * Control Path
+ */
+A_UINT32 cmdRecvNum;
+
+A_STATUS
+wmi_control_rx(struct wmi_t *wmip, void *osbuf)
+{
+    WMI_CMD_HDR *cmd;
+    A_UINT16 id;
+    A_UINT8 *datap;
+    A_UINT32 len, i, loggingReq;
+    A_STATUS status = A_OK;
+
+    A_ASSERT(osbuf != NULL);
+    if (A_NETBUF_LEN(osbuf) < sizeof(WMI_CMD_HDR)) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 1\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    cmd = (WMI_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    id = cmd->commandId;
+
+    if (A_NETBUF_PULL(osbuf, sizeof(WMI_CMD_HDR)) != A_OK) {
+        A_DPRINTF(DBG_WMI, (DBGFMT "bad packet 2\n", DBGARG));
+        wmip->wmi_stats.cmd_len_err++;
+        A_NETBUF_FREE(osbuf);
+        return A_ERROR;
+    }
+
+    datap = A_NETBUF_DATA(osbuf);
+    len = A_NETBUF_LEN(osbuf);
+
+    ar6000_get_driver_cfg(wmip->wmi_devt,
+                    AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS,
+                    &loggingReq);
+
+    if(loggingReq) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("WMI %d \n",id));
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("WMI recv, MsgNo %d : ", cmdRecvNum));
+        for(i = 0; i < len; i++)
+            AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("%x ", datap[i]));
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("\n"));
+    }
+
+    LOCK_WMI(wmip);
+    cmdRecvNum++;
+    UNLOCK_WMI(wmip);
+
+    switch (id) {
+    case (WMI_GET_BITRATE_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_BITRATE_CMDID\n", DBGARG));
+        status = wmi_bitrate_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_CHANNEL_LIST_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_CHANNEL_LIST_CMDID\n", DBGARG));
+        status = wmi_channelList_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_TX_PWR_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_TX_PWR_CMDID\n", DBGARG));
+        status = wmi_txPwr_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_READY_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_READY_EVENTID\n", DBGARG));
+        status = wmi_ready_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        A_WMI_DBGLOG_INIT_DONE(wmip->wmi_devt);
+        break;
+    case (WMI_CONNECT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CONNECT_EVENTID\n", DBGARG));
+        status = wmi_connect_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_DISCONNECT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_DISCONNECT_EVENTID\n", DBGARG));
+        status = wmi_disconnect_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_TKIP_MICERR_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_TKIP_MICERR_EVENTID\n", DBGARG));
+        status = wmi_tkip_micerr_event_rx(wmip, datap, len);
+        break;
+    case (WMI_BSSINFO_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_BSSINFO_EVENTID\n", DBGARG));
+        status = wmi_bssInfo_event_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_REGDOMAIN_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REGDOMAIN_EVENTID\n", DBGARG));
+        status = wmi_regDomain_event_rx(wmip, datap, len);
+        break;
+    case (WMI_PSTREAM_TIMEOUT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_PSTREAM_TIMEOUT_EVENTID\n", DBGARG));
+        status = wmi_pstream_timeout_event_rx(wmip, datap, len);
+            /* pstreams are fatpipe abstractions that get implicitly created.
+             * User apps only deal with thinstreams. creation of a thinstream
+             * by the user or data traffic flow in an AC triggers implicit
+             * pstream creation. Do we need to send this event to App..?
+             * no harm in sending it.
+             */
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_NEIGHBOR_REPORT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_NEIGHBOR_REPORT_EVENTID\n", DBGARG));
+        status = wmi_neighborReport_event_rx(wmip, datap, len);
+        break;
+    case (WMI_SCAN_COMPLETE_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_SCAN_COMPLETE_EVENTID\n", DBGARG));
+        status = wmi_scanComplete_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_CMDERROR_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CMDERROR_EVENTID\n", DBGARG));
+        status = wmi_errorEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_REPORT_STATISTICS_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REPORT_STATISTICS_EVENTID\n", DBGARG));
+        status = wmi_statsEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_RSSI_THRESHOLD_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_RSSI_THRESHOLD_EVENTID\n", DBGARG));
+        status = wmi_rssiThresholdEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_ERROR_REPORT_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_ERROR_REPORT_EVENTID\n", DBGARG));
+        status = wmi_reportErrorEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_OPT_RX_FRAME_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_OPT_RX_FRAME_EVENTID\n", DBGARG));
+        status = wmi_opt_frame_event_rx(wmip, datap, len);
+        break;
+    case (WMI_REPORT_ROAM_TBL_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REPORT_ROAM_TBL_EVENTID\n", DBGARG));
+        status = wmi_roam_tbl_event_rx(wmip, datap, len);
+        break;
+    case (WMI_EXTENSION_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_EXTENSION_EVENTID\n", DBGARG));
+        status = wmi_control_rx_xtnd(wmip, osbuf);
+        break;
+    case (WMI_CAC_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_CAC_EVENTID\n", DBGARG));
+        status = wmi_cac_event_rx(wmip, datap, len);
+        break;
+    case (WMI_REPORT_ROAM_DATA_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_REPORT_ROAM_DATA_EVENTID\n", DBGARG));
+        status = wmi_roam_data_event_rx(wmip, datap, len);
+        break;
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+    case (WMI_TEST_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_TEST_EVENTID\n", DBGARG));
+        status = wmi_tcmd_test_report_rx(wmip, datap, len);
+        break;
+#endif
+    case (WMI_GET_FIXRATES_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_FIXRATES_CMDID\n", DBGARG));
+        status = wmi_ratemask_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_TX_RETRY_ERR_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_TX_RETRY_ERR_EVENTID\n", DBGARG));
+        status = wmi_txRetryErrEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_SNR_THRESHOLD_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_SNR_THRESHOLD_EVENTID\n", DBGARG));
+        status = wmi_snrThresholdEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_LQ_THRESHOLD_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_LQ_THRESHOLD_EVENTID\n", DBGARG));
+        status = wmi_lqThresholdEvent_rx(wmip, datap, len);
+        A_WMI_SEND_EVENT_TO_APP(wmip->wmi_devt, id, datap, len);
+        break;
+    case (WMI_APLIST_EVENTID):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Received APLIST Event\n"));
+        status = wmi_aplistEvent_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_KEEPALIVE_CMDID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_KEEPALIVE_CMDID\n", DBGARG));
+        status = wmi_keepalive_reply_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_WOW_LIST_EVENTID):
+        status = wmi_get_wow_list_event_rx(wmip, datap, len);
+        break;
+    case (WMI_GET_PMKID_LIST_EVENTID):
+        A_DPRINTF(DBG_WMI, (DBGFMT "WMI_GET_PMKID_LIST Event\n", DBGARG));
+        status = wmi_get_pmkid_list_event_rx(wmip, datap, len);
+        break;
+    default:
+        A_DPRINTF(DBG_WMI|DBG_ERROR,
+            (DBGFMT "Unknown id 0x%x\n", DBGARG, id));
+        wmip->wmi_stats.cmd_id_err++;
+        status = A_ERROR;
+        break;
+    }
+
+    A_NETBUF_FREE(osbuf);
+
+    return status;
+}
+
+static A_STATUS
+wmi_ready_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_READY_EVENT *ev = (WMI_READY_EVENT *)datap;
+
+    if (len < sizeof(WMI_READY_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+    wmip->wmi_ready = TRUE;
+    A_WMI_READY_EVENT(wmip->wmi_devt, ev->macaddr, ev->phyCapability);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_connect_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CONNECT_EVENT *ev;
+
+    if (len < sizeof(WMI_CONNECT_EVENT)) {
+        return A_EINVAL;
+    }
+    ev = (WMI_CONNECT_EVENT *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "freq %d bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",
+        DBGARG, ev->channel,
+        ev->bssid[0], ev->bssid[1], ev->bssid[2],
+        ev->bssid[3], ev->bssid[4], ev->bssid[5]));
+
+    A_MEMCPY(wmip->wmi_bssid, ev->bssid, ATH_MAC_LEN);
+
+    A_WMI_CONNECT_EVENT(wmip->wmi_devt, ev->channel, ev->bssid,
+                         ev->listenInterval, ev->beaconInterval,
+                         ev->networkType, ev->beaconIeLen,
+                         ev->assocReqLen, ev->assocRespLen,
+                         ev->assocInfo);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_regDomain_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_REG_DOMAIN_EVENT *ev;
+
+    if (len < sizeof(*ev)) {
+        return A_EINVAL;
+    }
+    ev = (WMI_REG_DOMAIN_EVENT *)datap;
+
+    A_WMI_REGDOMAIN_EVENT(wmip->wmi_devt, ev->regDomain);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_neighborReport_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_NEIGHBOR_REPORT_EVENT *ev;
+    int numAps;
+
+    if (len < sizeof(*ev)) {
+        return A_EINVAL;
+    }
+    ev = (WMI_NEIGHBOR_REPORT_EVENT *)datap;
+    numAps = ev->numberOfAps;
+
+    if (len < (int)(sizeof(*ev) + ((numAps - 1) * sizeof(WMI_NEIGHBOR_INFO)))) {
+        return A_EINVAL;
+    }
+
+    A_WMI_NEIGHBORREPORT_EVENT(wmip->wmi_devt, numAps, ev->neighbor);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_disconnect_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_DISCONNECT_EVENT *ev;
+
+    if (len < sizeof(WMI_DISCONNECT_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    ev = (WMI_DISCONNECT_EVENT *)datap;
+
+    A_MEMZERO(wmip->wmi_bssid, sizeof(wmip->wmi_bssid));
+
+    A_WMI_DISCONNECT_EVENT(wmip->wmi_devt, ev->disconnectReason, ev->bssid,
+                            ev->assocRespLen, ev->assocInfo, ev->protocolReasonStatus);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_tkip_micerr_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TKIP_MICERR_EVENT *ev;
+
+    if (len < sizeof(*ev)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    ev = (WMI_TKIP_MICERR_EVENT *)datap;
+    A_WMI_TKIP_MICERR_EVENT(wmip->wmi_devt, ev->keyid, ev->ismcast);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_bssInfo_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    bss_t *bss;
+    WMI_BSS_INFO_HDR *bih;
+    A_UINT8 *buf;
+    A_UINT32 nodeCachingAllowed;
+
+    if (len <= sizeof(WMI_BSS_INFO_HDR)) {
+        return A_EINVAL;
+    }
+
+    A_WMI_BSSINFO_EVENT_RX(wmip->wmi_devt, datap, len);
+    /* What is driver config for wlan node caching? */
+    if(ar6000_get_driver_cfg(wmip->wmi_devt,
+                    AR6000_DRIVER_CFG_GET_WLANNODECACHING,
+                    &nodeCachingAllowed) != A_OK) {
+        return A_EINVAL;
+    }
+
+    if(!nodeCachingAllowed) {
+        return A_OK;
+    }
+
+
+    bih = (WMI_BSS_INFO_HDR *)datap;
+    buf = datap + sizeof(WMI_BSS_INFO_HDR);
+    len -= sizeof(WMI_BSS_INFO_HDR);
+
+    A_DPRINTF(DBG_WMI2, (DBGFMT "bssInfo event - ch %u, rssi %02x, "
+              "bssid \"%02x:%02x:%02x:%02x:%02x:%02x\"\n", DBGARG,
+              bih->channel, (unsigned char) bih->rssi, bih->bssid[0],
+              bih->bssid[1], bih->bssid[2], bih->bssid[3], bih->bssid[4],
+              bih->bssid[5]));
+
+    if(wps_enable && (bih->frameType == PROBERESP_FTYPE) ) {
+	    printk("%s() A_OK 2\n", __FUNCTION__);
+		return A_OK;
+    }
+
+    bss = wlan_find_node(&wmip->wmi_scan_table, bih->bssid);
+    if (bss != NULL) {
+        /*
+         * Free up the node.  Not the most efficient process given
+         * we are about to allocate a new node but it is simple and should be
+         * adequate.
+         */
+        wlan_node_reclaim(&wmip->wmi_scan_table, bss);
+    }
+
+    bss = wlan_node_alloc(&wmip->wmi_scan_table, len);
+    if (bss == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    bss->ni_snr        = bih->snr;
+    bss->ni_rssi       = bih->rssi;
+    A_ASSERT(bss->ni_buf != NULL);
+    A_MEMCPY(bss->ni_buf, buf, len);
+
+    if (wlan_parse_beacon(bss->ni_buf, len, &bss->ni_cie) != A_OK) {
+        wlan_node_free(bss);
+        return A_EINVAL;
+    }
+
+    /*
+     * Update the frequency in ie_chan, overwriting of channel number
+     * which is done in wlan_parse_beacon
+     */
+    bss->ni_cie.ie_chan = bih->channel;
+    wlan_setup_node(&wmip->wmi_scan_table, bss, bih->bssid);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_opt_frame_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    bss_t *bss;
+    WMI_OPT_RX_INFO_HDR *bih;
+    A_UINT8 *buf;
+
+    if (len <= sizeof(WMI_OPT_RX_INFO_HDR)) {
+        return A_EINVAL;
+    }
+
+    bih = (WMI_OPT_RX_INFO_HDR *)datap;
+    buf = datap + sizeof(WMI_OPT_RX_INFO_HDR);
+    len -= sizeof(WMI_OPT_RX_INFO_HDR);
+
+    A_DPRINTF(DBG_WMI2, (DBGFMT "opt frame event %2.2x:%2.2x\n", DBGARG,
+        bih->bssid[4], bih->bssid[5]));
+
+    bss = wlan_find_node(&wmip->wmi_scan_table, bih->bssid);
+    if (bss != NULL) {
+        /*
+         * Free up the node.  Not the most efficient process given
+         * we are about to allocate a new node but it is simple and should be
+         * adequate.
+         */
+        wlan_node_reclaim(&wmip->wmi_scan_table, bss);
+    }
+
+    bss = wlan_node_alloc(&wmip->wmi_scan_table, len);
+    if (bss == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    bss->ni_snr        = bih->snr;
+    bss->ni_cie.ie_chan = bih->channel;
+    A_ASSERT(bss->ni_buf != NULL);
+    A_MEMCPY(bss->ni_buf, buf, len);
+    wlan_setup_node(&wmip->wmi_scan_table, bss, bih->bssid);
+
+    return A_OK;
+}
+
+    /* This event indicates inactivity timeout of a fatpipe(pstream)
+     * at the target
+     */
+static A_STATUS
+wmi_pstream_timeout_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_PSTREAM_TIMEOUT_EVENT *ev;
+
+    if (len < sizeof(WMI_PSTREAM_TIMEOUT_EVENT)) {
+        return A_EINVAL;
+    }
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "wmi_pstream_timeout_event_rx\n", DBGARG));
+
+    ev = (WMI_PSTREAM_TIMEOUT_EVENT *)datap;
+
+        /* When the pstream (fat pipe == AC) timesout, it means there were no
+         * thinStreams within this pstream & it got implicitly created due to
+         * data flow on this AC. We start the inactivity timer only for
+         * implicitly created pstream. Just reset the host state.
+         */
+        /* Set the activeTsids for this AC to 0 */
+    LOCK_WMI(wmip);
+    wmip->wmi_streamExistsForAC[ev->trafficClass]=0;
+    wmip->wmi_fatPipeExists &= ~(1 << ev->trafficClass);
+    UNLOCK_WMI(wmip);
+
+        /*Indicate inactivity to driver layer for this fatpipe (pstream)*/
+    A_WMI_STREAM_TX_INACTIVE(wmip->wmi_devt, ev->trafficClass);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_bitrate_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_BIT_RATE_CMD *reply;
+    A_INT32 rate;
+
+    if (len < sizeof(WMI_BIT_RATE_CMD)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_BIT_RATE_CMD *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - rateindex %d\n", DBGARG, reply->rateIndex));
+
+    if (reply->rateIndex == RATE_AUTO) {
+        rate = RATE_AUTO;
+    } else {
+        rate = wmi_rateTable[(A_UINT32) reply->rateIndex];
+    }
+
+    A_WMI_BITRATE_RX(wmip->wmi_devt, rate);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_ratemask_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_FIX_RATES_CMD *reply;
+
+    if (len < sizeof(WMI_BIT_RATE_CMD)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_FIX_RATES_CMD *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - fixed rate mask %x\n", DBGARG, reply->fixRateMask));
+
+    A_WMI_RATEMASK_RX(wmip->wmi_devt, reply->fixRateMask);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_channelList_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CHANNEL_LIST_REPLY *reply;
+
+    if (len < sizeof(WMI_CHANNEL_LIST_REPLY)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_CHANNEL_LIST_REPLY *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_CHANNELLIST_RX(wmip->wmi_devt, reply->numChannels,
+                          reply->channelList);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_txPwr_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TX_PWR_REPLY *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TX_PWR_REPLY *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_TXPWR_RX(wmip->wmi_devt, reply->dbM);
+
+    return A_OK;
+}
+static A_STATUS
+wmi_keepalive_reply_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_GET_KEEPALIVE_CMD *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_GET_KEEPALIVE_CMD *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_KEEPALIVE_RX(wmip->wmi_devt, reply->configured);
+
+    return A_OK;
+}
+
+
+static A_STATUS
+wmi_dset_open_req_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_DSETOPENREQ_EVENT *dsetopenreq;
+
+    if (len < sizeof(WMIX_DSETOPENREQ_EVENT)) {
+        return A_EINVAL;
+    }
+    dsetopenreq = (WMIX_DSETOPENREQ_EVENT *)datap;
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - dset_id=0x%x\n", DBGARG, dsetopenreq->dset_id));
+    A_WMI_DSET_OPEN_REQ(wmip->wmi_devt,
+                        dsetopenreq->dset_id,
+                        dsetopenreq->targ_dset_handle,
+                        dsetopenreq->targ_reply_fn,
+                        dsetopenreq->targ_reply_arg);
+
+    return A_OK;
+}
+
+#ifdef CONFIG_HOST_DSET_SUPPORT
+static A_STATUS
+wmi_dset_close_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_DSETCLOSE_EVENT *dsetclose;
+
+    if (len < sizeof(WMIX_DSETCLOSE_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    dsetclose = (WMIX_DSETCLOSE_EVENT *)datap;
+    A_WMI_DSET_CLOSE(wmip->wmi_devt, dsetclose->access_cookie);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_dset_data_req_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_DSETDATAREQ_EVENT *dsetdatareq;
+
+    if (len < sizeof(WMIX_DSETDATAREQ_EVENT)) {
+        return A_EINVAL;
+    }
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    dsetdatareq = (WMIX_DSETDATAREQ_EVENT *)datap;
+    A_WMI_DSET_DATA_REQ(wmip->wmi_devt,
+                         dsetdatareq->access_cookie,
+                         dsetdatareq->offset,
+                         dsetdatareq->length,
+                         dsetdatareq->targ_buf,
+                         dsetdatareq->targ_reply_fn,
+                         dsetdatareq->targ_reply_arg);
+
+    return A_OK;
+}
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+
+static A_STATUS
+wmi_scanComplete_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_SCAN_COMPLETE_EVENT *ev;
+
+    ev = (WMI_SCAN_COMPLETE_EVENT *)datap;
+    A_WMI_SCANCOMPLETE_EVENT(wmip->wmi_devt, ev->status);
+
+    return A_OK;
+}
+
+/*
+ * Target is reporting a programming error.  This is for
+ * developer aid only.  Target only checks a few common violations
+ * and it is responsibility of host to do all error checking.
+ * Behavior of target after wmi error event is undefined.
+ * A reset is recommended.
+ */
+static A_STATUS
+wmi_errorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CMD_ERROR_EVENT *ev;
+
+    ev = (WMI_CMD_ERROR_EVENT *)datap;
+    AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Programming Error: cmd=%d ", ev->commandId));
+    switch (ev->errorCode) {
+    case (INVALID_PARAM):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Illegal Parameter\n"));
+        break;
+    case (ILLEGAL_STATE):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Illegal State\n"));
+        break;
+    case (INTERNAL_ERROR):
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Internal Error\n"));
+        break;
+    }
+
+    return A_OK;
+}
+
+
+static A_STATUS
+wmi_statsEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_STATS *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_STATS *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_TARGETSTATS_EVENT(wmip->wmi_devt, reply);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_rssiThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_RSSI_THRESHOLD_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_RSSI_THRESHOLD_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_RSSI_THRESHOLD_EVENT(wmip->wmi_devt, reply->range, reply->rssi);
+
+    return A_OK;
+}
+
+
+static A_STATUS
+wmi_reportErrorEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_ERROR_REPORT_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_ERROR_REPORT_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_REPORT_ERROR_EVENT(wmip->wmi_devt, reply->errorVal);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_cac_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_CAC_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_CAC_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_CAC_EVENT(wmip->wmi_devt, reply->ac,
+                reply->cac_indication, reply->statusCode,
+                reply->tspecSuggestion);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_hbChallengeResp_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_HB_CHALLENGE_RESP_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMIX_HB_CHALLENGE_RESP_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "wmi: challenge response event\n", DBGARG));
+
+    A_WMI_HBCHALLENGERESP_EVENT(wmip->wmi_devt, reply->cookie, reply->source);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_roam_tbl_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_ROAM_TBL *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_ROAM_TBL *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_ROAM_TABLE_EVENT(wmip->wmi_devt, reply);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_roam_data_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TARGET_ROAM_DATA *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TARGET_ROAM_DATA *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_ROAM_DATA_EVENT(wmip->wmi_devt, reply);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_txRetryErrEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_TX_RETRY_ERR_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_TX_RETRY_ERR_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_TX_RETRY_ERR_EVENT(wmip->wmi_devt);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_snrThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_SNR_THRESHOLD_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_SNR_THRESHOLD_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_SNR_THRESHOLD_EVENT_RX(wmip->wmi_devt, reply->range, reply->snr);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_lqThresholdEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_LQ_THRESHOLD_EVENT *reply;
+
+    if (len < sizeof(*reply)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_LQ_THRESHOLD_EVENT *)datap;
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_LQ_THRESHOLD_EVENT_RX(wmip->wmi_devt, reply->range, reply->lq);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_aplistEvent_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_UINT16 ap_info_entry_size;
+    WMI_APLIST_EVENT *ev = (WMI_APLIST_EVENT *)datap;
+    WMI_AP_INFO_V1 *ap_info_v1;
+    A_UINT8 i;
+
+    if (len < sizeof(WMI_APLIST_EVENT)) {
+        return A_EINVAL;
+    }
+
+    if (ev->apListVer == APLIST_VER1) {
+        ap_info_entry_size = sizeof(WMI_AP_INFO_V1);
+        ap_info_v1 = (WMI_AP_INFO_V1 *)ev->apList;
+    } else {
+        return A_EINVAL;
+    }
+
+    AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("Number of APs in APLIST Event is %d\n", ev->numAP));
+    if (len < (int)(sizeof(WMI_APLIST_EVENT) +
+              (ev->numAP - 1) * ap_info_entry_size))
+    {
+        return A_EINVAL;
+    }
+
+    /*
+     * AP List Ver1 Contents
+     */
+    for (i = 0; i < ev->numAP; i++) {
+        AR_DEBUG_PRINTF(ATH_DEBUG_WMI, ("AP#%d BSSID %2.2x %2.2x %2.2x %2.2x %2.2x %2.2x "\
+                    "Channel %d\n", i,
+                   ap_info_v1->bssid[0], ap_info_v1->bssid[1],
+                   ap_info_v1->bssid[2], ap_info_v1->bssid[3],
+                   ap_info_v1->bssid[4], ap_info_v1->bssid[5],
+                   ap_info_v1->channel));
+        ap_info_v1++;
+    }
+    return A_OK;
+}
+
+static A_STATUS
+wmi_dbglog_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_UINT32 dropped;
+
+    dropped = *((A_UINT32 *)datap);
+    datap += sizeof(dropped);
+    len -= sizeof(dropped);
+    A_WMI_DBGLOG_EVENT(wmip->wmi_devt, dropped, datap, len);
+    return A_OK;
+}
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+static A_STATUS
+wmi_gpio_intr_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_GPIO_INTR_EVENT *gpio_intr = (WMIX_GPIO_INTR_EVENT *)datap;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - intrmask=0x%x input=0x%x.\n", DBGARG,
+        gpio_intr->intr_mask, gpio_intr->input_values));
+
+    A_WMI_GPIO_INTR_RX(gpio_intr->intr_mask, gpio_intr->input_values);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_gpio_data_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMIX_GPIO_DATA_EVENT *gpio_data = (WMIX_GPIO_DATA_EVENT *)datap;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - reg=%d value=0x%x\n", DBGARG,
+        gpio_data->reg_id, gpio_data->value));
+
+    A_WMI_GPIO_DATA_RX(gpio_data->reg_id, gpio_data->value);
+
+    return A_OK;
+}
+
+static A_STATUS
+wmi_gpio_ack_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    A_WMI_GPIO_ACK_RX();
+
+    return A_OK;
+}
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+/*
+ * Called to send a wmi command. Command specific data is already built
+ * on osbuf and current osbuf->data points to it.
+ */
+A_STATUS
+wmi_cmd_send(struct wmi_t *wmip, void *osbuf, WMI_COMMAND_ID cmdId,
+               WMI_SYNC_FLAG syncflag)
+{
+#define IS_LONG_CMD(cmdId) ((cmdId == WMI_OPT_TX_FRAME_CMDID) || (cmdId == WMI_ADD_WOW_PATTERN_CMDID))
+    WMI_CMD_HDR         *cHdr;
+    WMI_PRI_STREAM_ID   streamID = WMI_CONTROL_PRI;
+
+    A_ASSERT(osbuf != NULL);
+
+    if (syncflag >= END_WMIFLAG) {
+        return A_EINVAL;
+    }
+
+    if ((syncflag == SYNC_BEFORE_WMIFLAG) || (syncflag == SYNC_BOTH_WMIFLAG)) {
+        /*
+         * We want to make sure all data currently queued is transmitted before
+         * the cmd execution.  Establish a new sync point.
+         */
+        wmi_sync_point(wmip);
+    }
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMI_CMD_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    cHdr = (WMI_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    cHdr->commandId = cmdId;
+
+    /*
+     * Send cmd, some via control pipe, others via data pipe
+     */
+    if (IS_LONG_CMD(cmdId)) {
+        wmi_data_hdr_add(wmip, osbuf, CNTL_MSGTYPE);
+        // TODO ... these can now go through the control endpoint via HTC 2.0
+        streamID = WMI_BEST_EFFORT_PRI;
+    }
+    A_WMI_CONTROL_TX(wmip->wmi_devt, osbuf, streamID);
+
+    if ((syncflag == SYNC_AFTER_WMIFLAG) || (syncflag == SYNC_BOTH_WMIFLAG)) {
+        /*
+         * We want to make sure all new data queued waits for the command to
+         * execute. Establish a new sync point.
+         */
+        wmi_sync_point(wmip);
+    }
+    return (A_OK);
+#undef IS_LONG_CMD
+}
+
+A_STATUS
+wmi_cmd_send_xtnd(struct wmi_t *wmip, void *osbuf, WMI_COMMAND_ID cmdId,
+                  WMI_SYNC_FLAG syncflag)
+{
+    WMIX_CMD_HDR     *cHdr;
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMIX_CMD_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    cHdr = (WMIX_CMD_HDR *)A_NETBUF_DATA(osbuf);
+    cHdr->commandId = cmdId;
+
+    return wmi_cmd_send(wmip, osbuf, WMI_EXTENSION_CMDID, syncflag);
+}
+
+A_STATUS
+wmi_connect_cmd(struct wmi_t *wmip, NETWORK_TYPE netType,
+                DOT11_AUTH_MODE dot11AuthMode, AUTH_MODE authMode,
+                CRYPTO_TYPE pairwiseCrypto, A_UINT8 pairwiseCryptoLen,
+                CRYPTO_TYPE groupCrypto,A_UINT8 groupCryptoLen,
+                int ssidLength, A_UCHAR *ssid,
+                A_UINT8 *bssid, A_UINT16 channel, A_UINT32 ctrl_flags)
+{
+    void *osbuf;
+    WMI_CONNECT_CMD *cc;
+
+    if ((pairwiseCrypto == NONE_CRYPT) && (groupCrypto != NONE_CRYPT)) {
+        return A_EINVAL;
+    }
+    if ((pairwiseCrypto != NONE_CRYPT) && (groupCrypto == NONE_CRYPT)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(WMI_CONNECT_CMD));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(WMI_CONNECT_CMD));
+
+    cc = (WMI_CONNECT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cc, sizeof(*cc));
+
+    A_MEMCPY(cc->ssid, ssid, ssidLength);
+    cc->ssidLength          = ssidLength;
+    cc->networkType         = netType;
+    cc->dot11AuthMode       = dot11AuthMode;
+    cc->authMode            = authMode;
+    cc->pairwiseCryptoType  = pairwiseCrypto;
+    cc->pairwiseCryptoLen   = pairwiseCryptoLen;
+    cc->groupCryptoType     = groupCrypto;
+    cc->groupCryptoLen      = groupCryptoLen;
+    cc->channel             = channel;
+    cc->ctrl_flags          = ctrl_flags;
+
+    if (bssid != NULL) {
+        A_MEMCPY(cc->bssid, bssid, ATH_MAC_LEN);
+    }
+    if (wmi_set_keepalive_cmd(wmip, wmip->wmi_keepaliveInterval) != A_OK) {
+        return(A_ERROR);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_CONNECT_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_reconnect_cmd(struct wmi_t *wmip, A_UINT8 *bssid, A_UINT16 channel)
+{
+    void *osbuf;
+    WMI_RECONNECT_CMD *cc;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(WMI_RECONNECT_CMD));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(WMI_RECONNECT_CMD));
+
+    cc = (WMI_RECONNECT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cc, sizeof(*cc));
+
+    cc->channel = channel;
+
+    if (bssid != NULL) {
+        A_MEMCPY(cc->bssid, bssid, ATH_MAC_LEN);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_RECONNECT_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_disconnect_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+    A_STATUS status;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    /* Bug fix for 24817(elevator bug) - the disconnect command does not
+       need to do a SYNC before.*/
+    status = (wmi_cmd_send(wmip, osbuf, WMI_DISCONNECT_CMDID,
+                         NO_SYNC_WMIFLAG));
+
+    return status;
+}
+
+A_STATUS
+wmi_startscan_cmd(struct wmi_t *wmip, WMI_SCAN_TYPE scanType,
+                  A_BOOL forceFgScan, A_BOOL isLegacy,
+                  A_UINT32 homeDwellTime, A_UINT32 forceScanInterval)
+{
+    void *osbuf;
+    WMI_START_SCAN_CMD *sc;
+
+    if ((scanType != WMI_LONG_SCAN) && (scanType != WMI_SHORT_SCAN)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*sc));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*sc));
+
+    sc = (WMI_START_SCAN_CMD *)(A_NETBUF_DATA(osbuf));
+    sc->scanType = scanType;
+    sc->forceFgScan = forceFgScan;
+    sc->isLegacy = isLegacy;
+    sc->homeDwellTime = homeDwellTime;
+    sc->forceScanInterval = forceScanInterval;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_START_SCAN_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_scanparams_cmd(struct wmi_t *wmip, A_UINT16 fg_start_sec,
+                   A_UINT16 fg_end_sec, A_UINT16 bg_sec,
+                   A_UINT16 minact_chdw_msec, A_UINT16 maxact_chdw_msec,
+                   A_UINT16 pas_chdw_msec,
+                   A_UINT8 shScanRatio, A_UINT8 scanCtrlFlags,
+                   A_UINT32 max_dfsch_act_time)
+{
+    void *osbuf;
+    WMI_SCAN_PARAMS_CMD *sc;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*sc));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*sc));
+
+    sc = (WMI_SCAN_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(sc, sizeof(*sc));
+    sc->fg_start_period  = fg_start_sec;
+    sc->fg_end_period    = fg_end_sec;
+    sc->bg_period        = bg_sec;
+    sc->minact_chdwell_time = minact_chdw_msec;
+    sc->maxact_chdwell_time = maxact_chdw_msec;
+    sc->pas_chdwell_time = pas_chdw_msec;
+    sc->shortScanRatio   = shScanRatio;
+    sc->scanCtrlFlags    = scanCtrlFlags;
+    sc->max_dfsch_act_time = max_dfsch_act_time;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_SCAN_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_bssfilter_cmd(struct wmi_t *wmip, A_UINT8 filter, A_UINT32 ieMask)
+{
+    void *osbuf;
+    WMI_BSS_FILTER_CMD *cmd;
+
+    if (filter >= LAST_BSS_FILTER) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BSS_FILTER_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->bssFilter = filter;
+    cmd->ieMask = ieMask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BSS_FILTER_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_probedSsid_cmd(struct wmi_t *wmip, A_UINT8 index, A_UINT8 flag,
+                   A_UINT8 ssidLength, A_UCHAR *ssid)
+{
+    void *osbuf;
+    WMI_PROBED_SSID_CMD *cmd;
+
+    if (index > MAX_PROBED_SSID_INDEX) {
+        return A_EINVAL;
+    }
+    if (ssidLength > sizeof(cmd->ssid)) {
+        return A_EINVAL;
+    }
+    if ((flag & (DISABLE_SSID_FLAG | ANY_SSID_FLAG)) && (ssidLength > 0)) {
+        return A_EINVAL;
+    }
+    if ((flag & SPECIFIC_SSID_FLAG) && !ssidLength) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_PROBED_SSID_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->entryIndex = index;
+    cmd->flag       = flag;
+    cmd->ssidLength = ssidLength;
+    A_MEMCPY(cmd->ssid, ssid, ssidLength);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_PROBED_SSID_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_listeninterval_cmd(struct wmi_t *wmip, A_UINT16 listenInterval, A_UINT16 listenBeacons)
+{
+    void *osbuf;
+    WMI_LISTEN_INT_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_LISTEN_INT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->listenInterval = listenInterval;
+    cmd->numBeacons = listenBeacons;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_LISTEN_INT_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_bmisstime_cmd(struct wmi_t *wmip, A_UINT16 bmissTime, A_UINT16 bmissBeacons)
+{
+    void *osbuf;
+    WMI_BMISS_TIME_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BMISS_TIME_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->bmissTime = bmissTime;
+    cmd->numBeacons =  bmissBeacons;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BMISS_TIME_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_associnfo_cmd(struct wmi_t *wmip, A_UINT8 ieType,
+                     A_UINT8 ieLen, A_UINT8 *ieInfo)
+{
+    void *osbuf;
+    WMI_SET_ASSOC_INFO_CMD *cmd;
+    A_UINT16 cmdLen;
+
+    cmdLen = sizeof(*cmd) + ieLen - 1;
+    osbuf = A_NETBUF_ALLOC(cmdLen);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, cmdLen);
+
+    cmd = (WMI_SET_ASSOC_INFO_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, cmdLen);
+    cmd->ieType = ieType;
+    cmd->bufferSize = ieLen;
+    A_MEMCPY(cmd->assocInfo, ieInfo, ieLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_ASSOC_INFO_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_powermode_cmd(struct wmi_t *wmip, A_UINT8 powerMode)
+{
+    void *osbuf;
+    WMI_POWER_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_POWER_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->powerMode = powerMode;
+    wmip->wmi_powerMode = powerMode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_POWER_MODE_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_ibsspmcaps_cmd(struct wmi_t *wmip, A_UINT8 pmEnable, A_UINT8 ttl,
+                   A_UINT16 atim_windows, A_UINT16 timeout_value)
+{
+    void *osbuf;
+    WMI_IBSS_PM_CAPS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_IBSS_PM_CAPS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->power_saving = pmEnable;
+    cmd->ttl = ttl;
+    cmd->atim_windows = atim_windows;
+    cmd->timeout_value = timeout_value;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_IBSS_PM_CAPS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_pmparams_cmd(struct wmi_t *wmip, A_UINT16 idlePeriod,
+                 A_UINT16 psPollNum, A_UINT16 dtimPolicy)
+{
+    void *osbuf;
+    WMI_POWER_PARAMS_CMD *pm;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*pm));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*pm));
+
+    pm = (WMI_POWER_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(pm, sizeof(*pm));
+    pm->idle_period   = idlePeriod;
+    pm->pspoll_number = psPollNum;
+    pm->dtim_policy   = dtimPolicy;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_POWER_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_disctimeout_cmd(struct wmi_t *wmip, A_UINT8 timeout)
+{
+    void *osbuf;
+    WMI_DISC_TIMEOUT_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DISC_TIMEOUT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->disconnectTimeout = timeout;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_DISC_TIMEOUT_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_addKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex, CRYPTO_TYPE keyType,
+               A_UINT8 keyUsage, A_UINT8 keyLength, A_UINT8 *keyRSC,
+               A_UINT8 *keyMaterial, A_UINT8 key_op_ctrl,
+               WMI_SYNC_FLAG sync_flag)
+{
+    void *osbuf;
+    WMI_ADD_CIPHER_KEY_CMD *cmd;
+
+    if ((keyIndex > WMI_MAX_KEY_INDEX) || (keyLength > WMI_MAX_KEY_LEN) ||
+        (keyMaterial == NULL))
+    {
+        return A_EINVAL;
+    }
+
+    if ((WEP_CRYPT != keyType) && (NULL == keyRSC)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_ADD_CIPHER_KEY_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->keyIndex = keyIndex;
+    cmd->keyType  = keyType;
+    cmd->keyUsage = keyUsage;
+    cmd->keyLength = keyLength;
+    A_MEMCPY(cmd->key, keyMaterial, keyLength);
+    if (NULL != keyRSC) {
+        A_MEMCPY(cmd->keyRSC, keyRSC, sizeof(cmd->keyRSC));
+    }
+    cmd->key_op_ctrl = key_op_ctrl;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_CIPHER_KEY_CMDID, sync_flag));
+}
+
+A_STATUS
+wmi_add_krk_cmd(struct wmi_t *wmip, A_UINT8 *krk)
+{
+    void *osbuf;
+    WMI_ADD_KRK_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_ADD_KRK_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    A_MEMCPY(cmd->krk, krk, WMI_KRK_LEN);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_KRK_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_delete_krk_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DELETE_KRK_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_deleteKey_cmd(struct wmi_t *wmip, A_UINT8 keyIndex)
+{
+    void *osbuf;
+    WMI_DELETE_CIPHER_KEY_CMD *cmd;
+
+    if (keyIndex > WMI_MAX_KEY_INDEX) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DELETE_CIPHER_KEY_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->keyIndex = keyIndex;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DELETE_CIPHER_KEY_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_setPmkid_cmd(struct wmi_t *wmip, A_UINT8 *bssid, A_UINT8 *pmkId,
+                 A_BOOL set)
+{
+    void *osbuf;
+    WMI_SET_PMKID_CMD *cmd;
+
+    if (bssid == NULL) {
+        return A_EINVAL;
+    }
+
+    if ((set == TRUE) && (pmkId == NULL)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_PMKID_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMCPY(cmd->bssid, bssid, sizeof(cmd->bssid));
+    if (set == TRUE) {
+        A_MEMCPY(cmd->pmkid, pmkId, sizeof(cmd->pmkid));
+        cmd->enable = PMKID_ENABLE;
+    } else {
+        A_MEMZERO(cmd->pmkid, sizeof(cmd->pmkid));
+        cmd->enable = PMKID_DISABLE;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_PMKID_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_tkip_countermeasures_cmd(struct wmi_t *wmip, A_BOOL en)
+{
+    void *osbuf;
+    WMI_SET_TKIP_COUNTERMEASURES_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_TKIP_COUNTERMEASURES_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->cm_en = (en == TRUE)? WMI_TKIP_CM_ENABLE : WMI_TKIP_CM_DISABLE;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_TKIP_COUNTERMEASURES_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_akmp_params_cmd(struct wmi_t *wmip,
+                        WMI_SET_AKMP_PARAMS_CMD *akmpParams)
+{
+    void *osbuf;
+    WMI_SET_AKMP_PARAMS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+    cmd = (WMI_SET_AKMP_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->akmpInfo = akmpParams->akmpInfo;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_AKMP_PARAMS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_pmkid_list_cmd(struct wmi_t *wmip,
+                       WMI_SET_PMKID_LIST_CMD *pmkInfo)
+{
+    void *osbuf;
+    WMI_SET_PMKID_LIST_CMD *cmd;
+    A_UINT16 cmdLen;
+    A_UINT8 i;
+
+    cmdLen = sizeof(pmkInfo->numPMKID) +
+             pmkInfo->numPMKID * sizeof(WMI_PMKID);
+
+    osbuf = A_NETBUF_ALLOC(cmdLen);
+
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, cmdLen);
+    cmd = (WMI_SET_PMKID_LIST_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->numPMKID = pmkInfo->numPMKID;
+
+    for (i = 0; i < cmd->numPMKID; i++) {
+        A_MEMCPY(&cmd->pmkidList[i], &pmkInfo->pmkidList[i],
+                 WMI_PMKID_LEN);
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_PMKID_LIST_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_pmkid_list_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_PMKID_LIST_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_dataSync_send(struct wmi_t *wmip, void *osbuf, WMI_PRI_STREAM_ID streamID)
+{
+    WMI_DATA_HDR     *dtHdr;
+
+    A_ASSERT(streamID != WMI_CONTROL_PRI);
+    A_ASSERT(osbuf != NULL);
+
+    if (A_NETBUF_PUSH(osbuf, sizeof(WMI_DATA_HDR)) != A_OK) {
+        return A_NO_MEMORY;
+    }
+
+    dtHdr = (WMI_DATA_HDR *)A_NETBUF_DATA(osbuf);
+    dtHdr->info =
+      (SYNC_MSGTYPE & WMI_DATA_HDR_MSG_TYPE_MASK) << WMI_DATA_HDR_MSG_TYPE_SHIFT;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter - streamID %d\n", DBGARG, streamID));
+
+    return (A_WMI_CONTROL_TX(wmip->wmi_devt, osbuf, streamID));
+}
+
+typedef struct _WMI_DATA_SYNC_BUFS {
+    A_UINT8            trafficClass;
+    void               *osbuf;
+}WMI_DATA_SYNC_BUFS;
+
+static A_STATUS
+wmi_sync_point(struct wmi_t *wmip)
+{
+	void *cmd_osbuf;
+    WMI_DATA_SYNC_BUFS dataSyncBufs[WMM_NUM_AC];
+	A_UINT8 i,numPriStreams=0;
+	A_STATUS status;
+
+	A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    memset(dataSyncBufs,0,sizeof(dataSyncBufs));
+
+    /* lock out while we walk through the priority list and assemble our local array */
+    LOCK_WMI(wmip);
+
+    for (i=0; i < WMM_NUM_AC ; i++) {
+		if (wmip->wmi_fatPipeExists & (1 << i)) {
+            numPriStreams++;
+            dataSyncBufs[numPriStreams-1].trafficClass = i;
+        }
+    }
+
+    UNLOCK_WMI(wmip);
+
+    /* dataSyncBufs is now filled with entries (starting at index 0) containing valid streamIDs */
+
+    do {
+	    /*
+	     * We allocate all network buffers needed so we will be able to
+	     * send all required frames.
+	     */
+	    cmd_osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+	    if (cmd_osbuf == NULL) {
+		    status = A_NO_MEMORY;
+            break;
+	    }
+
+	    for (i=0; i < numPriStreams ; i++) {
+	        dataSyncBufs[i].osbuf = A_NETBUF_ALLOC(0);
+            if (dataSyncBufs[i].osbuf == NULL) {
+                status = A_NO_MEMORY;
+                break;
+            }
+	    } //end for
+
+	    /*
+	     * Send sync cmd followed by sync data messages on all endpoints being
+	     * used
+	     */
+	    status = wmi_cmd_send(wmip, cmd_osbuf, WMI_SYNCHRONIZE_CMDID,
+						  NO_SYNC_WMIFLAG);
+
+        if (A_FAILED(status)) {
+            break;
+        }
+            /* cmd buffer sent, we no longer own it */
+        cmd_osbuf = NULL;
+
+		for(i=0; i < numPriStreams; i++) {
+            A_ASSERT(dataSyncBufs[i].osbuf != NULL);
+
+            status = wmi_dataSync_send(wmip, dataSyncBufs[i].osbuf,
+                        WMI_ACCESSCATEGORY_WMISTREAM(wmip,dataSyncBufs[i].trafficClass));
+
+            if (A_FAILED(status)) {
+                break;
+            }
+            /* we don't own this buffer anymore, NULL it out of the array so it
+             * won't get cleaned up */
+            dataSyncBufs[i].osbuf = NULL;
+		} //end for
+
+    } while(FALSE);
+
+    /* free up any resources left over (possibly due to an error) */
+
+    if (cmd_osbuf != NULL) {
+        A_NETBUF_FREE(cmd_osbuf);
+    }
+
+    for (i = 0; i < numPriStreams; i++) {
+        if (dataSyncBufs[i].osbuf != NULL) {
+            A_NETBUF_FREE(dataSyncBufs[i].osbuf);
+        }
+    }
+
+	return (status);
+}
+
+A_STATUS
+wmi_create_pstream_cmd(struct wmi_t *wmip, WMI_CREATE_PSTREAM_CMD *params)
+{
+    void *osbuf;
+    WMI_CREATE_PSTREAM_CMD *cmd;
+	A_UINT16 activeTsids=0;
+    A_UINT8 fatPipeExistsForAC=0;
+
+    /* Validate all the parameters. */
+    if( !((params->userPriority < 8) &&
+         (params->userPriority <= 0x7) &&
+         (convert_userPriority_to_trafficClass(params->userPriority) == params->trafficClass)  &&
+         (params->trafficDirection == UPLINK_TRAFFIC ||
+            params->trafficDirection == DNLINK_TRAFFIC ||
+            params->trafficDirection == BIDIR_TRAFFIC) &&
+         (params->trafficType == TRAFFIC_TYPE_APERIODIC ||
+            params->trafficType == TRAFFIC_TYPE_PERIODIC ) &&
+         (params->voicePSCapability == DISABLE_FOR_THIS_AC  ||
+            params->voicePSCapability == ENABLE_FOR_THIS_AC ||
+            params->voicePSCapability == ENABLE_FOR_ALL_AC) &&
+         (params->tsid == WMI_IMPLICIT_PSTREAM || params->tsid <= WMI_MAX_THINSTREAM)) )
+    {
+        return  A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Sending create_pstream_cmd: ac=%d    tsid:%d\n", DBGARG,
+        params->trafficClass, params->tsid));
+
+    cmd = (WMI_CREATE_PSTREAM_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    A_MEMCPY(cmd, params, sizeof(*cmd));
+
+        /* this is an implicitly created Fat pipe */
+    if (params->tsid == WMI_IMPLICIT_PSTREAM) {
+        LOCK_WMI(wmip);
+        fatPipeExistsForAC = (wmip->wmi_fatPipeExists & (1 << params->trafficClass));
+        wmip->wmi_fatPipeExists |= (1<<params->trafficClass);
+        UNLOCK_WMI(wmip);
+    } else {
+            /* this is an explicitly created thin stream within a fat pipe */
+        LOCK_WMI(wmip);
+        fatPipeExistsForAC = (wmip->wmi_fatPipeExists & (1 << params->trafficClass));
+        activeTsids = wmip->wmi_streamExistsForAC[params->trafficClass];
+        wmip->wmi_streamExistsForAC[params->trafficClass] |= (1<<params->tsid);
+            /* if a thinstream becomes active, the fat pipe automatically
+            * becomes active
+            */
+        wmip->wmi_fatPipeExists |= (1<<params->trafficClass);
+        UNLOCK_WMI(wmip);
+    }
+
+        /* Indicate activty change to driver layer only if this is the
+         * first TSID to get created in this AC explicitly or an implicit
+         * fat pipe is getting created.
+         */
+    if (!fatPipeExistsForAC) {
+        A_WMI_STREAM_TX_ACTIVE(wmip->wmi_devt, params->trafficClass);
+    }
+
+    /* mike: should be SYNC_BEFORE_WMIFLAG */
+    return (wmi_cmd_send(wmip, osbuf, WMI_CREATE_PSTREAM_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_delete_pstream_cmd(struct wmi_t *wmip, A_UINT8 trafficClass, A_UINT8 tsid)
+{
+    void *osbuf;
+    WMI_DELETE_PSTREAM_CMD *cmd;
+    A_STATUS status;
+	A_UINT16 activeTsids=0;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DELETE_PSTREAM_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+
+    cmd->trafficClass = trafficClass;
+    cmd->tsid = tsid;
+
+    LOCK_WMI(wmip);
+    activeTsids = wmip->wmi_streamExistsForAC[trafficClass];
+    UNLOCK_WMI(wmip);
+
+        /* Check if the tsid was created & exists */
+    if (!(activeTsids & (1<<tsid))) {
+
+        A_DPRINTF(DBG_WMI,
+        (DBGFMT "TSID %d does'nt exist for trafficClass: %d\n", DBGARG, tsid, trafficClass));
+            /* TODO: return a more appropriate err code */
+        return A_ERROR;
+    }
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Sending delete_pstream_cmd: trafficClass: %d tsid=%d\n", DBGARG, trafficClass, tsid));
+
+    status = (wmi_cmd_send(wmip, osbuf, WMI_DELETE_PSTREAM_CMDID,
+                         SYNC_BEFORE_WMIFLAG));
+
+    LOCK_WMI(wmip);
+    wmip->wmi_streamExistsForAC[trafficClass] &= ~(1<<tsid);
+    activeTsids = wmip->wmi_streamExistsForAC[trafficClass];
+    UNLOCK_WMI(wmip);
+
+
+        /* Indicate stream inactivity to driver layer only if all tsids
+         * within this AC are deleted.
+         */
+    if(!activeTsids) {
+        A_WMI_STREAM_TX_INACTIVE(wmip->wmi_devt, trafficClass);
+        wmip->wmi_fatPipeExists &= ~(1<<trafficClass);
+    }
+
+    return status;
+}
+
+/*
+ * used to set the bit rate.  rate is in Kbps.  If rate == -1
+ * then auto selection is used.
+ */
+A_STATUS
+wmi_set_bitrate_cmd(struct wmi_t *wmip, A_INT32 rate)
+{
+    void *osbuf;
+    WMI_BIT_RATE_CMD *cmd;
+    A_INT8 index;
+
+    if (rate != -1) {
+        index = wmi_validate_bitrate(wmip, rate);
+        if(index == A_EINVAL){
+            return A_EINVAL;
+        }
+    } else {
+        index = -1;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BIT_RATE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+
+    cmd->rateIndex = index;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BITRATE_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_bitrate_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_BITRATE_CMDID, NO_SYNC_WMIFLAG));
+}
+
+/*
+ * Returns TRUE iff the given rate index is legal in the current PHY mode.
+ */
+A_BOOL
+wmi_is_bitrate_index_valid(struct wmi_t *wmip, A_UINT32 rateIndex)
+{
+    WMI_PHY_MODE phyMode = wmip->wmi_phyMode;
+    A_BOOL isValid = TRUE;
+    switch(phyMode) {
+        case WMI_11A_MODE:
+            if ((rateIndex < MODE_A_SUPPORT_RATE_START) || (rateIndex > MODE_A_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        case WMI_11B_MODE:
+            if ((rateIndex < MODE_B_SUPPORT_RATE_START) || (rateIndex > MODE_B_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        case WMI_11GONLY_MODE:
+            if ((rateIndex < MODE_GONLY_SUPPORT_RATE_START) || (rateIndex > MODE_GONLY_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        case WMI_11G_MODE:
+        case WMI_11AG_MODE:
+            if ((rateIndex < MODE_G_SUPPORT_RATE_START) || (rateIndex > MODE_G_SUPPORT_RATE_STOP)) {
+                isValid = FALSE;
+            }
+            break;
+
+        default:
+            A_ASSERT(FALSE);
+            break;
+    }
+
+    return isValid;
+}
+
+A_INT8
+wmi_validate_bitrate(struct wmi_t *wmip, A_INT32 rate)
+{
+    A_INT8 i;
+    if (rate != -1)
+    {
+        for (i=0;;i++)
+        {
+            if (wmi_rateTable[(A_UINT32) i] == 0) {
+                return A_EINVAL;
+            }
+            if (wmi_rateTable[(A_UINT32) i] == rate) {
+                break;
+            }
+        }
+    }
+    else{
+     i = -1;
+    }
+
+    if(wmi_is_bitrate_index_valid(wmip, i) != TRUE) {
+        return A_EINVAL;
+    }
+
+    return i;
+}
+
+A_STATUS
+wmi_set_fixrates_cmd(struct wmi_t *wmip, A_INT16 fixRatesMask)
+{
+    void *osbuf;
+    WMI_FIX_RATES_CMD *cmd;
+    A_UINT32 rateIndex;
+
+    /* Make sure all rates in the mask are valid in the current PHY mode */
+    for(rateIndex = 0; rateIndex < MAX_NUMBER_OF_SUPPORT_RATES; rateIndex++) {
+       if((1 << rateIndex) & (A_UINT32)fixRatesMask) {
+            if(wmi_is_bitrate_index_valid(wmip, rateIndex) != TRUE) {
+                A_DPRINTF(DBG_WMI, (DBGFMT "Set Fix Rates command failed: Given rate is illegal in current PHY mode\n", DBGARG));
+                return A_EINVAL;
+            }
+       }
+    }
+
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_FIX_RATES_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+
+    cmd->fixRateMask = fixRatesMask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_FIXRATES_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_ratemask_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_FIXRATES_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_channelList_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_CHANNEL_LIST_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+/*
+ * used to generate a wmi sey channel Parameters cmd.
+ * mode should always be specified and corresponds to the phy mode of the
+ * wlan.
+ * numChan should alway sbe specified. If zero indicates that all available
+ * channels should be used.
+ * channelList is an array of channel frequencies (in Mhz) which the radio
+ * should limit its operation to.  It should be NULL if numChan == 0.  Size of
+ * array should correspond to numChan entries.
+ */
+A_STATUS
+wmi_set_channelParams_cmd(struct wmi_t *wmip, A_UINT8 scanParam,
+                          WMI_PHY_MODE mode, A_INT8 numChan,
+                          A_UINT16 *channelList)
+{
+    void *osbuf;
+    WMI_CHANNEL_PARAMS_CMD *cmd;
+    A_INT8 size;
+
+    size = sizeof (*cmd);
+
+    if (numChan) {
+        if (numChan > WMI_MAX_CHANNELS) {
+            return A_EINVAL;
+        }
+        size += sizeof(A_UINT16) * (numChan - 1);
+    }
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_CHANNEL_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    wmip->wmi_phyMode = mode;
+    cmd->scanParam   = scanParam;
+    cmd->phyMode     = mode;
+    cmd->numChannels = numChan;
+    A_MEMCPY(cmd->channelList, channelList, numChan * sizeof(A_UINT16));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_CHANNEL_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_rssi_threshold_params(struct wmi_t *wmip,
+                              WMI_RSSI_THRESHOLD_PARAMS_CMD *rssiCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_RSSI_THRESHOLD_PARAMS_CMD *cmd;
+    /* These values are in ascending order */
+    if( rssiCmd->thresholdAbove6_Val <= rssiCmd->thresholdAbove5_Val ||
+        rssiCmd->thresholdAbove5_Val <= rssiCmd->thresholdAbove4_Val ||
+        rssiCmd->thresholdAbove4_Val <= rssiCmd->thresholdAbove3_Val ||
+        rssiCmd->thresholdAbove3_Val <= rssiCmd->thresholdAbove2_Val ||
+        rssiCmd->thresholdAbove2_Val <= rssiCmd->thresholdAbove1_Val ||
+        rssiCmd->thresholdBelow6_Val <= rssiCmd->thresholdBelow5_Val ||
+        rssiCmd->thresholdBelow5_Val <= rssiCmd->thresholdBelow4_Val ||
+        rssiCmd->thresholdBelow4_Val <= rssiCmd->thresholdBelow3_Val ||
+        rssiCmd->thresholdBelow3_Val <= rssiCmd->thresholdBelow2_Val ||
+        rssiCmd->thresholdBelow2_Val <= rssiCmd->thresholdBelow1_Val) {
+
+        return A_EINVAL;
+    }
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_RSSI_THRESHOLD_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, rssiCmd, sizeof(WMI_RSSI_THRESHOLD_PARAMS_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_RSSI_THRESHOLD_PARAMS_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_host_sleep_mode_cmd(struct wmi_t *wmip,
+                              WMI_SET_HOST_SLEEP_MODE_CMD *hostModeCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_SET_HOST_SLEEP_MODE_CMD *cmd;
+
+    if( hostModeCmd->awake == hostModeCmd->asleep) {
+        return A_EINVAL;
+    }
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SET_HOST_SLEEP_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, hostModeCmd, sizeof(WMI_SET_HOST_SLEEP_MODE_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_HOST_SLEEP_MODE_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_wow_mode_cmd(struct wmi_t *wmip,
+                              WMI_SET_WOW_MODE_CMD *wowModeCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_SET_WOW_MODE_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SET_WOW_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, wowModeCmd, sizeof(WMI_SET_WOW_MODE_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WOW_MODE_CMDID,
+                            NO_SYNC_WMIFLAG));
+
+}
+
+A_STATUS
+wmi_get_wow_list_cmd(struct wmi_t *wmip,
+                              WMI_GET_WOW_LIST_CMD *wowListCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_GET_WOW_LIST_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_GET_WOW_LIST_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, wowListCmd, sizeof(WMI_GET_WOW_LIST_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_WOW_LIST_CMDID,
+                            NO_SYNC_WMIFLAG));
+
+}
+
+static A_STATUS
+wmi_get_wow_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+    WMI_GET_WOW_LIST_REPLY *reply;
+
+    if (len < sizeof(WMI_GET_WOW_LIST_REPLY)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_GET_WOW_LIST_REPLY *)datap;
+
+    A_WMI_WOW_LIST_EVENT(wmip->wmi_devt, reply->num_filters,
+                          reply);
+
+    return A_OK;
+}
+
+A_STATUS wmi_add_wow_pattern_cmd(struct wmi_t *wmip,
+                                 WMI_ADD_WOW_PATTERN_CMD *addWowCmd,
+                                 A_UINT8* pattern, A_UINT8* mask,
+                                 A_UINT8 pattern_size)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_ADD_WOW_PATTERN_CMD *cmd;
+    A_UINT8 *filter_mask = NULL;
+
+    size = sizeof (*cmd);
+
+    size += ((2 * addWowCmd->filter_size)* sizeof(A_UINT8));
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_ADD_WOW_PATTERN_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->filter_list_id = addWowCmd->filter_list_id;
+    cmd->filter_offset = addWowCmd->filter_offset;
+    cmd->filter_size = addWowCmd->filter_size;
+
+    A_MEMCPY(cmd->filter, pattern, addWowCmd->filter_size);
+
+    filter_mask = (A_UINT8*)(cmd->filter + cmd->filter_size);
+    A_MEMCPY(filter_mask, mask, addWowCmd->filter_size);
+
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_WOW_PATTERN_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_del_wow_pattern_cmd(struct wmi_t *wmip,
+                              WMI_DEL_WOW_PATTERN_CMD *delWowCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_DEL_WOW_PATTERN_CMD *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_DEL_WOW_PATTERN_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, delWowCmd, sizeof(WMI_DEL_WOW_PATTERN_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DEL_WOW_PATTERN_CMDID,
+                            NO_SYNC_WMIFLAG));
+
+}
+
+A_STATUS
+wmi_set_snr_threshold_params(struct wmi_t *wmip,
+                             WMI_SNR_THRESHOLD_PARAMS_CMD *snrCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_SNR_THRESHOLD_PARAMS_CMD *cmd;
+    /* These values are in ascending order */
+    if( snrCmd->thresholdAbove4_Val <= snrCmd->thresholdAbove3_Val ||
+        snrCmd->thresholdAbove3_Val <= snrCmd->thresholdAbove2_Val ||
+        snrCmd->thresholdAbove2_Val <= snrCmd->thresholdAbove1_Val ||
+        snrCmd->thresholdBelow4_Val <= snrCmd->thresholdBelow3_Val ||
+        snrCmd->thresholdBelow3_Val <= snrCmd->thresholdBelow2_Val ||
+        snrCmd->thresholdBelow2_Val <= snrCmd->thresholdBelow1_Val) {
+
+        return A_EINVAL;
+    }
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SNR_THRESHOLD_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, snrCmd, sizeof(WMI_SNR_THRESHOLD_PARAMS_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SNR_THRESHOLD_PARAMS_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_clr_rssi_snr(struct wmi_t *wmip)
+{
+    void    *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(int));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_CLR_RSSI_SNR_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_lq_threshold_params(struct wmi_t *wmip,
+                             WMI_LQ_THRESHOLD_PARAMS_CMD *lqCmd)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_LQ_THRESHOLD_PARAMS_CMD *cmd;
+    /* These values are in ascending order */
+    if( lqCmd->thresholdAbove4_Val <= lqCmd->thresholdAbove3_Val ||
+        lqCmd->thresholdAbove3_Val <= lqCmd->thresholdAbove2_Val ||
+        lqCmd->thresholdAbove2_Val <= lqCmd->thresholdAbove1_Val ||
+        lqCmd->thresholdBelow4_Val <= lqCmd->thresholdBelow3_Val ||
+        lqCmd->thresholdBelow3_Val <= lqCmd->thresholdBelow2_Val ||
+        lqCmd->thresholdBelow2_Val <= lqCmd->thresholdBelow1_Val ) {
+
+        return A_EINVAL;
+    }
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_LQ_THRESHOLD_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+    A_MEMCPY(cmd, lqCmd, sizeof(WMI_LQ_THRESHOLD_PARAMS_CMD));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_LQ_THRESHOLD_PARAMS_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_error_report_bitmask(struct wmi_t *wmip, A_UINT32 mask)
+{
+    void    *osbuf;
+    A_INT8  size;
+    WMI_TARGET_ERROR_REPORT_BITMASK *cmd;
+
+    size = sizeof (*cmd);
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_TARGET_ERROR_REPORT_BITMASK *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    cmd->bitmask = mask;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_TARGET_ERROR_REPORT_BITMASK_CMDID,
+                            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_challenge_resp_cmd(struct wmi_t *wmip, A_UINT32 cookie, A_UINT32 source)
+{
+    void *osbuf;
+    WMIX_HB_CHALLENGE_RESP_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMIX_HB_CHALLENGE_RESP_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->cookie = cookie;
+    cmd->source = source;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_HB_CHALLENGE_RESP_CMDID,
+                              NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_config_debug_module_cmd(struct wmi_t *wmip, A_UINT16 mmask,
+                            A_UINT16 tsr, A_BOOL rep, A_UINT16 size,
+                            A_UINT32 valid)
+{
+    void *osbuf;
+    WMIX_DBGLOG_CFG_MODULE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMIX_DBGLOG_CFG_MODULE_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->config.cfgmmask = mmask;
+    cmd->config.cfgtsr = tsr;
+    cmd->config.cfgrep = rep;
+    cmd->config.cfgsize = size;
+    cmd->config.cfgvalid = valid;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_DBGLOG_CFG_MODULE_CMDID,
+                              NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_stats_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_STATISTICS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_addBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex, A_UINT8 *bssid)
+{
+    void *osbuf;
+    WMI_ADD_BAD_AP_CMD *cmd;
+
+    if ((bssid == NULL) || (apIndex > WMI_MAX_BAD_AP_INDEX)) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_ADD_BAD_AP_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->badApIndex = apIndex;
+    A_MEMCPY(cmd->bssid, bssid, sizeof(cmd->bssid));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_ADD_BAD_AP_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_deleteBadAp_cmd(struct wmi_t *wmip, A_UINT8 apIndex)
+{
+    void *osbuf;
+    WMI_DELETE_BAD_AP_CMD *cmd;
+
+    if (apIndex > WMI_MAX_BAD_AP_INDEX) {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_DELETE_BAD_AP_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->badApIndex = apIndex;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_DELETE_BAD_AP_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_txPwr_cmd(struct wmi_t *wmip, A_UINT8 dbM)
+{
+    void *osbuf;
+    WMI_SET_TX_PWR_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_TX_PWR_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->dbM = dbM;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_TX_PWR_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_txPwr_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_TX_PWR_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_switch_radio(struct wmi_t *wmip, A_UINT8 on)
+{
+	WMI_SCAN_PARAMS_CMD scParams = {0, 0, 0, 0, 0,
+					WMI_SHORTSCANRATIO_DEFAULT,
+					DEFAULT_SCAN_CTRL_FLAGS,
+					0};
+
+	if (on) {
+		/* Enable foreground scanning */
+                if (wmi_scanparams_cmd(wmip, scParams.fg_start_period,
+                                       scParams.fg_end_period,
+                                       scParams.bg_period,
+                                       scParams.minact_chdwell_time,
+                                       scParams.maxact_chdwell_time,
+                                       scParams.pas_chdwell_time,
+                                       scParams.shortScanRatio,
+                                       scParams.scanCtrlFlags,
+                                       scParams.max_dfsch_act_time) != A_OK) {
+			return -EIO;
+		}
+	} else {
+		wmi_disconnect_cmd(wmip);
+		if (wmi_scanparams_cmd(wmip, 0xFFFF, 0, 0, 0,
+				       0, 0, 0, 0xFF, 0) != A_OK) {
+			return -EIO;
+		}
+	}
+
+	return A_OK;
+}
+
+
+A_UINT16
+wmi_get_mapped_qos_queue(struct wmi_t *wmip, A_UINT8 trafficClass)
+{
+	A_UINT16 activeTsids=0;
+
+    LOCK_WMI(wmip);
+    activeTsids = wmip->wmi_streamExistsForAC[trafficClass];
+    UNLOCK_WMI(wmip);
+
+    return activeTsids;
+}
+
+A_STATUS
+wmi_get_roam_tbl_cmd(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    osbuf = A_NETBUF_ALLOC(0);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_ROAM_TBL_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_roam_data_cmd(struct wmi_t *wmip, A_UINT8 roamDataType)
+{
+    void *osbuf;
+    A_UINT32 size = sizeof(A_UINT8);
+    WMI_TARGET_ROAM_DATA *cmd;
+
+    osbuf = A_NETBUF_ALLOC(size);      /* no payload */
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_TARGET_ROAM_DATA *)(A_NETBUF_DATA(osbuf));
+    cmd->roamDataType = roamDataType;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_ROAM_DATA_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_roam_ctrl_cmd(struct wmi_t *wmip, WMI_SET_ROAM_CTRL_CMD *p,
+                      A_UINT8 size)
+{
+    void *osbuf;
+    WMI_SET_ROAM_CTRL_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_SET_ROAM_CTRL_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    A_MEMCPY(cmd, p, size);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_ROAM_CTRL_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_powersave_timers_cmd(struct wmi_t *wmip,
+                            WMI_POWERSAVE_TIMERS_POLICY_CMD *pCmd,
+                            A_UINT8 size)
+{
+    void *osbuf;
+    WMI_POWERSAVE_TIMERS_POLICY_CMD *cmd;
+
+    /* These timers can't be zero */
+    if(!pCmd->psPollTimeout || !pCmd->triggerTimeout ||
+       !(pCmd->apsdTimPolicy == IGNORE_TIM_ALL_QUEUES_APSD ||
+         pCmd->apsdTimPolicy == PROCESS_TIM_ALL_QUEUES_APSD) ||
+       !(pCmd->simulatedAPSDTimPolicy == IGNORE_TIM_SIMULATED_APSD ||
+         pCmd->simulatedAPSDTimPolicy == PROCESS_TIM_SIMULATED_APSD))
+        return A_EINVAL;
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, size);
+
+    cmd = (WMI_POWERSAVE_TIMERS_POLICY_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, size);
+
+    A_MEMCPY(cmd, pCmd, size);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_POWERSAVE_TIMERS_POLICY_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+#ifdef CONFIG_HOST_GPIO_SUPPORT
+/* Send a command to Target to change GPIO output pins. */
+A_STATUS
+wmi_gpio_output_set(struct wmi_t *wmip,
+                    A_UINT32 set_mask,
+                    A_UINT32 clear_mask,
+                    A_UINT32 enable_mask,
+                    A_UINT32 disable_mask)
+{
+    void *osbuf;
+    WMIX_GPIO_OUTPUT_SET_CMD *output_set;
+    int size;
+
+    size = sizeof(*output_set);
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - set=0x%x clear=0x%x enb=0x%x dis=0x%x\n", DBGARG,
+        set_mask, clear_mask, enable_mask, disable_mask));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    output_set = (WMIX_GPIO_OUTPUT_SET_CMD *)(A_NETBUF_DATA(osbuf));
+
+    output_set->set_mask                   = set_mask;
+    output_set->clear_mask                 = clear_mask;
+    output_set->enable_mask                = enable_mask;
+    output_set->disable_mask               = disable_mask;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_OUTPUT_SET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target requesting state of the GPIO input pins */
+A_STATUS
+wmi_gpio_input_get(struct wmi_t *wmip)
+{
+    void *osbuf;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    osbuf = A_NETBUF_ALLOC(0);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_INPUT_GET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target that changes the value of a GPIO register. */
+A_STATUS
+wmi_gpio_register_set(struct wmi_t *wmip,
+                      A_UINT32 gpioreg_id,
+                      A_UINT32 value)
+{
+    void *osbuf;
+    WMIX_GPIO_REGISTER_SET_CMD *register_set;
+    int size;
+
+    size = sizeof(*register_set);
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - reg=%d value=0x%x\n", DBGARG, gpioreg_id, value));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    register_set = (WMIX_GPIO_REGISTER_SET_CMD *)(A_NETBUF_DATA(osbuf));
+
+    register_set->gpioreg_id               = gpioreg_id;
+    register_set->value                    = value;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_REGISTER_SET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target to fetch the value of a GPIO register. */
+A_STATUS
+wmi_gpio_register_get(struct wmi_t *wmip,
+                      A_UINT32 gpioreg_id)
+{
+    void *osbuf;
+    WMIX_GPIO_REGISTER_GET_CMD *register_get;
+    int size;
+
+    size = sizeof(*register_get);
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter - reg=%d\n", DBGARG, gpioreg_id));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    register_get = (WMIX_GPIO_REGISTER_GET_CMD *)(A_NETBUF_DATA(osbuf));
+
+    register_get->gpioreg_id               = gpioreg_id;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_REGISTER_GET_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+/* Send a command to the Target acknowledging some GPIO interrupts. */
+A_STATUS
+wmi_gpio_intr_ack(struct wmi_t *wmip,
+                  A_UINT32 ack_mask)
+{
+    void *osbuf;
+    WMIX_GPIO_INTR_ACK_CMD *intr_ack;
+    int size;
+
+    size = sizeof(*intr_ack);
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter ack_mask=0x%x\n", DBGARG, ack_mask));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    intr_ack = (WMIX_GPIO_INTR_ACK_CMD *)(A_NETBUF_DATA(osbuf));
+
+    intr_ack->ack_mask               = ack_mask;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_GPIO_INTR_ACK_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+#endif /* CONFIG_HOST_GPIO_SUPPORT */
+
+A_STATUS
+wmi_set_access_params_cmd(struct wmi_t *wmip, A_UINT16 txop, A_UINT8 eCWmin,
+                          A_UINT8 eCWmax, A_UINT8 aifsn)
+{
+    void *osbuf;
+    WMI_SET_ACCESS_PARAMS_CMD *cmd;
+
+    if ((eCWmin > WMI_MAX_CW_ACPARAM) || (eCWmax > WMI_MAX_CW_ACPARAM) ||
+        (aifsn > WMI_MAX_AIFSN_ACPARAM))
+    {
+        return A_EINVAL;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_ACCESS_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->txop   = txop;
+    cmd->eCWmin = eCWmin;
+    cmd->eCWmax = eCWmax;
+    cmd->aifsn  = aifsn;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_ACCESS_PARAMS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_retry_limits_cmd(struct wmi_t *wmip, A_UINT8 frameType,
+                         A_UINT8 trafficClass, A_UINT8 maxRetries,
+                         A_UINT8 enableNotify)
+{
+    void *osbuf;
+    WMI_SET_RETRY_LIMITS_CMD *cmd;
+
+    if ((frameType != MGMT_FRAMETYPE) && (frameType != CONTROL_FRAMETYPE) &&
+        (frameType != DATA_FRAMETYPE))
+    {
+        return A_EINVAL;
+    }
+
+    if (maxRetries > WMI_MAX_RETRIES) {
+        return A_EINVAL;
+    }
+
+    if (frameType != DATA_FRAMETYPE) {
+        trafficClass = 0;
+    }
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_RETRY_LIMITS_CMD *)(A_NETBUF_DATA(osbuf));
+    cmd->frameType    = frameType;
+    cmd->trafficClass = trafficClass;
+    cmd->maxRetries   = maxRetries;
+    cmd->enableNotify = enableNotify;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_RETRY_LIMITS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+void
+wmi_get_current_bssid(struct wmi_t *wmip, A_UINT8 *bssid)
+{
+    if (bssid != NULL) {
+        A_MEMCPY(bssid, wmip->wmi_bssid, ATH_MAC_LEN);
+    }
+}
+
+A_STATUS
+wmi_set_opt_mode_cmd(struct wmi_t *wmip, A_UINT8 optMode)
+{
+    void *osbuf;
+    WMI_SET_OPT_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_OPT_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->optMode = optMode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_OPT_MODE_CMDID,
+                         SYNC_BOTH_WMIFLAG));
+}
+
+A_STATUS
+wmi_opt_tx_frame_cmd(struct wmi_t *wmip,
+                      A_UINT8 frmType,
+                      A_UINT8 *dstMacAddr,
+                      A_UINT8 *bssid,
+                      A_UINT16 optIEDataLen,
+                      A_UINT8 *optIEData)
+{
+    void *osbuf;
+    WMI_OPT_TX_FRAME_CMD *cmd;
+    osbuf = A_NETBUF_ALLOC(optIEDataLen + sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, (optIEDataLen + sizeof(*cmd)));
+
+    cmd = (WMI_OPT_TX_FRAME_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, (optIEDataLen + sizeof(*cmd)-1));
+
+    cmd->frmType    = frmType;
+    cmd->optIEDataLen   = optIEDataLen;
+    //cmd->optIEData     = (A_UINT8 *)((int)cmd + sizeof(*cmd));
+    A_MEMCPY(cmd->bssid, bssid, sizeof(cmd->bssid));
+    A_MEMCPY(cmd->dstAddr, dstMacAddr, sizeof(cmd->dstAddr));
+    A_MEMCPY(&cmd->optIEData[0], optIEData, optIEDataLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_OPT_TX_FRAME_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_adhoc_bconIntvl_cmd(struct wmi_t *wmip, A_UINT16 intvl)
+{
+    void *osbuf;
+    WMI_BEACON_INT_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_BEACON_INT_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->beaconInterval = intvl;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BEACON_INT_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+
+A_STATUS
+wmi_set_voice_pkt_size_cmd(struct wmi_t *wmip, A_UINT16 voicePktSize)
+{
+    void *osbuf;
+    WMI_SET_VOICE_PKT_SIZE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_VOICE_PKT_SIZE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->voicePktSize = voicePktSize;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_VOICE_PKT_SIZE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+
+A_STATUS
+wmi_set_max_sp_len_cmd(struct wmi_t *wmip, A_UINT8 maxSPLen)
+{
+    void *osbuf;
+    WMI_SET_MAX_SP_LEN_CMD *cmd;
+
+    /* maxSPLen is a two-bit value. If user trys to set anything
+     * other than this, then its invalid
+     */
+    if(maxSPLen & ~0x03)
+        return  A_EINVAL;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_MAX_SP_LEN_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->maxSPLen = maxSPLen;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_MAX_SP_LEN_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_UINT8
+convert_userPriority_to_trafficClass(A_UINT8 userPriority)
+{
+        return  (up_to_ac[userPriority & 0x7]);
+}
+
+A_UINT8
+wmi_get_power_mode_cmd(struct wmi_t *wmip)
+{
+    return wmip->wmi_powerMode;
+}
+
+A_STATUS
+wmi_verify_tspec_params(WMI_CREATE_PSTREAM_CMD *pCmd, A_BOOL tspecCompliance)
+{
+    return A_OK;
+}
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+static A_STATUS
+wmi_tcmd_test_report_rx(struct wmi_t *wmip, A_UINT8 *datap, int len)
+{
+
+   A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+   A_WMI_TCMD_RX_REPORT_EVENT(wmip->wmi_devt, datap, len);
+
+   return A_OK;
+}
+
+#endif /* CONFIG_HOST_TCMD_SUPPORT*/
+
+A_STATUS
+wmi_set_authmode_cmd(struct wmi_t *wmip, A_UINT8 mode)
+{
+    void *osbuf;
+    WMI_SET_AUTH_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_AUTH_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->mode = mode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_AUTH_MODE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_reassocmode_cmd(struct wmi_t *wmip, A_UINT8 mode)
+{
+    void *osbuf;
+    WMI_SET_REASSOC_MODE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_REASSOC_MODE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->mode = mode;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_REASSOC_MODE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_lpreamble_cmd(struct wmi_t *wmip, A_UINT8 status)
+{
+    void *osbuf;
+    WMI_SET_LPREAMBLE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_LPREAMBLE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->status = status;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_LPREAMBLE_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_rts_cmd(struct wmi_t *wmip, A_UINT16 threshold)
+{
+    void *osbuf;
+    WMI_SET_RTS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_RTS_CMD*)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->threshold = threshold;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_RTS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_wmm_cmd(struct wmi_t *wmip, WMI_WMM_STATUS status)
+{
+    void *osbuf;
+    WMI_SET_WMM_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_WMM_CMD*)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->status = status;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WMM_CMDID,
+            NO_SYNC_WMIFLAG));
+
+}
+
+A_STATUS
+wmi_set_wmm_txop(struct wmi_t *wmip, WMI_TXOP_CFG cfg)
+{
+    void *osbuf;
+    WMI_SET_WMM_TXOP_CMD *cmd;
+
+    if( !((cfg == WMI_TXOP_DISABLED) || (cfg == WMI_TXOP_ENABLED)) )
+        return A_EINVAL;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_WMM_TXOP_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->txopEnable = cfg;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WMM_TXOP_CMDID,
+            NO_SYNC_WMIFLAG));
+
+}
+
+#ifdef CONFIG_HOST_TCMD_SUPPORT
+/* WMI  layer doesn't need to know the data type of the test cmd.
+   This would be beneficial for customers like Qualcomm, who might
+   have different test command requirements from differnt manufacturers
+ */
+A_STATUS
+wmi_test_cmd(struct wmi_t *wmip, A_UINT8 *buf, A_UINT32  len)
+{
+    void *osbuf;
+    char *data;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter\n", DBGARG));
+
+    osbuf= A_NETBUF_ALLOC(len);
+    if(osbuf == NULL)
+    {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, len);
+    data = A_NETBUF_DATA(osbuf);
+    A_MEMCPY(data, buf, len);
+
+    return(wmi_cmd_send(wmip, osbuf, WMI_TEST_CMDID,
+         NO_SYNC_WMIFLAG));
+}
+
+#endif
+
+A_STATUS
+wmi_set_bt_status_cmd(struct wmi_t *wmip, A_UINT8 streamType, A_UINT8 status)
+{
+    void *osbuf;
+    WMI_SET_BT_STATUS_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_BT_STATUS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->streamType = streamType;
+    cmd->status = status;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BT_STATUS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_bt_params_cmd(struct wmi_t *wmip, WMI_SET_BT_PARAMS_CMD* cmd)
+{
+    void *osbuf;
+    WMI_SET_BT_PARAMS_CMD* alloc_cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    alloc_cmd = (WMI_SET_BT_PARAMS_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(alloc_cmd, sizeof(*cmd));
+    A_MEMCPY(alloc_cmd, cmd, sizeof(*cmd));
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_BT_PARAMS_CMDID,
+            NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_get_keepalive_configured(struct wmi_t *wmip)
+{
+    void *osbuf;
+    WMI_GET_KEEPALIVE_CMD *cmd;
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+    cmd = (WMI_GET_KEEPALIVE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    return (wmi_cmd_send(wmip, osbuf, WMI_GET_KEEPALIVE_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_UINT8
+wmi_get_keepalive_cmd(struct wmi_t *wmip)
+{
+    return wmip->wmi_keepaliveInterval;
+}
+
+A_STATUS
+wmi_set_keepalive_cmd(struct wmi_t *wmip, A_UINT8 keepaliveInterval)
+{
+    void *osbuf;
+    WMI_SET_KEEPALIVE_CMD *cmd;
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*cmd));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*cmd));
+
+    cmd = (WMI_SET_KEEPALIVE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd->keepaliveInterval = keepaliveInterval;
+    wmip->wmi_keepaliveInterval = keepaliveInterval;
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_KEEPALIVE_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_appie_cmd(struct wmi_t *wmip, A_UINT8 mgmtFrmType, A_UINT8 ieLen,
+                  A_UINT8 *ieInfo)
+{
+    void *osbuf;
+    WMI_SET_APPIE_CMD *cmd;
+    A_UINT16 cmdLen;
+
+    if (ieLen > WMI_MAX_IE_LEN) {
+        return A_ERROR;
+    }
+    cmdLen = sizeof(*cmd) + ieLen - 1;
+    osbuf = A_NETBUF_ALLOC(cmdLen);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, cmdLen);
+
+    cmd = (WMI_SET_APPIE_CMD *)(A_NETBUF_DATA(osbuf));
+    A_MEMZERO(cmd, cmdLen);
+
+    cmd->mgmtFrmType = mgmtFrmType;
+    cmd->ieLen = ieLen;
+    A_MEMCPY(cmd->ieInfo, ieInfo, ieLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_APPIE_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_STATUS
+wmi_set_halparam_cmd(struct wmi_t *wmip, A_UINT8 *cmd, A_UINT16 dataLen)
+{
+    void *osbuf;
+    A_UINT8 *data;
+
+    osbuf = A_NETBUF_ALLOC(dataLen);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, dataLen);
+
+    data = A_NETBUF_DATA(osbuf);
+
+    A_MEMCPY(data, cmd, dataLen);
+
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WHALPARAM_CMDID, NO_SYNC_WMIFLAG));
+}
+
+A_INT32
+wmi_get_rate(A_INT8 rateindex)
+{
+    if (rateindex == RATE_AUTO) {
+        return 0;
+    } else {
+        return(wmi_rateTable[(A_UINT32) rateindex]);
+    }
+}
+
+void
+wmi_node_return (struct wmi_t *wmip, bss_t *bss)
+{
+	if (NULL != bss)
+	{
+		wlan_node_return (&wmip->wmi_scan_table, bss);
+	}
+}
+
+bss_t *
+wmi_find_Ssidnode (struct wmi_t *wmip, A_UCHAR *pSsid,
+				   A_UINT32 ssidLength, A_BOOL bIsWPA2)
+{
+	bss_t *node = NULL;
+    node = wlan_find_Ssidnode (&wmip->wmi_scan_table, pSsid,
+							   ssidLength, bIsWPA2);
+	return node;
+}
+
+void
+wmi_free_allnodes(struct wmi_t *wmip)
+{
+	wlan_free_allnodes(&wmip->wmi_scan_table);
+}
+
+bss_t *
+wmi_find_node(struct wmi_t *wmip, const A_UINT8 *macaddr)
+{
+	bss_t *ni=NULL;
+	ni=wlan_find_node(&wmip->wmi_scan_table,macaddr);
+	return ni;
+}
+
+A_STATUS
+wmi_dset_open_reply(struct wmi_t *wmip,
+                    A_UINT32 status,
+                    A_UINT32 access_cookie,
+                    A_UINT32 dset_size,
+                    A_UINT32 dset_version,
+                    A_UINT32 targ_handle,
+                    A_UINT32 targ_reply_fn,
+                    A_UINT32 targ_reply_arg)
+{
+    void *osbuf;
+    WMIX_DSETOPEN_REPLY_CMD *open_reply;
+
+    A_DPRINTF(DBG_WMI, (DBGFMT "Enter - wmip=0x%x\n", DBGARG, (int)wmip));
+
+    osbuf = A_NETBUF_ALLOC(sizeof(*open_reply));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    A_NETBUF_PUT(osbuf, sizeof(*open_reply));
+    open_reply = (WMIX_DSETOPEN_REPLY_CMD *)(A_NETBUF_DATA(osbuf));
+
+    open_reply->status                   = status;
+    open_reply->targ_dset_handle         = targ_handle;
+    open_reply->targ_reply_fn            = targ_reply_fn;
+    open_reply->targ_reply_arg           = targ_reply_arg;
+    open_reply->access_cookie            = access_cookie;
+    open_reply->size                     = dset_size;
+    open_reply->version                  = dset_version;
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_DSETOPEN_REPLY_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+
+static A_STATUS
+wmi_get_pmkid_list_event_rx(struct wmi_t *wmip, A_UINT8 *datap, A_UINT32 len)
+{
+    WMI_PMKID_LIST_REPLY *reply;
+    A_UINT32 expected_len;
+
+    if (len < sizeof(WMI_PMKID_LIST_REPLY)) {
+        return A_EINVAL;
+    }
+    reply = (WMI_PMKID_LIST_REPLY *)datap;
+    expected_len = sizeof(reply->numPMKID) + reply->numPMKID * WMI_PMKID_LEN;
+
+    if (len < expected_len) {
+        return A_EINVAL;
+    }
+
+    A_WMI_PMKID_LIST_EVENT(wmip->wmi_devt, reply->numPMKID,
+                           reply->pmkidList);
+
+    return A_OK;
+}
+
+#ifdef CONFIG_HOST_DSET_SUPPORT
+A_STATUS
+wmi_dset_data_reply(struct wmi_t *wmip,
+                    A_UINT32 status,
+                    A_UINT8 *user_buf,
+                    A_UINT32 length,
+                    A_UINT32 targ_buf,
+                    A_UINT32 targ_reply_fn,
+                    A_UINT32 targ_reply_arg)
+{
+    void *osbuf;
+    WMIX_DSETDATA_REPLY_CMD *data_reply;
+    int size;
+
+    size = sizeof(*data_reply) + length;
+
+    A_DPRINTF(DBG_WMI,
+        (DBGFMT "Enter - length=%d status=%d\n", DBGARG, length, status));
+
+    osbuf = A_NETBUF_ALLOC(size);
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+    A_NETBUF_PUT(osbuf, size);
+    data_reply = (WMIX_DSETDATA_REPLY_CMD *)(A_NETBUF_DATA(osbuf));
+
+    data_reply->status                     = status;
+    data_reply->targ_buf                   = targ_buf;
+    data_reply->targ_reply_fn              = targ_reply_fn;
+    data_reply->targ_reply_arg             = targ_reply_arg;
+    data_reply->length                     = length;
+
+    if (status == A_OK) {
+        if (a_copy_from_user(data_reply->buf, user_buf, length)) {
+            return A_ERROR;
+        }
+    }
+
+    return (wmi_cmd_send_xtnd(wmip, osbuf, WMIX_DSETDATA_REPLY_CMDID,
+                             NO_SYNC_WMIFLAG));
+}
+#endif /* CONFIG_HOST_DSET_SUPPORT */
+
+A_STATUS
+wmi_set_wsc_status_cmd(struct wmi_t *wmip, A_UINT32 status)
+{
+    void *osbuf;
+    char *cmd;
+
+	wps_enable = status;
+
+    osbuf = a_netbuf_alloc(sizeof(1));
+    if (osbuf == NULL) {
+        return A_NO_MEMORY;
+    }
+
+    a_netbuf_put(osbuf, sizeof(1));
+
+    cmd = (char *)(a_netbuf_to_data(osbuf));
+
+    A_MEMZERO(cmd, sizeof(*cmd));
+    cmd[0] = (status?1:0);
+    return (wmi_cmd_send(wmip, osbuf, WMI_SET_WSC_STATUS_CMDID,
+                         NO_SYNC_WMIFLAG));
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/wmi/wmi_doc.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/wmi/wmi_doc.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/wmi/wmi_doc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/wmi/wmi_doc.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,4421 @@
+/*
+ *
+ * Copyright (c) 2004-2007 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+
+#if 0
+Wireless Module Interface (WMI) Documentaion
+
+   This section describes the format and the usage model for WMI control and
+   data messages between the host and the AR6000-based targets. The header
+   file include/wmi.h contains all command and event manifest constants as
+   well as structure typedefs for each set of command and reply parameters.
+
+Data Frames
+
+   The data payload transmitted and received by the target follows RFC-1042
+   encapsulation and thus starts with an 802.2-style LLC-SNAP header. The
+   WLAN module completes 802.11 encapsulation of the payload, including the
+   MAC header, FCS, and WLAN security related fields. At the interface to the
+   message transport (HTC), a data frame is encapsulated in a WMI message.
+
+WMI Message Structure
+
+   The WMI protocol leverages an 802.3-style Ethernet header in communicating
+   the source and destination information between the host and the AR6000
+   modules using a 14-byte 802.3 header ahead of the 802.2-style payload. In
+   addition, the WMI protocol adds a header to all data messages:
+
+    {
+    INT8    rssi
+                  The RSSI of the received packet and its units are shown in db above the
+                      noise floor, and the noise floor is shown in dbm.
+    UINT8   info
+                      Contains information on message type and user priority. Message type
+                      differentiates between a data packet and a synchronization message.
+    } WMI_DATA_HDR
+
+   User priority contains the 802.1d user priority info from host to target. Host
+   software translates the host Ethernet format to 802.3 format prior to Tx and
+   802.3 format to host format in the Rx direction. The host does not transmit the
+   FCS that follows the data. MsgType differentiates between a regular data
+   packet (msgType=0) and a synchronization message (msgType=1).
+
+Data Endpoints
+
+   The AR6000 chipset provides several data endpoints to support quality of
+   service (QoS) and maintains separate queues and separate DMA engines for
+   each data endpoint. A data endpoint can be bi-directional.
+
+   Best effort (BE) class traffic uses the default data endpoint (2). The host can
+   establish up to two additional data endpoints for other traffic classes. Once
+   such a data endpoint is established, it sends and receives corresponding QoS
+   traffic in a manner similar to the default data endpoint.
+
+   If QoS is desired over the interconnect, host software must classify each data
+   packet and place it on the appropriate data endpoint. The information
+   required to classify data is generally available in-band as an 802.1p/q style
+   tag or as the ToS field in the IP header. The information may also be available
+   out-of-band depending on the host DDI.
+
+Connection States
+
+   Table B-1 describes the AR6000 WLAN connection states:
+
+   Table B-1.  AR6000 Connection States
+
+Connection State
+    Description
+
+   DISCONNECTED
+    In this state, the AR6000 device is not connected to a wireless
+   network. The device is in this state after reset when it sends the
+   WIRELESS MODULE READY EVENT, after it processes a
+   DISCONNECT command, and when it loses its link with the
+   access point (AP) that it was connected to. The device signals a
+   transition to the DISCONNECTED state with a DISCONNECT
+   event.
+
+CONNECTED
+    In this state, the AR6000 device is connected to wireless networks.
+   The device enters this state after successfully processing a
+   CONNECT, which establishes a connection with a wireless
+   network. The device signals a transition to the CONNECTED state
+   with a CONNECT event.
+
+
+Message Types
+
+   WMI uses commands, replies, and events for the control and configuration of
+   the AR6000 device. The control protocol is asynchronous. Table B-2 describes
+   AR6000 message types:
+
+Table B-2.  AR6000 Message Types
+
+Message Type
+    Description
+
+Commands
+    Control messages that flow from the host to the device
+
+Replies/Events
+    Control messages that flow from the device to the host.
+
+   The device issues a reply to some WMI commands, but not to others.
+   The payload in a reply is command-specific, and some commands do
+   not trigger a reply message at all. Events are control messages issued
+   by the device to signal the occurrence of an asynchronous event.
+
+
+WMI Message Format
+
+   All WMI control commands, replies and events use the header format:
+
+   WMI_CMD_HDR Header Format
+   {
+        UINT16 id
+                 This 16-bit constant identifies which WMI command the host is issuing,
+                 which command the target is replying to, or which event has occurred.
+        WMI_CMD_HDR
+   }
+
+
+   A variable-size command-, reply-, or event-specific payload follows the
+   header. Over the interconnect, all fields in control messages (including
+   WMI_CMD_HDR and the command specific payload) use 32-bit little Endian
+   byte ordering and fields are packed. The AR6000 device always executes
+   commands in order, and the host may send multiple commands without
+   waiting for previous commands to complete. A majority of commands are
+   processed to completion once received. Other commands trigger a longer
+   duration activity whose completion is signaled to the host through an event.
+
+Command Restrictions
+
+   Some commands may only be issued when the AR6000 device is in a certain
+   state. The host is required to wait for an event signaling a state transition
+   before such a command can be issued. For example, if a command requires
+   the device to be in the CONNECTED state, then the host is required to wait
+   for a CONNECT event before it issues that command.
+
+   The device ignores any commands inappropriate for its current state. If the
+   command triggers a reply, the device generates an error reply. Otherwise, the
+   device silently ignores the inappropriate command.
+
+Command and Data Synchronization
+
+   WMI provides a mechanism for a host to advise the device of necessary
+   synchronization between commands and data. The device implements
+   synchronization; no implicit synchronization exists between endpoints.
+
+   The host controls synchronization using the SYNCHRONIZE command
+   over the control channel and synchronization messages over data channels.
+   The device stops each data channel upon receiving a synchronization message
+   on that channel, processing all data packets received prior to that message.
+   After the device receives synchronization messages for each data endpoint
+   and the SYNCHRONIZE command, it resumes all channels.
+
+   When the host must guarantee a command executes before processing new
+   data packets, it first issues the command, then issues the SYNCHRONIZE
+   command and sends synchronization messages on data channels. When the
+   host must guarantee the device has processed all old data packets before a
+   processing a new command, it issues a SYNCHRONIZE command and
+   synchronization messages on all data channels, then issues the desired
+   command.
+
+
+
+WMI Commands
+
+   ADD_BAD_AP
+    Cause the AR6000 device to avoid a particular AP
+   ADD_CIPHER_KEY
+    Add or replace any of the four AR6000 encryption keys
+   ADD_WOW_PATTERN
+    Used to add a pattern to the WoW pattern list
+   CLR_RSSI_SNR
+    Clear the current calculated RSSI and SNR value
+   CONNECT_CMD
+    Request that the AR6000 device establish a wireless connection
+        with the specified SSID
+   CREATE_PSTREAM
+    Create prioritized data endpoint between the host and device
+   DELETE_BAD_AP
+    Clear an entry in the bad AP table
+   DELETE_CIPHER_KEY
+    Delete a previously added cipher key
+   DELETE_PSTREAM
+    Delete a prioritized data endpoint
+   DELETE_WOW_PATTERN
+    Remove a pre-specified pattern from the WoW pattern list
+   EXTENSION
+    WMI message interface command
+   GET_BIT_RATE
+    Retrieve rate most recently used by the AR6000
+   GET_CHANNEL_LIST
+    Retrieve list of channels used by the AR6000
+   GET_FIXRATES
+    Retrieves the rate-mask set via the SET_FIXRATES command.
+   GET_PMKID_LIST_CMD
+    Retrieve the firmware list of PMKIDs
+   GET_ROAM_DATA
+    Internal use for data collection; available in special build only
+   GET_ROAM_TBL
+    Retrieve the roaming table maintained on the target
+   GET_TARGET_STATS
+    Request that the target send the statistics it maintains
+   GET_TX_PWR
+    Retrieve the current AR6000 device Tx power levels
+   GET_WOW_LIST
+    Retrieve the current list of WoW patterns
+   LQ_THRESHOLD_PARAMS
+    Set the link quality thresholds
+   OPT_TX_FRAME
+    Send a special frame (special feature)
+   RECONNECT
+    Request a reconnection to a BSS
+   RSSI_THRESHOLD_PARAMS
+    Configure how the AR6000 device monitors and reports signal
+       strength (RSSI) of the connected BSS
+   SCAN_PARAMS
+    Determine dwell time and changes scanned channels
+   SET_ACCESS_PARAMS
+    Set access parameters for the wireless network
+   SET_ADHOC_BSSID
+    Set the BSSID for an ad hoc network
+   SET_AKMP_PARAMS
+    Set multiPMKID mode
+   SET_APPIE
+    Add application-specified IE to a management frame
+   SET_ASSOC_INFO
+    Specify the IEs the device should add to association or
+        reassociation requests
+   SET_AUTH_MODE
+    Set 802.11 authentication mode of reconnection
+   SET_BEACON_INT
+    Set the beacon interval for an ad hoc network
+   SET_BIT_RATE
+    Set the AR6000 to a specific fixed bit rate
+   SET_BMISS_TIME
+    Set the beacon miss time
+   SET_BSS_FILTER
+    Inform the AR6000 of network types about which it wants to
+        receive information using a BSSINFO event
+   SET_BT_PARAMS
+    Set the status of a Bluetooth stream (SCO or A2DP) or set
+        Bluetooth coexistence register parameters
+   SET_BT_STATUS
+    Set the status of a Bluetooth stream (SCO or A2DP)
+   SET_CHANNEL_PARAMETERS
+    Configure WLAN channel parameters
+   SET_DISC_TIMEOUT
+    Set the amount of time the AR6000 spends attempting to
+        reestablish a connection
+   SET_FIXRATES
+    Set the device to a specific fixed PHY rate (supported subset)
+   SET_HALPARAM
+    Internal AR6000 command to set certain hardware parameters
+   SET_HOST_SLEEP_MODE
+    Set the host mode to asleep or awake
+   SET_IBSS_PM_CAPS
+    Support a non-standard power management scheme for an
+        ad hoc network
+   SET_LISTEN_INT
+    Request a listen interval
+   SET_LPREAMBLE
+    Override the short preamble capability of the AR6000 device
+   SET_MAX_SP_LEN
+    Set the maximum service period
+   SET_OPT_MODE
+    Set the special mode on/off (special feature)
+   SET_PMKID
+    Set the pairwise master key ID (PMKID)
+   SET_PMKID_LIST_CMD
+    Configure the firmware list of PMKIDs
+   SET_POWER_MODE
+    Set guidelines on trade-off between power utilization
+   SET_POWER_PARAMS
+    Configure power parameters
+   SET_POWERSAVE_PARAMS
+    Set the two AR6000 power save timers
+   SET_PROBED_SSID
+    Provide list of SSIDs the device should seek
+   SET_REASSOC_MODE
+    Specify whether the disassociated frame should be sent upon
+        reassociation
+   SET_RETRY_LIMITS
+    Limit how many times the device tries to send a frame
+   SET_ROAM_CTRL
+    Control roaming behavior
+   SET_RTS
+    Determine when RTS should be sent
+   SET_SCAN_PARAMS
+    Set the AR6000 scan parameters
+   SET_TKIP_COUNTERMEASURES
+    Enable/disable reports of TKIP MIC errors
+   SET_TX_PWR
+    Specify the AR6000 device Tx power levels
+   SET_VOICE_PKT_SIZE
+    Set voice packet size
+   SET_WMM
+    Override the AR6000 WMM capability
+   SET_WMM_TXOP
+    Configure TxOP bursting when sending traffic to a WMM-
+    capable AP
+   SET_WOW_MODE
+    Enable/disable WoW mode
+   SET_WSC_STATUS
+    Enable/disable profile check in cserv when the WPS protocol
+    is in progress
+   SNR_THRESHOLD_PARAMS
+    Configure how the device monitors and reports SNR of BSS
+   START_SCAN
+    Start a long or short channel scan
+   SYNCHRONIZE
+    Force a synchronization point between command and data
+    paths
+   TARGET_REPORT_ERROR_BITMASK
+    Control ERROR_REPORT events from the AR6000
+
+
+
+
+Name
+    ADD_BAD_AP
+
+Synopsis
+    The host uses this command to cause the AR6000 to avoid a particular AP. The
+    AR6000 maintain a table with up to two APs to avoid. An ADD_BAD_AP command
+    adds or replaces the specified entry in this bad AP table.
+
+    If the AR6000 are currently connected to the AP specified in this command, they
+    disassociate.
+
+Command
+    wmiconfig eth1 --badap <bssid> <badApIndex>
+
+Command Parameters
+    UINT8 badApIndex    Index [0...1] that identifies which entry in the
+                        bad AP table to use
+
+
+    UINT8 bssid[6]  MAC address of the AP to avoid
+
+Command Values
+    badApIndex = 0, 1    Entry in the bad AP table to use
+
+Reset Value
+    The bad AP table is cleared
+
+Restrictions
+    None
+
+See Also
+    DELETE_BAD_AP on page B-13
+
+=====================================================================
+Name
+    ADD_CIPHER_KEY
+
+Synopsis
+    The host uses this command to add/replace any of four encryption keys on the
+    AR6000. The ADD_CIPHER_KEY command is issued after the CONNECT event
+    has been received by the host for all dot11Auth modes except for SHARED_AUTH.
+    When the dot11AuthMode is SHARED_AUTH, then the ADD_CIPHER_KEY
+    command should be issued before the CONNECT command.
+
+Command
+    wmiconfig eth1 --cipherkey <keyIndex> <keyType> <keyUsage>
+                            <keyLength> <keyopctrl> <keyRSC> <key>
+
+Command Parameters
+    UINT8 keyIndex      Index (0...3) of the key to add/replace;
+                        uniquely identifies the key
+    UINT8 keyType    CRYPTO_TYPE
+    UINT8 keyUsage   Specifies usage parameters of the key when
+                     keyType = WEP_CRYPT
+    UINT8 keyLength  Length of the key in bytes
+    UINT8 keyOpCtrl  bit[0] = Initialize TSC (default),
+                     bit[1] = Initialize RSC
+    UINT8 keyRSC[8]  Key replay sequence counter (RSC) initial
+                     value the device should use
+    UINT8 key[32]    Key material used for this connection
+    Command Values
+    {
+        NONE_CRYPT = 1
+        WEP_CRYPT  = 2
+        TKIP_CRYPT = 3
+        AES_CRYPT  = 4
+        KEY_OP_INIT_TSC   0x01
+        KEY_OP_INIT_RSC   0x02
+        KEY_OP_INIT_VAL   0x03
+                Default is to Initialize the TSC
+        KEY_OP_VALID_MASK 0x04
+                Two operations defined
+    } CRYPTO_TYPE
+
+    {
+        PAIRWISE_USAGE  = 0  Set if the key is used for unicast traffic only
+        GROUP_USAGE     = 1  Set if the key is used to receive multicast
+                              traffic (also set for static WEP keys)
+        TX_USAGE        = 2  Set for the GROUP key used to transmit frames
+                All others are reserved
+    } KEY_USAGE
+
+Reset Value
+    The four available keys are disabled.
+
+Restrictions
+    The cipher should correspond to the encryption mode specified in the CONNECT
+    command.
+
+See Also
+    DELETE_CIPHER_KEY
+
+=====================================================================
+
+
+Name
+    ADD_WOW_PATTERN
+
+Synopsis
+    The host uses this command to add a pattern to the WoW pattern list; used for
+    pattern-matching for host wakeups by the WoW module. If the host mode is asleep
+    and WoW is enabled, all packets are matched against the existing WoW patterns. If a
+    packet matches any of the patterns specified, the target will wake up the host. All
+    non-matching packets are discarded by the target without being sent up to the host.
+
+Command
+    wmiconfig addwowpattern <list-id> <filter-size> <filter-offset>
+    <pattern> <mask>
+
+Command Parameters
+    A_UINT8  filter_list_id    ID of the list that is to include the new pattern
+    A_UINT8  filter_size       Size of the new pattern
+    A_UINT8  filter_offset     Offset at which the pattern matching for this
+                                new pattern should begin at
+    A_UINT8  filter[1]         Byte stream that contains both the pattern and
+                                the mask of the new WoW wake-up pattern
+
+Reply Parameters
+    None
+
+Reset Value
+    None defined (default host mode is awake)
+
+Restrictions
+    None
+
+See Also
+    DELETE_WOW_PATTERN
+
+=====================================================================
+
+
+Name
+    CLR_RSSI_SNR
+
+Synopsis
+    Clears the current calculated RSSI and SNR value. RSSI and SNR are reported by
+    running-average value. This command will clear the history and have a fresh start
+    for the running-average mechanism.
+
+Command
+    wmiconfig eth1 --cleanRssiSnr
+
+Command Parameters
+    None
+
+Reply Parameters
+    None
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+=====================================================================
+
+Name
+    CONNECT_CMD
+
+Synopsis
+    New connect control information (connectCtrl) is added, with 32 possible modifiers.
+
+    CONNECT_SEND_REASSOC
+        Valid only for a host-controlled connection to a
+        particular AP. If this bit is set, a reassociation frame is
+        sent. If this bit is clear, an association request frame is
+        sent to the AP.
+
+    CONNECT_IGNORE_WPAx_GROUP_CIPHER
+        No group key is issued in the CONNECT command,
+        so use the group key advertised by the AP. In a target-
+        initiated roaming situation this allows a STA to roam
+        between APs that support different multicast ciphers.
+
+    CONNECT_PROFILE_MATCH_DONE
+        In a host-controlled connection case, it is possible that
+        during connect, firmware may not have the
+        information for a profile match (e.g, when the AP
+        supports hidden SSIDs and the device may not
+        transmit probe requests during connect). By setting
+        this bit in the connection control information, the
+        firmware waits for a beacon from the AP with the
+        BSSID supplied in the CONNECT command. No
+        additional profile checks are done.
+
+    CONNECT_IGNORE_AAC_BEACON
+        Ignore the Admission Capacity information in the
+        beacon of the AP
+
+    CONNECT_ASSOC_POLICY_USER
+        When set, the CONNECT_SEND_REASSOC setting
+        determines if an Assoc or Reassoc is sent to an AP
+
+Command
+    wmiconfig --setconnectctrl <ctrl flags bitmask>
+
+Command Parameters
+    typedef struct{
+    A_UINT8 networktype;
+    A_UINT8 dot11authmode;
+    A_UINT8 authmode;
+    A_UINT8 pairwiseCryptoType; /*CRYPTO_TYPE*/
+    A_UINT8 pairwiseCryptoLen;
+    A_UINT8 groupCryptoType; /*CRYPTO_TYPE*/
+    A_UINT8 groupCryptoLen;
+    A_UINT8 ssidLength;
+    A_UCHAR ssid[WMI_MAX_SSID_LEN];
+    A_UINT16 channel;
+    A_UINT8 bssid[AUTH_MAC_LEN];
+    A_UINT8 ctrl_flags; /*WMI_CONNECT_CTRL_FLAGS_BITS*/
+    } WMI_CONNECT_CMD;
+
+    ctrl flags bitmask
+        = 0x0001 CONNECT_ASSOC_POLICY_USER
+            Assoc frames are sent using the policy specified by
+            the flag
+        = 0x0002 CONNECT_SEND_REASSOC
+            Send Reassoc frame while connecting, otherwise send
+            assoc frames
+        = 0x0004 CONNECT_IGNORE_WPAx_GROUP_CIPHER
+            Ignore WPAx group cipher for WPA/WPA2
+        = 0x0008 CONNECT_PROFILE_MATCH_DONE
+            Ignore any profile check
+        = 0x0010 CONNECT_IGNORE_AAC_BEACON
+            Ignore the admission control information in the
+            beacon
+        ... CONNECT_CMD, continued
+        Command Values
+        typedef enum {
+            INFRA_NETWORK       = 0x01,
+            ADHOC_NETWORK       = 0x02,
+            ADHOC_CREATOR       = 0x04,
+        } NETWORK_TYPE;
+
+        typedef enum {
+            OPEN_AUTH           = 0x01,
+            SHARED_AUTH         = 0x02,
+            LEAP_AUTH           = 0x04,
+        } DOT11_AUTH_MODE;
+        typedef enum {
+            NONE_AUTH           = 0x01,
+            WPA_AUTH            = 0x02,
+            WPA_PSK_AUTH        = 0x03,
+            WPA2_AUTH           = 0x04,
+            WPA2_PSK_AUTH       = 0x05,
+            WPA_AUTH_CCKM       = 0x06,
+            WPA2_AUTH_CCKM      = 0x07,
+        } AUTH_MODE;
+        typedef enum {
+            NONE_CRYPT          = 0x01,
+            WEP_CRYPT           = 0x02,
+            TKIP_CRYPT          = 0x03,
+            AES_CRYPT           = 0x04,
+        } CRYPTO_TYPE;
+        typedef enum {
+            CONNECT_ASSOC_POLICY_USER = 0x0001,
+            CONNECT_SEND_REASSOC = 0x0002,
+            CONNECT_IGNORE_WPAx_GROUP_CIPHER = 0x0004,
+            CONNECT_PROFILE_MATCH_DONE = 0x0008,
+            CONNECT_IGNORE_AAC_BEACON = 0x0010,
+        } WMI_CONNECT_CTRL_FLAGS_BITS;
+
+    pairwiseCryptoLen and groupCryptoLen are valid when the respective
+    CryptoTypesis WEP_CRYPT, otherwise this value should be 0. This is the length in
+    bytes.
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    CREATE_PSTREAM
+
+Synopsis
+    The host uses this command to create a new prioritized data endpoint between the
+    host and the AR6000 device that carries a prioritized stream of data. If the AP that the
+    device connects to requires TSPEC stream establishment, the device requests the
+    corresponding TSPEC with the AP. The maximum and minimum service interval
+    ranges from 0  0x7FFFFFFF (ms), where 0 = disabled. The device does not send a
+    reply event for this command, as it is always assumed the command has succeeded.
+    An AP admission control response comes to the host via a WMI_CAC_INDICATION
+    event, once the response for the ADDTS frame comes.
+
+    Examples of cases where reassociation is generated (when WMM) and cases where
+    ADDTS is generated (when WMM and enabling ACM) are when:
+        Changing UAPSD flags in WMM mode, reassociation is generated
+        Changing the interval of sending auto QoS Null frame in WMM mode;
+            reassociation is not generated
+        Issuing a command with same previous parameters in WMM mode and enabling
+            ACM, an ADDTS request is generated
+        Changing the interval of a QoS null frame sending in WMM mode and enabling
+            ACM, an ADDTS request is generated
+        Issuing the command in disconnected state, reassociation or ADDTS is not
+            generated but the parameters are available after (re)association
+
+Command
+    --createqos <user priority> <direction> <traffic class>
+<trafficType> <voice PS capability> <min service interval> <max
+service interval> <inactivity interval> <suspension interval>
+<service start time> <tsid> <nominal MSDU> <max MSDU> <min data
+rate> <mean data rate> <peak data rate> <max burst size> <delay
+bound> <min phy rate> <sba> <medium time> where:
+
+    <user priority>
+    802.1D user priority range (07)
+    <direction>
+        = 0    Tx (uplink) traffic
+        = 1    Rx (downlink) traffic
+        = 2    Bi-directional traffic
+    <traffic class>
+        = 1    BK
+        = 2    VI
+        = 3    VO
+    <trafficType>
+        = 0    Aperiodic
+        = 1    Periodic
+    <voice PS capability>
+        Specifies whether the voice power save mechanism
+    (APSD if AP supports it or legacy/simulated APSD
+    [using PS-Poll]) should be used
+        = 0    Disable voice power save for traffic class
+        = 1    Enable APSD voice power save for traffic class
+        = 2    Enable voice power save for all traffic classes
+    <min service interval>
+        (In ms)
+    <max service interval>
+        Inactivity interval (in ms) (0 = Infinite)
+    <suspension interval>
+        (In ms)
+    <service start time>
+        Service start time
+    <tsid>
+        TSID range (015)
+    <nominal MSDU>
+        Nominal MAC SDU size
+    <max MSDU>
+        Maximum MAC SDU size
+    <min data rate>
+        Minimum data rate (in bps)
+    <mean data rate>
+        Mean data rate (in bps)
+    <peak data rate>
+        Peak data rate (in bps)
+    <max burst size>
+        Maximum burst size (in bps)
+    <delay bound>
+        Delay bound
+    <min phy rate>
+        Minimum PHY rate (in bps)
+    <sba>
+        Surplus bandwidth allowance
+    <medium time>
+        Medium time in TU of 32-ms periods per sec
+    ... CREATE_PSTREAM (continued)
+
+Command Parameters
+    UINT8 trafficClass    TRAFFIC_CLASS value
+    UINT8 traffic
+    Direction
+    DIR_TYPE value
+    UINT8    rxQueueNum
+        AR6000 device mailbox index (2 or 3)
+        corresponding to the endpoint the host
+        wishes to use to receive packets for the
+        prioritized stream
+    UINT8 trafficType  TRAFFIC_TYPE value
+    UINT8 voicePS
+Capability
+    VOICEPS_CAP_TYPE value
+    UINT8 tsid          Traffic stream ID
+    UINT8 userPriority  802.1D user priority
+    UINT16 nominalMSDU  Nominal MSDU in octets
+    UINT16 maxMSDU      Maximum MSDU in octets
+    UINT32 minServiceInt Minimum service interval: the min.
+                            period of traffic specified (in ms)
+    UINT32 maxServiceInt  Maximum service interval: the max.
+                        period of traffic specified (in ms)
+    UINT32 inactivityInt Indicates how many ms an established
+                        stream is inactive before the prioritized
+                        data endpoint is taken down and the
+                        corresponding T-SPEC deleted
+    UINT32 suspensionInt  Suspension interval (in ms)
+    UINT32 service       StartTime Service start time
+    UINT32 minDataRate  Minimum data rate (in bps)
+    UINT32 meanDataRate Mean data rate (in bps)
+    UINT32 peakDataRate Peak data rate (in bps)
+    UINT32 maxBurstSize
+    UINT32 delayBound
+    UINT32 minPhyRate   Minimum PHY rate for TSPEC (in bps)
+    UINT32 sba          Surplus bandwidth allowance
+    UINT32 mediumTime   Medium TSPEC time (in units of 32 ms)
+Command Values
+    {
+        WMM_AC_BE = 0   Best Effort
+        WMM_AC_BK = 1   Background
+        WMM_AC_VI = 2   Video
+        WMM_AC_VO = 3   Voice
+        All other values reserved
+    } TRAFFIC_CLASS
+    {
+        UPLINK_TRAFFIC   = 0  From the AR6000 device to the AP
+        DOWNLINK_TRAFFIC = 1  From the AP to the AR6000 device
+        BIDIR_TRAFFIC    = 2  Bi-directional traffic
+        All other values reserved
+    } DIR_TYPE
+    {
+        DISABLE_FOR_THIS_AC = 0
+        ENABLE_FOR_THIS_AC  = 1
+        ENABLE_FOR_ALL_AC   = 2
+        All other values reserved
+    } VOICEPS_CAP_TYPE
+
+    ... CREATE_PSTREAM (continued)
+
+
+        VI  BE   BK    Supported, Y/N?
+   0    0    0    0    Y
+   0    0    0    1    Y
+   0    0    1    0    N
+   0    0    1    1    N
+   0    1    0    0    Y
+   0    1    0    1    Y
+   0    1    1    0    N
+   0    1    1    1    N
+   1    0    0    0    Y
+   1    0    0    1    Y
+   1    0    1    0    N
+   1    1    0    0    N
+   1    1    0    1    Y
+   1    1    0    0    N
+   1    1    1    0    N
+   1    1    1    1    Y
+
+Reset Value
+    No pstream is present after reset; each of the BE, BK, VI,VO pstreams must be created
+    (either implicitly by data flow or explicitly by user)
+
+Restrictions
+    This command can only be issued when the device is in the CONNECTED state. If
+    the device receives the command while in DISCONNECTED state, it replies with a
+    failure indication. At most four prioritized data endpoints can be created, one for
+    each AC.
+
+See Also
+    DELETE_PSTREAM
+=====================================================================
+
+Name
+    DELETE_BAD_AP
+
+Synopsis
+    The host uses this command to clear a particular entry in the bad AP table
+
+Command
+    wmiconfig eth1 --rmAP [--num=<index>] // used to clear a badAP
+    entry. num is index from 0-3
+
+Command Parameters
+    UINT8  badApIndex   Index [0...n] that identifies the entry in the bad
+                        AP table to delete
+
+Command Values
+    badApIndex   = 0, 1, 2, 3
+            Entry in the bad AP table
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+See Also
+    ADD_BAD_AP
+
+=====================================================================
+
+
+Name
+    DELETE_CIPHER_KEY
+
+Synopsis
+    The host uses this command to delete a key that was previously added with the
+    ADD_CIPHER_KEY command.
+
+Command
+    TBD
+
+Command Parameters
+    UINT8   keyIndex    Index (0...3) of the key to be deleted
+
+Command Values
+    keyIndex    = 0, 1,2, 3    Key to delete
+
+Reset Value
+    None
+
+Restrictions
+    The host should not delete a key that is currently in use by the AR6000.
+
+See Also
+    ADD_CIPHER_KEY
+
+=====================================================================
+
+Name
+    DELETE_PSTREAM
+
+Synopsis
+    The host uses this command to delete a prioritized data endpoint created by a
+    previous CREATE_PSTREAM command
+
+Command
+    --deleteqos <trafficClass> <tsid>, where:
+
+    <traffic class>
+        = 0    BE
+        = 1    BK
+        = 2    VI
+        = 3    VO
+    <tsid>
+        The TSpec ID; use the -qosqueue option
+        to get the active TSpec IDs for each traffic class
+
+Command Parameters
+    A_UINT8    trafficClass    Indicate the traffic class of the stream
+                            being deleted
+
+Command Values
+    {
+        WMM_AC_BE = 0    Best effort
+        WMM_AC_BK = 1    Background
+        WMM_AC_VI = 2    Video
+        WMM_AC_VO = 3    Voice
+    } TRAFFIC CLASS
+
+    0-15 for TSID
+
+Reply Values
+    N/A
+
+Restrictions
+    This command should only be issued after a CREATE_PSTREAM command has
+    successfully created a prioritized stream
+
+See Also
+    CREATE_PSTREAM
+
+=====================================================================
+
+
+Name
+    DELETE_WOW_PATTERN
+
+Synopsis
+    The host uses this command to remove a pre-specified pattern from the
+    WoW pattern list.
+
+Command
+    wmiconfig delwowpattern <list-id> <pattern-id>
+
+Command Parameters
+    A_UINT8    filter_list_id    ID of the list that contains the WoW filter
+                                 pattern to delete
+    A_UINT8    filter_id    ID of the WoW filter pattern to delete
+
+Reply Parameters
+    None
+
+
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+See Also
+    ADD_WOW_PATTERN
+
+=====================================================================
+
+
+Name
+    EXTENSION
+
+Synopsis
+    The WMI message interface is used mostly for wireless control messages to a wireless
+    module applicable to wireless module management regardless of the target platform
+    implementation. However, some commands only peripherally related to wireless
+    management are desired during operation. These wireless extension commands may
+    be platform-specific or implementation-dependent.
+
+Command
+    N/A
+
+Command Parameters
+    Command-specific
+
+Command Values
+    Command-specific
+
+Reply Parameters
+    Command-specific
+
+Reset Values
+    None defined
+
+Restrictions
+    None defined
+
+=====================================================================
+
+
+Name
+    GET_BIT_RATE
+
+Synopsis
+    Used by the host to obtain the rate most recently used by the AR6000 device
+
+Command
+    wmiconfig eth1 --getfixrates
+
+Command Parameters
+    None
+
+
+
+Reply Parameters
+    INT8
+    rateIndex
+    See the SET_BIT_RATE command
+
+Reset Values
+    None
+
+Restrictions
+    This command should only be used during development/debug; it is not intended
+for use in production. It is only valid when the device is in the CONNECTED state
+
+See Also
+    SET_BIT_RATE
+
+=====================================================================
+
+
+Name
+    GET_CHANNEL_LIST
+
+Synopsis
+    Used by the host uses to retrieve the list of channels that can be used by the device
+    while in the current wireless mode and in the current regulatory domain.
+
+Command
+    TBD
+
+Command Parameters
+    None
+
+Reply Parameters
+    UINT8    reserved    Reserved
+    UINT8    numberOfChannels    Number of channels the reply contains
+    UINT16    channelList[numberOfChannels]  Array of channel frequencies (in MHz)
+
+Reset Values
+    None defined
+
+Restrictions
+    The maximum number of channels that can be reported are 32
+
+=====================================================================
+
+
+Name
+    GET_FIXRATES
+
+Synopsis
+    Clears the current calculated RSSI and SNR value. RSSI and SNR are reported by
+    running-average value. This command will clear the history and have a fresh start for
+    the running-average mechanism.
+
+Synopsis
+    This returns rate-mask set via WMI_SET_FIXRATES to retrieve the current fixed rate
+    that the AR6001 or AR6001 is using. See SET_FIXRATES.
+
+Command
+    wmiconfig eth1 --getfixrates
+
+Command Parameters
+    A_UINT16    fixRateMask;    Note: if this command is used prior to
+                using WMI_SET_FIXRATES, AR6000
+                returns 0xffff as fixRateMask, indicating
+                all the rates are enabled
+
+Reply Parameters
+    None
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+See Also
+    SET_FIXRATES
+
+=====================================================================
+
+
+
+Name
+    GET_PMKID_LIST_CMD
+
+Synopsis
+    Retrieves the list of PMKIDs on the firmware. The
+    WMI_GET_PMKID_LIST_EVENT is generated by the firmware.
+
+Command
+    TBD
+
+Command Parameters
+
+Reset Values
+    None
+
+Restrictions
+    None
+
+See Also
+    SET_PMKID_LIST_CMD GET_PMKID_LIST_EVENT
+
+=====================================================================
+
+
+Name
+    GET_ROAM_TBL
+
+Synopsis
+    Retrieve the roaming table maintained on the target. The response is reported
+    asynchronously through the ROAM_TBL_EVENT.
+
+Command
+    wmiconfig --getroamtable <roamctrl> <info>
+
+Command Parameters
+    A_UINT8    roamCtrlType;
+    A_UINT16   roamMode
+    A_UINT16   numEntries
+    WMI_BSS_ROAM_INFO bssRoamInfo[1]
+
+Reply Value
+    Reported asynchronously through the ROAM_TBL_EVENT
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+See Also
+    SET_KEEPALIVE
+
+=====================================================================
+
+
+Name
+    GET_TARGET_STATS
+
+Synopsis
+    The host uses this command to request that the target send the statistics that it
+    maintains. The statistics obtained from the target are accrued in the host every time
+    the GET_TARGET_STATS command is issued. The --clearStats option is added to
+    clear the target statistics maintained in the host.
+
+Command
+    wmiconfig --getTargetStats --clearStats
+
+Command Parameters
+    TARGET_STATS    targetStats
+    WMI_TARGET_STATS
+    UINT8   clearStats
+
+
+Reply Value
+    RSSI return value (0100)
+
+Reset Values
+    All statistics are cleared (zeroed)
+
+Restrictions
+    The --getTargetStats option must be used; the --clearStats option is also available also
+
+
+=====================================================================
+
+Name
+    GET_TX_PWR
+
+Synopsis
+    The host uses this command to retrieve the current Tx power level
+
+Command
+    wmiconfig -i eth1 --getpower
+
+Command Parameters
+    None
+
+Reply Parameters
+    UINT16 dbM    The current Tx power level specified in dbM
+
+Reset Values
+    The maximum permitted by the regulatory domain
+
+Restrictions
+    None
+
+See Also
+    SET_TX_PWR
+
+=====================================================================
+
+
+Name
+    GET_WOW_LIST
+
+Synopsis
+    The host uses this command to retrieve the current list of WoW patterns.
+
+Command
+    wmiconfig getwowlist <list-id>
+
+Command Parameters
+    A_UINT8 filter_list_id    ID of the list of WoW patterns to retrieve
+
+Reply Value(s)
+    A_UINT16  num_filters    Number of WoW patterns contained in the list
+    A_UINT8   wow_mode    Current mode of WoW (enabled or disabled)
+    A_UINT8    host_mode    Current host mode (asleep or awake)
+    WOW_FILTER    wow_filters[1]
+        Contents of the WoW filter pattern list
+        (contains mask, pattern, offset and size
+    information for each of the patterns)
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+See Also
+    SET_WSC_STATUS
+
+=====================================================================
+
+
+Name
+    LQ_THRESHOLD_PARAMS
+
+Synopsis
+    Sets Link Quality thresholds, the sampling will happen at every unicast data frame
+    Tx if a certain threshold is met, and the corresponding event will be sent to the host.
+
+Command
+    --lqThreshold <enable> <upper_threshold_1> ...
+    <upper_threshold_4> <lower_threshold_1> ... <lower_threshold_4>
+
+Command Parameters
+    <enable>    = 0    Disable link quality sampling
+                = 1    Enable link quality sampling
+    <upper_threshold_x>  Above thresholds (value in [0,100]), in
+                    ascending order
+    <lower_threshold_x> Below thresholds (value in [0,100]), in
+                    ascending order
+
+Command Values
+    See command parameters
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    OPT_TX_FRAME
+
+Synopsis
+    Special feature, sends a special frame.
+
+Command
+    wmiconfig --sendframe <frmType> <dstaddr> <bssid> <optIEDatalen>
+    <optIEData>
+
+Command Parameters
+    {
+        A_UINT16    optIEDataLen;
+        A_UINT8    frmType;
+        A_UINT8    dstAddr[ATH_MAC_LEN];
+        A_UINT8    bssid[ATH_MAC_LEN];
+        A_UINT8    optIEData[1];
+    } WMI_OPT_TX_FRAME_CMD;
+
+Command Values
+    <frmtype>   = 1    Probe request frame
+                = 2    Probe response frame
+                = 3    CPPP start
+                = 4    CPPP stop
+
+Reset Value
+    None defined
+
+Restrictions
+    Send a special frame only when special mode is on.
+
+=====================================================================
+
+
+Name
+    RECONNECT
+
+Synopsis
+    This command requests a reconnection to a BSS to which the AR6000 device was
+    formerly connected
+
+Command
+    TBD
+
+Command Parameters
+    UINT16    channel    Provides a hint as to which channel was
+                        used for a previous connection
+    UINT8    bssid[6]    If set, indicates which BSSID to connect to
+
+Command Values
+    None
+
+Reset Values
+    None
+
+Restrictions
+    None
+
+See Also
+    CONNECT_CMD
+
+=====================================================================
+
+
+Name
+    RSSI_THRESHOLD_PARAMS
+
+Synopsis
+    Configures how the AR6000 device monitors and reports signal strength (RSSI) of the
+    connected BSS, which is used as a link quality metric. The four RSSI threshold sets (in
+    dbM) of the host specification divide the signal strength range into six segments.
+    When signal strength increases or decreases across one of the boundaries, an
+    RSSI_THRESHOLD event is signaled to the host. The host may then choose to take
+    action (such as influencing roaming).
+
+Command
+    wmiconfig eth1 --rssiThreshold <weight> <pollTime>
+        <above_threshold_val_1> ... <above_threshold_tag_6>
+        <above_threshold_val_6>
+        <below_threshold_tag_1> <below_threshold_val_1> ...
+        <below_threshold_tag_6> <below_threshold_val_6>
+
+Command Parameters
+    UINT8    weight    Range in [1, 16] used to calculate average RSSI
+    UINT32   pollTime   RSSI (signal strength) sampling frequency in
+                seconds (if pollTime = 0, single strength
+        sampling is disabled)
+    USER_RSS__THOLD tholds[12]  Thresholds (6 x 2)
+
+Command Values
+    None defined
+
+Reset Values
+    pollTime is 0, and sampling is disabled
+
+Restrictions
+    Can only be issued if the AR6000 device is connected
+
+
+=====================================================================
+
+Name
+    SCAN_PARAMS
+
+Synopsis
+    The minact parameter determines the minimum active channel dwell time, within
+    which if the STA receives any beacon, it remains on that channel until the maxact
+    channel dwell time. If the STA does not receive a beacon within the minact dwell
+    time, it switches to scan the next channel.
+
+Command
+    wmiconfig -scan -minact=<ms> --maxact=<ms>
+
+Command Parameters
+    UINT16    maxact    Channel dwell time (in ms), default = 0
+    UINT16    minact    Channel dwell time (in ms), default = 105
+
+Command Values
+    See channel parameters
+
+Reset Values
+    None defined
+
+Restrictions
+    The minact value should be greater than 0; maxact should be between 565535 ms
+    and greater than minact
+
+=====================================================================
+
+
+Name
+    SET_ACCESS_PARAMS
+
+Synopsis
+    Allows the host to set access parameters for the wireless network. A thorough
+    understanding of IEEE 802.11 is required to properly manipulate these parameters.
+
+Command
+    wmiconfig eth1 --acparams --txop <limit> --cwmin <0-15>
+    --cwmax <0-15> --aifsn<0-15>
+
+Command Parameters
+    UINT16    txop    The maximum time (expressed in units of
+                        32 ms) the device can spend transmitting
+                        after acquiring the right to transmit
+    UINT8    eCWmin    Minimum contention window
+    UINT8    eCWmax    Maximum contention window
+    UINT8    aifsn    The arbitration inter-frame space number
+
+Command Values
+    None
+
+Reset Values
+    Reasonable defaults that vary, between endpoints (prioritized streams)
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_ADHOC_BSSID
+
+Synopsis
+    Allows the host to set the BSSID for an ad hoc network. If a network with this BSSID
+    is not found, the target creates an ad hoc network with this BSSID after the connect
+    WMI command is triggered (e.g., by the SIOCSIWESSID IOCTL).
+
+Command
+    wmiconfig eth1 --adhocbssid <bssid>
+
+Command Parameters
+    A_UINT8     bssid[ATH_MAC_LEN]    BSSID is specified in xx:xx:xx:xx:xx:xx format
+
+Command Values
+    None
+
+Reset Values
+    None
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_AKMP_PARAMS
+
+Synopsis
+    Enables or disables multi PMKID mode.
+
+Command
+    wmiconfig eth1 --setakmp --multipmkid=<on/off>
+
+Command Parameters
+    typedef struct {
+      A_UINT32    akmpInfo;
+    } WMI_SET_AKMP_PARAMS_CMD;
+
+Command Values
+    akmpInfo;
+    bit[0] = 0
+        MultiPMKID mode is disabled and PMKIDs that
+        were set using the WMI_SET_PMKID_CMD are
+        used in the [Re]AssocRequest frame.
+     bit[0] = 1
+        MultiPMKID mode is enabled and PMKIDs issued
+        by the WMI_SET_PMKID_LIST_CMD are used in
+        the next [Re]AssocRequest sent to the AP.
+
+Reset Values
+    MultiPMKID mode is disabled
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_APPIE
+
+Synopsis
+    Add an application-specified IE to a management frame. The maximum length is
+    76 bytes. Including the length and the element ID, this translates to 78 bytes.
+
+Command
+    wmiconfig --setappie <frame> <IE>, where:
+
+    frame
+        One of beacon, probe, respon, assoc
+
+    IE
+        A hex string beginning with DD (if = 0, no
+        IE is sent in the management frame)
+
+Command Parameters
+    mgmtFrmType;
+        A WMI_MGMT_FRAME_TYPE
+
+    ieLen;
+        Length of the IE to add to the GMT frame
+
+Command Values
+    None
+
+Reset Value
+    None defined
+
+Restrictions
+    Supported only for the probe request and association request management frame
+types. Also, only one IE can be added per management frame type.
+
+=====================================================================
+
+
+Name
+    SET_ASSOC_INFO
+
+Synopsis
+    The host uses this command to specify any information elements (IEs) it wishes the
+    AR6000 device to add to all future association and reassociation requests. IEs must be
+    correct and are used as is by the device. IEs specified through this command are
+    cleared with a DISCONNECT.
+
+Command
+    wmiconfig eth1 --setAssocIe <IE>
+
+Command Parameters
+    UINT8    ieType    Used directly in 802.11 frames
+    UINT8    bufferSize    Size of assocInfo (in bytes) ranging from
+                        0240. If = 0, previously set IEs are cleared.
+    UINT8    assocInfo[bufferSize]    Used directly in 802.11 frames
+
+Command Values
+    None
+
+Reset Values
+    IEs are cleared
+
+Restrictions
+    This command can only be issued in the DISCONNECTED state
+
+=====================================================================
+
+
+Name
+    SET_AUTHMODE
+
+Synopsis
+    Sets the 802.11 authentication mode of reconnection
+
+Command
+    wmiconfig eth1 --setauthmode <mode>
+
+Command Parameters
+    UINT8    mode
+
+Command Values
+    mode    = 0x00    Proceed with authentication during reconnect
+            = 0x01    Do not proceed with authentication during reconnect
+
+Reset Values
+    Authentication
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_BEACON_INT
+
+Synopsis
+    Sets the beacon interval for an ad hoc network. Beacon interval selection may have an
+    impact on power savings. To some degree, a longer interval reduces power
+    consumption but also decreases throughput. A thorough understanding of IEEE
+    802.11 ad hoc networks is required to use this command effectively.
+
+Command
+    wmiconfig eth1 --ibssconintv
+
+Command Parameters
+    UINT16    beaconInterval    Specifies the beacon interval in TU units (1024 ms)
+
+Command Values
+    None
+
+Reset Values
+    The default beacon interval is 100 TUs (102.4 ms)
+
+Restrictions
+    This command can only be issued before the AR6000 device starts an ad hoc network
+
+See Also
+    SET_IBSS_PM_CAPS
+
+=====================================================================
+
+
+Name
+    SET_BIT_RATE
+
+Synopsis
+    The host uses this command to set the AR6000 device to a specific fixed rate.
+
+Command
+    wmiconfig eth1 --setfixrates <rate_0> ... <rate_n>
+
+Command Parameters
+    INT8    rateIndex
+    A WMI_BIT_RATE value
+    {
+        RATE_AUTO    = -1
+        RATE_1Mb     = 0
+        RATE_2Mb     = 1
+        RATE_5_5M    = 2
+        RATE_11Mb    = 3
+        RATE_6Mb     = 4
+        RATE_9Mb     = 5
+        RATE_12Mb    = 6
+        RATE_18Mb    = 7
+        RATE_24Mb    = 8
+        RATE_36Mb    = 9
+        RATE_48Mb    = 10
+        RATE_54Mb    = 11
+      } WMI_BIT_RATE
+
+
+Command Values
+    See command parameters
+
+Reset Values
+    The dynamic rate is determined by the AR6000 device
+
+Restrictions
+    This command is intended for use only during development/debug; it is not
+intended for use in production
+
+See Also
+    GET_BIT_RATE
+
+=====================================================================
+
+
+Name
+    SET_BMISS_TIME
+
+Synopsis
+    This command sets the beacon miss (BMISS) time, which the AR6000 hardware use
+    to recognize missed beacons. When an excessive number (15) of consecutive beacons
+    are missed, the AR6000 consider switching to a different BSS. The time can be
+    specified in number of beacons or in TUs.
+
+Command(s)
+    wmiconfig eth1 --setbmissbeacons=<val>
+    wmiconfig eth1 --setbmisstime=<val>
+
+Command Parameters
+    UINT16    bmissTime    Specifies the beacon miss time
+                            [1000...5000] in TUs (1024 ms)
+    UINT16    bmissbeacons  Specifies the number of beacons [5...50]
+
+Command Values
+    None
+
+Reset Values
+    bmissTime is 1500 TUs (1536 ms)
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_BSS_FILTER
+
+Synopsis
+    The host uses this to inform the AR6000 device of the types of networks about which
+    it wants to receive information from the BSSINFO event. As the device performs
+    either foreground or background scans, it applies the filter and sends BSSINFO
+    events only for the networks that pass the filter. If any of the  bssFilter or the ieMask
+    filter matches, a BSS Info is sent to the host. The ieMask currently is used as a match
+    for the IEs in the beacons, probe reponses and channel switch action management
+    frame. See also Scan and Roam on page C-1.
+
+    The BSS filter command has been enhanced to support IE based filtering. The IEs can
+    be specified as a bitmask through this command using this enum.
+
+Command
+    wmiconfig eth1 filter = <filter> --ieMask 0x<mask>
+
+Command Parameters
+    UINT8    BssFilter
+
+ Command Values
+    typedef struct {
+        A_UINT8    bssFilter;    See WMI_BSS_FILTER
+        A_UINT32    ieMask;
+    } __ATTRIB_PACK WMI_BSS_FILTER_CMD;
+
+    The ieMask can take this combination of values:
+
+    enum {
+        BSS_ELEMID_CHANSWITCH   = 0x01
+        BSS_ELEMID_ATHEROS      = 0x02,
+    }
+
+Reply Value
+    None
+
+Reset Value
+    BssFilter = NONE_BSS_FILTER (0)
+
+Restrictions
+    None
+
+See Also
+    CONNECT_CMD
+
+=====================================================================
+
+
+Name
+    SET_BT_PARAMS
+
+Synopsis
+    This command is used to set the status of a Bluetooth stream or set Bluetooth
+    coexistence register parameters. The stream may be an SCO or an A2DP stream and
+    its status can be started/stopped/suspended/resumed.
+
+Command
+    wmiconfig setBTparams <paramType> <params>
+
+Command Parameters
+    struct {
+       union {
+            BT_PARAMS_SCO    scoParams;
+            BT_PARAMS_A2DP   a2dpParams;
+            BT_PARAMS_MISC   miscParams;
+            BT_COEX_REGS     regs;
+        } info;
+         A_UINT8 paramType;
+        struct {
+            A_UINT8 noSCOPkts;    Number of SCO packets between consecutive PS-POLLs
+            A_UINT8 pspollTimeout;
+            A_UINT8 stompbt;
+        } BT_PARAMS_SCO;
+        struct {
+            A2DP BT stream parameters
+            A_UINT32   period;
+            A_UINT32   dutycycle;
+            A_UINT8    stompbt;
+        } BT_PARAMS_A2DP;
+        struct {
+            union {
+               WLAN_PROTECT_POLICY_TYPE   protectParams;
+               A_UINT16    wlanCtrlFlags;
+            }info;
+        A_UINT8 paramType;
+        } BT_PARAMS_MISC;
+        struct {
+            BT coexistence registers values
+            A_UINT32    mode;     Coexistence mode
+            A_UINT32    scoWghts; WLAN and BT weights
+            A_UINT32    a2dpWghts;
+            A_UINT32    genWghts;
+            A_UINT32    mode2;    Coexistence mode2
+            A_UINT8    setVal;
+        } BT_COEX_REGS;
+
+Command Values
+    None defined
+
+Reset Value
+    None
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_BT_STATUS
+
+Synopsis
+    Sets the status of a Bluetooth stream. The stream may be a SCO or an A2DP stream
+    and its status can be started/stopped/suspended/resumed.
+
+Command
+    wmiconfig setBTstatus <streamType> <status>
+
+Command Parameters
+    {
+        A_UINT8        streamType;    Stream type
+        A_UINT8        status;    Stream status
+    }WMI_SET_BT_STATUS_CMD;
+
+Command Values
+    {
+        BT_STREAM_UNDEF    = 0
+        BT_STREAM_SCO
+        SCO stream
+        BT_STREAM_A2DP
+        A2DP stream
+        BT_STREAM_MAX
+    } BT_STREAM_TYPE;
+
+    {
+        BT_STATUS_UNDEF    = 0
+        BT_STATUS_START
+        BT_STATUS_STOP
+        BT_STATUS_RESUME
+        BT_STATUS_SUSPEND
+        BT_STATUS_MAX
+    } BT_STREAM_STATUS;
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_CHANNEL_PARAMETERS
+
+Synopsis
+    Configures various WLAN parameters related to channels, sets the wireless mode,
+    and can restrict the AR6000 device to a subset of available channels. The list of
+    available channels varies depending on the wireless mode and the regulatory
+    domain. The device never operates on a channel outside of its regulatory domain. The
+    device starts to scan the list of channels right after this command.
+
+Command
+    wmiconfig eth1 --wmode <mode> <list>
+
+Command Parameters
+    UINT8    phyMode    See Values below.
+    UINT8    numberOfChannels
+        Number of channels in the channel array that
+        follows. If = 0, then the device uses all of the
+        channels permitted by the regulatory domain
+        and by the specified phyMode.
+    UINT16    channel[numberOfChannels]
+        Array listing the subset of channels (expressed
+        as frequencies in MHz) the host wants the
+        device to use. Any channel not permitted by
+        the specified phyMode or by the specified
+        regulatory domain is ignored by the device.
+
+Command Values
+    phyMode = {
+        Wireless mode
+        11a    = 0x01
+        11g    = 0x02
+        11ag   = 0x03
+        11b    = 0x04
+        11g only    = 0x05
+        }
+
+Reset Values
+    phyMode
+    11ag
+    802.11a/g modules
+        11g
+    802.11g module
+    channels
+        Defaults to all channels permitted by the
+        current regulatory domain.
+
+Restrictions
+    This command, if issued, should be issued soon after reset and prior to the first
+    connection. This command should only be issued in the DISCONNECTED state.
+
+=====================================================================
+
+
+Name
+    SET_DISC_TIMEOUT
+
+Synopsis
+    The host uses this command to configure the amount of time that the AR6000 should
+    spend when it attempts to reestablish a connection after losing link with its current
+    BSS. If this time limit is exceeded, the AR6000 send a DISCONNECT event. After
+    sending the DISCONNECT event the AR6000 continues to attempt to reestablish a
+    connection, but they do so at the interval corresponding to a foreground scan as
+    established by the SET_SCAN_PARAMS command.
+
+    A timeout value of 0 indicates that the AR6000 will disable all autonomous roaming,
+    so that the AR6000 will not perform any scans after sending a DISCONNECT
+    event to the host. The state is maintained until a shutdown or host sets different
+    timeout value from 0.
+
+Command
+    wmiconfig eth1 --disc=<timeout in seconds>
+
+Command Parameters
+    UINT8    disconnectTimeout
+        Specifies the time limit (in seconds) after
+        which a failure to reestablish a connection
+        results in a DISCONNECT event
+
+Command Values
+    None
+
+Reset Values
+    disconnectTimeout is 10 seconds
+
+Restrictions
+    This command can only be issued while in a DISCONNECTED state
+
+=====================================================================
+
+
+Name
+    SET_FIXRATES
+
+Synopsis
+    By default, the AR6000 device uses all PHY rates based on mode of operation. If the
+    host application requires the device to use subset of supported rates, it can set those
+    rates with this command. In 802.11g mode, the AR6000 device takes the entire
+    802.11g basic rate set and the rates specified with this command and uses it as the
+    supported rate set.
+
+    This rate set is advertised in the probe request and the assoc/re-assoc request as
+    supported rates. Upon successful association, the device modifies the rate set pool
+    using the: intersection of AP-supported rates with the union of the 802.11g basic rate
+    set and rates set using this command. The device picks transmission rates from this
+    pool based on a rate control algorithm.
+
+Command
+    TBD
+
+Command Parameters
+    A_UINT16    fixRateMask;
+        The individual bit is an index for rate table,
+        and setting the that index to 1 would set that
+        corresponding rate. E.g., fixRateMask = 9
+        (1001) sets 1 Mbps and 11 Mbps.
+
+Command Values
+    None
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+See Also
+    GET_FIXRATES
+
+=====================================================================
+
+
+Name
+    SET_WHAL_PARAM
+
+Synopsis
+    An internal AR6000 command that is used to set certain hardware parameters. The
+    description of this command is in $WORKAREA/include/halapi.h.
+
+Command
+    TBD
+
+Command Parameters
+    ATH_HAL_SETCABTO_CMDID
+        Sets the timeout waiting for the multicast
+        traffic after a DTIM beacon (in TUs).
+
+Command Values
+    None
+
+Reset Value
+    Default = 10 TUs
+
+Restrictions
+    This command should be executed before issuing a connect command.
+
+=====================================================================
+
+
+Name
+    SET_HOST_SLEEP_MODE
+
+Synopsis
+    The host uses this command to set the host mode to asleep or awake. All packets are
+    delivered to the host when the host mode is awake. When host mode is asleep, only if
+    WoW is enabled and the incoming packet matches one of the specified WoW
+    patterns, will the packet be delivered to the host. The host will also be woken up by
+    the target for pattern-matching packets and important events.
+
+Command
+    wmiconfig sethostmode=<asleep/awake>
+
+Command Parameters
+    A_BOOL    awake    Set the host mode to awake
+    A_BOOL    asleep   Set the host mode to asleep
+
+Command Values
+    1 = awake, 0 = asleep
+
+Reset Value
+    None defined (default host mode is awake)
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    SET_IBSS_PM_CAPS
+
+Synopsis
+    Used to support a non-standard power management scheme for an ad hoc wireless
+    network consisting of up to eight stations (STAs) that support this form of power
+    saving (e.g., Atheros-based STAs). A thorough understanding of IEEE 802.11 ad hoc
+    networks is required to use this command effectively.
+
+Command
+    wmiconfig eth1 --ibsspmcaps --ps=<enable/disable>
+        --aw=<ATIM Windows in ms>
+        --ttl=<Time to live in number of beacon periods>
+        --to=<timeout in ms>
+
+Command Parameters
+    UINT8    power_saving
+        = 0
+        The non-standard power saving scheme is
+        disabled and maximum throughput (with no
+        power saving) is obtained.
+
+        = 1
+        Ad hoc power saving scheme is enabled (but
+        throughput may be decreased)
+
+    UINT16    atim_windows
+        Specifies the length (in ms) of the ad hoc traffic
+        indication message (ATIM) windows used in an ad
+        hoc network. All Atheros-based STAs that join the
+        network use this duration ATIM window.
+
+    The duration is communicated between wireless
+    STAs through an IE in beacons and probe responses.
+
+    The host sets atim_windows to control trade-offs
+    between power use and throughput. The value
+    chosen should be based on the beacon interval (see
+    the SET_BEACON_INT command) on the
+    expected number of STAs in the IBSS, and on the
+    amount of traffic and traffic patterns between STAs.
+
+    UINT16    timeout_value
+        Specifies the timeout (in ms). The value is the same
+        for all ad hoc connections, but tracks separately for
+        each.
+
+        Applicable only for a beacon period and used to
+        derive actual timeout values on the Tx and Rx sides.
+        On the Tx side, the value defines a window during
+        which the STA accepts the frame(s) from the host for a
+        particular connection. Until closed, the window
+        restarts with every frame received from the host. On
+        the Rx side, indicates the time until which the STA
+        continues accepting frames from a particular
+        connection. The value resets with every frame
+        received. The value can be used to determine the
+        trade off between throughput and power.
+        Default = 10 ms
+
+    UINT8    ttl
+        Specifies the value in number of beacon periods. The
+        value is used to set a limit on the time until which a
+        frame is kept alive in the AR6001 before being
+        discarded. Default = 5
+
+Command Values
+    None
+
+Reset Values
+    By default, power_saving is enabled with atim_window = 20 ms
+
+Restrictions
+    Can only be issued before the AR6000 starts an ad hoc network
+
+See Also
+    SET_BEACON_INT
+
+=====================================================================
+
+
+
+Name
+    SET_LISTEN_INT
+
+Synopsis
+    The host uses this command to request a listen interval, which determines how often
+    the AR6000 device should wake up and listen for traffic. The listen interval can be set
+    by the TUs or by the number of beacons. The device may not be able to comply with
+    the request (e.g., if the beacon interval is greater than the requested listen interval, the
+    device sets the listen interval to the beacon interval). The actual listen interval used
+    by the device is available in the CONNECT event.
+
+Command
+    wmiconfig eth1 --listen=<#of TUs, can range from 15 to 3000>
+
+    --listenbeacons=<#of beacons, can range from 1 to 50>
+
+Command Parameters
+    UINT16    listenInterval
+        Specifies the listen interval in Kms
+        (1024 ms), ranging from 100 to 1000
+
+    UINT16    listenbeacons
+        Specifies the listen interval in beacons,
+        ranging from 1 to 50
+
+Command Values
+    None
+
+Reset Values
+    The device sets the listen interval equal to the beacon interval of the AP it associates
+    to.
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_LPREAMBLE
+
+Synopsis
+    Overrides the short preamble capability of the AR6000 device
+
+Command
+    TBD
+
+Command Parameters
+    WMI_LPREAMBLE_DISABLED
+        The device is short-preamble capable
+
+    WMI_LPREAMBLE_ENABLED
+        The device supports only the long-
+    preamble mode
+
+Command Values
+    None
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    SET_MAX_SP_LEN
+
+Synopsis
+    Set the maximum service period; indicates the number of packets the AR6001 can
+    receive from the AP when triggered
+
+Command
+    wmiconfig eth1 --setMaxSPLength <maxSPLen>
+
+Command Parameters
+    UINT8    maxSPLen
+        An APSD_SP_LEN_TYPE value
+
+Command Values
+    {
+        DELIVER_ALL_PKT  = 0x0
+        DELIVER_2_PKT    = 0x1
+        DELIVER_4_PKT    = 0x2
+        DELIVER_6_PKT    = 0x3
+    }APSD_SP_LEN_TYPE
+
+
+Reset Values
+    maxSPLen is DELIVER_ALL_PKT
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_OPT_MODE
+
+Synopsis
+    Special feature, sets the special mode on/off
+
+Command
+    wmiconfig eth1 --mode <mode>
+    Set the optional mode, where mode is special or off
+
+Command Parameters
+    enum {
+        SPECIAL_OFF
+        SPECIAL_ON
+    } OPT_MODE_TYPE;
+
+Command Values
+
+Reset Value
+    Mode = Off
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_PMKID
+
+Synopsis
+    The host uses this command to enable or disable a pairwise master key ID (PMKID)
+    in the AR6000 PMKID cache. The AR6000 clears its PMKID cache on receipt of a
+    DISCONNECT command from the host. Individual entries in the cache might be
+    deleted as the AR6000 detect new APs and decides to remove old ones.
+
+Command
+    wmiconfig eth1 --setbsspmkid --bssid=<aabbccddeeff>
+    --bsspmkid=<pmkid>
+
+Command Parameters
+    UINT8    bssid[6]
+        The MAC address of the AP that the
+        PMKID corresponds to (6 bytes in hex
+        format)
+
+    UINT8    enable
+        Either PMKID_DISABLE (0) to disable
+        the PMKID or PMKID_ENABLE (1) to
+        enable it (16 bytes in hex format)
+
+    UINT8    pmkid[16]
+        Meaningful only if enable is
+        PMKID_ENABLE, when it is the PMKID
+        that the AR6000 should use on the next
+        reassociation with the specified AP
+
+Command Values
+    enable
+    = 0 (disable), 1 (enable)
+    PKMID enabled/disabled
+
+Reset Values
+    None defined
+
+Restrictions
+    Only supported in infrastructure networks
+
+=====================================================================
+
+
+Name
+    SET_PMKID_LIST_CMD
+
+Synopsis
+    Configures the list of PMKIDs on the firmware.
+
+Command
+    wmiconfig --setpmkidlist --numpmkid=<n> --pmkid=<pmkid_1>
+    ... --pmkid=<pmkid_n>
+
+    Where n is the number of pmkids (maximum = 8) and pmkid_i is the ith pmkid (16
+    bytes in hex format)
+
+Command Parameters
+    {
+        A_UINT8 pmkid[WMI_PMKID_LEN];
+    } __ATTRIB_PACK WMI_PMKID;
+
+    {
+        A_UINT32 numPMKID;
+        WMI_PMKID pmkidList[WMI_MAX_PMKID_CACHE];
+    } __ATTRIB_PACK WMI_SET_PMKID_LIST_CMD;
+
+Command Values
+    None
+
+Reset Values
+    None
+
+Restrictions
+    Supported only in infrastructure modes
+
+=====================================================================
+
+
+Name
+    SET_POWER_MODE
+
+Synopsis
+    The host uses this command to provide the AR6000 device with guidelines on the
+    desired trade-off between power utilization and performance.
+
+        In normal power mode, the device enters a sleep state if they have nothing to do,
+        which conserves power but may cost performance as it can take up to 2 ms to
+        resume operation after leaving sleep state.
+
+        In maximum performance mode, the device never enters sleep state, thus no time
+        is spent waking up, resulting in higher power consumption and better
+        performance.
+
+Command
+    TBD
+
+Command Parameters
+    UINT8    powerMode
+        WMI_POWER_MODE value
+    {
+        REC_POWER   = 1
+            (Recommended setting) Tries to conserve
+            power without sacrificing performance
+        MAX_PERF_POWER    = 2
+            Setting that maximizes performance at
+            the expense of power
+
+            All other values are reserved
+    } WMI_POWER_MODE
+
+Command Values
+    See command parameters
+
+Reset Values
+    powerMode is REC_POWER
+
+Restrictions
+    This command should only be issued in the DISCONNECTED state for the
+    infrastructure network.
+
+            For a PM-disabled ad hoc network, the power mode should remain in
+            MAX_PERF_POWER.
+
+            For a PM-enabled ad hoc network, the device can have REC_POWER or
+            MAX_PERF_POWER set, but either way it must follow the power save ad hoc
+            protocol. The host can change power modes in the CONNECTED state.
+
+    Host changes to the PS setting when the STA is off the home channel take no effect
+    and cause a TARGET_PM_FAIL event.
+
+=====================================================================
+
+
+Name
+    SET_POWER_PARAMS
+
+Synopsis
+    The host uses this command to configure power parameters
+
+Command
+    wmiconfig eth1 --pmparams --it=<ms> --np=<number of PS POLL>
+    --dp=<DTIM policy: ignore/normal/stick>
+
+Command Parameters
+    UINT16    idle_period
+        Length of time (in ms) the AR6000 device
+        remains awake after frame Rx/Tx before going
+        to SLEEP state
+
+    UINT16    pspoll_number
+            The number of PowerSavePoll (PS-poll)
+            messages the device should send before
+            notifying the AP it is awake
+
+    UINT16    dtim_policy
+            A WMI_POWER_PARAMS_CMD value
+
+    {
+        IGNORE_DTIM    =1
+            The device does not listen to any content after
+            beacon (CAB) traffic
+        NORMAL_DTIM    = 2
+            DTIM period follows the listen interval (e.g., if
+            the listen interval is 4 and the DTIM period is 2,
+            the device wakes up every fourth beacon)
+        STICK_DTIM    = 3
+            Device attempt to receive all CAB traffic (e.g., if
+            the DTIM period is 2 and the listen interval is 4,
+            the device wakes up every second beacon)
+    } WMI_POWER_PARAMS_CMD
+
+Command Parameters
+    See command parameters
+
+Reset Values
+    idle_period
+        200 ms
+
+    pspoll_number
+    = 1
+
+    dtim_policy
+    = NORMAL_DTIM
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_POWERSAVE_PARAMS
+
+Synopsis
+    Set the two AR6000 power save timers (PS-POLL timer and APSD trigger timer) and
+    the two ASPD TIM policies
+
+Command
+    wmiconfig eth1--psparams --psPollTimer=<psPollTimeout in ms>
+    --triggerTimer=<triggerTimeout in ms> --apsdTimPolicy=<ignore/
+    adhere> --simulatedAPSDTimPolicy=<ignore/adhere>
+
+Command Parameters
+    typedef struct {
+        A_UINT16    psPollTimeout;
+            Timeout (in ms) after sending PS-POLL; the
+            AR6000 device sleeps if it does not receive a
+            data packet from the AP
+
+        A_UINT16    triggerTimeout;
+            Timeout (in ms) after sending a trigger; the
+            device sleeps if it does not receive any data
+            or null frame from the AP
+
+        APSD_TIM_POLICY    apsdTimPolicy;
+            TIM behavior with queue APSD enabled
+
+        APSD_TIM_POLICY    simulatedAPSD
+
+        TimPolicy;
+            TIM behavior with simulated APSD
+            enabled
+
+    typedef enum {
+        IGNORE_TIM_ALL_QUEUES_APSD = 0,
+        PROCESS_TIM_ALL_QUEUES_APSD = 1,
+        IGNORE_TIM_SIMULATED_APSD = 2,
+        POWERSAVE_TIMERS_POLICY = 3,
+    } APSD_TIM_POLICY;
+
+Command Values
+    None
+
+Reset Values
+    psPollTimeout is 50 ms; triggerTimeout is 10 ms;
+    apsdTimPolicy = IGNORE_TIM_ALL_QUEUES_APSD;
+    simulatedAPSDTimPolicy = POWERSAVE_TIMERS_POLICY
+
+Restrictions
+    When this command is used, all parameters must be set; this command does not
+    allow setting only one parameter.
+
+=====================================================================
+
+
+Name
+    SET_PROBED_SSID
+
+Synopsis
+    The host uses this command to provide a list of up to MAX_PROBED_SSID_INDEX
+    (six) SSIDs that the AR6000 device should actively look for. It lists the active SSID
+    table. By default, the device actively looks for only the SSID specified in the
+    CONNECT_CMD command, and only when the regulatory domain allows active
+    probing. With this command, specified SSIDs are probed for, even if they are hidden.
+
+Command
+    wmiconfig eth1 --ssid=<ssid> [--num=<index>]
+
+Command Parameters
+    {
+        A_UINT8    numSsids
+            A number from 0 to
+            MAX_PROBED_SSID_INDEX indicating
+            the active SSID table entry index for this
+            command (if the specified entry index
+            already has an SSID, the SSID specified in
+            this command replaces it)
+
+        WMI_PROBED_SSID_INFO    probedSSID[1]
+    } WMI_PROBED_SSID_CMD
+
+    {
+        A_UINT8    flag
+            WMI_SSID_FLAG indicates the current
+            entry in the active SSID table
+        A_UINT8    ssidLength
+            Length of the specified SSID in bytes.
+            If = 0, the entry corresponding to the
+            index is erased
+        A_UINT8    ssid[32]
+            SSID string actively probed for when
+            permitted by the regulatory domain
+    } WMI_PROBED_SSID_INFO
+
+Command Values
+    WMI_SSID_FLAG
+    {
+         DISABLE_SSID_FLAG    = 0
+            Disables entry
+        SPECIFIC_SSID_FLAG    = 1
+            Probes specified SSID
+        ANY_SSID_FLAG    = 2
+            Probes for any SSID
+    } WMI_SSID_FLAG
+
+Reset Value
+    The entries are unused.
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_REASSOC_MODE
+
+Synopsis
+    Specify whether the disassociated frame should be sent or not upon reassociation.
+
+Command
+    wmiconfig eth1 --setreassocmode <mode>
+
+Command Parameters
+    UINT8    mode
+
+Command Values
+    mode
+        = 0x00
+        Send disassoc to a previously connected AP
+        upon reassociation
+        = 0x01
+        Do not send disassoc to previously connected
+        AP upon reassociation
+
+Reset Values
+    None defined
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    SET_RETRY_LIMITS
+
+Synopsis
+    Allows the host to influence the number of times that the AR6000 device should
+    attempt to send a frame before they give up.
+
+Command
+    wmiconfig --setretrylimits <frameType> <trafficClass> <maxRetries>
+    <enableNotify>
+
+Command Parameters
+    {
+        UINT8    frameType
+            A WMI_FRAMETYPE specifying
+            which type of frame is of interest.
+        UINT8    trafficClass
+            Specifies a traffic class (see
+            CREATE_PSTREAM). This
+            parameter is only significant when
+            frameType = DATA_FRAMETYPE.
+        UINT8    maxRetries
+            Maximum number of times the
+            device attempts to retry a frame Tx,
+            ranging from WMI_MIN_RETRIES
+            (2) to WMI_MAX_RETRIES (15). If
+            the special value 0 is used,
+            maxRetries is set to 15.
+        A_UINT8    enableNotify
+            Notify when enabled
+    } WMI_RETRY_LIMIT_INFO
+
+    {
+        A_UINT8    numEntries
+        WMI_RETRY_LIMIT_INFO  retryLimitInfo[1]
+    } WMI_SET_RETRY_LIMITS_CMD
+
+Command Values
+    {
+        MGMT_FRAMETYPE    = 0    Management frame
+        CONTROL_FRAMETYPE = 1    Control frame
+        DATA_FRAMETYPE    = 2    Data frame
+    } WMI_FRAMETYPE
+
+Reset Values
+    Retries are set to 15
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_ROAM_CTRL
+
+Synopsis
+    Affects how the AR6000 device selects a BSS. The host uses this command to set and
+    enable low RSSI scan parameters. The time period of low RSSI background scan is
+    mentioned in scan period. Low RSSI scan is triggered when the current RSSI
+    threshold (75% of current RSSI) is equal to or less than scan threshold.
+
+    Low RSSI roam is triggered when the current RSSI threshold falls below the roam
+    threshold and roams to a better AP by the end of the scan cycle. During Low RSSI
+    roam, if the STA finds a new AP with an RSSI greater than roam RSSI to floor, during
+    scan, it roams immediately to it instead of waiting for the end of the scan cycle. See
+    also Scan and Roam on page C-1.
+
+Command
+    wmiconfig --roam <roamctrl> <info>, where info is <scan period>
+    <scan threshold> <roam threshold> <roam rssi floor>
+
+Command Parameters
+    A_UINT8    roamCtrlType;
+
+Command Values
+    WMI_FORCE_ROAM     = 1
+    Roam to the specified BSSID
+
+    WMI_SET_ROAM_MODE  = 2
+    Default, progd bias, no roam
+
+    WMI_SET_HOST_BIAS  = 3
+    Set the host bias
+
+    WMI_SET_LOWRSSI_SCAN_PARAMS  = 4
+    Info parameters
+
+    A_UINT8    bssid[ATH_MAC_LEN];
+    WMI_FORCE_ROAM
+
+    A_UINT8    roamMode;
+    WMI_SET_ROAM_MODE
+
+    A_UINT8    bssBiasInfo;
+    WMI_SET_HOST_BIAS
+
+    A_UINT16    lowrssi_scan_period;
+    WMI_SET_LOWRSSI_SCAN_PARAMS
+
+    A_INT16
+    lowrssi_scan_threshold;
+    WMI_SET_LOWRSSI_SCAN_PARAMS
+
+    A_INT16    lowrssi_roam_threshold;
+    WMI_SET_LOWRSSI_SCAN_PARAMS
+
+    A_UINT8    roam_rssi_floor;
+    WMI_SET_LOWRSSI_SCAN_PARAMS
+
+Reset Value
+    None defined (default lowrssi scan is disabled. Enabled only when scan period is set.)
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_RTS
+
+Synopsis
+    Decides when RTS should be sent.
+
+Command
+    wmiconfig eth1 --setRTS <pkt length threshold>
+
+Command Parameters
+    A_UINT16
+    threshold;
+    Command parameter threshold in bytes. An RTS is
+    sent if the data length is more than this threshold.
+    The default is to NOT send RTS.
+
+Command Values
+    None
+
+Reset Value
+    Not to send RTS.
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    SET_SCAN_PARAMS
+
+Synopsis
+    The host uses this command to set the AR6000 scan parameters, including the duty
+    cycle for both foreground and background scanning. Foreground scanning takes
+    place when the AR6000 device is not connected, and discovers all available wireless
+    networks to find the best BSS to join. Background scanning takes place when the
+    device is already connected to a network and scans for potential roaming candidates
+    and maintains them in order of best to worst. A second priority of background
+    scanning is to find new wireless networks.
+
+    The device initiates a scan when necessary. For example, a foreground scan is always
+    started on receipt of a CONNECT_CMD command or when the device cannot find
+    a BSS to connect to. Foreground scanning is disabled by default until receipt of a
+    CONNECT command. Background scanning is enabled by default and occurs every
+    60 seconds after the device is connected.
+
+    The device implements a binary backoff interval for foreground scanning when it
+    enters the DISCONNECTED state after losing connectivity with an AP or when a
+    CONNECT command is received. The first interval is ForegroundScanStartPeriod,
+    which doubles after each scan until the interval reaches ForegroundScanEndPeriod.
+    If the host terminates a connection with DISCONNECT, the foreground scan period
+    is ForegroundScanEndPeriod. All scan intervals are measured from the time a full
+    scan ends to the time the next full scan starts. The host starts a scan by issuing a
+    START_SCAN command. See also Scan and Roam on page C-1.
+
+Command
+    wmiconfig eth1 --scan --fgstart=<sec> --fgend=<sec> --bg=<sec> --
+    act=<msec> --pas=<msec> --sr=<short scan ratio> --scanctrlflags
+    <connScan> <scanConnected> <activeScan> <reportBSSINFO>
+
+Command Parameters
+    UINT16    fgStartPeriod
+        First interval used by the device when it
+        disconnects from an AP or receives a
+        CONNECT command, specified in seconds (0
+        65535). If = 0, the device uses the reset value.
+        If = 65535, the device disables foreground
+        scanning.
+
+    UINT16    fgEndPeriod
+        The maximum interval the device waits between
+        foreground scans specified in seconds (from
+        ForegroundScanStartPeriod to 65535). If = 0, the
+        device uses the reset value.
+
+    UINT16    bgScanPeriod
+        The period of background scan specified in
+        seconds (065535). By default, it is set to the reset
+        value of 60 seconds. If 0 or 65535 is specified, the
+        device disables background scanning.
+
+    UINT16    maxactChDwellTime
+        The period of time the device stays on a
+        particular channel while active scanning. It is
+        specified in ms (1065535). If the special value of
+        0 is specified, the device uses the reset value.
+
+    UINT16    PasChDwellTime
+        The period of time the device remains on a
+        particular channel while passive scanning. It is
+        specified in ms (1065535). If the special value of
+        0 is specified, the device uses the reset value.
+
+    UINT8    shortScanRatio
+        Number of short scans to perform for each
+        long scan.
+
+    UINT8    scanCtrlFlasgs
+
+    UINT16    minactChDwellTime
+        Specified in ms
+
+    UINT32    maxDFSchActTime
+        The maximum time a DFS channel can stay
+        active before being marked passive, specified in
+        ms.
+
+Command Values
+    None
+
+Reset Values
+    ForegroundScanStart
+Period
+        1 sec
+
+    ForegroundScanEndPeriod
+        60 sec
+
+    BackgroundScanPeriod
+        60 sec
+
+    ActiveChannelDwellTime
+        105 ms
+
+=====================================================================
+
+
+Name
+    SET_TKIP_COUNTERMEASURES
+
+Synopsis
+    The host issues this command to tell the target whether to enable or disable TKIP
+    countermeasures.
+
+Command
+    TBD
+
+Command Parameters
+    UINT8    WMI_TKIP_CM_ENABLE
+        Enables the countermeasures
+
+
+    UINT8    TKIP_CM_DISABLE
+        Disables the countermeasures
+
+Command Values
+    None
+
+Reset Values
+    By default, TKIP MIC reporting is disabled
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_TX_PWR
+
+Synopsis
+    The host uses this command to specify the Tx power level of the AR6000. Cannot be
+    used to exceed the power limit permitted by the regulatory domain. The maximum
+    output power is limited in the chip to 31.5 dBm; the range is 0  31.5 dbm.
+
+Command
+    wmiconfig --power <dbM>
+
+Command Parameters
+    UINT8    dbM
+        The desired Tx power specified in dbM.
+        If = 0, the device chooses the maximum
+        permitted by the regulatory domain.
+
+Command Values
+    None
+
+Reset Values
+    The maximum permitted by the regulatory domain
+
+Restrictions
+    None
+
+See Also
+    GET_TX_PWR
+
+
+=====================================================================
+
+Name
+    SET_VOICE_PKT_SIZE
+
+Synopsis
+    If an AP does not support WMM, it has no way to differentiate voice from data.
+    Because the voice packet is typically small, packet in size less than voicePktSize are
+    assumed to be voice, otherwise it is treated as data.
+
+Command
+    wmiconfig eth1 --setVoicePktSize <size-in-bytes>
+
+Command Parameters
+    UINT16    voicePktSize
+        Packet size in octets
+
+Command Values
+    None
+
+Reset Values
+    voicePktSize default is 400 bytes
+
+Restrictions
+    No effect if WMM is unavailable
+
+
+=====================================================================
+
+Name
+    SET_WMM
+
+Synopsis
+    Overrides the AR6000 device WMM capability
+
+Command
+    wmiconfig eth1 --setwmm <enable>
+
+Command Parameters
+    WMI_WMM_ENABLED
+        Enables WMM
+
+    WMI_WMM_DISABLED
+        Disables WMM support
+
+Command Values
+    0 = disabled
+    1 = enabled
+
+Reset Value
+    WMM Disabled
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    SET_WMM_TXOP
+
+Synopsis
+    Configures TxOP Bursting when sending traffic to a WMM capable AP
+
+Command
+    wmiconfig eth1 --txopbursting <burstEnable>
+
+    <burstEnable>
+        = 0
+    Disallow TxOp bursting
+
+        = 1
+    Allow TxOp bursting
+
+Command Parameters
+    txopEnable
+        = WMI_TXOP_DISABLED
+        Disabled
+
+        = WMI_TXOP_ENABLED
+        Enabled
+
+Command Values
+    txopEnable
+        = 0    Disabled
+
+        = 1    Enabled
+
+Reset Value
+    Bursting is off by default
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    SET_WOW_MODE
+
+Synopsis
+    The host uses this command to enable or disable the WoW mode. When WoW mode
+    is enabled and the host is asleep, pattern matching takes place at the target level.
+    Only packets that match any of the pre-specified WoW filter patterns, will be passed
+    up to the host. The host will also be woken up by the target. Packets which do not
+    match any of the WoW patterns are discarded.
+
+Command
+    wmiconfig setwowmode <enable/disable>
+
+Command Parameters
+    A_BOOL    enable_wow
+        Enable or disable WoW:
+
+Command Values
+        = 0
+    Disable WoW
+
+        = 1
+    Enable WoW
+
+Reset Value
+    None defined (default WoW mode is disabled).
+
+Restrictions
+    None
+
+See Also
+    GET_WOW_LIST
+
+
+=====================================================================
+
+Name
+    SET_WSC_STATUS
+
+Synopsis
+    The supplicant uses this command to inform the target about the status of the WSC
+    registration protocol. During the WSC registration protocol, a flag is set so the target
+    bypasses some of the checks in the CSERV module. At the end of the registration, this
+    flag is reset.
+
+Command
+    N/A
+
+Command Parameters
+    A_BOOL status
+        = 1    WSC registration in progress
+        = 0    WSC protocol not running
+
+Reply Parameters
+    None
+
+Reset Value
+    None defined (default = 0)
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    SNR_THRESHOLD_PARAMS
+
+Synopsis
+    Configures how the AR6000 device monitors and reports SNR of the connected BSS,
+    used as a link quality metric.
+
+Command
+    --snrThreshold <weight> <upper_threshold_1> ...
+    <upper_threshold_4> <lower_threshold_1> ... <lower_threshold_4>
+    <pollTimer>
+
+Command Parameters
+    <weight>
+        Share with rssiThreshold. Range in [1, 16], used
+        in the formula to calculate average RSSI
+
+    <upper_threshold_x>
+        Above thresholds expressed in db, in ascending
+        order
+
+    <lower_threshold_x>
+        Below thresholds expressed in db, in ascending
+        order
+
+    <pollTimer>
+        The signal strength sampling frequency in
+        seconds. If polltime = 0, signal strength
+        sampling is disabled
+
+Command Values
+    None
+
+Reset Value
+    None defined
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    START_SCAN
+
+Synopsis
+    The host uses this command to start a long or short channel scan. All future scans are
+    relative to the time the AR6000 device processes this command. The device performs
+    a channel scan on receipt of this command, even if a scan was already in progress.
+    The host uses this command when it wishes to refresh its cached database of wireless
+    networks. The isLegacy field will be removed (0 for now) because it is achieved by
+    setting CONNECT_PROFILE_MATCH_DONE in the CONNECT command. See also
+    Scan and Roam
+
+Command
+    wmiconfig eth1 --startscan <scan type> <forcefgscan> 0
+    <homeDwellTime> <forceScanInterval>
+
+Command Parameters
+    UINT8    scanType
+        WMI_SCAN_TYPE
+
+Command Values
+    {
+        WMI_LONG_SCAN    =0x0
+            Requests a full scan
+        WMI_SHORT_SCAN   =0x1
+            Requests a short scan
+    } WMI_SCAN_TYPE
+
+    A_BOOL    forceFgScan
+        forceFgScan
+        = 0
+        Disable the foreground scan
+
+        forceFgScan
+        = 1
+        Forces a foreground scan
+
+    A_UINT32    homeDwellTime
+        Maximum duration in the home
+        channel (in ms)
+
+    A_UINT32     forceScanInterval
+        Time interval between scans (in ms)
+
+    A_UINT32     scanType
+        WMI_SCAN_TYPE
+
+Reset Value
+    Disable forcing foreground scan
+
+Restrictions
+    isLegacy field will no longer be supported (pass as 0 for now)
+
+
+=====================================================================
+
+Name
+    SYNCHRONIZE
+
+Synopsis
+    The host uses this command to force a synchronization point between the command
+    and data paths
+
+Command
+    TBD
+
+Command Parameters
+    None
+
+
+
+Command Values
+    None
+
+
+
+Reset Values
+    None
+
+
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    TARGET_ERROR_REPORT_BITMASK
+
+Synopsis
+    Allows the host to control ERROR_REPORT events from the AR6000 device.
+
+        If error reporting is disabled for an error type, a count of errors of that type is
+        maintained by the device.
+
+        If error reporting is enabled for an error type, an ERROR_REPORT event is
+        sent when an error occurs and the error report bit is cleared.
+
+    Error counts for each error type are available through the GET_TARGET_STATS
+    command.
+
+Command
+    wmiconfig eth1 --setErrorReportingBitmask
+
+Command Parameters
+    UINT32    bitmask
+        Represents the set of
+        WMI_TARGET_ERROR_VAL error types
+        enabled for reporting
+
+Command Values
+    {
+        WMI_TARGET_PM_ERR_FAIL    = 0x00000001
+            Power save fails (only two cases):
+               Retry out of null function/QoS null
+               function to associated AP for PS
+               indication'
+               Host changes the PS setting when
+               STA is off home channel
+
+        WMI_TARGET_KEY_NOT_FOUND    = 0x00000002
+            No cipher key
+        WMI_TARGET_DECRYPTION_ERR   = 0x00000004
+            Decryption error
+        WMI_TARGET_BMISS            = 0x00000008
+            Beacon miss
+        WMI_PSDISABLE_NODE_JOIN     = 0x00000010
+            A non-PS-enabled STA joined the
+            PS-enabled network
+        WMI_TARGET_COM_ERR          = 0x00000020
+            Host/target communication error
+        WMI_TARGET_FATAL_ERR        = 0x00000040
+            Fatal error
+    } WMI_TARGET_ERROR_VAL
+
+Reset Values
+    Bitmask is 0, and all error reporting is disabled
+
+Restrictions
+    None
+
+
+=====================================================================
+WMI Events
+
+Event
+    Description
+    Page
+
+
+BSSINFO
+    Contains information describing BSSs collected during a scan
+
+CAC_EVENTID
+    Indicates signalling events in admission control
+
+CMDERROR
+    The AR6000 device encounters an error while attempting to process
+    a command
+
+CONNECT
+    The device has connected to a wireless network
+
+DISCONNECT
+    The device lost connectivity with a wireless network
+
+ERROR_REPORT
+    An error has occurred for which the host previously requested
+    notification with the command
+    TARGET_ERROR_REPORT_BITMASK
+
+EXTENSION
+    WMI extension event
+
+GET_PMKID_LIST_EVENT
+    Created in response to a GET_PMKID_LIST_CMD command
+
+GET_WOW_LIST_EVENT
+    Response to the wmiconfig GET_WOW_LIST command to
+    retrieve the configured WoW patterns
+
+NEIGHBOR_REPORT
+    Neighbor APs that match the current profile were detected
+
+OPT_RX_FRAME_EVENT
+    (Special feature) informs the host of the reception of a special frame
+
+PSTREAM_TIMEOUT
+    A prioritized stream has been idle for a specified interval
+
+READY
+    The AR6000 device is ready to accept commands
+
+REGDOMAIN
+    The regulatory domain has changed
+
+REPORT_ROAM_DATA_EVENT
+    Reports the roam time calculations made by the device
+    (generated with a special build)
+    
+
+REPORT_STATISTICS
+    Reply to a GET_TARGET_STATS command
+
+ROAM_TBL_EVENT
+    Reports the roam table
+
+RSSI_THRESHOLD
+    Signal strength from the connected AP has crossed the threshold
+    defined in the RSSI_THRESHOLD_PARAMS command
+
+SCAN_COMPLETE_EVENT
+    A scan has completed (added status SCAN_ABORTED in release 2.0)
+
+TEST_EVENT
+    Event generated by the TCMD
+
+TKIP_MICERROR
+    TKIP MIC errors were detected
+
+=====================================================================
+
+Name
+    BSSINFO
+
+Synopsis
+    Contains information describing one or more BSSs as collected during a scan.
+    Information includes the BSSID, SSID, RSSI, network type, channel, supported rates,
+    and IEs. BSSINFO events are sent only after the device receives a beacon or probe-
+    response frame that pass the filter specified in the SET_BSS_FILTER command.
+    BSSINFO events consist of a small header followed by a copy of the beacon or probe
+    response frame. The 802.11 header is not present. For formats of beacon and probe-
+    response frames please consult the IEEE 802.11 specification.
+
+    The beacons or probe responses containing the IE specified by the
+    WMI_BSS_FILTER_CMD are passed to the host through the
+    WMI_BSSINFO_EVENT. The event carries a 32-bit bitmask that indicates the IEs that
+    were detected in the management frame. The frame type field has been extended to
+    indicate action management frames. This would be helpful to route these frames
+    through the same event mechanism as used by the beacon processing function.
+
+    If the bssFilter in the SET_BSS_FILTER matches, then the ieMask is not relevant
+    because the BSSINFO event is sent to the host. If the bssFilter doesnot match in the
+    beacons/probe respones, then the ieMask match dictates whether the BSSINFO
+    event is sent to the host. In the case of action management frames, the ieMask is the
+    filter that is applied.
+
+Event ID
+    0x1004
+
+Event Parameters
+    typedef struct {
+        A_UINT16    channel;
+            Specifies the frequency (in MHz) where the
+            frame was received
+        A_UINT8    frameType;
+            A WMI_BI_FTYPE value
+        A_UINT8    snr;
+        A_INT16    rssi;
+            Indicates signal strength
+        A_UINT8    bssid[ATH_MAC_LEN];
+        A_UINT32    ieMask;
+    } _ATTRIB_PACK_WMI_BSS_INFO_HDR;
+
+    Beacon or Probe Response Frame
+
+Event Values
+    {
+        BEACON_FTYPE    = 0x1
+            Indicates a beacon frame
+        PROBERESP_FTYPE
+            Indicates a probe response frame
+        ACTION_MGMT_FTYPE
+     } WMI_BI_FTYPE
+
+=====================================================================
+
+Name
+    CAC_EVENTID
+
+Synopsis
+    Indicates signalling events in admission control. Events are generated when
+    admission is accepted, rejected, or deleted by either the host or the AP. If the AP does
+    not respond to an admission request within a timeout of 500 ms, an event is
+    generated to the host.
+
+Event ID
+    0x1011
+
+Event Parameters
+    UINT8
+    ac
+    Access class pertaining to the
+signalling
+
+    UINT8    cac_indication
+        Type of indication; indications are
+        listed in WMI_CAC_INDICATION
+
+    UINT8    statusCode
+        AP response status code for a
+        request
+
+    UINT8    tspecSuggestion[63]
+        Suggested TSPEC from AP
+
+Event Values
+    {
+        CAC_INDICATION_ADMISSION = 0x00
+        CAC_INDICATION_ADMISSION_RESP    = 0x01
+        CAC_INDICATION_DELETE    = 0x02
+        CAC_INDICATION_NO_RESP   = 0x03
+    } WMI_CAC_INDICATION
+
+
+=====================================================================
+
+
+Name
+    CMDERROR
+
+Synopsis
+    Indicates that the AR6000 device encountered an error while attempting to process a
+    command. This error is fatal and indicates that the device requires a reset.
+
+Event ID
+    0x1005
+
+Event Parameters
+    UINT16    commandId
+        Corresponds to the command which generated
+        the error
+    UINT8    errorCode
+        A WMI_ERROR_CODE value
+
+Event Values
+    {
+        INVALID_PARAM    = 1
+            Invalid parameter
+        ILLEGAL_STATE    = 2
+            Illegal state
+        INTERNAL_ERROR   = 3
+            Internal Error
+        All other values reserved
+    } WMI_ERROR_CODE
+
+
+=====================================================================
+
+
+Name
+    CONNECT
+
+Synopsis
+    Signals that the AR6000 connected to a wireless network. Connection occurs due to a
+    CONNECT command or roaming to a new AP. For infrastructure networks, shows
+    that the AR6000 successfully performed 802.11 authentication and AP association.
+
+Event ID
+    0x1002
+
+Event Parameters
+    UINT16    channel
+        Channel frequency (in MHz) of the network the
+        AR6000 are connected to
+
+    UINT8    bssid[6]
+        MAC address of the AP the AR6000 are
+        connected to or the BSSID of the ad hoc
+        network
+
+    UINT16    listenInterval
+        Listen interval (in Kms) that the AR6000 are
+        using
+
+    UINT 8    beaconIeLen
+        Length (in bytes) of the beacon IEs
+
+    UINT8    assocInfo
+        Pointer to an array containing beacon IEs,
+        followed first by association request IEs then by
+        association response IEs
+
+    UINT8    assocReqLen
+        Length (in bytes) of the assocReqIEs array
+
+    UINT8    assocRespLen
+        Length (in bytes) of the assocRespIEs array
+
+Event Values
+    None defined
+
+=====================================================================
+
+
+Name
+    DISCONNECT
+
+Synopsis
+    Signals that the AR6000 device lost connectivity with the wireless network.
+    DISCONENCT is generated when the device fails to complete a CONNECT
+    command or as a result of a transition from a connected state to disconnected state.
+
+    After sending the DISCONNECT event the device continually tries to re-establish
+    a connection. A LOST_LINK occurs when STA cannot receive beacons within the
+    specified time for the SET_BMISS_TIME command.
+
+Event ID
+    0x1003
+
+Event Parameters
+    UINT8    disconnect
+        Reason
+        A WMI_DISCONNECT_REASON value
+
+    UINT8    bssid[6]
+        Indicates which BSS the device was connected to
+
+    UINT8    assocRespLen
+        Length of the 802.11 association response frame
+        that triggered this event, or 0 if not applicable
+
+    UINT8    assocInfo[assocRespLen]
+        Copy of the 802.11 association response frame
+
+Event Values
+    {
+        NO_NETWORK_AVAIL    =0x01
+            Indicates that the device was unable to
+            establish or find the desired network
+        LOST_LINK    =0x02
+            Indicates the devices is no longer receiving
+            beacons from the BSS it was previously
+            connected to
+
+        DISCONNECT_CMD  =0x03
+            Indicates a DISCONNECT command was
+            processed
+        BSS_DISCONNECTED =0x04
+            Indicates the BSS explicitly disconnected the
+            device. Possible mechanisms include the AP
+            sending 802.11 management frames
+            (e.g., disassociate or deauthentication
+            messages).
+        AUTH_FAILED    =0x05
+            Indicates that the device failed 802.11
+            authentication with the BSS
+        ASSOC_FAILED    =0x06
+            Indicates that the device failed 802.11
+            association with the BSS
+        NO_RESOURCES_AVAIL    =0x07
+            Indicates that a connection failed because the
+            AP had insufficient resources to complete the
+            connection
+        CSERV_DISCONNECT    =0x08
+            Indicates that the devices connection services
+            module decided to disconnect from a BSS,
+            which can happen for a variety of reasons (e.g.,
+            the host marks the current connected AP as a
+            bad AP).
+        INVALID_PROFILE    =0x0A
+            Indicates that an attempt was made to
+            reconnect to a BSS that no longer matches the
+            current profile
+        All other values are reserved
+    } WMI_DISCONNECT_REASON
+
+
+=====================================================================
+
+
+Name
+    ERROR_REPORT
+
+Synopsis
+    Signals that a type of error has occurred for which the host previously requested
+    notification through the TARGET_ERROR_REPORT_BITMASK command.
+
+Event ID
+    0x100D
+
+Event Parameters
+    UINT32    errorVal
+            WMI_TARGET_ERROR_VAL value. See
+            TARGET_ERROR_REPORT_BITMASK.
+
+Event Values
+    errorVal
+    = 0x00000001
+    Power save fails
+
+        = 0x00000002
+    No cipher key
+
+        = 0x00000004
+    Decryption error
+
+        = 0x00000008
+    Beacon miss
+
+        = 0x00000010
+    A non-power save disabled node has joined
+    the PS-enabled network
+
+
+=====================================================================
+
+
+Name
+    EXTENSION
+
+Synopsis
+    The WMI is used mostly for wireless control messages to a wireless module that
+    apply to wireless module management regardless of the target platform
+    implementation. However, some events peripherally related to wireless management
+    are desired during operation. These wireless extension events may be platform-
+    specific or implementation-dependent. See WMI Extension Commands
+
+
+Event ID
+    0x1010
+
+
+=====================================================================
+
+
+Name
+    GET_PMKID_LIST_EVENT
+
+Synopsis
+    Generated by firmware in response to a GET_PMKID_LIST_CMD command.
+
+Event Parameters
+    typedef struct {
+        A_UINT32    numPMKID;
+            Contains the number of PMKIDs in the reply
+        WMI_PMKID   pmkidList[1];
+    } __ATTRIB_PACK WMI_PMKID_LIST_REPLY;
+
+Event Values
+    None
+
+
+=====================================================================
+
+
+Name
+    GET_WOW_LIST_EVENT
+
+Synopsis
+    Response to the wmiconfig getwowlist command to retrieve the configured Wake on
+    Wireless patterns
+
+Event ID
+    0x10018
+
+Event Parameters
+    {
+
+    A_UINT8    num_filters
+        Total number of patterns in the list
+    A_UINT8    this_filter_num
+        The filter number
+    A_UINT8    wow_mode
+        Shows whether WoW is enabled or disabled
+    A_UINT8    host_mode
+        Shows whether the host is asleep or awake
+    WOW_FILTER    wow_filters[1]
+        List of WoW filters (pattern and mask data bytes)
+    } WMI_GET_WOW_LIST_REPLY;
+
+    {
+        Each wow_filter_list element shows:
+    A_UINT8    wow_valid_filter
+        Whether the filter is valid
+    A_UINT8    wow_filter_list_id
+        Filter List ID (23 = default)
+    A_UINT8    wow_filter_size
+        Size in bytes of the filter
+    A_UINT8    wow_filter_offset
+        Offset of the pattern to search in the data packet
+    A_UINT8    wow_filter_mask[MASK_SIZE]
+        The mask to be applied to the pattern
+    A_UINT8    wow_filter_pattern[WOW_PATTERN_SIZE]
+        The pattern that to match to wake up the host
+    } WOW_FILTER
+
+Event Values
+    None
+
+=====================================================================
+
+
+
+Name
+    NEIGHBOR_REPORT
+
+Synopsis
+    Indicates the existence of neighbor APs that match the current profile. The host uses
+    this event to populate the PMKID cache on the AR6000 and/or to perform
+    preauthentication. This event is only generated in infrastructure mode.
+
+    A total of numberOfAps pairs of bssid/bssFlags exist, one pair for each AP.
+
+Event ID
+    0x1008
+
+Event Parameters
+    UINT8    numberOfAps
+        The number of APs reported about in
+        this event
+    {
+        UINT8    bssid[6]
+            MAC address of a neighbor AP
+        UINT8    bssFlags
+            A WMI_BSS_FLAGS value
+    }[numberOfAps]
+
+
+Event Values
+    {
+        WMI_DEFAULT_BSS_FLAGS    = 0
+            Logical OR of 1 or more
+        WMI_BSS_FLAGS
+        WMI_PREAUTH_CAPABLE_BSS
+            = 1
+            Indicates that this AP is capable of
+            preauthentication
+        WMI_PMKID_VALID_BSS
+            = 2
+            Indicates that the AR6000 have a
+            valid pairwise master key for this AP
+    } WMI_BSS_FLAGS
+
+
+=====================================================================
+
+
+
+Name
+    OPT_RX_FRAME_EVENT
+
+Synopsis
+    Special feature, informs host of the reception of a special frame.
+
+Event ID
+    0x100E
+
+Event Parameters
+    {
+        A_UINT16    channel;
+        A_UINT8    frameType;
+        A_INT8    snr;
+        A_UINT8    srcAddr[ATH_MAC_LEN];
+        A_UINT8    bssid[ATH_MAC_LEN];
+        }WMI_OPT_RX_INFO_HDR
+
+Event Values
+    None
+
+=====================================================================
+
+
+
+Name
+    PSTREAM_TIMEOUT
+
+Synopsis
+    Indicates that a priority stream that got created as a result of priority-marked data
+    flow (priority marked in IP TOS) being idle for the default inactivity interval period
+    (specified in the CREATE_PSTREAM command) used for priority streams created
+    implicitly by the driver. This event is not indicated for user-created priority streams.
+    User-created priority streams exist until the users delete them explicitly. They do not
+    timeout due to data inactivity.
+
+Event ID
+    0x1007
+
+Event Parameters
+    A_UINT8
+    trafficClass
+    Indicated the traffic class of priority
+    stream that timed out
+
+Event Values
+    {
+        WMM_AC_BE    = 0
+            Best effort
+        WMM_AC_BK    = 1
+            Background
+        WMM_AC_VI    = 2
+            Video
+        WMM_AC_VO     = 3
+            Voice
+    } TRAFFIC CLASS
+
+
+=====================================================================
+
+Name
+    READY
+
+Synopsis
+    Indicates that the AR6000 device is prepared to accept commands. It is sent once after
+    power on or reset. It also indicates the MAC address of the device.
+
+Event ID
+    0x1001
+
+Event Parameters
+    UINT8    macAddr[6]
+        Device MAC address
+    UINT8    phyCapability
+        A WMI_PHY_CAPABILITY value. Indicates the
+        capabilities of the device wireless modules radio
+
+Event Values
+    {
+        WMI_11A_CAPABILITY       = 1
+        WMI_11G_CAPABILITY       = 2
+        WMI_11AG_CAPABILITY      = 3
+    } WMI_PHY_CAPABILITY
+
+
+=====================================================================
+
+Name
+    REGDOMAIN
+
+Synopsis
+    Indicates that the regulatory domain has changed. It initially occurs when the
+    AR6000 device reads the board data information. The regulatory domain can also
+    change when the device is a world-mode SKU. In this case, the regulatory domain is
+    based on the country advertised by APs per the IEEE 802.11d specification. A
+    potential side effect of a regulatory domain change is a change in the list of available
+    channels. Any channel restrictions that exist as a result of a previous
+    SET_CHANNEL_PARAMETERS command are lifted.
+
+Event ID
+    0x1006
+
+Event Parameters
+    UINT32    regDomain
+        The range of 0x0000  0x00FF
+        corresponds to an ISO country code.
+
+    Other regCodes are reserved for world
+    mode settings and specific regulatory
+    domains.
+
+Event Values
+    None
+
+
+=====================================================================
+
+
+
+Name
+    REPORT_STATISTICS
+
+Synopsis
+    A reply to a GET_TARGET_STATS command.
+
+Event ID
+    0x100B
+
+Event Parameters
+    When the statistics are sent to the host, the AR6001 clear them so that a new set of
+    statistics are collected for the next report.
+
+    UINT32    tx_packets
+    UINT32    tx_bytes
+    UINT32    tx_unicast_pkts
+    UINT32    tx_unicast_bytes
+    UINT32    tx_multicast_pkts
+    UINT32    tx_multicast_bytes
+    UINT32    tx_broadcast_pkts
+    UINT32    tx_broadcast_bytes
+    UINT32    tx_rts_success_cnt
+    UINT32    tx_packet_per_ac[4]
+        Tx packets per AC: [0] = BE, [1] = BK,
+        [2] = VI, [3] = VO
+    UINT32    tx_errors
+        Number of packets which failed Tx, due
+        to all failures
+    ... REPORT_STATISTICS, continued
+    UINT32    tx_failed_cnt
+        Number of data packets that failed Tx
+    UINT32    tx_retry_cnt
+        Number of Tx retries for all packets
+    UINT32    tx_rts_fail_cnt
+        Number of RTS Tx failed count
+    UINT32    rx_packets
+    UINT32    rx_bytes
+    UINT32    rx_unicast_pkts
+    UINT32    rx_unicast_bytes
+    UINT32    rx_multicast_pkts
+    UINT32    rx_multicast_bytes
+    UINT32    rx_broadcast_pkts
+    UINT32    rx_broadcast_bytes
+    UINT32    rx_fragment_pkt
+        Number of fragmented packets received
+    UINT32    rx_errors
+        Number of Rx errors due to all failures
+    UINT32    rx_crcerr
+        Number of Rx errors due to CRC errors
+    UINT32    rx_key_cache_miss
+        Number of Rx errors due to a key not
+        being plumbed
+    UINT32    rx_decrypt_err
+        Number of Rx errors due to decryption
+        failure
+    UINT32    rx_duplicate_frames
+        Number of duplicate frames received
+    UINT32    tkip_local_mic_failure
+        Number of TKIP MIC errors detected
+    UINT32    tkip_counter_measures_invoked
+        Number of times TKIP countermeasures
+        were invoked
+    UINT32    tkip_replays
+        Number of frames that replayed a TKIP
+        encrypted frame received earlier
+    UINT32    tkip_format_errors
+        Number of frames that did not conform
+        to the TKIP frame format
+    UINT32    ccmp_format_errors
+        Number of frames that did not conform
+        to the CCMP frame format
+    UINT32    ccmp_replays
+        Number of frames that replayed a CCMP
+        encrypted frame received earlier
+    UINT32    power_save_failure_cnt
+        Number of failures that occurred when
+        the AR6001 could not go to sleep
+    UINT32    cs_bmiss_cnt
+        Number of BMISS interrupts since
+    connection
+    UINT32    cs_lowRssi_cnt
+        Number of the times the RSSI went below
+        the low RSSI threshold
+    UINT16    cs_connect_cnt
+        Number of connection times
+    UINT16    cs_disconnect_cnt
+        Number of disconnection times
+    UINT8    cs_aveBeacon_rssi
+        The current averaged value of the RSSI
+        from the beacons of the connected BSS
+    UINT8    cs_lastRoam_msec
+        Time that the last roaming took, in ms.
+        This time is the difference between
+        roaming start and actual connection.
+
+Event Values
+    None defined
+
+
+=====================================================================
+
+Name
+    ROAM_TBL_EVENT
+
+Synopsis
+    Reports the roam table, which contains the current roam mode and this information
+    for every BSS:
+
+Event ID
+    0x100F
+
+Event Parameters
+    A_UINT8     bssid[ATH_MAC_LEN];
+        BSSID
+    A_UINT8     rssi
+        Averaged RSSI
+    A_UINT8     rssidt
+        Change in RSSI
+    A_UINT8     last_rssi
+        Last recorded RSSI
+    A_UINT8     roam_util
+        Utility value used in roaming decision
+    A_UINT8     util
+        Base utility with the BSS
+    A_UINT8     bias
+        Host configured for this BSS
+
+Event Values
+    roamMode
+        Current roam mode
+
+        = 1
+    RSSI based roam
+
+        = 2
+    Host bias-based roam
+
+        = 3
+    Lock to the current BSS
+
+        = 4
+    Autonomous roaming disabled
+
+
+=====================================================================
+
+Name
+    RSSI_THRESHOLD
+
+Synopsis
+    Alerts the host that the signal strength from the connected AP has crossed a
+    interesting threshold as defined in a previous RSSI_THRESHOLD_PARAMS
+    command.
+
+Event ID
+    0x100C
+
+Event Parameters
+    UINT8    range
+        A WMI_RSSI_THRESHOLD_VAL
+        value, which indicates the range of
+        the average signal strength
+
+Event Values
+    {
+        WMI_RSSI_LOWTHRESHOLD_BELOW_LOWERVAL  = 1
+        WMI_RSSI_LOWTHRESHOLD_LOWERVAL        = 2
+        WMI_RSSI_LOWTHRESHOLD_UPPERVAL        = 3
+        WMI_RSSI_HIGHTHRESHOLD_LOWERVAL       = 4
+        WMI_RSSI_HIGHTHRESHOLD_HIGHERVAL      = 5
+    } WMI_RSSI_THRESHOLD_VAL
+
+
+=====================================================================
+
+Name
+    SCAN_COMPLETE_EVENT
+
+Synopsis
+    Indicates the scan status. if the Scan was not completed, this event is generated with
+    the status A_ECANCELED.
+
+Event ID
+    0x100A
+
+Event Parameters
+    A_UINT8    scanStatus
+
+Event Values
+    {
+        #define     SCAN_ABORTED 16
+        #define     SCAN_COMPLETED 0
+        A_UINT8     scanStatus
+            A_OK or A_ECANCELED
+    } WMI_SCAN_COMPLETE_EVENT;
+
+
+=====================================================================
+
+Name
+    TEST_EVENT
+
+Synopsis
+    The TCMD application uses a single WMI event (WMI_TEST_EVENTID) to
+    communicate events from target to host. The events are parsed by the TCMD
+    application and WMI layer is oblivious of it.
+
+Event ID
+    0x1016
+
+Event Parameters
+    WMI_TEST_EVENTID
+
+
+Event Values
+    None
+
+
+=====================================================================
+
+
+
+Name
+    TKIP_MICERR
+
+Synopsis
+    Indicates that TKIP MIC errors were detected.
+
+Event ID
+    0x1009
+
+Event Parameters
+    UINT8    keyid
+        Indicates the TKIP key ID
+
+    UINT8    ismcast
+        0 = Unicast
+        1 = Multicast
+
+Event Values
+    See event parameters
+
+=====================================================================
+
+WMI Extension Commands
+
+The WMI EXTENSION command is used to multiplex a collection of
+commands that:
+
+        Are not generic wireless commands
+        May be implementation-specific
+        May be target platform-specific
+        May be optional for a host implementation
+
+    An extension command is sent to the AR6000 targets like any other WMI
+command message and uses the WMI_EXTENSION. The first field of the
+payload for this EXTENSION command is another commandId, sometimes
+called the subcommandId, which indicates which extension command is
+being used. A subcommandId-specific payload follows the subcommandId.
+
+All extensions (subcommandIds) are listed in the header file include/wmix.h.
+See also WMI Extension Events on page B-58.
+
+
+WMI Extension Commands
+
+
+GPIO_INPUT_GET
+    Read GPIO pins configured for input
+
+GPIO_INTR_ACK
+    Acknowledge and re-arm GPIO interrupts reported earlier
+
+GPIO_OUTPUT_SET
+    Manage output on GPIO pins configured for output
+
+GPIO_REGISTER_GET
+    Read an arbitrary GPIO register
+
+GPIO_REGISTER_SET
+    Dynamically change GPIO configuration
+
+SET_LQTHRESHOLD
+    Set link quality thresholds; the sampling happens at every unicast
+    data frame Tx, if certain thresholds are met, and corresponding
+    events are sent to the host
+
+
+=====================================================================
+
+Name
+    GPIO_INPUT_GET
+
+Synopsis
+    Allows the host to read GPIO pins that are configured for input. The values read are
+    returned through a GPIO_DATA extension event.
+
+NOTE: Support for GPIO is optional.
+
+Command
+    N/A
+
+Command Parameters
+    None
+
+
+
+Reply Parameters
+    None
+
+
+Reset Value
+    None
+
+
+
+Restrictions
+    None
+
+=====================================================================
+
+
+Name
+    GPIO_INTR_ACK
+
+Synopsis
+    The host uses this command to acknowledge and to re-arm GPIO interrupts reported
+    through an earlier GPIO_INTR extension event. A single GPIO_INTR_ACK
+    command should be used to acknowledge all GPIO interrupts that the host knows to
+    be outstanding (if pending interrupts are not acknowledged through
+    GPIO_INTR_ACK, another GPIO_INTR extension event is raised).
+
+NOTE: Support for GPIO is optional.
+
+Command
+    N/A
+
+Command Parameters
+    UINT32    ack_mask
+        A mask of interrupting GPIO pins (e.g., ack_mask
+        bit [3] acknowledges an interrupt from the pin GPIO3).
+
+Command Values
+    None
+
+Reset Value
+    None
+
+Restrictions
+    The host should acknowledge only interrupts about which it was notified.
+
+
+=====================================================================
+
+Name
+    GPIO_OUTPUT_SET
+
+Synopsis
+    Manages output on GPIO pins configured for output.
+
+    Conflicts between set_mask and clear_mask or enable_mask and disable_mask result
+    in undefined behavior.
+
+NOTE: Support for GPIO is optional.
+
+Command
+    N/A
+
+Command Parameters
+    UINT32    set_mask
+        Specifies which pins should drive a 1 out
+    UINT32    clear_mask
+        Specifies which pins should drive a 0 out
+    UINT32    enable_mask
+        Specifies which pins should be enabled for output
+    UINT32    disable_mask
+        Specifies which pins should be disabled for output
+
+Command Values
+    None
+
+
+Reset Value
+    None
+
+
+Restrictions
+    None
+
+
+
+=====================================================================
+
+
+Name
+    GPIO_REGISTER_GET
+
+Synopsis
+    Allows the host to read an arbitrary GPIO register. It is intended for use during
+    bringup/debug. The target responds to this command with a GPIO_DATA event.
+
+NOTE: Support for GPIO is optional.
+
+Command
+    N/A
+
+Command Parameters
+    UINT32
+    gpioreg_id
+    Specifies a GPIO register identifier, as defined
+in include/AR6000/AR6000_gpio.h
+
+Reply Parameters
+    None
+
+Reset Value
+    N/A
+
+Restrictions
+    None
+
+
+=====================================================================
+
+Name
+    GPIO_REGISTER_SET
+
+Synopsis
+    Allows the host to dynamically change GPIO configuration (usually handled
+    statically through the GPIO configuration DataSet).
+
+NOTE: Support for GPIO is optional.
+
+Command
+    N/A
+
+Command Parameters
+    UINT32    gpioreg_id
+        Specifies a GPIO register identifier, as defined in
+        include/AR6000/AR6000_gpio.h
+    UINT32    value
+        Specifies a value to write to the specified
+        GPIO register
+
+Command Values
+    None
+
+
+Reset Value
+    Initial hardware configuration is as defined in the AR6001 or AR6002 ROCmTM
+    Single-Chip MAC/BB/Radio for 2.4/5 GHz Embedded WLAN Applications data sheet. This
+    configuration is modified by the GPIO Configuration DataSet, if one exists.
+
+Restrictions
+    None
+
+
+=====================================================================
+
+
+Name
+    SET_LQTHRESHOLD
+
+Synopsis
+    Set link quality thresholds, the sampling happens at every unicast data frame Tx, if
+    certain threshold is met, corresponding event will be sent to host.
+
+Command
+    wmiconfig eth1 --lqThreshold <enable> <upper_threshold_1>...
+    <upper_threshold_4> <lower_threshold_1>... <lower_threshold_4>
+
+Command Parameters
+    A_UINT8   enable;
+    A_UINT8   thresholdAbove1_Val;
+    A_UINT8   thresholdAbove2_Val;
+    A_UINT8   thresholdAbove3_Val;
+    A_UINT8   thresholdAbove4_Val;
+    A_UINT8   thresholdBelow1_Val;
+    A_UINT8   thresholdBelow2_Val;
+    A_UINT8   thresholdBelow3_Val;
+    A_UINT8   thresholdBelow4_Val;
+
+Command Values
+    enable
+    = 0
+    Disable link quality sampling
+
+        = 1
+    Enable link quality sampling
+
+
+    thresholdAbove_Val
+    [1...4]
+    Above thresholds (value in [0,100]), in ascending
+    order threshold
+
+    Below_Val [1...4] = below thresholds (value
+    in [0,100]), in ascending order
+
+Reset Values
+    None
+
+Restrictions
+    None
+
+=====================================================================
+WMI Extension Events
+
+The WMI EXTENSION event is used for a collection of events that:
+
+    Are not generic wireless events
+    May be implementation-specific
+    May be target platform-specific
+    May be optional for a host implementation
+
+    An extension event is sent from the AR6000 device targets to the host just like
+any other WMI event message, using the WMI_EXTENSION_EVENTID. The
+first field of the payload for this EXTENSION event is another commandId
+(sometimes called the subcommandId) that indicates which EXTENSION
+event is being used. A subcommandId-specific payload follows the
+subcommandId.
+
+All extensions (subcommandIds) are listed in the header file include/wmix.h.
+See also WMI Extension Commands on page B-55.
+
+
+WMI Extension Events
+
+
+GPIO_ACK
+    Acknowledges a host set command has been processed by the device
+
+GPIO_DATA
+    Response to a hosts request for data
+
+GPIO_INTR
+    Signals that GPIO interrupts are pending
+
+
+=====================================================================
+
+Name
+    GPIO_ACK
+
+Synopsis
+    Acknowledges that a host set command (either GPIO_OUTPUT_SET or
+    GPIO_REGISTER_SET) has been processed by the AR6000 device.
+
+NOTE: Support for GPIO is optional.
+
+Event ID
+    N/A
+
+Event Parameters
+    None
+
+
+Event Values
+    None
+
+=====================================================================
+
+
+Name
+    GPIO_DATA
+
+Synopsis
+    The AR6000 device uses this event to respond to the hosts earlier request for data
+    (through either a GPIO_REGISTER_GET or a GPIO_INPUT_GET command).
+
+NOTE: Support for GPIO is optional.
+
+Event ID
+    N/A
+
+Event Parameters
+    UINT32    value
+        Holds the data of interest, which is either a register value
+        (in the case of GPIO_REGISTER_GET) or a mask of
+        pin inputs (in the case of GPIO_INPUT_GET).
+    UINT32    reg_id
+        Indicates which register was read (in the case of
+        GPIO_REGISTER_GET) or is GPIO_ID_NONE (in the
+        case of GPIO_INPUT_GET)
+
+Event Values
+    None
+
+
+=====================================================================
+
+
+
+Name
+    GPIO_INTR
+
+Synopsis
+    The AR6000 device raises this event to signal that GPIO interrupts are pending.
+    These GPIOs may be interrupts that occurred after the last GPIO_INTR_ACK
+    command was issued, or may be GPIO interrupts that the host failed to acknowledge
+    in the last GPIO_INTR_ACK. The AR6000 will not raise another GPIO_INTR
+    event until this event is acknowledged through a GPIO_INTR_ACK command.
+
+NOTE: Support for GPIO is optional.
+
+Event ID
+    N/A
+
+Event Parameters
+    UINT32    intr_mask
+        Indicates which GPIO interrupts are currently pending
+
+    UINT32    input_values
+        A recent copy of the GPIO input values, taken at the
+        time the most recent GPIO interrupt was processed
+
+Event Values
+    None
+
+
+
+=====================================================================
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/ar6000/wmi/wmi_host.h linux-2.6.29-rc3.owrt.om/drivers/ar6000/wmi/wmi_host.h
--- linux-2.6.29-rc3.owrt/drivers/ar6000/wmi/wmi_host.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/ar6000/wmi/wmi_host.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,71 @@
+#ifndef _WMI_HOST_H_
+#define _WMI_HOST_H_
+/*
+ * Copyright (c) 2004-2006 Atheros Communications Inc.
+ * All rights reserved.
+ *
+ * This file contains local definitios for the wmi host module.
+ *
+ * $Id: //depot/sw/releases/olca2.0-GPL/host/wmi/wmi_host.h#1 $
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation;
+ *
+ *  Software distributed under the License is distributed on an "AS
+ *  IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+ *  implied. See the License for the specific language governing
+ *  rights and limitations under the License.
+ *
+ *
+ *
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct wmi_stats {
+    A_UINT32    cmd_len_err;
+    A_UINT32    cmd_id_err;
+};
+
+struct wmi_t {
+    A_BOOL                          wmi_ready;
+    A_BOOL                          wmi_numQoSStream;
+    A_UINT8                         wmi_wmiStream2AcMapping[WMI_PRI_MAX_COUNT];
+    WMI_PRI_STREAM_ID               wmi_ac2WmiStreamMapping[WMM_NUM_AC];
+    A_UINT16                        wmi_streamExistsForAC[WMM_NUM_AC];
+    A_UINT8                         wmi_fatPipeExists;
+    void                           *wmi_devt;
+    struct wmi_stats                wmi_stats;
+    struct ieee80211_node_table     wmi_scan_table;
+    A_UINT8                         wmi_bssid[ATH_MAC_LEN];
+    A_UINT8                         wmi_powerMode;
+    A_UINT8                         wmi_phyMode;
+    A_UINT8                         wmi_keepaliveInterval;
+    A_MUTEX_T                       wmi_lock;
+};
+
+#define WMI_INIT_WMISTREAM_AC_MAP(w) \
+{  (w)->wmi_wmiStream2AcMapping[WMI_BEST_EFFORT_PRI] = WMM_AC_BE; \
+   (w)->wmi_wmiStream2AcMapping[WMI_LOW_PRI] = WMM_AC_BK; \
+   (w)->wmi_wmiStream2AcMapping[WMI_HIGH_PRI] = WMM_AC_VI; \
+   (w)->wmi_wmiStream2AcMapping[WMI_HIGHEST_PRI] = WMM_AC_VO; \
+   (w)->wmi_ac2WmiStreamMapping[WMM_AC_BE] = WMI_BEST_EFFORT_PRI; \
+   (w)->wmi_ac2WmiStreamMapping[WMM_AC_BK] = WMI_LOW_PRI; \
+   (w)->wmi_ac2WmiStreamMapping[WMM_AC_VI] = WMI_HIGH_PRI; \
+   (w)->wmi_ac2WmiStreamMapping[WMM_AC_VO] = WMI_HIGHEST_PRI; }
+
+#define WMI_WMISTREAM_ACCESSCATEGORY(w,s)      (w)->wmi_wmiStream2AcMapping[s]
+#define WMI_ACCESSCATEGORY_WMISTREAM(w,ac)       (w)->wmi_ac2WmiStreamMapping[ac]
+
+#define LOCK_WMI(w)     A_MUTEX_LOCK(&(w)->wmi_lock);
+#define UNLOCK_WMI(w)   A_MUTEX_UNLOCK(&(w)->wmi_lock);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _WMI_HOST_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/base/bus.c linux-2.6.29-rc3.owrt.om/drivers/base/bus.c
--- linux-2.6.29-rc3.owrt/drivers/base/bus.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/base/bus.c	2009-05-10 22:27:59.000000000 +0200
@@ -141,6 +141,29 @@
 }
 EXPORT_SYMBOL_GPL(bus_remove_file);
 
+int bus_create_device_link(struct bus_type *bus, struct kobject *target,
+			   const char *name)
+{
+	int error;
+	if (bus_get(bus)) {
+		error = sysfs_create_link(&bus->p->devices_kset->kobj, target,
+					  name);
+		bus_put(bus);
+	} else
+		error = -EINVAL;
+	return error;
+}
+EXPORT_SYMBOL_GPL(bus_create_device_link);
+
+void bus_remove_device_link(struct bus_type *bus, const char *name)
+{
+	if (bus_get(bus)) {
+		sysfs_remove_link(&bus->p->devices_kset->kobj, name);
+		bus_put(bus);
+	}
+}
+EXPORT_SYMBOL_GPL(bus_remove_device_link);
+
 static struct kobj_type bus_ktype = {
 	.sysfs_ops	= &bus_sysfs_ops,
 };
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/base/core.c linux-2.6.29-rc3.owrt.om/drivers/base/core.c
--- linux-2.6.29-rc3.owrt/drivers/base/core.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/base/core.c	2009-05-10 22:27:59.000000000 +0200
@@ -55,6 +55,11 @@
  */
 const char *dev_driver_string(const struct device *dev)
 {
+	if (!dev) {
+		printk(KERN_ERR"Null dev to dev_driver_string\n");
+		dump_stack();
+		return "*NULL*";
+	}
 	return dev->driver ? dev->driver->name :
 			(dev->bus ? dev->bus->name :
 			(dev->class ? dev->class->name : ""));
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/base/power/main.c linux-2.6.29-rc3.owrt.om/drivers/base/power/main.c
--- linux-2.6.29-rc3.owrt/drivers/base/power/main.c	2009-05-10 22:08:41.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/base/power/main.c	2009-05-10 22:27:59.000000000 +0200
@@ -69,9 +69,9 @@
  */
 void device_pm_add(struct device *dev)
 {
-	pr_debug("PM: Adding info for %s:%s\n",
+	/* pr_debug("PM: Adding info for %s:%s\n",
 		 dev->bus ? dev->bus->name : "No Bus",
-		 kobject_name(&dev->kobj));
+		 kobject_name(&dev->kobj)); */
 	mutex_lock(&dpm_list_mtx);
 	if (dev->parent) {
 		if (dev->parent->power.status >= DPM_SUSPENDING)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/char/Kconfig linux-2.6.29-rc3.owrt.om/drivers/char/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/char/Kconfig	2009-05-10 22:08:42.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/char/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -66,6 +66,18 @@
 
 	  If unsure, say Y.
 
+config NR_TTY_DEVICES
+	int "Maximum tty device number"
+	depends on VT
+	default 63
+	---help---
+	  This is the highest numbered device created in /dev. You will actually have
+	  NR_TTY_DEVICES+1 devices in /dev. The default is 63, which will result in
+	  64 /dev entries. The lowest number you can set is 11, anything below that, 
+	  and it will default to 11. 63 is also the upper limit so we don't overrun
+	  the serial consoles.
+
+
 config HW_CONSOLE
 	bool
 	depends on VT && !S390 && !UML
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/gpio/gpiolib.c linux-2.6.29-rc3.owrt.om/drivers/gpio/gpiolib.c
--- linux-2.6.29-rc3.owrt/drivers/gpio/gpiolib.c	2009-05-10 22:08:42.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/gpio/gpiolib.c	2009-05-10 22:27:59.000000000 +0200
@@ -6,8 +6,7 @@
 #include <linux/err.h>
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
-#include <linux/gpio.h>
-
+#include <mach/gpio.h>
 
 /* Optional implementation infrastructure for GPIO interfaces.
  *
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/busses/i2c-s3c2410.c linux-2.6.29-rc3.owrt.om/drivers/i2c/busses/i2c-s3c2410.c
--- linux-2.6.29-rc3.owrt/drivers/i2c/busses/i2c-s3c2410.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/busses/i2c-s3c2410.c	2009-05-10 22:27:59.000000000 +0200
@@ -34,9 +34,9 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/cpufreq.h>
+#include <linux/io.h>
 
 #include <asm/irq.h>
-#include <asm/io.h>
 
 #include <plat/regs-iic.h>
 #include <plat/iic.h>
@@ -135,6 +135,14 @@
 	unsigned long tmp;
 
 	tmp = readl(i2c->regs + S3C2410_IICCON);
+
+/* S3c2442 datasheet
+ *
+ * If the IICCON[5]=0, IICCON[4] does not operate correctly.
+ * So, It is recommended that you should set IICCON[5]=1,
+ * although you does not use the IIC interrupt.
+ */
+
 	writel(tmp & ~S3C2410_IICCON_IRQEN, i2c->regs + S3C2410_IICCON);
 }
 
@@ -480,6 +488,15 @@
 	if (i2c->suspended)
 		return -EIO;
 
+	if (i2c->suspended) {
+		dev_err(i2c->dev,
+		    "Hey I am still asleep (suspended: %d), retry later\n",
+		    i2c->suspended);
+		dump_stack();
+		ret = -EAGAIN;
+		goto out;
+	}
+
 	ret = s3c24xx_i2c_set_master(i2c);
 	if (ret != 0) {
 		dev_err(i2c->dev, "cannot get bus (error %d)\n", ret);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/busses/Kconfig linux-2.6.29-rc3.owrt.om/drivers/i2c/busses/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/i2c/busses/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/busses/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -455,11 +455,12 @@
 	  I2C bus.
 
 config I2C_S3C2410
-	tristate "S3C2410 I2C Driver"
-	depends on ARCH_S3C2410
+	tristate "Samsung SoC I2C Driver (S3C24XX and S3C64XX series)"
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
 	help
 	  Say Y here to include support for I2C controller in the
-	  Samsung S3C2410 based System-on-Chip devices.
+	  Samsung S3C based System-on-Chip devices such as the S3C2410,
+	  S3C2440, S3C2442, S3C2443 and S3C6410.
 
 config I2C_SH7760
 	tristate "Renesas SH7760 I2C Controller"
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/Kconfig linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -16,6 +16,53 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called ds1682.
 
+config AT24
+	tristate "EEPROMs from most vendors"
+	depends on SYSFS && EXPERIMENTAL
+	help
+	  Enable this driver to get read/write support to most I2C EEPROMs,
+	  after you configure the driver to know about each EEPROM on
+	  your target board.  Use these generic chip names, instead of
+	  vendor-specific ones like at24c64 or 24lc02:
+
+	     24c00, 24c01, 24c02, spd (readonly 24c02), 24c04, 24c08,
+	     24c16, 24c32, 24c64, 24c128, 24c256, 24c512, 24c1024
+
+	  Unless you like data loss puzzles, always be sure that any chip
+	  you configure as a 24c32 (32 kbit) or larger is NOT really a
+	  24c16 (16 kbit) or smaller, and vice versa. Marking the chip
+	  as read-only won't help recover from this. Also, if your chip
+	  has any software write-protect mechanism you may want to review the
+	  code to make sure this driver won't turn it on by accident.
+
+	  If you use this with an SMBus adapter instead of an I2C adapter,
+	  full functionality is not available.  Only smaller devices are
+	  supported (24c16 and below, max 4 kByte).
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called at24.
+
+config SENSORS_EEPROM
+	tristate "EEPROM reader"
+	depends on EXPERIMENTAL
+	help
+	  If you say yes here you get read-only access to the EEPROM data
+	  available on modern memory DIMMs and Sony Vaio laptops.  Such
+	  EEPROMs could theoretically be available on other devices as well.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called eeprom.
+
+config SENSORS_PCF50606
+	tristate "Philips/NXP PCF50606"
+	depends on I2C
+	help
+	  If you say yes here you get support for Philips/NXP PCF50606
+	  PMU (Power Management Unit) chips.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called pcf50606.
+
 config SENSORS_PCF8574
 	tristate "Philips PCF8574 and PCF8574A (DEPRECATED)"
 	depends on EXPERIMENTAL && GPIO_PCF857X = "n"
@@ -102,4 +149,14 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called tsl2550.
 
+config PCA9632
+	tristate "Philips/NXP PCA9632 low power LED driver"
+	depends on I2C
+	help
+	  If you say yes here you get support for the Philips/NXP PCA9632
+	  LED driver.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called pca9632.
+
 endmenu
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/Makefile linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/Makefile
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -13,10 +13,12 @@
 obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_SENSORS_MAX6875)	+= max6875.o
 obj-$(CONFIG_SENSORS_PCA9539)	+= pca9539.o
+obj-$(CONFIG_SENSORS_PCF50606)	+= pcf50606.o
 obj-$(CONFIG_SENSORS_PCF8574)	+= pcf8574.o
 obj-$(CONFIG_PCF8575)		+= pcf8575.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_SENSORS_TSL2550)	+= tsl2550.o
+obj-$(CONFIG_PCA9632)		+= pca9632.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/pca9632.c linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pca9632.c
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/pca9632.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pca9632.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,551 @@
+/*
+ *  Philips/NXP PCA9632 low power LED driver.
+ *  Copyright (C) 2008 Matt Hsu <matt_hsu@openmoko.org>
+ *
+ *  low_level implementation are based on pcf50606 driver
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  TODO:
+ *  - attach ledclass??
+ *  - add platform data
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+
+#include "pca9632.h"
+
+/* Addresses to scan */
+static unsigned short normal_i2c[] = { 0x62, I2C_CLIENT_END };
+
+/* Insmod parameters */
+I2C_CLIENT_INSMOD_1(pca9632);
+
+enum pca9632_pwr_state {
+	PCA9632_NORMAL,
+	PCA9632_SLEEP,
+};
+
+enum pca9632_led_output {
+	PCA9632_OFF,
+	PCA9632_ON,
+	PCA9632_CTRL_BY_PWM,
+	PCA9632_CTRL_BY_PWM_GRPPWM,
+};
+
+static const char *led_output_name[] = {
+	[PCA9632_OFF]  			= "off",
+	[PCA9632_ON]			= "fully-on",
+	[PCA9632_CTRL_BY_PWM] 		= "ctrl-by-pwm",
+	[PCA9632_CTRL_BY_PWM_GRPPWM] 	= "ctrl-by-pwm-grppwm",
+};
+
+struct pca9632_data {
+	struct i2c_client client;
+	struct mutex lock;
+};
+
+static struct i2c_driver pca9632_driver;
+static struct platform_device *pca9632_pdev;
+
+static int pca9632_attach_adapter(struct i2c_adapter *adapter);
+static int pca9632_detach_client(struct i2c_client *client);
+
+static int __reg_write(struct pca9632_data *pca, u_int8_t reg, u_int8_t val)
+{
+	return i2c_smbus_write_byte_data(&pca->client, reg, val);
+}
+
+static int reg_write(struct pca9632_data *pca, u_int8_t reg, u_int8_t val)
+{
+	int ret;
+
+	mutex_lock(&pca->lock);
+	ret = __reg_write(pca, reg, val);
+	mutex_unlock(&pca->lock);
+
+	return ret;
+}
+
+static int32_t __reg_read(struct pca9632_data *pca, u_int8_t reg)
+{
+	int32_t ret;
+
+	ret = i2c_smbus_read_byte_data(&pca->client, reg);
+
+	return ret;
+}
+
+static u_int8_t reg_read(struct pca9632_data *pca, u_int8_t reg)
+{
+	int32_t ret;
+
+	mutex_lock(&pca->lock);
+	ret = __reg_read(pca, reg);
+	mutex_unlock(&pca->lock);
+
+	return ret & 0xff;
+}
+
+static int reg_set_bit_mask(struct pca9632_data *pca,
+			    u_int8_t reg, u_int8_t mask, u_int8_t val)
+{
+	int ret;
+	u_int8_t tmp;
+
+	val &= mask;
+
+	mutex_lock(&pca->lock);
+
+	tmp = __reg_read(pca, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	ret = __reg_write(pca, reg, tmp);
+
+	mutex_unlock(&pca->lock);
+
+	return ret;
+}
+
+static inline int calc_dc(uint8_t idc)
+{
+	return (idc * 100) / 256;
+}
+
+/*
+ * Software reset
+ */
+static int software_rst(struct i2c_adapter *adapter)
+{
+	u8 buf[] = { 0xa5, 0x5a };
+
+	struct i2c_msg msg[] = {
+		{
+			.addr = 0x3,
+			.flags = 0,
+			.buf = &buf,
+			.len = sizeof(buf)
+		}
+	};
+
+	return i2c_transfer(adapter, msg, 1);
+}
+
+/*
+ * Group dmblnk control
+ */
+static void config_group_dmblnk(struct pca9632_data *pca, int group_dmblnk_mode)
+{
+	reg_set_bit_mask(pca, PCA9632_REG_MODE2, 0x20,
+			group_dmblnk_mode << PCA9632_DMBLNK_SHIFT);
+}
+
+static int get_group_dmblnk(struct pca9632_data *pca)
+{
+	return reg_read(pca, PCA9632_REG_MODE2) >> PCA9632_DMBLNK_SHIFT;
+}
+
+static ssize_t show_group_dmblnk(struct device *dev, struct device_attribute
+					*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+
+	if (get_group_dmblnk(pca))
+		return sprintf(buf, "blinking\n");
+	else
+		return sprintf(buf, "dimming\n");
+}
+
+static ssize_t set_group_dmblnk(struct device *dev, struct device_attribute
+					*attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+	unsigned int mode = simple_strtoul(buf, NULL, 10);
+
+	if (mode)
+		dev_info(&pca->client.dev, "blinking\n");
+	else
+		dev_info(&pca->client.dev, "dimming\n");
+
+	config_group_dmblnk(pca, mode);
+
+	return count;
+}
+
+static DEVICE_ATTR(group_dmblnk, S_IRUGO | S_IWUSR, show_group_dmblnk,
+							set_group_dmblnk);
+
+static int reg_id_by_name(const char *name)
+{
+	int reg_id = -1;
+
+	if (!strncmp(name, "led0", 4))
+		reg_id = PCA9632_REG_PWM0;
+	else if (!strncmp(name, "led1", 4))
+		reg_id = PCA9632_REG_PWM1;
+	else if (!strncmp(name, "led2", 4))
+		reg_id = PCA9632_REG_PWM2;
+	else if (!strncmp(name, "led3", 4))
+		reg_id = PCA9632_REG_PWM3;
+
+	return reg_id;
+}
+
+static int get_led_output(struct pca9632_data *pca, int ldrx)
+{
+	u_int8_t led_state;
+
+	ldrx = ldrx - 2;
+	led_state = reg_read(pca, PCA9632_REG_LEDOUT);
+	led_state = (led_state >> (2 * ldrx)) & 0x03;
+
+	return led_state;
+}
+
+static void config_led_output(struct pca9632_data *pca, int ldrx,
+					enum pca9632_led_output led_output)
+{
+	u_int8_t mask;
+	int tmp;
+
+	ldrx = ldrx - 2;
+	mask = 0x03 << (2 * ldrx);
+	tmp = reg_set_bit_mask(pca, PCA9632_REG_LEDOUT,
+					mask, led_output << (2 * ldrx));
+}
+
+/*
+ * Individual brightness control
+ */
+static ssize_t show_brightness(struct device *dev, struct device_attribute
+					*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+	int ldrx;
+
+	ldrx = reg_id_by_name(attr->attr.name);
+
+	switch (get_led_output(pca, ldrx)) {
+
+	case PCA9632_OFF:
+	case PCA9632_ON:
+		return sprintf(buf, "%s",
+			led_output_name[get_led_output(pca, ldrx)]);
+
+	case PCA9632_CTRL_BY_PWM:
+		return sprintf(buf, "%d%% \n", calc_dc(reg_read(pca, ldrx)));
+
+	case PCA9632_CTRL_BY_PWM_GRPPWM:
+		/* check group dmblnk */
+		if (get_group_dmblnk(pca))
+			return sprintf(buf, "%d%% \n",
+				calc_dc(reg_read(pca, ldrx)));
+		return sprintf(buf, "%d%% \n",
+					 calc_dc((reg_read(pca, ldrx) & 0xfc)));
+	default:
+		break;
+	}
+
+	return sprintf(buf, "invalid argument\n");
+}
+
+static ssize_t set_brightness(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+	unsigned int pwm = simple_strtoul(buf, NULL, 10);
+	int ldrx;
+
+	ldrx = reg_id_by_name(attr->attr.name);
+	reg_set_bit_mask(pca, ldrx, 0xff, pwm);
+
+	return count;
+}
+
+static
+DEVICE_ATTR(led0_pwm, S_IRUGO | S_IWUSR, show_brightness, set_brightness);
+static
+DEVICE_ATTR(led1_pwm, S_IRUGO | S_IWUSR, show_brightness, set_brightness);
+static
+DEVICE_ATTR(led2_pwm, S_IRUGO | S_IWUSR, show_brightness, set_brightness);
+static
+DEVICE_ATTR(led3_pwm, S_IRUGO | S_IWUSR, show_brightness, set_brightness);
+
+/*
+ * Group frequency control
+ */
+static ssize_t show_group_freq(struct device *dev, struct device_attribute
+				*attr, char *buf)
+{
+	uint32_t period;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+
+	period = ((reg_read(pca, PCA9632_REG_GRPFREQ) + 1) * 1000) / 24;
+
+	return sprintf(buf, "%d ms\n", period);
+}
+
+static ssize_t set_group_freq(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+
+	unsigned int freq = simple_strtoul(buf, NULL, 10);
+	reg_write(pca, PCA9632_REG_GRPFREQ, freq);
+	return count;
+}
+
+static
+DEVICE_ATTR(group_freq, S_IRUGO | S_IWUSR, show_group_freq, set_group_freq);
+
+/*
+ * Group duty cycle tonrol*
+ */
+static ssize_t show_group_dc(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+
+	if (get_group_dmblnk(pca)) {
+
+		if (reg_read(pca, PCA9632_REG_GRPFREQ) <= 0x03)
+			return sprintf(buf, "%d%% \n",
+			     calc_dc(reg_read(pca, PCA9632_REG_GRPPWM) & 0xfc));
+
+		return sprintf(buf, "%d%% \n", calc_dc(reg_read(pca,
+							  PCA9632_REG_GRPPWM)));
+	}
+
+	return sprintf(buf, "%d%% \n", calc_dc(reg_read(pca,
+						   PCA9632_REG_GRPPWM) & 0xf0));
+}
+
+static ssize_t set_group_dc(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+
+	unsigned int dc = simple_strtoul(buf, NULL, 10);
+
+	reg_set_bit_mask(pca, PCA9632_REG_GRPPWM, 0xff, dc);
+
+	return count;
+}
+
+static DEVICE_ATTR(group_dc, S_IRUGO | S_IWUSR, show_group_dc, set_group_dc);
+
+/*
+ * LED driver output
+ */
+static ssize_t show_led_output(struct device *dev, struct device_attribute
+					*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+	int ldrx;
+
+	ldrx = reg_id_by_name(attr->attr.name);
+
+	return sprintf(buf, "%s \n",
+				    led_output_name[get_led_output(pca, ldrx)]);
+
+}
+static ssize_t set_led_output(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pca9632_data *pca = i2c_get_clientdata(client);
+	enum pca9632_led_output led_output;
+	int ldrx;
+
+	led_output = simple_strtoul(buf, NULL, 10);
+	ldrx = reg_id_by_name(attr->attr.name);
+	config_led_output(pca, ldrx, led_output);
+
+	return count;
+}
+
+static
+DEVICE_ATTR(led0_output, S_IRUGO | S_IWUSR, show_led_output, set_led_output);
+static
+DEVICE_ATTR(led1_output, S_IRUGO | S_IWUSR, show_led_output, set_led_output);
+static
+DEVICE_ATTR(led2_output, S_IRUGO | S_IWUSR, show_led_output, set_led_output);
+static
+DEVICE_ATTR(led3_output, S_IRUGO | S_IWUSR, show_led_output, set_led_output);
+
+static struct attribute *pca_sysfs_entries[] = {
+	&dev_attr_group_dmblnk.attr,
+	&dev_attr_led0_pwm.attr,
+	&dev_attr_led1_pwm.attr,
+	&dev_attr_led2_pwm.attr,
+	&dev_attr_led3_pwm.attr,
+	&dev_attr_group_dc.attr,
+	&dev_attr_group_freq.attr,
+	&dev_attr_led0_output.attr,
+	&dev_attr_led1_output.attr,
+	&dev_attr_led2_output.attr,
+	&dev_attr_led3_output.attr,
+	NULL
+};
+
+static struct attribute_group pca_attr_group = {
+	.name	= NULL,			/* put in device directory */
+	.attrs	= pca_sysfs_entries,
+};
+
+#ifdef CONFIG_PM
+static int pca9632_suspend(struct device *dev, pm_message_t state)
+{
+	/* FIXME: Not implemented */
+	return 0;
+}
+
+static int pca9632_resume(struct device *dev)
+{
+	/* FIXME: Not implemented */
+	return 0;
+}
+#else
+#define pca9632_suspend NULL
+#define pca9632_resume NULL
+#endif
+
+static struct i2c_driver pca9632_driver = {
+	.driver = {
+		.name	 = "pca9632",
+		.suspend = pca9632_suspend,
+		.resume	 = pca9632_resume,
+	},
+	.id		= I2C_DRIVERID_PCA9632,
+	.attach_adapter	= pca9632_attach_adapter,
+	.detach_client	= pca9632_detach_client,
+};
+
+static int pca9632_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct pca9632_data *pca;
+	int err;
+
+	pca = kzalloc(sizeof(struct pca9632_data), GFP_KERNEL);
+	if (!pca)
+		return -ENOMEM;
+
+	mutex_init(&pca->lock);
+
+	new_client = &pca->client;
+	i2c_set_clientdata(new_client, pca);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &pca9632_driver;
+	new_client->flags = 0;
+
+	strlcpy(new_client->name, "pca9632", I2C_NAME_SIZE);
+
+	/* register with i2c core */
+	err = i2c_attach_client(new_client);
+	if (err)
+		goto exit_kfree;
+
+	err = sysfs_create_group(&new_client->dev.kobj, &pca_attr_group);
+	if (err)
+		goto exit_detach;
+
+	/* software reset */
+	if (!software_rst(adapter))
+		dev_info(&pca->client.dev, "pca9632 sw-rst done\n");
+
+	/* enter normal mode */
+	reg_set_bit_mask(pca, PCA9632_REG_MODE1, 0x10, PCA9632_NORMAL);
+
+	return 0;
+
+exit_detach:
+	i2c_detach_client(new_client);
+exit_kfree:
+	kfree(pca);
+
+	return err;
+}
+
+static int pca9632_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, pca9632_detect);
+}
+
+static int pca9632_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	sysfs_remove_group(&client->dev.kobj, &pca_attr_group);
+	err = i2c_detach_client(client);
+
+	if (err)
+		return err;
+
+	kfree(i2c_get_clientdata(client));
+
+	return 0;
+}
+
+static int __init pca9632_plat_probe(struct platform_device *pdev)
+{
+	/* FIXME: platform data should be attached here */
+	pca9632_pdev = pdev;
+
+	return 0;
+}
+
+static int pca9632_plat_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver pca9632_plat_driver = {
+	.probe	= pca9632_plat_probe,
+	.remove	= pca9632_plat_remove,
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name 	= "pca9632",
+	},
+};
+
+static int __init pca9632_init(void)
+{
+	int rc;
+
+	rc = platform_driver_register(&pca9632_plat_driver);
+	if (!rc)
+		i2c_add_driver(&pca9632_driver);
+
+	return rc;
+}
+
+static void __exit pca9632_exit(void)
+{
+	i2c_del_driver(&pca9632_driver);
+
+	platform_driver_unregister(&pca9632_plat_driver);
+}
+
+MODULE_AUTHOR("Matt Hsu <matt_hsu@openmoko.org>");
+MODULE_DESCRIPTION("NXP PCA9632 driver");
+MODULE_LICENSE("GPL");
+
+module_init(pca9632_init);
+module_exit(pca9632_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/pca9632.h linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pca9632.h
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/pca9632.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pca9632.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,24 @@
+#ifndef _PCA9632_H
+#define _PCA9632_H
+
+
+enum pca9632_regs{
+
+	PCA9632_REG_MODE1 	= 0x00,
+	PCA9632_REG_MODE2 	= 0x01,
+	PCA9632_REG_PWM0 	= 0x02,
+	PCA9632_REG_PWM1 	= 0x03,
+	PCA9632_REG_PWM2 	= 0x04,
+	PCA9632_REG_PWM3 	= 0x05,
+	PCA9632_REG_GRPPWM 	= 0x06,
+	PCA9632_REG_GRPFREQ 	= 0x07,
+	PCA9632_REG_LEDOUT 	= 0x08,
+	PCA9632_REG_SUBADDR1 	= 0x09,
+	PCA9632_REG_SUBADDR2 	= 0x0a,
+	PCA9632_REG_SUBADDR3 	= 0x0b,
+	PCA9632_REG_ALLCALLADR1 = 0x0c,
+};
+
+#define PCA9632_DMBLNK_SHIFT 	5
+
+#endif /* _PCA9632_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/pcf50606.c linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pcf50606.c
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/pcf50606.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pcf50606.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,2193 @@
+/* Philips/NXP PCF50606 Power Management Unit (PMU) driver
+ *
+ * (C) 2006-2007 by Openmoko, Inc.
+ * Authors: Harald Welte <laforge@openmoko.org>,
+ *	    Matt Hsu <matt@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * This driver is a monster ;) It provides the following features
+ * - voltage control for a dozen different voltage domains
+ * - charging control for main and backup battery
+ * - rtc / alarm
+ * - watchdog
+ * - adc driver (hw_sensors like)
+ * - pwm driver
+ * - backlight
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/watchdog.h>
+#include <linux/miscdevice.h>
+#include <linux/input.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/sched.h>
+#include <linux/platform_device.h>
+#include <linux/pcf50606.h>
+#include <linux/apm-emulation.h>
+
+#include <asm/mach-types.h>
+#include <mach/gta01.h>
+
+#include "pcf50606.h"
+
+/* we use dev_dbg() throughout the code, but sometimes don't want to
+ * write an entire line of debug related information.  This DEBUGPC
+ * macro is a continuation for dev_dbg() */
+#ifdef DEBUG
+#define DEBUGPC(x, args ...) printk(x, ## args)
+#else
+#define DEBUGPC(x, args ...)
+#endif
+
+/***********************************************************************
+ * Static data / structures
+ ***********************************************************************/
+
+static unsigned short normal_i2c[] = { 0x08, I2C_CLIENT_END };
+
+I2C_CLIENT_INSMOD_1(pcf50606);
+
+#define PCF50606_B_CHG_FAST	0	/* Charger Fast allowed */
+#define PCF50606_B_CHG_PRESENT	1	/* Charger present */
+#define PCF50606_B_CHG_FOK	2	/* Fast OK for battery */
+#define PCF50606_B_CHG_ERR	3	/* Charger Error */
+#define PCF50606_B_CHG_PROT	4	/* Charger Protection */
+#define PCF50606_B_CHG_READY	5	/* Charging completed */
+
+#define PCF50606_F_CHG_FAST	(1<<PCF50606_B_CHG_FAST)
+#define PCF50606_F_CHG_PRESENT	(1<<PCF50606_B_CHG_PRESENT)
+#define PCF50606_F_CHG_FOK	(1<<PCF50606_B_CHG_FOK)
+#define PCF50606_F_CHG_ERR	(1<<PCF50606_B_CHG_ERR)
+#define PCF50606_F_CHG_PROT	(1<<PCF50606_B_CHG_PROT)
+#define PCF50606_F_CHG_READY	(1<<PCF50606_B_CHG_READY)
+#define PCF50606_F_CHG_MASK	0x000000fc
+
+#define PCF50606_F_PWR_PRESSED	0x00000100
+#define PCF50606_F_RTC_SECOND	0x00000200
+
+enum close_state {
+	CLOSE_STATE_NOT,
+	CLOSE_STATE_ALLOW = 0x2342,
+};
+
+enum pcf50606_suspend_states {
+	PCF50606_SS_RUNNING,
+	PCF50606_SS_STARTING_SUSPEND,
+	PCF50606_SS_COMPLETED_SUSPEND,
+	PCF50606_SS_RESUMING_BUT_NOT_US_YET,
+	PCF50606_SS_STARTING_RESUME,
+	PCF50606_SS_COMPLETED_RESUME,
+};
+
+struct pcf50606_data {
+	struct i2c_client client;
+	struct pcf50606_platform_data *pdata;
+	struct backlight_device *backlight;
+	struct mutex lock;
+	unsigned int flags;
+	unsigned int working;
+	struct mutex working_lock;
+	struct work_struct work;
+	struct rtc_device *rtc;
+	struct input_dev *input_dev;
+	int allow_close;
+	int onkey_seconds;
+	int irq;
+	int coldplug_done;
+	int suppress_onkey_events;
+	enum pcf50606_suspend_states suspend_state;
+#ifdef CONFIG_PM
+	struct {
+		u_int8_t dcdc1, dcdc2;
+		u_int8_t dcdec1;
+		u_int8_t dcudc1;
+		u_int8_t ioregc;
+		u_int8_t d1regc1;
+		u_int8_t d2regc1;
+		u_int8_t d3regc1;
+		u_int8_t lpregc1;
+		u_int8_t adcc1, adcc2;
+		u_int8_t pwmc1;
+		u_int8_t int1m, int2m, int3m;
+	} standby_regs;
+#endif
+};
+
+static struct i2c_driver pcf50606_driver;
+
+/* This is an ugly construct on how to access the (currently single/global)
+ * pcf50606 handle from other code in the kernel.  I didn't really come up with
+ * a more decent method of dynamically resolving this */
+struct pcf50606_data *pcf50606_global;
+EXPORT_SYMBOL_GPL(pcf50606_global);
+
+static struct platform_device *pcf50606_pdev;
+
+/* This is a 10k, B=3370 NTC Thermistor -10..79 centigrade */
+/* Table entries are offset by +0.5C so a properly rounded value is generated */
+static const u_int16_t ntc_table_10k_3370B[] = {
+	/* -10 */
+	43888, 41819, 39862, 38010, 36257, 34596, 33024, 31534, 30121, 28781,
+	27510, 26304, 25159, 24071, 23038, 22056, 21122, 20234, 19390, 18586,
+	17821, 17093, 16399, 15738, 15107, 14506, 13933, 13387, 12865, 12367,
+	11891, 11437, 11003, 10588, 10192, 9813, 9450, 9103, 8771, 8453,
+	8149, 7857, 7578, 7310, 7054, 6808, 6572, 6346, 6129, 5920,
+	5720, 5528, 5344, 5167, 4996, 4833, 4675, 4524, 4379, 4239,
+	4104, 3975, 3850, 3730, 3614, 3503, 3396, 3292, 3193, 3097,
+	3004, 2915, 2829, 2745, 2665, 2588, 2513, 2441, 2371, 2304,
+	2239, 2176, 2116, 2057, 2000, 1945, 1892, 1841, 1791, 1743,
+};
+
+
+/***********************************************************************
+ * Low-Level routines
+ ***********************************************************************/
+
+static inline int __reg_write(struct pcf50606_data *pcf, u_int8_t reg,
+			      u_int8_t val)
+{
+	if (pcf->suspend_state == PCF50606_SS_COMPLETED_SUSPEND) {
+		dev_err(&pcf->client.dev, "__reg_write while suspended.\n");
+		dump_stack();
+	}
+	return i2c_smbus_write_byte_data(&pcf->client, reg, val);
+}
+
+static int reg_write(struct pcf50606_data *pcf, u_int8_t reg, u_int8_t val)
+{
+	int ret;
+
+	mutex_lock(&pcf->lock);
+	ret = __reg_write(pcf, reg, val);
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+
+static inline int32_t __reg_read(struct pcf50606_data *pcf, u_int8_t reg)
+{
+	int32_t ret;
+
+	if (pcf->suspend_state == PCF50606_SS_COMPLETED_SUSPEND) {
+		dev_err(&pcf->client.dev, "__reg_read while suspended.\n");
+		dump_stack();
+	}
+	ret = i2c_smbus_read_byte_data(&pcf->client, reg);
+
+	return ret;
+}
+
+static u_int8_t reg_read(struct pcf50606_data *pcf, u_int8_t reg)
+{
+	int32_t ret;
+
+	mutex_lock(&pcf->lock);
+	ret = __reg_read(pcf, reg);
+	mutex_unlock(&pcf->lock);
+
+	return ret & 0xff;
+}
+
+static int reg_set_bit_mask(struct pcf50606_data *pcf,
+			    u_int8_t reg, u_int8_t mask, u_int8_t val)
+{
+	int ret;
+	u_int8_t tmp;
+
+	val &= mask;
+
+	mutex_lock(&pcf->lock);
+
+	tmp = __reg_read(pcf, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	ret = __reg_write(pcf, reg, tmp);
+
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+
+static int reg_clear_bits(struct pcf50606_data *pcf, u_int8_t reg, u_int8_t val)
+{
+	int ret;
+	u_int8_t tmp;
+
+	mutex_lock(&pcf->lock);
+
+	tmp = __reg_read(pcf, reg);
+	tmp &= ~val;
+	ret = __reg_write(pcf, reg, tmp);
+
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+
+/* synchronously read one ADC channel (busy-wait for result to be complete) */
+static u_int16_t adc_read(struct pcf50606_data *pcf,  int channel,
+			  u_int16_t *data2)
+{
+	u_int8_t adcs2, adcs1;
+	u_int16_t ret;
+
+	dev_dbg(&pcf->client.dev, "entering (pcf=%p, channel=%u, data2=%p)\n",
+		pcf, channel, data2);
+
+	channel &= PCF50606_ADCC2_ADCMUX_MASK;
+
+	mutex_lock(&pcf->lock);
+
+	/* start ADC conversion of selected channel */
+	__reg_write(pcf, PCF50606_REG_ADCC2, channel |
+		    PCF50606_ADCC2_ADCSTART | PCF50606_ADCC2_RES_10BIT);
+
+	do {
+		adcs2 = __reg_read(pcf, PCF50606_REG_ADCS2);
+	} while (!(adcs2 & PCF50606_ADCS2_ADCRDY));
+
+	adcs1 = __reg_read(pcf, PCF50606_REG_ADCS1);
+	ret = (adcs1 << 2) | (adcs2 & 0x03);
+
+	if (data2) {
+		adcs1 = __reg_read(pcf, PCF50606_REG_ADCS3);
+		*data2 = (adcs1 << 2) | ((adcs2 & 0x0c) >> 2);
+	}
+
+	mutex_unlock(&pcf->lock);
+
+	dev_dbg(&pcf->client.dev, "returning %u %u\n", ret,
+		data2 ? *data2 : 0);
+
+	return ret;
+}
+
+/***********************************************************************
+ * Voltage / ADC
+ ***********************************************************************/
+
+static u_int8_t dcudc_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	if (millivolts > 5500)
+		return 0x1f;
+	if (millivolts <= 3300) {
+		millivolts -= 900;
+		return millivolts/300;
+	}
+	if (millivolts < 4000)
+		return 0x0f;
+	else {
+		millivolts -= 4000;
+		return millivolts/100;
+	}
+}
+
+static unsigned int dcudc_2voltage(u_int8_t bits)
+{
+	bits &= 0x1f;
+	if (bits < 0x08)
+		return 900 + bits * 300;
+	else if (bits < 0x10)
+		return 3300;
+	else
+		return 4000 + bits * 100;
+}
+
+static u_int8_t dcdec_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	else if (millivolts > 3300)
+		return 0x0f;
+
+	millivolts -= 900;
+	return millivolts/300;
+}
+
+static unsigned int dcdec_2voltage(u_int8_t bits)
+{
+	bits &= 0x0f;
+	return 900 + bits*300;
+}
+
+static u_int8_t dcdc_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	else if (millivolts > 3600)
+		return 0x1f;
+
+	if (millivolts < 1500) {
+		millivolts -= 900;
+		return millivolts/25;
+	} else {
+		millivolts -= 1500;
+		return 0x18 + millivolts/300;
+	}
+}
+
+static unsigned int dcdc_2voltage(u_int8_t bits)
+{
+	bits &= 0x1f;
+	if ((bits & 0x18) == 0x18)
+		return 1500 + ((bits & 0x7) * 300);
+	else
+		return 900 + (bits * 25);
+}
+
+static u_int8_t dx_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	else if (millivolts > 3300)
+		return 0x18;
+
+	millivolts -= 900;
+	return millivolts/100;
+}
+
+static unsigned int dx_2voltage(u_int8_t bits)
+{
+	bits &= 0x1f;
+	return 900 + (bits * 100);
+}
+
+static const u_int8_t regulator_registers[__NUM_PCF50606_REGULATORS] = {
+	[PCF50606_REGULATOR_DCD]	= PCF50606_REG_DCDC1,
+	[PCF50606_REGULATOR_DCDE]	= PCF50606_REG_DCDEC1,
+	[PCF50606_REGULATOR_DCUD]	= PCF50606_REG_DCUDC1,
+	[PCF50606_REGULATOR_D1REG]	= PCF50606_REG_D1REGC1,
+	[PCF50606_REGULATOR_D2REG]	= PCF50606_REG_D2REGC1,
+	[PCF50606_REGULATOR_D3REG]	= PCF50606_REG_D3REGC1,
+	[PCF50606_REGULATOR_LPREG]	= PCF50606_REG_LPREGC1,
+	[PCF50606_REGULATOR_IOREG]	= PCF50606_REG_IOREGC,
+};
+
+int pcf50606_onoff_set(struct pcf50606_data *pcf,
+		       enum pcf50606_regulator_id reg, int on)
+{
+	u_int8_t addr;
+
+	if (reg >= __NUM_PCF50606_REGULATORS)
+		return -EINVAL;
+
+	/* IOREG cannot be powered off since it powers the PMU I2C */
+	if (reg == PCF50606_REGULATOR_IOREG)
+		return -EIO;
+
+	addr = regulator_registers[reg];
+
+	if (on == 0)
+		reg_set_bit_mask(pcf, addr, 0xe0, 0x00);
+	else
+		reg_set_bit_mask(pcf, addr, 0xe0, 0xe0);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pcf50606_onoff_set);
+
+int pcf50606_onoff_get(struct pcf50606_data *pcf,
+		       enum pcf50606_regulator_id reg)
+{
+	u_int8_t val, addr;
+
+	if (reg >= __NUM_PCF50606_REGULATORS)
+		return -EINVAL;
+
+	addr = regulator_registers[reg];
+	val = (reg_read(pcf, addr) & 0xe0) >> 5;
+
+	/* PWREN1 = 1, PWREN2 = 1, see table 16 of datasheet */
+	switch (val) {
+	case 0:
+	case 5:
+		return 0;
+	default:
+		return 1;
+	}
+}
+EXPORT_SYMBOL_GPL(pcf50606_onoff_get);
+
+int pcf50606_voltage_set(struct pcf50606_data *pcf,
+			 enum pcf50606_regulator_id reg,
+			 unsigned int millivolts)
+{
+	u_int8_t volt_bits;
+	u_int8_t regnr;
+	int rc;
+
+	dev_dbg(&pcf->client.dev, "pcf=%p, reg=%d, mvolts=%d\n", pcf, reg,
+		millivolts);
+
+	if (reg >= __NUM_PCF50606_REGULATORS)
+		return -EINVAL;
+
+	if (millivolts > pcf->pdata->rails[reg].voltage.max)
+		return -EINVAL;
+
+	switch (reg) {
+	case PCF50606_REGULATOR_DCD:
+		volt_bits = dcdc_voltage(millivolts);
+		rc = reg_set_bit_mask(pcf, PCF50606_REG_DCDC1, 0x1f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCDE:
+		volt_bits = dcdec_voltage(millivolts);
+		rc = reg_set_bit_mask(pcf, PCF50606_REG_DCDEC1, 0x0f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCUD:
+		volt_bits = dcudc_voltage(millivolts);
+		rc = reg_set_bit_mask(pcf, PCF50606_REG_DCUDC1, 0x1f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_D1REG:
+	case PCF50606_REGULATOR_D2REG:
+	case PCF50606_REGULATOR_D3REG:
+		regnr = PCF50606_REG_D1REGC1 + (reg - PCF50606_REGULATOR_D1REG);
+		volt_bits = dx_voltage(millivolts);
+		rc = reg_set_bit_mask(pcf, regnr, 0x1f, volt_bits);
+		break;
+	case PCF50606_REGULATOR_LPREG:
+		volt_bits = dx_voltage(millivolts);
+		rc = reg_set_bit_mask(pcf, PCF50606_REG_LPREGC1, 0x1f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_IOREG:
+		if (millivolts < 1800)
+			return -EINVAL;
+		volt_bits = dx_voltage(millivolts);
+		rc = reg_set_bit_mask(pcf, PCF50606_REG_IOREGC, 0x1f,
+				      volt_bits);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pcf50606_voltage_set);
+
+unsigned int pcf50606_voltage_get(struct pcf50606_data *pcf,
+			 enum pcf50606_regulator_id reg)
+{
+	u_int8_t volt_bits;
+	u_int8_t regnr;
+	unsigned int rc = 0;
+
+	if (reg >= __NUM_PCF50606_REGULATORS)
+		return -EINVAL;
+
+	switch (reg) {
+	case PCF50606_REGULATOR_DCD:
+		volt_bits = reg_read(pcf, PCF50606_REG_DCDC1) & 0x1f;
+		rc = dcdc_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCDE:
+		volt_bits = reg_read(pcf, PCF50606_REG_DCDEC1) & 0x0f;
+		rc = dcdec_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCUD:
+		volt_bits = reg_read(pcf, PCF50606_REG_DCUDC1) & 0x1f;
+		rc = dcudc_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_D1REG:
+	case PCF50606_REGULATOR_D2REG:
+	case PCF50606_REGULATOR_D3REG:
+		regnr = PCF50606_REG_D1REGC1 + (reg - PCF50606_REGULATOR_D1REG);
+		volt_bits = reg_read(pcf, regnr) & 0x1f;
+		if (volt_bits > 0x18)
+			volt_bits = 0x18;
+		rc = dx_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_LPREG:
+		volt_bits = reg_read(pcf, PCF50606_REG_LPREGC1) & 0x1f;
+		if (volt_bits > 0x18)
+			volt_bits = 0x18;
+		rc = dx_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_IOREG:
+		volt_bits = reg_read(pcf, PCF50606_REG_IOREGC) & 0x1f;
+		if (volt_bits > 0x18)
+			volt_bits = 0x18;
+		rc = dx_2voltage(volt_bits);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(pcf50606_voltage_get);
+
+/* go into 'STANDBY' mode, i.e. power off the main CPU and peripherals */
+void pcf50606_go_standby(void)
+{
+	reg_write(pcf50606_global, PCF50606_REG_OOCC1,
+		  PCF50606_OOCC1_GOSTDBY);
+}
+EXPORT_SYMBOL_GPL(pcf50606_go_standby);
+
+void pcf50606_gpo0_set(struct pcf50606_data *pcf, int on)
+{
+	u_int8_t val;
+
+	if (on)
+		val = 0x07;
+	else
+		val = 0x0f;
+
+	reg_set_bit_mask(pcf, PCF50606_REG_GPOC1, 0x0f, val);
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo0_set);
+
+int pcf50606_gpo0_get(struct pcf50606_data *pcf)
+{
+	u_int8_t reg = reg_read(pcf, PCF50606_REG_GPOC1) & 0x0f;
+
+	if (reg == 0x07 || reg == 0x08)
+		return 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo0_get);
+
+static void pcf50606_work(struct work_struct *work)
+{
+	struct pcf50606_data *pcf =
+			container_of(work, struct pcf50606_data, work);
+	u_int8_t pcfirq[3];
+	int ret;
+
+	mutex_lock(&pcf->working_lock);
+	pcf->working = 1;
+
+	/* sanity */
+	if (!&pcf->client.dev)
+		goto bail;
+
+	/*
+	 * if we are presently suspending, we are not in a position to deal
+	 * with pcf50606 interrupts at all.
+	 *
+	 * Because we didn't clear the int pending registers, there will be
+	 * no edge / interrupt waiting for us when we wake.  But it is OK
+	 * because at the end of our resume, we call this workqueue function
+	 * gratuitously, clearing the pending register and re-enabling
+	 * servicing this interrupt.
+	 */
+
+	if ((pcf->suspend_state == PCF50606_SS_STARTING_SUSPEND) ||
+	    (pcf->suspend_state == PCF50606_SS_COMPLETED_SUSPEND))
+		goto bail;
+
+	/*
+	 * If we are inside suspend -> resume completion time we don't attempt
+	 * service until we have fully resumed.  Although we could talk to the
+	 * device as soon as I2C is up, the regs in the device which we might
+	 * choose to modify as part of the service action have not been
+	 * reloaded with their pre-suspend states yet.  Therefore we will
+	 * defer our service if we are called like that until our resume has
+	 * completed.
+	 *
+	 * This shouldn't happen any more because we disable servicing this
+	 * interrupt in suspend and don't re-enable it until resume is
+	 * completed.
+	 */
+
+	if (pcf->suspend_state &&
+		(pcf->suspend_state != PCF50606_SS_COMPLETED_RESUME))
+		goto reschedule;
+
+	/* this is the case early in resume! Sanity check! */
+	if (i2c_get_clientdata(&pcf->client) == NULL)
+		goto reschedule;
+
+	/*
+	 * p35 pcf50606 datasheet rev 2.2:
+	 * ''The system controller shall read all interrupt registers in
+	 *   one I2C read action''
+	 * because if you don't INT# gets stuck asserted forever after a
+	 * while
+	 */
+	ret = i2c_smbus_read_i2c_block_data(&pcf->client, PCF50606_REG_INT1,
+					    sizeof(pcfirq), pcfirq);
+	if (ret != sizeof(pcfirq)) {
+		DEBUGPC("Oh crap PMU IRQ register read failed %d\n", ret);
+		/*
+		 * it shouldn't fail, we no longer attempt to use
+		 * I2C while it can be suspended.  But we don't have
+		 * much option but to retry if if it ever did fail,
+		 * because if we don't service the interrupt to clear
+		 * it, we will never see another PMU interrupt edge.
+		 */
+		goto reschedule;
+	}
+
+	/* hey did we just resume? (because we don't get here unless we are
+	 * running normally or the first call after resumption)
+	 *
+	 * pcf50606 resume is really really over now then.
+	 */
+	if (pcf->suspend_state != PCF50606_SS_RUNNING) {
+		pcf->suspend_state = PCF50606_SS_RUNNING;
+
+		/* peek at the IRQ reason, if power button then set a flag
+		 * so that we do not signal the event to userspace
+		 */
+		if (pcfirq[0] & (PCF50606_INT1_ONKEYF | PCF50606_INT1_ONKEYR)) {
+			pcf->suppress_onkey_events = 1;
+			dev_dbg(&pcf->client.dev,
+				"Wake by ONKEY, suppressing ONKEY events");
+		} else {
+			pcf->suppress_onkey_events = 0;
+		}
+	}
+
+	if (!pcf->coldplug_done) {
+		DEBUGPC("PMU Coldplug init\n");
+
+		/* we used SECOND to kick ourselves started -- turn it off */
+		pcfirq[0] &= ~PCF50606_INT1_SECOND;
+		reg_set_bit_mask(pcf, PCF50606_REG_INT1M, PCF50606_INT1_SECOND,
+				 PCF50606_INT1_SECOND);
+
+		/* coldplug the USB if present */
+		if (__reg_read(pcf, PCF50606_REG_OOCS) & PCF50606_OOCS_EXTON) {
+			/* Charger inserted */
+			DEBUGPC("COLD CHGINS ");
+			input_report_key(pcf->input_dev, KEY_BATTERY, 1);
+			apm_queue_event(APM_POWER_STATUS_CHANGE);
+			pcf->flags |= PCF50606_F_CHG_PRESENT;
+			if (pcf->pdata->cb)
+				pcf->pdata->cb(&pcf->client.dev,
+						PCF50606_FEAT_MBC,
+						PMU_EVT_INSERT);
+		}
+
+		pcf->coldplug_done = 1;
+	}
+
+
+	dev_dbg(&pcf->client.dev, "INT1=0x%02x INT2=0x%02x INT3=0x%02x:",
+		pcfirq[0], pcfirq[1], pcfirq[2]);
+
+	if (pcfirq[0] & PCF50606_INT1_ONKEYF) {
+		/* ONKEY falling edge (start of button press) */
+		pcf->flags |= PCF50606_F_PWR_PRESSED;
+		if (!pcf->suppress_onkey_events) {
+			DEBUGPC("ONKEYF ");
+			input_report_key(pcf->input_dev, KEY_POWER, 1);
+		} else {
+			DEBUGPC("ONKEYF(unreported) ");
+		}
+	}
+	if (pcfirq[0] & PCF50606_INT1_ONKEY1S) {
+		/* ONKEY pressed for more than 1 second */
+		pcf->onkey_seconds = 0;
+		DEBUGPC("ONKEY1S ");
+		/* Tell PMU we are taking care of this */
+		reg_set_bit_mask(pcf, PCF50606_REG_OOCC1,
+				 PCF50606_OOCC1_TOTRST,
+				 PCF50606_OOCC1_TOTRST);
+		/* enable SECOND interrupt (hz tick) */
+		reg_clear_bits(pcf, PCF50606_REG_INT1M, PCF50606_INT1_SECOND);
+	}
+	if (pcfirq[0] & PCF50606_INT1_ONKEYR) {
+		/* ONKEY rising edge (end of button press) */
+		pcf->flags &= ~PCF50606_F_PWR_PRESSED;
+		pcf->onkey_seconds = -1;
+		if (!pcf->suppress_onkey_events) {
+			DEBUGPC("ONKEYR ");
+			input_report_key(pcf->input_dev, KEY_POWER, 0);
+		} else {
+			DEBUGPC("ONKEYR(suppressed) ");
+			/* don't suppress any more power button events */
+			pcf->suppress_onkey_events = 0;
+		}
+		/* disable SECOND interrupt in case RTC didn't
+		 * request it */
+		if (!(pcf->flags & PCF50606_F_RTC_SECOND))
+			reg_set_bit_mask(pcf, PCF50606_REG_INT1M,
+					 PCF50606_INT1_SECOND,
+					 PCF50606_INT1_SECOND);
+	}
+	if (pcfirq[0] & PCF50606_INT1_EXTONR) {
+		DEBUGPC("EXTONR ");
+		input_report_key(pcf->input_dev, KEY_POWER2, 1);
+	}
+	if (pcfirq[0] & PCF50606_INT1_EXTONF) {
+		DEBUGPC("EXTONF ");
+		input_report_key(pcf->input_dev, KEY_POWER2, 0);
+	}
+	if (pcfirq[0] & PCF50606_INT1_SECOND) {
+		DEBUGPC("SECOND ");
+		if (pcf->flags & PCF50606_F_RTC_SECOND)
+			rtc_update_irq(pcf->rtc, 1,
+				       RTC_PF | RTC_IRQF);
+
+		if (pcf->onkey_seconds >= 0 &&
+		    pcf->flags & PCF50606_F_PWR_PRESSED) {
+			DEBUGPC("ONKEY_SECONDS(%u, OOCC1=0x%02x) ",
+				pcf->onkey_seconds,
+				reg_read(pcf, PCF50606_REG_OOCC1));
+			pcf->onkey_seconds++;
+			if (pcf->onkey_seconds >=
+			    pcf->pdata->onkey_seconds_required) {
+				/* Ask init to do 'ctrlaltdel' */
+				/*
+				 * currently Linux reacts badly to issuing a
+				 * signal to PID #1 before init is started.
+				 * What happens is that the next kernel thread
+				 * to start, which is the JFFS2 Garbage
+				 * collector in our case, gets the signal
+				 * instead and proceeds to fail to fork --
+				 * which is very bad.  Therefore we confirm
+				 * PID #1 exists before issuing the signal
+				 */
+				if (find_task_by_pid_ns(1, &init_pid_ns)) {
+					kill_pid(task_pid(find_task_by_pid_ns(1, 
+							&init_pid_ns)), SIGINT, 1);
+					DEBUGPC("SIGINT(init) ");
+				}
+				/* FIXME: what to do if userspace doesn't
+				 * shut down? Do we want to force it? */
+			}
+		}
+	}
+	if (pcfirq[0] & PCF50606_INT1_ALARM) {
+		DEBUGPC("ALARM ");
+		if (pcf->pdata->used_features & PCF50606_FEAT_RTC)
+			rtc_update_irq(pcf->rtc, 1,
+				       RTC_AF | RTC_IRQF);
+	}
+
+	if (pcfirq[1] & PCF50606_INT2_CHGINS) {
+		/* Charger inserted */
+		DEBUGPC("CHGINS ");
+		input_report_key(pcf->input_dev, KEY_BATTERY, 1);
+		apm_queue_event(APM_POWER_STATUS_CHANGE);
+		pcf->flags |= PCF50606_F_CHG_PRESENT;
+		if (pcf->pdata->cb)
+			pcf->pdata->cb(&pcf->client.dev,
+				       PCF50606_FEAT_MBC, PMU_EVT_INSERT);
+		/* FIXME: how to signal this to userspace */
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGRM) {
+		/* Charger removed */
+		DEBUGPC("CHGRM ");
+		input_report_key(pcf->input_dev, KEY_BATTERY, 0);
+		apm_queue_event(APM_POWER_STATUS_CHANGE);
+		pcf->flags &= ~(PCF50606_F_CHG_MASK|PCF50606_F_CHG_PRESENT);
+		if (pcf->pdata->cb)
+			pcf->pdata->cb(&pcf->client.dev,
+				       PCF50606_FEAT_MBC, PMU_EVT_INSERT);
+		/* FIXME: how signal this to userspace */
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGFOK) {
+		/* Battery ready for fast charging */
+		DEBUGPC("CHGFOK ");
+		pcf->flags |= PCF50606_F_CHG_FOK;
+		/* FIXME: how to signal this to userspace */
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGERR) {
+		/* Error in charge mode */
+		DEBUGPC("CHGERR ");
+		pcf->flags |= PCF50606_F_CHG_ERR;
+		pcf->flags &= ~(PCF50606_F_CHG_FOK|PCF50606_F_CHG_READY);
+		/* FIXME: how to signal this to userspace */
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGFRDY) {
+		/* Fast charge completed */
+		DEBUGPC("CHGFRDY ");
+		pcf->flags |= PCF50606_F_CHG_READY;
+		pcf->flags &= ~PCF50606_F_CHG_FOK;
+		/* FIXME: how to signal this to userspace */
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGPROT) {
+		/* Charging protection interrupt */
+		DEBUGPC("CHGPROT ");
+		pcf->flags &= ~(PCF50606_F_CHG_FOK|PCF50606_F_CHG_READY);
+		/* FIXME: signal this to userspace */
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGWD10S) {
+		/* Charger watchdog will expire in 10 seconds */
+		DEBUGPC("CHGWD10S ");
+		reg_set_bit_mask(pcf, PCF50606_REG_OOCC1,
+				 PCF50606_OOCC1_WDTRST,
+				 PCF50606_OOCC1_WDTRST);
+	}
+	if (pcfirq[1] & PCF50606_INT2_CHGWDEXP) {
+		/* Charger watchdog expires */
+		DEBUGPC("CHGWDEXP ");
+		/* FIXME: how to signal this to userspace */
+	}
+
+	if (pcfirq[2] & PCF50606_INT3_ADCRDY) {
+		/* ADC result ready */
+		DEBUGPC("ADCRDY ");
+	}
+	if (pcfirq[2] & PCF50606_INT3_ACDINS) {
+		/* Accessory insertion detected */
+		DEBUGPC("ACDINS ");
+		if (pcf->pdata->cb)
+			pcf->pdata->cb(&pcf->client.dev,
+				       PCF50606_FEAT_ACD, PMU_EVT_INSERT);
+	}
+	if (pcfirq[2] & PCF50606_INT3_ACDREM) {
+		/* Accessory removal detected */
+		DEBUGPC("ACDREM ");
+		if (pcf->pdata->cb)
+			pcf->pdata->cb(&pcf->client.dev,
+				       PCF50606_FEAT_ACD, PMU_EVT_REMOVE);
+	}
+	/* FIXME: TSCPRES */
+	if (pcfirq[2] & PCF50606_INT3_LOWBAT) {
+		if (__reg_read(pcf, PCF50606_REG_OOCS) & PCF50606_OOCS_EXTON) {
+			/*
+			 * hey no need to freak out, we have some kind of
+			 * valid charger power
+			 */
+			DEBUGPC("(NO)BAT ");
+		} else {
+			/* Really low battery voltage, we have 8 seconds left */
+			DEBUGPC("LOWBAT ");
+			/*
+			 * currently Linux reacts badly to issuing a signal to
+			 * PID #1 before init is started.  What happens is that
+			 * the next kernel thread to start, which is the JFFS2
+			 * Garbage collector in our case, gets the signal
+			 * instead and proceeds to fail to fork -- which is
+			 * very bad.  Therefore we confirm PID #1 exists
+			 * before issuing SPIGPWR
+			 */
+			if (find_task_by_pid_ns(1, &init_pid_ns)) {
+				apm_queue_event(APM_LOW_BATTERY);
+				DEBUGPC("SIGPWR(init) ");
+				kill_pid(task_pid(find_task_by_pid_ns(1, &init_pid_ns)), SIGPWR, 1);
+			} else
+				/*
+				 * well, our situation is like this:  we do not
+				 * have any external power, we have a low
+				 * battery and since PID #1 doesn't exist yet,
+				 * we are early in the boot, likely before
+				 * rootfs mount.  We should just call it a day
+				 */
+				apm_queue_event(APM_CRITICAL_SUSPEND);
+		}
+		/* Tell PMU we are taking care of this */
+		reg_set_bit_mask(pcf, PCF50606_REG_OOCC1,
+				 PCF50606_OOCC1_TOTRST,
+				 PCF50606_OOCC1_TOTRST);
+	}
+	if (pcfirq[2] & PCF50606_INT3_HIGHTMP) {
+		/* High temperature */
+		DEBUGPC("HIGHTMP ");
+		apm_queue_event(APM_CRITICAL_SUSPEND);
+	}
+
+	DEBUGPC("\n");
+
+bail:
+	pcf->working = 0;
+	input_sync(pcf->input_dev);
+	put_device(&pcf->client.dev);
+	mutex_unlock(&pcf->working_lock);
+
+	return;
+
+reschedule:
+
+	if ((pcf->suspend_state != PCF50606_SS_STARTING_SUSPEND) &&
+	    (pcf->suspend_state != PCF50606_SS_COMPLETED_SUSPEND)) {
+		msleep(10);
+		dev_info(&pcf->client.dev, "rescheduling interrupt service\n");
+	}
+	if (!schedule_work(&pcf->work))
+		dev_err(&pcf->client.dev, "int service reschedule failed\n");
+
+	/* we don't put the device here, hold it for next time */
+	mutex_unlock(&pcf->working_lock);
+}
+
+static irqreturn_t pcf50606_irq(int irq, void *_pcf)
+{
+	struct pcf50606_data *pcf = _pcf;
+
+	dev_dbg(&pcf->client.dev, "entering(irq=%u, pcf=%p): scheduling work\n",
+		irq, _pcf);
+	get_device(&pcf->client.dev);
+	if (!schedule_work(&pcf->work) && !pcf->working)
+		dev_err(&pcf->client.dev, "pcf irq work already queued.\n");
+
+	return IRQ_HANDLED;
+}
+
+static u_int16_t adc_to_batt_millivolts(u_int16_t adc)
+{
+	u_int16_t mvolts;
+
+	mvolts = (adc * 6000) / 1024;
+
+	return mvolts;
+}
+
+#define BATTVOLT_SCALE_START 2800
+#define BATTVOLT_SCALE_END 4200
+#define BATTVOLT_SCALE_DIVIDER ((BATTVOLT_SCALE_END - BATTVOLT_SCALE_START)/100)
+
+static u_int8_t battvolt_scale(u_int16_t battvolt)
+{
+	/* FIXME: this linear scale is completely bogus */
+	u_int16_t battvolt_relative = battvolt - BATTVOLT_SCALE_START;
+	unsigned int percent = battvolt_relative / BATTVOLT_SCALE_DIVIDER;
+
+	return percent;
+}
+
+u_int16_t pcf50606_battvolt(struct pcf50606_data *pcf)
+{
+	u_int16_t adc;
+	adc = adc_read(pcf, PCF50606_ADCMUX_BATVOLT_RES, NULL);
+
+	return adc_to_batt_millivolts(adc);
+}
+EXPORT_SYMBOL_GPL(pcf50606_battvolt);
+
+static ssize_t show_battvolt(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%u\n", pcf50606_battvolt(pcf));
+}
+static DEVICE_ATTR(battvolt, S_IRUGO | S_IWUSR, show_battvolt, NULL);
+
+static int reg_id_by_name(const char *name)
+{
+	int reg_id;
+
+	if (!strcmp(name, "voltage_dcd"))
+		reg_id = PCF50606_REGULATOR_DCD;
+	else if (!strcmp(name, "voltage_dcde"))
+		reg_id = PCF50606_REGULATOR_DCDE;
+	else if (!strcmp(name, "voltage_dcud"))
+		reg_id = PCF50606_REGULATOR_DCUD;
+	else if (!strcmp(name, "voltage_d1reg"))
+		reg_id = PCF50606_REGULATOR_D1REG;
+	else if (!strcmp(name, "voltage_d2reg"))
+		reg_id = PCF50606_REGULATOR_D2REG;
+	else if (!strcmp(name, "voltage_d3reg"))
+		reg_id = PCF50606_REGULATOR_D3REG;
+	else if (!strcmp(name, "voltage_lpreg"))
+		reg_id = PCF50606_REGULATOR_LPREG;
+	else if (!strcmp(name, "voltage_ioreg"))
+		reg_id = PCF50606_REGULATOR_IOREG;
+	else
+		reg_id = -1;
+
+	return reg_id;
+}
+
+static ssize_t show_vreg(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	unsigned int reg_id;
+
+	reg_id = reg_id_by_name(attr->attr.name);
+	if (reg_id < 0)
+		return 0;
+
+	if (pcf50606_onoff_get(pcf, reg_id) > 0)
+		return sprintf(buf, "%u\n", pcf50606_voltage_get(pcf, reg_id));
+	else
+		return strlcpy(buf, "0\n", PAGE_SIZE);
+}
+
+static ssize_t set_vreg(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	unsigned long mvolts = simple_strtoul(buf, NULL, 10);
+	unsigned int reg_id;
+
+	reg_id = reg_id_by_name(attr->attr.name);
+	if (reg_id < 0)
+		return -EIO;
+
+	dev_dbg(dev, "attempting to set %s(%d) to %lu mvolts\n",
+		attr->attr.name, reg_id, mvolts);
+
+	if (mvolts == 0) {
+		pcf50606_onoff_set(pcf, reg_id, 0);
+	} else {
+		if (pcf50606_voltage_set(pcf, reg_id, mvolts) < 0) {
+			dev_warn(dev, "refusing to set %s(%d) to %lu mvolts "
+				 "(max=%u)\n", attr->attr.name, reg_id, mvolts,
+				 pcf->pdata->rails[reg_id].voltage.max);
+			return -EINVAL;
+		}
+		pcf50606_onoff_set(pcf, reg_id, 1);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(voltage_dcd, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_dcde, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_dcud, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_d1reg, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_d2reg, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_d3reg, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_lpreg, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+static DEVICE_ATTR(voltage_ioreg, S_IRUGO | S_IWUSR, show_vreg, set_vreg);
+
+/***********************************************************************
+ * Charger Control
+ ***********************************************************************/
+
+/* Enable/disable fast charging (500mA in the GTA01) */
+void pcf50606_charge_fast(struct pcf50606_data *pcf, int on)
+{
+	if (!(pcf->pdata->used_features & PCF50606_FEAT_MBC))
+		return;
+
+	if (on) {
+		/* We can allow PCF to automatically charge
+		 * using Ifast */
+		pcf->flags |= PCF50606_F_CHG_FAST;
+		reg_set_bit_mask(pcf, PCF50606_REG_MBCC1,
+				 PCF50606_MBCC1_AUTOFST,
+				 PCF50606_MBCC1_AUTOFST);
+	} else {
+		pcf->flags &= ~PCF50606_F_CHG_FAST;
+		/* disable automatic fast-charge */
+		reg_clear_bits(pcf, PCF50606_REG_MBCC1,
+				PCF50606_MBCC1_AUTOFST);
+		/* switch to idle mode to abort existing charge
+		 * process */
+		reg_set_bit_mask(pcf, PCF50606_REG_MBCC1,
+				 PCF50606_MBCC1_CHGMOD_MASK,
+				 PCF50606_MBCC1_CHGMOD_IDLE);
+	}
+}
+EXPORT_SYMBOL_GPL(pcf50606_charge_fast);
+
+static inline u_int16_t adc_to_rntc(struct pcf50606_data *pcf, u_int16_t adc)
+{
+	u_int32_t r_ntc = (adc * (u_int32_t)pcf->pdata->r_fix_batt)
+		/ (1023 - adc);
+
+	return r_ntc;
+}
+
+static inline int16_t rntc_to_temp(u_int16_t rntc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ntc_table_10k_3370B); i++) {
+		if (rntc > ntc_table_10k_3370B[i])
+			return i - 10;	/* First element is -10 */
+	}
+	return -99;	/* Below our range */
+}
+
+static ssize_t show_battemp(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int16_t adc;
+
+	adc = adc_read(pcf, PCF50606_ADCMUX_BATTEMP, NULL);
+
+	return sprintf(buf, "%d\n", rntc_to_temp(adc_to_rntc(pcf, adc)));
+}
+static DEVICE_ATTR(battemp, S_IRUGO | S_IWUSR, show_battemp, NULL);
+
+static inline int16_t adc_to_chg_milliamps(struct pcf50606_data *pcf,
+					     u_int16_t adc_adcin1,
+					     u_int16_t adc_batvolt)
+{
+	int32_t res = (adc_adcin1 - adc_batvolt) * 2400;
+	return (res * 1000) / (pcf->pdata->r_sense_milli * 1024);
+}
+
+static ssize_t show_chgcur(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int16_t adc_batvolt, adc_adcin1;
+	int16_t ma;
+
+	adc_batvolt = adc_read(pcf, PCF50606_ADCMUX_BATVOLT_ADCIN1,
+			       &adc_adcin1);
+	ma = adc_to_chg_milliamps(pcf, adc_adcin1, adc_batvolt);
+
+	return sprintf(buf, "%d\n", ma);
+}
+static DEVICE_ATTR(chgcur, S_IRUGO | S_IWUSR, show_chgcur, NULL);
+
+static const char *chgmode_names[] = {
+	[PCF50606_MBCC1_CHGMOD_QUAL]		= "qualification",
+	[PCF50606_MBCC1_CHGMOD_PRE]		= "pre",
+	[PCF50606_MBCC1_CHGMOD_TRICKLE]		= "trickle",
+	[PCF50606_MBCC1_CHGMOD_FAST_CCCV]	= "fast_cccv",
+	[PCF50606_MBCC1_CHGMOD_FAST_NOCC]	= "fast_nocc",
+	[PCF50606_MBCC1_CHGMOD_FAST_NOCV]	= "fast_nocv",
+	[PCF50606_MBCC1_CHGMOD_FAST_SW]		= "fast_switch",
+	[PCF50606_MBCC1_CHGMOD_IDLE]		= "idle",
+};
+
+static ssize_t show_chgmode(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int8_t mbcc1 = reg_read(pcf, PCF50606_REG_MBCC1);
+	u_int8_t chgmod = (mbcc1 & PCF50606_MBCC1_CHGMOD_MASK);
+
+	return sprintf(buf, "%s\n", chgmode_names[chgmod]);
+}
+
+static ssize_t set_chgmode(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int8_t mbcc1 = reg_read(pcf, PCF50606_REG_MBCC1);
+
+	mbcc1 &= ~PCF50606_MBCC1_CHGMOD_MASK;
+
+	if (!strcmp(buf, "qualification"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_QUAL;
+	else if (!strcmp(buf, "pre"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_PRE;
+	else if (!strcmp(buf, "trickle"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_TRICKLE;
+	else if (!strcmp(buf, "fast_cccv"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_FAST_CCCV;
+	/* We don't allow the other fast modes for security reasons */
+	else if (!strcmp(buf, "idle"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_IDLE;
+	else
+		return -EINVAL;
+
+	reg_write(pcf, PCF50606_REG_MBCC1, mbcc1);
+
+	return count;
+}
+
+static DEVICE_ATTR(chgmode, S_IRUGO | S_IWUSR, show_chgmode, set_chgmode);
+
+static const char *chgstate_names[] = {
+	[PCF50606_B_CHG_FAST]			= "fast_enabled",
+	[PCF50606_B_CHG_PRESENT] 		= "present",
+	[PCF50606_B_CHG_FOK]			= "fast_ok",
+	[PCF50606_B_CHG_ERR]			= "error",
+	[PCF50606_B_CHG_PROT]			= "protection",
+	[PCF50606_B_CHG_READY]			= "ready",
+};
+
+static ssize_t show_chgstate(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	char *b = buf;
+	int i;
+
+	for (i = 0; i < 32; i++)
+		if (pcf->flags & (1 << i) && i < ARRAY_SIZE(chgstate_names))
+			b += sprintf(b, "%s ", chgstate_names[i]);
+
+	if (b > buf)
+		b += sprintf(b, "\n");
+
+	return b - buf;
+}
+static DEVICE_ATTR(chgstate, S_IRUGO | S_IWUSR, show_chgstate, NULL);
+
+/***********************************************************************
+ * APM emulation
+ ***********************************************************************/
+
+static void pcf50606_get_power_status(struct apm_power_info *info)
+{
+	struct pcf50606_data *pcf = pcf50606_global;
+	u_int8_t mbcc1 = reg_read(pcf, PCF50606_REG_MBCC1);
+	u_int8_t chgmod = mbcc1 & PCF50606_MBCC1_CHGMOD_MASK;
+	u_int16_t battvolt = pcf50606_battvolt(pcf);
+
+	if (reg_read(pcf, PCF50606_REG_OOCS) & PCF50606_OOCS_EXTON)
+		info->ac_line_status = APM_AC_ONLINE;
+	else
+		info->ac_line_status = APM_AC_OFFLINE;
+
+	switch (chgmod) {
+	case PCF50606_MBCC1_CHGMOD_QUAL:
+	case PCF50606_MBCC1_CHGMOD_PRE:
+	case PCF50606_MBCC1_CHGMOD_IDLE:
+		info->battery_life = battvolt_scale(battvolt);
+		break;
+	default:
+		info->battery_status = APM_BATTERY_STATUS_CHARGING;
+		info->battery_flag = APM_BATTERY_FLAG_CHARGING;
+		break;
+	}
+}
+
+/***********************************************************************
+ * RTC
+ ***********************************************************************/
+
+struct pcf50606_time {
+	u_int8_t sec;
+	u_int8_t min;
+	u_int8_t hour;
+	u_int8_t wkday;
+	u_int8_t day;
+	u_int8_t month;
+	u_int8_t year;
+};
+
+static void pcf2rtc_time(struct rtc_time *rtc, struct pcf50606_time *pcf)
+{
+	rtc->tm_sec = bcd2bin(pcf->sec);
+	rtc->tm_min = bcd2bin(pcf->min);
+	rtc->tm_hour = bcd2bin(pcf->hour);
+	rtc->tm_wday = bcd2bin(pcf->wkday);
+	rtc->tm_mday = bcd2bin(pcf->day);
+	rtc->tm_mon = bcd2bin(pcf->month);
+	rtc->tm_year = bcd2bin(pcf->year) + 100;
+}
+
+static void rtc2pcf_time(struct pcf50606_time *pcf, struct rtc_time *rtc)
+{
+	pcf->sec = bin2bcd(rtc->tm_sec);
+	pcf->min = bin2bcd(rtc->tm_min);
+	pcf->hour = bin2bcd(rtc->tm_hour);
+	pcf->wkday = bin2bcd(rtc->tm_wday);
+	pcf->day = bin2bcd(rtc->tm_mday);
+	pcf->month = bin2bcd(rtc->tm_mon);
+	pcf->year = bin2bcd(rtc->tm_year - 100);
+}
+
+static int pcf50606_rtc_ioctl(struct device *dev, unsigned int cmd,
+			      unsigned long arg)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+
+	switch (cmd) {
+	case RTC_AIE_OFF:
+		/* disable the alarm interrupt */
+		reg_set_bit_mask(pcf, PCF50606_REG_INT1M,
+				 PCF50606_INT1_ALARM, PCF50606_INT1_ALARM);
+		return 0;
+	case RTC_AIE_ON:
+		/* enable the alarm interrupt */
+		reg_clear_bits(pcf, PCF50606_REG_INT1M, PCF50606_INT1_ALARM);
+		return 0;
+	case RTC_PIE_OFF:
+		/* disable periodic interrupt (hz tick) */
+		pcf->flags &= ~PCF50606_F_RTC_SECOND;
+		reg_set_bit_mask(pcf, PCF50606_REG_INT1M,
+				 PCF50606_INT1_SECOND, PCF50606_INT1_SECOND);
+		return 0;
+	case RTC_PIE_ON:
+		/* ensable periodic interrupt (hz tick) */
+		pcf->flags |= PCF50606_F_RTC_SECOND;
+		reg_clear_bits(pcf, PCF50606_REG_INT1M, PCF50606_INT1_SECOND);
+		return 0;
+	}
+	return -ENOIOCTLCMD;
+}
+
+static int pcf50606_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	struct pcf50606_time pcf_tm;
+
+	mutex_lock(&pcf->lock);
+	pcf_tm.sec = __reg_read(pcf, PCF50606_REG_RTCSC);
+	pcf_tm.min = __reg_read(pcf, PCF50606_REG_RTCMN);
+	pcf_tm.hour = __reg_read(pcf, PCF50606_REG_RTCHR);
+	pcf_tm.wkday = __reg_read(pcf, PCF50606_REG_RTCWD);
+	pcf_tm.day = __reg_read(pcf, PCF50606_REG_RTCDT);
+	pcf_tm.month = __reg_read(pcf, PCF50606_REG_RTCMT);
+	pcf_tm.year = __reg_read(pcf, PCF50606_REG_RTCYR);
+	mutex_unlock(&pcf->lock);
+
+	dev_dbg(dev, "PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\n",
+		pcf_tm.day, pcf_tm.month, pcf_tm.year,
+		pcf_tm.hour, pcf_tm.min, pcf_tm.sec);
+
+	pcf2rtc_time(tm, &pcf_tm);
+
+	dev_dbg(dev, "RTC_TIME: %u.%u.%u %u:%u:%u\n",
+		tm->tm_mday, tm->tm_mon, tm->tm_year,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return 0;
+}
+
+static int pcf50606_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	struct pcf50606_time pcf_tm;
+	u_int8_t int1m;
+
+	dev_dbg(dev, "RTC_TIME: %u.%u.%u %u:%u:%u\n",
+		tm->tm_mday, tm->tm_mon, tm->tm_year,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+	rtc2pcf_time(&pcf_tm, tm);
+	dev_dbg(dev, "PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\n",
+		pcf_tm.day, pcf_tm.month, pcf_tm.year,
+		pcf_tm.hour, pcf_tm.min, pcf_tm.sec);
+
+	mutex_lock(&pcf->lock);
+
+	/* disable SECOND interrupt */
+	int1m = __reg_read(pcf, PCF50606_REG_INT1M);
+	__reg_write(pcf, PCF50606_REG_INT1M, int1m | PCF50606_INT1_SECOND);
+
+	__reg_write(pcf, PCF50606_REG_RTCSC, pcf_tm.sec);
+	__reg_write(pcf, PCF50606_REG_RTCMN, pcf_tm.min);
+	__reg_write(pcf, PCF50606_REG_RTCHR, pcf_tm.hour);
+	__reg_write(pcf, PCF50606_REG_RTCWD, pcf_tm.wkday);
+	__reg_write(pcf, PCF50606_REG_RTCDT, pcf_tm.day);
+	__reg_write(pcf, PCF50606_REG_RTCMT, pcf_tm.month);
+	__reg_write(pcf, PCF50606_REG_RTCYR, pcf_tm.year);
+
+	/* restore INT1M, potentially re-enable SECOND interrupt */
+	__reg_write(pcf, PCF50606_REG_INT1M, int1m);
+
+	mutex_unlock(&pcf->lock);
+
+	return 0;
+}
+
+static int pcf50606_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	struct pcf50606_time pcf_tm;
+
+	mutex_lock(&pcf->lock);
+	alrm->enabled =
+		__reg_read(pcf, PCF50606_REG_INT1M) & PCF50606_INT1_ALARM
+		? 0 : 1;
+	pcf_tm.sec = __reg_read(pcf, PCF50606_REG_RTCSCA);
+	pcf_tm.min = __reg_read(pcf, PCF50606_REG_RTCMNA);
+	pcf_tm.hour = __reg_read(pcf, PCF50606_REG_RTCHRA);
+	pcf_tm.wkday = __reg_read(pcf, PCF50606_REG_RTCWDA);
+	pcf_tm.day = __reg_read(pcf, PCF50606_REG_RTCDTA);
+	pcf_tm.month = __reg_read(pcf, PCF50606_REG_RTCMTA);
+	pcf_tm.year = __reg_read(pcf, PCF50606_REG_RTCYRA);
+	mutex_unlock(&pcf->lock);
+
+	pcf2rtc_time(&alrm->time, &pcf_tm);
+
+	return 0;
+}
+
+static int pcf50606_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	struct pcf50606_time pcf_tm;
+	u_int8_t irqmask;
+
+	rtc2pcf_time(&pcf_tm, &alrm->time);
+
+	mutex_lock(&pcf->lock);
+
+	/* disable alarm interrupt */
+	irqmask = __reg_read(pcf, PCF50606_REG_INT1M);
+	irqmask |= PCF50606_INT1_ALARM;
+	__reg_write(pcf, PCF50606_REG_INT1M, irqmask);
+
+	__reg_write(pcf, PCF50606_REG_RTCSCA, pcf_tm.sec);
+	__reg_write(pcf, PCF50606_REG_RTCMNA, pcf_tm.min);
+	__reg_write(pcf, PCF50606_REG_RTCHRA, pcf_tm.hour);
+	__reg_write(pcf, PCF50606_REG_RTCWDA, pcf_tm.wkday);
+	__reg_write(pcf, PCF50606_REG_RTCDTA, pcf_tm.day);
+	__reg_write(pcf, PCF50606_REG_RTCMTA, pcf_tm.month);
+	__reg_write(pcf, PCF50606_REG_RTCYRA, pcf_tm.year);
+
+	if (alrm->enabled) {
+		/* (re-)enaable alarm interrupt */
+		irqmask = __reg_read(pcf, PCF50606_REG_INT1M);
+		irqmask &= ~PCF50606_INT1_ALARM;
+		__reg_write(pcf, PCF50606_REG_INT1M, irqmask);
+	}
+
+	mutex_unlock(&pcf->lock);
+
+	/* FIXME */
+	return 0;
+}
+
+static struct rtc_class_ops pcf50606_rtc_ops = {
+	.ioctl		= pcf50606_rtc_ioctl,
+	.read_time	= pcf50606_rtc_read_time,
+	.set_time	= pcf50606_rtc_set_time,
+	.read_alarm	= pcf50606_rtc_read_alarm,
+	.set_alarm	= pcf50606_rtc_set_alarm,
+};
+
+/***********************************************************************
+ * Watchdog
+ ***********************************************************************/
+
+static void pcf50606_wdt_start(struct pcf50606_data *pcf)
+{
+	reg_set_bit_mask(pcf, PCF50606_REG_OOCC1, PCF50606_OOCC1_WDTRST,
+			 PCF50606_OOCC1_WDTRST);
+}
+
+static void pcf50606_wdt_stop(struct pcf50606_data *pcf)
+{
+	reg_clear_bits(pcf, PCF50606_REG_OOCS, PCF50606_OOCS_WDTEXP);
+}
+
+static void pcf50606_wdt_keepalive(struct pcf50606_data *pcf)
+{
+	pcf50606_wdt_start(pcf);
+}
+
+static int pcf50606_wdt_open(struct inode *inode, struct file *file)
+{
+	struct pcf50606_data *pcf = pcf50606_global;
+
+	file->private_data = pcf;
+
+	/* start the timer */
+	pcf50606_wdt_start(pcf);
+
+	return nonseekable_open(inode, file);
+}
+
+static int pcf50606_wdt_release(struct inode *inode, struct file *file)
+{
+	struct pcf50606_data *pcf = file->private_data;
+
+	if (pcf->allow_close == CLOSE_STATE_ALLOW)
+		pcf50606_wdt_stop(pcf);
+	else {
+		printk(KERN_CRIT "Unexpected close, not stopping watchdog!\n");
+		pcf50606_wdt_keepalive(pcf);
+	}
+
+	pcf->allow_close = CLOSE_STATE_NOT;
+
+	return 0;
+}
+
+static ssize_t pcf50606_wdt_write(struct file *file, const char __user *data,
+				  size_t len, loff_t *ppos)
+{
+	struct pcf50606_data *pcf = file->private_data;
+	if (len) {
+		size_t i;
+
+		for (i = 0; i != len; i++) {
+			char c;
+			if (get_user(c, data + i))
+				return -EFAULT;
+			if (c == 'V')
+				pcf->allow_close = CLOSE_STATE_ALLOW;
+		}
+		pcf50606_wdt_keepalive(pcf);
+	}
+
+	return len;
+}
+
+static struct watchdog_info pcf50606_wdt_ident = {
+	.options	= WDIOF_MAGICCLOSE,
+	.firmware_version = 0,
+	.identity	= "PCF50606 Watchdog",
+};
+
+static int pcf50606_wdt_ioctl(struct inode *inode, struct file *file,
+			      unsigned int cmd, unsigned long arg)
+{
+	struct pcf50606_data *pcf = file->private_data;
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &pcf50606_wdt_ident,
+				    sizeof(pcf50606_wdt_ident)) ? -EFAULT : 0;
+		break;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+	case WDIOC_KEEPALIVE:
+		pcf50606_wdt_keepalive(pcf);
+		return 0;
+	case WDIOC_GETTIMEOUT:
+		return put_user(8, p);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+static struct file_operations pcf50606_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= &pcf50606_wdt_write,
+	.ioctl		= &pcf50606_wdt_ioctl,
+	.open		= &pcf50606_wdt_open,
+	.release	= &pcf50606_wdt_release,
+};
+
+static struct miscdevice pcf50606_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &pcf50606_wdt_fops,
+};
+
+/***********************************************************************
+ * PWM
+ ***********************************************************************/
+
+static const char *pwm_dc_table[] = {
+	"0/16", "1/16", "2/16", "3/16",
+	"4/16", "5/16", "6/16", "7/16",
+	"8/16", "9/16", "10/16", "11/16",
+	"12/16", "13/16", "14/16", "15/16",
+};
+
+static ssize_t show_pwm_dc(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int8_t val;
+
+	val = reg_read(pcf, PCF50606_REG_PWMC1) >> PCF50606_PWMC1_DC_SHIFT;
+	val &= 0xf;
+
+	return sprintf(buf, "%s\n", pwm_dc_table[val]);
+}
+
+static ssize_t set_pwm_dc(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int8_t i;
+
+	for (i = 0; i < ARRAY_SIZE(pwm_dc_table); i++) {
+		if (!strncmp(buf, pwm_dc_table[i], strlen(pwm_dc_table[i]))) {
+			dev_dbg(dev, "setting pwm dc %s\n\r", pwm_dc_table[i]);
+			reg_set_bit_mask(pcf, PCF50606_REG_PWMC1, 0x1e,
+					 (i << PCF50606_PWMC1_DC_SHIFT));
+		}
+	}
+	return count;
+}
+
+static DEVICE_ATTR(pwm_dc, S_IRUGO | S_IWUSR, show_pwm_dc, set_pwm_dc);
+
+static const char *pwm_clk_table[] = {
+	"512", "256", "128", "64",
+	"56300", "28100", "14100", "7000",
+};
+
+static ssize_t show_pwm_clk(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int8_t val;
+
+	val = reg_read(pcf, PCF50606_REG_PWMC1) >> PCF50606_PWMC1_CLK_SHIFT;
+	val &= 0x7;
+
+	return sprintf(buf, "%s\n", pwm_clk_table[val]);
+}
+
+static ssize_t set_pwm_clk(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	u_int8_t i;
+
+	for (i = 0; i < ARRAY_SIZE(pwm_clk_table); i++) {
+		if (!strncmp(buf, pwm_clk_table[i], strlen(pwm_clk_table[i]))) {
+			dev_dbg(dev, "setting pwm clk %s\n\r",
+				pwm_clk_table[i]);
+			reg_set_bit_mask(pcf, PCF50606_REG_PWMC1, 0xe0,
+					 (i << PCF50606_PWMC1_CLK_SHIFT));
+		}
+	}
+	return count;
+}
+
+static DEVICE_ATTR(pwm_clk, S_IRUGO | S_IWUSR, show_pwm_clk, set_pwm_clk);
+
+static int pcf50606bl_get_intensity(struct backlight_device *bd)
+{
+	struct pcf50606_data *pcf = bl_get_data(bd);
+	int intensity = reg_read(pcf, PCF50606_REG_PWMC1);
+	intensity = (intensity >> PCF50606_PWMC1_DC_SHIFT);
+
+	return intensity & 0xf;
+}
+
+static int pcf50606bl_set_intensity(struct backlight_device *bd)
+{
+	struct pcf50606_data *pcf = bl_get_data(bd);
+	int intensity = bd->props.brightness;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+
+	return reg_set_bit_mask(pcf, PCF50606_REG_PWMC1, 0x1e,
+				(intensity << PCF50606_PWMC1_DC_SHIFT));
+}
+
+static struct backlight_ops pcf50606bl_ops = {
+	.get_brightness	= pcf50606bl_get_intensity,
+	.update_status	= pcf50606bl_set_intensity,
+};
+
+/***********************************************************************
+ * Driver initialization
+ ***********************************************************************/
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+/* We currently place those platform devices here to make sure the device
+ * suspend/resume order is correct */
+static struct platform_device gta01_pm_gps_dev = {
+	.name		= "neo1973-pm-gps",
+};
+
+static struct platform_device gta01_pm_bt_dev = {
+	.name		= "neo1973-pm-bt",
+};
+#endif
+
+static struct attribute *pcf_sysfs_entries[16] = {
+	&dev_attr_voltage_dcd.attr,
+	&dev_attr_voltage_dcde.attr,
+	&dev_attr_voltage_dcud.attr,
+	&dev_attr_voltage_d1reg.attr,
+	&dev_attr_voltage_d2reg.attr,
+	&dev_attr_voltage_d3reg.attr,
+	&dev_attr_voltage_lpreg.attr,
+	&dev_attr_voltage_ioreg.attr,
+	NULL
+};
+
+static struct attribute_group pcf_attr_group = {
+	.name	= NULL,			/* put in device directory */
+	.attrs	= pcf_sysfs_entries,
+};
+
+static void populate_sysfs_group(struct pcf50606_data *pcf)
+{
+	int i = 0;
+	struct attribute **attr;
+
+	for (attr = pcf_sysfs_entries; *attr; attr++)
+		i++;
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_MBC) {
+		pcf_sysfs_entries[i++] = &dev_attr_chgstate.attr;
+		pcf_sysfs_entries[i++] = &dev_attr_chgmode.attr;
+	}
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_CHGCUR)
+		pcf_sysfs_entries[i++] = &dev_attr_chgcur.attr;
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_BATVOLT)
+		pcf_sysfs_entries[i++] = &dev_attr_battvolt.attr;
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_BATTEMP)
+		pcf_sysfs_entries[i++] = &dev_attr_battemp.attr;
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_PWM) {
+		pcf_sysfs_entries[i++] = &dev_attr_pwm_dc.attr;
+		pcf_sysfs_entries[i++] = &dev_attr_pwm_clk.attr;
+	}
+}
+
+static int pcf50606_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct pcf50606_data *data;
+	int err = 0;
+	int irq;
+
+	if (!pcf50606_pdev) {
+		printk(KERN_ERR "pcf50606: driver needs a platform_device!\n");
+		return -EIO;
+	}
+
+	irq = platform_get_irq(pcf50606_pdev, 0);
+	if (irq < 0) {
+		dev_err(&pcf50606_pdev->dev, "no irq in platform resources!\n");
+		return -EIO;
+	}
+
+	/* At the moment, we only support one PCF50606 in a system */
+	if (pcf50606_global) {
+		dev_err(&pcf50606_pdev->dev,
+			"currently only one chip supported\n");
+		return -EBUSY;
+	}
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	mutex_init(&data->lock);
+	mutex_init(&data->working_lock);
+	INIT_WORK(&data->work, pcf50606_work);
+	data->irq = irq;
+	data->working = 0;
+	data->suppress_onkey_events = 0;
+	data->onkey_seconds = -1;
+	data->pdata = pcf50606_pdev->dev.platform_data;
+
+	new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &pcf50606_driver;
+	new_client->flags = 0;
+	strlcpy(new_client->name, "pcf50606", I2C_NAME_SIZE);
+
+	/* now we try to detect the chip */
+
+	/* register with i2c core */
+	err = i2c_attach_client(new_client);
+	if (err) {
+		dev_err(&new_client->dev,
+			"error during i2c_attach_client()\n");
+		goto exit_free;
+	}
+
+	populate_sysfs_group(data);
+
+	err = sysfs_create_group(&new_client->dev.kobj, &pcf_attr_group);
+	if (err) {
+		dev_err(&new_client->dev, "error creating sysfs group\n");
+		goto exit_detach;
+	}
+
+	/* create virtual charger 'device' */
+
+	/* input device registration */
+	data->input_dev = input_allocate_device();
+	if (!data->input_dev)
+		goto exit_sysfs;
+
+	data->input_dev->name = "FIC Neo1973 PMU events";
+	data->input_dev->phys = "I2C";
+	data->input_dev->id.bustype = BUS_I2C;
+
+	data->input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_PWR);
+	set_bit(KEY_POWER, data->input_dev->keybit);
+	set_bit(KEY_POWER2, data->input_dev->keybit);
+	set_bit(KEY_BATTERY, data->input_dev->keybit);
+
+	err = input_register_device(data->input_dev);
+	if (err)
+		goto exit_sysfs;
+
+	/* register power off handler with core power management */
+	pm_power_off = &pcf50606_go_standby;
+
+	/* configure interrupt mask */
+	/* we don't mask SECOND here, because we want one to do coldplug with */
+	reg_write(data, PCF50606_REG_INT1M, 0x00);
+	reg_write(data, PCF50606_REG_INT2M, 0x00);
+	reg_write(data, PCF50606_REG_INT3M, PCF50606_INT3_TSCPRES);
+
+	err = request_irq(irq, pcf50606_irq, IRQF_TRIGGER_FALLING,
+			  "pcf50606", data);
+	if (err < 0)
+		goto exit_input;
+
+	if (enable_irq_wake(irq) < 0)
+		dev_err(&new_client->dev, "IRQ %u cannot be enabled as wake-up"
+			"source in this hardware revision!", irq);
+
+	pcf50606_global = data;
+
+	if (data->pdata->used_features & PCF50606_FEAT_RTC) {
+		data->rtc = rtc_device_register("pcf50606", &new_client->dev,
+						&pcf50606_rtc_ops, THIS_MODULE);
+		if (IS_ERR(data->rtc)) {
+			err = PTR_ERR(data->rtc);
+			goto exit_irq;
+		}
+	}
+
+	if (data->pdata->used_features & PCF50606_FEAT_WDT) {
+		err = misc_register(&pcf50606_wdt_miscdev);
+		if (err) {
+			dev_err(&new_client->dev, "cannot register miscdev on "
+			       "minor=%d (%d)\n", WATCHDOG_MINOR, err);
+			goto exit_rtc;
+		}
+	}
+
+	if (data->pdata->used_features & PCF50606_FEAT_PWM) {
+		/* enable PWM controller */
+		reg_set_bit_mask(data, PCF50606_REG_PWMC1,
+				 PCF50606_PWMC1_ACTSET,
+				 PCF50606_PWMC1_ACTSET);
+	}
+
+	if (data->pdata->used_features & PCF50606_FEAT_PWM_BL) {
+		data->backlight = backlight_device_register("pcf50606-bl",
+							    &new_client->dev,
+							    data,
+							    &pcf50606bl_ops);
+		if (!data->backlight)
+			goto exit_misc;
+		data->backlight->props.max_brightness = 16;
+		data->backlight->props.power = FB_BLANK_UNBLANK;
+		data->backlight->props.brightness =
+					data->pdata->init_brightness;
+		backlight_update_status(data->backlight);
+	}
+
+	apm_get_power_status = pcf50606_get_power_status;
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	if (machine_is_neo1973_gta01()) {
+		gta01_pm_gps_dev.dev.parent = &new_client->dev;
+		switch (system_rev) {
+		case GTA01Bv2_SYSTEM_REV:
+		case GTA01Bv3_SYSTEM_REV:
+		case GTA01Bv4_SYSTEM_REV:
+			gta01_pm_bt_dev.dev.parent = &new_client->dev;
+			platform_device_register(&gta01_pm_bt_dev);
+			break;
+		}
+		platform_device_register(&gta01_pm_gps_dev);
+		/* a link for gllin compatibility */
+		err = bus_create_device_link(&platform_bus_type,
+			&gta01_pm_gps_dev.dev.kobj, "gta01-pm-gps.0");
+		if (err)
+			printk(KERN_ERR
+			    "sysfs_create_link (gta01-pm-gps.0): %d\n", err);
+	}
+#endif
+
+	if (data->pdata->used_features & PCF50606_FEAT_ACD)
+		reg_set_bit_mask(data, PCF50606_REG_ACDC1,
+				 PCF50606_ACDC1_ACDAPE, PCF50606_ACDC1_ACDAPE);
+	else
+		reg_clear_bits(data, PCF50606_REG_ACDC1,
+			       PCF50606_ACDC1_ACDAPE);
+
+	return 0;
+
+exit_misc:
+	if (data->pdata->used_features & PCF50606_FEAT_WDT)
+		misc_deregister(&pcf50606_wdt_miscdev);
+exit_rtc:
+	if (data->pdata->used_features & PCF50606_FEAT_RTC)
+		rtc_device_unregister(pcf50606_global->rtc);
+exit_irq:
+	free_irq(pcf50606_global->irq, pcf50606_global);
+	pcf50606_global = NULL;
+exit_input:
+	pm_power_off = NULL;
+	input_unregister_device(data->input_dev);
+exit_sysfs:
+	sysfs_remove_group(&new_client->dev.kobj, &pcf_attr_group);
+exit_detach:
+	i2c_detach_client(new_client);
+exit_free:
+	kfree(data);
+	return err;
+}
+
+static int pcf50606_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, &pcf50606_detect);
+}
+
+static int pcf50606_detach_client(struct i2c_client *client)
+{
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+
+	apm_get_power_status = NULL;
+	input_unregister_device(pcf->input_dev);
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_PWM_BL)
+		backlight_device_unregister(pcf->backlight);
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_WDT)
+		misc_deregister(&pcf50606_wdt_miscdev);
+
+	if (pcf->pdata->used_features & PCF50606_FEAT_RTC)
+		rtc_device_unregister(pcf->rtc);
+
+	free_irq(pcf->irq, pcf);
+
+	sysfs_remove_group(&client->dev.kobj, &pcf_attr_group);
+
+	pm_power_off = NULL;
+
+	kfree(pcf);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#define INT1M_RESUMERS	(PCF50606_INT1_ALARM | \
+			 PCF50606_INT1_ONKEYF | \
+			 PCF50606_INT1_EXTONR)
+#define INT2M_RESUMERS	(PCF50606_INT2_CHGWD10S | \
+			 PCF50606_INT2_CHGPROT | \
+			 PCF50606_INT2_CHGERR)
+#define INT3M_RESUMERS	(PCF50606_INT3_LOWBAT | \
+			 PCF50606_INT3_HIGHTMP | \
+			 PCF50606_INT3_ACDINS)
+static int pcf50606_suspend(struct device *dev, pm_message_t state)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+	int i;
+
+	/* we suspend once (!) as late as possible in the suspend sequencing */
+
+	if ((state.event != PM_EVENT_SUSPEND) ||
+	    (pcf->suspend_state != PCF50606_SS_RUNNING))
+		return -EBUSY;
+
+	/* The general idea is to power down all unused power supplies,
+	 * and then mask all PCF50606 interrup sources but EXTONR, ONKEYF
+	 * and ALARM */
+
+	mutex_lock(&pcf->lock);
+
+	pcf->suspend_state = PCF50606_SS_STARTING_SUSPEND;
+
+	/* we are not going to service any further interrupts until we
+	 * resume.  If the IRQ workqueue is still pending in the background,
+	 * it will bail when it sees we set suspend state above.
+	 */
+
+	disable_irq(pcf->irq);
+
+	/* Save all registers that don't "survive" standby state */
+	pcf->standby_regs.dcdc1 = __reg_read(pcf, PCF50606_REG_DCDC1);
+	pcf->standby_regs.dcdc2 = __reg_read(pcf, PCF50606_REG_DCDC2);
+	pcf->standby_regs.dcdec1 = __reg_read(pcf, PCF50606_REG_DCDEC1);
+	pcf->standby_regs.dcudc1 = __reg_read(pcf, PCF50606_REG_DCUDC1);
+	pcf->standby_regs.ioregc = __reg_read(pcf, PCF50606_REG_IOREGC);
+	pcf->standby_regs.d1regc1 = __reg_read(pcf, PCF50606_REG_D1REGC1);
+	pcf->standby_regs.d2regc1 = __reg_read(pcf, PCF50606_REG_D2REGC1);
+	pcf->standby_regs.d3regc1 = __reg_read(pcf, PCF50606_REG_D3REGC1);
+	pcf->standby_regs.lpregc1 = __reg_read(pcf, PCF50606_REG_LPREGC1);
+	pcf->standby_regs.adcc1 = __reg_read(pcf, PCF50606_REG_ADCC1);
+	pcf->standby_regs.adcc2 = __reg_read(pcf, PCF50606_REG_ADCC2);
+	pcf->standby_regs.pwmc1 = __reg_read(pcf, PCF50606_REG_PWMC1);
+
+	/* switch off power supplies that are not needed during suspend */
+	for (i = 0; i < __NUM_PCF50606_REGULATORS; i++) {
+		if (!(pcf->pdata->rails[i].flags & PMU_VRAIL_F_SUSPEND_ON)) {
+			u_int8_t tmp;
+
+			/* IOREG powers the I@C interface so we cannot switch
+			 * it off */
+			if (i == PCF50606_REGULATOR_IOREG)
+				continue;
+
+			dev_dbg(dev, "disabling pcf50606 regulator %u\n", i);
+			/* we cannot use pcf50606_onoff_set() because we're
+			 * already under the mutex */
+			tmp = __reg_read(pcf, regulator_registers[i]);
+			tmp &= 0x1f;
+			__reg_write(pcf, regulator_registers[i], tmp);
+		}
+	}
+
+	pcf->standby_regs.int1m = __reg_read(pcf, PCF50606_REG_INT1M);
+	pcf->standby_regs.int2m = __reg_read(pcf, PCF50606_REG_INT2M);
+	pcf->standby_regs.int3m = __reg_read(pcf, PCF50606_REG_INT3M);
+	__reg_write(pcf, PCF50606_REG_INT1M, ~INT1M_RESUMERS & 0xff);
+	__reg_write(pcf, PCF50606_REG_INT2M, ~INT2M_RESUMERS & 0xff);
+	__reg_write(pcf, PCF50606_REG_INT3M, ~INT3M_RESUMERS & 0xff);
+
+	pcf->suspend_state = PCF50606_SS_COMPLETED_SUSPEND;
+
+	mutex_unlock(&pcf->lock);
+
+	return 0;
+}
+
+static int pcf50606_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcf50606_data *pcf = i2c_get_clientdata(client);
+
+	mutex_lock(&pcf->lock);
+
+	pcf->suspend_state = PCF50606_SS_STARTING_RESUME;
+
+	/* Resume all saved registers that don't "survive" standby state */
+	__reg_write(pcf, PCF50606_REG_INT1M, pcf->standby_regs.int1m);
+	__reg_write(pcf, PCF50606_REG_INT2M, pcf->standby_regs.int2m);
+	__reg_write(pcf, PCF50606_REG_INT3M, pcf->standby_regs.int3m);
+
+	__reg_write(pcf, PCF50606_REG_DCDC1, pcf->standby_regs.dcdc1);
+	__reg_write(pcf, PCF50606_REG_DCDC2, pcf->standby_regs.dcdc2);
+	__reg_write(pcf, PCF50606_REG_DCDEC1, pcf->standby_regs.dcdec1);
+	__reg_write(pcf, PCF50606_REG_DCUDC1, pcf->standby_regs.dcudc1);
+	__reg_write(pcf, PCF50606_REG_IOREGC, pcf->standby_regs.ioregc);
+	__reg_write(pcf, PCF50606_REG_D1REGC1, pcf->standby_regs.d1regc1);
+	__reg_write(pcf, PCF50606_REG_D2REGC1, pcf->standby_regs.d2regc1);
+	__reg_write(pcf, PCF50606_REG_D3REGC1, pcf->standby_regs.d3regc1);
+	__reg_write(pcf, PCF50606_REG_LPREGC1, pcf->standby_regs.lpregc1);
+	__reg_write(pcf, PCF50606_REG_ADCC1, pcf->standby_regs.adcc1);
+	__reg_write(pcf, PCF50606_REG_ADCC2, pcf->standby_regs.adcc2);
+	__reg_write(pcf, PCF50606_REG_PWMC1, pcf->standby_regs.pwmc1);
+
+	pcf->suspend_state = PCF50606_SS_COMPLETED_RESUME;
+
+	enable_irq(pcf->irq);
+
+	mutex_unlock(&pcf->lock);
+
+	/* Call PCF work function; this fixes an issue on the gta01 where
+	 * the power button "goes away" if it is used to wake the device.
+	 */
+	get_device(&pcf->client.dev);
+	pcf50606_work(&pcf->work);
+
+	return 0;
+}
+#else
+#define pcf50606_suspend NULL
+#define pcf50606_resume NULL
+#endif
+
+static struct i2c_driver pcf50606_driver = {
+	.driver = {
+		.name	 = "pcf50606",
+		.suspend = pcf50606_suspend,
+		.resume	 = pcf50606_resume,
+	},
+	.id		= I2C_DRIVERID_PCF50606,
+	.attach_adapter	= pcf50606_attach_adapter,
+	.detach_client	= pcf50606_detach_client,
+};
+
+/* platform driver, since i2c devices don't have platform_data */
+static int __init pcf50606_plat_probe(struct platform_device *pdev)
+{
+	struct pcf50606_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata)
+		return -ENODEV;
+
+	pcf50606_pdev = pdev;
+
+	return 0;
+}
+
+static int pcf50606_plat_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+/* We have this purely to capture an early indication that we are coming out
+ * of suspend, before our device resume got called; async interrupt service is
+ * interested in this.
+ */
+
+static int pcf50606_plat_resume(struct platform_device *pdev)
+{
+	/* i2c_get_clientdata(to_i2c_client(&pdev->dev)) returns NULL at this
+	 * early resume time so we have to use pcf50606_global
+	 */
+	pcf50606_global->suspend_state = PCF50606_SS_RESUMING_BUT_NOT_US_YET;
+
+	return 0;
+}
+
+static struct platform_driver pcf50606_plat_driver = {
+	.probe	= pcf50606_plat_probe,
+	.remove	= pcf50606_plat_remove,
+	.resume_early = pcf50606_plat_resume,
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name 	= "pcf50606",
+	},
+};
+
+static int __init pcf50606_init(void)
+{
+	int rc;
+
+	rc = platform_driver_register(&pcf50606_plat_driver);
+	if (!rc)
+		rc = i2c_add_driver(&pcf50606_driver);
+
+	return rc;
+}
+
+static void pcf50606_exit(void)
+{
+	i2c_del_driver(&pcf50606_driver);
+	platform_driver_unregister(&pcf50606_plat_driver);
+}
+
+MODULE_DESCRIPTION("I2C chip driver for NXP PCF50606 power management unit");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_LICENSE("GPL");
+
+module_init(pcf50606_init);
+module_exit(pcf50606_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/pcf50606.h linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pcf50606.h
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/pcf50606.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pcf50606.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,302 @@
+#ifndef _PCF50606_H
+#define _PCF50606_H
+
+/* Philips PCF50606 Power Managemnt Unit (PMU) driver
+ * (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ */
+
+enum pfc50606_regs {
+	PCF50606_REG_ID		= 0x00,
+	PCF50606_REG_OOCS	= 0x01,
+	PCF50606_REG_INT1	= 0x02,	/* Interrupt Status */
+	PCF50606_REG_INT2	= 0x03,	/* Interrupt Status */
+	PCF50606_REG_INT3	= 0x04,	/* Interrupt Status */
+	PCF50606_REG_INT1M	= 0x05,	/* Interrupt Mask */
+	PCF50606_REG_INT2M	= 0x06,	/* Interrupt Mask */
+	PCF50606_REG_INT3M	= 0x07,	/* Interrupt Mask */
+	PCF50606_REG_OOCC1	= 0x08,
+	PCF50606_REG_OOCC2	= 0x09,
+	PCF50606_REG_RTCSC	= 0x0a,	/* Second */
+	PCF50606_REG_RTCMN	= 0x0b,	/* Minute */
+	PCF50606_REG_RTCHR	= 0x0c,	/* Hour */
+	PCF50606_REG_RTCWD	= 0x0d,	/* Weekday */
+	PCF50606_REG_RTCDT	= 0x0e,	/* Day */
+	PCF50606_REG_RTCMT	= 0x0f,	/* Month */
+	PCF50606_REG_RTCYR	= 0x10,	/* Year */
+	PCF50606_REG_RTCSCA	= 0x11, /* Alarm Second */
+	PCF50606_REG_RTCMNA	= 0x12, /* Alarm Minute */
+	PCF50606_REG_RTCHRA	= 0x13, /* Alarm Hour */
+	PCF50606_REG_RTCWDA	= 0x14, /* Alarm Weekday */
+	PCF50606_REG_RTCDTA	= 0x15, /* Alarm Day */
+	PCF50606_REG_RTCMTA	= 0x16, /* Alarm Month */
+	PCF50606_REG_RTCYRA	= 0x17, /* Alarm Year */
+	PCF50606_REG_PSSC	= 0x18,	/* Power sequencing */
+	PCF50606_REG_PWROKM	= 0x19,	/* PWROK mask */
+	PCF50606_REG_PWROKS	= 0x1a,	/* PWROK status */
+	PCF50606_REG_DCDC1	= 0x1b,
+	PCF50606_REG_DCDC2	= 0x1c,
+	PCF50606_REG_DCDC3	= 0x1d,
+	PCF50606_REG_DCDC4	= 0x1e,
+	PCF50606_REG_DCDEC1	= 0x1f,
+	PCF50606_REG_DCDEC2	= 0x20,
+	PCF50606_REG_DCUDC1	= 0x21,
+	PCF50606_REG_DCUDC2	= 0x22,
+	PCF50606_REG_IOREGC	= 0x23,
+	PCF50606_REG_D1REGC1	= 0x24,
+	PCF50606_REG_D2REGC1	= 0x25,
+	PCF50606_REG_D3REGC1	= 0x26,
+	PCF50606_REG_LPREGC1	= 0x27,
+	PCF50606_REG_LPREGC2	= 0x28,
+	PCF50606_REG_MBCC1	= 0x29,
+	PCF50606_REG_MBCC2	= 0x2a,
+	PCF50606_REG_MBCC3	= 0x2b,
+	PCF50606_REG_MBCS1	= 0x2c,
+	PCF50606_REG_BBCC	= 0x2d,
+	PCF50606_REG_ADCC1	= 0x2e,
+	PCF50606_REG_ADCC2	= 0x2f,
+	PCF50606_REG_ADCS1	= 0x30,
+	PCF50606_REG_ADCS2	= 0x31,
+	PCF50606_REG_ADCS3	= 0x32,
+	PCF50606_REG_ACDC1	= 0x33,
+	PCF50606_REG_BVMC	= 0x34,
+	PCF50606_REG_PWMC1	= 0x35,
+	PCF50606_REG_LEDC1	= 0x36,
+	PCF50606_REG_LEDC2	= 0x37,
+	PCF50606_REG_GPOC1	= 0x38,
+	PCF50606_REG_GPOC2	= 0x39,
+	PCF50606_REG_GPOC3	= 0x3a,
+	PCF50606_REG_GPOC4	= 0x3b,
+	PCF50606_REG_GPOC5	= 0x3c,
+	__NUM_PCF50606_REGS
+};
+
+enum pcf50606_reg_oocs {
+	PFC50606_OOCS_ONKEY	= 0x01,
+	PCF50606_OOCS_EXTON	= 0x02,
+	PCF50606_OOCS_PWROKRST	= 0x04,
+	PCF50606_OOCS_BATOK	= 0x08,
+	PCF50606_OOCS_BACKOK	= 0x10,
+	PCF50606_OOCS_CHGOK	= 0x20,
+	PCF50606_OOCS_TEMPOK	= 0x40,
+	PCF50606_OOCS_WDTEXP	= 0x80,
+};
+
+enum pcf50606_reg_oocc1 {
+	PCF50606_OOCC1_GOSTDBY	= 0x01,
+	PCF50606_OOCC1_TOTRST	= 0x02,
+	PCF50606_OOCC1_CLK32ON	= 0x04,
+	PCF50606_OOCC1_WDTRST	= 0x08,
+	PCF50606_OOCC1_RTCWAK	= 0x10,
+	PCF50606_OOCC1_CHGWAK	= 0x20,
+	PCF50606_OOCC1_EXTONWAK_HIGH	= 0x40,
+	PCF50606_OOCC1_EXTONWAK_LOW	= 0x80,
+};
+
+enum pcf50606_reg_oocc2 {
+	PCF50606_OOCC2_ONKEYDB_NONE	= 0x00,
+	PCF50606_OOCC2_ONKEYDB_14ms	= 0x01,
+	PCF50606_OOCC2_ONKEYDB_62ms	= 0x02,
+	PCF50606_OOCC2_ONKEYDB_500ms	= 0x03,
+	PCF50606_OOCC2_EXTONDB_NONE	= 0x00,
+	PCF50606_OOCC2_EXTONDB_14ms	= 0x04,
+	PCF50606_OOCC2_EXTONDB_62ms	= 0x08,
+	PCF50606_OOCC2_EXTONDB_500ms	= 0x0c,
+};
+
+enum pcf50606_reg_int1 {
+	PCF50606_INT1_ONKEYR	= 0x01,	/* ONKEY rising edge */
+	PCF50606_INT1_ONKEYF	= 0x02,	/* ONKEY falling edge */
+	PCF50606_INT1_ONKEY1S	= 0x04,	/* OMKEY at least 1sec low */
+	PCF50606_INT1_EXTONR	= 0x08,	/* EXTON rising edge */
+	PCF50606_INT1_EXTONF	= 0x10,	/* EXTON falling edge */
+	PCF50606_INT1_SECOND	= 0x40,	/* RTC periodic second interrupt */
+	PCF50606_INT1_ALARM	= 0x80, /* RTC alarm time is reached */
+};
+
+enum pcf50606_reg_int2 {
+	PCF50606_INT2_CHGINS	= 0x01, /* Charger inserted */
+	PCF50606_INT2_CHGRM	= 0x02, /* Charger removed */
+	PCF50606_INT2_CHGFOK	= 0x04,	/* Fast charging OK */
+	PCF50606_INT2_CHGERR	= 0x08,	/* Error in charging mode */
+	PCF50606_INT2_CHGFRDY	= 0x10,	/* Fast charge completed */
+	PCF50606_INT2_CHGPROT	= 0x20,	/* Charging protection interrupt */
+	PCF50606_INT2_CHGWD10S	= 0x40,	/* Charger watchdig expires in 10s */
+	PCF50606_INT2_CHGWDEXP	= 0x80,	/* Charger watchdog expires */
+};
+
+enum pcf50606_reg_int3 {
+	PCF50606_INT3_ADCRDY	= 0x01,	/* ADC conversion finished */
+	PCF50606_INT3_ACDINS	= 0x02,	/* Accessory inserted */
+	PCF50606_INT3_ACDREM	= 0x04, /* Accessory removed */
+	PCF50606_INT3_TSCPRES	= 0x08,	/* Touch screen pressed */
+	PCF50606_INT3_LOWBAT	= 0x40,	/* Low battery voltage */
+	PCF50606_INT3_HIGHTMP	= 0x80, /* High temperature */
+};
+
+/* used by PSSC, PWROKM, PWROKS, */
+enum pcf50606_regu {
+	PCF50606_REGU_DCD	= 0x01,	/* DCD in phase 2 */
+	PCF50606_REGU_DCDE	= 0x02,	/* DCDE in phase 2 */
+	PCF50606_REGU_DCUD	= 0x04,	/* DCDU in phase 2 */
+	PCF50606_REGU_IO	= 0x08,	/* IO in phase 2 */
+	PCF50606_REGU_D1	= 0x10, /* D1 in phase 2 */
+	PCF50606_REGU_D2	= 0x20,	/* D2 in phase 2 */
+	PCF50606_REGU_D3	= 0x40,	/* D3 in phase 2 */
+	PCF50606_REGU_LP	= 0x80,	/* LP in phase 2 */
+};
+
+enum pcf50606_reg_dcdc4 {
+	PCF50606_DCDC4_MODE_AUTO	= 0x00,
+	PCF50606_DCDC4_MODE_PWM		= 0x01,
+	PCF50606_DCDC4_MODE_PCF		= 0x02,
+	PCF50606_DCDC4_OFF_FLOAT	= 0x00,
+	PCF50606_DCDC4_OFF_BYPASS	= 0x04,
+	PCF50606_DCDC4_OFF_PULLDOWN	= 0x08,
+	PCF50606_DCDC4_CURLIM_500mA	= 0x00,
+	PCF50606_DCDC4_CURLIM_750mA	= 0x10,
+	PCF50606_DCDC4_CURLIM_1000mA	= 0x20,
+	PCF50606_DCDC4_CURLIM_1250mA	= 0x30,
+	PCF50606_DCDC4_TOGGLE		= 0x40,
+	PCF50606_DCDC4_REGSEL_DCDC2	= 0x80,
+};
+
+enum pcf50606_reg_dcdec2 {
+	PCF50606_DCDEC2_MODE_AUTO	= 0x00,
+	PCF50606_DCDEC2_MODE_PWM	= 0x01,
+	PCF50606_DCDEC2_MODE_PCF	= 0x02,
+	PCF50606_DCDEC2_OFF_FLOAT	= 0x00,
+	PCF50606_DCDEC2_OFF_BYPASS	= 0x04,
+};
+
+enum pcf50606_reg_dcudc2 {
+	PCF50606_DCUDC2_MODE_AUTO	= 0x00,
+	PCF50606_DCUDC2_MODE_PWM	= 0x01,
+	PCF50606_DCUDC2_MODE_PCF	= 0x02,
+	PCF50606_DCUDC2_OFF_FLOAT	= 0x00,
+	PCF50606_DCUDC2_OFF_BYPASS	= 0x04,
+};
+
+enum pcf50606_reg_adcc1 {
+	PCF50606_ADCC1_TSCMODACT	= 0x01,
+	PCF50606_ADCC1_TSCMODSTB	= 0x02,
+	PCF50606_ADCC1_TRATSET		= 0x04,
+	PCF50606_ADCC1_NTCSWAPE		= 0x08,
+	PCF50606_ADCC1_NTCSWAOFF	= 0x10,
+	PCF50606_ADCC1_EXTSYNCBREAK	= 0x20,
+	/* reserved */
+	PCF50606_ADCC1_TSCINT		= 0x80,
+};
+
+enum pcf50606_reg_adcc2 {
+	PCF50606_ADCC2_ADCSTART		= 0x01,
+	/* see enum pcf50606_adcc2_adcmux */
+	PCF50606_ADCC2_SYNC_NONE	= 0x00,
+	PCF50606_ADCC2_SYNC_TXON	= 0x20,
+	PCF50606_ADCC2_SYNC_PWREN1	= 0x40,
+	PCF50606_ADCC2_SYNC_PWREN2	= 0x60,
+	PCF50606_ADCC2_RES_10BIT	= 0x00,
+	PCF50606_ADCC2_RES_8BIT		= 0x80,
+};
+
+#define PCF50606_ADCC2_ADCMUX_MASK	(0xf << 1)
+
+#define ADCMUX_SHIFT	1
+enum pcf50606_adcc2_adcmux {
+	PCF50606_ADCMUX_BATVOLT_RES	= 0x0 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_BATVOLT_SUBTR	= 0x1 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN1_RES	= 0x2 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN1_SUBTR	= 0x3 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_BATTEMP		= 0x4 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN2		= 0x5 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN3		= 0x6 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_ADCIN3_RATIO	= 0x7 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_XPOS		= 0x8 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_YPOS		= 0x9 << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_P1		= 0xa << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_P2		= 0xb << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_BATVOLT_ADCIN1	= 0xc << ADCMUX_SHIFT,
+	PCF50606_ADCMUX_XY_SEQUENCE	= 0xe << ADCMUX_SHIFT,
+	PCF50606_P1_P2_RESISTANCE	= 0xf << ADCMUX_SHIFT,
+};
+
+enum pcf50606_adcs2 {
+	PCF50606_ADCS2_ADCRDY		= 0x80,
+};
+
+enum pcf50606_reg_mbcc1 {
+	PCF50606_MBCC1_CHGAPE		= 0x01,
+	PCF50606_MBCC1_AUTOFST		= 0x02,
+#define	PCF50606_MBCC1_CHGMOD_MASK	  0x1c
+#define	PCF50606_MBCC1_CHGMOD_SHIFT	  2
+	PCF50606_MBCC1_CHGMOD_QUAL	= 0x00,
+	PCF50606_MBCC1_CHGMOD_PRE	= 0x04,
+	PCF50606_MBCC1_CHGMOD_TRICKLE	= 0x08,
+	PCF50606_MBCC1_CHGMOD_FAST_CCCV	= 0x0c,
+	PCF50606_MBCC1_CHGMOD_FAST_NOCC	= 0x10,
+	PCF50606_MBCC1_CHGMOD_FAST_NOCV	= 0x14,
+	PCF50606_MBCC1_CHGMOD_FAST_SW	= 0x18,
+	PCF50606_MBCC1_CHGMOD_IDLE	= 0x1c,
+	PCF50606_MBCC1_DETMOD_LOWCHG	= 0x20,
+	PCF50606_MBCC1_DETMOD_WDRST	= 0x40,
+};
+
+enum pcf50606_reg_acdc1 {
+	PCF50606_ACDC1_ACDDET		= 0x01,
+	PCF50606_ACDC1_THRSHLD_1V0	= 0x00,
+	PCF50606_ACDC1_THRSHLD_1V2	= 0x02,
+	PCF50606_ACDC1_THRSHLD_1V4	= 0x04,
+	PCF50606_ACDC1_THRSHLD_1V6	= 0x06,
+	PCF50606_ACDC1_THRSHLD_1V8	= 0x08,
+	PCF50606_ACDC1_THRSHLD_2V0	= 0x0a,
+	PCF50606_ACDC1_THRSHLD_2V2	= 0x0c,
+	PCF50606_ACDC1_THRSHLD_2V4	= 0x0e,
+	PCF50606_ACDC1_DISDB		= 0x10,
+	PCF50606_ACDC1_ACDAPE		= 0x80,
+};
+
+enum pcf50606_reg_bvmc {
+	PCF50606_BVMC_LOWBAT		= 0x01,
+	PCF50606_BVMC_THRSHLD_NULL	= 0x00,
+	PCF50606_BVMC_THRSHLD_2V8	= 0x02,
+	PCF50606_BVMC_THRSHLD_2V9	= 0x04,
+	PCF50606_BVMC_THRSHLD_3V	= 0x08,
+	PCF50606_BVMC_THRSHLD_3V1	= 0x08,
+	PCF50606_BVMC_THRSHLD_3V2	= 0x0a,
+	PCF50606_BVMC_THRSHLD_3V3	= 0x0c,
+	PCF50606_BVMC_THRSHLD_3V4	= 0x0e,
+	PCF50606_BVMC_DISDB		= 0x10,
+};
+
+enum pcf50606_reg_pwmc1 {
+	PCF50606_PWMC1_ACTSET		= 0x01,
+	PCF50606_PWMC1_PWMDC_0_16	= 0x00,
+	PCF50606_PWMC1_PWMDC_1_16	= 0x02,
+	PCF50606_PWMC1_PWMDC_2_16	= 0x04,
+	PCF50606_PWMC1_PWMDC_3_16	= 0x06,
+	PCF50606_PWMC1_PWMDC_4_16	= 0x08,
+	PCF50606_PWMC1_PWMDC_5_16	= 0x0a,
+	PCF50606_PWMC1_PWMDC_6_16	= 0x0c,
+	PCF50606_PWMC1_PWMDC_7_16	= 0x0e,
+	PCF50606_PWMC1_PWMDC_8_16	= 0x10,
+	PCF50606_PWMC1_PWMDC_9_16	= 0x12,
+	PCF50606_PWMC1_PWMDC_10_16	= 0x14,
+	PCF50606_PWMC1_PWMDC_11_16	= 0x16,
+	PCF50606_PWMC1_PWMDC_12_16	= 0x18,
+	PCF50606_PWMC1_PWMDC_13_16	= 0x1a,
+	PCF50606_PWMC1_PWMDC_14_16	= 0x1c,
+	PCF50606_PWMC1_PWMDC_15_16	= 0x1e,
+	PCF50606_PWMC1_PRESC_512Hz	= 0x20,
+	PCF50606_PWMC1_PRESC_256Hz	= 0x40,
+	PCF50606_PWMC1_PRESC_64Hz	= 0x60,
+	PCF50606_PWMC1_PRESC_56kHz	= 0x80,
+	PCF50606_PWMC1_PRESC_28kHz	= 0xa0,
+	PCF50606_PWMC1_PRESC_14kHz	= 0xc0,
+	PCF50606_PWMC1_PRESC_7kHz	= 0xe0,
+};
+#define PCF50606_PWMC1_CLK_SHIFT	5
+#define PCF50606_PWMC1_DC_SHIFT		1
+
+#endif /* _PCF50606_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/chips/pcf50633.h linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pcf50633.h
--- linux-2.6.29-rc3.owrt/drivers/i2c/chips/pcf50633.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/chips/pcf50633.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,349 @@
+#ifndef _PCF50633_H
+#define _PCF50633_H
+
+/* Philips PCF50633 Power Managemnt Unit (PMU) driver
+ * (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ */
+
+enum pfc50633_regs {
+	PCF50633_REG_VERSION	= 0x00,
+	PCF50633_REG_VARIANT	= 0x01,
+	PCF50633_REG_INT1	= 0x02,	/* Interrupt Status */
+	PCF50633_REG_INT2	= 0x03,	/* Interrupt Status */
+	PCF50633_REG_INT3	= 0x04,	/* Interrupt Status */
+	PCF50633_REG_INT4	= 0x05,	/* Interrupt Status */
+	PCF50633_REG_INT5	= 0x06,	/* Interrupt Status */
+	PCF50633_REG_INT1M	= 0x07,	/* Interrupt Mask */
+	PCF50633_REG_INT2M	= 0x08,	/* Interrupt Mask */
+	PCF50633_REG_INT3M	= 0x09,	/* Interrupt Mask */
+	PCF50633_REG_INT4M	= 0x0a,	/* Interrupt Mask */
+	PCF50633_REG_INT5M	= 0x0b,	/* Interrupt Mask */
+	PCF50633_REG_OOCSHDWN	= 0x0c,
+	PCF50633_REG_OOCWAKE	= 0x0d,
+	PCF50633_REG_OOCTIM1	= 0x0e,
+	PCF50633_REG_OOCTIM2	= 0x0f,
+	PCF50633_REG_OOCMODE	= 0x10,
+	PCF50633_REG_OOCCTL	= 0x11,
+	PCF50633_REG_OOCSTAT	= 0x12,
+	PCF50633_REG_GPIOCTL	= 0x13,
+	PCF50633_REG_GPIO1CFG	= 0x14,
+	PCF50633_REG_GPIO2CFG	= 0x15,
+	PCF50633_REG_GPIO3CFG	= 0x16,
+	PCF50633_REG_GPOCFG	= 0x17,
+	PCF50633_REG_BVMCTL	= 0x18,
+	PCF50633_REG_SVMCTL	= 0x19,
+	PCF50633_REG_AUTOOUT	= 0x1a,
+	PCF50633_REG_AUTOENA	= 0x1b,
+	PCF50633_REG_AUTOCTL	= 0x1c,
+	PCF50633_REG_AUTOMXC	= 0x1d,
+	PCF50633_REG_DOWN1OUT	= 0x1e,
+	PCF50633_REG_DOWN1ENA	= 0x1f,
+	PCF50633_REG_DOWN1CTL	= 0x20,
+	PCF50633_REG_DOWN1MXC	= 0x21,
+	PCF50633_REG_DOWN2OUT	= 0x22,
+	PCF50633_REG_DOWN2ENA	= 0x23,
+	PCF50633_REG_DOWN2CTL	= 0x24,
+	PCF50633_REG_DOWN2MXC	= 0x25,
+	PCF50633_REG_MEMLDOOUT	= 0x26,
+	PCF50633_REG_MEMLDOENA	= 0x27,
+	PCF50633_REG_LEDOUT	= 0x28,
+	PCF50633_REG_LEDENA	= 0x29,
+	PCF50633_REG_LEDCTL	= 0x2a,
+	PCF50633_REG_LEDDIM	= 0x2b,
+	/* reserved */
+	PCF50633_REG_LDO1OUT	= 0x2d,
+	PCF50633_REG_LDO1ENA	= 0x2e,
+	PCF50633_REG_LDO2OUT	= 0x2f,
+	PCF50633_REG_LDO2ENA	= 0x30,
+	PCF50633_REG_LDO3OUT	= 0x31,
+	PCF50633_REG_LDO3ENA	= 0x32,
+	PCF50633_REG_LDO4OUT	= 0x33,
+	PCF50633_REG_LDO4ENA	= 0x34,
+	PCF50633_REG_LDO5OUT	= 0x35,
+	PCF50633_REG_LDO5ENA	= 0x36,
+	PCF50633_REG_LDO6OUT	= 0x37,
+	PCF50633_REG_LDO6ENA	= 0x38,
+	PCF50633_REG_HCLDOOUT	= 0x39,
+	PCF50633_REG_HCLDOENA	= 0x3a,
+	PCF50633_REG_STBYCTL1	= 0x3b,
+	PCF50633_REG_STBYCTL2	= 0x3c,
+	PCF50633_REG_DEBPF1	= 0x3d,
+	PCF50633_REG_DEBPF2	= 0x3e,
+	PCF50633_REG_DEBPF3	= 0x3f,
+	PCF50633_REG_HCLDOOVL	= 0x40,
+	PCF50633_REG_DCDCSTAT	= 0x41,
+	PCF50633_REG_LDOSTAT	= 0x42,
+	PCF50633_REG_MBCC1	= 0x43,
+	PCF50633_REG_MBCC2	= 0x44,
+	PCF50633_REG_MBCC3	= 0x45,
+	PCF50633_REG_MBCC4	= 0x46,
+	PCF50633_REG_MBCC5	= 0x47,
+	PCF50633_REG_MBCC6	= 0x48,
+	PCF50633_REG_MBCC7	= 0x49,
+	PCF50633_REG_MBCC8	= 0x4a,
+	PCF50633_REG_MBCS1	= 0x4b,
+	PCF50633_REG_MBCS2	= 0x4c,
+	PCF50633_REG_MBCS3	= 0x4d,
+	PCF50633_REG_BBCCTL	= 0x4e,
+	PCF50633_REG_ALMGAIN	= 0x4f,
+	PCF50633_REG_ALMDATA	= 0x50,
+	/* reserved */
+	PCF50633_REG_ADCC3	= 0x52,
+	PCF50633_REG_ADCC2	= 0x53,
+	PCF50633_REG_ADCC1	= 0x54,
+	PCF50633_REG_ADCS1	= 0x55,
+	PCF50633_REG_ADCS2	= 0x56,
+	PCF50633_REG_ADCS3	= 0x57,
+	/* reserved */
+	PCF50633_REG_RTCSC	= 0x59,	/* Second */
+	PCF50633_REG_RTCMN	= 0x5a,	/* Minute */
+	PCF50633_REG_RTCHR	= 0x5b,	/* Hour */
+	PCF50633_REG_RTCWD	= 0x5c,	/* Weekday */
+	PCF50633_REG_RTCDT	= 0x5d,	/* Day */
+	PCF50633_REG_RTCMT	= 0x5e,	/* Month */
+	PCF50633_REG_RTCYR	= 0x5f,	/* Year */
+	PCF50633_REG_RTCSCA	= 0x60, /* Alarm Second */
+	PCF50633_REG_RTCMNA	= 0x61, /* Alarm Minute */
+	PCF50633_REG_RTCHRA	= 0x62, /* Alarm Hour */
+	PCF50633_REG_RTCWDA	= 0x63, /* Alarm Weekday */
+	PCF50633_REG_RTCDTA	= 0x64, /* Alarm Day */
+	PCF50633_REG_RTCMTA	= 0x65, /* Alarm Month */
+	PCF50633_REG_RTCYRA	= 0x66, /* Alarm Year */
+
+	PCF50633_REG_MEMBYTE0	= 0x67,
+	PCF50633_REG_MEMBYTE1	= 0x68,
+	PCF50633_REG_MEMBYTE2	= 0x69,
+	PCF50633_REG_MEMBYTE3	= 0x6a,
+	PCF50633_REG_MEMBYTE4	= 0x6b,
+	PCF50633_REG_MEMBYTE5	= 0x6c,
+	PCF50633_REG_MEMBYTE6	= 0x6d,
+	PCF50633_REG_MEMBYTE7	= 0x6e,
+	/* reserved */
+	PCF50633_REG_DCDCPFM	= 0x84,
+	__NUM_PCF50633_REGS
+};
+
+
+enum pcf50633_reg_oocshdwn {
+	PCF50633_OOCSHDWN_GOSTDBY	= 0x01,
+	PCF50633_OOCSHDWN_TOTRST	= 0x04,
+	PCF50633_OOCSHDWN_COLDBOOT	= 0x08,
+};
+
+enum pcf50633_reg_oocwake {
+	PCF50633_OOCWAKE_ONKEY		= 0x01,
+	PCF50633_OOCWAKE_EXTON1		= 0x02,
+	PCF50633_OOCWAKE_EXTON2		= 0x04,
+	PCF50633_OOCWAKE_EXTON3		= 0x08,
+	PCF50633_OOCWAKE_RTC		= 0x10,
+	/* reserved */
+	PCF50633_OOCWAKE_USB		= 0x40,
+	PCF50633_OOCWAKE_ADP		= 0x80,
+};
+
+enum pcf50633_reg_mbcc1 {
+	PCF50633_MBCC1_CHGENA		= 0x01,	/* Charger enable */
+	PCF50633_MBCC1_AUTOSTOP		= 0x02,
+	PCF50633_MBCC1_AUTORES		= 0x04, /* automatic resume */
+	PCF50633_MBCC1_RESUME		= 0x08, /* explicit resume cmd */
+	PCF50633_MBCC1_RESTART		= 0x10, /* restart charging */
+	PCF50633_MBCC1_PREWDTIME_60M	= 0x20,	/* max. precharging time */
+	PCF50633_MBCC1_WDTIME_1H	= 0x00,
+	PCF50633_MBCC1_WDTIME_2H	= 0x40,
+	PCF50633_MBCC1_WDTIME_4H	= 0x80,
+	PCF50633_MBCC1_WDTIME_6H	= 0xc0,
+};
+#define PCF50633_MBCC1_WDTIME_MASK	  0xc0
+
+enum pcf50633_reg_mbcc2 {
+	PCF50633_MBCC2_VBATCOND_2V7	= 0x00,
+	PCF50633_MBCC2_VBATCOND_2V85	= 0x01,
+	PCF50633_MBCC2_VBATCOND_3V0	= 0x02,
+	PCF50633_MBCC2_VBATCOND_3V15	= 0x03,
+	PCF50633_MBCC2_VMAX_4V		= 0x00,
+	PCF50633_MBCC2_VMAX_4V20	= 0x28,
+	PCF50633_MBCC2_VRESDEBTIME_64S	= 0x80,	/* debounce time (32/64sec) */
+};
+#define	PCF50633_MBCC2_VBATCOND_MASK	  0x03
+#define PCF50633_MBCC2_VMAX_MASK	  0x3c
+
+enum pcf50633_reg_adcc1 {
+	PCF50633_ADCC1_ADCSTART		= 0x01,
+	PCF50633_ADCC1_RES_10BIT	= 0x02,
+	PCF50633_ADCC1_AVERAGE_NO	= 0x00,
+	PCF50633_ADCC1_AVERAGE_4	= 0x04,
+	PCF50633_ADCC1_AVERAGE_8	= 0x08,
+	PCF50633_ADCC1_AVERAGE_16	= 0x0c,
+
+	PCF50633_ADCC1_MUX_BATSNS_RES	= 0x00,
+	PCF50633_ADCC1_MUX_BATSNS_SUBTR	= 0x10,
+	PCF50633_ADCC1_MUX_ADCIN2_RES	= 0x20,
+	PCF50633_ADCC1_MUX_ADCIN2_SUBTR	= 0x30,
+	PCF50633_ADCC1_MUX_BATTEMP	= 0x60,
+	PCF50633_ADCC1_MUX_ADCIN1	= 0x70,
+};
+#define PCF50633_ADCC1_AVERAGE_MASK	0x0c
+#define	PCF50633_ADCC1_ADCMUX_MASK	0xf0
+
+enum pcf50633_reg_adcc2 {
+	PCF50633_ADCC2_RATIO_NONE	= 0x00,
+	PCF50633_ADCC2_RATIO_BATTEMP	= 0x01,
+	PCF50633_ADCC2_RATIO_ADCIN1	= 0x02,
+	PCF50633_ADCC2_RATIO_BOTH	= 0x03,
+	PCF50633_ADCC2_RATIOSETTL_100US	= 0x04,
+};
+#define PCF50633_ADCC2_RATIO_MASK	0x03
+
+enum pcf50633_reg_adcc3 {
+	PCF50633_ADCC3_ACCSW_EN		= 0x01,
+	PCF50633_ADCC3_NTCSW_EN		= 0x04,
+	PCF50633_ADCC3_RES_DIV_TWO	= 0x10,
+	PCF50633_ADCC3_RES_DIV_THREE	= 0x00,
+};
+
+enum pcf50633_reg_adcs3 {
+	PCF50633_ADCS3_REF_NTCSW	= 0x00,
+	PCF50633_ADCS3_REF_ACCSW	= 0x10,
+	PCF50633_ADCS3_REF_2V0		= 0x20,
+	PCF50633_ADCS3_REF_VISA		= 0x30,
+	PCF50633_ADCS3_REF_2V0_2	= 0x70,
+	PCF50633_ADCS3_ADCRDY		= 0x80,
+};
+#define PCF50633_ADCS3_ADCDAT1L_MASK	0x03
+#define PCF50633_ADCS3_ADCDAT2L_MASK	0x0c
+#define PCF50633_ADCS3_ADCDAT2L_SHIFT	2
+#define PCF50633_ASCS3_REF_MASK		0x70
+
+enum pcf50633_regulator_enable {
+	PCF50633_REGULATOR_ON		= 0x01,
+	PCF50633_REGULATOR_ON_GPIO1	= 0x02,
+	PCF50633_REGULATOR_ON_GPIO2	= 0x04,
+	PCF50633_REGULATOR_ON_GPIO3	= 0x08,
+};
+#define PCF50633_REGULATOR_ON_MASK	0x0f
+
+enum pcf50633_regulator_phase {
+	PCF50633_REGULATOR_ACTPH1	= 0x00,
+	PCF50633_REGULATOR_ACTPH2	= 0x10,
+	PCF50633_REGULATOR_ACTPH3	= 0x20,
+	PCF50633_REGULATOR_ACTPH4	= 0x30,
+};
+#define PCF50633_REGULATOR_ACTPH_MASK	0x30
+
+enum pcf50633_reg_gpocfg {
+	PCF50633_GPOCFG_GPOSEL_0	= 0x00,
+	PCF50633_GPOCFG_GPOSEL_LED_NFET	= 0x01,
+	PCF50633_GPOCFG_GPOSEL_SYSxOK	= 0x02,
+	PCF50633_GPOCFG_GPOSEL_CLK32K	= 0x03,
+	PCF50633_GPOCFG_GPOSEL_ADAPUSB	= 0x04,
+	PCF50633_GPOCFG_GPOSEL_USBxOK	= 0x05,
+	PCF50633_GPOCFG_GPOSEL_ACTPH4	= 0x06,
+	PCF50633_GPOCFG_GPOSEL_1	= 0x07,
+	PCF50633_GPOCFG_GPOSEL_INVERSE	= 0x08,
+};
+#define PCF50633_GPOCFG_GPOSEL_MASK	0x07
+
+#if 0
+enum pcf50633_reg_mbcc1 {
+	PCF50633_MBCC1_CHGENA		= 0x01,
+	PCF50633_MBCC1_AUTOSTOP		= 0x02,
+	PCF50633_MBCC1_AUTORES		= 0x04,
+	PCF50633_MBCC1_RESUME		= 0x08,
+	PCF50633_MBCC1_RESTART		= 0x10,
+	PCF50633_MBCC1_PREWDTIME_30MIN	= 0x00,
+	PCF50633_MBCC1_PREWDTIME_60MIN	= 0x20,
+	PCF50633_MBCC1_WDTIME_2HRS	= 0x40,
+	PCF50633_MBCC1_WDTIME_4HRS	= 0x80,
+	PCF50633_MBCC1_WDTIME_6HRS	= 0xc0,
+};
+
+enum pcf50633_reg_mbcc2 {
+	PCF50633_MBCC2_VBATCOND_2V7	= 0x00,
+	PCF50633_MBCC2_VBATCOND_2V85	= 0x01,
+	PCF50633_MBCC2_VBATCOND_3V0	= 0x02,
+	PCF50633_MBCC2_VBATCOND_3V15	= 0x03,
+	PCF50633_MBCC2_VRESDEBTIME_64S	= 0x80,
+};
+#define PCF50633_MBCC2_VMAX_MASK	0x3c
+#endif
+
+enum pcf50633_reg_mbcc7 {
+	PCF50633_MBCC7_USB_100mA	= 0x00,
+	PCF50633_MBCC7_USB_500mA	= 0x01,
+	PCF50633_MBCC7_USB_1000mA	= 0x02,
+	PCF50633_MBCC7_USB_SUSPEND	= 0x03,
+	PCF50633_MBCC7_BATTEMP_EN	= 0x04,
+	PCF50633_MBCC7_BATSYSIMAX_1A6	= 0x00,
+	PCF50633_MBCC7_BATSYSIMAX_1A8	= 0x40,
+	PCF50633_MBCC7_BATSYSIMAX_2A0	= 0x80,
+	PCF50633_MBCC7_BATSYSIMAX_2A2	= 0xc0,
+};
+#define PCF56033_MBCC7_USB_MASK		0x03
+
+enum pcf50633_reg_mbcc8 {
+	PCF50633_MBCC8_USBENASUS	= 0x10,
+};
+
+enum pcf50633_reg_mbcs1 {
+	PCF50633_MBCS1_USBPRES		= 0x01,
+	PCF50633_MBCS1_USBOK		= 0x02,
+	PCF50633_MBCS1_ADAPTPRES	= 0x04,
+	PCF50633_MBCS1_ADAPTOK		= 0x08,
+	PCF50633_MBCS1_TBAT_OK		= 0x00,
+	PCF50633_MBCS1_TBAT_ABOVE	= 0x10,
+	PCF50633_MBCS1_TBAT_BELOW	= 0x20,
+	PCF50633_MBCS1_TBAT_UNDEF	= 0x30,
+	PCF50633_MBCS1_PREWDTEXP	= 0x40,
+	PCF50633_MBCS1_WDTEXP		= 0x80,
+};
+
+enum pcf50633_reg_mbcs2_mbcmod {
+	PCF50633_MBCS2_MBC_PLAY		= 0x00,
+	PCF50633_MBCS2_MBC_USB_PRE	= 0x01,
+	PCF50633_MBCS2_MBC_USB_PRE_WAIT	= 0x02,
+	PCF50633_MBCS2_MBC_USB_FAST	= 0x03,
+	PCF50633_MBCS2_MBC_USB_FAST_WAIT= 0x04,
+	PCF50633_MBCS2_MBC_USB_SUSPEND	= 0x05,
+	PCF50633_MBCS2_MBC_ADP_PRE	= 0x06,
+	PCF50633_MBCS2_MBC_ADP_PRE_WAIT	= 0x07,
+	PCF50633_MBCS2_MBC_ADP_FAST	= 0x08,
+	PCF50633_MBCS2_MBC_ADP_FAST_WAIT= 0x09,
+	PCF50633_MBCS2_MBC_BAT_FULL	= 0x0a,
+	PCF50633_MBCS2_MBC_HALT		= 0x0b,
+};
+#define PCF50633_MBCS2_MBC_MASK		0x0f
+enum pcf50633_reg_mbcs2_chgstat {
+	PCF50633_MBCS2_CHGS_NONE	= 0x00,
+	PCF50633_MBCS2_CHGS_ADAPTER	= 0x10,
+	PCF50633_MBCS2_CHGS_USB		= 0x20,
+	PCF50633_MBCS2_CHGS_BOTH	= 0x30,
+};
+#define PCF50633_MBCS2_RESSTAT_AUTO	0x40
+
+enum pcf50633_reg_mbcs3 {
+	PCF50633_MBCS3_USBLIM_PLAY	= 0x01,
+	PCF50633_MBCS3_USBLIM_CGH	= 0x02,
+	PCF50633_MBCS3_TLIM_PLAY	= 0x04,
+	PCF50633_MBCS3_TLIM_CHG		= 0x08,
+	PCF50633_MBCS3_ILIM		= 0x10,	/* 1: Ibat > Icutoff */
+	PCF50633_MBCS3_VLIM		= 0x20,	/* 1: Vbat == Vmax */
+	PCF50633_MBCS3_VBATSTAT		= 0x40,	/* 1: Vbat > Vbatcond */
+	PCF50633_MBCS3_VRES		= 0x80, /* 1: Vbat > Vth(RES) */
+};
+
+/* this is to be provided by the board implementation */
+extern const u_int8_t pcf50633_initial_regs[__NUM_PCF50633_REGS];
+
+void pcf50633_reg_write(u_int8_t reg, u_int8_t val);
+
+u_int8_t pcf50633_reg_read(u_int8_t reg);
+
+void pcf50633_reg_set_bit_mask(u_int8_t reg, u_int8_t mask, u_int8_t val);
+void pcf50633_reg_clear_bits(u_int8_t reg, u_int8_t bits);
+
+void pcf50633_charge_autofast(int on);
+
+#endif /* _PCF50606_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/i2c/i2c-core.c linux-2.6.29-rc3.owrt.om/drivers/i2c/i2c-core.c
--- linux-2.6.29-rc3.owrt/drivers/i2c/i2c-core.c	2009-05-10 22:08:42.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/i2c/i2c-core.c	2009-05-10 22:27:59.000000000 +0200
@@ -1,4 +1,3 @@
-/* i2c-core.c - a device driver for the iic-bus interface		     */
 /* ------------------------------------------------------------------------- */
 /*   Copyright (C) 1995-99 Simon G. Vogl
 
@@ -158,10 +157,16 @@
 
 	if (!dev->driver)
 		return 0;
+#if 0
 	driver = to_i2c_driver(dev->driver);
 	if (!driver->suspend)
 		return 0;
 	return driver->suspend(to_i2c_client(dev), mesg);
+#else
+	if (!dev->driver->suspend)
+		return 0;
+	return dev->driver->suspend(dev, mesg);
+#endif
 }
 
 static int i2c_device_resume(struct device * dev)
@@ -170,10 +175,16 @@
 
 	if (!dev->driver)
 		return 0;
+#if 0
 	driver = to_i2c_driver(dev->driver);
 	if (!driver->resume)
 		return 0;
 	return driver->resume(to_i2c_client(dev));
+#else
+	if (!dev->driver->resume)
+		return 0;
+	return dev->driver->resume(dev);
+#endif
 }
 
 static void i2c_client_release(struct device *dev)
@@ -1129,11 +1140,11 @@
 	int err;
 
 	/* Make sure the address is valid */
-	if (addr < 0x03 || addr > 0x77) {
+	/*if (addr < 0x03 || addr > 0x77) {
 		dev_warn(&adapter->dev, "Invalid probe address 0x%02x\n",
 			 addr);
 		return -EINVAL;
-	}
+	}*/
 
 	/* Skip if already in use */
 	if (i2c_check_addr(adapter, addr))
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/keyboard/gpio_keys.c linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/gpio_keys.c
--- linux-2.6.29-rc3.owrt/drivers/input/keyboard/gpio_keys.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/gpio_keys.c	2009-05-10 22:27:59.000000000 +0200
@@ -23,7 +23,7 @@
 #include <linux/input.h>
 #include <linux/gpio_keys.h>
 
-#include <asm/gpio.h>
+#include <mach/gpio.h>
 
 struct gpio_button_data {
 	struct gpio_keys_button *button;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/keyboard/Kconfig linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/input/keyboard/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -332,4 +332,21 @@
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called sh_keysc.
+config KEYBOARD_NEO1973
+	tristate "FIC Neo1973 buttons"
+	depends on MACH_NEO1973
+	default y
+	help
+	  Say Y here to enable the buttons on the FIC Neo1973
+	  GSM phone.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called neo1973kbd.
+
+config KEYBOARD_QT2410
+	tristate "QT2410 buttons"
+	depends on MACH_QT2410
+	default y
+
+
 endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/keyboard/Makefile linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/Makefile
--- linux-2.6.29-rc3.owrt/drivers/input/keyboard/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -14,6 +14,8 @@
 obj-$(CONFIG_KEYBOARD_NEWTON)		+= newtonkbd.o
 obj-$(CONFIG_KEYBOARD_STOWAWAY)		+= stowaway.o
 obj-$(CONFIG_KEYBOARD_CORGI)		+= corgikbd.o
+obj-$(CONFIG_KEYBOARD_NEO1973)		+= neo1973kbd.o
+obj-$(CONFIG_KEYBOARD_QT2410)		+= qt2410kbd.o
 obj-$(CONFIG_KEYBOARD_SPITZ)		+= spitzkbd.o
 obj-$(CONFIG_KEYBOARD_TOSA)		+= tosakbd.o
 obj-$(CONFIG_KEYBOARD_HIL)		+= hil_kbd.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/keyboard/neo1973kbd.c linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/neo1973kbd.c
--- linux-2.6.29-rc3.owrt/drivers/input/keyboard/neo1973kbd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/neo1973kbd.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,467 @@
+/*
+ * Keyboard driver for FIC Neo1973 GSM phone
+ *
+ * (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * inspired by corkgbd.c by Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+
+#include <mach/gpio.h>
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_PM
+extern int global_inside_suspend;
+#else
+#define global_inside_suspend 0
+#endif
+
+struct neo1973kbd {
+	struct platform_device *pdev;
+	struct input_dev *input;
+	struct device *cdev;
+	struct work_struct work;
+	int aux_state;
+	int work_in_progress;
+	int hp_irq_count_in_work;
+	int hp_irq_count;
+	int jack_irq;
+};
+
+static struct class *neo1973kbd_switch_class;
+
+enum keys {
+	NEO1973_KEY_AUX,    /* GTA01 / 02 only */
+	NEO1973_KEY_HOLD,
+	NEO1973_KEY_JACK,
+	NEO1973_KEY_PLUS,   /* GTA03 only */
+	NEO1973_KEY_MINUS,  /* GTA03 only */
+};
+
+struct neo1973kbd_key {
+	const char * name;
+	irqreturn_t (*isr)(int irq, void *dev_id);
+	int irq;
+	int input_key;
+};
+
+static irqreturn_t neo1973kbd_aux_irq(int irq, void *dev_id);
+static irqreturn_t neo1973kbd_headphone_irq(int irq, void *dev_id);
+static irqreturn_t neo1973kbd_default_key_irq(int irq, void *dev_id);
+
+
+static struct neo1973kbd_key keys[] = {
+	[NEO1973_KEY_AUX] = {
+		.name = "Neo1973 AUX button",
+		.isr = neo1973kbd_aux_irq,
+		.input_key = KEY_PHONE,
+	},
+	[NEO1973_KEY_HOLD] = {
+		.name = "Neo1973 HOLD button",
+		.isr = neo1973kbd_default_key_irq,
+		.input_key = KEY_PAUSE,
+	},
+	[NEO1973_KEY_JACK] = {
+		.name = "Neo1973 Headphone jack",
+		.isr = neo1973kbd_headphone_irq,
+	},
+	[NEO1973_KEY_PLUS] = {
+		.name = "GTA03 PLUS button",
+		.isr = neo1973kbd_default_key_irq,
+		.input_key = KEY_KPPLUS,
+	},
+	[NEO1973_KEY_MINUS] = {
+		.name = "GTA03 MINUS button",
+		.isr = neo1973kbd_default_key_irq,
+		.input_key = KEY_KPMINUS,
+	},
+};
+
+/* This timer section filters AUX button IRQ bouncing */
+
+static void aux_key_timer_f(unsigned long data);
+
+static struct timer_list aux_key_timer =
+		TIMER_INITIALIZER(aux_key_timer_f, 0, 0);
+
+#define AUX_TIMER_TIMEOUT (HZ >> 7)
+#define AUX_TIMER_ALLOWED_NOOP 2
+#define AUX_TIMER_CONSECUTIVE_EVENTS 5
+
+struct neo1973kbd *timer_kbd;
+
+static void aux_key_timer_f(unsigned long data)
+{
+	static int noop_counter;
+	static int last_key = -1;
+	static int last_count;
+	int key_pressed;
+
+	key_pressed =
+	    !gpio_get_value(timer_kbd->pdev->resource[NEO1973_KEY_AUX].start);
+	if (machine_is_neo1973_gta02())
+		key_pressed = !key_pressed;
+
+	if (likely(key_pressed == last_key))
+		last_count++;
+	else {
+		last_count = 1;
+		last_key = key_pressed;
+	}
+
+	if (unlikely(last_count >= AUX_TIMER_CONSECUTIVE_EVENTS)) {
+		if (timer_kbd->aux_state != last_key) {
+			input_report_key(timer_kbd->input, KEY_PHONE, last_key);
+			input_sync(timer_kbd->input);
+
+			timer_kbd->aux_state = last_key;
+			noop_counter = 0;
+		}
+		last_count = 0;
+		if (unlikely(++noop_counter > AUX_TIMER_ALLOWED_NOOP)) {
+			noop_counter = 0;
+			return;
+		}
+	}
+
+	mod_timer(&aux_key_timer, jiffies + AUX_TIMER_TIMEOUT);
+}
+
+static irqreturn_t neo1973kbd_aux_irq(int irq, void *dev)
+{
+	mod_timer(&aux_key_timer, jiffies + AUX_TIMER_TIMEOUT);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t neo1973kbd_default_key_irq(int irq, void *dev_id)
+{
+	struct neo1973kbd *kbd = dev_id;
+	int n;
+
+	for (n = 0; n < ARRAY_SIZE(keys); n++) {
+
+		if (irq != keys[n].irq)
+			continue;
+
+		input_report_key(kbd->input, keys[n].input_key,
+				  gpio_get_value(kbd->pdev->resource[n].start));
+		input_sync(kbd->input);
+	}
+
+	return IRQ_HANDLED;
+}
+
+
+static const char *event_array_jack[2][4] = {
+	[0] = {
+		"SWITCH_NAME=headset",
+		"SWITCH_STATE=0",
+		"EVENT=remove",
+		NULL
+	},
+	[1] = {
+		"SWITCH_NAME=headset",
+		"SWITCH_STATE=1",
+		"EVENT=insert",
+		NULL
+	},
+};
+
+static void neo1973kbd_jack_event(struct device *dev, int num)
+{
+	kobject_uevent_env(&dev->kobj, KOBJ_CHANGE, (char **)event_array_jack[!!num]);
+}
+
+
+static void neo1973kbd_debounce_jack(struct work_struct *work)
+{
+	struct neo1973kbd *kbd = container_of(work, struct neo1973kbd, work);
+	unsigned long flags;
+	int loop = 0;
+	int level;
+
+	do {
+		/*
+		 * we wait out any multiple interrupt
+		 * stuttering in 100ms lumps
+		 */
+		do {
+			kbd->hp_irq_count_in_work = kbd->hp_irq_count;
+			msleep(100);
+		} while (kbd->hp_irq_count != kbd->hp_irq_count_in_work);
+		/*
+		 * no new interrupts on jack for 100ms...
+		 * ok we will report it
+		 */
+		level = gpio_get_value(kbd->pdev->resource[NEO1973_KEY_JACK].start);
+		input_report_switch(kbd->input, SW_HEADPHONE_INSERT, level);
+		input_sync(kbd->input);
+		neo1973kbd_jack_event(kbd->cdev, level);
+		/*
+		 * we go around the outer loop again if we detect that more
+		 * interrupts came while we are servicing here.  But we have
+		 * to sequence it carefully with interrupts off
+		 */
+		local_save_flags(flags);
+		/* no interrupts during this work means we can exit the work */
+		loop = !!(kbd->hp_irq_count != kbd->hp_irq_count_in_work);
+		if (!loop)
+			kbd->work_in_progress = 0;
+		local_irq_restore(flags);
+		/*
+		 * interrupt that comes here will either queue a new work action
+		 * since work_in_progress is cleared now, or be dealt with
+		 * when we loop.
+		 */
+	} while (loop);
+}
+
+
+static irqreturn_t neo1973kbd_headphone_irq(int irq, void *dev_id)
+{
+	struct neo1973kbd *neo1973kbd_data = dev_id;
+
+	/*
+	 * this interrupt is prone to bouncing and userspace doesn't like
+	 * to have to deal with that kind of thing.  So we do not accept
+	 * that a jack interrupt is equal to a jack event.  Instead we fire
+	 * some work on the first interrupt, and it hangs about in 100ms units
+	 * until no more interrupts come.  Then it accepts the state it finds
+	 * for jack insert and reports it once
+	 */
+
+	neo1973kbd_data->hp_irq_count++;
+	/*
+	 * the first interrupt we see for a while, we fire the work item
+	 * and record the interrupt count when we did that.  If more interrupts
+	 * come in the meanwhile, we can tell by the difference in that
+	 * stored count and hp_irq_count which increments every interrupt
+	 */
+	if (!neo1973kbd_data->work_in_progress) {
+		neo1973kbd_data->jack_irq = irq;
+		neo1973kbd_data->hp_irq_count_in_work =
+						neo1973kbd_data->hp_irq_count;
+		if (!schedule_work(&neo1973kbd_data->work))
+			printk(KERN_ERR
+				"Unable to schedule headphone debounce\n");
+		else
+			neo1973kbd_data->work_in_progress = 1;
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+static int neo1973kbd_suspend(struct platform_device *dev, pm_message_t state)
+{
+	if (machine_is_neo1973_gta02()) {
+		disable_irq(keys[NEO1973_KEY_AUX].irq);
+		del_timer_sync(&aux_key_timer);
+	}
+	return 0;
+}
+
+static int neo1973kbd_resume(struct platform_device *dev)
+{
+	if (machine_is_neo1973_gta02())
+		enable_irq(keys[NEO1973_KEY_AUX].irq);
+
+	return 0;
+}
+#else
+#define neo1973kbd_suspend	NULL
+#define neo1973kbd_resume	NULL
+#endif
+
+static ssize_t neo1973kbd_switch_name_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", "neo1973 Headset Jack");
+}
+
+static ssize_t neo1973kbd_switch_state_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct neo1973kbd *kbd = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n",
+		   gpio_get_value(kbd->pdev->resource[NEO1973_KEY_JACK].start));
+}
+
+static DEVICE_ATTR(name, S_IRUGO , neo1973kbd_switch_name_show, NULL);
+static DEVICE_ATTR(state, S_IRUGO , neo1973kbd_switch_state_show, NULL);
+
+static int neo1973kbd_probe(struct platform_device *pdev)
+{
+	struct neo1973kbd *neo1973kbd;
+	struct input_dev *input_dev;
+	int rc;
+	int irq;
+	int n;
+
+	neo1973kbd = kzalloc(sizeof(struct neo1973kbd), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!neo1973kbd || !input_dev) {
+		kfree(neo1973kbd);
+		input_free_device(input_dev);
+		return -ENOMEM;
+	}
+
+	neo1973kbd->pdev = pdev;
+	timer_kbd = neo1973kbd;
+
+	if (pdev->resource[0].flags != 0)
+		return -EINVAL;
+
+	platform_set_drvdata(pdev, neo1973kbd);
+
+	neo1973kbd->input = input_dev;
+
+	INIT_WORK(&neo1973kbd->work, neo1973kbd_debounce_jack);
+
+	input_dev->name = "Neo1973 Buttons";
+	input_dev->phys = "neo1973kbd/input0";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+	input_dev->dev.parent = &pdev->dev;
+
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_SW);
+	set_bit(SW_HEADPHONE_INSERT, input_dev->swbit);
+	set_bit(KEY_PHONE, input_dev->keybit);
+	set_bit(KEY_PAUSE, input_dev->keybit);
+
+	rc = input_register_device(neo1973kbd->input);
+	if (rc)
+		goto out_register;
+
+	neo1973kbd->cdev = device_create(neo1973kbd_switch_class,
+					  &pdev->dev, 0, neo1973kbd, "headset");
+	if (unlikely(IS_ERR(neo1973kbd->cdev))) {
+		rc = PTR_ERR(neo1973kbd->cdev);
+		goto out_device_create;
+	}
+
+	rc = device_create_file(neo1973kbd->cdev, &dev_attr_name);
+	if(rc)
+		goto out_device_create_file;
+
+	rc = device_create_file(neo1973kbd->cdev, &dev_attr_state);
+	if(rc)
+		goto out_device_create_file;
+
+	/* register GPIO IRQs */
+	for(n = 0; n < min(pdev->num_resources, ARRAY_SIZE(keys)); n++) {
+
+		if (!pdev->resource[0].start)
+			continue;
+
+		irq = gpio_to_irq(pdev->resource[n].start);
+		if (irq < 0)
+			continue;
+
+		if (request_irq(irq, keys[n].isr, IRQF_DISABLED |
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				keys[n].name, neo1973kbd)) {
+			dev_err(&pdev->dev, "Can't get IRQ %u\n", irq);
+
+			/* unwind any irq registrations and fail */
+
+			while (n > 0) {
+				n--;
+				free_irq(gpio_to_irq(pdev->resource[n].start),
+								    neo1973kbd);
+			}
+			goto out_device_create_file;
+		}
+
+		keys[n].irq = irq;
+	}
+
+	/*
+	 * GTA01 revisions before Bv4 can't be resumed by the PMU, so we use
+	 * resume by AUX.
+	 */
+	if (machine_is_neo1973_gta01())
+		enable_irq_wake(keys[NEO1973_KEY_AUX].irq);
+
+	enable_irq_wake(keys[NEO1973_KEY_JACK].irq);
+
+	return 0;
+
+out_device_create_file:
+	device_unregister(neo1973kbd->cdev);
+out_device_create:
+	input_unregister_device(neo1973kbd->input);
+out_register:
+	input_free_device(neo1973kbd->input);
+	platform_set_drvdata(pdev, NULL);
+	kfree(neo1973kbd);
+
+	return -ENODEV;
+}
+
+static int neo1973kbd_remove(struct platform_device *pdev)
+{
+	struct neo1973kbd *neo1973kbd = platform_get_drvdata(pdev);
+
+	free_irq(gpio_to_irq(pdev->resource[2].start), neo1973kbd);
+	free_irq(gpio_to_irq(pdev->resource[1].start), neo1973kbd);
+	free_irq(gpio_to_irq(pdev->resource[0].start), neo1973kbd);
+
+	device_unregister(neo1973kbd->cdev);
+	input_unregister_device(neo1973kbd->input);
+	input_free_device(neo1973kbd->input);
+	platform_set_drvdata(pdev, NULL);
+	kfree(neo1973kbd);
+
+	return 0;
+}
+
+static struct platform_driver neo1973kbd_driver = {
+	.probe		= neo1973kbd_probe,
+	.remove		= neo1973kbd_remove,
+	.suspend	= neo1973kbd_suspend,
+	.resume		= neo1973kbd_resume,
+	.driver		= {
+		.name	= "neo1973-button",
+	},
+};
+
+static int __devinit neo1973kbd_init(void)
+{
+	neo1973kbd_switch_class = class_create(THIS_MODULE, "switch");
+	if (IS_ERR(neo1973kbd_switch_class))
+		return PTR_ERR(neo1973kbd_switch_class);
+	return platform_driver_register(&neo1973kbd_driver);
+}
+
+static void __exit neo1973kbd_exit(void)
+{
+	platform_driver_unregister(&neo1973kbd_driver);
+	class_destroy(neo1973kbd_switch_class);
+}
+
+module_init(neo1973kbd_init);
+module_exit(neo1973kbd_exit);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("FIC Neo1973 buttons input driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/keyboard/qt2410kbd.c linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/qt2410kbd.c
--- linux-2.6.29-rc3.owrt/drivers/input/keyboard/qt2410kbd.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/keyboard/qt2410kbd.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,231 @@
+/*
+ * Keyboard driver for Armzone QT2410
+ *
+ * (C) 2006 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include <mach/hardware.h>
+#include <mach/gta01.h>
+
+struct gta01kbd {
+	struct input_dev *input;
+	unsigned int suspended;
+	unsigned long suspend_jiffies;
+};
+
+static irqreturn_t gta01kbd_interrupt(int irq, void *dev_id)
+{
+	struct gta01kbd *gta01kbd_data = dev_id;
+
+	/* FIXME: use GPIO from platform_dev resources */
+	if (s3c2410_gpio_getpin(S3C2410_GPF0))
+		input_report_key(gta01kbd_data->input, KEY_PHONE, 1);
+	else
+		input_report_key(gta01kbd_data->input, KEY_PHONE, 0);
+
+	input_sync(gta01kbd_data->input);
+
+	return IRQ_HANDLED;
+}
+
+
+#ifdef CONFIG_PM
+static int gta01kbd_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct gta01kbd *gta01kbd = platform_get_drvdata(dev);
+
+	gta01kbd->suspended = 1;
+
+	return 0;
+}
+
+static int gta01kbd_resume(struct platform_device *dev)
+{
+	struct gta01kbd *gta01kbd = platform_get_drvdata(dev);
+
+	gta01kbd->suspended = 0;
+
+	return 0;
+}
+#else
+#define gta01kbd_suspend	NULL
+#define gta01kbd_resume		NULL
+#endif
+
+static int gta01kbd_probe(struct platform_device *pdev)
+{
+	struct gta01kbd *gta01kbd;
+	struct input_dev *input_dev;
+	int irq_911;
+	int rc = 0;
+
+	gta01kbd = kzalloc(sizeof(struct gta01kbd), GFP_KERNEL);
+	if (!gta01kbd) {
+		rc = -ENOMEM;
+		goto bail;
+	}
+	input_dev = input_allocate_device();
+	if (!gta01kbd || !input_dev) {
+		rc = -ENOMEM;
+		goto bail_free;
+	}
+
+	if (pdev->resource[0].flags != 0) {\
+		rc = -EINVAL;
+		goto bail_free_dev;
+	}
+
+	irq_911 = s3c2410_gpio_getirq(pdev->resource[0].start);
+	if (irq_911 < 0) {
+		rc = -EINVAL;
+		goto bail_free_dev;
+	}
+
+	platform_set_drvdata(pdev, gta01kbd);
+
+	gta01kbd->input = input_dev;
+
+#if 0
+	spin_lock_init(&gta01kbd->lock);
+	/* Init Keyboard rescan timer */
+	init_timer(&corgikbd->timer);
+	corgikbd->timer.function = corgikbd_timer_callback;
+	corgikbd->timer.data = (unsigned long) corgikbd;
+
+	/* Init Hinge Timer */
+	init_timer(&corgikbd->htimer);
+	corgikbd->htimer.function = corgikbd_hinge_timer;
+	corgikbd->htimer.data = (unsigned long) corgikbd;
+
+	corgikbd->suspend_jiffies=jiffies;
+
+	memcpy(corgikbd->keycode, corgikbd_keycode, sizeof(corgikbd->keycode));
+#endif
+
+	input_dev->name = "QT2410 Buttons";
+	input_dev->phys = "qt2410kbd/input0";
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+
+	input_dev->evbit[0] = BIT(EV_KEY);
+#if 0
+	input_dev->keycode = gta01kbd->keycode;
+	input_dev->keycodesize = sizeof(unsigned char);
+	input_dev->keycodemax = ARRAY_SIZE(corgikbd_keycode);
+
+	for (i = 0; i < ARRAY_SIZE(corgikbd_keycode); i++)
+		set_bit(corgikbd->keycode[i], input_dev->keybit);
+	clear_bit(0, input_dev->keybit);
+	set_bit(SW_LID, input_dev->swbit);
+	set_bit(SW_TABLET_MODE, input_dev->swbit);
+	set_bit(SW_HEADPHONE_INSERT, input_dev->swbit);
+#endif
+
+	rc = input_register_device(gta01kbd->input);
+	if (rc)
+		goto bail_free_dev;
+
+	s3c2410_gpio_cfgpin(S3C2410_GPF0, S3C2410_GPF0_EINT0);
+	if (request_irq(irq_911, gta01kbd_interrupt,
+			IRQF_DISABLED | IRQF_TRIGGER_RISING |
+			IRQF_TRIGGER_FALLING, "qt2410kbd_eint0", gta01kbd))
+		printk(KERN_WARNING "gta01kbd: Can't get IRQ\n");
+	enable_irq_wake(irq_911);
+
+	/* FIXME: headphone insert */
+
+#if 0
+	mod_timer(&corgikbd->htimer, jiffies + msecs_to_jiffies(HINGE_SCAN_INTERVAL));
+
+	/* Setup sense interrupts - RisingEdge Detect, sense lines as inputs */
+	for (i = 0; i < CORGI_KEY_SENSE_NUM; i++) {
+		pxa_gpio_mode(CORGI_GPIO_KEY_SENSE(i) | GPIO_IN);
+		if (request_irq(CORGI_IRQ_GPIO_KEY_SENSE(i), corgikbd_interrupt,
+				SA_INTERRUPT | SA_TRIGGER_RISING,
+				"corgikbd", corgikbd))
+			printk(KERN_WARNING "corgikbd: Can't get IRQ: %d!\n", i);
+	}
+
+	/* Set Strobe lines as outputs - set high */
+	for (i = 0; i < CORGI_KEY_STROBE_NUM; i++)
+		pxa_gpio_mode(CORGI_GPIO_KEY_STROBE(i) | GPIO_OUT | GPIO_DFLT_HIGH);
+
+	/* Setup the headphone jack as an input */
+	pxa_gpio_mode(CORGI_GPIO_AK_INT | GPIO_IN);
+#endif
+
+	return 0;
+
+bail_free_dev:
+	input_free_device(input_dev);
+bail_free:
+	kfree(gta01kbd);
+bail:
+	return rc;
+}
+
+static int gta01kbd_remove(struct platform_device *pdev)
+{
+	struct gta01kbd *gta01kbd = platform_get_drvdata(pdev);
+
+	free_irq(s3c2410_gpio_getirq(pdev->resource[0].start), gta01kbd);
+#if 0
+	int i;
+
+	for (i = 0; i < CORGI_KEY_SENSE_NUM; i++)
+		free_irq(CORGI_IRQ_GPIO_KEY_SENSE(i), corgikbd);
+
+	del_timer_sync(&corgikbd->htimer);
+	del_timer_sync(&corgikbd->timer);
+#endif
+	input_unregister_device(gta01kbd->input);
+
+	kfree(gta01kbd);
+
+	return 0;
+}
+
+static struct platform_driver gta01kbd_driver = {
+	.probe		= gta01kbd_probe,
+	.remove		= gta01kbd_remove,
+	.suspend	= gta01kbd_suspend,
+	.resume		= gta01kbd_resume,
+	.driver		= {
+		.name	= "qt2410-button",
+	},
+};
+
+static int __devinit gta01kbd_init(void)
+{
+	return platform_driver_register(&gta01kbd_driver);
+}
+
+static void __exit gta01kbd_exit(void)
+{
+	platform_driver_unregister(&gta01kbd_driver);
+}
+
+module_init(gta01kbd_init);
+module_exit(gta01kbd_exit);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("Armzone QT2410 Buttons Driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/misc/Kconfig linux-2.6.29-rc3.owrt.om/drivers/input/misc/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/input/misc/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/misc/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -220,12 +220,26 @@
 	  Say Y here if you want to support the built-in real time clock
 	  of the HP SDC controller.
 
+config INPUT_LIS302DL
+	tristate "STmicro LIS302DL 3-axis accelerometer"
+	depends on SPI_MASTER
+	help
+	  SPI driver for the STmicro LIS302DL 3-axis accelerometer.
+
+	  The userspece interface is a 3-axis (X/Y/Z) relative movement
+	  Linux input device, reporting REL_[XYZ] events.
+
 config INPUT_PCF50633_PMU
 	tristate "PCF50633 PMU events"
 	depends on MFD_PCF50633
 	help
-	 Say Y to include support for delivering  PMU events via  input
-	 layer on NXP PCF50633.
+	 Say Y to include support for input events on NXP PCF50633.
+
+config INPUT_PCF50606_PMU
+	tristate "PCF50606 PMU events"
+	depends on MFD_PCF50606
+	help
+	 Say Y to include support for input events on NXP PCF50606.
 
 config INPUT_GPIO_BUTTONS
 	tristate "Polled GPIO buttons interface"
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/misc/lis302dl.c linux-2.6.29-rc3.owrt.om/drivers/input/misc/lis302dl.c
--- linux-2.6.29-rc3.owrt/drivers/input/misc/lis302dl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/misc/lis302dl.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,958 @@
+/* Linux kernel driver for the ST LIS302D 3-axis accelerometer
+ *
+ * Copyright (C) 2007-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *         converted to private bitbang by:
+ *         Andy Green <andy@openmoko.com>
+ *         ability to set acceleration threshold added by:
+ *         Simon Kagstrom <simon.kagstrom@gmail.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * TODO
+ * 	* statistics for overflow events
+ * 	* configuration interface (sysfs) for
+ * 		* enable/disable x/y/z axis data ready
+ * 		* enable/disable resume from freee fall / click
+ * 		* free fall / click parameters
+ * 		* high pass filter parameters
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/spi/spi.h>
+
+#include <linux/lis302dl.h>
+
+/* Utility functions */
+static u8 __reg_read(struct lis302dl_info *lis, u8 reg)
+{
+	struct spi_message msg;
+	struct spi_transfer t;
+	u8 data[2] = {0xc0 | reg};
+	int rc;
+
+	spi_message_init(&msg);
+	memset(&t, 0, sizeof t);
+	t.len = 2;
+	spi_message_add_tail(&t, &msg);
+	t.tx_buf = &data[0];
+	t.rx_buf = &data[0];
+
+	/* Should complete without blocking */
+	rc = spi_non_blocking_transfer(lis->spi, &msg);
+	if (rc < 0) {
+		dev_err(lis->dev, "Error reading register\n");
+		return rc;
+	}
+
+	return data[1];
+}
+
+static void __reg_write(struct lis302dl_info *lis, u8 reg, u8 val)
+{	
+	struct spi_message msg;
+	struct spi_transfer t;
+	u8 data[2] = {reg, val};
+
+	spi_message_init(&msg);
+	memset(&t, 0, sizeof t);
+	t.len = 2;
+	spi_message_add_tail(&t, &msg);
+	t.tx_buf = &data[0];
+	t.rx_buf = &data[0];
+
+	/* Completes without blocking */
+	if (spi_non_blocking_transfer(lis->spi, &msg) < 0)
+		dev_err(lis->dev, "Error writing register\n");
+}
+
+static void __reg_set_bit_mask(struct lis302dl_info *lis, u8 reg, u8 mask,
+		u8 val)
+{
+	u_int8_t tmp;
+
+	val &= mask;
+
+	tmp = __reg_read(lis, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	__reg_write(lis, reg, tmp);
+}
+
+static int __ms_to_duration(struct lis302dl_info *lis, int ms)
+{
+	/* If we have 400 ms sampling rate, the stepping is 2.5 ms,
+	 * on 100 ms the stepping is 10ms */
+	if (lis->flags & LIS302DL_F_DR)
+		return min((ms * 10) / 25, 637);
+
+	return min(ms / 10, 2550);
+}
+
+static int __duration_to_ms(struct lis302dl_info *lis, int duration)
+{
+	if (lis->flags & LIS302DL_F_DR)
+		return (duration * 25) / 10;
+
+	return duration * 10;
+}
+
+static u8 __mg_to_threshold(struct lis302dl_info *lis, int mg)
+{
+	/* If FS is set each bit is 71mg, otherwise 18mg. The THS register
+	 * has 7 bits for the threshold value */
+	if (lis->flags & LIS302DL_F_FS)
+		return min(mg / 71, 127);
+
+	return min(mg / 18, 127);
+}
+
+static int __threshold_to_mg(struct lis302dl_info *lis, u8 threshold)
+{
+	if (lis->flags & LIS302DL_F_FS)
+		return threshold * 71;
+
+	return threshold * 18;
+}
+
+/* interrupt handling related */
+
+enum lis302dl_intmode {
+	LIS302DL_INTMODE_GND		= 0x00,
+	LIS302DL_INTMODE_FF_WU_1	= 0x01,
+	LIS302DL_INTMODE_FF_WU_2	= 0x02,
+	LIS302DL_INTMODE_FF_WU_12	= 0x03,
+	LIS302DL_INTMODE_DATA_READY	= 0x04,
+	LIS302DL_INTMODE_CLICK		= 0x07,
+};
+
+static void __lis302dl_int_mode(struct device *dev, int int_pin,
+			      enum lis302dl_intmode mode)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+
+	switch (int_pin) {
+	case 1:
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL3, 0x07, mode);
+		break;
+	case 2:
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL3, 0x38, mode << 3);
+		break;
+	default:
+		BUG();
+	}
+}
+
+static void __enable_wakeup(struct lis302dl_info *lis)
+{
+	__reg_write(lis, LIS302DL_REG_CTRL1, 0);
+
+	/* First zero to get to a known state */
+	__reg_write(lis, LIS302DL_REG_FF_WU_CFG_1, LIS302DL_FFWUCFG_XHIE |
+			LIS302DL_FFWUCFG_YHIE | LIS302DL_FFWUCFG_ZHIE |
+			LIS302DL_FFWUCFG_LIR);
+	__reg_write(lis, LIS302DL_REG_FF_WU_THS_1,
+			__mg_to_threshold(lis, lis->wakeup.threshold));
+	__reg_write(lis, LIS302DL_REG_FF_WU_DURATION_1,
+			__ms_to_duration(lis, lis->wakeup.duration));
+
+	/* Route the interrupt for wakeup */
+	__lis302dl_int_mode(lis->dev, 1,
+			LIS302DL_INTMODE_FF_WU_1);
+
+	__reg_read(lis, LIS302DL_REG_HP_FILTER_RESET);
+	__reg_read(lis, LIS302DL_REG_OUT_X);
+	__reg_read(lis, LIS302DL_REG_OUT_Y);
+	__reg_read(lis, LIS302DL_REG_OUT_Z);
+	__reg_read(lis, LIS302DL_REG_STATUS);
+	__reg_read(lis, LIS302DL_REG_FF_WU_SRC_1);
+	__reg_read(lis, LIS302DL_REG_FF_WU_SRC_2);
+	__reg_write(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_PD | 7);
+}
+
+static void __enable_data_collection(struct lis302dl_info *lis)
+{
+	u_int8_t ctrl1 = LIS302DL_CTRL1_PD | LIS302DL_CTRL1_Xen |
+			 LIS302DL_CTRL1_Yen | LIS302DL_CTRL1_Zen;
+
+	/* make sure we're powered up and generate data ready */
+	__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, ctrl1, ctrl1);
+
+	/* If the threshold is zero, let the device generated an interrupt
+	 * on each datum */
+	if (lis->threshold == 0) {
+		__reg_write(lis, LIS302DL_REG_CTRL2, 0);
+		__lis302dl_int_mode(lis->dev, 1, LIS302DL_INTMODE_DATA_READY);
+		__lis302dl_int_mode(lis->dev, 2, LIS302DL_INTMODE_DATA_READY);
+	} else {
+		__reg_write(lis, LIS302DL_REG_CTRL2,
+				LIS302DL_CTRL2_HPFF1);
+		__reg_write(lis, LIS302DL_REG_FF_WU_THS_1,
+				__mg_to_threshold(lis, lis->threshold));
+		__reg_write(lis, LIS302DL_REG_FF_WU_DURATION_1,
+				__ms_to_duration(lis, lis->duration));
+
+		/* Clear the HP filter "starting point" */
+		__reg_read(lis, LIS302DL_REG_HP_FILTER_RESET);
+		__reg_write(lis, LIS302DL_REG_FF_WU_CFG_1,
+				LIS302DL_FFWUCFG_XHIE | LIS302DL_FFWUCFG_YHIE |
+				LIS302DL_FFWUCFG_ZHIE | LIS302DL_FFWUCFG_LIR);
+		__lis302dl_int_mode(lis->dev, 1, LIS302DL_INTMODE_FF_WU_12);
+		__lis302dl_int_mode(lis->dev, 2, LIS302DL_INTMODE_FF_WU_12);
+	}
+}
+
+#if 0
+static void _report_btn_single(struct input_dev *inp, int btn)
+{
+	input_report_key(inp, btn, 1);
+	input_sync(inp);
+	input_report_key(inp, btn, 0);
+}
+
+static void _report_btn_double(struct input_dev *inp, int btn)
+{
+	input_report_key(inp, btn, 1);
+	input_sync(inp);
+	input_report_key(inp, btn, 0);
+	input_sync(inp);
+	input_report_key(inp, btn, 1);
+	input_sync(inp);
+	input_report_key(inp, btn, 0);
+}
+#endif
+
+
+static void lis302dl_bitbang_read_sample(struct lis302dl_info *lis)
+{
+	u8 data[(LIS302DL_REG_OUT_Z - LIS302DL_REG_STATUS) + 2] = {0xC0 | LIS302DL_REG_STATUS};
+	u8 *read = data + 1;
+	unsigned long flags;
+	int mg_per_sample = __threshold_to_mg(lis, 1);
+	struct spi_message msg;
+	struct spi_transfer t;
+
+	spi_message_init(&msg);
+	memset(&t, 0, sizeof t);
+	t.len = sizeof(data);
+	spi_message_add_tail(&t, &msg);
+	t.tx_buf = &data[0];
+	t.rx_buf = &data[0];
+
+	/* grab the set of register containing status and XYZ data */
+
+	local_irq_save(flags);
+
+	/* Should complete without blocking */
+	if (spi_non_blocking_transfer(lis->spi, &msg) < 0) 
+		dev_err(lis->dev, "Error reading registers\n");
+
+	local_irq_restore(flags);
+
+	/*
+	 * at the minute the test below fails 50% of the time due to
+	 * a problem with level interrupts causing ISRs to get called twice.
+	 * This is a workaround for that, but actually this test is still
+	 * valid and the information can be used for overrrun stats.
+	 */
+
+	/* has any kind of overrun been observed by the lis302dl? */
+	if (read[0] & (LIS302DL_STATUS_XOR |
+		       LIS302DL_STATUS_YOR |
+		       LIS302DL_STATUS_ZOR))
+		lis->overruns++;
+
+	/* we have a valid sample set? */
+	if (read[0] & LIS302DL_STATUS_XYZDA) {
+		input_report_abs(lis->input_dev, ABS_X, mg_per_sample *
+			    (s8)read[LIS302DL_REG_OUT_X - LIS302DL_REG_STATUS]);
+		input_report_abs(lis->input_dev, ABS_Y, mg_per_sample *
+			    (s8)read[LIS302DL_REG_OUT_Y - LIS302DL_REG_STATUS]);
+		input_report_abs(lis->input_dev, ABS_Z, mg_per_sample *
+			    (s8)read[LIS302DL_REG_OUT_Z - LIS302DL_REG_STATUS]);
+
+		input_sync(lis->input_dev);
+	}
+
+	if (lis->threshold)
+		/* acknowledge the wakeup source */
+		__reg_read(lis,	LIS302DL_REG_FF_WU_SRC_1);
+}
+
+static irqreturn_t lis302dl_interrupt(int irq, void *_lis)
+{
+	struct lis302dl_info *lis = _lis;
+
+	lis302dl_bitbang_read_sample(lis);
+	return IRQ_HANDLED;
+}
+
+/* sysfs */
+
+static ssize_t show_overruns(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", lis->overruns);
+}
+
+static DEVICE_ATTR(overruns, S_IRUGO, show_overruns, NULL);
+
+static ssize_t show_rate(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	u8 ctrl1;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	ctrl1 = __reg_read(lis, LIS302DL_REG_CTRL1);
+	local_irq_restore(flags);
+
+	return sprintf(buf, "%d\n", ctrl1 & LIS302DL_CTRL1_DR ? 400 : 100);
+}
+
+static ssize_t set_rate(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	if (!strcmp(buf, "400\n")) {
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_DR,
+				 LIS302DL_CTRL1_DR);
+		lis->flags |= LIS302DL_F_DR;
+	} else {
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_DR,
+				0);
+		lis->flags &= ~LIS302DL_F_DR;
+	}
+	local_irq_restore(flags);
+
+	return count;
+}
+
+static DEVICE_ATTR(sample_rate, S_IRUGO | S_IWUSR, show_rate, set_rate);
+
+static ssize_t show_scale(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	u_int8_t ctrl1;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	ctrl1 = __reg_read(lis, LIS302DL_REG_CTRL1);
+	local_irq_restore(flags);
+
+	return sprintf(buf, "%s\n", ctrl1 & LIS302DL_CTRL1_FS ? "9.2" : "2.3");
+}
+
+static ssize_t set_scale(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	if (!strcmp(buf, "9.2\n")) {
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_FS,
+				 LIS302DL_CTRL1_FS);
+		lis->flags |= LIS302DL_F_FS;
+	} else {
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_FS,
+				0);
+		lis->flags &= ~LIS302DL_F_FS;
+	}
+
+	if (lis->flags & LIS302DL_F_INPUT_OPEN)
+		__enable_data_collection(lis);
+
+	local_irq_restore(flags);
+
+	return count;
+}
+
+static DEVICE_ATTR(full_scale, S_IRUGO | S_IWUSR, show_scale, set_scale);
+
+static ssize_t show_threshold(struct device *dev, struct device_attribute *attr,
+		 char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+
+	/* Display the device view of the threshold setting */
+	return sprintf(buf, "%d\n", __threshold_to_mg(lis,
+			__mg_to_threshold(lis, lis->threshold)));
+}
+
+static ssize_t set_threshold(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	unsigned int val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	/* 8g is the maximum if FS is 1 */
+	if (val > 8000)
+		return -ERANGE;
+
+	/* Set the threshold and write it out if the device is used */
+	lis->threshold = val;
+
+	if (lis->flags & LIS302DL_F_INPUT_OPEN) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		__enable_data_collection(lis);
+		local_irq_restore(flags);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(threshold, S_IRUGO | S_IWUSR, show_threshold, set_threshold);
+
+static ssize_t show_duration(struct device *dev, struct device_attribute *attr,
+		 char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", __duration_to_ms(lis,
+			__ms_to_duration(lis, lis->duration)));
+}
+
+static ssize_t set_duration(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t count)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	unsigned int val;
+
+	if (sscanf(buf, "%u\n", &val) != 1)
+		return -EINVAL;
+	if (val > 2550)
+		return -ERANGE;
+
+	lis->duration = val;
+	if (lis->flags & LIS302DL_F_INPUT_OPEN)
+		__reg_write(lis, LIS302DL_REG_FF_WU_DURATION_1,
+				__ms_to_duration(lis, lis->duration));
+
+	return count;
+}
+
+static DEVICE_ATTR(duration, S_IRUGO | S_IWUSR, show_duration, set_duration);
+
+static ssize_t lis302dl_dump(struct device *dev, struct device_attribute *attr,
+								      char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	int n = 0;
+	u8 reg[0x40];
+	char *end = buf;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	for (n = 0; n < sizeof(reg); n++)
+		reg[n] = __reg_read(lis, n);
+
+	local_irq_restore(flags);
+
+	for (n = 0; n < sizeof(reg); n += 16) {
+		hex_dump_to_buffer(reg + n, 16, 16, 1, end, 128, 0);
+		end += strlen(end);
+		*end++ = '\n';
+		*end++ = '\0';
+	}
+
+	return end - buf;
+}
+static DEVICE_ATTR(dump, S_IRUGO, lis302dl_dump, NULL);
+
+/* Configure freefall/wakeup interrupts */
+static ssize_t set_wakeup_threshold(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	unsigned int threshold;
+
+	if (sscanf(buf, "%u\n", &threshold) != 1)
+		return -EINVAL;
+
+	if (threshold > 8000)
+		return -ERANGE;
+
+	/* Zero turns the feature off */
+	if (threshold == 0) {
+		if (lis->flags & LIS302DL_F_IRQ_WAKE) {
+			disable_irq_wake(lis->pdata->interrupt);
+			lis->flags &= ~LIS302DL_F_IRQ_WAKE;
+		}
+
+		return count;
+	}
+
+	lis->wakeup.threshold = threshold;
+
+	if (!(lis->flags & LIS302DL_F_IRQ_WAKE)) {
+		enable_irq_wake(lis->pdata->interrupt);
+		lis->flags |= LIS302DL_F_IRQ_WAKE;
+	}
+
+	return count;
+}
+
+static ssize_t show_wakeup_threshold(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+
+	/* All events off? */
+	if (lis->wakeup.threshold == 0)
+		return sprintf(buf, "off\n");
+
+	return sprintf(buf, "%u\n", lis->wakeup.threshold);
+}
+
+static DEVICE_ATTR(wakeup_threshold, S_IRUGO | S_IWUSR, show_wakeup_threshold,
+		set_wakeup_threshold);
+
+static ssize_t set_wakeup_duration(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+	unsigned int duration;
+
+	if (sscanf(buf, "%u\n", &duration) != 1)
+		return -EINVAL;
+
+	if (duration > 2550)
+		return -ERANGE;
+
+	lis->wakeup.duration = duration;
+
+	return count;
+}
+
+static ssize_t show_wakeup_duration(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", lis->wakeup.duration);
+}
+
+static DEVICE_ATTR(wakeup_duration, S_IRUGO | S_IWUSR, show_wakeup_duration,
+		set_wakeup_duration);
+
+static struct attribute *lis302dl_sysfs_entries[] = {
+	&dev_attr_sample_rate.attr,
+	&dev_attr_full_scale.attr,
+	&dev_attr_threshold.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_dump.attr,
+	&dev_attr_wakeup_threshold.attr,
+	&dev_attr_wakeup_duration.attr,
+	&dev_attr_overruns.attr,
+	NULL
+};
+
+static struct attribute_group lis302dl_attr_group = {
+	.name	= NULL,
+	.attrs	= lis302dl_sysfs_entries,
+};
+
+/* input device handling and driver core interaction */
+
+static int lis302dl_input_open(struct input_dev *inp)
+{
+	struct lis302dl_info *lis = input_get_drvdata(inp);
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	__enable_data_collection(lis);
+	lis->flags |= LIS302DL_F_INPUT_OPEN;
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void lis302dl_input_close(struct input_dev *inp)
+{
+	struct lis302dl_info *lis = input_get_drvdata(inp);
+	u_int8_t ctrl1 = LIS302DL_CTRL1_Xen | LIS302DL_CTRL1_Yen |
+			 LIS302DL_CTRL1_Zen;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* since the input core already serializes access and makes sure we
+	 * only see close() for the close of the last user, we can safely
+	 * disable the data ready events */
+	__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, ctrl1, 0x00);
+	lis->flags &= ~LIS302DL_F_INPUT_OPEN;
+
+	/* however, don't power down the whole device if still needed */
+	if (!(lis->flags & LIS302DL_F_WUP_FF ||
+	      lis->flags & LIS302DL_F_WUP_CLICK)) {
+		__reg_set_bit_mask(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_PD,
+				 0x00);
+	}
+	local_irq_restore(flags);
+}
+
+/* get the device to reload its coefficients from EEPROM and wait for it
+ * to complete
+ */
+
+static int __lis302dl_reset_device(struct lis302dl_info *lis)
+{
+	int timeout = 10;
+
+	__reg_write(lis, LIS302DL_REG_CTRL2,
+			LIS302DL_CTRL2_BOOT | LIS302DL_CTRL2_FDS);
+
+	while ((__reg_read(lis, LIS302DL_REG_CTRL2)
+			& LIS302DL_CTRL2_BOOT) && (timeout--))
+		mdelay(1);
+
+	return !!(timeout < 0);
+}
+
+static int __devinit lis302dl_probe(struct spi_device *spi)
+{
+	int rc;
+	struct lis302dl_info *lis;
+	u_int8_t wai;
+	unsigned long flags;
+	struct lis302dl_platform_data *pdata = spi->dev.platform_data;
+
+	spi->mode = SPI_MODE_3;
+	rc = spi_setup(spi);
+	if (rc < 0) {
+		dev_err(&spi->dev, "spi_setup failed\n");
+		return rc;
+	}
+
+	lis = kzalloc(sizeof(*lis), GFP_KERNEL);
+	if (!lis)
+		return -ENOMEM;
+
+	lis->dev = &spi->dev;
+	lis->spi = spi;
+
+	dev_set_drvdata(lis->dev, lis);
+
+	lis->pdata = pdata;
+
+	rc = sysfs_create_group(&lis->dev->kobj, &lis302dl_attr_group);
+	if (rc) {
+		dev_err(lis->dev, "error creating sysfs group\n");
+		goto bail_free_lis;
+	}
+
+	/* initialize input layer details */
+	lis->input_dev = input_allocate_device();
+	if (!lis->input_dev) {
+		dev_err(lis->dev, "Unable to allocate input device\n");
+		goto bail_sysfs;
+	}
+
+	input_set_drvdata(lis->input_dev, lis);
+	lis->input_dev->name = pdata->name;
+	 /* SPI Bus not defined as a valid bus for input subsystem*/
+	lis->input_dev->id.bustype = BUS_I2C; /* lie about it */
+	lis->input_dev->open = lis302dl_input_open;
+	lis->input_dev->close = lis302dl_input_close;
+
+	rc = input_register_device(lis->input_dev);
+	if (rc) {
+		dev_err(lis->dev, "error %d registering input device\n", rc);
+		goto bail_inp_dev;
+	}
+
+	local_irq_save(flags);
+	/* Configure our IO */
+	(lis->pdata->lis302dl_suspend_io)(lis, 1);
+
+	wai = __reg_read(lis, LIS302DL_REG_WHO_AM_I);
+	if (wai != LIS302DL_WHO_AM_I_MAGIC) {
+		dev_err(lis->dev, "unknown who_am_i signature 0x%02x\n", wai);
+		dev_set_drvdata(lis->dev, NULL);
+		rc = -ENODEV;
+		local_irq_restore(flags);
+		goto bail_inp_reg;
+	}
+
+	set_bit(EV_ABS, lis->input_dev->evbit);
+	input_set_abs_params(lis->input_dev, ABS_X, 0, 0, 0, 0);
+	input_set_abs_params(lis->input_dev, ABS_Y, 0, 0, 0, 0);
+	input_set_abs_params(lis->input_dev, ABS_Z, 0, 0, 0, 0);
+	
+
+	lis->threshold = 0;
+	lis->duration = 0;
+	memset(&lis->wakeup, 0, sizeof(lis->wakeup));
+
+	if (__lis302dl_reset_device(lis))
+		dev_err(lis->dev, "device BOOT reload failed\n");
+
+	/* force us powered */
+	__reg_write(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_PD |
+			LIS302DL_CTRL1_Xen |
+			LIS302DL_CTRL1_Yen |
+			LIS302DL_CTRL1_Zen);
+	mdelay(1);
+
+	__reg_write(lis, LIS302DL_REG_CTRL2, 0);
+	__reg_write(lis, LIS302DL_REG_CTRL3,
+			LIS302DL_CTRL3_PP_OD | LIS302DL_CTRL3_IHL);
+	__reg_write(lis, LIS302DL_REG_FF_WU_THS_1, 0x0);
+	__reg_write(lis, LIS302DL_REG_FF_WU_DURATION_1, 0x00);
+	__reg_write(lis, LIS302DL_REG_FF_WU_CFG_1, 0x0);
+
+	/* start off in powered down mode; we power up when someone opens us */
+	__reg_write(lis, LIS302DL_REG_CTRL1, LIS302DL_CTRL1_Xen |
+			LIS302DL_CTRL1_Yen | LIS302DL_CTRL1_Zen);
+
+	if (pdata->open_drain)
+		/* switch interrupt to open collector, active-low */
+		__reg_write(lis, LIS302DL_REG_CTRL3,
+				LIS302DL_CTRL3_PP_OD | LIS302DL_CTRL3_IHL);
+	else
+		/* push-pull, active-low */
+		__reg_write(lis, LIS302DL_REG_CTRL3, LIS302DL_CTRL3_IHL);
+
+	__lis302dl_int_mode(lis->dev, 1, LIS302DL_INTMODE_GND);
+	__lis302dl_int_mode(lis->dev, 2, LIS302DL_INTMODE_GND);
+
+	__reg_read(lis, LIS302DL_REG_STATUS);
+	__reg_read(lis, LIS302DL_REG_FF_WU_SRC_1);
+	__reg_read(lis, LIS302DL_REG_FF_WU_SRC_2);
+	__reg_read(lis, LIS302DL_REG_CLICK_SRC);
+	local_irq_restore(flags);
+
+	dev_info(lis->dev, "Found %s\n", pdata->name);
+
+	lis->pdata = pdata;
+
+	set_irq_handler(lis->pdata->interrupt, handle_level_irq);
+
+	rc = request_irq(lis->pdata->interrupt, lis302dl_interrupt,
+			 IRQF_TRIGGER_LOW, "lis302dl", lis);
+	
+	if (rc < 0) {
+		dev_err(lis->dev, "error requesting IRQ %d\n",
+			lis->pdata->interrupt);
+		goto bail_inp_reg;
+	}
+	return 0;
+
+bail_inp_reg:
+	input_unregister_device(lis->input_dev);
+bail_inp_dev:
+	input_free_device(lis->input_dev);
+bail_sysfs:
+	sysfs_remove_group(&lis->dev->kobj, &lis302dl_attr_group);
+bail_free_lis:
+	kfree(lis);
+	return rc;
+}
+
+static int __devexit lis302dl_remove(struct spi_device *spi)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+
+	/* Disable interrupts */
+	if (lis->flags & LIS302DL_F_IRQ_WAKE)
+		disable_irq_wake(lis->pdata->interrupt);
+	free_irq(lis->pdata->interrupt, lis);
+
+	/* Reset and power down the device */
+	local_irq_save(flags);
+	__reg_write(lis, LIS302DL_REG_CTRL3, 0x00);
+	__reg_write(lis, LIS302DL_REG_CTRL2, 0x00);
+	__reg_write(lis, LIS302DL_REG_CTRL1, 0x00);
+	local_irq_restore(flags);
+
+	/* Cleanup resources */
+	sysfs_remove_group(&spi->dev.kobj, &lis302dl_attr_group);
+	input_unregister_device(lis->input_dev);
+	if (lis->input_dev)
+		input_free_device(lis->input_dev);
+	dev_set_drvdata(lis->dev, NULL);
+	kfree(lis);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static u8 regs_to_save[] = {
+	LIS302DL_REG_CTRL1,
+	LIS302DL_REG_CTRL2,
+	LIS302DL_REG_CTRL3,
+	LIS302DL_REG_FF_WU_CFG_1,
+	LIS302DL_REG_FF_WU_THS_1,
+	LIS302DL_REG_FF_WU_DURATION_1,
+	LIS302DL_REG_FF_WU_CFG_2,
+	LIS302DL_REG_FF_WU_THS_2,
+	LIS302DL_REG_FF_WU_DURATION_2,
+	LIS302DL_REG_CLICK_CFG,
+	LIS302DL_REG_CLICK_THSY_X,
+	LIS302DL_REG_CLICK_THSZ,
+	LIS302DL_REG_CLICK_TIME_LIMIT,
+	LIS302DL_REG_CLICK_LATENCY,
+	LIS302DL_REG_CLICK_WINDOW,
+
+};
+
+static int lis302dl_suspend(struct spi_device *spi, pm_message_t state)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+	u_int8_t tmp;
+	int n;
+
+	/* determine if we want to wake up from the accel. */
+	if (lis->flags & LIS302DL_F_WUP_CLICK)
+		return 0;
+
+	disable_irq(lis->pdata->interrupt);
+	local_irq_save(flags);
+
+	/*
+	 * When we share SPI over multiple sensors, there is a race here
+	 * that one or more sensors will lose.  In that case, the shared
+	 * SPI bus GPIO will be in sleep mode and partially pulled down.  So
+	 * we explicitly put our IO into "wake" mode here before the final
+	 * traffic to the sensor.
+	 */
+	(lis->pdata->lis302dl_suspend_io)(lis, 1);
+
+	/* save registers */
+	for (n = 0; n < ARRAY_SIZE(regs_to_save); n++)
+		lis->regs[regs_to_save[n]] =
+			__reg_read(lis, regs_to_save[n]);
+
+	/* power down or enable wakeup */
+
+	if (lis->wakeup.threshold == 0) {
+		tmp = __reg_read(lis, LIS302DL_REG_CTRL1);
+		tmp &= ~LIS302DL_CTRL1_PD;
+		__reg_write(lis, LIS302DL_REG_CTRL1, tmp);
+	} else
+		__enable_wakeup(lis);
+
+	/* place our IO to the device in sleep-compatible states */
+	(lis->pdata->lis302dl_suspend_io)(lis, 0);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int lis302dl_resume(struct spi_device *spi)
+{
+	struct lis302dl_info *lis = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+	int n;
+
+	if (lis->flags & LIS302DL_F_WUP_CLICK)
+		return 0;
+
+	local_irq_save(flags);
+
+	/* get our IO to the device back in operational states */
+	(lis->pdata->lis302dl_suspend_io)(lis, 1);
+
+	/* resume from powerdown first! */
+	__reg_write(lis, LIS302DL_REG_CTRL1,
+			LIS302DL_CTRL1_PD |
+			LIS302DL_CTRL1_Xen |
+			LIS302DL_CTRL1_Yen |
+			LIS302DL_CTRL1_Zen);
+	mdelay(1);
+
+	if (__lis302dl_reset_device(lis))
+		dev_err(&spi->dev, "device BOOT reload failed\n");
+
+	lis->regs[LIS302DL_REG_CTRL1] |=	LIS302DL_CTRL1_PD |
+						LIS302DL_CTRL1_Xen |
+						LIS302DL_CTRL1_Yen |
+						LIS302DL_CTRL1_Zen;
+
+	/* restore registers after resume */
+	for (n = 0; n < ARRAY_SIZE(regs_to_save); n++)
+		__reg_write(lis, regs_to_save[n], lis->regs[regs_to_save[n]]);
+
+	/* if someone had us open, reset the non-wake threshold stuff */
+	if (lis->flags & LIS302DL_F_INPUT_OPEN)
+		__enable_data_collection(lis);
+
+	local_irq_restore(flags);
+	enable_irq(lis->pdata->interrupt);
+
+	return 0;
+}
+#else
+#define lis302dl_suspend	NULL
+#define lis302dl_resume		NULL
+#endif
+
+static struct spi_driver lis302dl_spi_driver = {
+	.driver = {
+		.name = "lis302dl",
+		.owner = THIS_MODULE,
+	},
+
+	.probe 	= lis302dl_probe,	
+	.remove	= __devexit_p(lis302dl_remove),
+	.suspend = lis302dl_suspend,
+	.resume	 = lis302dl_resume,
+};
+
+static int __devinit lis302dl_init(void)
+{
+	return spi_register_driver(&lis302dl_spi_driver);
+}
+
+static void __exit lis302dl_exit(void)
+{
+	spi_unregister_driver(&lis302dl_spi_driver);
+}
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_LICENSE("GPL");
+
+module_init(lis302dl_init);
+module_exit(lis302dl_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/misc/Makefile linux-2.6.29-rc3.owrt.om/drivers/input/misc/Makefile
--- linux-2.6.29-rc3.owrt/drivers/input/misc/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/misc/Makefile	2009-05-10 22:29:16.000000000 +0200
@@ -21,5 +21,7 @@
 obj-$(CONFIG_INPUT_UINPUT)		+= uinput.o
 obj-$(CONFIG_INPUT_APANEL)		+= apanel.o
 obj-$(CONFIG_INPUT_SGI_BTNS)		+= sgi_btns.o
+obj-$(CONFIG_INPUT_LIS302DL)		+= lis302dl.o
 obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
+obj-$(CONFIG_INPUT_PCF50606_PMU)	+= pcf50606-input.o
 obj-$(CONFIG_INPUT_GPIO_BUTTONS)	+= gpio_buttons.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/misc/pcf50606-input.c linux-2.6.29-rc3.owrt.om/drivers/input/misc/pcf50606-input.c
--- linux-2.6.29-rc3.owrt/drivers/input/misc/pcf50606-input.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/misc/pcf50606-input.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,140 @@
+/* Philips PCF50606 Input Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte, Matt Hsu, Andy Green and Werner Almesberger
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+
+#include <linux/mfd/pcf50606/core.h>
+
+#define PCF50606_OOCS_ONKEY		0x01
+#define PCF50606_OOCS_EXTON	 	0x02
+
+#define PCF50606_OOCC2_ONKEYDB_NONE	0x00
+#define PCF50606_OOCC2_ONKEYDB_14ms	0x01
+#define PCF50606_OOCC2_ONKEYDB_62ms	0x02
+#define PCF50606_OOCC2_ONKEYDB_500ms	0x03
+#define PCF50606_OOCC2_EXTONDB_NONE	0x00
+#define PCF50606_OOCC2_EXTONDB_14ms	0x04
+#define PCF50606_OOCC2_EXTONDB_62ms	0x08
+#define PCF50606_OOCC2_EXTONDB_500ms	0x0c
+
+#define PCF50606_REG_OOCS 	0x01
+
+struct pcf50606_input {
+	struct pcf50606 *pcf;
+	struct input_dev *input_dev;
+};
+
+static void
+pcf50606_input_irq(int irq, void *data)
+{
+	struct pcf50606_input *input;
+	int onkey_released;
+
+	input = data;
+	onkey_released = pcf50606_reg_read(input->pcf, PCF50606_REG_OOCS) &
+						PCF50606_OOCS_ONKEY;
+
+	if (irq == PCF50606_IRQ_ONKEYF && !onkey_released)
+		input_report_key(input->input_dev, KEY_POWER, 1);
+	else if (irq == PCF50606_IRQ_ONKEYR && onkey_released)
+		input_report_key(input->input_dev, KEY_POWER, 0);
+
+	input_sync(input->input_dev);
+}
+
+static int __devinit pcf50606_input_probe(struct platform_device *pdev)
+{
+	struct pcf50606_input *input;
+	struct pcf50606_subdev_pdata *pdata = pdev->dev.platform_data;
+	struct input_dev *input_dev;
+	int ret;
+
+
+	input = kzalloc(sizeof(*input), GFP_KERNEL);
+	if (!input)
+		return -ENOMEM;
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		kfree(input);
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, input);
+	input->pcf = pdata->pcf;
+	input->input_dev = input_dev;
+
+	input_dev->name = "PCF50606 PMU events";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->evbit[0] = BIT(EV_KEY) | BIT(EV_PWR);
+	set_bit(KEY_POWER, input_dev->keybit);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		input_free_device(input_dev);
+		kfree(input);
+		return ret;
+	}
+	pcf50606_register_irq(pdata->pcf, PCF50606_IRQ_ONKEYR,
+				pcf50606_input_irq, input);
+	pcf50606_register_irq(pdata->pcf, PCF50606_IRQ_ONKEYF,
+				pcf50606_input_irq, input);
+
+	return 0;
+}
+
+static int __devexit pcf50606_input_remove(struct platform_device *pdev)
+{
+	struct pcf50606_input *input  = platform_get_drvdata(pdev);
+
+	input_unregister_device(input->input_dev);
+	pcf50606_free_irq(input->pcf, PCF50606_IRQ_ONKEYR);
+	pcf50606_free_irq(input->pcf, PCF50606_IRQ_ONKEYF);
+
+	kfree(input);
+
+	return 0;
+}
+
+static struct platform_driver pcf50606_input_driver = {
+	.driver = {
+		.name = "pcf50606-input",
+	},
+	.probe = pcf50606_input_probe,
+	.remove = __devexit_p(pcf50606_input_remove),
+};
+
+static int __init pcf50606_input_init(void)
+{
+	return platform_driver_register(&pcf50606_input_driver);
+}
+module_init(pcf50606_input_init);
+
+static void __exit pcf50606_input_exit(void)
+{
+	platform_driver_unregister(&pcf50606_input_driver);
+}
+module_exit(pcf50606_input_exit);
+
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_DESCRIPTION("PCF50606 input driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pcf50606-input");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/mousedev.c linux-2.6.29-rc3.owrt.om/drivers/input/mousedev.c
--- linux-2.6.29-rc3.owrt/drivers/input/mousedev.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/mousedev.c	2009-05-10 22:27:59.000000000 +0200
@@ -1015,6 +1015,7 @@
 		.evbit = { BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) },
 		.relbit = { BIT_MASK(REL_WHEEL) },
 	},	/* A separate scrollwheel */
+#if 0
 	{
 		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
 				INPUT_DEVICE_ID_MATCH_KEYBIT |
@@ -1024,6 +1025,7 @@
 		.absbit = { BIT_MASK(ABS_X) | BIT_MASK(ABS_Y) },
 	},	/* A tablet like device, at least touch detection,
 		   two absolute axes */
+#endif
 	{
 		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
 				INPUT_DEVICE_ID_MATCH_KEYBIT |
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/Kconfig linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -11,6 +11,54 @@
 
 if INPUT_TOUCHSCREEN
 
+menuconfig TOUCHSCREEN_FILTER
+	boolean "Touchscreen Filtering"
+	depends on INPUT_TOUCHSCREEN
+	select TOUCHSCREEN_FILTER_GROUP
+	select TOUCHSCREEN_FILTER_MEDIAN
+	select TOUCHSCREEN_FILTER_MEAN
+	select TOUCHSCREEN_FILTER_LINEAR
+	help
+	  Select this to include kernel touchscreen filter support.  The filters
+	  can be combined in any order in your machine init and the parameters
+	  for them can also be set there.
+
+if TOUCHSCREEN_FILTER
+
+config TOUCHSCREEN_FILTER_GROUP
+	bool "Group Touchscreen Filter"
+	depends on INPUT_TOUCHSCREEN && TOUCHSCREEN_FILTER
+	default Y
+	help
+	  Say Y here if you want to use the Group touchscreen filter, it
+	  avoids using atypical samples.
+
+config TOUCHSCREEN_FILTER_MEDIAN
+	bool "Median Average Touchscreen Filter"
+	depends on INPUT_TOUCHSCREEN && TOUCHSCREEN_FILTER
+	default Y
+	help
+	  Say Y here if you want to use the Median touchscreen filter, it's
+	  highly effective if you data is noisy with occasional excursions.
+
+config TOUCHSCREEN_FILTER_MEAN
+	bool "Mean Average Touchscreen Filter"
+	depends on INPUT_TOUCHSCREEN && TOUCHSCREEN_FILTER
+	default Y
+	help
+	  Say Y here if you want to use the Mean touchscreen filter, it
+	  can further improve decent quality data by removing jitter
+
+config TOUCHSCREEN_FILTER_LINEAR
+	bool "Linear Touchscreen Filter"
+	depends on INPUT_TOUCHSCREEN && TOUCHSCREEN_FILTER
+	default Y
+	help
+	  Say Y here if you want to use the Linear touchscreen filter, it
+	  enables the use of calibration data for the touchscreen.
+
+endif
+
 config TOUCHSCREEN_ADS7846
 	tristate "ADS7846/TSC2046 and ADS7843 based touchscreens"
 	depends on SPI_MASTER
@@ -79,6 +127,24 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called fujitsu-ts.
 
+config TOUCHSCREEN_S3C2410
+	tristate "Samsung S3C2410 touchscreen input driver"
+	depends on ARCH_S3C2410 && INPUT && INPUT_TOUCHSCREEN
+	select SERIO
+	help
+	  Say Y here if you have the s3c2410 touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called s3c2410_ts.
+
+config TOUCHSCREEN_S3C2410_DEBUG
+	boolean "Samsung S3C2410 touchscreen debug messages"
+	depends on TOUCHSCREEN_S3C2410
+	help
+	  Select this if you want debug messages
+
 config TOUCHSCREEN_GUNZE
 	tristate "Gunze AHL-51S touchscreen"
 	select SERIO
@@ -408,4 +474,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called tsc2007.
 
+config TOUCHSCREEN_PCAP7200
+	tristate "EETI Projected capacitive touchscreen controller"
+	help
+	  Say Y here if you have the EETI PCAP7200 touchscreen
+	  controller chip in your system.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called pcap7200.
 endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/Makefile linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/Makefile
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -34,3 +34,10 @@
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9712)	+= wm9712.o
 wm97xx-ts-$(CONFIG_TOUCHSCREEN_WM9713)	+= wm9713.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
+obj-$(CONFIG_TOUCHSCREEN_S3C2410)	+= s3c2410_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FILTER)	+= ts_filter_chain.o
+obj-$(CONFIG_TOUCHSCREEN_FILTER_GROUP)	+= ts_filter_group.o
+obj-$(CONFIG_TOUCHSCREEN_FILTER_LINEAR)	+= ts_filter_linear.o
+obj-$(CONFIG_TOUCHSCREEN_FILTER_MEDIAN)	+= ts_filter_median.o
+obj-$(CONFIG_TOUCHSCREEN_FILTER_MEAN)	+= ts_filter_mean.o
+obj-$(CONFIG_TOUCHSCREEN_PCAP7200)	+= pcap7200_ts.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/pcap7200_ts.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/pcap7200_ts.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/pcap7200_ts.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/pcap7200_ts.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,309 @@
+ /* Projected capacitive touchscreen controller driver.
+ *
+ * Copyright(c) 2008 Openmoko Inc.
+ *
+ * Author: Matt Hsu <matt_hsu@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * TODO
+ * - apply ts_filter
+ * - add support for gesture event
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/input.h>
+#include <linux/device.h>
+
+#include <linux/pcap7200.h>
+#include <../drivers/input/touchscreen/ts_filter.h>
+
+#include <mach/om-3d7k.h>
+
+#define PCAP7200_OP_MODE_REG	0x07
+#define RPT_PKT_SIZE 	5
+#define EVENT_UP 	0x80
+#define EVENT_DOWN 	0x81
+
+
+#define coord_interpret(msb_byte, lsb_byte) \
+			(msb_byte << 7 | lsb_byte)
+
+struct pcap7200_data{
+	struct i2c_client *client;
+	struct input_dev *dev;
+	struct ts_filter **tsf;
+	struct mutex lock;
+	int irq;
+	struct work_struct work;
+};
+
+static void pcap7200_work(struct work_struct *work)
+{
+	struct pcap7200_data *pcap =
+		container_of(work, struct pcap7200_data, work);
+	uint8_t rpt_pkt[RPT_PKT_SIZE], event;
+	int coords[2];
+	int ret;
+
+	mutex_lock(&pcap->lock);
+
+	memset(rpt_pkt, 0, sizeof(rpt_pkt));
+
+	BUG_ON(pcap == NULL);
+
+	ret = i2c_master_recv(pcap->client, rpt_pkt, RPT_PKT_SIZE);
+
+	event = rpt_pkt[0];
+
+	/*
+	 * this is annonying. system would receive two consecutive interrupts if we set INT
+	 * type as LOW_LEVEL. the data we pull from pcap7200 are invalid which are all
+	 * zero in the second interrupt.
+	 */
+	if (event != 0) {
+		dev_dbg(&pcap->client->dev, "[%2x][%2x][%2x][%2x][%2x]: %d bytes return \n",
+					rpt_pkt[0], rpt_pkt[1], rpt_pkt[2],
+					rpt_pkt[3], rpt_pkt[4], ret);
+
+		coords[0] = coord_interpret(rpt_pkt[1], rpt_pkt[2]);
+		coords[1] = coord_interpret(rpt_pkt[3], rpt_pkt[4]);
+
+		if (event == EVENT_DOWN) {
+			input_report_abs(pcap->dev, ABS_X, coords[0]);
+			input_report_abs(pcap->dev, ABS_Y, coords[1]);
+			input_report_key(pcap->dev, BTN_TOUCH, 1);
+			input_report_abs(pcap->dev, ABS_PRESSURE, 1);
+		} else if (event == EVENT_UP) {
+			input_report_key(pcap->dev, BTN_TOUCH, 0);
+			input_report_abs(pcap->dev, ABS_PRESSURE, 0);
+		} else {
+			/* FIMXE: gesture events should be reported here. */
+		}
+
+		input_sync(pcap->dev);
+	}
+
+	mutex_unlock(&pcap->lock);
+	enable_irq(pcap->irq);
+}
+
+static const char *op_mode_name[] = {
+	[SLEEP] 		= "sleep",
+	[WAKEUP] 		= "wakeup",
+	[SINGLE_TOUCH] 		= "single_touch",
+	[MULTI_TOUCH] 		= "multi_touch",
+};
+
+static struct i2c_driver pcap7200_driver;
+
+static int __set_op_mode(struct pcap7200_data *pcap, u_int8_t val)
+{
+	u8 buf[] = { PCAP7200_OP_MODE_REG, val};
+	int ret, i;
+
+	mutex_lock(&pcap->lock);
+
+	val = val & 0x03;
+
+	/* this chip has an issue.
+	 * you need to give wakeup call for 3 times if it's
+	 * in sleep mode.
+	 */
+	if (val == WAKEUP) {
+		for (i = 0; i < 3; i++)
+			ret = i2c_master_send(pcap->client, buf, sizeof(buf));
+	} else
+		ret = i2c_master_send(pcap->client, buf, sizeof(buf));
+
+	mutex_unlock(&pcap->lock);
+	return ret;
+}
+
+static ssize_t set_op_mode(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcap7200_data *pcap = i2c_get_clientdata(client);
+	u_int8_t i;
+
+	for (i = 0; i < ARRAY_SIZE(op_mode_name); i++) {
+		if (!strncmp(buf, op_mode_name[i], strlen(op_mode_name[i])))
+			__set_op_mode(pcap, i);
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(op_mode, S_IRUGO | S_IWUSR, NULL, set_op_mode);
+
+static irqreturn_t pcap7200_irq(int irq, void *_pcap)
+{
+	struct pcap7200_data *pcap = _pcap;
+
+	disable_irq(pcap->irq);
+	schedule_work(&pcap->work);
+
+	return IRQ_HANDLED;
+}
+
+static int
+pcap7200_probe(struct i2c_client *client, const struct i2c_device_id *ids)
+{
+	struct pcap7200_data *pcap;
+	struct input_dev *input_dev;
+	int err;
+	struct pcap7200_platform_data *pdata = client->dev.platform_data;
+
+	/* allocate pcap7200 data */
+	pcap = kzalloc(sizeof(struct pcap7200_data), GFP_KERNEL);
+	if (!pcap)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, pcap);
+	pcap->client = client;
+
+	mutex_init(&pcap->lock);
+
+	/* reset */
+	if (pdata->reset) {
+		pdata->reset();
+		dev_dbg(&client->dev, "hard reset\n");
+	}
+
+	/* operating mode */
+	__set_op_mode(pcap, pdata->mode);
+
+	/* initialize input device */
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		dev_err(&client->dev, "Unable to allocate the input device\n");
+		err = -ENOMEM;
+		goto exit_kfree;
+	}
+
+	pcap->dev = input_dev;
+	input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) |
+					BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	/* configurable resolution 2048x2048 */
+	input_set_abs_params(pcap->dev, ABS_X, 0, 0x7FF, 0, 0);
+	input_set_abs_params(pcap->dev, ABS_Y, 0, 0x7FF, 0, 0);
+	input_set_abs_params(pcap->dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	input_dev->name = client->name;
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &client->dev;
+
+	err = input_register_device(input_dev);
+
+	if (err)
+		goto exit_unreg;
+
+	INIT_WORK(&pcap->work, pcap7200_work);
+
+	err = sysfs_create_file(&client->dev.kobj, &dev_attr_op_mode.attr);
+
+	if (err) {
+		dev_err(&client->dev, "Failed to create sysfs\n");
+		goto exit_unreg;
+	}
+
+	/* setup IRQ */
+	if (client->irq < 0) {
+		dev_err(&client->dev,
+			"No irq allocated in client resources!\n");
+		goto exit_rmsysfs;
+	}
+
+	pcap->irq = client->irq;
+	err = request_irq(pcap->irq, pcap7200_irq, IRQF_TRIGGER_LOW, "pcap7200", pcap);
+
+	if (err < 0)
+		goto exit_rmsysfs;
+
+	return 0;
+
+exit_rmsysfs:
+	sysfs_remove_file(&client->dev.kobj, &dev_attr_op_mode.attr);
+exit_unreg:
+	input_unregister_device(input_dev);
+exit_kfree:
+	kfree(pcap);
+	return err;
+}
+
+static int pcap7200_remove(struct i2c_client *client)
+{
+	struct pcap7200_data *pcap = i2c_get_clientdata(client);
+
+	free_irq(pcap->irq, pcap);
+	input_unregister_device(pcap->dev);
+	kfree(pcap);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pcap7200_suspend(struct device *dev, pm_message_t state)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcap7200_data *pcap = i2c_get_clientdata(client);
+
+	__set_op_mode(pcap, SLEEP);
+	return 0;
+}
+
+static int pcap7200_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct pcap7200_data *pcap = i2c_get_clientdata(client);
+
+	__set_op_mode(pcap, WAKEUP);
+	return 0;
+}
+#else
+#define pcap7200_suspend NULL
+#define pcap7200_resume NULL
+#endif
+
+static struct i2c_device_id pcap7200_id_table[] = {
+	{"pcap7200", 0x0a},
+};
+
+static struct i2c_driver pcap7200_driver = {
+	.driver = {
+		.name	 = "pcap7200",
+		.suspend = pcap7200_suspend,
+		.resume	 = pcap7200_resume,
+	},
+	.id_table	= pcap7200_id_table,
+	.probe 		= pcap7200_probe,
+	.remove 	= pcap7200_remove,
+};
+
+static int __init pcap7200_init(void)
+{
+	return i2c_add_driver(&pcap7200_driver);
+}
+
+static void pcap7200_exit(void)
+{
+	i2c_del_driver(&pcap7200_driver);
+}
+module_init(pcap7200_init);
+module_exit(pcap7200_exit);
+
+MODULE_AUTHOR("Matt Hsu <matt_hsu@openmoko.org>");
+MODULE_LICENSE("GPLv2");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/s3c2410_ts.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/s3c2410_ts.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/s3c2410_ts.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/s3c2410_ts.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,593 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (c) 2004 Arnaud Patard <arnaud.patard@rtp-net.org>
+ * iPAQ H1940 touchscreen support
+ *
+ * ChangeLog
+ *
+ * 2004-09-05: Herbert Ptzl <herbert@13thfloor.at>
+ *      - added clock (de-)allocation code
+ *
+ * 2005-03-06: Arnaud Patard <arnaud.patard@rtp-net.org>
+ *      - h1940_ -> s3c2410 (this driver is now also used on the n30
+ *        machines :P)
+ *      - Debug messages are now enabled with the config option
+ *        TOUCHSCREEN_S3C2410_DEBUG
+ *      - Changed the way the value are read
+ *      - Input subsystem should now work
+ *      - Use ioremap and readl/writel
+ *
+ * 2005-03-23: Arnaud Patard <arnaud.patard@rtp-net.org>
+ *      - Make use of some undocumented features of the touchscreen
+ *        controller
+ *
+ * 2007-05-23: Harald Welte <laforge@openmoko.org>
+ *      - Add proper support for S32440
+ *
+ * 2008-06-23: Andy Green <andy@openmoko.com>
+ *      - removed averaging system
+ *      - added generic Touchscreen filter stuff
+ *
+ * 2008-11-27: Nelson Castillo <arhuaco@freaks-unidos.net>
+ *      - improve interrupt handling
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/timer.h>
+#include <linux/kfifo.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include <mach/regs-gpio.h>
+#include <mach/ts.h>
+#include <mach/hardware.h>
+#include <plat/regs-adc.h>
+
+#include "ts_filter_chain.h"
+
+/* For ts.dev.id.version */
+#define S3C2410TSVERSION	0x0101
+
+#define TSC_SLEEP  (S3C2410_ADCTSC_PULL_UP_DISABLE | S3C2410_ADCTSC_XY_PST(0))
+
+#define WAIT4INT(x)  (((x)<<8) | \
+		     S3C2410_ADCTSC_YM_SEN | \
+		     S3C2410_ADCTSC_YP_SEN | \
+		     S3C2410_ADCTSC_XP_SEN | \
+		     S3C2410_ADCTSC_XY_PST(3))
+
+#define AUTOPST	     (S3C2410_ADCTSC_YM_SEN | \
+		      S3C2410_ADCTSC_YP_SEN | \
+		      S3C2410_ADCTSC_XP_SEN | \
+		      S3C2410_ADCTSC_AUTO_PST | \
+		      S3C2410_ADCTSC_XY_PST(0))
+
+#define DEBUG_LVL    KERN_DEBUG
+
+MODULE_AUTHOR("Arnaud Patard <arnaud.patard@rtp-net.org>");
+MODULE_DESCRIPTION("s3c2410 touchscreen driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Definitions & global arrays.
+ */
+
+static char *s3c2410ts_name = "s3c2410 TouchScreen";
+
+#define TS_RELEASE_TIMEOUT (HZ >> 7 ? HZ >> 7 : 1) /* 8ms (5ms if HZ is 200) */
+#define TS_EVENT_FIFO_SIZE (2 << 6) /* must be a power of 2 */
+
+#define TS_STATE_STANDBY 0 /* initial state */
+#define TS_STATE_PRESSED 1
+#define TS_STATE_RELEASE_PENDING 2
+#define TS_STATE_RELEASE 3
+
+/*
+ * Per-touchscreen data.
+ */
+
+struct s3c2410ts {
+	struct input_dev *dev;
+	struct ts_filter_chain *chain;
+	int is_down;
+	int state;
+	struct kfifo *event_fifo;
+};
+
+static struct s3c2410ts ts;
+
+static void __iomem *base_addr;
+
+/*
+ * A few low level functions.
+ */
+
+static inline void s3c2410_ts_connect(void)
+{
+	s3c2410_gpio_cfgpin(S3C2410_GPG12, S3C2410_GPG12_XMON);
+	s3c2410_gpio_cfgpin(S3C2410_GPG13, S3C2410_GPG13_nXPON);
+	s3c2410_gpio_cfgpin(S3C2410_GPG14, S3C2410_GPG14_YMON);
+	s3c2410_gpio_cfgpin(S3C2410_GPG15, S3C2410_GPG15_nYPON);
+}
+
+static void s3c2410_ts_start_adc_conversion(void)
+{
+	writel(S3C2410_ADCTSC_PULL_UP_DISABLE | AUTOPST,
+	       base_addr + S3C2410_ADCTSC);
+	writel(readl(base_addr + S3C2410_ADCCON) | S3C2410_ADCCON_ENABLE_START,
+	       base_addr + S3C2410_ADCCON);
+}
+
+/*
+ * Just send the input events.
+ */
+
+enum ts_input_event {IE_DOWN = 0, IE_UP};
+
+static void ts_input_report(int event, int coords[])
+{
+#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
+	static char *s[] = {"down", "up"};
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+#endif
+
+	if (event == IE_DOWN) {
+		input_report_abs(ts.dev, ABS_X, coords[0]);
+		input_report_abs(ts.dev, ABS_Y, coords[1]);
+		input_report_key(ts.dev, BTN_TOUCH, 1);
+		input_report_abs(ts.dev, ABS_PRESSURE, 1);
+
+#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
+		printk(DEBUG_LVL "T:%06d %6s (X:%03d, Y:%03d)\n",
+		       (int)tv.tv_usec, s[event], coords[0], coords[1]);
+#endif
+	} else {
+		input_report_key(ts.dev, BTN_TOUCH, 0);
+		input_report_abs(ts.dev, ABS_PRESSURE, 0);
+
+#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
+		printk(DEBUG_LVL "T:%06d %6s\n",
+		       (int)tv.tv_usec, s[event]);
+#endif
+	}
+
+	input_sync(ts.dev);
+}
+
+/*
+ * Manage the state of the touchscreen.
+ */
+
+static void event_send_timer_f(unsigned long data);
+
+static struct timer_list event_send_timer =
+		TIMER_INITIALIZER(event_send_timer_f, 0, 0);
+
+static void event_send_timer_f(unsigned long data)
+{
+	static int noop_counter;
+	int event_type;
+
+	while (__kfifo_get(ts.event_fifo, (unsigned char *)&event_type,
+			   sizeof(int))) {
+		int buf[2];
+
+		switch (event_type) {
+		case 'D':
+			if (ts.state == TS_STATE_RELEASE_PENDING)
+				/* Ignore short UP event */
+				ts.state = TS_STATE_PRESSED;
+			break;
+
+		case 'U':
+			ts.state = TS_STATE_RELEASE_PENDING;
+			break;
+
+		case 'P':
+			if (ts.is_down) /* stylus_action needs a conversion */
+				s3c2410_ts_start_adc_conversion();
+
+			if (unlikely(__kfifo_get(ts.event_fifo,
+						 (unsigned char *)buf,
+						 sizeof(int) * 2)
+				     != sizeof(int) * 2))
+				goto ts_exit_error;
+
+			ts_input_report(IE_DOWN, buf);
+			ts.state = TS_STATE_PRESSED;
+			break;
+
+		default:
+			goto ts_exit_error;
+		}
+
+		noop_counter = 0;
+	}
+
+	if (noop_counter++ >= 1) {
+		noop_counter = 0;
+		if (ts.state == TS_STATE_RELEASE_PENDING) {
+			/*
+			 * We delay the UP event for a while to avoid jitter.
+			 * If we get a DOWN event we do not send it.
+			 */
+			ts_input_report(IE_UP, NULL);
+			ts.state = TS_STATE_STANDBY;
+
+			ts_filter_chain_clear(ts.chain);
+		}
+	} else {
+		mod_timer(&event_send_timer, jiffies + TS_RELEASE_TIMEOUT);
+	}
+
+	return;
+
+ts_exit_error: /* should not happen unless we have a bug */
+	printk(KERN_ERR __FILE__ ": event_send_timer_f failed\n");
+}
+
+/*
+ * Manage interrupts.
+ */
+
+static irqreturn_t stylus_updown(int irq, void *dev_id)
+{
+	unsigned long data0;
+	unsigned long data1;
+	int event_type;
+
+	data0 = readl(base_addr+S3C2410_ADCDAT0);
+	data1 = readl(base_addr+S3C2410_ADCDAT1);
+
+	ts.is_down = (!(data0 & S3C2410_ADCDAT0_UPDOWN)) &&
+					    (!(data1 & S3C2410_ADCDAT0_UPDOWN));
+
+	event_type = ts.is_down ? 'D' : 'U';
+
+	if (unlikely(__kfifo_put(ts.event_fifo, (unsigned char *)&event_type,
+		     sizeof(int)) != sizeof(int))) /* should not happen */
+		printk(KERN_ERR __FILE__": stylus_updown lost event!\n");
+
+	if (ts.is_down)
+		s3c2410_ts_start_adc_conversion();
+	else
+		writel(WAIT4INT(0), base_addr+S3C2410_ADCTSC);
+
+	mod_timer(&event_send_timer, jiffies + 1);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stylus_action(int irq, void *dev_id)
+{
+	int buf[3];
+
+	/* Grab the ADC results. */
+	buf[1] = readl(base_addr + S3C2410_ADCDAT0) &
+		       S3C2410_ADCDAT0_XPDATA_MASK;
+	buf[2] = readl(base_addr + S3C2410_ADCDAT1) &
+		       S3C2410_ADCDAT1_YPDATA_MASK;
+
+	switch (ts_filter_chain_feed(ts.chain, &buf[1])) {
+	case 0:
+		/* The filter wants more points. */
+		s3c2410_ts_start_adc_conversion();
+		return IRQ_HANDLED;
+	case 1:
+		/* We have a point from the filters or no filtering enabled. */
+		buf[0] = 'P';
+		break;
+	default:
+		printk(KERN_ERR __FILE__
+		       ":%d Invalid ts_filter_chain_feed return value.\n",
+		       __LINE__);
+	case -1:
+		/* Error. Ignore the event. */
+		ts_filter_chain_clear(ts.chain);
+		writel(WAIT4INT(1), base_addr + S3C2410_ADCTSC);
+		return IRQ_HANDLED;
+	};
+
+	if (unlikely(__kfifo_put(ts.event_fifo, (unsigned char *)buf,
+		     sizeof(int) * 3) != sizeof(int) * 3))
+		printk(KERN_ERR __FILE__":stylus_action bug.\n");
+
+	writel(WAIT4INT(1), base_addr + S3C2410_ADCTSC);
+	mod_timer(&event_send_timer, jiffies + 1);
+
+	return IRQ_HANDLED;
+}
+
+static struct clk	*adc_clock;
+
+/*
+ * The functions for inserting/removing us as a module.
+ */
+
+static int __init s3c2410ts_probe(struct platform_device *pdev)
+{
+	int rc;
+	struct s3c2410_ts_mach_info *info;
+	struct input_dev *input_dev;
+	int ret = 0;
+
+	dev_info(&pdev->dev, "Starting\n");
+
+	info = (struct s3c2410_ts_mach_info *)pdev->dev.platform_data;
+
+	if (!info)
+	{
+		dev_err(&pdev->dev, "Hm... too bad: no platform data for ts\n");
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
+	printk(DEBUG_LVL "Entering s3c2410ts_init\n");
+#endif
+
+	adc_clock = clk_get(NULL, "adc");
+	if (!adc_clock) {
+		dev_err(&pdev->dev, "failed to get adc clock source\n");
+		return -ENOENT;
+	}
+	clk_enable(adc_clock);
+
+#ifdef CONFIG_TOUCHSCREEN_S3C2410_DEBUG
+	printk(DEBUG_LVL "got and enabled clock\n");
+#endif
+
+	base_addr = ioremap(S3C2410_PA_ADC,0x20);
+	if (base_addr == NULL) {
+		dev_err(&pdev->dev, "Failed to remap register block\n");
+		ret = -ENOMEM;
+		goto bail0;
+	}
+
+
+	/* If we acutally are a S3C2410: Configure GPIOs */
+	if (!strcmp(pdev->name, "s3c2410-ts"))
+		s3c2410_ts_connect();
+
+	if ((info->presc & 0xff) > 0)
+		writel(S3C2410_ADCCON_PRSCEN |
+		       S3C2410_ADCCON_PRSCVL(info->presc&0xFF),
+						    base_addr + S3C2410_ADCCON);
+	else
+		writel(0, base_addr+S3C2410_ADCCON);
+
+	/* Initialise registers */
+	if ((info->delay & 0xffff) > 0)
+		writel(info->delay & 0xffff,  base_addr + S3C2410_ADCDLY);
+
+	writel(WAIT4INT(0), base_addr + S3C2410_ADCTSC);
+
+	/* Initialise input stuff */
+	memset(&ts, 0, sizeof(struct s3c2410ts));
+	input_dev = input_allocate_device();
+
+	if (!input_dev) {
+		dev_err(&pdev->dev, "Unable to allocate the input device\n");
+		ret = -ENOMEM;
+		goto bail1;
+	}
+
+	ts.dev = input_dev;
+	ts.dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) |
+			   BIT_MASK(EV_ABS);
+	ts.dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(ts.dev, ABS_X, 0, 0x3FF, 0, 0);
+	input_set_abs_params(ts.dev, ABS_Y, 0, 0x3FF, 0, 0);
+	input_set_abs_params(ts.dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	ts.dev->name = s3c2410ts_name;
+	ts.dev->id.bustype = BUS_RS232;
+	ts.dev->id.vendor = 0xDEAD;
+	ts.dev->id.product = 0xBEEF;
+	ts.dev->id.version = S3C2410TSVERSION;
+	ts.state = TS_STATE_STANDBY;
+	ts.event_fifo = kfifo_alloc(TS_EVENT_FIFO_SIZE, GFP_KERNEL, NULL);
+	if (IS_ERR(ts.event_fifo)) {
+		ret = -EIO;
+		goto bail2;
+	}
+
+	/* create the filter chain set up for the 2 coordinates we produce */
+	ts.chain = ts_filter_chain_create(pdev, info->filter_config, 2);
+
+	if (IS_ERR(ts.chain))
+		goto bail2;
+
+	ts_filter_chain_clear(ts.chain);
+
+	/* Get irqs */
+	if (request_irq(IRQ_ADC, stylus_action, IRQF_SAMPLE_RANDOM,
+						    "s3c2410_action", ts.dev)) {
+		dev_err(&pdev->dev, "Could not allocate ts IRQ_ADC !\n");
+		iounmap(base_addr);
+		ret = -EIO;
+		goto bail3;
+	}
+	if (request_irq(IRQ_TC, stylus_updown, IRQF_SAMPLE_RANDOM,
+			"s3c2410_action", ts.dev)) {
+		dev_err(&pdev->dev, "Could not allocate ts IRQ_TC !\n");
+		free_irq(IRQ_ADC, ts.dev);
+		iounmap(base_addr);
+		ret = -EIO;
+		goto bail4;
+	}
+
+	dev_info(&pdev->dev, "Successfully loaded\n");
+
+	/* All went ok, so register to the input system */
+	rc = input_register_device(ts.dev);
+	if (rc) {
+		ret = -EIO;
+		goto bail5;
+	}
+
+	return 0;
+
+bail5:
+	free_irq(IRQ_TC, ts.dev);
+	free_irq(IRQ_ADC, ts.dev);
+	clk_disable(adc_clock);
+	iounmap(base_addr);
+	disable_irq(IRQ_TC);
+bail4:
+	disable_irq(IRQ_ADC);
+bail3:
+	ts_filter_chain_destroy(ts.chain);
+	kfifo_free(ts.event_fifo);
+bail2:
+	input_unregister_device(ts.dev);
+bail1:
+	iounmap(base_addr);
+bail0:
+
+	return ret;
+}
+
+static int s3c2410ts_remove(struct platform_device *pdev)
+{
+	disable_irq(IRQ_ADC);
+	disable_irq(IRQ_TC);
+	free_irq(IRQ_TC,ts.dev);
+	free_irq(IRQ_ADC,ts.dev);
+
+	if (adc_clock) {
+		clk_disable(adc_clock);
+		clk_put(adc_clock);
+		adc_clock = NULL;
+	}
+
+	input_unregister_device(ts.dev);
+	iounmap(base_addr);
+
+	ts_filter_chain_destroy(ts.chain);
+
+	kfifo_free(ts.event_fifo);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c2410ts_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	writel(TSC_SLEEP, base_addr+S3C2410_ADCTSC);
+	writel(readl(base_addr+S3C2410_ADCCON) | S3C2410_ADCCON_STDBM,
+	       base_addr+S3C2410_ADCCON);
+
+	disable_irq(IRQ_ADC);
+	disable_irq(IRQ_TC);
+
+	clk_disable(adc_clock);
+
+	return 0;
+}
+
+static int s3c2410ts_resume(struct platform_device *pdev)
+{
+	struct s3c2410_ts_mach_info *info =
+		( struct s3c2410_ts_mach_info *)pdev->dev.platform_data;
+
+	clk_enable(adc_clock);
+	mdelay(1);
+
+	ts_filter_chain_clear(ts.chain);
+
+	enable_irq(IRQ_ADC);
+	enable_irq(IRQ_TC);
+
+	if ((info->presc&0xff) > 0)
+		writel(S3C2410_ADCCON_PRSCEN |
+		       S3C2410_ADCCON_PRSCVL(info->presc&0xFF),
+						      base_addr+S3C2410_ADCCON);
+	else
+		writel(0,base_addr+S3C2410_ADCCON);
+
+	/* Initialise registers */
+	if ((info->delay & 0xffff) > 0)
+		writel(info->delay & 0xffff,  base_addr+S3C2410_ADCDLY);
+
+	writel(WAIT4INT(0), base_addr+S3C2410_ADCTSC);
+
+	return 0;
+}
+
+#else
+#define s3c2410ts_suspend NULL
+#define s3c2410ts_resume  NULL
+#endif
+
+static struct platform_driver s3c2410ts_driver = {
+       .driver         = {
+	       .name   = "s3c2410-ts",
+	       .owner  = THIS_MODULE,
+       },
+       .probe          = s3c2410ts_probe,
+       .remove         = s3c2410ts_remove,
+       .suspend        = s3c2410ts_suspend,
+       .resume         = s3c2410ts_resume,
+
+};
+
+static struct platform_driver s3c2440ts_driver = {
+       .driver         = {
+	       .name   = "s3c2440-ts",
+	       .owner  = THIS_MODULE,
+       },
+       .probe          = s3c2410ts_probe,
+       .remove         = s3c2410ts_remove,
+       .suspend        = s3c2410ts_suspend,
+       .resume         = s3c2410ts_resume,
+
+};
+
+static int __init s3c2410ts_init(void)
+{
+	int rc;
+
+	rc = platform_driver_register(&s3c2410ts_driver);
+	if (rc < 0)
+		return rc;
+
+	rc = platform_driver_register(&s3c2440ts_driver);
+	if (rc < 0)
+		platform_driver_unregister(&s3c2410ts_driver);
+
+	return rc;
+}
+
+static void __exit s3c2410ts_exit(void)
+{
+	platform_driver_unregister(&s3c2440ts_driver);
+	platform_driver_unregister(&s3c2410ts_driver);
+}
+
+module_init(s3c2410ts_init);
+module_exit(s3c2410ts_exit);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_chain.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_chain.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_chain.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_chain.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,183 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (c) 2008,2009 Andy Green <andy@openmoko.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+
+#include "ts_filter_chain.h"
+#include "ts_filter.h"
+
+/*
+ * Tux, would you like the following function in /lib?
+ * It helps us avoid silly code.
+ */
+
+/**
+ * sptrlen - Count how many non-null pointers are in a pointer array
+ * @arr: The array of pointers
+ */
+static int sptrlen(const void *arr)
+{
+	/* All pointers have the same size. */
+	const int **p = (const int **)arr;
+	int len = 0;
+
+	while (*(p++))
+		len++;
+
+	return len;
+}
+
+
+struct ts_filter_chain {
+	/* All of the filters. */
+	struct ts_filter **arr;
+	/* Filters that can propagate values in the chain. */
+	struct ts_filter **pchain;
+	/* Length of the pchain array. */
+	int pchain_len;
+	/* FIXME: Add a spinlock and use it. */
+};
+
+struct ts_filter_chain *ts_filter_chain_create(
+	struct platform_device *pdev,
+	const struct ts_filter_chain_configuration conf[],
+	int count_coords)
+{
+	struct ts_filter_chain *c;
+	int count = 0;
+	int len;
+
+	BUG_ON((count_coords < 1));
+	BUG_ON(count_coords > MAX_TS_FILTER_COORDS);
+
+	c = kzalloc(sizeof(struct ts_filter_chain), GFP_KERNEL);
+	if (!c)
+		goto create_err_1;
+
+	len = (sptrlen(conf) + 1);
+	/* Memory for two null-terminated arrays of filters. */
+	c->arr = kzalloc(2 * sizeof(struct ts_filter *) * len, GFP_KERNEL);
+	if (!c->arr)
+		goto create_err_1;
+	c->pchain = c->arr + len;
+
+	while (conf->api) {
+		/* TODO: Can we get away with only sending pdev->dev? */
+		struct ts_filter *f =
+			(conf->api->create)(pdev, conf->config, count_coords);
+		if (!f) {
+			dev_info(&pdev->dev, "Filter %d creation failed\n",
+				 count);
+			goto create_err_2;
+		}
+
+		f->api = conf->api;
+		c->arr[count++] = f;
+
+		if (f->api->haspoint && f->api->getpoint && f->api->process)
+			c->pchain[c->pchain_len++] = f;
+
+		conf++;
+	}
+
+	dev_info(&pdev->dev, "%d filter(s) initialized\n", count);
+
+	return c;
+
+create_err_2:
+	ts_filter_chain_destroy(c); /* Also frees c. */
+create_err_1:
+	dev_info(&pdev->dev, "Error in filter chain initialization\n");
+	/*
+	 * FIXME: Individual filters have to return errors this way.
+	 * We only have to forward the errors we find.
+	 */
+	return ERR_PTR(-ENOMEM);
+}
+EXPORT_SYMBOL_GPL(ts_filter_chain_create);
+
+void ts_filter_chain_destroy(struct ts_filter_chain *c)
+{
+	if (c->arr) {
+		struct ts_filter **a = c->arr;
+		while (*a) {
+			((*a)->api->destroy)(*a);
+			a++;
+		}
+		kfree(c->arr);
+	}
+	kfree(c);
+}
+EXPORT_SYMBOL_GPL(ts_filter_chain_destroy);
+
+void ts_filter_chain_clear(struct ts_filter_chain *c)
+{
+	struct ts_filter **a = c->arr;
+
+	while (*a) {
+		if ((*a)->api->clear)
+			((*a)->api->clear)(*a);
+		a++;
+	}
+}
+EXPORT_SYMBOL_GPL(ts_filter_chain_clear);
+
+static void ts_filter_chain_scale(struct ts_filter_chain *c, int *coords)
+{
+	struct ts_filter **a = c->arr;
+	while (*a) {
+		if ((*a)->api->scale)
+			((*a)->api->scale)(*a, coords);
+		a++;
+	}
+}
+
+int ts_filter_chain_feed(struct ts_filter_chain *c, int *coords)
+{
+	int len = c->pchain_len;
+	int i = len - 1;
+
+	if (!c->pchain[0])
+		return 1; /* Nothing to do. */
+
+	BUG_ON(c->pchain[0]->api->haspoint(c->pchain[0]));
+
+	if (c->pchain[0]->api->process(c->pchain[0], coords))
+		return -1;
+
+	while (i >= 0 && i < len) {
+		if (c->pchain[i]->api->haspoint(c->pchain[i])) {
+			c->pchain[i]->api->getpoint(c->pchain[i], coords);
+			if (++i < len &&
+			    c->pchain[i]->api->process(c->pchain[i], coords))
+				return -1; /* Error. */
+		} else {
+			i--;
+		}
+	}
+
+	if (i >= 0) {	/* Same as i == len. */
+		ts_filter_chain_scale(c, coords);
+		return 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ts_filter_chain_feed);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_chain.h linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_chain.h
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_chain.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_chain.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,58 @@
+#ifndef __TS_FILTER_CHAIN_H__
+#define __TS_FILTER_CHAIN_H__
+
+/*
+ * Touchscreen filter chains.
+ *
+ * (c) 2008,2009 Andy Green <andy@openmoko.com>
+ */
+
+#include "ts_filter.h"
+
+#include <linux/err.h>
+
+struct ts_filter_chain_configuration {
+	/* API to use. */
+	const struct ts_filter_api *api;
+	/* Generic filter configuration. Different for each filter. */
+	const struct ts_filter_configuration *config;
+};
+
+struct ts_filter_chain;
+
+#ifdef CONFIG_TOUCHSCREEN_FILTER
+
+/*
+ * Create a filter chain. It will allocate an array of
+ * null-terminated pointers to filters. On error it will return
+ * an error you can check with IS_ERR.
+ */
+extern struct ts_filter_chain *ts_filter_chain_create(
+	struct platform_device *pdev,
+	const struct ts_filter_chain_configuration conf[],
+	int count_coords);
+
+/* Destroy the chain. */
+extern void ts_filter_chain_destroy(struct ts_filter_chain *c);
+
+/* Clear the filter chain. */
+extern void ts_filter_chain_clear(struct ts_filter_chain *c);
+
+/*
+ * Try to get one point. Returns 0 if no points are available.
+ * coords will be used as temporal space, thus you supply a point
+ * using coords but you shouldn't rely on its value on return unless
+ * it returns a nonzero value that is not -1.
+ * If one of the filters find an error then this function will
+ * return -1.
+ */
+int ts_filter_chain_feed(struct ts_filter_chain *c, int *coords);
+
+#else /* !CONFIG_TOUCHSCREEN_FILTER */
+#define ts_filter_chain_create(pdev, config, count_coords) (NULL)
+#define ts_filter_chain_destroy(c) do { } while (0)
+#define ts_filter_chain_clear(c) do { } while (0)
+#define ts_filter_chain_feed(c, coords) (1)
+#endif
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_group.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_group.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_group.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_group.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,296 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2008,2009 by Openmoko, Inc.
+ * Author: Nelson Castillo <arhuaco@freaks-unidos.net>
+ * All rights reserved.
+ *
+ *
+ * This filter is useful to reject samples that are not reliable. We consider
+ * that a sample is not reliable if it deviates form the Majority.
+ *
+ * 1) We collect S samples.
+ *
+ * 2) For each dimension:
+ *
+ *  - We sort the points.
+ *  - Points that are "close enough" are considered to be in the same set.
+ *  - We choose the set with more elements. If more than "threshold"
+ *    points are in this set we use the first and the last point of the set
+ *    to define the valid range for this dimension [min, max], otherwise we
+ *    discard all the points and go to step 1.
+ *
+ * 3) We consider the unsorted S samples and try to feed them to the next
+ *    filter in the chain. If one of the points of each sample
+ *    is not in the allowed range for its dimension, we discard the sample.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sort.h>
+#include "ts_filter_group.h"
+
+struct ts_filter_group {
+	/* Private filter configuration. */
+	struct ts_filter_group_configuration *config;
+	/* Filter API. */
+	struct ts_filter tsf;
+
+	int N;			/* How many samples we have. */
+	int *samples[MAX_TS_FILTER_COORDS];	/* The samples: our input. */
+
+	int *group_size;	/* Used for temporal computations. */
+	int *sorted_samples;	/* Used for temporal computations. */
+
+	int range_max[MAX_TS_FILTER_COORDS];	/* Max. computed ranges. */
+	int range_min[MAX_TS_FILTER_COORDS];	/* Min. computed ranges. */
+
+	int tries_left;		/* We finish if we don't get enough samples. */
+	int ready;		/* If we are ready to deliver samples. */
+	int result;		/* Index of the point being returned. */
+};
+
+#define ts_filter_to_filter_group(f) \
+	container_of(f, struct ts_filter_group, tsf)
+
+
+static void ts_filter_group_clear_internal(struct ts_filter_group *tsfg,
+					   int attempts)
+{
+	tsfg->N = 0;
+	tsfg->tries_left = attempts;
+	tsfg->ready = 0;
+	tsfg->result = 0;
+}
+
+static void ts_filter_group_clear(struct ts_filter *tsf)
+{
+	struct ts_filter_group *tsfg = ts_filter_to_filter_group(tsf);
+
+	ts_filter_group_clear_internal(tsfg, tsfg->config->attempts);
+}
+
+static struct ts_filter *ts_filter_group_create(
+	struct platform_device *pdev,
+	const struct ts_filter_configuration *conf,
+	int count_coords)
+{
+	struct ts_filter_group *tsfg;
+	int i;
+
+	tsfg = kzalloc(sizeof(struct ts_filter_group), GFP_KERNEL);
+	if (!tsfg)
+		return NULL;
+
+	tsfg->config = container_of(conf,
+				    struct ts_filter_group_configuration,
+				    config);
+	tsfg->tsf.count_coords = count_coords;
+
+	BUG_ON(tsfg->config->attempts <= 0);
+
+	tsfg->samples[0] = kmalloc((2 + count_coords) * sizeof(int) *
+				   tsfg->config->length, GFP_KERNEL);
+	if (!tsfg->samples[0]) {
+		kfree(tsfg);
+		return NULL;
+	}
+	for (i = 1; i < count_coords; ++i)
+		tsfg->samples[i] = tsfg->samples[0] + i * tsfg->config->length;
+	tsfg->sorted_samples = tsfg->samples[0] + count_coords *
+			       tsfg->config->length;
+	tsfg->group_size = tsfg->samples[0] + (1 + count_coords) *
+			       tsfg->config->length;
+
+	ts_filter_group_clear_internal(tsfg, tsfg->config->attempts);
+
+	dev_info(&pdev->dev, "Created Group filter len:%d coords:%d close:%d "
+		 "thresh:%d\n", tsfg->config->length, count_coords,
+		 tsfg->config->close_enough, tsfg->config->threshold);
+
+	return &tsfg->tsf;
+}
+
+static void ts_filter_group_destroy(struct ts_filter *tsf)
+{
+	struct ts_filter_group *tsfg = ts_filter_to_filter_group(tsf);
+
+	kfree(tsfg->samples[0]); /* first guy has pointer from kmalloc */
+	kfree(tsf);
+}
+
+static int int_cmp(const void *_a, const void *_b)
+{
+	const int *a = _a;
+	const int *b = _b;
+
+	if (*a > *b)
+		return 1;
+	if (*a < *b)
+		return -1;
+	return 0;
+}
+
+static void ts_filter_group_prepare_next(struct ts_filter *tsf);
+
+static int ts_filter_group_process(struct ts_filter *tsf, int *coords)
+{
+	struct ts_filter_group *tsfg = ts_filter_to_filter_group(tsf);
+	int n;
+	int i;
+
+	BUG_ON(tsfg->N >= tsfg->config->length);
+	BUG_ON(tsfg->ready);
+
+	for (n = 0; n < tsf->count_coords; n++)
+		tsfg->samples[n][tsfg->N] = coords[n];
+
+	if (++tsfg->N < tsfg->config->length)
+		return 0;	/* We need more samples. */
+
+	for (n = 0; n < tsfg->tsf.count_coords; n++) {
+		int *v = tsfg->sorted_samples;
+		int ngroups = 0;
+		int best_size;
+		int best_idx = 0;
+		int idx = 0;
+
+		memcpy(v, tsfg->samples[n], tsfg->N * sizeof(int));
+		/*
+		 * FIXME: Remove this sort call. We already have the
+		 * algorithm for this modification. The filter will
+		 * need less points (about half) if there is not a
+		 * lot of noise. Right now we are doing a constant
+		 * amount of work no matter how much noise we are
+		 * dealing with.
+		 */
+		sort(v, tsfg->N, sizeof(int), int_cmp, NULL);
+
+		tsfg->group_size[0] = 1;
+		for (i = 1; i < tsfg->N; ++i) {
+			if (v[i] - v[i - 1] <= tsfg->config->close_enough)
+				tsfg->group_size[ngroups]++;
+			else
+				tsfg->group_size[++ngroups] = 1;
+		}
+		ngroups++;
+
+		best_size = tsfg->group_size[0];
+		for (i = 1; i < ngroups; i++) {
+			idx += tsfg->group_size[i - 1];
+			if (best_size < tsfg->group_size[i]) {
+				best_size = tsfg->group_size[i];
+				best_idx = idx;
+			}
+		}
+
+		if (best_size < tsfg->config->threshold) {
+			/* This set is not good enough for us. */
+			if (--tsfg->tries_left) {
+				ts_filter_group_clear_internal
+					(tsfg, tsfg->tries_left);
+				/* No errors but we need more samples. */
+				return 0;
+			}
+			return 1; /* We give up: error. */
+		}
+
+		tsfg->range_min[n] = v[best_idx];
+		tsfg->range_max[n] = v[best_idx + best_size - 1];
+	}
+
+	ts_filter_group_prepare_next(tsf);
+
+	return 0;
+}
+
+/*
+ * This private function prepares a point that will be returned
+ * in ts_filter_group_getpoint if it is available. It updates
+ * the priv->ready state also.
+ */
+static void ts_filter_group_prepare_next(struct ts_filter *tsf)
+{
+	struct ts_filter_group *priv = ts_filter_to_filter_group(tsf);
+	int n;
+
+	while (priv->result < priv->N) {
+		for (n = 0; n < priv->tsf.count_coords; ++n) {
+			if (priv->samples[n][priv->result] <
+			    priv->range_min[n] ||
+			    priv->samples[n][priv->result] > priv->range_max[n])
+				break;
+		}
+
+		if (n == priv->tsf.count_coords) /* Sample is OK. */
+			break;
+
+		priv->result++;
+	}
+
+	if (unlikely(priv->result >= priv->N)) { /* No sample to deliver. */
+		ts_filter_group_clear_internal(priv, priv->config->attempts);
+		priv->ready = 0;
+	} else {
+		priv->ready = 1;
+	}
+}
+
+static int ts_filter_group_haspoint(struct ts_filter *tsf)
+{
+	struct ts_filter_group *priv = ts_filter_to_filter_group(tsf);
+
+	return priv->ready;
+}
+
+static void ts_filter_group_getpoint(struct ts_filter *tsf, int *point)
+{
+	struct ts_filter_group *priv = ts_filter_to_filter_group(tsf);
+	int n;
+
+	BUG_ON(!priv->ready);
+
+	for (n = 0; n < priv->tsf.count_coords; n++)
+		point[n] = priv->samples[n][priv->result];
+
+	priv->result++;
+
+	/* This call will update priv->ready. */
+	ts_filter_group_prepare_next(tsf);
+}
+
+/*
+ * Get ready to process the next batch of points, forget
+ * points we could have delivered.
+ */
+static void ts_filter_group_scale(struct ts_filter *tsf, int *coords)
+{
+	struct ts_filter_group *priv = ts_filter_to_filter_group(tsf);
+
+	ts_filter_group_clear_internal(priv, priv->config->attempts);
+}
+
+const struct ts_filter_api ts_filter_group_api = {
+	.create =	ts_filter_group_create,
+	.destroy =	ts_filter_group_destroy,
+	.clear =	ts_filter_group_clear,
+	.process =	ts_filter_group_process,
+	.haspoint =	ts_filter_group_haspoint,
+	.getpoint =	ts_filter_group_getpoint,
+	.scale =	ts_filter_group_scale,
+};
+EXPORT_SYMBOL_GPL(ts_filter_group_api);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_group.h linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_group.h
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_group.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_group.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,36 @@
+#ifndef __TS_FILTER_GROUP_H__
+#define __TS_FILTER_GROUP_H__
+
+#include "ts_filter.h"
+
+/*
+ * Touchscreen group filter.
+ *
+ * Copyright (C) 2008,2009 by Openmoko, Inc.
+ * Author: Nelson Castillo <arhuaco@freaks-unidos.net>
+ *
+ */
+
+struct ts_filter_group_configuration {
+	/* Size of the filter. */
+	int length;
+	/*
+	 * If two points are separated by this distance or less they
+	 * are considered to be members of the same group.
+	 */
+	int close_enough;
+	/* Minimum allowed size for the biggest group in the sample set. */
+	int threshold;
+	/*
+	 * Number of times we try to get a group of points with at least
+	 * threshold points.
+	 */
+	int attempts;
+
+	/* Generic filter configuration. */
+	struct ts_filter_configuration config;
+};
+
+extern const struct ts_filter_api ts_filter_group_api;
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter.h linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter.h
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,74 @@
+#ifndef __TS_FILTER_H__
+#define __TS_FILTER_H__
+
+/*
+ * Touchscreen filter.
+ *
+ * (c) 2008,2009 Andy Green <andy@openmoko.com>
+ */
+
+#include <linux/platform_device.h>
+
+#define MAX_TS_FILTER_COORDS		3  /* X, Y and Z (pressure). */
+
+struct ts_filter;
+struct ts_filter_configuration;
+
+/* Operations that a filter can perform. */
+
+struct ts_filter_api {
+	/* Create the filter - mandatory. */
+	struct ts_filter * (*create)(
+		struct platform_device *pdev,
+		const struct ts_filter_configuration *config,
+		int count_coords);
+	/* Destroy the filter - mandatory. */
+	void (*destroy)(struct ts_filter *filter);
+	/* Clear the filter - optional. */
+	void (*clear)(struct ts_filter *filter);
+
+
+	/*
+	 * The next three API functions only make sense if all of them are
+	 * set for a filter. If a filter has the next three methods then
+	 * it can propagate coordinates in the chain.
+	 */
+
+	/*
+	 * Process the filter.
+	 * It returns non-zero if the filter reaches an error.
+	 */
+	int (*process)(struct ts_filter *filter, int *coords);
+	/*
+	 * Is the filter ready to return a point?
+	 * Please do not code side effects in this function.
+	 */
+	int (*haspoint)(struct ts_filter *filter);
+	/*
+	 * Get a point.
+	 * Do not call unless the filter actually has a point to deliver.
+	 */
+	void (*getpoint)(struct ts_filter *filter, int *coords);
+
+	/*
+	 * Scale the points - optional.
+	 * A filter could only scale coordinates.
+	 */
+	void (*scale)(struct ts_filter *filter, int *coords);
+};
+
+/*
+ * Generic filter configuration. Actual configurations have this structure
+ * as a member.
+ */
+struct ts_filter_configuration {
+};
+
+struct ts_filter {
+	/* Operations for this filter. */
+	const struct ts_filter_api *api;
+	/* Number of coordinates to process. */
+	int count_coords;
+};
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_linear.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_linear.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_linear.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_linear.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,212 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2008,2009 by Openmoko, Inc.
+ * Author: Nelson Castillo <arhuaco@freaks-unidos.net>
+ * All rights reserved.
+ *
+ * Linearly scale touchscreen values.
+ *
+ * Expose the TS_FILTER_LINEAR_NCONSTANTS for the linear transformation
+ * using sysfs.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "ts_filter_linear.h"
+
+struct ts_filter_linear;
+
+/* Sysfs code. */
+
+struct const_obj {
+	/* The actual private object. */
+	struct ts_filter_linear *tsfl;
+	/* Our kobject. */
+	struct kobject kobj;
+};
+
+#define to_const_obj(x) container_of(x, struct const_obj, kobj)
+
+struct const_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct const_obj *const, struct const_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct const_obj *const, struct const_attribute *attr,
+			 const char *buf, size_t count);
+};
+
+#define to_const_attr(x) container_of(x, struct const_attribute, attr)
+
+
+/* Private linear filter structure. */
+
+struct ts_filter_linear {
+	/* Private configuration for this filter. */
+	struct ts_filter_linear_configuration *config;
+
+	/* Generic filter API. */
+	struct ts_filter tsf;
+
+	/* Linear constants for the transformation. */
+	int constants[TS_FILTER_LINEAR_NCONSTANTS];
+
+	/* Sysfs. */
+
+	/* Our const_object. */
+	struct const_obj c_obj;
+	/* Our type. We will stick operations to it. */
+	struct kobj_type const_ktype;
+	/* Attrs. of the virtual files. */
+	struct const_attribute kattrs[TS_FILTER_LINEAR_NCONSTANTS];
+	/* Default Attrs. Always NULL for us. */
+	struct attribute *attrs[TS_FILTER_LINEAR_NCONSTANTS + 1];
+	/* Storage for the name of the virtual files. */
+	char attr_names[TS_FILTER_LINEAR_NCONSTANTS][2];
+};
+
+#define ts_filter_to_filter_linear(f) \
+	container_of(f, struct ts_filter_linear, tsf)
+
+/* Sysfs functions. */
+
+static ssize_t const_attr_show(struct kobject *kobj,
+			       struct attribute *attr,
+			       char *buf)
+{
+	struct const_attribute *a = to_const_attr(attr);
+
+	return a->show(to_const_obj(kobj), a, buf);
+}
+
+static ssize_t const_attr_store(struct kobject *kobj,
+				struct attribute *attr,
+				const char *buf, size_t len)
+{
+	struct const_attribute *a = to_const_attr(attr);
+
+	return a->store(to_const_obj(kobj), a, buf, len);
+}
+
+static struct sysfs_ops const_sysfs_ops = {
+	.show =		const_attr_show,
+	.store =	const_attr_store,
+};
+
+static void const_release(struct kobject *kobj)
+{
+	kfree(to_const_obj(kobj)->tsfl);
+}
+
+static ssize_t const_show(struct const_obj *obj, struct const_attribute *attr,
+			  char *buf)
+{
+	int who;
+
+	sscanf(attr->attr.name, "%d", &who);
+	return sprintf(buf, "%d\n", obj->tsfl->constants[who]);
+}
+
+static ssize_t const_store(struct const_obj *obj, struct const_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int who;
+
+	sscanf(attr->attr.name, "%d", &who);
+	sscanf(buf, "%d", &obj->tsfl->constants[who]);
+	return count;
+}
+
+/* Filter functions. */
+
+static struct ts_filter *ts_filter_linear_create(
+	struct platform_device *pdev,
+	const struct ts_filter_configuration *conf,
+	int count_coords)
+{
+	struct ts_filter_linear *tsfl;
+	int i;
+	int ret;
+
+	tsfl = kzalloc(sizeof(struct ts_filter_linear), GFP_KERNEL);
+	if (!tsfl)
+		return NULL;
+
+	tsfl->config = container_of(conf,
+				    struct ts_filter_linear_configuration,
+				    config);
+
+	tsfl->tsf.count_coords = count_coords;
+
+	for (i = 0; i < TS_FILTER_LINEAR_NCONSTANTS; ++i) {
+		tsfl->constants[i] = tsfl->config->constants[i];
+
+		/* sysfs */
+		sprintf(tsfl->attr_names[i], "%d", i);
+		tsfl->kattrs[i].attr.name = tsfl->attr_names[i];
+		tsfl->kattrs[i].attr.mode = 0666;
+		tsfl->kattrs[i].show = const_show;
+		tsfl->kattrs[i].store = const_store;
+		tsfl->attrs[i] = &tsfl->kattrs[i].attr;
+	}
+	tsfl->attrs[i] = NULL;
+
+	tsfl->const_ktype.sysfs_ops = &const_sysfs_ops;
+	tsfl->const_ktype.release = const_release;
+	tsfl->const_ktype.default_attrs = tsfl->attrs;
+	tsfl->c_obj.tsfl = tsfl; /* kernel frees tsfl in const_release */
+
+	ret = kobject_init_and_add(&tsfl->c_obj.kobj, &tsfl->const_ktype,
+				   &pdev->dev.kobj, "calibration");
+	if (ret) {
+		kobject_put(&tsfl->c_obj.kobj);
+		return NULL;
+	}
+
+	dev_info(&pdev->dev, "Created Linear filter coords:%d\n", count_coords);
+
+	return &tsfl->tsf;
+}
+
+static void ts_filter_linear_destroy(struct ts_filter *tsf)
+{
+	struct ts_filter_linear *tsfl = ts_filter_to_filter_linear(tsf);
+
+	/* Kernel frees tsfl in const_release. */
+	kobject_put(&tsfl->c_obj.kobj);
+}
+
+static void ts_filter_linear_scale(struct ts_filter *tsf, int *coords)
+{
+	struct ts_filter_linear *tsfl = ts_filter_to_filter_linear(tsf);
+
+	int *k = tsfl->constants;
+	int c0 = coords[tsfl->config->coord0];
+	int c1 = coords[tsfl->config->coord1];
+
+	coords[tsfl->config->coord0] = (k[2] + k[0] * c0 + k[1] * c1) / k[6];
+	coords[tsfl->config->coord1] = (k[5] + k[3] * c0 + k[4] * c1) / k[6];
+}
+
+const struct ts_filter_api ts_filter_linear_api = {
+	.create =	ts_filter_linear_create,
+	.destroy =	ts_filter_linear_destroy,
+	.scale =	ts_filter_linear_scale,
+};
+EXPORT_SYMBOL_GPL(ts_filter_linear_api);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_linear.h linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_linear.h
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_linear.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_linear.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,31 @@
+#ifndef __TS_FILTER_LINEAR_H__
+#define __TS_FILTER_LINEAR_H__
+
+#include "ts_filter.h"
+#include <linux/kobject.h>
+
+/*
+ * Touchscreen linear filter.
+ *
+ * Copyright (C) 2008,2009 by Openmoko, Inc.
+ * Author: Nelson Castillo <arhuaco@freaks-unidos.net>
+ *
+ */
+
+#define TS_FILTER_LINEAR_NCONSTANTS 7
+
+struct ts_filter_linear_configuration {
+	/* Calibration constants. */
+	int constants[TS_FILTER_LINEAR_NCONSTANTS];
+	/* First coordinate. */
+	int coord0;
+	/* Second coordinate. */
+	int coord1;
+
+	/* Generic filter configuration. */
+	struct ts_filter_configuration config;
+};
+
+extern const struct ts_filter_api ts_filter_linear_api;
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_mean.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_mean.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_mean.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_mean.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,174 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (c) 2008,2009
+ *       Andy Green <andy@openmoko.com>
+ *       Nelson Castillo <arhuaco@freaks-unidos.net>
+ *
+ * Simple mean filter.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+
+#include "ts_filter_mean.h"
+
+struct ts_filter_mean {
+	/* Copy of the private filter configuration. */
+	struct ts_filter_mean_configuration *config;
+	/* Filter API. */
+	struct ts_filter tsf;
+
+	/* Index on a circular buffer. */
+	int curr;
+	/* Useful to tell if the circular buffer is full(read:ready). */
+	int count;
+	/* Sumation used to compute the mean. */
+	int sum[MAX_TS_FILTER_COORDS];
+	/* Keep point values and decrement them from the sum on time. */
+	int *fifo[MAX_TS_FILTER_COORDS];
+	/* Store the output of this filter. */
+	int ready;
+};
+
+#define ts_filter_to_filter_mean(f) container_of(f, struct ts_filter_mean, tsf)
+
+
+static void ts_filter_mean_clear(struct ts_filter *tsf);
+
+static struct ts_filter *ts_filter_mean_create(
+	struct platform_device *pdev,
+	const struct ts_filter_configuration *conf,
+	int count_coords)
+{
+	struct ts_filter_mean *priv;
+	int *v;
+	int n;
+
+	priv = kzalloc(sizeof(struct ts_filter_mean), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+
+	priv->tsf.count_coords = count_coords;
+	priv->config = container_of(conf,
+				    struct ts_filter_mean_configuration,
+				    config);
+
+	BUG_ON(priv->config->length <= 0);
+
+	v = kmalloc(priv->config->length * sizeof(int) * count_coords,
+		    GFP_KERNEL);
+	if (!v)
+		return NULL;
+
+	for (n = 0; n < count_coords; n++) {
+		priv->fifo[n] = v;
+		v += priv->config->length;
+	}
+
+	ts_filter_mean_clear(&priv->tsf);
+
+	dev_info(&pdev->dev, "Created Mean filter len:%d coords:%d\n",
+		 priv->config->length, count_coords);
+
+	return &priv->tsf;
+}
+
+static void ts_filter_mean_destroy(struct ts_filter *tsf)
+{
+	struct ts_filter_mean *priv = ts_filter_to_filter_mean(tsf);
+
+	kfree(priv->fifo[0]); /* first guy has pointer from kmalloc */
+	kfree(tsf);
+}
+
+static void ts_filter_mean_clear(struct ts_filter *tsf)
+{
+	struct ts_filter_mean *priv = ts_filter_to_filter_mean(tsf);
+
+	priv->count = 0;
+	priv->curr = 0;
+	priv->ready = 0;
+	memset(priv->sum, 0, tsf->count_coords * sizeof(int));
+}
+
+static int ts_filter_mean_process(struct ts_filter *tsf, int *coords)
+{
+	struct ts_filter_mean *priv = ts_filter_to_filter_mean(tsf);
+	int n;
+
+	BUG_ON(priv->ready);
+
+	for (n = 0; n < tsf->count_coords; n++) {
+		priv->sum[n] += coords[n];
+		priv->fifo[n][priv->curr] = coords[n];
+	}
+
+	if (priv->count + 1 == priv->config->length)
+		priv->ready = 1;
+	else
+		priv->count++;
+
+	priv->curr = (priv->curr + 1) % priv->config->length;
+
+	return 0; /* No error. */
+}
+
+static int ts_filter_mean_haspoint(struct ts_filter *tsf)
+{
+	struct ts_filter_mean *priv = ts_filter_to_filter_mean(tsf);
+
+	return priv->ready;
+}
+
+static void ts_filter_mean_getpoint(struct ts_filter *tsf, int *point)
+{
+	struct ts_filter_mean *priv = ts_filter_to_filter_mean(tsf);
+	int n;
+
+	BUG_ON(!priv->ready);
+
+	for (n = 0; n < tsf->count_coords; n++) {
+		point[n] = priv->sum[n];
+		priv->sum[n] -= priv->fifo[n][priv->curr];
+	}
+
+	priv->ready = 0;
+}
+
+static void ts_filter_mean_scale(struct ts_filter *tsf, int *coords)
+{
+	int n;
+	struct ts_filter_mean *priv = ts_filter_to_filter_mean(tsf);
+
+	for (n = 0; n < tsf->count_coords; n++) {
+		coords[n] += priv->config->length >> 1; /* Rounding. */
+		coords[n] /= priv->config->length;
+	}
+}
+
+const struct ts_filter_api ts_filter_mean_api = {
+	.create =	ts_filter_mean_create,
+	.destroy =	ts_filter_mean_destroy,
+	.clear =	ts_filter_mean_clear,
+	.process =	ts_filter_mean_process,
+	.scale =	ts_filter_mean_scale,
+	.haspoint =	ts_filter_mean_haspoint,
+	.getpoint =	ts_filter_mean_getpoint,
+};
+EXPORT_SYMBOL_GPL(ts_filter_mean_api);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_mean.h linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_mean.h
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_mean.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_mean.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef __TS_FILTER_MEAN_H__
+#define __TS_FILTER_MEAN_H__
+
+#include "ts_filter.h"
+
+/*
+ * Touchscreen filter.
+ *
+ * mean
+ *
+ * (c) 2008,2009
+ *     Andy Green <andy@openmoko.com>
+ *     Nelson Castillo <arhuaco@freaks-unidos.net>
+ */
+
+/* Configuration for this filter. */
+struct ts_filter_mean_configuration {
+	/* Number of points for the mean. */
+	int length;
+
+	/* Generic filter configuration. */
+	struct ts_filter_configuration config;
+};
+
+/* API functions for the mean filter */
+extern const struct ts_filter_api ts_filter_mean_api;
+
+#endif /* __TS_FILTER_MEAN_H__ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_median.c linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_median.c
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_median.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_median.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,261 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (c) 2008 Andy Green <andy@openmoko.com>
+ *
+ *
+ * Median averaging stuff.  We sort incoming raw samples into an array of
+ * MEDIAN_SIZE length, discarding the oldest sample each time once we are full.
+ * We then return the sum of the middle three samples for X and Y.  It means
+ * the final result must be divided by (3 * scaling factor) to correct for
+ * avoiding the repeated /3.
+ *
+ * This strongly rejects brief excursions away from a central point that is
+ * sticky in time compared to the excursion duration.
+ *
+ * Thanks to Dale Schumacher (who wrote some example code) and Carl-Daniel
+ * Halifinger who pointed out this would be a good method.
+ */
+
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "ts_filter_median.h"
+
+struct ts_filter_median {
+	/* Private configuration. */
+	struct ts_filter_median_configuration *config;
+	/* Generic Filter API. */
+	struct ts_filter tsf;
+
+	/* Count raw samples we get. */
+	int samples_count;
+	/*
+	 * Remember the last coordinates we got in order to know if
+	 * we are moving slow or fast.
+	 */
+	int last_issued[MAX_TS_FILTER_COORDS];
+	/* How many samples in the sort buffer are valid. */
+	int valid;
+	/* Samples taken for median in sorted form. */
+	int *sort[MAX_TS_FILTER_COORDS];
+	/* Samples taken for median. */
+	int *fifo[MAX_TS_FILTER_COORDS];
+	/* Where we are in the fifo sample memory. */
+	int pos;
+	/* Do we have a sample to deliver? */
+	int ready;
+};
+
+#define ts_filter_to_filter_median(f) \
+	container_of(f, struct ts_filter_median, tsf)
+
+
+static void ts_filter_median_insert(int *p, int sample, int count)
+{
+	int n;
+
+	/* Search through what we got so far to find where to put sample. */
+	for (n = 0; n < count; n++)
+		if (sample < p[n]) {	/* We met somebody bigger than us? */
+			/* Starting from the end, push bigger guys down one. */
+			for (count--; count >= n; count--)
+				p[count + 1] = p[count];
+			p[n] = sample; /* Put us in place of first bigger. */
+			return;
+		}
+
+	p[count] = sample; /* Nobody was bigger than us, add us on the end. */
+}
+
+static void ts_filter_median_del(int *p, int value, int count)
+{
+	int index;
+
+	for (index = 0; index < count; index++)
+		if (p[index] == value) {
+			for (; index < count; index++)
+				p[index] = p[index + 1];
+			return;
+		}
+}
+
+
+static void ts_filter_median_clear(struct ts_filter *tsf)
+{
+	struct ts_filter_median *tsfm = ts_filter_to_filter_median(tsf);
+
+	tsfm->pos = 0;
+	tsfm->valid = 0;
+	tsfm->ready = 0;
+	memset(&tsfm->last_issued[0], 1, tsf->count_coords * sizeof(int));
+}
+
+static struct ts_filter *ts_filter_median_create(
+	struct platform_device *pdev,
+	const struct ts_filter_configuration *conf,
+	int count_coords)
+{
+	int *p;
+	int n;
+	struct ts_filter_median *tsfm = kzalloc(sizeof(struct ts_filter_median),
+								    GFP_KERNEL);
+
+	if (!tsfm)
+		return NULL;
+
+	tsfm->config = container_of(conf,
+				    struct ts_filter_median_configuration,
+				    config);
+
+	tsfm->tsf.count_coords = count_coords;
+
+	tsfm->config->midpoint = (tsfm->config->extent >> 1) + 1;
+
+	p = kmalloc(2 * count_coords * sizeof(int) * (tsfm->config->extent + 1),
+		    GFP_KERNEL);
+	if (!p) {
+		kfree(tsfm);
+		return NULL;
+	}
+
+	for (n = 0; n < count_coords; n++) {
+		tsfm->sort[n] = p;
+		p += tsfm->config->extent + 1;
+		tsfm->fifo[n] = p;
+		p += tsfm->config->extent + 1;
+	}
+
+	ts_filter_median_clear(&tsfm->tsf);
+
+	dev_info(&pdev->dev,
+		 "Created Median filter len:%d coords:%d dec_threshold:%d\n",
+		 tsfm->config->extent, count_coords,
+		 tsfm->config->decimation_threshold);
+
+	return &tsfm->tsf;
+}
+
+static void ts_filter_median_destroy(struct ts_filter *tsf)
+{
+	struct ts_filter_median *tsfm = ts_filter_to_filter_median(tsf);
+
+	kfree(tsfm->sort[0]); /* First guy has pointer from kmalloc. */
+	kfree(tsf);
+}
+
+static void ts_filter_median_scale(struct ts_filter *tsf, int *coords)
+{
+	int n;
+
+	for (n = 0; n < tsf->count_coords; n++)
+		coords[n] = (coords[n] + 2) / 3;
+}
+
+/*
+ * Give us the raw sample data coords, and if we return 1 then you can
+ * get a filtered coordinate from coords. If we return 0 you didn't
+ * fill all the filters with samples yet.
+ */
+
+static int ts_filter_median_process(struct ts_filter *tsf, int *coords)
+{
+	struct ts_filter_median *tsfm = ts_filter_to_filter_median(tsf);
+	int n;
+	int movement = 1;
+
+	for (n = 0; n < tsf->count_coords; n++) {
+		/* Grab copy in insertion order to remove when oldest. */
+		tsfm->fifo[n][tsfm->pos] = coords[n];
+		/* Insert these samples in sorted order in the median arrays. */
+		ts_filter_median_insert(tsfm->sort[n], coords[n], tsfm->valid);
+	}
+	/* Move us on in the fifo. */
+	if (++tsfm->pos == (tsfm->config->extent + 1))
+		tsfm->pos = 0;
+
+	/* Have we finished a median sampling? */
+	if (++tsfm->valid < tsfm->config->extent)
+		goto process_exit; /* No valid sample to use. */
+
+	BUG_ON(tsfm->valid != tsfm->config->extent);
+
+	tsfm->valid--;
+
+	/*
+	 * Sum the middle 3 in the median sorted arrays. We don't divide back
+	 * down which increases the sum resolution by a factor of 3 until the
+	 * scale API function is called.
+	 */
+	for (n = 0; n < tsf->count_coords; n++)
+		/* Perform the deletion of the oldest sample. */
+		ts_filter_median_del(tsfm->sort[n], tsfm->fifo[n][tsfm->pos],
+				     tsfm->valid);
+
+	tsfm->samples_count--;
+	if (tsfm->samples_count >= 0)
+		goto process_exit;
+
+	for (n = 0; n < tsf->count_coords; n++) {
+		/* Give the coordinate result from summing median 3. */
+		coords[n] = tsfm->sort[n][tsfm->config->midpoint - 1] +
+			    tsfm->sort[n][tsfm->config->midpoint] +
+			    tsfm->sort[n][tsfm->config->midpoint + 1];
+
+		movement += abs(tsfm->last_issued[n] - coords[n]);
+	}
+
+	if (movement > tsfm->config->decimation_threshold) /* Moving fast. */
+		tsfm->samples_count = tsfm->config->decimation_above;
+	else
+		tsfm->samples_count = tsfm->config->decimation_below;
+
+	memcpy(&tsfm->last_issued[0], coords, tsf->count_coords * sizeof(int));
+
+	tsfm->ready = 1;
+
+process_exit:
+	return 0;
+}
+
+static int ts_filter_median_haspoint(struct ts_filter *tsf)
+{
+	struct ts_filter_median *priv = ts_filter_to_filter_median(tsf);
+
+	return priv->ready;
+}
+
+static void ts_filter_median_getpoint(struct ts_filter *tsf, int *point)
+{
+	struct ts_filter_median *priv = ts_filter_to_filter_median(tsf);
+
+	BUG_ON(!priv->ready);
+
+	memcpy(point, &priv->last_issued[0], tsf->count_coords * sizeof(int));
+
+	priv->ready = 0;
+}
+
+const struct ts_filter_api ts_filter_median_api = {
+	.create =	ts_filter_median_create,
+	.destroy =	ts_filter_median_destroy,
+	.clear =	ts_filter_median_clear,
+	.process =	ts_filter_median_process,
+	.scale =	ts_filter_median_scale,
+	.haspoint =	ts_filter_median_haspoint,
+	.getpoint =	ts_filter_median_getpoint,
+};
+EXPORT_SYMBOL_GPL(ts_filter_median_api);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_median.h linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_median.h
--- linux-2.6.29-rc3.owrt/drivers/input/touchscreen/ts_filter_median.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/input/touchscreen/ts_filter_median.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef __TS_FILTER_MEDIAN_H__
+#define __TS_FILTER_MEDIAN_H__
+
+#include "ts_filter.h"
+
+/*
+ * Touchscreen filter.
+ *
+ * median
+ *
+ * (c) 2008 Andy Green <andy@openmoko.com>
+ */
+
+struct ts_filter_median_configuration {
+	/* Size of the filter. */
+	int extent;
+	/* Precomputed midpoint. */
+	int midpoint;
+	/* A reference value for us to check if we are going fast or slow. */
+	int decimation_threshold;
+	/* How many points to replace if we're going fast. */
+	int decimation_above;
+	/* How many points to replace if we're going slow. */
+	int decimation_below;
+
+	/* Generic configuration. */
+	struct ts_filter_configuration config;
+};
+
+extern const struct ts_filter_api ts_filter_median_api;
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/Kconfig linux-2.6.29-rc3.owrt.om/drivers/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -109,4 +109,5 @@
 source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
+
 endmenu
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/leds/Kconfig linux-2.6.29-rc3.owrt.om/drivers/leds/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/leds/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/leds/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -33,7 +33,7 @@
 
 config LEDS_S3C24XX
 	tristate "LED Support for Samsung S3C24XX GPIO LEDs"
-	depends on LEDS_CLASS && ARCH_S3C2410
+	depends on LEDS_CLASS && ARCH_S3C2410 && S3C2410_PWM
 	help
 	  This option enables support for LEDs connected to GPIO lines
 	  on Samsung S3C24XX series CPUs, such as the S3C2410 and S3C2440.
@@ -171,6 +171,25 @@
 	  This option enables support for on-chip LED drivers found
 	  on Dialog Semiconductor DA9030/DA9034 PMICs.
 
+config LEDS_NEO1973_VIBRATOR
+	tristate "Vibrator Support for the FIC Neo1973 GSM phone"
+	depends on LEDS_CLASS && MACH_NEO1973
+	help
+	  This option enables support for the vibrator on the FIC Neo1973.
+
+config LEDS_NEO1973_GTA02
+	tristate "LED Support for the FIC Neo1973 (GTA02)"
+	depends on LEDS_CLASS && MACH_NEO1973_GTA02
+	help
+	  This option enables support for the LEDs on the FIC Neo1973.
+
+config LEDS_LP5521
+	tristate "LED Support for LP5521 LED I2C chip"
+	depends on LEDS_CLASS && I2C
+	help
+	  If you say yes here you get support for the National Semiconductor
+	  LP5521 LED driver.
+
 comment "LED Triggers"
 
 config LEDS_TRIGGERS
@@ -234,4 +253,11 @@
 	  This allows LEDs to be controlled by network device activity.
 	  If unsure, say Y.
 
+config LEDS_TRIGGER_NETDEV
+	tristate "LED Network Device Trigger"
+	depends on LEDS_TRIGGERS
+	help
+	  This allows LEDs to be controlled by Network Device activity.
+	  If unsure, say Y.
+	  
 endif # NEW_LEDS
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/leds/led-class.c linux-2.6.29-rc3.owrt.om/drivers/leds/led-class.c
--- linux-2.6.29-rc3.owrt/drivers/leds/led-class.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/leds/led-class.c	2009-05-10 22:27:59.000000000 +0200
@@ -56,8 +56,10 @@
 	if (count == size) {
 		ret = count;
 
+#if 0 /* This is really bad. Don't do it!!!! */
 		if (state == LED_OFF)
 			led_trigger_remove(led_cdev);
+#endif
 		led_set_brightness(led_cdev, state);
 	}
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/leds/leds-lp5521.c linux-2.6.29-rc3.owrt.om/drivers/leds/leds-lp5521.c
--- linux-2.6.29-rc3.owrt/drivers/leds/leds-lp5521.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/leds/leds-lp5521.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,386 @@
+/* NS LP5521 Programmable LED driver.
+ *
+ * (C) 2009 by Openmoko, Inc.
+ * Author: Matt Hsu <matt_hsu@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <linux/lp5521.h>
+
+#define LP5521_DRIVER_NAME              "lp5521"
+
+static int __lp5521_reg_write(struct lp5521 *lp, u8 reg, u8 value)
+{
+	return i2c_smbus_write_byte_data(lp->client, reg, value);
+}
+
+static int reg_write(struct lp5521 *lp, u_int8_t reg, u_int8_t val)
+{
+	int ret;
+
+	mutex_lock(&lp->lock);
+	ret = __lp5521_reg_write(lp, reg, val);
+	mutex_unlock(&lp->lock);
+
+	return ret;
+}
+
+static int __lp5521_reg_read(struct lp5521 *lp, u8 reg)
+{
+	int32_t ret;
+
+	ret = i2c_smbus_read_byte_data(lp->client, reg);
+
+	return ret;
+}
+
+static u_int8_t reg_read(struct lp5521 *lp, u_int8_t reg)
+{
+	int32_t ret;
+
+	mutex_lock(&lp->lock);
+	ret = __lp5521_reg_read(lp, reg);
+	mutex_unlock(&lp->lock);
+
+	return ret & 0xff;
+}
+
+static int reg_set_bit_mask(struct lp5521 *lp,
+			    u_int8_t reg, u_int8_t mask, u_int8_t val)
+{
+	int ret;
+	u_int8_t tmp;
+
+	val &= mask;
+
+	mutex_lock(&lp->lock);
+
+	tmp = __lp5521_reg_read(lp, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	ret = __lp5521_reg_write(lp, reg, tmp);
+
+	mutex_unlock(&lp->lock);
+
+	return ret;
+}
+
+static const char *lp5521_ch_name[] = {
+	"blue", "green", "red",
+};
+
+static inline int channel_id_by_name(const char *name)
+{
+	int channel_id = -1;
+
+	if (!strncmp(name, lp5521_ch_name[LP5521_BLUE],
+				strlen(lp5521_ch_name[LP5521_BLUE])))
+		channel_id = LP5521_BLUE;
+	else if (!strncmp(name, lp5521_ch_name[LP5521_GREEN],
+				strlen(lp5521_ch_name[LP5521_GREEN])))
+		channel_id = LP5521_GREEN;
+	else if (!strncmp(name, lp5521_ch_name[LP5521_RED],
+				strlen(lp5521_ch_name[LP5521_RED])))
+		channel_id = LP5521_RED;
+
+	return channel_id;
+}
+
+static const char *lp5521_ch_mode[] = {
+	"disable", "load", "run",
+	"direct",
+};
+
+/*
+ * Individual mode control
+ */
+static ssize_t show_mode(struct device *dev, struct device_attribute
+					*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lp5521 *lp = i2c_get_clientdata(client);
+	int id;
+	uint8_t val;
+
+	id = channel_id_by_name(attr->attr.name);
+	val = reg_read(lp, LP5521_REG_OP_MODE);
+
+	val = val >> (id * 2);
+	val &= 0x3;
+
+	return sprintf(buf, "%s\n", lp5521_ch_mode[val]);
+}
+
+static ssize_t set_mode(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lp5521 *lp = i2c_get_clientdata(client);
+	int id;
+	uint8_t mask, i;
+
+	id = channel_id_by_name(attr->attr.name);
+
+	mask = (0x3 << (id * 2));
+
+	for (i = LP5521_MODE_DISABLE; i <= LP5521_MODE_DIRECT; i++) {
+		if (!strncmp(buf, lp5521_ch_mode[i], strlen(lp5521_ch_mode[i]))) {
+			reg_set_bit_mask(lp,
+				LP5521_REG_OP_MODE, mask, (i << (id * 2)));
+		}
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(red_mode, S_IRUGO | S_IWUSR, show_mode, set_mode);
+static DEVICE_ATTR(green_mode, S_IRUGO | S_IWUSR, show_mode, set_mode);
+static DEVICE_ATTR(blue_mode, S_IRUGO | S_IWUSR, show_mode, set_mode);
+
+/*
+ * Individual pwm control
+ */
+static ssize_t show_pwm(struct device *dev, struct device_attribute
+					*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lp5521 *lp = i2c_get_clientdata(client);
+	int id;
+	uint8_t val;
+
+	id = channel_id_by_name(attr->attr.name);
+	val = reg_read(lp, LP5521_REG_B_PWM-id);
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int id;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lp5521 *lp = i2c_get_clientdata(client);
+	unsigned int pwm = simple_strtoul(buf, NULL, 10);
+
+	id = channel_id_by_name(attr->attr.name);
+	reg_write(lp, LP5521_REG_B_PWM-id, pwm);
+
+	return count;
+}
+
+static DEVICE_ATTR(red_pwm, S_IRUGO | S_IWUSR, show_pwm, set_pwm);
+static DEVICE_ATTR(green_pwm, S_IRUGO | S_IWUSR, show_pwm, set_pwm);
+static DEVICE_ATTR(blue_pwm, S_IRUGO | S_IWUSR, show_pwm, set_pwm);
+
+/*
+ * Individual current control
+ */
+static ssize_t show_cur(struct device *dev, struct device_attribute
+					*attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lp5521 *lp = i2c_get_clientdata(client);
+	int id;
+	uint8_t val;
+
+	id = channel_id_by_name(attr->attr.name);
+	val = reg_read(lp, LP5521_REG_B_CUR-id);
+
+	return sprintf(buf, "%d (100uA)\n", val);
+}
+
+static ssize_t set_cur(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int id;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lp5521 *lp = i2c_get_clientdata(client);
+	unsigned int cur = simple_strtoul(buf, NULL, 10);
+
+	id = channel_id_by_name(attr->attr.name);
+	reg_write(lp, LP5521_REG_B_CUR-id, cur);
+
+	return count;
+}
+
+static DEVICE_ATTR(red_cur, S_IRUGO | S_IWUSR, show_cur, set_cur);
+static DEVICE_ATTR(green_cur, S_IRUGO | S_IWUSR, show_cur, set_cur);
+static DEVICE_ATTR(blue_cur, S_IRUGO | S_IWUSR, show_cur, set_cur);
+
+static struct attribute *lp_sysfs_entries[16];
+
+static struct attribute_group lp_attr_group = {
+	.name   = NULL,
+	.attrs  = lp_sysfs_entries,
+};
+
+static void populate_sysfs_group(struct lp5521 *lp)
+{
+	int i = 0;
+
+	if (lp->pdata->channels[LP5521_RED] & LP5521_CONNECTED) {
+		lp_sysfs_entries[i++] = &dev_attr_red_mode.attr;
+		lp_sysfs_entries[i++] = &dev_attr_red_pwm.attr;
+		lp_sysfs_entries[i++] = &dev_attr_red_cur.attr;
+	}
+
+	if (lp->pdata->channels[LP5521_GREEN] & LP5521_CONNECTED) {
+		lp_sysfs_entries[i++] = &dev_attr_green_mode.attr;
+		lp_sysfs_entries[i++] = &dev_attr_green_pwm.attr;
+		lp_sysfs_entries[i++] = &dev_attr_green_cur.attr;
+	}
+
+	if (lp->pdata->channels[LP5521_BLUE] & LP5521_CONNECTED) {
+		lp_sysfs_entries[i++] = &dev_attr_blue_mode.attr;
+		lp_sysfs_entries[i++] = &dev_attr_blue_pwm.attr;
+		lp_sysfs_entries[i++] = &dev_attr_blue_cur.attr;
+	}
+}
+
+static struct i2c_driver lp5521_driver;
+
+#ifdef CONFIG_PM
+static int lp5521_suspend(struct device *dev, pm_message_t state)
+{
+	/* FIXME: Not implemented
+	 * Here we could upload firmware to perform
+	 * any scenarios we want and save registers.
+	 */
+	return 0;
+}
+
+static int lp5521_resume(struct device *dev)
+{
+	/* FIXME: Not implemented */
+	return 0;
+}
+#else
+#define lp5521_suspend NULL
+#define lp5521_resume NULL
+#endif
+
+static irqreturn_t lp5521_irq(int irq, void *_lp)
+{
+	struct lp5521 *lp = _lp;
+	dev_info(lp->dev, "lp5521 interrupt\n");
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit
+lp5521_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct lp5521 *lp;
+	int ret = 0;
+	struct lp5521_platform_data *pdata = client->dev.platform_data;
+
+	lp = kzalloc(sizeof(*lp), GFP_KERNEL);
+	if (!lp)
+		return -ENOMEM;
+
+	lp->client = client;
+	lp->irq = client->irq;
+	lp->dev = &client->dev;
+	i2c_set_clientdata(client, lp);
+
+	lp->pdata = pdata;
+	mutex_init(&lp->lock);
+
+	/* enter start-up mode */
+	if (pdata->ext_enable)
+		(pdata->ext_enable)(1);
+
+	reg_write(lp, LP5521_REG_ENABLE, 0x40);
+
+	/* charge pump mode and clk src selection */
+	reg_write(lp, LP5521_REG_CONFIG, 0x11);
+
+	/* allocate IRQ resource */
+	if (lp->irq) {
+		ret = request_irq(client->irq, lp5521_irq,
+				IRQF_TRIGGER_LOW, LP5521_DRIVER_NAME, lp);
+		if (ret) {
+			dev_err(lp->dev, "request IRQ failed\n");
+			goto fail;
+		}
+	} else {
+		dev_err(lp->dev, "No IRQ allocated \n");
+	}
+
+	populate_sysfs_group(lp);
+
+	ret = sysfs_create_group(&client->dev.kobj, &lp_attr_group);
+
+	if (ret) {
+		dev_err(lp->dev, "error creating sysfs group\n");
+		goto fail;
+	}
+
+	return ret;
+
+fail:
+	kfree(lp);
+	return ret;
+}
+
+static int __devexit lp5521_remove(struct i2c_client *client)
+{
+	struct lp5521 *lp = i2c_get_clientdata(client);
+
+	kfree(lp);
+
+	return 0;
+}
+
+static struct i2c_device_id lp5521_id[] = {
+	{LP5521_DRIVER_NAME, },
+};
+
+static struct i2c_driver lp5521_driver = {
+	.driver = {
+		.name	= LP5521_DRIVER_NAME,
+		.suspend = lp5521_suspend,
+		.resume	= lp5521_resume,
+	},
+	.id_table 	= lp5521_id,
+	.probe		= lp5521_probe,
+	.remove		= __exit_p(lp5521_remove),
+};
+
+static int __init lp5521_init(void)
+{
+	return i2c_add_driver(&lp5521_driver);
+}
+
+static void __exit lp5521_exit(void)
+{
+	i2c_del_driver(&lp5521_driver);
+}
+
+MODULE_AUTHOR("Matt Hsu <matt_hsu@openmoko.org>");
+MODULE_DESCRIPTION("NS lp5521 LED driver");
+MODULE_LICENSE("GPLv2");
+
+module_init(lp5521_init);
+module_exit(lp5521_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/leds/leds-neo1973-gta02.c linux-2.6.29-rc3.owrt.om/drivers/leds/leds-neo1973-gta02.c
--- linux-2.6.29-rc3.owrt/drivers/leds/leds-neo1973-gta02.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/leds/leds-neo1973-gta02.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,179 @@
+/*
+ * LED driver for the Openmoko GTA02 GSM phone
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <mach/gta02.h>
+#include <plat/regs-timer.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+
+#define MAX_LEDS 3
+#define COUNTER 256
+
+struct gta02_led_priv
+{
+	spinlock_t lock;
+	struct led_classdev cdev;
+	unsigned int gpio;
+};
+
+struct gta02_led_bundle
+{
+	int num_leds;
+	struct gta02_led_priv led[MAX_LEDS];
+};
+
+static inline struct gta02_led_priv *to_priv(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct gta02_led_priv, cdev);
+}
+
+static inline struct gta02_led_bundle *to_bundle(struct led_classdev *led_cdev)
+{
+	return dev_get_drvdata(led_cdev->dev->parent);
+}
+
+static void gta02led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value)
+{
+	unsigned long flags;
+	struct gta02_led_priv *lp = to_priv(led_cdev);
+
+	spin_lock_irqsave(&lp->lock, flags);
+	neo1973_gpb_setpin(lp->gpio, value ? 1 : 0);
+	spin_unlock_irqrestore(&lp->lock, flags);
+}
+
+#ifdef CONFIG_PM
+static int gta02led_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct gta02_led_bundle *bundle = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < bundle->num_leds; i++)
+		led_classdev_suspend(&bundle->led[i].cdev);
+
+	return 0;
+}
+
+static int gta02led_resume(struct platform_device *pdev)
+{
+	struct gta02_led_bundle *bundle = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < bundle->num_leds; i++)
+		led_classdev_resume(&bundle->led[i].cdev);
+
+	return 0;
+}
+#endif
+
+static int __init gta02led_probe(struct platform_device *pdev)
+{
+	int i, rc;
+	struct gta02_led_bundle *bundle;
+
+	if (!machine_is_neo1973_gta02())
+		return -EIO;
+
+	bundle = kzalloc(sizeof(struct gta02_led_bundle), GFP_KERNEL);
+	if (!bundle)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, bundle);
+
+	for (i = 0; i < pdev->num_resources; i++) {
+		struct gta02_led_priv *lp;
+		struct resource *r;
+
+		if (i >= MAX_LEDS)
+			break;
+
+		r = platform_get_resource(pdev, 0, i);
+		if (!r || !r->start || !r->name)
+			continue;
+
+		lp = &bundle->led[i];
+
+		lp->gpio = r->start;
+		lp->cdev.name = r->name;
+		lp->cdev.brightness_set = gta02led_set;
+
+		switch (lp->gpio) {
+		case S3C2410_GPB0:
+		case S3C2410_GPB1:
+		case S3C2410_GPB2:
+			s3c2410_gpio_cfgpin(lp->gpio, S3C2410_GPIO_OUTPUT);
+			neo1973_gpb_add_shadow_gpio(lp->gpio);
+			break;
+		default:
+			break;
+		}
+
+		spin_lock_init(&lp->lock);
+		rc = led_classdev_register(&pdev->dev, &lp->cdev);
+	}
+
+	bundle->num_leds = i;
+
+	return 0;
+}
+
+static int gta02led_remove(struct platform_device *pdev)
+{
+	struct gta02_led_bundle *bundle = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < bundle->num_leds; i++) {
+		struct gta02_led_priv *lp = &bundle->led[i];
+		gta02led_set(&lp->cdev, 0);
+		led_classdev_unregister(&lp->cdev);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(bundle);
+
+	return 0;
+}
+
+static struct platform_driver gta02led_driver = {
+	.probe		= gta02led_probe,
+	.remove		= gta02led_remove,
+#ifdef CONFIG_PM
+	.suspend	= gta02led_suspend,
+	.resume		= gta02led_resume,
+#endif
+	.driver		= {
+		.name		= "gta02-led",
+	},
+};
+
+static int __init gta02led_init(void)
+{
+	return platform_driver_register(&gta02led_driver);
+}
+
+static void __exit gta02led_exit(void)
+{
+	platform_driver_unregister(&gta02led_driver);
+}
+
+module_init(gta02led_init);
+module_exit(gta02led_exit);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("Openmoko GTA02 LED driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/leds/leds-neo1973-vibrator.c linux-2.6.29-rc3.owrt.om/drivers/leds/leds-neo1973-vibrator.c
--- linux-2.6.29-rc3.owrt/drivers/leds/leds-neo1973-vibrator.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/leds/leds-neo1973-vibrator.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,241 @@
+/*
+ * LED driver for the vibrator of the Openmoko GTA01/GTA02 GSM Phones
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Javi Roman <javiroman@kernel-labs.org>:
+ *	Implement PWM support for GTA01Bv4 and later
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <plat/pwm.h>
+#include <mach/gta01.h>
+#include <plat/regs-timer.h>
+#include <linux/neo1973_vibrator.h>
+
+#include <asm/plat-s3c24xx/neo1973.h>
+
+#define COUNTER 64
+
+static struct neo1973_vib_priv {
+	struct led_classdev cdev;
+	unsigned int gpio;
+	spinlock_t lock;
+	unsigned int has_pwm;
+	struct s3c2410_pwm pwm;
+	
+	unsigned long vib_gpio_pin; /* which pin to meddle with */
+	u8 vib_pwm; /* 0 = OFF -- will ensure GPIO deasserted and stop FIQ */
+	u8 vib_pwm_latched;
+	u32 fiq_count;
+
+	struct neo1973_vib_platform_data *pdata;
+} neo1973_vib_priv;
+
+int neo1973_vibrator_fiq_handler(void)
+{
+	neo1973_vib_priv.fiq_count++;
+
+	if (!neo1973_vib_priv.vib_pwm_latched && !neo1973_vib_priv.vib_pwm)
+		/* idle */
+		return 0;
+
+	if ((u8)neo1973_vib_priv.fiq_count == neo1973_vib_priv.vib_pwm_latched)
+		neo1973_gpb_setpin(neo1973_vib_priv.vib_gpio_pin, 0);
+
+	if ((u8)neo1973_vib_priv.fiq_count)
+		return 1;
+
+	neo1973_vib_priv.vib_pwm_latched = neo1973_vib_priv.vib_pwm;
+	if (neo1973_vib_priv.vib_pwm_latched)
+		neo1973_gpb_setpin(neo1973_vib_priv.vib_gpio_pin, 1);
+
+	return 1;
+}
+
+static void neo1973_vib_vib_set(struct led_classdev *led_cdev,
+				enum led_brightness value)
+{
+	unsigned long flags;
+	struct neo1973_vib_priv *vp = container_of(led_cdev,
+						   struct neo1973_vib_priv,
+						   cdev);
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+	if (machine_is_neo1973_gta02()) { /* use FIQ to control GPIO */
+		neo1973_vib_priv.vib_pwm = value; /* set it for FIQ */
+		neo1973_vib_priv.pdata->kick_fiq(); /* start up FIQs if not already going */
+		return;
+	}
+#endif
+	/*
+	 * value == 255 -> 99% duty cycle (full power)
+	 * value == 128 -> 50% duty cycle (medium power)
+	 * value == 0 -> 0% duty cycle (zero power)
+	 */
+	spin_lock_irqsave(&vp->lock, flags);
+
+	if (vp->has_pwm)
+		s3c2410_pwm_duty_cycle(value / 4, &vp->pwm);
+	else
+		neo1973_gpb_setpin(vp->gpio, value ? 1 : 0);
+
+	spin_unlock_irqrestore(&vp->lock, flags);
+}
+
+static struct neo1973_vib_priv neo1973_vib_led = {
+	.cdev = {
+		.name = "neo1973:vibrator",
+		.brightness_set = neo1973_vib_vib_set,
+	},
+};
+
+static int neo1973_vib_init_hw(struct neo1973_vib_priv *vp)
+{
+	int rc;
+
+	rc = s3c2410_pwm_init(&vp->pwm);
+	if (rc)
+		return rc;
+
+	vp->pwm.timerid = PWM3;
+	/* use same prescaler as arch/arm/plat-s3c24xx/time.c */
+	vp->pwm.prescaler = (6 - 1) / 2;
+	vp->pwm.divider = S3C2410_TCFG1_MUX3_DIV2;
+	vp->pwm.counter = COUNTER;
+	vp->pwm.comparer = COUNTER;
+
+	rc = s3c2410_pwm_enable(&vp->pwm);
+	if (rc)
+		return rc;
+
+	s3c2410_pwm_start(&vp->pwm);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int neo1973_vib_suspend(struct platform_device *dev, pm_message_t state)
+{
+	led_classdev_suspend(&neo1973_vib_led.cdev);
+	if (neo1973_vib_priv.pdata)
+		neo1973_vib_priv.pdata->disable_fiq();
+	return 0;
+}
+
+static int neo1973_vib_resume(struct platform_device *dev)
+{
+	struct neo1973_vib_priv *vp = platform_get_drvdata(dev);
+
+	if (vp->has_pwm)
+		neo1973_vib_init_hw(vp);
+
+	led_classdev_resume(&neo1973_vib_led.cdev);
+	if (neo1973_vib_priv.pdata)
+		neo1973_vib_priv.pdata->enable_fiq();
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static int __init neo1973_vib_probe(struct platform_device *pdev)
+{
+	struct resource *r;
+	int rc;
+
+	if (!machine_is_neo1973_gta01() && !machine_is_neo1973_gta02())
+		return -EIO;
+
+	r = platform_get_resource(pdev, 0, 0);
+	if (!r || !r->start)
+		return -EIO;
+
+	neo1973_vib_led.gpio = r->start;
+
+	neo1973_vib_priv.pdata = pdev->dev.platform_data;
+	platform_set_drvdata(pdev, &neo1973_vib_led);
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+	if (machine_is_neo1973_gta02()) { /* use FIQ to control GPIO */
+		neo1973_gpb_setpin(neo1973_vib_led.gpio, 0); /* off */
+		s3c2410_gpio_cfgpin(neo1973_vib_led.gpio, S3C2410_GPIO_OUTPUT);
+		/* safe, kmalloc'd copy needed for FIQ ISR */
+		neo1973_vib_priv.vib_gpio_pin = neo1973_vib_led.gpio;
+		neo1973_vib_priv.vib_pwm = 0; /* off */
+		goto configured;
+	}
+#endif
+
+	/* TOUT3 */
+	if (neo1973_vib_led.gpio == S3C2410_GPB3) {
+		rc = neo1973_vib_init_hw(&neo1973_vib_led);
+		if (rc)
+			return rc;
+
+		s3c2410_pwm_duty_cycle(0, &neo1973_vib_led.pwm);
+		s3c2410_gpio_cfgpin(neo1973_vib_led.gpio, S3C2410_GPB3_TOUT3);
+		neo1973_vib_led.has_pwm = 1;
+	}
+#ifdef CONFIG_MACH_NEO1973_GTA02
+configured:
+#endif
+	spin_lock_init(&neo1973_vib_led.lock);
+
+	return led_classdev_register(&pdev->dev, &neo1973_vib_led.cdev);
+}
+
+static int neo1973_vib_remove(struct platform_device *pdev)
+{
+#ifdef CONFIG_MACH_NEO1973_GTA02
+	if (machine_is_neo1973_gta02()) /* use FIQ to control GPIO */
+		neo1973_vib_priv.vib_pwm = 0; /* off */
+	/* would only need kick if already off so no kick needed */
+#endif
+
+	if (neo1973_vib_led.has_pwm)
+		s3c2410_pwm_disable(&neo1973_vib_led.pwm);
+
+	led_classdev_unregister(&neo1973_vib_led.cdev);
+
+	return 0;
+}
+
+static struct platform_driver neo1973_vib_driver = {
+	.probe		= neo1973_vib_probe,
+	.remove		= neo1973_vib_remove,
+#ifdef CONFIG_PM
+	.suspend	= neo1973_vib_suspend,
+	.resume		= neo1973_vib_resume,
+#endif
+	.driver		= {
+		.name		= "neo1973-vibrator",
+	},
+};
+
+static int __init neo1973_vib_init(void)
+{
+	return platform_driver_register(&neo1973_vib_driver);
+}
+
+static void __exit neo1973_vib_exit(void)
+{
+	platform_driver_unregister(&neo1973_vib_driver);
+}
+
+module_init(neo1973_vib_init);
+module_exit(neo1973_vib_exit);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("Openmoko GTA01/GTA02 vibrator driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/leds/Makefile linux-2.6.29-rc3.owrt.om/drivers/leds/Makefile
--- linux-2.6.29-rc3.owrt/drivers/leds/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/leds/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -24,11 +24,15 @@
 obj-$(CONFIG_LEDS_PCA955X)		+= leds-pca955x.o
 obj-$(CONFIG_LEDS_DA903X)		+= leds-da903x.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
+obj-$(CONFIG_LEDS_NEO1973_VIBRATOR)	+= leds-neo1973-vibrator.o
+obj-$(CONFIG_LEDS_NEO1973_GTA02)	+= leds-neo1973-gta02.o
+obj-$(CONFIG_LEDS_LP5521)		+= leds-lp5521.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
 obj-$(CONFIG_LEDS_TRIGGER_IDE_DISK)	+= ledtrig-ide-disk.o
 obj-$(CONFIG_LEDS_TRIGGER_HEARTBEAT)	+= ledtrig-heartbeat.o
+obj-$(CONFIG_LEDS_TRIGGER_NETDEV)	+= ledtrig-netdev.o
 obj-$(CONFIG_LEDS_TRIGGER_BACKLIGHT)	+= ledtrig-backlight.o
 obj-$(CONFIG_LEDS_TRIGGER_DEFAULT_ON)	+= ledtrig-default-on.o
 obj-$(CONFIG_LEDS_TRIGGER_MORSE)	+= ledtrig-morse.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/Makefile linux-2.6.29-rc3.owrt.om/drivers/Makefile
--- linux-2.6.29-rc3.owrt/drivers/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -90,6 +90,7 @@
 obj-y				+= idle/
 obj-$(CONFIG_MMC)		+= mmc/
 obj-$(CONFIG_MEMSTICK)		+= memstick/
+obj-$(CONFIG_AR6000_WLAN)	+= ar6000/
 obj-$(CONFIG_NEW_LEDS)		+= leds/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-$(CONFIG_SGI_SN)		+= sn/
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/Kconfig linux-2.6.29-rc3.owrt.om/drivers/media/video/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/media/video/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/Kconfig	2009-05-10 22:27:59.000000000 +0200
@@ -711,6 +711,25 @@
 	  CMOS camera controller.  This is the controller found on first-
 	  generation OLPC systems.
 
+config VIDEO_SAMSUNG
+	bool "S3C SMDK CAMERA support"
+	depends on VIDEO_V4L2
+
+	default n
+	---help---
+	  TBA
+
+choice
+depends on VIDEO_SAMSUNG
+prompt "Select CIS module type"
+default VIDEO_SAMSUNG_S5K3BA
+
+config VIDEO_SAMSUNG_S5K4BA
+	bool "S5K4BA (2.0M CIS module, 1600x1200)"
+	---help---
+	  TBA
+endchoice
+
 config SOC_CAMERA
 	tristate "SoC camera support"
 	depends on VIDEO_V4L2 && HAS_DMA
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/Makefile linux-2.6.29-rc3.owrt.om/drivers/media/video/Makefile
--- linux-2.6.29-rc3.owrt/drivers/media/video/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -134,6 +134,8 @@
 obj-$(CONFIG_VIDEO_VIVI) += vivi.o
 obj-$(CONFIG_VIDEO_CX23885) += cx23885/
 
+obj-$(CONFIG_VIDEO_SAMSUNG)	+= s3c_camera_driver.o s3c_camif.o samsung/
+
 obj-$(CONFIG_VIDEO_PXA27x)	+= pxa_camera.o
 obj-$(CONFIG_VIDEO_SH_MOBILE_CEU)	+= sh_mobile_ceu_camera.o
 obj-$(CONFIG_VIDEO_OMAP2)		+= omap2cam.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/s3c_camera_driver.c linux-2.6.29-rc3.owrt.om/drivers/media/video/s3c_camera_driver.c
--- linux-2.6.29-rc3.owrt/drivers/media/video/s3c_camera_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/s3c_camera_driver.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1943 @@
+/* drivers/media/video/s3c_camera_driver.c
+ *
+ * Copyright (c) 2008 Samsung Electronics
+ *
+ * Samsung S3C Camera driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/signal.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/kmod.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/mm.h>
+#include <linux/videodev2.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/semaphore.h>
+#include <asm/io.h>
+#include <asm/page.h>
+#include <plat/regs-gpio.h>
+#include <plat/regs-camif.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#include "s3c_camif.h"
+#include "videodev2_s3c.h"
+
+#include <linux/mfd/pcf50633/core.h>	/* @@@ hack - WA */
+#include <plat/gpio-bank-f.h>
+#include <plat/gpio-cfg.h>
+#include <mach/gpio.h>
+#include <mach/map.h>
+#include <plat/regs-sys.h>
+#include <plat/regs-syscon-power.h>
+
+
+static struct clk *cam_clock;
+camif_cfg_t s3c_fimc[CAMIF_DEV_NUM];
+extern camif_cis_t msdma_input;
+extern int s3c_camif_do_postprocess(camif_cfg_t *cfg);
+
+/*************************************************************************
+ * Utility part
+ ************************************************************************/
+camif_cfg_t *s3c_camif_get_fimc_object(int nr)
+{
+	camif_cfg_t *ret = NULL;
+
+	switch (nr) {
+	case CODEC_MINOR:
+		ret = &s3c_fimc[FIMC_CODEC_INDEX];
+		break;
+
+	case PREVIEW_MINOR:
+		ret = &s3c_fimc[FIMC_PREVIEW_INDEX];
+		break;
+
+	default:
+		printk(KERN_ERR "Unknown minor number\n");
+		ret = &s3c_fimc[FIMC_PREVIEW_INDEX];
+	}
+
+	return ret;
+}
+
+#if defined(FSM_ON_PREVIEW)
+static int s3c_camif_check_global_status(camif_cfg_t *cfg)
+{
+	int ret = 0;
+
+	if (down_interruptible(&cfg->cis->lock))
+		return -ERESTARTSYS;
+
+	if (cfg->cis->status & CWANT2START) {
+		cfg->cis->status &= ~CWANT2START;
+		cfg->auto_restart = 1;
+		ret = 1;
+	} else {
+	        ret = 0;		/* There is no codec */
+		cfg->auto_restart = 0;	/* Duplicated ..Dummy */
+	}
+
+	up(&cfg->cis->lock);
+
+	return ret;
+}
+#endif
+
+static int s3c_camif_convert_format(int pixfmt, int *fmtptr)
+{
+	int fmt = CAMIF_YCBCR420;
+	int depth = 12;
+
+	switch (pixfmt) {
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB565X:
+		fmt = CAMIF_RGB16;
+		depth = 16;
+		break;
+
+	case V4L2_PIX_FMT_BGR24: /* Not tested */
+	case V4L2_PIX_FMT_RGB24:
+		fmt = CAMIF_RGB24;
+		depth = 24;
+		break;
+
+	case V4L2_PIX_FMT_BGR32:
+	case V4L2_PIX_FMT_RGB32:
+		fmt = CAMIF_RGB24;
+		depth = 32;
+		break;
+
+	case V4L2_PIX_FMT_GREY:	/* Not tested  */
+		fmt = CAMIF_YCBCR420;
+		depth = 8;
+		break;
+
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		fmt = CAMIF_YCBCR422I;
+		depth = 16;
+		break;
+
+	case V4L2_PIX_FMT_YUV422P:
+		fmt = CAMIF_YCBCR422;
+		depth = 16;
+		break;
+
+	case V4L2_PIX_FMT_YUV420:
+		fmt = CAMIF_YCBCR420;
+		depth = 12;
+		break;
+	}
+
+	if (fmtptr)
+		*fmtptr = fmt;
+
+	return depth;
+}
+
+static int s3c_camif_set_fb_info(camif_cfg_t *cfg, int depth, int fourcc)
+{
+	/* To define v4l2_format used currently */
+	cfg->v2.frmbuf.fmt.width = cfg->target_x;
+	cfg->v2.frmbuf.fmt.height = cfg->target_y;
+	cfg->v2.frmbuf.fmt.field = V4L2_FIELD_NONE;
+	cfg->v2.frmbuf.fmt.pixelformat = fourcc;
+	cfg->v2.frmbuf.fmt.bytesperline = cfg->v2.frmbuf.fmt.width * depth >> 3;
+	cfg->v2.frmbuf.fmt.sizeimage =
+	    cfg->v2.frmbuf.fmt.height * cfg->v2.frmbuf.fmt.bytesperline;
+
+	return 0;
+}
+
+static int s3c_camif_convert_type(camif_cfg_t *cfg, int f)
+{
+	int pixfmt;
+
+	cfg->target_x = cfg->v2.frmbuf.fmt.width;
+	cfg->target_y = cfg->v2.frmbuf.fmt.height;
+
+	s3c_camif_convert_format(cfg->v2.frmbuf.fmt.pixelformat, &pixfmt);
+
+	cfg->dst_fmt = pixfmt;
+
+	return 0;
+}
+
+/*************************************************************************
+ * Control part
+ ************************************************************************/
+static int s3c_camif_start_capture(camif_cfg_t * cfg)
+{
+	int ret = 0;
+
+	cfg->capture_enable = CAMIF_DMA_ON;
+
+	s3c_camif_start_dma(cfg);
+
+	cfg->status = CAMIF_STARTED;
+
+	if (!(cfg->fsm == CAMIF_SET_LAST_INT ||
+	    cfg->fsm == CAMIF_CONTINUOUS_INT)) {
+		cfg->fsm = CAMIF_DUMMY_INT;
+		cfg->perf.frames = 0;
+	}
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+	if (cfg->input_channel == MSDMA_FROM_CODEC)
+		s3c_camif_start_codec_msdma(cfg);
+#endif
+	return ret;
+}
+
+ssize_t s3c_camif_start_preview(camif_cfg_t *cfg)
+{
+	cfg->capture_enable = CAMIF_DMA_ON;
+
+	s3c_camif_start_dma(cfg);
+
+	cfg->status = CAMIF_STARTED;
+	cfg->fsm = CAMIF_1st_INT;
+	cfg->perf.frames = 0;
+
+	return 0;
+}
+
+ssize_t s3c_camif_stop_preview(camif_cfg_t *cfg)
+{
+	cfg->capture_enable = CAMIF_DMA_OFF;
+	cfg->status = CAMIF_STOPPED;
+
+	s3c_camif_stop_dma(cfg);
+
+	cfg->perf.frames = 0;
+
+	return 0;
+}
+
+ssize_t s3c_camif_stop_capture(camif_cfg_t *cfg)
+{
+	cfg->capture_enable = CAMIF_DMA_OFF;
+	cfg->status = CAMIF_STOPPED;
+
+	s3c_camif_stop_dma(cfg);
+
+	cfg->perf.frames = 0;
+
+	return 0;
+}
+
+ssize_t s3c_camif_stop_fimc(camif_cfg_t *cfg)
+{
+	cfg->capture_enable = CAMIF_BOTH_DMA_OFF;
+	cfg->fsm = CAMIF_DUMMY_INT;
+	cfg->perf.frames = 0;
+
+	s3c_camif_stop_dma(cfg);
+
+	return 0;
+}
+
+#if defined(FSM_ON_PREVIEW)
+static void s3c_camif_start_preview_with_codec(camif_cfg_t *cfg)
+{
+	camif_cfg_t *other = cfg->other;
+
+	/* Preview Stop */
+	cfg->capture_enable = CAMIF_DMA_OFF;
+	s3c_camif_stop_dma(cfg);
+
+	/* Start Preview and CODEC */
+	cfg->capture_enable =CAMIF_BOTH_DMA_ON;
+
+	s3c_camif_start_dma(cfg);
+	cfg->fsm = CAMIF_1st_INT; /* For Preview */
+
+	if (!other)
+		panic("Unexpected error: other is null\n");
+
+	switch (other->pp_num) {
+	case 4:
+		other->fsm = CAMIF_1st_INT; /* For CODEC */
+		break;
+
+	case 1:
+		other->fsm = CAMIF_Yth_INT;
+		break;
+
+	default:
+		panic("Invalid pingpong number");
+		break;
+	}
+}
+
+static void s3c_camif_auto_restart(camif_cfg_t *cfg)
+{
+	if (cfg->auto_restart)
+		s3c_camif_start_preview_with_codec(cfg);
+}
+#endif
+
+static void s3c_camif_change_mode(camif_cfg_t *cfg, int mode)
+{
+	camif_cis_t *cis = cfg->cis;
+	int res;
+
+	if (mode == SENSOR_MAX) {
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K3AA)
+		res = SENSOR_SXGA;
+#elif defined(CONFIG_VIDEO_SAMSUNG_S5K3BA)
+		res = SENSOR_UXGA;
+
+/* 4BA max is UXGA, but we don't have UXGA control values */
+#elif defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+		res = SENSOR_SVGA;
+#endif
+	} else if (mode == SENSOR_DEFAULT) {
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+		res = SENSOR_SVGA;
+#else
+		res = SENSOR_VGA;
+#endif
+	} else
+		res = mode;
+
+	s3c_camif_stop_fimc(cfg);
+
+	switch (res) {
+	case SENSOR_SXGA:
+		printk(KERN_INFO
+		    "Resolution changed into SXGA (1280x1024) mode -> 1.3M\n");
+		cis->sensor->driver->command(cis->sensor, SENSOR_SXGA, NULL);
+		cis->source_x = 1280;
+		cis->source_y = 1024;
+		break;
+
+	case SENSOR_UXGA:
+		printk(KERN_INFO
+		    "Resolution changed into UXGA (1600x1200) mode -> 2.0M\n");
+		cis->sensor->driver->command(cis->sensor, SENSOR_UXGA, NULL);
+		cis->source_x = 1600;
+		cis->source_y = 1200;
+		break;
+
+	case SENSOR_SVGA:
+		printk(KERN_INFO
+		    "Resolution changed back to SVGA (800x600) mode\n");
+		cis->sensor->driver->command(cis->sensor, SENSOR_SVGA, NULL);
+		cis->source_x = 800;
+		cis->source_y = 600;
+		break;
+
+	case SENSOR_VGA:
+		printk(KERN_INFO "Resolution changed back to VGA (640x480) "
+		    "mode (default)\n");
+		cis->sensor->driver->command(cis->sensor, SENSOR_VGA, NULL);
+		cis->source_x = 640;
+		cis->source_y = 480;
+		break;
+	}
+
+	cis->win_hor_ofst = cis->win_hor_ofst2 = 0;
+	cis->win_ver_ofst = cis->win_ver_ofst2 = 0;
+
+	s3c_camif_set_source_format(cis);
+}
+
+static int s3c_camif_check_zoom_range(camif_cfg_t *cfg, int type)
+{
+	switch (type) {
+	case V4L2_CID_ZOOMIN:
+		if (((cfg->sc.modified_src_x - (cfg->cis->win_hor_ofst +
+		    ZOOM_AT_A_TIME_IN_PIXELS + cfg->cis->win_hor_ofst2 +
+		    ZOOM_AT_A_TIME_IN_PIXELS)) / cfg->sc.prehratio) >
+		    ZOOM_IN_MAX) {
+	                printk(KERN_INFO "Invalid Zoom-in: this zoom-in on "
+			    "preview scaler already comes to the maximum\n");
+			return 0;
+		}
+
+		cfg->sc.zoom_in_cnt++;
+		break;
+
+	case V4L2_CID_ZOOMOUT:
+		if (cfg->sc.zoom_in_cnt > 0) {
+			cfg->sc.zoom_in_cnt--;
+		} else {
+	                printk(KERN_INFO "Invalid Zoom-out: this zoom-out on "
+			    "preview scaler already comes to the minimum\n");
+			return 0;
+		}
+
+		break;
+
+	default:
+		break;
+	}
+
+	return 1;
+}
+
+static int s3c_camif_restart_preview(camif_cfg_t *cfg)
+{
+	int ret = 0;
+
+	s3c_camif_stop_preview(cfg);
+
+	if (s3c_camif_control_fimc(cfg)) {
+		printk(KERN_ERR "S3C fimc control failed\n");
+		ret = -1;
+	}
+
+	s3c_camif_start_preview(cfg);
+
+	return ret;
+}
+
+static int s3c_camif_send_sensor_command(camif_cfg_t *cfg, unsigned int cmd,
+    int arg)
+{
+	cfg->cis->sensor->driver->command(cfg->cis->sensor, cmd, (void *) arg);
+
+	return 0;
+}
+
+/*************************************************************************
+ * V4L2 part
+ ************************************************************************/
+static int s3c_camif_v4l2_querycap(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_capability *cap = arg;
+
+	strcpy(cap->driver, "S3C FIMC Camera driver");
+	strlcpy(cap->card, cfg->v->name, sizeof(cap->card));
+	sprintf(cap->bus_info, "FIMC AHB Bus");
+
+	cap->version = 0;
+	cap->capabilities = V4L2_CAP_VIDEO_OVERLAY | V4L2_CAP_VIDEO_CAPTURE |
+	    V4L2_CAP_STREAMING;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_g_fbuf(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_framebuffer *fb = arg;
+
+	*fb = cfg->v2.frmbuf;
+
+	fb->base = cfg->v2.frmbuf.base;
+	fb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;
+
+	fb->fmt.pixelformat  = cfg->v2.frmbuf.fmt.pixelformat;
+	fb->fmt.width = cfg->v2.frmbuf.fmt.width;
+	fb->fmt.height = cfg->v2.frmbuf.fmt.height;
+	fb->fmt.bytesperline = cfg->v2.frmbuf.fmt.bytesperline;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_s_fbuf(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_framebuffer *fb = arg;
+	int i, depth;
+
+	for (i = 0; i < NUMBER_OF_PREVIEW_FORMATS; i++)
+		if (fimc_preview_formats[i].pixelformat == fb->fmt.pixelformat)
+			break;
+
+	if (i == NUMBER_OF_PREVIEW_FORMATS)
+		return -EINVAL;
+
+	cfg->v2.frmbuf.base  = fb->base;
+	cfg->v2.frmbuf.flags = fb->flags;
+	cfg->v2.frmbuf.capability = fb->capability;
+
+	cfg->target_x = fb->fmt.width;
+	cfg->target_y = fb->fmt.height;
+
+	depth = s3c_camif_convert_format(fb->fmt.pixelformat,
+	    (int *) &cfg->dst_fmt);
+	s3c_camif_set_fb_info(cfg, depth, fb->fmt.pixelformat);
+
+	return s3c_camif_control_fimc(cfg);
+}
+
+static int s3c_camif_v4l2_g_fmt(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_format *f = arg;
+	int size = sizeof(struct v4l2_pix_format);
+	int ret = -1;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		memset(&f->fmt.pix, 0, size);
+		memcpy(&f->fmt.pix, &cfg->v2.frmbuf.fmt, size);
+		ret = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int s3c_camif_v4l2_s_fmt(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_format *f = arg;
+	int ret = -1;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		cfg->v2.frmbuf.fmt = f->fmt.pix;
+		cfg->v2.status |= CAMIF_v4L2_DIRTY;
+		cfg->v2.status &= ~CAMIF_v4L2_DIRTY; /* dummy ? */
+
+		s3c_camif_convert_type(cfg, 1);
+		s3c_camif_control_fimc(cfg);
+		ret = 0;
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int s3c_camif_v4l2_enum_fmt(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_fmtdesc *f = arg;
+	int index = f->index;
+
+	if (index >= NUMBER_OF_CODEC_FORMATS)
+		return -EINVAL;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		break;
+
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+	default:
+		return -EINVAL;
+	}
+
+	memset(f, 0, sizeof(*f));
+	memcpy(f, cfg->v2.fmtdesc + index, sizeof(*f));
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_overlay(camif_cfg_t *cfg, void *arg)
+{
+	int on = *(int *) arg;
+
+	if (on)
+		return s3c_camif_start_preview(cfg);
+	else
+		return s3c_camif_stop_preview(cfg);
+}
+
+static int s3c_camif_v4l2_g_ctrl(camif_cfg_t *cfg, void *arg)
+{
+	return 0;
+}
+
+static int s3c_camif_v4l2_s_ctrl(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_control *ctrl = arg;
+
+	switch (ctrl->id) {
+		case V4L2_CID_ORIGINAL:
+		case V4L2_CID_ARBITRARY:
+		case V4L2_CID_NEGATIVE:
+		case V4L2_CID_EMBOSSING:
+		case V4L2_CID_ART_FREEZE:
+		case V4L2_CID_SILHOUETTE:
+			cfg->effect = ctrl->value;
+			s3c_camif_change_effect(cfg);
+			break;
+
+		case V4L2_CID_HFLIP:
+			cfg->flip = CAMIF_FLIP_X;
+			s3c_camif_change_flip(cfg);
+			break;
+
+		case V4L2_CID_VFLIP:
+			cfg->flip = CAMIF_FLIP_Y;
+			s3c_camif_change_flip(cfg);
+			break;
+
+		case V4L2_CID_ROTATE_180:
+			cfg->flip = CAMIF_FLIP_MIRROR;
+			s3c_camif_change_flip(cfg);
+			break;
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+		case V4L2_CID_ROTATE_90:
+			cfg->flip = CAMIF_ROTATE_90;
+			s3c_camif_change_flip(cfg);
+			break;
+
+		case V4L2_CID_ROTATE_270:
+			cfg->flip = CAMIF_FLIP_ROTATE_270;
+			s3c_camif_change_flip(cfg);
+			break;
+#endif
+
+		case V4L2_CID_ROTATE_BYPASS:
+			cfg->flip = CAMIF_FLIP;
+			s3c_camif_change_flip(cfg);
+			break;
+
+		case V4L2_CID_ZOOMIN:
+			if (!s3c_camif_check_zoom_range(cfg, ctrl->id))
+				break;
+			cfg->cis->win_hor_ofst += ZOOM_AT_A_TIME_IN_PIXELS;
+			cfg->cis->win_ver_ofst += ZOOM_AT_A_TIME_IN_PIXELS;
+			cfg->cis->win_hor_ofst2 += ZOOM_AT_A_TIME_IN_PIXELS;
+			cfg->cis->win_ver_ofst2 += ZOOM_AT_A_TIME_IN_PIXELS;
+
+			s3c_camif_restart_preview(cfg);
+
+			break;
+
+		case V4L2_CID_ZOOMOUT:
+			if (!s3c_camif_check_zoom_range(cfg, ctrl->id))
+				break;
+			cfg->cis->win_hor_ofst -= ZOOM_AT_A_TIME_IN_PIXELS;
+			cfg->cis->win_ver_ofst -= ZOOM_AT_A_TIME_IN_PIXELS;
+			cfg->cis->win_hor_ofst2 -= ZOOM_AT_A_TIME_IN_PIXELS;
+			cfg->cis->win_ver_ofst2 -= ZOOM_AT_A_TIME_IN_PIXELS;
+
+			s3c_camif_restart_preview(cfg);
+
+			break;
+
+		case V4L2_CID_CONTRAST:
+		case V4L2_CID_AUTO_WHITE_BALANCE:
+			s3c_camif_send_sensor_command(cfg, SENSOR_WB,
+			    ctrl->value);
+			break;
+
+		default:
+			printk(KERN_ERR "Invalid control id: %d\n", ctrl->id);
+			return -1;
+	}
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_streamon(camif_cfg_t *cfg, void *arg)
+{
+	return s3c_camif_start_capture(cfg);
+}
+
+static int s3c_camif_v4l2_streamoff(camif_cfg_t *cfg, void *arg)
+{
+	cfg->cis->status &= ~C_WORKING;
+
+	s3c_camif_stop_capture(cfg);
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_g_input(camif_cfg_t *cfg, void *arg)
+{
+	unsigned int *index = arg;
+
+	*index = cfg->v2.input->index;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_s_input(camif_cfg_t *cfg, unsigned int index)
+{
+	int ret = -1;
+
+	if (index >= NUMBER_OF_INPUTS)
+		ret = -1;
+	else {
+		cfg->v2.input = &fimc_inputs[index];
+
+		if (cfg->v2.input->type == V4L2_INPUT_TYPE_MSDMA) {
+			if (cfg->dma_type & CAMIF_PREVIEW) {
+				cfg->input_channel = MSDMA_FROM_PREVIEW;
+				ret = 0;
+			} else if (cfg->dma_type & CAMIF_CODEC) {
+				cfg->input_channel = MSDMA_FROM_CODEC;
+				ret = 0;
+			}
+		} else {
+			cfg->input_channel = CAMERA_INPUT;
+			ret = 0;
+		}
+	}
+
+	return ret;
+}
+
+static int s3c_camif_v4l2_g_output(camif_cfg_t *cfg, void *arg)
+{
+	unsigned int *index = arg;
+
+	*index = cfg->v2.output->index;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_s_output(camif_cfg_t *cfg, unsigned int index)
+{
+	if (index >= NUMBER_OF_OUTPUTS)
+		return -EINVAL;
+	else {
+		cfg->v2.output = (struct v4l2_output *) &fimc_outputs[index];
+		return 0;
+	}
+}
+
+static int s3c_camif_v4l2_enum_input(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_input *i = arg;
+
+	if (i->index >= NUMBER_OF_INPUTS)
+		return -EINVAL;
+
+	memcpy(i, &fimc_inputs[i->index], sizeof(struct v4l2_input));
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_enum_output(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_output *i = arg;
+
+	if (i->index >= NUMBER_OF_OUTPUTS)
+		return -EINVAL;
+
+	memcpy(i, &fimc_outputs[i->index], sizeof(struct v4l2_output));
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_reqbufs(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_requestbuffers *req = arg;
+
+	if (req->memory != V4L2_MEMORY_MMAP) {
+		printk(KERN_ERR "Only V4L2_MEMORY_MMAP capture is supported\n");
+		return -EINVAL;
+	}
+
+	/* control user input */
+	if (req->count > 2)
+		req->count = 4;
+	else if (req->count > 1)
+		req->count = 2;
+	else
+		req->count = 1;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_querybuf(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_buffer *buf = arg;
+
+	if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    buf->memory != V4L2_MEMORY_MMAP)
+		return -1;
+
+	buf->length = cfg->buffer_size;
+	buf->m.offset = buf->length * buf->index;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_qbuf(camif_cfg_t *cfg, void *arg)
+{
+	return 0;
+}
+
+static int s3c_camif_v4l2_dqbuf(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_buffer *buf = arg;
+
+	buf->index = cfg->cur_frame_num % cfg->pp_num;
+
+	return 0;
+}
+
+/*
+ * S3C specific
+ */
+static int s3c_camif_v4l2_s_msdma(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_msdma_format *f = arg;
+	int ret;
+
+	switch(f->input_path) {
+	case V4L2_MSDMA_PREVIEW:
+		cfg->cis->user--;
+		    /* CIS will be replaced with a CIS for MSDMA */
+
+		cfg->cis = &msdma_input;
+		cfg->cis->user++;
+		cfg->input_channel = MSDMA_FROM_PREVIEW;
+		break;
+
+	case V4L2_MSDMA_CODEC:
+		cfg->cis->user--;
+		    /* CIS will be replaced with a CIS for MSDMA */
+
+		cfg->cis = &msdma_input;
+		cfg->cis->user++;
+		cfg->input_channel = MSDMA_FROM_CODEC;
+		break;
+
+	default:
+		cfg->input_channel = CAMERA_INPUT;
+		break;
+	}
+
+	cfg->cis->source_x = f->width;
+	cfg->cis->source_y = f->height;
+
+	s3c_camif_convert_format(f->pixelformat, (int *) &cfg->src_fmt);
+
+	cfg->cis->win_hor_ofst = 0;
+	cfg->cis->win_ver_ofst = 0;
+	cfg->cis->win_hor_ofst2 = 0;
+	cfg->cis->win_ver_ofst2 = 0;
+
+	ret = s3c_camif_control_fimc(cfg);
+
+	switch(f->input_path) {
+	case V4L2_MSDMA_PREVIEW:
+		ret = s3c_camif_start_preview(cfg);
+		break;
+
+	case V4L2_MSDMA_CODEC:
+		ret = s3c_camif_start_capture(cfg);
+		break;
+
+	default:
+		break;
+
+	}
+
+	return ret;
+}
+
+static int s3c_camif_v4l2_msdma_start(camif_cfg_t *cfg, void *arg)
+{
+	if (cfg->input_channel == MSDMA_FROM_PREVIEW) {
+		cfg->msdma_status = 1;
+		s3c_camif_start_preview_msdma(cfg);
+	}
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_msdma_stop(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_msdma_format *f = arg;
+	int ret = -1;
+
+	cfg->cis->status &= ~C_WORKING;
+	cfg->msdma_status = 0;
+
+	switch(f->input_path) {
+	case V4L2_MSDMA_PREVIEW:
+		ret = s3c_camif_stop_preview(cfg);
+		break;
+
+	case V4L2_MSDMA_CODEC:
+		ret = s3c_camif_stop_capture(cfg);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int s3c_camif_v4l2_camera_start(camif_cfg_t *cfg, void *arg)
+{
+	return 0;
+}
+
+static int s3c_camif_v4l2_camera_stop(camif_cfg_t *cfg, void *arg)
+{
+	return 0;
+}
+
+static int s3c_camif_v4l2_cropcap(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_cropcap *cap = arg;
+
+	if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    cap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)
+		return -EINVAL;
+
+	/* crop limitations */
+	cfg->v2.crop_bounds.left = 0;
+	cfg->v2.crop_bounds.top = 0;
+	cfg->v2.crop_bounds.width = cfg->cis->source_x;
+	cfg->v2.crop_bounds.height = cfg->cis->source_y;
+
+	/* crop default values */
+	cfg->v2.crop_defrect.left =
+	    (cfg->cis->source_x - CROP_DEFAULT_WIDTH) / 2;
+	cfg->v2.crop_defrect.top =
+	    (cfg->cis->source_y - CROP_DEFAULT_HEIGHT) / 2;
+	cfg->v2.crop_defrect.width = CROP_DEFAULT_WIDTH;
+	cfg->v2.crop_defrect.height = CROP_DEFAULT_HEIGHT;
+
+	cap->bounds = cfg->v2.crop_bounds;
+	cap->defrect = cfg->v2.crop_defrect;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_g_crop(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_crop *crop = arg;
+
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)
+		return -EINVAL;
+
+	crop->c = cfg->v2.crop_current;
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_s_crop(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_crop *crop = arg;
+
+	if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)
+		return -EINVAL;
+
+	if (crop->c.height < 0)
+		return -EINVAL;
+
+	if (crop->c.width < 0)
+		return -EINVAL;
+
+	if ((crop->c.left + crop->c.width > cfg->cis->source_x) ||
+		(crop->c.top + crop->c.height > cfg->cis->source_y))
+		return -EINVAL;
+
+	cfg->v2.crop_current = crop->c;
+
+	cfg->cis->win_hor_ofst = (cfg->cis->source_x - crop->c.width) / 2;
+	cfg->cis->win_ver_ofst = (cfg->cis->source_y - crop->c.height) / 2;
+
+	cfg->cis->win_hor_ofst2 = cfg->cis->win_hor_ofst;
+	cfg->cis->win_ver_ofst2 = cfg->cis->win_ver_ofst;
+
+	s3c_camif_restart_preview(cfg);
+
+	return 0;
+}
+
+static int s3c_camif_v4l2_s_parm(camif_cfg_t *cfg, void *arg)
+{
+	struct v4l2_streamparm *sp = arg;
+
+	if (sp->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	if (sp->parm.capture.capturemode == V4L2_MODE_HIGHQUALITY) {
+		s3c_camif_change_mode(cfg, SENSOR_MAX);
+		s3c_camif_control_fimc(cfg);
+	} else {
+		s3c_camif_change_mode(cfg, SENSOR_DEFAULT);
+		s3c_camif_control_fimc(cfg);
+	}
+
+	return 0;
+}
+
+/*************************************************************************
+ * Interrupt part
+ ************************************************************************/
+#if defined(FSM_ON_CODEC) && !defined(USE_LAST_IRQ)
+int s3c_camif_do_fsm_codec(camif_cfg_t *cfg)
+{
+	cfg->perf.frames++;
+
+	if (cfg->fsm == CAMIF_DUMMY_INT &&
+	    cfg->perf.frames > CAMIF_CAPTURE_SKIP_FRAMES)
+		cfg->fsm = CAMIF_NORMAL_INT;
+
+	switch (cfg->fsm) {
+	case CAMIF_DUMMY_INT:
+		DPRINTK(KERN_INFO "CAMIF_DUMMY_INT: %d\n", cfg->perf.frames);
+		cfg->status = CAMIF_STARTED;
+		cfg->fsm = CAMIF_DUMMY_INT;
+		return INSTANT_SKIP;
+
+	case CAMIF_NORMAL_INT:
+		DPRINTK(KERN_INFO "CAMIF_NORMAL_INT: %d\n", cfg->perf.frames);
+		cfg->status = CAMIF_INT_HAPPEN;
+		cfg->fsm = CAMIF_CONTINUOUS_INT;
+		return INSTANT_GO;
+
+	case CAMIF_CONTINUOUS_INT:
+		DPRINTK(KERN_INFO "CAMIF_CONTINUOS_INT: %d\n",
+		    cfg->perf.frames);
+		cfg->status = CAMIF_INT_HAPPEN;
+		cfg->fsm = CAMIF_CONTINUOUS_INT;
+		return INSTANT_GO;
+
+	default:
+		printk(KERN_INFO "Unexpect INT: %d\n", cfg->fsm);
+		return INSTANT_SKIP;
+	}
+}
+#endif
+
+#if defined(FSM_ON_CODEC) && defined(USE_LAST_IRQ)
+int s3c_camif_do_fsm_codec_lastirq(camif_cfg_t *cfg)
+{
+	cfg->perf.frames++;
+
+	if (cfg->fsm == CAMIF_DUMMY_INT &&
+	    cfg->perf.frames > CAMIF_CAPTURE_SKIP_FRAMES - 2)
+		cfg->fsm = CAMIF_SET_LAST_INT;
+
+	switch (cfg->fsm) {
+	case CAMIF_DUMMY_INT:
+		DPRINTK(KERN_INFO "CAMIF_DUMMY_INT: %d\n", cfg->perf.frames);
+		cfg->status = CAMIF_STARTED;
+		cfg->fsm = CAMIF_DUMMY_INT;
+		return INSTANT_SKIP;
+
+	case CAMIF_SET_LAST_INT:
+		DPRINTK(KERN_INFO "CAMIF_SET_LAST_INT: %d\n", cfg->perf.frames);
+		s3c_camif_enable_lastirq(cfg);
+
+/* in 64xx, lastirq is not auto cleared. */
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+		s3c_camif_disable_lastirq(cfg);
+#endif
+		cfg->status = CAMIF_INT_HAPPEN;
+		cfg->fsm = CAMIF_STOP_CAPTURE;
+		return INSTANT_SKIP;
+
+	case CAMIF_STOP_CAPTURE:
+		DPRINTK(KERN_INFO "CAMIF_STOP_CAPTURE: %d\n", cfg->perf.frames);
+		cfg->capture_enable = CAMIF_DMA_OFF;
+		s3c_camif_stop_dma(cfg);
+		cfg->fsm = CAMIF_LAST_IRQ;
+		return INSTANT_SKIP;
+
+	case CAMIF_LAST_IRQ:
+		DPRINTK(KERN_INFO "CAMIF_LAST_IRQ: %d\n", cfg->perf.frames);
+		cfg->fsm = CAMIF_SET_LAST_INT;
+		cfg->status = CAMIF_INT_HAPPEN;
+		return INSTANT_GO;
+
+	default:
+		printk(KERN_INFO "Unexpect INT: %d\n", cfg->fsm);
+		return = INSTANT_SKIP;
+	}
+}
+#endif
+
+#if defined(FSM_ON_PREVIEW)
+static int s3c_camif_do_lastirq_preview(camif_cfg_t *cfg)
+{
+	cfg->perf.frames++;
+
+	if (cfg->fsm == CAMIF_NORMAL_INT)
+		if (cfg->perf.frames % CHECK_FREQ == 0)
+			if (s3c_camif_check_global_status(cfg) > 0)
+				cfg->fsm = CAMIF_Xth_INT;
+
+	switch (cfg->fsm) {
+	case CAMIF_1st_INT:
+		DPRINTK(KERN_INFO "CAMIF_1st_INT INT\n");
+		cfg->fsm = CAMIF_NORMAL_INT;
+		return INSTANT_SKIP;
+
+	case CAMIF_NORMAL_INT:
+		DPRINTK(KERN_INFO "CAMIF_NORMAL_INT\n");
+		cfg->status = CAMIF_INT_HAPPEN;
+		cfg->fsm = CAMIF_NORMAL_INT;
+		return INSTANT_GO;
+
+	case CAMIF_Xth_INT:
+		DPRINTK(KERN_INFO "CAMIF_Xth_INT\n");
+		s3c_camif_enable_lastirq(cfg);
+		cfg->status = CAMIF_INT_HAPPEN;
+		cfg->fsm = CAMIF_Yth_INT;
+		return INSTANT_GO;
+
+	case CAMIF_Yth_INT:
+		DPRINTK(KERN_INFO "CAMIF_Yth_INT\n");
+		s3c_camif_disable_lastirq(cfg);
+		cfg->capture_enable = CAMIF_DMA_OFF;
+		cfg->status = CAMIF_INT_HAPPEN;
+		s3c_camif_stop_dma(cfg);
+		cfg->fsm = CAMIF_Zth_INT;
+		return INSTANT_GO;
+
+	case CAMIF_Zth_INT:
+		DPRINTK(KERN_INFO "CAMIF_Zth_INT\n");
+		cfg->fsm = CAMIF_DUMMY_INT;
+		cfg->status = CAMIF_INT_HAPPEN;
+		s3c_camif_auto_restart(cfg);
+		return INSTANT_GO;
+
+	case CAMIF_DUMMY_INT:
+		DPRINTK(KERN_INFO "CAMIF_DUMMY_INT\n");
+		cfg->status = CAMIF_STOPPED;
+		return INSTANT_SKIP;
+
+	default:
+		printk(KERN_INFO "Unexpected INT %d\n", cfg->fsm);
+		return INSTANT_SKIP;
+	}
+}
+#endif
+
+static irqreturn_t s3c_camif_do_irq_codec(int irq, void *dev_id)
+{
+	camif_cfg_t *cfg = (camif_cfg_t *) dev_id;
+
+/* @@@ SMKD ? - WA */
+#if 0 && (defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410))
+	s3c_gpio_setpin(S3C_GPN15, 1);
+#endif
+	s3c_camif_clear_irq(irq);
+	s3c_camif_get_fifo_status(cfg);
+	s3c_camif_get_frame_num(cfg);
+
+#if defined(FSM_ON_CODEC) && !defined(USE_LAST_IRQ)
+	if (s3c_camif_do_fsm_codec(cfg) == INSTANT_SKIP)
+		return IRQ_HANDLED;
+#endif
+
+#if defined(FSM_ON_CODEC) && defined(USE_LAST_IRQ)
+	if (s3c_camif_do_fsm_codec_lastirq(cfg) == INSTANT_SKIP)
+		return IRQ_HANDLED;
+#endif
+	wake_up_interruptible(&cfg->waitq);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t s3c_camif_do_irq_preview(int irq, void *dev_id)
+{
+	camif_cfg_t *cfg = (camif_cfg_t *) dev_id;
+
+	s3c_camif_clear_irq(irq);
+	s3c_camif_get_fifo_status(cfg);
+	s3c_camif_get_frame_num(cfg);
+	wake_up_interruptible(&cfg->waitq);
+
+#if defined(FSM_ON_PREVIEW)
+	if (s3c_camif_do_lastirq_preview(cfg) == INSTANT_SKIP)
+		return IRQ_HANDLED;
+
+	wake_up_interruptible(&cfg->waitq);
+#endif
+	cfg->status = CAMIF_INT_HAPPEN;
+
+	return IRQ_HANDLED;
+}
+
+static void s3c_camif_release_irq(camif_cfg_t * cfg)
+{
+	disable_irq(cfg->irq);
+	free_irq(cfg->irq, cfg);
+}
+
+static int s3c_camif_request_irq(camif_cfg_t * cfg)
+{
+	int ret;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		ret = request_irq(cfg->irq, s3c_camif_do_irq_codec,
+		    IRQF_SHARED, cfg->shortname, cfg);
+		if (ret)
+			printk(KERN_ERR "Request irq (CAM_C) failed\n");
+		else
+			printk(KERN_INFO "Request irq %d for codec\n",
+			    cfg->irq);
+	}
+
+	if (cfg->dma_type & CAMIF_PREVIEW) {
+		ret = request_irq(cfg->irq, s3c_camif_do_irq_preview,
+		    IRQF_SHARED, cfg->shortname, cfg);
+		if (ret)
+			printk("Request_irq (CAM_P) failed\n");
+		else
+			printk(KERN_INFO "Request irq %d for preview\n",
+			    cfg->irq);
+	}
+
+	return 0;
+}
+
+/*************************************************************************
+ * Standard file operations part
+ ************************************************************************/
+long s3c_camif_ioctl(struct file *file, unsigned int cmd, unsigned long _arg)
+{
+	camif_cfg_t *cfg = file->private_data;
+	void *arg = (void *) _arg; /* @@@ - WA */
+
+	switch (cmd) {
+	case VIDIOC_QUERYCAP:
+		return s3c_camif_v4l2_querycap(cfg, arg);
+
+	case VIDIOC_G_FBUF:
+		return s3c_camif_v4l2_g_fbuf(cfg, arg);
+
+	case VIDIOC_S_FBUF:
+		return s3c_camif_v4l2_s_fbuf(cfg, arg);
+
+	case VIDIOC_G_FMT:
+		return s3c_camif_v4l2_g_fmt(cfg, arg);
+
+	case VIDIOC_S_FMT:
+		return s3c_camif_v4l2_s_fmt(cfg, arg);
+
+	case VIDIOC_ENUM_FMT:
+		return s3c_camif_v4l2_enum_fmt(cfg, arg);
+
+	case VIDIOC_OVERLAY:
+		return s3c_camif_v4l2_overlay(cfg, arg);
+
+	case VIDIOC_S_CTRL:
+		return s3c_camif_v4l2_s_ctrl(cfg, arg);
+
+	case VIDIOC_G_CTRL:
+		return s3c_camif_v4l2_g_ctrl(cfg, arg);
+
+	case VIDIOC_STREAMON:
+		return s3c_camif_v4l2_streamon(cfg, arg);
+
+	case VIDIOC_STREAMOFF:
+		return s3c_camif_v4l2_streamoff(cfg, arg);
+
+	case VIDIOC_G_INPUT:
+		return s3c_camif_v4l2_g_input(cfg, arg);
+
+	case VIDIOC_S_INPUT:
+		return s3c_camif_v4l2_s_input(cfg, *((int *) arg));
+
+	case VIDIOC_G_OUTPUT:
+		return s3c_camif_v4l2_g_output(cfg, arg);
+
+	case VIDIOC_S_OUTPUT:
+		return s3c_camif_v4l2_s_output(cfg, *((int *) arg));
+
+	case VIDIOC_ENUMINPUT:
+		return s3c_camif_v4l2_enum_input(cfg, arg);
+
+	case VIDIOC_ENUMOUTPUT:
+		return s3c_camif_v4l2_enum_output(cfg, arg);
+
+	case VIDIOC_REQBUFS:
+		return s3c_camif_v4l2_reqbufs(cfg, arg);
+
+	case VIDIOC_QUERYBUF:
+		return s3c_camif_v4l2_querybuf(cfg, arg);
+
+	case VIDIOC_QBUF:
+		return s3c_camif_v4l2_qbuf(cfg, arg);
+
+	case VIDIOC_DQBUF:
+		return s3c_camif_v4l2_dqbuf(cfg, arg);
+
+	case VIDIOC_S_MSDMA:
+		return s3c_camif_v4l2_s_msdma(cfg, arg);
+
+	case VIDIOC_MSDMA_START:
+		return s3c_camif_v4l2_msdma_start(cfg, arg);
+
+	case VIDIOC_MSDMA_STOP:
+		return s3c_camif_v4l2_msdma_stop(cfg, arg);
+
+	case VIDIOC_S_CAMERA_START:
+		return s3c_camif_v4l2_camera_start(cfg, arg);
+
+	case VIDIOC_S_CAMERA_STOP:
+		return s3c_camif_v4l2_camera_stop(cfg, arg);
+
+	case VIDIOC_CROPCAP:
+		return s3c_camif_v4l2_cropcap(cfg, arg);
+
+	case VIDIOC_G_CROP:
+		return s3c_camif_v4l2_g_crop(cfg, arg);
+
+	case VIDIOC_S_CROP:
+		return s3c_camif_v4l2_s_crop(cfg, arg);
+
+	case VIDIOC_S_PARM:
+		return s3c_camif_v4l2_s_parm(cfg, arg);
+
+	default:	/* For v4l compatability */
+		return
+		    v4l_compat_translate_ioctl(file, cmd, arg, s3c_camif_ioctl);
+	}
+}
+
+
+void om_3d7k_camera_on(void)
+{
+	extern struct pcf50633 *om_3d7k_pcf;
+	int i;
+
+	gpio_direction_output(S3C64XX_GPF(3), 0);
+
+	/* @@@ hack - WA */
+	pcf50633_reg_write(om_3d7k_pcf, 0x30, 0x21);
+	for (i = 0; !(pcf50633_reg_read(om_3d7k_pcf, 0x42) & 0x02); i++) {
+		if (i == 100) {
+			printk(KERN_ERR "can't bring up LDO2\n");
+			break;
+		}
+		msleep(10);
+	}
+
+	pcf50633_reg_write(om_3d7k_pcf, 0x39, 0x13);
+	pcf50633_reg_write(om_3d7k_pcf, 0x3a, 0x21);
+	for (i = 0; !(pcf50633_reg_read(om_3d7k_pcf, 0x42) & 0x40); i++) {
+		if (i == 100) {
+			printk(KERN_ERR "can't bring up HCLDO\n");
+			break;
+		}
+		msleep(10);
+	}
+
+	msleep(100);	/* > 0 ms */
+
+	if (cam_clock)
+		clk_enable(cam_clock);
+
+	msleep(1);	/* > 100 cycles */
+	gpio_direction_output(S3C64XX_GPF(3), 1);
+	msleep(25);	/* > 1 Mcycles */
+	s3c_gpio_cfgpin(S3C64XX_GPF(3), S3C64XX_GPF3_CAMIF_nRST);
+	msleep(25);	/* just to be sure > 1 Mcycles */
+
+	__raw_writel(__raw_readl(S3C64XX_NORMAL_CFG) |
+	    S3C64XX_NORMALCFG_DOMAIN_I_ON, S3C64XX_NORMAL_CFG);
+}
+
+void om_3d7k_camera_off(void)
+{
+	extern struct pcf50633 *om_3d7k_pcf;
+
+	gpio_direction_output(S3C64XX_GPF(3), 0);
+
+	msleep(1);	/* > 20 cycles */
+
+	if (cam_clock)
+		clk_disable(cam_clock);
+	msleep(1);	/* > 0 ms */
+
+	/* @@@ hack - WA */
+	pcf50633_reg_write(om_3d7k_pcf, 0x3a, 0x20);	/* 2V8, ... */
+	pcf50633_reg_write(om_3d7k_pcf, 0x30, 0x20);	/* ... then 1V5 */
+
+#if 0
+	__raw_writel(__raw_readl(S3C64XX_NORMAL_CFG) &
+	    ~S3C64XX_NORMALCFG_DOMAIN_I_ON, S3C64XX_NORMAL_CFG);
+#endif
+}
+
+
+/* @@@ - WA */
+#define s3c_camif_exclusive_open(inode, file) 0
+#define s3c_camif_exclusive_release(inode, file)
+
+int s3c_camif_open(struct file *file)
+{
+	int err;
+	camif_cfg_t *cfg =
+	    s3c_camif_get_fimc_object(MINOR(file->f_dentry->d_inode->i_rdev));
+
+	if (!cfg->cis) {
+		printk(KERN_ERR "An object for a CIS is missing\n");
+		printk(KERN_ERR
+		    "Using msdma_input as a default CIS data structure\n");
+		cfg->cis = &msdma_input;
+
+		/* global lock for both Codec and Preview */
+		sema_init(&cfg->cis->lock, 1);
+		cfg->cis->status |= P_NOT_WORKING;
+	}
+
+	if (cfg->dma_type & CAMIF_PREVIEW) {
+		if (cfg->dma_type & CAMIF_PREVIEW)
+			cfg->cis->status &= ~P_NOT_WORKING;
+
+		up(&cfg->cis->lock);
+	}
+
+	om_3d7k_camera_on();
+
+	err = s3c_camif_exclusive_open(inode, file);
+	cfg->cis->user++;
+	cfg->status = CAMIF_STOPPED;
+
+	if (err < 0)
+		return err;
+
+	if (file->f_flags & O_NONCAP) {
+		printk(KERN_ERR "Don't support non-capturing open\n");
+		return 0;
+	}
+
+	file->private_data = cfg;
+
+	s3c_camif_init_sensor(cfg);
+
+	return 0;
+}
+
+int s3c_camif_release(struct file *file)
+{
+	camif_cfg_t *cfg =
+	    s3c_camif_get_fimc_object(MINOR(file->f_dentry->d_inode->i_rdev));
+
+	if (cfg->dma_type & CAMIF_PREVIEW) {
+		cfg->cis->status &= ~PWANT2START;
+		cfg->cis->status |= P_NOT_WORKING;
+		s3c_camif_stop_preview(cfg);
+		up(&cfg->cis->lock);
+	} else {
+		cfg->cis->status &= ~CWANT2START;
+		s3c_camif_stop_capture(cfg);
+	}
+
+	s3c_camif_exclusive_release(inode, file);
+
+	if (cfg->cis->sensor == NULL)
+		DPRINTK("A CIS sensor for MSDMA has been used\n");
+	else
+		cfg->cis->sensor->driver->command(cfg->cis->sensor, USER_EXIT,
+		    NULL);
+
+	cfg->cis->user--;
+	cfg->status = CAMIF_STOPPED;
+
+	om_3d7k_camera_off();
+	cfg->cis->init_sensor = 0;
+
+	return 0;
+}
+
+ssize_t s3c_camif_read(struct file * file, char *buf, size_t count,
+    loff_t *pos)
+{
+	camif_cfg_t *cfg = NULL;
+	size_t end;
+
+	cfg = s3c_camif_get_fimc_object(MINOR(file->f_dentry->d_inode->i_rdev));
+
+#if defined(FSM_ON_PREVIEW)
+	if (cfg->dma_type == CAMIF_PREVIEW) {
+		if (wait_event_interruptible(cfg->waitq,
+		    cfg->status == CAMIF_INT_HAPPEN))
+			return -ERESTARTSYS;
+
+		cfg->status = CAMIF_STOPPED;
+	}
+#endif
+
+#if defined(FSM_ON_CODEC)
+	if (cfg->dma_type == CAMIF_CODEC) {
+		if (wait_event_interruptible(cfg->waitq,
+		    cfg->status == CAMIF_INT_HAPPEN))
+			return -ERESTARTSYS;
+
+		cfg->status = CAMIF_STOPPED;
+	}
+#endif
+	end = min_t(size_t, cfg->pp_totalsize / cfg->pp_num, count);
+
+	if (copy_to_user(buf, s3c_camif_get_frame(cfg), end))
+		return -EFAULT;
+
+	return end;
+}
+
+ssize_t s3c_camif_write(struct file * f, const char *b, size_t c,
+    loff_t *offset)
+{
+	camif_cfg_t *cfg;
+	int ret = 0;
+
+	cfg = s3c_camif_get_fimc_object(MINOR(f->f_dentry->d_inode->i_rdev));
+
+	switch (*b) {
+	case 'O':
+		if (cfg->dma_type & CAMIF_PREVIEW)
+			s3c_camif_start_preview(cfg);
+		else {
+			ret = s3c_camif_start_capture(cfg);
+
+			if (ret < 0)
+				ret = 1;
+		}
+
+		break;
+
+	case 'X':
+		if (cfg->dma_type & CAMIF_PREVIEW) {
+			s3c_camif_stop_preview(cfg);
+			cfg->cis->status |= P_NOT_WORKING;
+		} else {
+			cfg->cis->status &= ~C_WORKING;
+			s3c_camif_stop_capture(cfg);
+		}
+
+		break;
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+	case 'P':
+		if (cfg->dma_type & CAMIF_PREVIEW) {
+			s3c_camif_start_preview(cfg);
+			s3c_camif_do_postprocess(cfg);
+			return 0;
+		} else
+			return -EFAULT;
+#endif
+	default:
+		panic("s3c_camera_driver.c: s3c_camif_write() - "
+		    "Unexpected Parameter\n");
+	}
+
+	return ret;
+}
+
+int s3c_camif_mmap(struct file* filp, struct vm_area_struct *vma)
+{
+	camif_cfg_t *cfg = filp->private_data;
+
+	unsigned long pageFrameNo;
+	unsigned long size = vma->vm_end - vma->vm_start;
+	unsigned long total_size;
+
+	if (cfg->dma_type == CAMIF_PREVIEW)
+		total_size = RGB_MEM;
+	else
+		total_size = YUV_MEM;
+
+	/*
+	 * page frame number of the address for a source RGB frame to be stored
+	 * at.
+	 */
+	pageFrameNo = __phys_to_pfn(cfg->pp_phys_buf);
+
+	if (size > total_size) {
+		printk(KERN_ERR "The size of RGB_MEM mapping is too big\n");
+		return -EINVAL;
+	}
+
+	if ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED)) {
+		printk(KERN_ERR "Writable RGB_MEM mapping must be shared\n");
+		return -EINVAL;
+	}
+
+	if (remap_pfn_range(vma, vma->vm_start, pageFrameNo + vma->vm_pgoff,
+	    size, vma->vm_page_prot))
+		return -EINVAL;
+
+	return 0;
+}
+
+static unsigned int s3c_camif_poll(struct file *file, poll_table *wait)
+{
+	unsigned int mask = 0;
+	camif_cfg_t *cfg = file->private_data;
+
+	poll_wait(file, &cfg->waitq, wait);
+
+	if (cfg->status == CAMIF_INT_HAPPEN)
+		mask = POLLIN | POLLRDNORM;
+
+	cfg->status = CAMIF_STOPPED;
+
+	return mask;
+}
+
+struct v4l2_file_operations camif_c_fops = {
+	.owner = THIS_MODULE,
+	.open = s3c_camif_open,
+	.release = s3c_camif_release,
+	.ioctl = s3c_camif_ioctl,
+	.read = s3c_camif_read,
+	.write = s3c_camif_write,
+	.mmap = s3c_camif_mmap,
+	.poll = s3c_camif_poll,
+};
+
+struct v4l2_file_operations camif_p_fops = {
+	.owner = THIS_MODULE,
+	.open = s3c_camif_open,
+	.release = s3c_camif_release,
+	.ioctl = s3c_camif_ioctl,
+	.read = s3c_camif_read,
+	.write = s3c_camif_write,
+	.mmap = s3c_camif_mmap,
+	.poll = s3c_camif_poll,
+};
+
+/*************************************************************************
+ * Templates for V4L2
+ ************************************************************************/
+void camif_vdev_release (struct video_device *vdev) {
+	kfree(vdev);
+}
+
+struct video_device codec_template = {
+	.name = CODEC_DEV_NAME,
+#if 0
+	.type = VID_TYPE_OVERLAY | VID_TYPE_CAPTURE | VID_TYPE_CLIPPING | VID_TYPE_SCALES,
+	.type2 = V4L2_CAP_VIDEO_OVERLAY | V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING,
+	.hardware = VID_HARDWARE_SAMSUNG_FIMC3X,
+#endif
+	.fops = &camif_c_fops,
+	.release  = camif_vdev_release,
+	.minor = CODEC_MINOR,
+};
+
+struct video_device preview_template = {
+	.name = PREVIEW_DEV_NAME,
+#if 0
+	.type = VID_TYPE_OVERLAY | VID_TYPE_CAPTURE | VID_TYPE_CLIPPING | VID_TYPE_SCALES,
+	.type2 = V4L2_CAP_VIDEO_OVERLAY | V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING,
+	.hardware = VID_HARDWARE_SAMSUNG_FIMC3X,
+#endif
+	.fops = &camif_p_fops,
+	.release  = camif_vdev_release,
+	.minor = PREVIEW_MINOR,
+};
+
+/*************************************************************************
+ * Initialize part
+ ************************************************************************/
+void s3c_camif_init_sensor(camif_cfg_t *cfg)
+{
+	camif_cis_t *cis = cfg->cis;
+	camif_cis_t *initialized_cis;
+
+	if (!cis->sensor) {
+		initialized_cis = (camif_cis_t *) get_initialized_cis();
+
+		if (initialized_cis == NULL) {
+			printk(KERN_ERR "An I2C client for CIS sensor isn't registered\n");
+			return;
+		}
+
+		cis = cfg->cis = initialized_cis;
+		cfg->input_channel = 0;
+		cfg->cis->user++;
+	}
+
+	if (!cis->init_sensor) {
+		cis->sensor->driver->command(cis->sensor, SENSOR_INIT, NULL);
+		cis->init_sensor = 1;
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K3BA)
+		cis->sensor->driver->command(cis->sensor, SENSOR_VGA, NULL);
+	        cis->source_x = 640;
+	        cis->source_y = 480;
+#elif defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+		cis->sensor->driver->command(cis->sensor, SENSOR_SVGA, NULL);
+	        cis->source_x = 800;
+	        cis->source_y = 600;
+#endif
+	}
+
+	cis->sensor->driver->command(cis->sensor, USER_ADD, NULL);
+}
+
+static int s3c_camif_init_preview(camif_cfg_t * cfg)
+{
+	cfg->target_x = PREVIEW_DEFAULT_WIDTH;
+	cfg->target_y = PREVIEW_DEFAULT_WIDTH;
+	cfg->pp_num = PREVIEW_DEFAULT_PPNUM;
+	cfg->dma_type = CAMIF_PREVIEW;
+	cfg->input_channel = CAMERA_INPUT;
+	cfg->src_fmt = CAMIF_YCBCR422;
+	cfg->output_channel = CAMIF_OUT_PP;
+	cfg->dst_fmt = CAMIF_RGB16;
+	cfg->flip = CAMIF_FLIP_Y;
+	cfg->v = &preview_template;
+
+	/* @@@ - WA */
+	//init_MUTEX((struct semaphore *) &cfg->v->lock);
+	init_waitqueue_head(&cfg->waitq);
+
+	cfg->status = CAMIF_STOPPED;
+
+	/* To get the handle of CODEC */
+	cfg->other = s3c_camif_get_fimc_object(CODEC_MINOR);
+
+	return cfg->status;
+}
+
+static int s3c_camif_init_codec(camif_cfg_t * cfg)
+{
+	cfg->target_x = CODEC_DEFAULT_WIDTH;
+	cfg->target_y = CODEC_DEFAULT_HEIGHT;
+	cfg->pp_num = CODEC_DEFAULT_PPNUM;
+	cfg->dma_type = CAMIF_CODEC;
+	cfg->src_fmt = CAMIF_YCBCR422;
+	cfg->input_channel = CAMERA_INPUT;
+	cfg->dst_fmt = CAMIF_YCBCR420;
+	cfg->output_channel = CAMIF_OUT_PP;
+	cfg->flip = CAMIF_FLIP_X;
+	cfg->v = &codec_template;
+
+	/* @@@ - WA */
+	//init_MUTEX((struct semaphore *) &cfg->v->lock);
+
+	init_waitqueue_head(&cfg->waitq);
+
+	cfg->status = CAMIF_STOPPED;
+
+	/* To get the handle of PREVIEW */
+	cfg->other = s3c_camif_get_fimc_object(PREVIEW_MINOR);
+
+	return cfg->status;
+}
+
+static int s3c_camif_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	camif_cfg_t *codec, *preview;
+	struct clk *camif_clock;
+
+	/* Initialize fimc objects */
+	codec = s3c_camif_get_fimc_object(CODEC_MINOR);
+	preview = s3c_camif_get_fimc_object(PREVIEW_MINOR);
+
+	memset(codec, 0, sizeof(camif_cfg_t));
+	memset(preview, 0, sizeof(camif_cfg_t));
+
+	/* Set the fimc name */
+	strcpy(codec->shortname, CODEC_DEV_NAME);
+	strcpy(preview->shortname, PREVIEW_DEV_NAME);
+
+	/* get resource for io memory */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!res) {
+		printk("Failed to get io memory region resouce.\n");
+		return -1;
+	}
+
+	/* request mem region */
+	res = request_mem_region(res->start, res->end - res->start + 1,
+	    pdev->name);
+
+	if (!res) {
+		printk("Failed to request io memory region.\n");
+		return -1;
+	}
+
+	/* ioremap for register block */
+	codec->regs = preview->regs =
+	    ioremap(res->start, res->end - res->start + 1);
+
+	if (codec->regs == NULL) {
+		printk(KERN_ERR "Failed to remap register block\n");
+		return -1;
+	}
+
+	/* ioremap for reserved memory */
+	codec->pp_phys_buf = PHYS_OFFSET + (MEM_SIZE - RESERVED_MEM);
+	codec->pp_virt_buf = ioremap_nocache(codec->pp_phys_buf, YUV_MEM);
+
+	preview->pp_phys_buf =
+	    PHYS_OFFSET + (MEM_SIZE - RESERVED_MEM) + YUV_MEM;
+	preview->pp_virt_buf = ioremap_nocache(preview->pp_phys_buf, RGB_MEM);
+
+	camif_clock = clk_get(&pdev->dev, "camif");
+	if (IS_ERR(camif_clock)) {
+		dev_err(&pdev->dev,
+		    "Failed to find camera interface clock source\n");
+		return PTR_ERR(cam_clock);
+	}
+	clk_enable(camif_clock);
+
+	/* Device init */
+	s3c_camif_init();
+	s3c_camif_init_codec(codec);
+	s3c_camif_init_preview(preview);
+
+	/* Set irq */
+	codec->irq = platform_get_irq(pdev, FIMC_CODEC_INDEX);
+	preview->irq = platform_get_irq(pdev, FIMC_PREVIEW_INDEX);
+
+	s3c_camif_request_irq(codec);
+	s3c_camif_request_irq(preview);
+
+	/* Register to video device */
+	if (video_register_device(codec->v, VFL_TYPE_GRABBER, CODEC_MINOR) !=
+	    0) {
+		printk(KERN_ERR "Couldn't register this codec driver\n");
+		return -1;
+	}
+
+	if (video_register_device(preview->v, VFL_TYPE_GRABBER, PREVIEW_MINOR)
+	    != 0) {
+		printk(KERN_ERR "Couldn't register this preview driver\n");
+		return -1;
+	}
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+	cam_clock = clk_get(&pdev->dev, "camera");
+#elif defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2416) || defined(CONFIG_CPU_S3C2450)
+	cam_clock = clk_get(&pdev->dev, "camif-upll");
+#else
+#error	cam_clock should be defined
+#endif
+
+	if (IS_ERR(cam_clock)) {
+		printk("Failed to find camera clock source\n");
+		return PTR_ERR(cam_clock);
+	}
+
+	/* Print banner */
+	printk(KERN_INFO "S3C FIMC v%s\n", FIMC_VER);
+
+	return 0;
+}
+
+static int s3c_camif_remove(struct platform_device *pdev)
+{
+	camif_cfg_t *codec, *preview;
+
+	codec = s3c_camif_get_fimc_object(CODEC_MINOR);
+	preview = s3c_camif_get_fimc_object(PREVIEW_MINOR);
+
+	s3c_camif_release_irq(codec);
+	s3c_camif_release_irq(preview);
+
+	iounmap(codec->pp_virt_buf);
+	codec->pp_virt_buf = 0;
+
+	iounmap(preview->pp_virt_buf);
+	preview->pp_virt_buf = 0;
+
+	video_unregister_device(codec->v);
+	video_unregister_device(preview->v);
+
+	s3c_camif_set_priority(0);
+	clk_disable(cam_clock);
+
+	memset(codec, 0, sizeof(camif_cfg_t));
+	memset(preview, 0, sizeof(camif_cfg_t));
+
+	return 0;
+}
+
+static struct platform_driver s3c_camif_driver =
+{
+	.probe          = s3c_camif_probe,
+	.remove         = s3c_camif_remove,
+	.driver		= {
+		.name	= "s3c-camif",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int s3c_camif_register(void)
+{
+	platform_driver_register(&s3c_camif_driver);
+
+	return 0;
+}
+
+static void s3c_camif_unregister(void)
+{
+	platform_driver_unregister(&s3c_camif_driver);
+}
+
+void s3c_camif_open_sensor(camif_cis_t *cis)
+{
+	clk_set_rate(cam_clock, cis->camclk);
+	s3c_camif_reset(cis->reset_type, cis->reset_udelay);
+}
+
+void s3c_camif_register_sensor(struct i2c_client *ptr)
+{
+	camif_cfg_t *codec, *preview;
+	camif_cis_t *cis = i2c_get_clientdata(ptr);
+
+	codec = s3c_camif_get_fimc_object(CODEC_MINOR);
+	preview = s3c_camif_get_fimc_object(PREVIEW_MINOR);
+
+	codec->cis = preview->cis = cis;
+
+	sema_init(&codec->cis->lock, 1);
+	sema_init(&preview->cis->lock, 1);
+
+	preview->cis->status |= P_NOT_WORKING;	/* Default Value */
+
+	s3c_camif_set_polarity(preview);
+	s3c_camif_set_source_format(cis);
+	s3c_camif_set_priority(1);
+}
+
+void s3c_camif_unregister_sensor(struct i2c_client *ptr)
+{
+	camif_cis_t *cis;
+
+	cis = i2c_get_clientdata(ptr);
+	cis->init_sensor = 0;
+}
+
+module_init(s3c_camif_register);
+module_exit(s3c_camif_unregister);
+
+EXPORT_SYMBOL(s3c_camif_register_sensor);
+EXPORT_SYMBOL(s3c_camif_unregister_sensor);
+
+MODULE_AUTHOR("Jinsung Yang <jsgood.yang@samsung.com>");
+MODULE_DESCRIPTION("S3C Camera Driver for FIMC Interface");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/s3c_camif.c linux-2.6.29-rc3.owrt.om/drivers/media/video/s3c_camif.c
--- linux-2.6.29-rc3.owrt/drivers/media/video/s3c_camif.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/s3c_camif.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,1916 @@
+/* drivers/media/video/s3c_camif.c
+ *
+ * Copyright (c) 2008 Samsung Electronics
+ *
+ * Samsung S3C Camera driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/wait.h>
+#include <linux/videodev.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <asm/uaccess.h>
+#include <mach/map.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <plat/gpio-cfg.h>
+#include <plat/regs-camif.h>
+#include <plat/regs-gpio.h>
+#include <plat/gpio-bank-f.h>
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#include <asm/arch/regs-irq.h>
+#endif
+
+#include "s3c_camif.h"
+
+#define S3C_VIDW00ADD0B0 (S3C24XX_VA_LCD+0xa0)
+#define S3C_VIDW01ADD0B0 (S3C24XX_VA_LCD+0xa8)
+
+static unsigned int irq_old_priority;
+
+/*************************************************************************
+ * Utility part
+ ************************************************************************/
+int s3c_camif_get_frame_num(camif_cfg_t *cfg)
+{
+	int index = 0;
+
+	if (cfg->dma_type & CAMIF_CODEC)
+		index = (readl(cfg->regs + S3C_CICOSTATUS) >> 26) & 0x3;
+	else {
+		assert(cfg->dma_type & CAMIF_PREVIEW);
+		index = (readl(cfg->regs + S3C_CIPRSTATUS) >> 26) & 0x3;
+	}
+
+	cfg->cur_frame_num = (index + 2) % 4;    /* When 4 PingPong */
+
+	return 0;
+}
+
+unsigned char* s3c_camif_get_frame(camif_cfg_t *cfg)
+{
+	unsigned char *ret = NULL;
+	int cnt = cfg->cur_frame_num;
+
+	if (cfg->dma_type & CAMIF_PREVIEW)
+		ret = cfg->img_buf[cnt].virt_rgb;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		if ((cfg->dst_fmt & CAMIF_RGB16) ||
+		    (cfg->dst_fmt & CAMIF_RGB24))
+			ret = cfg->img_buf[cnt].virt_rgb;
+		else
+			ret = cfg->img_buf[cnt].virt_y;
+	}
+
+	return ret;
+}
+
+int s3c_camif_get_fifo_status(camif_cfg_t *cfg)
+{
+	unsigned int reg, val, flag;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		flag = S3C_CICOSTATUS_OVFIY_CO | S3C_CICOSTATUS_OVFICB_CO |
+		    S3C_CICOSTATUS_OVFICR_CO;
+		reg = readl(cfg->regs + S3C_CICOSTATUS);
+
+		if (reg & flag) {
+			/* FIFO Error Count ++  */
+			val = readl(cfg->regs + S3C_CIWDOFST);
+			val |= S3C_CIWDOFST_CLROVCOFIY |
+			    S3C_CIWDOFST_CLROVCOFICB | S3C_CIWDOFST_CLROVCOFICR;
+			writel(val, cfg->regs + S3C_CIWDOFST);
+
+			val = readl(cfg->regs + S3C_CIWDOFST);
+			val &= ~(S3C_CIWDOFST_CLROVCOFIY |
+			    S3C_CIWDOFST_CLROVCOFICB |
+			    S3C_CIWDOFST_CLROVCOFICR);
+			writel(val, cfg->regs + S3C_CIWDOFST);
+
+			return 1; /* Error */
+		}
+	} else if (cfg->dma_type & CAMIF_PREVIEW) {
+		flag = S3C_CIPRSTATUS_OVFICB_PR | S3C_CIPRSTATUS_OVFICR_PR;
+		reg = readl(cfg->regs + S3C_CIPRSTATUS);
+
+		if (reg & flag) {
+			/* FIFO Error Count ++  */
+			val = readl(cfg->regs + S3C_CIWDOFST);
+			val |= S3C_CIWDOFST_CLROVPRFICB |
+			    S3C_CIWDOFST_CLROVPRFICR;
+			writel(val, cfg->regs + S3C_CIWDOFST);
+
+			val = readl(cfg->regs + S3C_CIWDOFST);
+			val &= ~(S3C_CIWDOFST_CLROVPRFIY |
+			    S3C_CIWDOFST_CLROVPRFICB |
+			    S3C_CIWDOFST_CLROVPRFICR);
+			writel(val, cfg->regs + S3C_CIWDOFST);
+
+			return 1; /* Error */
+		}
+	}
+
+	return 0;
+}
+
+void s3c_camif_set_polarity(camif_cfg_t *cfg)
+{
+	camif_cis_t *cis = cfg->cis;
+	unsigned int val;
+	unsigned int cmd;
+
+	cmd = readl(cfg->regs + S3C_CIGCTRL);
+	cmd &= ~(0x7 << 24);
+
+	if (cis->polarity_pclk)
+		cmd |= S3C_CIGCTRL_INVPOLPCLK;
+
+	if (cis->polarity_vsync)
+		cmd |= S3C_CIGCTRL_INVPOLVSYNC;
+
+	if (cis->polarity_href)
+		cmd |= S3C_CIGCTRL_INVPOLHREF;
+
+	val = readl(cfg->regs + S3C_CIGCTRL);
+	val |= cmd;
+	writel(val, cfg->regs + S3C_CIGCTRL);
+}
+
+/*************************************************************************
+ * Memory part
+ ************************************************************************/
+static int s3c_camif_request_memory(camif_cfg_t *cfg)
+{
+	unsigned int t_size = 0, i = 0;
+	unsigned int area = 0;
+
+	area = cfg->target_x * cfg->target_y;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		if (cfg->dst_fmt & CAMIF_YCBCR420)
+			t_size = area * 3 / 2;		/* CAMIF_YCBCR420 */
+		else if (cfg->dst_fmt & CAMIF_YCBCR422 ||
+			 cfg->dst_fmt & CAMIF_YCBCR422I)
+			t_size = area * 2;		/* CAMIF_YCBCR422 */
+		else if (cfg->dst_fmt & CAMIF_RGB16)
+			t_size = area * 2;		/* 2 bytes per pixel */
+		else if (cfg->dst_fmt & CAMIF_RGB24)
+			t_size = area * 4;		/* 4 bytes per pixel */
+		else
+			printk(KERN_INFO "Invalid target format\n");
+	} else if (cfg->dma_type & CAMIF_PREVIEW) {
+
+		if (cfg->dst_fmt & CAMIF_RGB16)
+			t_size = area * 2;		/* 2 bytes per pixel */
+		else if (cfg->dst_fmt & CAMIF_RGB24)
+			t_size = area * 4;		/* 4 bytes per pixel */
+		else
+			printk(KERN_ERR "Invalid target format\n");
+
+	} else {
+		return 0;
+	}
+
+	if (t_size % PAGE_SIZE != 0) {
+		i = t_size / PAGE_SIZE;
+		t_size = (i + 1) * PAGE_SIZE;
+	}
+
+	t_size = t_size * cfg->pp_num;
+	cfg->pp_totalsize = t_size;
+
+	printk(KERN_INFO "%s memory required: 0x%08X bytes\n",
+	    cfg->dma_type & CAMIF_CODEC ? "Codec" : "Preview", t_size);
+
+	return 0;
+}
+
+static void s3c_camif_calc_burst_length_yuv422i(unsigned int hsize,
+    unsigned int *mburst, unsigned int *rburst)
+{
+	unsigned int tmp, wanted;
+
+	tmp = (hsize / 2) & 0xf;
+
+	switch (tmp) {
+	case 0:
+		wanted = 16;
+		break;
+
+	case 4:
+		wanted = 4;
+		break;
+
+	case 8:
+		wanted = 8;
+		break;
+
+	default:
+		wanted = 4;
+		break;
+	}
+
+	*mburst = wanted / 2;
+	*rburst = wanted / 2;
+}
+
+static void s3c_camif_calc_burst_length(unsigned int hsize,
+    unsigned int *mburst, unsigned int *rburst)
+{
+	unsigned int tmp;
+
+	tmp = (hsize / 4) & 0xf;
+
+	switch (tmp) {
+	case 0:
+		*mburst = 16;
+		*rburst = 16;
+		break;
+
+	case 4:
+		*mburst = 16;
+		*rburst = 4;
+		break;
+
+	case 8:
+		*mburst = 16;
+		*rburst = 8;
+		break;
+
+	default:
+		tmp = (hsize / 4) % 8;
+
+		if (tmp == 0) {
+			*mburst = 8;
+			*rburst = 8;
+		} else if (tmp == 4) {
+			*mburst = 8;
+			*rburst = 4;
+		} else {
+			tmp = (hsize / 4) % 4;
+			*mburst = 4;
+			*rburst = tmp ? tmp : 4;
+		}
+
+		break;
+	}
+}
+
+int s3c_camif_setup_dma(camif_cfg_t *cfg)
+{
+	int width = cfg->target_x;
+	unsigned int val, yburst_m, yburst_r, cburst_m, cburst_r;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		if (cfg->dst_fmt == CAMIF_RGB16 ||
+		    cfg->dst_fmt == CAMIF_RGB24) {
+			if (cfg->dst_fmt == CAMIF_RGB24) {
+				if (width % 2 != 0)
+					return BURST_ERR;
+
+				s3c_camif_calc_burst_length(width * 4,
+				    &yburst_m, &yburst_r);
+			} else {
+				if ((width / 2) % 2 != 0)
+					return BURST_ERR;
+
+				s3c_camif_calc_burst_length(width * 2,
+				    &yburst_m, &yburst_r);
+			}
+
+			val = readl(cfg->regs + S3C_CICOCTRL);
+			val &= ~(0xfffff << 4);
+
+			if (cfg->dst_fmt == CAMIF_RGB24) {
+				val = S3C_CICOCTRL_YBURST1_CO(yburst_m / 2) |
+				    S3C_CICOCTRL_YBURST2_CO(yburst_r / 4) |
+				    (4 << 9) | (2 << 4);
+			} else {
+				val = S3C_CICOCTRL_YBURST1_CO(yburst_m / 2) |
+				    S3C_CICOCTRL_YBURST2_CO(yburst_r / 2) |
+				    (4 << 9) | (2 << 4);
+			}
+
+			writel(val, cfg->regs + S3C_CICOCTRL);
+		} else {
+			/* CODEC DMA WIDHT is multiple of 16 */
+			if (width % 16 != 0)
+				return BURST_ERR;
+
+			if (cfg->dst_fmt == CAMIF_YCBCR422I) {
+				s3c_camif_calc_burst_length_yuv422i(width,
+				    &yburst_m, &yburst_r);
+				cburst_m = yburst_m / 2;
+				cburst_r = yburst_r / 2;
+			} else {
+				s3c_camif_calc_burst_length(width, &yburst_m,
+				    &yburst_r);
+				s3c_camif_calc_burst_length(width / 2,
+				    &cburst_m, &cburst_r);
+			}
+
+			val = readl(cfg->regs + S3C_CICOCTRL);
+			val &= ~(0xfffff << 4);
+			val |= S3C_CICOCTRL_YBURST1_CO(yburst_m) |
+			    S3C_CICOCTRL_CBURST1_CO(cburst_m) |
+			    S3C_CICOCTRL_YBURST2_CO(yburst_r) |
+			    S3C_CICOCTRL_CBURST2_CO(cburst_r);
+			writel(val, cfg->regs + S3C_CICOCTRL);
+		}
+	} else if (cfg->dma_type & CAMIF_PREVIEW) {
+		if (cfg->dst_fmt == CAMIF_RGB24) {
+			if (width % 2 != 0)
+				return BURST_ERR;
+
+			s3c_camif_calc_burst_length(width * 4, &yburst_m,
+			    &yburst_r);
+		} else {
+			if ((width / 2) % 2 != 0)
+				return BURST_ERR;
+
+			s3c_camif_calc_burst_length(width * 2, &yburst_m,
+			    &yburst_r);
+		}
+
+		val = readl(cfg->regs + S3C_CIPRCTRL);
+		val &= ~(0x3ff << 14);
+		val |= S3C_CICOCTRL_YBURST1_CO(yburst_m) |
+		    S3C_CICOCTRL_YBURST2_CO(yburst_r);
+		writel(val, cfg->regs + S3C_CIPRCTRL);
+	}
+
+	return 0;
+}
+
+/*************************************************************************
+ * Input path part
+ ************************************************************************/
+/*
+ * 2443 MSDMA (Preview Only)
+ */
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+int s3c_camif_input_msdma_preview(camif_cfg_t * cfg)
+{
+	unsigned int addr_start_Y, addr_start_CB, addr_start_CR;
+	unsigned int addr_end_Y, addr_end_CB, addr_end_CR;
+	unsigned int val, val_width;
+	unsigned area, div;
+
+	val = readl(cfg->regs + S3C_CIMSCTRL);
+	val &= ~(1 << 2);
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	val = readl(cfg->regs + S3C_CIMSCTRL);
+	val |= 1 << 2;
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	switch(cfg->src_fmt) {
+	case CAMIF_YCBCR420:
+	default:
+		val = readl(cfg->regs + S3C_CIMSCTRL);
+		val |= 0x1 << 1;
+		writel(val, cfg->regs + S3C_CIMSCTRL);
+
+		div = 4;
+		break;
+
+	case CAMIF_YCBCR422:
+	case CAMIF_YCBCR422I:
+		val = readl(cfg->regs + S3C_CIMSCTRL);
+		val = (val & ~(0x1 << 5)) | (0x1 << 5);	/* Interleave_MS */
+		val &= ~(0x1 << 1);
+		val &= ~(0x3 << 3);			/* YCbYCr */
+		writel(val, cfg->regs + S3C_CIMSCTRL);
+
+		div = 2;
+		break;
+	}
+
+	area = cfg->cis->source_x * cfg->cis->source_y;
+
+	addr_start_Y = readl(cfg->regs + S3C_CIMSYSA);
+	addr_start_CB = addr_start_Y + area;
+	addr_start_CR = addr_start_CB + area / div;
+
+	addr_end_Y = addr_start_Y + area;
+	addr_end_CB = addr_start_CB + area / div;
+	addr_end_CR = addr_start_CR + area / div;
+
+	/* MSDMA memory */
+	writel(addr_start_Y, cfg->regs + S3C_CIMSYSA);
+	writel(addr_start_CB, cfg->regs + S3C_CIMSCBSA);
+	writel(addr_start_CR, cfg->regs + S3C_CIMSCRSA);
+
+	writel(addr_end_Y, cfg->regs + S3C_CIMSYEND);
+	writel(addr_end_CB, cfg->regs + S3C_CIMSCBEND);
+	writel(addr_end_CR, cfg->regs + S3C_CIMSCREND);
+
+	/* MSDMA memory offset - default : 0 */
+	writel(0, cfg->regs + S3C_CIMSYOFF);
+	writel(0, cfg->regs + S3C_CIMSCBOFF);
+	writel(0, cfg->regs + S3C_CIMSCROFF);
+
+	/* MSDMA for codec source image width */
+	val_width = cfg->cis->source_x;		/* MSCOWIDTH */
+	writel(val_width, cfg->regs + S3C_CIMSWIDTH);
+
+	return 0;
+}
+
+static int s3c_camif_input_msdma(camif_cfg_t *cfg)
+{
+	if (cfg->input_channel == MSDMA_FROM_PREVIEW)
+		s3c_camif_input_msdma_preview(cfg);
+
+	return 0;
+}
+
+/*
+ * 6400 MSDMA (Preview & Codec)
+ */
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+int s3c_camif_input_msdma_codec(camif_cfg_t * cfg)
+{
+	u32 addr_start_Y, addr_start_CB, addr_start_CR;
+	u32 addr_end_Y, addr_end_CB, addr_end_CR;
+	u32 val, val_width;
+	unsigned area, div;
+
+	/* Codec path input data selection */
+	val = readl(cfg->regs + S3C_MSCOCTRL);
+	val &= ~(1 << 3);
+	writel(val, cfg->regs + S3C_MSCOCTRL);
+
+	val = readl(cfg->regs + S3C_MSCOCTRL);
+	val |= 1 << 3;
+	writel(val, cfg->regs + S3C_MSCOCTRL);
+
+	switch(cfg->src_fmt) {
+	case CAMIF_YCBCR420:
+	default:
+		val = readl(cfg->regs + S3C_MSCOCTRL);
+		val &= ~(0x3 << 1);
+		writel(val, cfg->regs + S3C_MSCOCTRL);
+
+		div = 4;
+		break;
+
+	case CAMIF_YCBCR422:
+	case CAMIF_YCBCR422I:
+		val = readl(cfg->regs + S3C_MSCOCTRL);
+		val = (val & ~(0x3 << 1)) | (0x2 << 1);
+		writel(val, cfg->regs + S3C_MSCOCTRL);
+
+		div = 2;
+		break;
+	}
+
+	area = cfg->cis->source_x * cfg->cis->source_y;
+
+	addr_start_Y = cfg->pp_phys_buf;
+	addr_start_CB = addr_start_Y + area;
+	addr_start_CR = addr_start_CB + area / div;
+
+	addr_end_Y = addr_start_Y + area;
+	addr_end_CB = addr_start_CB + area / div;
+	addr_end_CR = addr_start_CR + area / div;
+
+	/* MSDMA memory */
+	writel(addr_start_Y, cfg->regs + S3C_MSCOY0SA);
+	writel(addr_start_CB, cfg->regs + S3C_MSCOCB0SA);
+	writel(addr_start_CR, cfg->regs + S3C_MSCOCR0SA);
+
+	writel(addr_end_Y, cfg->regs + S3C_MSCOY0END);
+	writel(addr_end_CB, cfg->regs + S3C_MSCOCB0END);
+	writel(addr_end_CR, cfg->regs + S3C_MSCOCR0END);
+
+	/* MSDMA memory offset */
+	writel(0, cfg->regs + S3C_MSCOYOFF);
+	writel(0, cfg->regs + S3C_MSCOCBOFF);
+	writel(0, cfg->regs + S3C_MSCOCROFF);
+
+	/* MSDMA for codec source image width */
+	val_width = readl(cfg->regs + S3C_MSCOWIDTH);
+	val_width &= ~0x0fffffff;
+	val_width |= 0x1 << 31;				/* AutoLoadEnable */
+	val_width |= cfg->cis->source_y << 16;		/* MSCOHEIGHT */
+	val_width |= cfg->cis->source_x;		/* MSCOWIDTH */
+	writel(val_width, cfg->regs + S3C_MSCOWIDTH);
+
+	return 0;
+}
+
+int s3c_camif_input_msdma_preview(camif_cfg_t * cfg)
+{
+	int ret = 0;
+	unsigned int addr_start_Y, addr_start_CB, addr_start_CR;
+	unsigned int addr_end_Y, addr_end_CB, addr_end_CR;
+	unsigned int val, val_width;
+	unsigned area, div;
+
+	val = readl(cfg->regs + S3C_CIMSCTRL);
+	val &= ~(0x1 << 3);
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	val = readl(cfg->regs + S3C_CIMSCTRL);
+	val |= 0x1 << 3;
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	switch(cfg->src_fmt) {
+	case CAMIF_YCBCR420:
+	default:
+		val = readl(cfg->regs + S3C_CIMSCTRL);
+		val &= ~(0x3 << 1);
+		writel(val, cfg->regs + S3C_CIMSCTRL);
+
+		div = 4;
+		break;
+
+	case CAMIF_YCBCR422:
+	case CAMIF_YCBCR422I:
+		val = readl(cfg->regs + S3C_CIMSCTRL);
+		val = (val & ~(0x3 << 1)) | (0x2 << 1);	/* YCbCr 422 Interleave */
+		val = (val & ~(0x3 << 4)) | (0x3 << 4);	/* YCbYCr */
+		writel(val, cfg->regs + S3C_CIMSCTRL);
+
+		div = 2;
+		break;
+	}
+
+	area = cfg->cis->source_x * cfg->cis->source_y;
+
+	addr_start_Y = readl(cfg->regs + S3C_MSPRY0SA);
+	addr_start_CB = addr_start_Y + area;
+	addr_start_CR = addr_start_CB + area / div;
+
+	addr_end_Y = addr_start_Y + area;
+	addr_end_CB = addr_start_CB + area / div;
+	addr_end_CR = addr_start_CR + area / div;
+
+	/* MSDMA memory */
+	writel(addr_start_Y, cfg->regs + S3C_MSPRY0SA);
+	writel(addr_start_CB, cfg->regs + S3C_MSPRCB0SA);
+	writel(addr_start_CR, cfg->regs + S3C_MSPRCR0SA);
+
+	writel(addr_end_Y, cfg->regs + S3C_MSPRY0END);
+	writel(addr_end_CB, cfg->regs + S3C_MSPRCB0END);
+	writel(addr_end_CR, cfg->regs + S3C_MSPRCR0END);
+
+	/* MSDMA memory offset */
+	writel(0, cfg->regs + S3C_MSPRYOFF);
+	writel(0, cfg->regs + S3C_MSPRCBOFF);
+	writel(0, cfg->regs + S3C_MSPRCROFF);
+
+	/* MSDMA for codec source image width */
+	val_width = readl(cfg->regs + S3C_MSPRWIDTH);
+	val_width &= ~(0x1 << 31);			/* AutoLoadEnable */
+	val_width &= ~0x0fffffff;
+	val_width |= cfg->cis->source_y << 16;		/* MSCOHEIGHT */
+	val_width |= cfg->cis->source_x;		/* MSCOWIDTH */
+	writel(val_width, cfg->regs + S3C_MSPRWIDTH);
+
+	return ret;
+}
+
+static int s3c_camif_input_msdma(camif_cfg_t *cfg)
+{
+	if (cfg->input_channel == MSDMA_FROM_PREVIEW)
+		s3c_camif_input_msdma_preview(cfg);
+	else if (cfg->input_channel == MSDMA_FROM_CODEC)
+		s3c_camif_input_msdma_codec(cfg);
+
+	return 0;
+}
+#endif
+
+static int s3c_camif_input_camera(camif_cfg_t *cfg)
+{
+	unsigned int val;
+
+	s3c_camif_set_offset(cfg->cis);
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+		val = readl(cfg->regs + S3C_MSCOCTRL);
+		val &= ~(1 << 3);
+		writel(val, cfg->regs + S3C_MSCOCTRL);
+#endif
+	} else if (cfg->dma_type & CAMIF_PREVIEW) {
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450)
+		val = readl(cfg->regs + S3C_CIMSCTRL);
+		val &= ~(1 << 2);
+		writel(val, cfg->regs + S3C_CIMSCTRL);
+#elif defined(CONFIG_CPU_S3C6400)
+		val = readl(cfg->regs + S3C_CIMSCTRL);
+		val &= ~(1 << 3);
+		writel(val, cfg->regs + S3C_CIMSCTRL);
+#endif
+	} else
+		printk(KERN_ERR "Invalid DMA type\n");
+
+	return 0;
+}
+
+static int s3c_camif_setup_input_path(camif_cfg_t *cfg)
+{
+	if (cfg->input_channel == CAMERA_INPUT)
+		s3c_camif_input_camera(cfg);
+	else
+		s3c_camif_input_msdma(cfg);
+
+	return 0;
+}
+
+/*************************************************************************
+ * Output path part
+ ************************************************************************/
+static int s3c_camif_output_pp_codec_rgb(camif_cfg_t *cfg)
+{
+	int i;
+	unsigned int val;
+	unsigned int area = cfg->target_x * cfg->target_y;
+
+	if (cfg->dst_fmt & CAMIF_RGB24)
+		area = area * 4;
+	else {
+		assert (cfg->dst_fmt & CAMIF_RGB16);
+		area = area * 2;
+	}
+
+	if ((area % PAGE_SIZE) != 0) {
+		i = area / PAGE_SIZE;
+		area = (i + 1) * PAGE_SIZE;
+	}
+
+	cfg->buffer_size = area;
+
+	if (cfg->input_channel == MSDMA_FROM_CODEC) {
+{
+void __iomem *S3C24XX_VA_LCD = ioremap(S3C64XX_PA_FB, 1024*1024);
+		val = readl(S3C_VIDW00ADD0B0);
+}
+
+		for (i = 0; i < 4; i++)
+			writel(val, cfg->regs + S3C_CICOYSA(i));
+	} else {
+		switch ( cfg->pp_num ) {
+		case 1:
+			for (i = 0; i < 4; i++) {
+				cfg->img_buf[i].virt_rgb = cfg->pp_virt_buf;
+				cfg->img_buf[i].phys_rgb = cfg->pp_phys_buf;
+				writel(cfg->img_buf[i].phys_rgb,
+				    cfg->regs + S3C_CICOYSA(i));
+			}
+
+			break;
+
+		case 2:
+			for (i = 0; i < 4; i++) {
+				cfg->img_buf[i].virt_rgb = cfg->pp_virt_buf;
+				cfg->img_buf[i].phys_rgb = cfg->pp_phys_buf;
+				if (i & 1) {
+					cfg->img_buf[i].virt_rgb += area;
+					cfg->img_buf[i].phys_rgb += area;
+				}
+				writel(cfg->img_buf[i].phys_rgb,
+				    cfg->regs + S3C_CICOYSA(i));
+			}
+
+			break;
+
+		case 4:
+			for (i = 0; i < 4; i++) {
+				cfg->img_buf[i].virt_rgb =
+				    cfg->pp_virt_buf + i * area;
+				cfg->img_buf[i].phys_rgb =
+				    cfg->pp_phys_buf + i * area;
+				writel(cfg->img_buf[i].phys_rgb,
+				    cfg->regs + S3C_CICOYSA(i));
+			}
+
+			break;
+
+		default:
+			printk(KERN_ERR "Invalid pingpong number %d\n",
+			    cfg->pp_num);
+			panic("s3c camif halt\n");
+		}
+	}
+
+	return 0;
+}
+
+static int s3c_camif_output_pp_codec(camif_cfg_t *cfg)
+{
+	unsigned int i, cbcr_size = 0;
+	unsigned int area = cfg->target_x * cfg->target_y;
+	unsigned int one_p_size;
+
+	area = cfg->target_x * cfg->target_y;
+
+	if (cfg->dst_fmt & CAMIF_YCBCR420)
+		cbcr_size = area / 4;
+	else if (cfg->dst_fmt & CAMIF_YCBCR422 ||
+		 cfg->dst_fmt & CAMIF_YCBCR422I)
+		cbcr_size = area / 2;
+	else if ((cfg->dst_fmt & CAMIF_RGB16) || (cfg->dst_fmt & CAMIF_RGB24)) {
+		s3c_camif_output_pp_codec_rgb(cfg);
+		return 0;
+	} else
+		printk(KERN_ERR "Invalid target format %d\n", cfg->dst_fmt);
+
+	one_p_size = area + 2 * cbcr_size;
+
+	if ((one_p_size % PAGE_SIZE) != 0) {
+		i = one_p_size / PAGE_SIZE;
+		one_p_size = (i + 1) * PAGE_SIZE;
+	}
+
+	cfg->buffer_size = one_p_size;
+
+	switch (cfg->pp_num) {
+	case 1 :
+		for (i = 0; i < 4; i++) {
+			cfg->img_buf[i].virt_y = cfg->pp_virt_buf;
+			cfg->img_buf[i].phys_y = cfg->pp_phys_buf;
+			cfg->img_buf[i].virt_cb = cfg->pp_virt_buf + area;
+			cfg->img_buf[i].phys_cb = cfg->pp_phys_buf + area;
+			cfg->img_buf[i].virt_cr = cfg->pp_virt_buf + area + cbcr_size;
+			cfg->img_buf[i].phys_cr = cfg->pp_phys_buf + area + cbcr_size;
+			writel(cfg->img_buf[i].phys_y, cfg->regs + S3C_CICOYSA(i));
+			writel(cfg->img_buf[i].phys_cb, cfg->regs + S3C_CICOCBSA(i));
+			writel(cfg->img_buf[i].phys_cr, cfg->regs + S3C_CICOCRSA(i));
+		}
+
+		break;
+
+	case 2:
+		for (i = 0; i < 4; i++) {
+			cfg->img_buf[i].virt_y = cfg->pp_virt_buf;
+			cfg->img_buf[i].phys_y = cfg->pp_phys_buf;
+			cfg->img_buf[i].virt_cb = cfg->pp_virt_buf + area;
+			cfg->img_buf[i].phys_cb = cfg->pp_phys_buf + area;
+			cfg->img_buf[i].virt_cr =
+			    cfg->pp_virt_buf + area + cbcr_size;
+			cfg->img_buf[i].phys_cr =
+			    cfg->pp_phys_buf + area + cbcr_size;
+
+			if (i & 1) {
+				cfg->img_buf[i].virt_y += one_p_size;
+				cfg->img_buf[i].phys_y += one_p_size;
+				cfg->img_buf[i].virt_cb += one_p_size;
+				cfg->img_buf[i].phys_cb += one_p_size;
+				cfg->img_buf[i].virt_cr += one_p_size;
+				cfg->img_buf[i].phys_cr += one_p_size;
+			}
+
+			writel(cfg->img_buf[i].phys_y,
+			    cfg->regs + S3C_CICOYSA(i));
+			writel(cfg->img_buf[i].phys_cb,
+			    cfg->regs + S3C_CICOCBSA(i));
+			writel(cfg->img_buf[i].phys_cr,
+			    cfg->regs + S3C_CICOCRSA(i));
+		}
+
+		break;
+
+	case 4:
+		for (i = 0; i < 4; i++) {
+			cfg->img_buf[i].virt_y =
+			    cfg->pp_virt_buf + i * one_p_size;
+			cfg->img_buf[i].phys_y =
+			    cfg->pp_phys_buf + i * one_p_size;
+			cfg->img_buf[i].virt_cb =
+			    cfg->pp_virt_buf + area + i * one_p_size;
+			cfg->img_buf[i].phys_cb =
+			    cfg->pp_phys_buf + area + i * one_p_size;
+			cfg->img_buf[i].virt_cr = cfg->pp_virt_buf +
+			    area + cbcr_size + i * one_p_size;
+			cfg->img_buf[i].phys_cr = cfg->pp_phys_buf +
+			    area + cbcr_size + i * one_p_size;
+			writel(cfg->img_buf[i].phys_y,
+			    cfg->regs + S3C_CICOYSA(i));
+			writel(cfg->img_buf[i].phys_cb,
+			    cfg->regs + S3C_CICOCBSA(i));
+			writel(cfg->img_buf[i].phys_cr,
+			    cfg->regs + S3C_CICOCRSA(i));
+		}
+
+		break;
+
+	default:
+		printk(KERN_ERR "Invalid pingpong number %d\n", cfg->pp_num);
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+static int s3c_camif_io_duplex_preview(camif_cfg_t *cfg)
+{
+	unsigned int cbcr_size = 0;
+	unsigned int area = cfg->cis->source_x * cfg->cis->source_y;
+	unsigned int val;
+	int i;
+
+	val = readl(S3C_VIDW01ADD0);
+
+	if (!((cfg->dst_fmt & CAMIF_RGB16) || (cfg->dst_fmt & CAMIF_RGB24)))
+		printk(KERN_ERR "Invalid target format\n");
+
+	for (i = 0; i < 4; i++)
+		writel(val, cfg->regs + S3C_CIPRYSA(i));
+
+	if (cfg->src_fmt & CAMIF_YCBCR420) {
+		cbcr_size = area / 4;
+		cfg->img_buf[0].virt_cb = cfg->pp_virt_buf + area;
+		cfg->img_buf[0].phys_cb = cfg->pp_phys_buf + area;
+		cfg->img_buf[0].virt_cr = cfg->pp_virt_buf + area + cbcr_size;
+		cfg->img_buf[0].phys_cr = cfg->pp_phys_buf + area + cbcr_size;
+	} else if (cfg->src_fmt & CAMIF_YCBCR422 || cfg->dst_fmt & CAMIF_YCBCR422I) {
+		area = area * 2;
+		cfg->img_buf[0].virt_cb = 0;
+		cfg->img_buf[0].phys_cb = 0;
+		cfg->img_buf[0].virt_cr = 0;
+		cfg->img_buf[0].phys_cr = 0;
+	}
+
+	cfg->img_buf[0].virt_y = cfg->pp_virt_buf;
+	cfg->img_buf[0].phys_y = cfg->pp_phys_buf;
+
+	writel(cfg->img_buf[0].phys_y, cfg->regs + S3C_CIMSYSA);
+	writel(cfg->img_buf[0].phys_y + area, cfg->regs + S3C_CIMSYEND);
+
+	writel(cfg->img_buf[0].phys_cb, cfg->regs + S3C_CIMSCBSA);
+	writel(cfg->img_buf[0].phys_cb + cbcr_size, cfg->regs + S3C_CIMSCBEND);
+
+	writel(cfg->img_buf[0].phys_cr, cfg->regs + S3C_CIMSCRSA);
+	writel(cfg->img_buf[0].phys_cr + cbcr_size, cfg->regs + S3C_CIMSCREND);
+
+	writel(cfg->cis->source_x, cfg->regs + S3C_CIMSWIDTH);
+
+	return 0;
+}
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+static int s3c_camif_io_duplex_preview(camif_cfg_t *cfg)
+{
+	unsigned int cbcr_size = 0;
+	unsigned int area = cfg->cis->source_x * cfg->cis->source_y;
+	unsigned int val;
+	int i;
+
+{
+void __iomem *S3C24XX_VA_LCD = ioremap(S3C64XX_PA_FB, 1024*1024);
+	val = readl(S3C_VIDW01ADD0B0);
+}
+
+	if (!((cfg->dst_fmt & CAMIF_RGB16) || (cfg->dst_fmt & CAMIF_RGB24)))
+		printk(KERN_ERR "Invalid target format\n");
+
+	for (i = 0; i < 4; i++)
+		writel(val, cfg->regs + S3C_CIPRYSA(i));
+
+	if (cfg->src_fmt & CAMIF_YCBCR420) {
+		cbcr_size = area / 4;
+		cfg->img_buf[0].virt_cb = cfg->pp_virt_buf + area;
+		cfg->img_buf[0].phys_cb = cfg->pp_phys_buf + area;
+		cfg->img_buf[0].virt_cr = cfg->pp_virt_buf + area + cbcr_size;
+		cfg->img_buf[0].phys_cr = cfg->pp_phys_buf + area + cbcr_size;
+	} else if (cfg->src_fmt & CAMIF_YCBCR422 ||
+		   cfg->dst_fmt & CAMIF_YCBCR422I) {
+		area = area * 2;
+		cfg->img_buf[0].virt_cb = 0;
+		cfg->img_buf[0].phys_cb = 0;
+		cfg->img_buf[0].virt_cr = 0;
+		cfg->img_buf[0].phys_cr = 0;
+	}
+
+	cfg->img_buf[0].virt_y = cfg->pp_virt_buf;
+	cfg->img_buf[0].phys_y = cfg->pp_phys_buf;
+
+	writel(cfg->img_buf[0].phys_y, cfg->regs + S3C_MSPRY0SA);
+	writel(cfg->img_buf[0].phys_y + area, cfg->regs + S3C_MSPRY0END);
+
+	writel(cfg->img_buf[0].phys_cb, cfg->regs + S3C_MSPRCB0SA);
+	writel(cfg->img_buf[0].phys_cb + cbcr_size, cfg->regs + S3C_MSPRCB0END);
+
+	writel(cfg->img_buf[0].phys_cr, cfg->regs + S3C_MSPRCR0SA);
+	writel(cfg->img_buf[0].phys_cr + cbcr_size, cfg->regs + S3C_MSPRCR0END);
+
+	val = readl(cfg->regs + S3C_MSCOWIDTH);
+	val |= 0x1 << 31;
+	val |= cfg->cis->source_y << 16;
+	val |= cfg->cis->source_x;
+	writel(val, cfg->regs + S3C_MSPRWIDTH);
+
+	return 0;
+}
+#endif
+
+static int s3c_camif_output_pp_preview(camif_cfg_t *cfg)
+{
+	int i;
+	unsigned int cbcr_size = 0;
+	unsigned int area = cfg->target_x * cfg->target_y;
+
+	if (cfg->input_channel) {
+		s3c_camif_io_duplex_preview(cfg);
+		return 0;
+	}
+
+	if (cfg->dst_fmt & CAMIF_YCBCR420)
+		cbcr_size = area / 4;
+	else if (cfg->dst_fmt & CAMIF_YCBCR422 ||
+		 cfg->dst_fmt & CAMIF_YCBCR422I)
+		cbcr_size = area / 2;
+	else if (cfg->dst_fmt & CAMIF_RGB24)
+		area = area * 4;
+	else if (cfg->dst_fmt & CAMIF_RGB16)
+		area = area * 2;
+	else
+		printk(KERN_ERR "Invalid target format %d\n", cfg->dst_fmt);
+
+	if ((area % PAGE_SIZE) != 0) {
+		i = area / PAGE_SIZE;
+		area = (i + 1) * PAGE_SIZE;
+	}
+
+	cfg->buffer_size = area;
+
+	switch (cfg->pp_num) {
+	case 1:
+		for (i = 0; i < 4; i++) {
+			cfg->img_buf[i].virt_rgb = cfg->pp_virt_buf;
+			cfg->img_buf[i].phys_rgb = cfg->pp_phys_buf;
+			writel(cfg->img_buf[i].phys_rgb,
+			    cfg->regs + S3C_CIPRYSA(i));
+		}
+
+		break;
+
+	case 2:
+		for (i = 0; i < 4; i++) {
+			cfg->img_buf[i].virt_rgb = cfg->pp_virt_buf;
+			cfg->img_buf[i].phys_rgb = cfg->pp_phys_buf;
+			if (i & 1) {
+				cfg->img_buf[i].virt_rgb += area;
+				cfg->img_buf[i].phys_rgb += area;
+			}
+
+			writel(cfg->img_buf[i].phys_rgb,
+			    cfg->regs + S3C_CIPRYSA(i));
+		}
+
+		break;
+
+	case 4:
+		for (i = 0; i < 4; i++) {
+			cfg->img_buf[i].virt_rgb = cfg->pp_virt_buf + i * area;
+			cfg->img_buf[i].phys_rgb = cfg->pp_phys_buf + i * area;
+			writel(cfg->img_buf[i].phys_rgb,
+			    cfg->regs + S3C_CIPRYSA(i));
+		}
+
+		break;
+
+	default:
+		printk(KERN_ERR "Invalid pingpong number %d\n", cfg->pp_num);
+	}
+
+	return 0;
+}
+
+static int s3c_camif_output_pp(camif_cfg_t *cfg)
+{
+	if (cfg->dma_type & CAMIF_CODEC)
+		s3c_camif_output_pp_codec(cfg);
+	else if (cfg->dma_type & CAMIF_PREVIEW)
+		s3c_camif_output_pp_preview(cfg);
+
+	return 0;
+}
+
+static int s3c_camif_output_lcd(camif_cfg_t *cfg)
+{
+	/* To Be Implemented */
+	return 0;
+}
+
+static int s3c_camif_setup_output_path(camif_cfg_t *cfg)
+{
+	if (cfg->output_channel == CAMIF_OUT_FIFO)
+		s3c_camif_output_lcd(cfg);
+	else
+		s3c_camif_output_pp(cfg);
+
+	return 0;
+}
+
+/*************************************************************************
+ * Scaler part
+ ************************************************************************/
+static int s3c_camif_set_target_area(camif_cfg_t *cfg)
+{
+	unsigned int rect = cfg->target_x * cfg->target_y;
+
+	if (cfg->dma_type & CAMIF_CODEC)
+		writel(rect, cfg->regs + S3C_CICOTAREA);
+	else if (cfg->dma_type & CAMIF_PREVIEW)
+		writel(rect, cfg->regs + S3C_CIPRTAREA);
+
+	return 0;
+}
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+static inline int s3c_camif_set_ratio(camif_cfg_t *cfg)
+{
+	unsigned int cmd =
+	    S3C_CICOSCCTRL_CSCR2Y_WIDE | S3C_CICOSCCTRL_CSCY2R_WIDE;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+
+		writel(S3C_CICOSCPRERATIO_SHFACTOR_CO(cfg->sc.shfactor) |
+		    S3C_CICOSCPRERATIO_PREHORRATIO_CO(cfg->sc.prehratio) |
+		    S3C_CICOSCPRERATIO_PREVERRATIO_CO(cfg->sc.prevratio),
+		    cfg->regs + S3C_CICOSCPRERATIO);
+
+		writel(S3C_CICOSCPREDST_PREDSTWIDTH_CO(cfg->sc.predst_x) |
+		    S3C_CICOSCPREDST_PREDSTHEIGHT_CO(cfg->sc.predst_y),
+		    cfg->regs + S3C_CICOSCPREDST);
+
+		/* Differ from Preview */
+		if (cfg->sc.scalerbypass)
+			cmd |= S3C_CICOSCCTRL_SCALERBYPASS_CO;
+
+		/* Differ from Codec */
+		if (cfg->dst_fmt & CAMIF_RGB24)
+			cmd |= S3C_CICOSCCTRL_OUTRGB_FMT_RGB888;
+		else
+			cmd |= S3C_CICOSCCTRL_OUTRGB_FMT_RGB565;
+
+		if (cfg->sc.scaleup_h & cfg->sc.scaleup_v)
+			cmd |=
+			    S3C_CICOSCCTRL_SCALEUP_H | S3C_CICOSCCTRL_SCALEUP_V;
+
+		writel(cmd |
+		    S3C_CICOSCCTRL_MAINHORRATIO_CO(cfg->sc.mainhratio) |
+		    S3C_CICOSCCTRL_MAINVERRATIO_CO(cfg->sc.mainvratio),
+		    cfg->regs + S3C_CICOSCCTRL);
+
+	} else if (cfg->dma_type & CAMIF_PREVIEW) {
+		writel(S3C_CIPRSCPRERATIO_SHFACTOR_PR(cfg->sc.shfactor) |
+		    S3C_CIPRSCPRERATIO_PREHORRATIO_PR(cfg->sc.prehratio) |
+		    S3C_CIPRSCPRERATIO_PREVERRATIO_PR(cfg->sc.prevratio),
+		    cfg->regs + S3C_CIPRSCPRERATIO);
+
+		writel(S3C_CIPRSCPREDST_PREDSTWIDTH_PR(cfg->sc.predst_x) |
+		    S3C_CIPRSCPREDST_PREDSTHEIGHT_PR(cfg->sc.predst_y),
+		    cfg->regs + S3C_CIPRSCPREDST);
+
+		if (cfg->dst_fmt & CAMIF_RGB24)
+			cmd |= S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB888;
+		else
+			cmd |= S3C_CIPRSCCTRL_OUTRGB_FMT_PR_RGB565;
+
+		if (cfg->sc.scaleup_h & cfg->sc.scaleup_v)
+			cmd |= (1 << 30) | (1 << 29);
+
+		writel(cmd |
+		    S3C_CIPRSCCTRL_MAINHORRATIO_PR(cfg->sc.mainhratio) |
+		    S3C_CIPRSCCTRL_MAINVERRATIO_PR(cfg->sc.mainvratio),
+		    cfg->regs + S3C_CIPRSCCTRL);
+
+	} else
+		printk(KERN_ERR "Invalid DMA type\n");
+
+	return 0;
+}
+#elif defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+static inline int s3c_camif_set_ratio(camif_cfg_t *cfg)
+{
+	u32 cmd = 0;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+
+		writel(S3C_CICOSCPRERATIO_SHFACTOR_CO(cfg->sc.shfactor) |
+		    S3C_CICOSCPRERATIO_PREHORRATIO_CO(cfg->sc.prehratio) |
+		    S3C_CICOSCPRERATIO_PREVERRATIO_CO(cfg->sc.prevratio),
+		    cfg->regs + S3C_CICOSCPRERATIO);
+
+		writel(S3C_CICOSCPREDST_PREDSTWIDTH_CO(cfg->sc.predst_x) |
+		    S3C_CICOSCPREDST_PREDSTHEIGHT_CO(cfg->sc.predst_y),
+		    cfg->regs + S3C_CICOSCPREDST);
+
+		if (cfg->sc.scalerbypass)
+			cmd |= S3C_CICOSCCTRL_SCALERBYPASS_CO;
+
+		if (cfg->sc.scaleup_h & cfg->sc.scaleup_v)
+			cmd |=
+			    S3C_CICOSCCTRL_SCALEUP_H | S3C_CICOSCCTRL_SCALEUP_V;
+
+		writel(cmd |
+		    S3C_CICOSCCTRL_MAINHORRATIO_CO(cfg->sc.mainhratio) |
+		    S3C_CICOSCCTRL_MAINVERRATIO_CO(cfg->sc.mainvratio),
+		    cfg->regs + S3C_CICOSCCTRL);
+
+	} else if (cfg->dma_type & CAMIF_PREVIEW) {
+
+		cmd |= S3C_CIPRSCCTRL_SAMPLE_PR;
+
+		writel(S3C_CIPRSCPRERATIO_SHFACTOR_PR(cfg->sc.shfactor) |
+		    S3C_CIPRSCPRERATIO_PREHORRATIO_PR(cfg->sc.prehratio) |
+		    S3C_CIPRSCPRERATIO_PREVERRATIO_PR(cfg->sc.prevratio),
+		    cfg->regs + S3C_CIPRSCPRERATIO);
+
+		writel(S3C_CIPRSCPREDST_PREDSTWIDTH_PR(cfg->sc.predst_x) |
+		    S3C_CIPRSCPREDST_PREDSTHEIGHT_PR(cfg->sc.predst_y),
+		    cfg->regs + S3C_CIPRSCPREDST);
+
+		if (cfg->dst_fmt & CAMIF_RGB24)
+			cmd |= S3C_CIPRSCCTRL_RGBFORMAT_24;
+
+		if (cfg->sc.scaleup_h & cfg->sc.scaleup_v)
+			cmd |= (1 << 29) | (1 << 28);
+
+		writel(cmd |
+		    S3C_CIPRSCCTRL_MAINHORRATIO_PR(cfg->sc.mainhratio) |
+		    S3C_CIPRSCCTRL_MAINVERRATIO_PR(cfg->sc.mainvratio),
+		    cfg->regs + S3C_CIPRSCCTRL);
+
+	} else
+		printk(KERN_ERR "Invalid DMA type\n");
+
+	return 0;
+}
+#endif
+
+static int s3c_camif_calc_ratio(unsigned int src_width, unsigned int dst_width,
+    unsigned int *ratio, unsigned int *shift)
+{
+	if (src_width >= 64 * dst_width) {
+		printk(KERN_ERR "Out of pre-scaler range: "
+		    "src_width / dst_width = %d (< 64)\n",
+		    src_width / dst_width);
+		return 1;
+	}
+	if (src_width >= 32 * dst_width) {
+		*shift = 5;
+	} else if (src_width >= 16 * dst_width) {
+		*shift = 4;
+	} else if (src_width >= 8 * dst_width) {
+		*shift = 3;
+	} else if (src_width >= 4 * dst_width) {
+		*shift = 2;
+	} else if (src_width >= 2 * dst_width) {
+		*shift = 1;
+	} else {
+		*shift = 0;
+	}
+
+	*ratio = 1 << *shift;
+
+	return 0;
+}
+
+static int s3c_camif_setup_scaler(camif_cfg_t *cfg)
+{
+	int tx = cfg->target_x, ty = cfg->target_y;
+	int sx, sy;
+
+	if (tx <= 0 || ty <= 0) {
+		printk(KERN_ERR "Invalid target size\n");
+		return -1;
+	}
+
+	sx = cfg->cis->source_x -
+	    (cfg->cis->win_hor_ofst + cfg->cis->win_hor_ofst2);
+	sy = cfg->cis->source_y -
+	    (cfg->cis->win_ver_ofst + cfg->cis->win_hor_ofst2);
+
+	if (sx <= 0 || sy <= 0)	{
+		printk(KERN_ERR "Invalid source size\n");
+		return -1;
+	}
+
+	cfg->sc.modified_src_x = sx;
+	cfg->sc.modified_src_y = sy;
+
+	/* Pre-scaler control register 1 */
+	s3c_camif_calc_ratio(sx, tx, &cfg->sc.prehratio, &cfg->sc.hfactor);
+	s3c_camif_calc_ratio(sy, ty, &cfg->sc.prevratio, &cfg->sc.vfactor);
+
+	if (cfg->dma_type & CAMIF_PREVIEW) {
+		if (sx / cfg->sc.prehratio > 640) {
+			printk(KERN_INFO "Internal preview line buffer length "
+			    "is 640 pixels\n");
+			printk(KERN_INFO "Decrease the resolution or adjust "
+			    "window offset values appropriately\n");
+		}
+	}
+
+	cfg->sc.shfactor = 10 - (cfg->sc.hfactor + cfg->sc.vfactor);
+
+	/* Pre-scaler control register 2 */
+	cfg->sc.predst_x = sx / cfg->sc.prehratio;
+	cfg->sc.predst_y = sy / cfg->sc.prevratio;
+
+	/* Main-scaler control register */
+	cfg->sc.mainhratio = (sx << 8) / (tx << cfg->sc.hfactor);
+	cfg->sc.mainvratio = (sy << 8) / (ty << cfg->sc.vfactor);
+
+	cfg->sc.scaleup_h = sx <= tx;
+	cfg->sc.scaleup_v = sy <= ty;
+
+	s3c_camif_set_ratio(cfg);
+	s3c_camif_set_target_area(cfg);
+
+	return 0;
+}
+
+/*************************************************************************
+ * Format part
+ ************************************************************************/
+int s3c_camif_set_source_format(camif_cis_t *cis)
+{
+	camif_cfg_t *cfg = s3c_camif_get_fimc_object(CODEC_MINOR);
+	unsigned int cmd = 0;
+
+	/* Configure CISRCFMT --Source Format */
+	if (cis->itu_fmt & CAMIF_ITU601)
+		cmd = CAMIF_ITU601;
+	else {
+		assert(cis->itu_fmt & CAMIF_ITU656);
+		cmd = CAMIF_ITU656;
+	}
+
+	cmd |= S3C_CISRCFMT_SOURCEHSIZE(cis->source_x) |
+	    S3C_CISRCFMT_SOURCEVSIZE(cis->source_y);
+
+	/* Order422 */
+	cmd |= cis->order422;
+	writel(cmd, cfg->regs + S3C_CISRCFMT);
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+	cmd = cis->order422 >> 14;
+	writel((readl(cfg->regs + S3C_CICOCTRL) & ~(0x3 << 0)) | cmd,
+	    cfg->regs + S3C_CICOCTRL);
+#endif
+
+	return 0;
+}
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+static int s3c_camif_set_target_format(camif_cfg_t *cfg)
+{
+	unsigned int cmd = 0;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		cmd |= S3C_CICOTRGFMT_TARGETHSIZE_CO(cfg->target_x) |
+		    S3C_CICOTRGFMT_TARGETVSIZE_CO(cfg->target_y);
+
+		if (cfg->dst_fmt & CAMIF_YCBCR420)
+			cmd |= S3C_CICOTRGFMT_OUT422_420 |
+			    S3C_CICOTRGFMT_IN422_422;
+		else if (cfg->dst_fmt & CAMIF_YCBCR422)
+			cmd |= (S3C_CICOTRGFMT_OUT422_422 |
+			    S3C_CICOTRGFMT_IN422_422);
+		else if ((cfg->dst_fmt & CAMIF_RGB24) ||
+			   (cfg->dst_fmt & CAMIF_RGB16))
+			cmd |= (S3C_CICOTRGFMT_OUT422_422 |
+			    S3C_CICOTRGFMT_IN422_422) | (1 << 29);
+		else
+			printk(KERN_ERR "Invalid target format\n");
+		writel(cmd, cfg->regs + S3C_CICOTRGFMT);
+	} else {
+		assert(cfg->dma_type & CAMIF_PREVIEW);
+
+		cmd = readl(cfg->regs + S3C_CIPRTRGFMT);
+		cmd &= ~(S3C_CIPRTRGFMT_TARGETHSIZE_PR(0x1fff) |
+		    S3C_CIPRTRGFMT_TARGETVSIZE_PR(0x1fff));
+		cmd |= S3C_CIPRTRGFMT_TARGETHSIZE_PR(cfg->target_x) |
+		    S3C_CIPRTRGFMT_TARGETVSIZE_PR(cfg->target_y);
+
+		writel(cmd | (2 << 30), cfg->regs + S3C_CIPRTRGFMT);
+	}
+
+	return 0;
+}
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+static int s3c_camif_set_target_format(camif_cfg_t *cfg)
+{
+	unsigned int cmd = 0;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		cmd |= S3C_CICOTRGFMT_TARGETHSIZE_CO(cfg->target_x) |
+		    S3C_CICOTRGFMT_TARGETVSIZE_CO(cfg->target_y);
+
+		if (cfg->dst_fmt & CAMIF_YCBCR420)
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_YCBCR420OUT;
+		else if (cfg->dst_fmt & CAMIF_YCBCR422)
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUT;
+		else if (cfg->dst_fmt & CAMIF_YCBCR422I)
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUTINTERLEAVE;
+		else if ((cfg->dst_fmt & CAMIF_RGB24) ||
+			   (cfg->dst_fmt & CAMIF_RGB16))
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_RGBOUT;
+		else
+			printk(KERN_ERR "Invalid target format\n");
+		writel(cmd, cfg->regs + S3C_CICOTRGFMT);
+	} else {
+		assert(cfg->dma_type & CAMIF_PREVIEW);
+
+		cmd = readl(cfg->regs + S3C_CIPRTRGFMT);
+		cmd &= ~(S3C_CIPRTRGFMT_TARGETHSIZE_PR(0x1fff) |
+		    S3C_CIPRTRGFMT_TARGETVSIZE_PR(0x1fff));
+		cmd |= S3C_CIPRTRGFMT_TARGETHSIZE_PR(cfg->target_x) |
+		    S3C_CIPRTRGFMT_TARGETVSIZE_PR(cfg->target_y);
+
+		if (cfg->dst_fmt & CAMIF_YCBCR420)
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_YCBCR420OUT;
+		else if (cfg->dst_fmt & CAMIF_YCBCR422)
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUT;
+		else if (cfg->dst_fmt & CAMIF_YCBCR422I)
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_YCBCR422OUTINTERLEAVE;
+		else if ((cfg->dst_fmt & CAMIF_RGB24) ||
+			 (cfg->dst_fmt & CAMIF_RGB16))
+			cmd |= S3C_CICOTRGFMT_OUTFORMAT_RGBOUT;
+		else
+			printk(KERN_ERR "Invalid target format\n");
+
+		writel(cmd, cfg->regs + S3C_CIPRTRGFMT);
+	}
+
+	return 0;
+}
+#endif
+
+/*************************************************************************
+ * Control part
+ ************************************************************************/
+int s3c_camif_control_fimc(camif_cfg_t *cfg)
+{
+	if (s3c_camif_request_memory(cfg)) {
+		printk(KERN_ERR "Instead of using consistent_alloc(). "
+		    "Let me use dedicated mem for DMA\n");
+		return -1;
+	}
+
+	s3c_camif_setup_input_path(cfg);
+
+	if (s3c_camif_setup_scaler(cfg)) {
+		printk(KERN_ERR "Preview scaler fault: "
+		    "change WinHorOfset or target size\n");
+		return 1;
+	}
+
+	s3c_camif_set_target_format(cfg);
+
+	if (s3c_camif_setup_dma(cfg)) {
+		printk(KERN_ERR "DMA burst length error\n");
+		return 1;
+	}
+
+	s3c_camif_setup_output_path(cfg);
+
+	return 0;
+}
+
+int s3c_camif_start_dma(camif_cfg_t *cfg)
+{
+	unsigned int n_cmd = readl(cfg->regs + S3C_CIIMGCPT);
+	unsigned int val;
+
+	switch(cfg->capture_enable) {
+	case CAMIF_BOTH_DMA_ON:
+		s3c_camif_reset(CAMIF_RESET, 0); /* Flush Camera Core Buffer */
+
+		/* For Codec */
+		val = readl(cfg->regs + S3C_CICOSCCTRL);
+		val |= S3C_CICOSCCTRL_COSCALERSTART;
+		writel(val, cfg->regs + S3C_CICOSCCTRL);
+
+		/* For Preview */
+		val = readl(cfg->regs + S3C_CIPRSCCTRL);
+		val |= S3C_CIPRSCCTRL_START;
+		writel(val, cfg->regs + S3C_CIPRSCCTRL);
+
+		n_cmd |=
+		    S3C_CIIMGCPT_IMGCPTEN_COSC | S3C_CIIMGCPT_IMGCPTEN_PRSC;
+		break;
+
+	case CAMIF_DMA_ON:
+		s3c_camif_reset(CAMIF_RESET, 0); /* Flush Camera Core Buffer */
+
+		if (cfg->dma_type & CAMIF_CODEC) {
+			val = readl(cfg->regs + S3C_CICOSCCTRL);
+			val |= S3C_CICOSCCTRL_COSCALERSTART;
+			writel(val, cfg->regs + S3C_CICOSCCTRL);
+
+			n_cmd |= S3C_CIIMGCPT_IMGCPTEN_COSC;
+
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+			n_cmd |= (1 << 24);
+#endif
+		} else {
+			val = readl(cfg->regs + S3C_CIPRSCCTRL);
+			val |= S3C_CIPRSCCTRL_START;
+			writel(val, cfg->regs + S3C_CIPRSCCTRL);
+			n_cmd |= S3C_CIIMGCPT_IMGCPTEN_PRSC;
+		}
+
+		/* wait until Sync Time expires */
+		/* First settting, to wait VSYNC fall  */
+		/* By VESA spec,in 640x480 @60Hz
+		   MAX Delay Time is around 64us which "while" has.*/
+		while (S3C_CICOSTATUS_VSYNC &
+		    readl(cfg->regs + S3C_CICOSTATUS));
+		break;
+
+	default:
+		break;
+	}
+
+#if defined(CONFIG_CPU_S3C2443)
+	if (cfg->dma_type & CAMIF_CODEC) {
+		if (cfg->dst_fmt & CAMIF_RGB24)
+			n_cmd |= 3 << 25;
+		else if (cfg->dst_fmt & CAMIF_RGB16)
+			n_cmd |= 1 << 25;
+		else if (cfg->dst_fmt & CAMIF_YCBCR420)
+			n_cmd |= 2 << 25;
+	}
+#endif
+
+	val = readl(cfg->regs + S3C_CIIMGCPT);
+	val &= ~(0x7 << 29);
+	writel(val | n_cmd | S3C_CIIMGCPT_IMGCPTEN, cfg->regs + S3C_CIIMGCPT);
+
+	return 0;
+}
+
+int s3c_camif_stop_dma(camif_cfg_t *cfg)
+{
+	unsigned int n_cmd = readl(cfg->regs + S3C_CIIMGCPT);
+	unsigned int val;
+
+	switch(cfg->capture_enable) {
+	case CAMIF_BOTH_DMA_OFF:
+		val = readl(cfg->regs + S3C_CICOSCCTRL);
+		val &= ~S3C_CICOSCCTRL_COSCALERSTART;
+		writel(val, cfg->regs + S3C_CICOSCCTRL);
+
+		val = readl(cfg->regs + S3C_CIPRSCCTRL);
+		val &= ~S3C_CIPRSCCTRL_START;
+		writel(val, cfg->regs + S3C_CIPRSCCTRL);
+
+		n_cmd = 0;
+		break;
+
+	case CAMIF_DMA_OFF_L_IRQ: /* fall thru */
+	case CAMIF_DMA_OFF:
+		if (cfg->dma_type & CAMIF_CODEC) {
+			val = readl(cfg->regs + S3C_CICOSCCTRL);
+			val &= ~S3C_CICOSCCTRL_COSCALERSTART;
+			writel(val, cfg->regs + S3C_CICOSCCTRL);
+			n_cmd &= ~S3C_CIIMGCPT_IMGCPTEN_COSC;
+
+			if (!(n_cmd & S3C_CIIMGCPT_IMGCPTEN_PRSC))
+				n_cmd = 0;
+		} else {
+			val = readl(cfg->regs + S3C_CIPRSCCTRL);
+			val &= ~S3C_CIPRSCCTRL_START;
+			writel(val, cfg->regs + S3C_CIPRSCCTRL);
+
+			n_cmd &= ~S3C_CIIMGCPT_IMGCPTEN_PRSC;
+
+			if (!(n_cmd & S3C_CIIMGCPT_IMGCPTEN_COSC))
+				n_cmd = 0;
+		}
+
+		break;
+
+	default:
+		printk(KERN_ERR "Unexpected DMA control\n");
+	}
+
+	writel(n_cmd, cfg->regs + S3C_CIIMGCPT);
+
+	if (cfg->capture_enable == CAMIF_DMA_OFF_L_IRQ) { /* Last IRQ  */
+		if (cfg->dma_type & CAMIF_CODEC) {
+			val = readl(cfg->regs + S3C_CICOCTRL);
+			val |= S3C_CICOCTRL_LASTIRQEN;
+			writel(val, cfg->regs + S3C_CICOCTRL);
+		} else {
+			val = readl(cfg->regs + S3C_CIPRCTRL);
+			val |= S3C_CIPRCTRL_LASTIRQEN_ENABLE;
+			writel(val, cfg->regs + S3C_CIPRCTRL);
+		}
+	}
+
+	return 0;
+}
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+int s3c_camif_start_codec_msdma(camif_cfg_t *cfg)
+{
+	int ret = 0;
+	u32 val;
+
+	val = readl(cfg->regs + S3C_MSCOCTRL);
+	val &= ~(1 << 0);
+	writel(val, cfg->regs + S3C_MSCOCTRL);
+
+	val = readl(cfg->regs + S3C_MSCOCTRL);
+	val |= (1 << 0);
+	writel(val, cfg->regs + S3C_MSCOCTRL);
+
+	return ret;
+}
+#endif
+
+int s3c_camif_start_preview_msdma(camif_cfg_t * cfg)
+{
+	unsigned int val;
+	int ret = 0;
+
+#if !defined(CONFIG_CPU_S3C6400) && !defined(CONFIG_CPU_S3C6410)
+	val = readl(cfg->regs + S3C_CIMSCTRL);
+	val &= ~(1 << 0);
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+#endif
+	val = readl(cfg->regs + S3C_CIMSCTRL);
+	val |= (1 << 0);
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	while(!readl(cfg->regs + S3C_CIMSCTRL) & (1 << 6));
+
+	return ret;
+}
+
+void s3c_camif_change_flip(camif_cfg_t *cfg)
+{
+	unsigned int cmd = 0;
+
+	if (cfg->dma_type & CAMIF_CODEC) {
+		cmd  = readl(cfg->regs + S3C_CICOTRGFMT);
+		cmd &= ~((1 << 14) | (1 << 15));
+		cmd |= cfg->flip;
+		writel(cmd, cfg->regs + S3C_CICOTRGFMT);
+	} else {
+		/* if ROT90_Pr == 1, dma burst length must be 4 */
+		if (cfg->flip == CAMIF_ROTATE_90 ||
+		    cfg->flip == CAMIF_FLIP_ROTATE_270) {
+			cmd = readl(cfg->regs + S3C_CIPRCTRL);
+			cmd &= ~(0x3ff << 14);
+			cmd |= (S3C_CICOCTRL_YBURST1_CO(4) |
+			    S3C_CICOCTRL_YBURST2_CO(4));
+			writel(cmd, cfg->regs + S3C_CIPRCTRL);
+		}
+
+		cmd  = readl(cfg->regs + S3C_CIPRTRGFMT);
+		cmd &= ~(0x7 << 13);
+		cmd |= cfg->flip;
+		writel(cmd, cfg->regs + S3C_CIPRTRGFMT);
+	}
+}
+
+void s3c_camif_change_effect(camif_cfg_t *cfg)
+{
+	unsigned int val = readl(cfg->regs + S3C_CIIMGEFF);
+
+	val &= ~((1 << 28) | (1 << 27) | (1 << 26));
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+	val |= ((1 << 31) | (1 << 30));
+#endif
+
+	switch(cfg->effect) {
+	case CAMIF_SILHOUETTE:
+		val |= S3C_CIIMGEFF_FIN_SILHOUETTE;
+		break;
+
+	case CAMIF_EMBOSSING:
+		val |= S3C_CIIMGEFF_FIN_EMBOSSING;
+		break;
+
+	case CAMIF_ART_FREEZE:
+		val |= S3C_CIIMGEFF_FIN_ARTFREEZE;
+		break;
+
+	case CAMIF_NEGATIVE:
+		val |= S3C_CIIMGEFF_FIN_NEGATIVE;
+		break;
+
+	case CAMIF_ARBITRARY_CB_CR:
+		val |= S3C_CIIMGEFF_FIN_ARBITRARY;
+		break;
+
+	case CAMIF_BYPASS:
+	default:
+		break;
+	}
+
+	writel(val, cfg->regs + S3C_CIIMGEFF);
+}
+
+int s3c_camif_do_postprocess(camif_cfg_t *cfg)
+{
+	unsigned int val = readl(cfg->regs + S3C_CIMSCTRL);
+
+	if (cfg->dst_fmt & CAMIF_YCBCR420)
+		val |= 1 << 1;
+	else
+		val &= ~(1 << 1);
+
+	val &= ~(1 << 0);
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	val |= 1 << 0;
+	writel(val, cfg->regs + S3C_CIMSCTRL);
+
+	printk(KERN_INFO "Postprocessing started\n");
+
+	while(!readl(cfg->regs + S3C_CIMSCTRL) & (1 << 6));
+
+	printk(KERN_INFO "Postprocessing finished\n");
+
+	return 0;
+}
+
+int s3c_camif_set_offset(camif_cis_t *cis)
+{
+	camif_cfg_t *cfg = s3c_camif_get_fimc_object(CODEC_MINOR);
+	unsigned int h = cis->win_hor_ofst;	/* Camera input offset ONLY */
+	unsigned int v = cis->win_ver_ofst;	/* Camera input offset ONLY */
+	unsigned int h2 = cis->win_hor_ofst2;	/* Camera input offset ONLY */
+	unsigned int v2 = cis->win_ver_ofst2;	/* Camera input offset ONLY */
+
+	/*Clear Overflow */
+	writel(S3C_CIWDOFST_CLROVCOFIY | S3C_CIWDOFST_CLROVCOFICB |
+	    S3C_CIWDOFST_CLROVCOFICR | S3C_CIWDOFST_CLROVPRFICB |
+	    S3C_CIWDOFST_CLROVPRFICR, cfg->regs + S3C_CIWDOFST);
+
+	writel(0, cfg->regs + S3C_CIWDOFST);
+
+	if (!h && !v) {
+		writel(0, cfg->regs + S3C_CIWDOFST);
+		writel(0, cfg->regs + S3C_CIDOWSFT2);
+		return 0;
+	}
+
+	writel(S3C_CIWDOFST_WINOFSEN | S3C_CIWDOFST_WINHOROFST(h) |
+	    S3C_CIWDOFST_WINVEROFST(v), cfg->regs + S3C_CIWDOFST);
+	writel(S3C_CIDOWSFT2_WINHOROFST2(h) | S3C_CIDOWSFT2_WINVEROFST2(v),
+	    cfg->regs + S3C_CIDOWSFT2);
+	writel(S3C_CIDOWSFT2_WINHOROFST2(h2) | S3C_CIDOWSFT2_WINVEROFST2(v2),
+	    cfg->regs + S3C_CIDOWSFT2);
+
+	return 0;
+}
+
+void s3c_camif_set_priority(int flag)
+{
+	unsigned int val;
+
+	if (flag) {
+		irq_old_priority = readl(S3C64XX_PRIORITY);
+		val = irq_old_priority;
+		val &= ~(3 << 7);
+		writel(val, S3C64XX_PRIORITY);
+
+		/* Arbiter 1, REQ2 first */
+		val |=  (1 << 7);
+		writel(val, S3C64XX_PRIORITY);
+
+		/* Disable Priority Rotate */
+		val &= ~(1 << 1);
+		writel(val, S3C64XX_PRIORITY);
+	} else
+		writel(irq_old_priority, S3C64XX_PRIORITY);
+}
+
+/*************************************************************************
+ * Interrupt part
+ ************************************************************************/
+void s3c_camif_enable_lastirq(camif_cfg_t *cfg)
+{
+	unsigned int val;
+
+	if (cfg->capture_enable == CAMIF_BOTH_DMA_ON ||
+	    (cfg->dma_type & CAMIF_CODEC)) {
+		val = readl(cfg->regs + S3C_CICOCTRL);
+		val |= S3C_CICOCTRL_LASTIRQEN;
+		writel(val, cfg->regs + S3C_CICOCTRL);
+	}
+
+	if (cfg->capture_enable == CAMIF_BOTH_DMA_ON ||
+	    !(cfg->dma_type & CAMIF_CODEC)) {
+		val = readl(cfg->regs + S3C_CIPRCTRL);
+		val |= S3C_CIPRCTRL_LASTIRQEN_ENABLE;
+		writel(val, cfg->regs + S3C_CIPRCTRL);
+	}
+}
+
+void s3c_camif_disable_lastirq(camif_cfg_t *cfg)
+{
+	unsigned int val;
+
+	if (cfg->capture_enable == CAMIF_BOTH_DMA_ON ||
+	    (cfg->dma_type & CAMIF_CODEC)) {
+		val = readl(cfg->regs + S3C_CICOCTRL);
+		val &= ~S3C_CICOCTRL_LASTIRQEN;
+		writel(val, cfg->regs + S3C_CICOCTRL);
+	}
+
+	if (cfg->capture_enable == CAMIF_BOTH_DMA_ON ||
+	    !(cfg->dma_type & CAMIF_CODEC)) {
+		val = readl(cfg->regs + S3C_CIPRCTRL);
+		val &= ~S3C_CIPRCTRL_LASTIRQEN_ENABLE;
+		writel(val, cfg->regs + S3C_CIPRCTRL);
+	}
+}
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+void s3c_camif_clear_irq(int irq)
+{
+	camif_cfg_t *cfg = s3c_camif_get_fimc_object(CODEC_MINOR);
+	unsigned int val = 0;
+
+	if (irq == IRQ_CAMIF_C) {
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val |= (1 << 19);
+	} else if (irq == IRQ_CAMIF_P) {
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val |= (1 << 18);
+	}
+
+	writel(val, cfg->regs + S3C_CIGCTRL);
+}
+#else
+void s3c_camif_clear_irq(int irq)
+{
+}
+#endif
+
+/*************************************************************************
+ * Initialize part
+ ************************************************************************/
+#if defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+static int s3c_camif_set_gpio(void)
+{
+	s3c2410_gpio_cfgpin(S3C2440_GPJ0, S3C2440_GPJ0_CAMDATA0);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ1, S3C2440_GPJ1_CAMDATA1);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ2, S3C2440_GPJ2_CAMDATA2);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ3, S3C2440_GPJ3_CAMDATA3);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ4, S3C2440_GPJ4_CAMDATA4);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ5, S3C2440_GPJ5_CAMDATA5);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ6, S3C2440_GPJ6_CAMDATA6);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ7, S3C2440_GPJ7_CAMDATA7);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ8, S3C2440_GPJ8_CAMPCLK);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ9, S3C2440_GPJ9_CAMVSYNC);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ10, S3C2440_GPJ10_CAMHREF);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ11, S3C2440_GPJ11_CAMCLKOUT);
+	s3c2410_gpio_cfgpin(S3C2440_GPJ12, S3C2440_GPJ12_CAMRESET);
+
+	writel(0x1fff, S3C2443_GPJDN);
+
+	return 0;
+}
+#elif defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+static int s3c_camif_set_gpio(void)
+{
+	s3c_gpio_cfgpin(S3C64XX_GPF(5), S3C64XX_GPF5_CAMIF_YDATA0);
+	s3c_gpio_cfgpin(S3C64XX_GPF(6), S3C64XX_GPF6_CAMIF_YDATA1);
+	s3c_gpio_cfgpin(S3C64XX_GPF(7), S3C64XX_GPF7_CAMIF_YDATA2);
+	s3c_gpio_cfgpin(S3C64XX_GPF(8), S3C64XX_GPF8_CAMIF_YDATA3);
+	s3c_gpio_cfgpin(S3C64XX_GPF(9), S3C64XX_GPF9_CAMIF_YDATA4);
+	s3c_gpio_cfgpin(S3C64XX_GPF(10), S3C64XX_GPF10_CAMIF_YDATA5);
+	s3c_gpio_cfgpin(S3C64XX_GPF(11), S3C64XX_GPF11_CAMIF_YDATA6);
+	s3c_gpio_cfgpin(S3C64XX_GPF(12), S3C64XX_GPF12_CAMIF_YDATA7);
+	s3c_gpio_cfgpin(S3C64XX_GPF(2), S3C64XX_GPF2_CAMIF_PCLK);
+	s3c_gpio_cfgpin(S3C64XX_GPF(4), S3C64XX_GPF4_CAMIF_VSYNC);
+	s3c_gpio_cfgpin(S3C64XX_GPF(1), S3C64XX_GPF1_CAMIF_HREF);
+	s3c_gpio_cfgpin(S3C64XX_GPF(0), S3C64XX_GPF0_CAMIF_CLK);
+	s3c_gpio_cfgpin(S3C64XX_GPF(3), S3C64XX_GPF3_CAMIF_nRST);
+
+	writel(0, S3C64XX_GPFPUD);
+
+	return 0;
+}
+#endif
+
+void s3c_camif_reset(int is, int delay)
+{
+	camif_cfg_t *cfg = s3c_camif_get_fimc_object(CODEC_MINOR);
+	unsigned int val;
+	unsigned int tmp;
+
+	switch (is) {
+	case CAMIF_RESET:
+		tmp = readl(cfg->regs + S3C_CISRCFMT);
+
+		if (tmp &= (1 << 31)) {
+			/* ITU-R BT 601 */
+			val = readl(cfg->regs + S3C_CIGCTRL);
+			val |= S3C_CIGCTRL_SWRST;
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+			val |= S3C_CIGCTRL_IRQ_LEVEL;
+#endif
+			writel(val, cfg->regs + S3C_CIGCTRL);
+			mdelay(1);
+
+			val = readl(cfg->regs + S3C_CIGCTRL);
+			val &= ~S3C_CIGCTRL_SWRST;
+			writel(val, cfg->regs + S3C_CIGCTRL);
+		} else {
+			/* ITU-R BT 656 */
+			tmp = readl(cfg->regs + S3C_CISRCFMT);
+			tmp |= (1 << 31);
+			writel(tmp, cfg->regs + S3C_CISRCFMT);
+
+			val = readl(cfg->regs + S3C_CIGCTRL);
+			val |= S3C_CIGCTRL_SWRST;
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+			val |= S3C_CIGCTRL_IRQ_LEVEL;
+#endif
+			writel(val, cfg->regs + S3C_CIGCTRL);
+			mdelay(1);
+
+			val = readl(cfg->regs + S3C_CIGCTRL);
+			val &= ~S3C_CIGCTRL_SWRST;
+			writel(val, cfg->regs + S3C_CIGCTRL);
+
+			tmp = readl(cfg->regs + S3C_CISRCFMT);
+			tmp &= ~(1 << 31);
+			writel(tmp, cfg->regs + S3C_CISRCFMT);
+		}
+
+		break;
+
+	case CAMIF_EX_RESET_AH:
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val |= S3C_CIGCTRL_CAMRST;
+		writel(val, cfg->regs + S3C_CIGCTRL);
+		udelay(200);
+
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val &= ~S3C_CIGCTRL_CAMRST;
+		writel(val, cfg->regs + S3C_CIGCTRL);
+		udelay(delay);
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K3AA)
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val |= S3C_CIGCTRL_CAMRST;
+		writel(val, cfg->regs + S3C_CIGCTRL);
+		udelay(200);
+#endif
+		break;
+
+	case CAMIF_EX_RESET_AL:
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val &= ~S3C_CIGCTRL_CAMRST;
+		writel(val, cfg->regs + S3C_CIGCTRL);
+		udelay(200);
+
+		val = readl(cfg->regs + S3C_CIGCTRL);
+		val |= S3C_CIGCTRL_CAMRST;
+		writel(val, cfg->regs + S3C_CIGCTRL);
+		udelay(delay);
+		break;
+
+	default:
+		break;
+	}
+}
+
+void s3c_camif_init(void)
+{
+	s3c_camif_reset(CAMIF_RESET, 0);
+	s3c_camif_set_gpio();
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/s3c_camif.h linux-2.6.29-rc3.owrt.om/drivers/media/video/s3c_camif.h
--- linux-2.6.29-rc3.owrt/drivers/media/video/s3c_camif.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/s3c_camif.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,404 @@
+/* drivers/media/video/s3c_camif.h
+ *
+ * Copyright (c) 2008 Samsung Electronics
+ *
+ * Samsung S3C Camera driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __S3C_CAMIF_H_
+#define __S3C_CAMIF_H_
+
+#ifdef __KERNEL__
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <asm/types.h>
+#include <linux/i2c.h>
+#include <linux/video_decoder.h>
+#endif	/* __KERNEL__ */
+
+#if !defined(O_NONCAP)
+#define O_NONCAP O_TRUNC
+#endif
+
+#if defined(CAMIF_DEBUG)
+#define DPRINTK(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+#if defined(CAMIF_DEBUG)
+#define assert(expr) \
+	if(!(expr)) { \
+	printk( "Assertion failed! %s,%s,%s,line=%d\n", \
+	#expr,__FILE__,__FUNCTION__,__LINE__);		\
+	}
+#else
+#define assert(expr)
+#endif
+
+#if defined(CONFIG_CPU_S3C6400) || defined(CONFIG_CPU_S3C6410)
+#define MEM_SIZE	0x08000000
+#define FIMC_VER	"3.0"
+#elif defined(CONFIG_CPU_S3C2443) || defined(CONFIG_CPU_S3C2450) || defined(CONFIG_CPU_S3C2416)
+#define MEM_SIZE	0x04000000
+#define FIMC_VER	"2.3"
+#else
+#define MEM_SIZE	0x04000000
+#define FIMC_VER	"2.x"
+#endif
+
+#undef FSM_ON_PREVIEW
+#define FSM_ON_CODEC
+
+#undef USE_LAST_IRQ			/* turn on if pp count is 1 */
+
+#define CODEC_DEV_NAME			"CAMIF_CODEC"
+#define PREVIEW_DEV_NAME		"CAMIF_PREVIEW"
+
+#define CAMIF_DEV_NUM			2
+#define FIMC_CODEC_INDEX		0
+#define FIMC_PREVIEW_INDEX		1
+
+#define BURST_ERR			1
+#define RESERVED_MEM			(15 * 1024 * 1024)
+#define YUV_MEM				(10 * 1024 * 1024)
+#define RGB_MEM				(RESERVED_MEM - YUV_MEM)
+
+#define CODEC_DEFAULT_WIDTH		640
+#define CODEC_DEFAULT_HEIGHT		480
+#define PREVIEW_DEFAULT_WIDTH		640
+#define PREVIEW_DEFAULT_HEIGHT		480
+
+#define CROP_DEFAULT_WIDTH		352
+#define CROP_DEFAULT_HEIGHT		272
+
+#define CODEC_DEFAULT_PPNUM		4
+#define PREVIEW_DEFAULT_PPNUM		4
+
+#define CODEC_MINOR			12
+#define PREVIEW_MINOR			13
+
+#define CHECK_FREQ			5
+#define INSTANT_SKIP			0
+#define INSTANT_GO			1
+
+#define VID_HARDWARE_SAMSUNG_FIMC3X	236
+
+#define ZOOM_AT_A_TIME_IN_PIXELS	32
+#define ZOOM_IN_MAX			640
+
+/* Codec or Preview Status */
+#define CAMIF_STARTED			(1 << 1)
+#define CAMIF_STOPPED			(1 << 2)
+#define CAMIF_INT_HAPPEN		(1 << 3)
+
+/* Codec or Preview  : Interrupt FSM */
+#define CAMIF_1st_INT			(1 << 7)
+#define CAMIF_Xth_INT			(1 << 8)
+#define CAMIF_Yth_INT			(1 << 9)
+#define CAMIF_Zth_INT			(1 << 10)
+#define CAMIF_NORMAL_INT		(1 << 11)
+#define CAMIF_DUMMY_INT			(1 << 12)
+#define CAMIF_CONTINUOUS_INT		(1 << 13)
+#define CAMIF_SET_LAST_INT		(1 << 14)
+#define CAMIF_STOP_CAPTURE		(1 << 15)
+#define CAMIF_LAST_IRQ			(1 << 16)
+#define CAMIF_PENDING_INT		0
+
+#define CAMIF_CAPTURE_SKIP_FRAMES	5
+
+/* CAMIF RESET Definition */
+#define CAMIF_RESET			(1 << 0)
+#define CAMIF_EX_RESET_AL		(1 << 1)	/* Active Low */
+#define CAMIF_EX_RESET_AH		(1 << 2)	/* Active High */
+
+#define USER_EXIT			(1 << 2)
+#define USER_ADD			(1 << 1)
+#define SENSOR_INIT			(1 << 0)
+
+#define SENSOR_MAX			255
+#define SENSOR_QSVGA			(1 << 12)
+#define SENSOR_UXGA			(1 << 11)
+#define SENSOR_SVGA			(1 << 10)
+#define SENSOR_SXGA			(1 << 4)
+#define SENSOR_VGA			(1 << 3)
+#define SENSOR_DEFAULT			0
+
+#define SENSOR_WB			(1 << 9)
+#define SENSOR_AF			(1 << 8)
+#define SENSOR_MIRROR			(1 << 7)
+#define SENSOR_ZOOMOUT			(1 << 6)
+#define SENSOR_ZOOMIN			(1 << 5)
+
+/* Global Status Definition */
+#define PWANT2START			(1 << 0)
+#define CWANT2START			(1 << 1)
+#define BOTH_STARTED			(PWANT2START | CWANT2START)
+#define P_NOT_WORKING			(1 << 4)
+#define C_WORKING			(1 << 5)
+#define P_WORKING			(1 << 6)
+#define C_NOT_WORKING			(1 << 7)
+
+#define FORMAT_FLAGS_DITHER		0x01
+#define FORMAT_FLAGS_PACKED		0x02
+#define FORMAT_FLAGS_PLANAR		0x04
+#define FORMAT_FLAGS_RAW		0x08
+#define FORMAT_FLAGS_CrCb		0x10
+
+enum camif_itu_fmt {
+	CAMIF_ITU601 = (1 << 31),
+	CAMIF_ITU656 = 0,
+};
+
+/* It is possbie to use two device simultaneously */
+enum camif_dma_type {
+	CAMIF_PREVIEW = (1 << 0),
+	CAMIF_CODEC   = (1 << 1),
+};
+
+enum camif_order422 {
+	CAMIF_YCBYCR = 0,
+	CAMIF_YCRYCB = (1 << 14),
+	CAMIF_CBYCRY = (1 << 15),
+	CAMIF_CRYCBY = (1 << 15) | (1 << 14),
+};
+
+enum flip_mode {
+	CAMIF_FLIP = 0,
+	CAMIF_ROTATE_90	= (1 << 13),
+	CAMIF_FLIP_X = (1 << 14),
+	CAMIF_FLIP_Y = (1 << 15),
+	CAMIF_FLIP_MIRROR = (1 << 15) | (1 << 14),
+	CAMIF_FLIP_ROTATE_270 = (1 << 15) | (1 << 14) | (1 << 13),
+};
+
+enum camif_fmt {
+	CAMIF_YCBCR420 = (1 << 0),
+	CAMIF_YCBCR422 = (1 << 1),
+	CAMIF_YCBCR422I = (1 << 2),
+	CAMIF_RGB16 = (1 << 3),
+	CAMIF_RGB24 = (1 << 4),
+	CAMIF_RGB32 = (1 << 5),
+};
+
+enum camif_capturing {
+	CAMIF_BOTH_DMA_ON = (1 << 4),
+	CAMIF_DMA_ON = (1 << 3),
+	CAMIF_BOTH_DMA_OFF = (1 << 1),
+	CAMIF_DMA_OFF = (1 << 0),
+	CAMIF_DMA_OFF_L_IRQ = (1 << 5),
+};
+
+enum image_effect {
+	CAMIF_BYPASS,
+	CAMIF_ARBITRARY_CB_CR,
+	CAMIF_NEGATIVE,
+	CAMIF_ART_FREEZE,
+	CAMIF_EMBOSSING ,
+	CAMIF_SILHOUETTE,
+};
+
+enum input_channel{
+	CAMERA_INPUT,
+	MSDMA_FROM_CODEC,
+	MSDMA_FROM_PREVIEW,
+};
+
+enum output_channel{
+	CAMIF_OUT_PP,
+	CAMIF_OUT_FIFO,
+};
+
+typedef struct camif_performance
+{
+	int	frames;
+	int	framesdropped;
+	__u64	bytesin;
+	__u64	bytesout;
+	__u32	reserved[4];
+} camif_perf_t;
+
+typedef struct {
+	dma_addr_t	phys_y;
+	dma_addr_t	phys_cb;
+	dma_addr_t	phys_cr;
+	u8		*virt_y;
+	u8		*virt_cb;
+	u8		*virt_cr;
+	dma_addr_t	phys_rgb;
+	u8		*virt_rgb;
+} img_buf_t;
+
+/* this structure convers the CIWDOFFST, prescaler, mainscaler */
+typedef struct {
+	u32 modified_src_x;	/* After windows applyed to source_x */
+	u32 modified_src_y;
+	u32 hfactor;
+	u32 vfactor;
+	u32 shfactor;		/* SHfactor = 10 - ( hfactor + vfactor ) */
+	u32 prehratio;
+	u32 prevratio;
+	u32 predst_x;
+	u32 predst_y;
+	u32 scaleup_h;
+	u32 scaleup_v;
+	u32 mainhratio;
+	u32 mainvratio;
+	u32 scalerbypass;	/* only codec */
+	u32 zoom_in_cnt;
+} scaler_t;
+
+enum v4l2_status {
+	CAMIF_V4L2_INIT	= (1 << 0),
+	CAMIF_v4L2_DIRTY = (1 << 1),
+};
+
+typedef struct {
+	struct semaphore	lock;
+	enum camif_itu_fmt	itu_fmt;
+	enum camif_order422	order422;
+	struct i2c_client	*sensor;
+	u32			win_hor_ofst;
+	u32			win_ver_ofst;
+	u32			win_hor_ofst2;
+	u32			win_ver_ofst2;
+	u32			camclk; 		/* External Image Sensor Camera Clock */
+	u32			source_x;
+	u32			source_y;
+	u32			polarity_pclk;
+	u32			polarity_vsync;
+	u32			polarity_href;
+	u32			user;			/* MAX 2 (codec, preview) */
+	u32			irq_old_priority;	/* BUS PRIORITY register */
+	u32			status;
+	u32			init_sensor;		/* initializing sensor */
+	u32			reset_type;		/* External Sensor Reset  Type */
+	u32			reset_udelay;
+	u32			zoom_in_cnt;
+} camif_cis_t;
+
+/* when  App want to change v4l2 parameter,
+ * we instantly store it into v4l2_t v2
+ * and then reflect it to hardware
+ */
+typedef struct v4l2 {
+	struct v4l2_fmtdesc	*fmtdesc;
+	struct v4l2_framebuffer	frmbuf; /* current frame buffer */
+	struct v4l2_input	*input;
+	struct v4l2_output	*output;
+	enum v4l2_status	status;
+
+	/* crop */
+	struct v4l2_rect	crop_bounds;
+	struct v4l2_rect	crop_defrect;
+	struct v4l2_rect	crop_current;
+
+} v4l2_t;
+
+
+typedef struct camif_c_t {
+	struct video_device	*v;
+
+	/* V4L2 param only for v4l2 driver */
+	v4l2_t			v2;
+	camif_cis_t		*cis;			/* Common between Codec and Preview */
+
+	/* logical parameter */
+	wait_queue_head_t	waitq;
+	u32			status; 		/* Start/Stop */
+	u32			fsm;			/* Start/Stop */
+	u32			open_count;		/* duplicated */
+	int			irq;
+	char			shortname[16];
+	u32			target_x;
+	u32			target_y;
+	scaler_t		sc;
+	enum flip_mode		flip;
+	enum image_effect	effect;
+	enum camif_dma_type	dma_type;
+
+	/* 4 pingpong Frame memory */
+	u8			*pp_virt_buf;
+	dma_addr_t		pp_phys_buf;
+	u32			pp_totalsize;
+	u32			pp_num; 		/* used pingpong memory number */
+	img_buf_t		img_buf[4];
+	enum camif_fmt		src_fmt;
+	enum camif_fmt		dst_fmt;
+	enum camif_capturing	capture_enable;
+	camif_perf_t		perf;
+	u32			cur_frame_num;
+	u32			auto_restart;		/* Only For Preview */
+	int			input_channel;
+	int			output_channel;
+	int			buffer_size;
+	void			*other; 		/* other camif_cfg_t */
+	u32			msdma_status;		/* 0 : stop, 1 : start */
+	void __iomem		*regs;
+} camif_cfg_t;
+
+/*  Test Application Usage */
+typedef struct {
+	int src_x;
+	int src_y;
+	int dst_x;
+	int dst_y;
+	int src_fmt;
+	int dst_fmt;
+	int flip;
+	int awb;
+	int effect;
+	int input_channel;
+	int output_channel;
+	unsigned int h_offset;
+	unsigned int v_offset;
+	unsigned int h_offset2;
+	unsigned int v_offset2;
+} camif_param_t;
+
+/* Externs */
+extern camif_cfg_t* s3c_camif_get_fimc_object(int);
+extern int s3c_camif_start_dma(camif_cfg_t *);
+extern int s3c_camif_stop_dma(camif_cfg_t *);
+extern int s3c_camif_get_frame_num(camif_cfg_t *);
+extern unsigned char* s3c_camif_get_frame(camif_cfg_t *);
+extern int s3c_camif_control_fimc(camif_cfg_t *);
+extern void s3c_camif_reset(int, int);
+extern void s3c_camif_init(void);
+extern int s3c_camif_get_fifo_status(camif_cfg_t *);
+extern void s3c_camif_enable_lastirq(camif_cfg_t *);
+extern void s3c_camif_disable_lastirq(camif_cfg_t *);
+extern void s3c_camif_change_flip(camif_cfg_t *);
+extern void s3c_camif_change_effect(camif_cfg_t *);
+extern int s3c_camif_start_codec_msdma(camif_cfg_t *);
+extern int s3c_camif_set_clock(unsigned int camclk);
+extern void s3c_camif_disable_clock(void);
+extern int s3c_camif_start_preview_msdma(camif_cfg_t *);
+extern camif_cis_t* get_initialized_cis(void);
+extern void s3c_camif_clear_irq(int);
+extern int s3c_camif_set_source_format(camif_cis_t *);
+extern void s3c_camif_register_sensor(struct i2c_client *);
+extern void s3c_camif_unregister_sensor(struct i2c_client*);
+extern int s3c_camif_setup_dma(camif_cfg_t *);
+extern void s3c_camif_init_sensor(camif_cfg_t *);
+extern int s3c_camif_set_offset(camif_cis_t *);
+extern void s3c_camif_set_priority(int);
+extern void s3c_camif_open_sensor(camif_cis_t *);
+extern void s3c_camif_set_polarity(camif_cfg_t *cfg);
+
+#endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/samsung/4xa_sensor.c linux-2.6.29-rc3.owrt.om/drivers/media/video/samsung/4xa_sensor.c
--- linux-2.6.29-rc3.owrt/drivers/media/video/samsung/4xa_sensor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/samsung/4xa_sensor.c	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,384 @@
+/*
+ *  Copyright (C) 2004 Samsung Electronics
+ *             SW.LEE <hitchcar@samsung.com>
+ *            - based on Russell King : pcf8583.c
+ * 	      - added  smdk24a0, smdk2440
+ *            - added  poseidon (s3c24a0+wavecom)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Driver for FIMC2.x Camera Decoder
+ *
+ */
+
+//#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+//#define CAMIF_DEBUG
+
+#include "../s3c_camif.h"
+#include "4xa_sensor.h"
+
+
+/*
+ * Samsung's original code:
+ *	.camclk		= 44000000,	/ * for 20 fps: 44MHz, for 12 fps (more
+ *					   stable): 26MHz * /
+ *
+ * Experimenting with the controls yielded the following:
+ *
+ * PLL_CLK gets divided according to TCMD.Div8_r (1,00h) and then by
+ * SEL_MAIN.Half_PCLK_Enable (5,8Fh) until it finally becomes PCLK.
+ *
+ * Div8_r = 0: 1/4, 1: 1/2 (default)
+ * Half_PCLK_Enable = 0: 1/1 (default), 1: 1/2
+ *
+ * Thus our 26.6 MHz MCLK becomes an 87.78 MHz PLL_CLK and eventually a PCLK
+ * of 43.89 MHz.
+ */
+
+#define	CAMCLK	26600000	/* 26.6 MHz */
+
+
+static struct i2c_driver sensor_driver;
+
+/* This is an abstract CIS sensor for MSDMA input. */
+
+camif_cis_t msdma_input = {
+	.itu_fmt	= CAMIF_ITU601,
+	.order422	= CAMIF_CBYCRY,	/* another case: YCRYCB */
+	.camclk		= CAMCLK,
+	.source_x	= 800,
+	.source_y	= 600,
+	.win_hor_ofst	= 0,
+	.win_ver_ofst	= 0,
+	.win_hor_ofst2	= 0,
+	.win_ver_ofst2	= 0,
+	.polarity_pclk	= 0,
+	.polarity_vsync	= 1,
+	.polarity_href	= 0,
+	.reset_type	= CAMIF_EX_RESET_AL,
+	.reset_udelay	= 5000,
+};
+
+camif_cis_t interlace_input = {
+	.itu_fmt	= CAMIF_ITU601,
+	.order422	= CAMIF_CBYCRY,	/* another case: YCRYCB */
+	.camclk		= CAMCLK,
+	.source_x	= 800,
+	.source_y	= 600,
+	.win_hor_ofst	= 0,
+	.win_ver_ofst	= 0,
+	.win_hor_ofst2	= 0,
+	.win_ver_ofst2	= 0,
+	.polarity_pclk	= 0,
+	.polarity_vsync	= 1,
+	.polarity_href	= 0,
+	.reset_type	= CAMIF_EX_RESET_AL,
+	.reset_udelay	= 5000,
+};
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+static camif_cis_t data = {
+	.itu_fmt	= CAMIF_ITU601,
+	.order422	= CAMIF_YCBYCR,
+	.camclk		= CAMCLK,
+	.source_x	= 800,
+	.source_y	= 600,
+	.win_hor_ofst	= 0,
+	.win_ver_ofst	= 0,
+	.win_hor_ofst2	= 0,
+	.win_ver_ofst2	= 0,
+	.polarity_pclk	= 0,
+	.polarity_vsync	= 1,
+	.polarity_href	= 0,
+	.reset_type	= CAMIF_EX_RESET_AL,
+	.reset_udelay	= 5000,
+};
+
+s5k4xa_t s5k4ba_regs_mirror[S5K4BA_REGS];
+#else
+#error No samsung CIS moudule here !
+#endif
+
+camif_cis_t* get_initialized_cis(void)
+{
+	if (data.init_sensor == 0)
+		return NULL;
+
+	return &data;
+}
+
+#define CAM_ID 0x5a
+
+static unsigned short ignore[] = { I2C_CLIENT_END };
+static unsigned short normal_addr[] = { CAM_ID >> 1, I2C_CLIENT_END };
+static const unsigned short *forces[] = { NULL };
+
+static struct i2c_client_address_data addr_data = {
+	.normal_i2c	= normal_addr,
+	.probe		= ignore,
+	.ignore		= ignore,
+	.forces		= forces,
+};
+
+
+static unsigned char sensor_read(struct i2c_client *client,
+    unsigned char subaddr)
+{
+	unsigned char buf = subaddr;
+	struct i2c_msg msg = {
+		.addr	= client->addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &buf,
+	};
+
+	if (i2c_transfer(client->adapter, &msg, 1) != 1) {
+		printk(" I2C write Error\n");
+		return -EIO;
+	}
+
+	msg.flags = I2C_M_RD;
+	if (i2c_transfer(client->adapter, &msg, 1) != 1) {
+		printk(" I2C read Error\n");
+		return -EIO;
+	}
+
+	return buf;
+}
+
+static int
+sensor_write(struct i2c_client *client,
+	     unsigned char subaddr, unsigned char val)
+{
+	unsigned char buf[2];
+	struct i2c_msg msg = {
+		.addr	= client->addr,
+		.flags	= 0,
+		.len	= 2,
+		.buf	= buf,
+	};
+
+	buf[0] = subaddr;
+	buf[1] = val;
+
+	return i2c_transfer(client->adapter, &msg, 1) == 1 ? 0 : -EIO;
+}
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+void inline sensor_init(struct i2c_client *sam_client)
+{
+	int i;
+
+	i = ARRAY_SIZE(s5k4ba_reg);
+	for (i = 0; i < S5K4BA_INIT_REGS; i++)
+		sensor_write(sam_client,
+			     s5k4ba_reg[i].subaddr, s5k4ba_reg[i].value);
+}
+#else
+#error No samsung CIS moudule !
+#endif
+
+static int
+s5k4xa_attach(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *c;
+
+	c = kmalloc(sizeof(*c), GFP_KERNEL);
+	if (!c)
+		return -ENOMEM;
+
+	memset(c, 0, sizeof(struct i2c_client));
+
+	strcpy(c->name, "S5K4XA");
+	c->addr = addr;
+	c->adapter = adap;
+	c->driver = &sensor_driver;
+	i2c_set_clientdata(c, &data);
+	data.sensor = c;
+
+	s3c_camif_register_sensor(c);
+
+	return i2c_attach_client(c);
+}
+
+static int sensor_attach_adapter(struct i2c_adapter *adap)
+{
+	extern void om_3d7k_camera_on(void);
+	extern void om_3d7k_camera_off(void);
+	int ret;
+
+	s3c_camif_open_sensor(&data);
+
+	om_3d7k_camera_on();
+	ret = i2c_probe(adap, &addr_data, s5k4xa_attach);
+	om_3d7k_camera_off();
+	return ret;
+}
+
+static int sensor_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+	s3c_camif_unregister_sensor(client);
+	return 0;
+}
+
+/*
+ * Purpose:
+ * This function only for SVGA Camera : 4BA
+ */
+
+static int change_sensor_size(struct i2c_client *client, int size)
+{
+	int i;
+
+	switch (size) {
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+	case SENSOR_QSVGA:
+		for (i = 0; i < S5K4BA_QSVGA_REGS; i++)
+			sensor_write(client, s5k4ba_reg_qsvga[i].subaddr,
+				     s5k4ba_reg_qsvga[i].value);
+		break;
+
+	case SENSOR_SVGA:
+		for (i = 0; i < S5K4BA_SVGA_REGS; i++)
+			sensor_write(client, s5k4ba_reg_svga[i].subaddr,
+				     s5k4ba_reg_svga[i].value);
+		break;
+#else
+#error No samsung CIS moudule !
+#endif
+	default:
+		panic("4xa_sensor.c: unexpect value\n");
+	}
+
+	return 0;
+}
+
+static int change_sensor_wb(struct i2c_client *client, int type)
+{
+	printk("[ *** Page 0, 4XA Sensor White Balance Mode ***]\n");
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+	sensor_write(client, 0xFC, 0x0);
+	sensor_write(client, 0x30, type);
+#endif
+
+	switch(type){
+	case 0:
+	default:
+		printk(" -> AWB auto mode ]\n");
+		break;
+	case 1:
+		printk(" -> Indoor 3100 mode ]\n");
+		break;
+	case 2:
+		printk(" -> Outdoor 5100 mode ]\n");
+		break;
+	case 3:
+		printk(" -> Indoor 2000 mode ]\n");
+		break;
+	case 4:
+		printk(" -> AE/AWB halt ]\n");
+		break;
+	case 5:
+		printk(" -> Cloudy(6000) mode ]\n");
+		break;
+	case 6:
+		printk(" -> Sunny(8000) mode ]\n");
+		break;
+	}
+
+	return 0;
+}
+
+static int
+sensor_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	switch (cmd) {
+	case SENSOR_INIT:
+		sensor_init(client);
+		printk(KERN_INFO "External Camera initialized\n");
+		break;
+
+	case USER_ADD:
+		break;
+
+	case USER_EXIT:
+		break;
+
+	case SENSOR_QSVGA:
+		change_sensor_size(client, SENSOR_QSVGA);
+		break;
+
+	case SENSOR_VGA:
+		change_sensor_size(client, SENSOR_VGA);
+		break;
+
+	case SENSOR_SVGA:
+		change_sensor_size(client, SENSOR_SVGA);
+		break;
+
+	case SENSOR_SXGA:
+		change_sensor_size(client, SENSOR_SXGA);
+		break;
+
+	case SENSOR_UXGA:
+		change_sensor_size(client, SENSOR_UXGA);
+		break;
+/* Todo
+	case SENSOR_BRIGHTNESS:
+		change_sensor_setting();
+		break;
+*/
+	case SENSOR_WB:
+		printk("[ *** 4XA Sensor White Balance , No mode ***]\n");
+		change_sensor_wb(client, (int) arg);
+		break;
+
+	default:
+		panic("4xa_sensor.c: Unexpected Sensor Command\n");
+		break;
+	}
+
+	return 0;
+}
+
+static struct i2c_driver sensor_driver = {
+	.driver = {
+		.name = "s5k4xa",
+	},
+	.id = I2C_DRIVERID_S5K_4XA,
+	.attach_adapter = sensor_attach_adapter,
+	.detach_client = sensor_detach,
+	.command = sensor_command
+};
+
+static __init int camif_sensor_init(void)
+{
+	return i2c_add_driver(&sensor_driver);
+}
+
+
+static __init void camif_sensor_exit(void)
+{
+	i2c_del_driver(&sensor_driver);
+}
+
+module_init(camif_sensor_init)
+module_exit(camif_sensor_exit)
+
+MODULE_AUTHOR("Jinsung, Yang <jsgood.yang@samsung.com>");
+MODULE_DESCRIPTION("I2C Client Driver For FIMC V4L2 Driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/samsung/4xa_sensor.h linux-2.6.29-rc3.owrt.om/drivers/media/video/samsung/4xa_sensor.h
--- linux-2.6.29-rc3.owrt/drivers/media/video/samsung/4xa_sensor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/samsung/4xa_sensor.h	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,2412 @@
+#ifndef _SAMSUNG_SXGA_H_
+#define _SAMSUNG_SXGA_H_
+
+/******************************************************************************
+ *  Display resolution standards
+ *
+ *	QCIF: 176 x 144
+ *	CIF: 352 x 288
+ *	QVGA: 320 x 240
+ *	VGA: 640 x 480
+ *	SVGA: 800 x 600
+ *	XGA: 1024 x 768
+ *	WXGA: 1280 x 800
+ *	QVGA: 1280 x 960
+ *	SXGA: 1280 x 1024
+ *	SXGA+: 1400 x 1050
+ *	WSXGA+: 1680 x 1050
+ *	UXGA: 1600 x 1200
+ *	WUXGA: 1920 x 1200
+ *	QXGA: 2048 x 1536
+ *****************************************************************************/
+
+//#include "../bits.h"
+
+/*
+ * Camera information
+ * FPC Label : Samsung MEGA Pixel Camera : V4220 REV06
+ * Modified by charles -Initial function of '3AA' test routine
+ * Modified and tested by YongHwui.Kim <yonghwui.kim@samsung.com> for S5K3AAEX
+ * Camera
+ */
+
+#define CHIP_DELAY 0xFF
+
+typedef struct samsung_t{
+        unsigned char subaddr;
+        unsigned char value;
+        unsigned char page;
+} s5k4xa_t;
+
+#ifdef CONFIG_CPU_S3C24A0A
+#define TRY_HIGH_CLOCK 1
+#endif
+
+/***************************************************
+ *  name: 	S5K3AAEX EVT2 setfile
+ *  ver:		v2.61
+ *  history:
+ *	v0.0	start from 040908 setfile
+ *	v1.0	arange register
+ *	v1.01	change MCLK(25Mhz) and Frame rate(7fps)
+ *	v2.0	adjust register setting for 3AA EVT2
+ *		- color correction, RGB shading off, hsync start position,
+ *		   Mirror, fps
+ *		- Color Tuning, YGRPDLY
+ *	v2.1	change Frame rate(7.5fps) and Total gain to x4
+ *		(because of reducing visual noise at low illumination)
+ *		- change BPRM AGC Max and FrameAE start
+ *		improve AE speed
+ *	v2.2	modify AWB G gain and solve 50hz flicker detection fail in
+ *		25MHz 7.5fps
+ *	v2.3	Adjust gamma, Dark Slice, white point, Hue gain,
+ *		White Balance B control, Y gain On, Digital Clamp On
+ *		lower AWB G gain
+ *	v2.4	Adjust AE window weight, Y Gamma, WhitePoint, Shading and BPR
+ *		Max Thres.
+ * 	v2.41	Adjust AE/AWB window and AWB internal window boundary to
+ *		decrease skin color tracking
+ * 	v2.411	special version for PSCDS
+ * 	v2.412	RGB shading off
+ *	v2.5	Lens change STW to Sekonix
+ *		adjust White point and Y shading Coef (RGB shading off)
+ *	v2.6	New Tuning because of Full YC off and YCbCr Coef change
+ *		Gamma, Dark Slice, color matrix (not use), Color suppress
+ *		R Gain and DBPR agc MIN/MAX
+ *	v2.61	VCK inversion(data rising)
+ ****************************************************/
+
+#if defined(CONFIG_VIDEO_SAMSUNG_S5K4BA)
+
+/* For SVGA (800 x 600) */
+#if 1 /* from han */
+s5k4xa_t s5k4ba_reg[] =
+{
+	{0xfc,0x07},
+	{0x66,0x01},    /* Watch Dog Time On */
+	{0xfc,0x00},
+	{0x00,0xAA},	/* For EDS Check */
+	{0x21,0x03},	/* peter */
+	{0xfc,0x01},
+	{0x04,0x01},	/* ARM Clock Divider */
+
+	{0xfc,0x02},
+	{0x30,0x90},	/* Analog offset */
+	{0x37,0x0d}, 	/* Global Gain */
+	{0x2d,0x48},	/* Double Shutter */
+	{0x60,0x00},	/* Blank_Adrs */
+
+	{0x45,0x1e},	/* 0e -  CDS Timing for Average Sub_Sampling */
+	{0x47,0x2f},
+	{0x02,0x0e},	/* ADC Resolution */
+	{0x3d,0x06},	/* Frame ADLC */
+	{0x4d,0x08},	/* Doubler Volatage */
+	{0x54,0x02},	/* Double Shutter */
+	{0x55,0x1e},	/* Line ADLC */
+	{0x56,0x30},
+	{0x59,0x00},	/* LineADLC offset */
+	{0x5b,0x08},	/* R_Ref_Ctrl */
+	{0x44,0x63},	/* CLP_EN */
+	{0x4A,0x10},	/* Clamp Control */
+	{0x42,0x02},
+	{0x43,0xef},
+
+	/*
+	 * Table Set for Sub-Sampling
+	 */
+
+	{0xfc,0x03},
+	{0x2c,0x00},	/* crcb_sel for Sub-Sampling Table */
+	{0x05,0x46},	/* Output Image Size Set for Capture */
+	{0x07,0xb6},
+	{0x0e,0x04},
+	{0x12,0x03},
+
+	{0xfc,0x04},
+	{0x32,0x04},
+	{0x33,0xbc},
+
+	{0xfc,0x04},
+	{0xc5,0x26},	/* Output Image Size Set for Preview */
+	{0xc7,0x5e},
+	{0xce,0x04},
+	{0xd2,0x04},
+
+	{0xec,0x06},	/* CrCb sel = YCBYCR(0x06) by jsgood */
+	{0xc0,0x06},
+	{0xc1,0x70},
+	{0xc2,0x02},
+	{0xc3,0x87},
+
+	{0xfc,0x07},
+	{0x05,0x00},
+	{0x06,0x00},
+	{0x07,0x8b},
+	{0x08,0xf5},
+	{0x09,0x00},
+	{0x0a,0xb4},
+	{0x0b,0x00},
+	{0x0c,0xea},
+	{0x0d,0x00},
+	{0x0e,0x40},
+
+	{0xfc,0x00},
+	{0x70,0x02},
+
+	/* Jeongyun added still shot cbcr_sel */
+	{0xfc,0x03},
+	{0x2c,0x00},
+	{0x5c,0x00},
+	{0x8c,0x00},
+	{0xbc,0x00},
+	{0xfc,0x04},
+	{0x5c,0x00},
+
+	/*
+	 * COMMAND SET
+	 */
+
+	{0xfc,0x00},
+	{0x73,0x21},	/* Frame AE Enable peter */
+	{0x20,0x02},	/* Change AWB Mode */
+
+	{0xfc,0x00},
+	{0x6c,0xb0},	/* AE target */
+	{0x6d,0x00},
+
+	{0xfc,0x20},
+	{0x16,0x5a},	/* for Prevating AE Hunting */
+
+	{0xfc,0x00},
+	{0x78,0x6a},	/* AGC Max */
+	{0xfc,0x20},
+	{0x16,0x60},	/* Frame AE Start */
+
+	{0xfc,0x20},
+	{0x57,0x18},	/* Stable_Frame_AE */
+	{0x2C,0x30},	/* For Forbidden Area */
+	{0x2E,0x00},	/* For Forbidden Area */
+	{0x14,0x70},
+	{0x01,0x00},	/* Stepless_Off */
+
+	{0xfc,0x07},
+	{0x11,0x02},	/* AWB G Gain offset */
+
+	{0xfc,0x07},
+	{0x3e,0x0a},	/* AWB Cut R max */
+
+	{0xfc,0x01},
+	{0xc8,0xd0},	/* AWB Y Max */
+	{0xfc,0x00},
+	{0x3e,0x20},	/* 30 - AWB Y_min */
+	{0x3d,0x10},	/* AWB Y_min Low */
+	{0xfc,0x22},
+	{0x8c,0x04},	/* AWB Min Y Weight AWB */
+	{0x8d,0x16},	/* AWB Max Y Weight */
+
+	{0xfc,0x00},
+	{0x32,0x04},	/* AWB moving average 8 frame */
+	{0x81,0x10},	/* AWB G gain suppress Disable */
+	{0xbc,0xf0},
+
+	{0x29,0x04},	/* Y level H */
+	{0x2a,0x00},	/* Y level L */
+	{0x2b,0x03},	/* color level H */
+	{0x2c,0xc8},	/* color level L */
+
+	{0xfc,0x07},
+	{0x37,0x00},	/* Flicker Add for 32 MHz */
+	{0xfc,0x00},
+	{0x72,0xa0},	/* Flicker for 32 MHz */
+	{0x74,0x08},	/* flicker 60 Hz Fix */
+
+	{0xfc,0x20},
+	{0x02,0x02},	/* Flicker Dgain Mode */
+
+	{0xfc,0x00},
+	//{0x23,0x40},  /* Mirror Option */
+	{0x62,0x0a},	/* Mirror Option */
+
+	{0xfc,0x02},
+	{0x4e,0x1b},	/* Enable SDA and SCL pull-up; drive 8 mA */
+	{0x4f,0xf0},	/* PCLK and YC: 8 mA, AF and ZM (AZ): 2 mA */
+
+	{0xfc,0x01},
+	{0x0c,0x03},	/* Full YC Enable */
+	//{0x0c,03},	/* Full YC Enable */
+	//{0x02,02},	/* crcb_sel */
+	//{0x02,02},	/* crcb_sel  peter */
+	//{0x01,01},	/* pclk      peter */
+	//{0x01,01},
+
+	/*
+	 * COLOR MATRIX
+	 */
+
+	{0xfc,0x01},	/* color matrix */
+	{0x51,0x0A},
+	{0x52,0x42},
+	{0x53,0xF9},
+	{0x54,0x80},
+	{0x55,0x00},
+	{0x56,0x3D},
+
+	{0x57,0xFE},
+	{0x58,0x0B},
+	{0x59,0x06},
+	{0x5A,0x9C},
+	{0x5B,0xFF},
+	{0x5C,0x59},
+
+	{0x5D,0xFF},
+	{0x5E,0xD8},
+	{0x5F,0xFC},
+	{0x60,0x2E},
+	{0x61,0x07},
+	{0x62,0xFA},
+
+	/*
+	 * EDGE ENHANCEMENT
+	 */
+
+	{0xfc,0x00},
+	{0x89,0x03},	/* Edge Suppress On */
+	{0xfc,0x0b},
+	{0x42,0x50},	/* Edge AGC MIN */
+	{0x43,0x60},	/* Edge AGC MAX */
+	{0x45,0x18},	/* positive gain AGC MIN */
+	{0x49,0x0a},	/* positive gain AGC MAX */
+	{0x4d,0x18},	/* negative gain AGC MIN */
+	{0x51,0x0a},	/* negative gain AGC MAX */
+
+	{0xfc,0x05},
+	{0x34,0x20},	/* APTCLP */
+	{0x35,0x09},	/* APTSC */
+	{0x36,0x0b},	/* ENHANCE */
+	{0x3f,0x00},	/* NON-LIN */
+	{0x42,0x10},	/* EGFALL */
+	{0x43,0x00},	/* HLFALL */
+	{0x45,0xa0},	/* EGREF */
+	{0x46,0x7a},	/* HLREF */
+	{0x47,0x40},	/* LLREF */
+	{0x48,0x0c},
+	{0x49,0x31},	/* CSSEL  EGSEL  CS_DLY */
+
+	{0x40,0x41},	/* Y delay */
+
+	/*
+	 * GAMMA
+	 */
+
+	{0xfc,0x01},
+
+	{0x6F,0x0A},	/* R */
+	{0x70,0x1A},
+	{0x71,0x7A},
+	{0x72,0xF8},
+	{0x73,0x00},
+
+	{0x74,0xA0},
+	{0x75,0x18},
+	{0x76,0x65},
+	{0x77,0xAD},
+	{0x78,0x6A},
+
+	{0x79,0xE2},
+	{0x7A,0x12},
+	{0x7B,0x3D},
+	{0x7C,0x5A},
+	{0x7D,0xBF},
+
+	{0x7E,0x72},
+	{0x7F,0x88},
+	{0x80,0x9D},
+	{0x81,0xB0},
+	{0x82,0xFF},
+
+	{0x83,0xC0},
+	{0x84,0xCF},
+	{0x85,0xDA},
+	{0x86,0xFC},
+
+	{0x87,0x08},	/* G */
+	{0x88,0x12},
+	{0x89,0x42},
+	{0x8A,0xBA},
+	{0x8B,0x00},
+
+	{0x8C,0x75},
+	{0x8D,0xED},
+	{0x8E,0x42},
+	{0x8F,0x80},
+	{0x90,0x5A},
+
+	{0x91,0xB5},
+	{0x92,0xE5},
+	{0x93,0x10},
+	{0x94,0x35},
+	{0x95,0xAF},
+
+	{0x96,0x55},
+	{0x97,0x70},
+	{0x98,0x88},
+	{0x99,0x9D},
+	{0x9A,0xFF},
+
+	{0x9B,0xB1},
+	{0x9C,0xC4},
+	{0x9D,0xD5},
+	{0x9E,0xFC},
+
+	{0x9F,0x05},	/* B */
+	{0xA0,0x18},
+	{0xA1,0x42},
+	{0xA2,0xd7},
+	{0xA3,0x00},
+
+	{0xA4,0xB6},
+	{0xA5,0x3b},
+	{0xA6,0x88},
+	{0xA7,0xC8},
+	{0xA8,0x6A},
+
+	{0xA9,0x00},
+	{0xAA,0x30},
+	{0xAB,0x58},
+	{0xAC,0x78},
+	{0xAD,0xFF},
+
+	{0xAE,0x90},
+	{0xAF,0xA5},
+	{0xB0,0xB6},
+	{0xB1,0xC5},
+	{0xB2,0xFF},
+
+	{0xB3,0xD0},
+	{0xB4,0xD6},
+	{0xB5,0xDA},
+	{0xB6,0xFC},
+
+	/*
+	 * HUE CONTROL
+	 */
+
+	{0xfc,0x00},
+	{0x48,0x34},	/* 2000K */
+	{0x49,0x34},
+	{0x4a,0xf4},
+	{0x4b,0x00},
+	{0x4c,0x44},
+	{0x4d,0x3c},
+	{0x4e,0xf0},
+	{0x4f,0x0c},
+
+	{0x50,0x34},	/* 3000K */
+	{0x51,0x34},
+	{0x52,0xf4},
+	{0x53,0x00},
+	{0x54,0x44},
+	{0x55,0x3c},
+	{0x56,0xf0},
+	{0x57,0x0c},
+
+	{0x58,0x34},	/* 5100K */
+	{0x59,0x30},
+	{0x5a,0x00},
+	{0x5b,0x04},
+	{0x5c,0x40},
+	{0x5d,0x2c},
+	{0x5e,0xfc},
+	{0x5f,0x04},
+
+	/*
+	 * UPPRE0x0x FUNCTION
+	 */
+
+	{0xfc,0x00},
+	{0x7e,0xf4},
+
+	/*
+	 * BPR
+	 */
+
+	{0xfc,0x01},
+	{0x3d,0x10},
+
+	{0xfc,0x0b},
+	{0x0b,0x00},	/* ISP BPR On start */
+	{0x0c,0x20},	/* Th13 AGC Min */
+	{0x0d,0x40},	/* Th13 AGC Max */
+	{0x0e,0x00},	/* Th1 Max H for AGCMIN */
+	{0x0f,0x20},	/* Th1 Max L for AGCMIN */
+	{0x10,0x00},	/* Th1 Min H for AGCMAX */
+	{0x11,0x10},	/* Th1 Min L for AGCMAX */
+	{0x12,0x00},	/* Th3 Max H for AGCMIN */
+	{0x13,0x00},	/* Th3 Max L for AGCMIN */
+	{0x14,0xff},	/* Th3 Min H for AGCMAX */
+	{0x15,0xff},	/* Th3 Min L for AGCMAX */
+	{0x16,0x20},	/* Th57 AGC Min */
+	{0x17,0x40},	/* Th57 AGC Max */
+	{0x18,0x00},	/* Th5 Max H for AGCMIN */
+	{0x19,0x00},	/* Th5 Max L for AGCMIN */
+	{0x1a,0x00},	/* Th5 Min H for AGCMAX */
+	{0x1b,0x20},	/* Th5 Min L for AGCMAX */
+	{0x1c,0x00},	/* Th7 Max H for AGCMIN */
+	{0x1d,0x00},	/* Th7 Max L for AGCMIN */
+	{0x1e,0x00},	/* Th7 Min H for AGCMAX */
+	{0x1f,0x20},	/* Th7 Min L for AGCMAX */
+
+	/*
+	 * GR/GB CORRECTION
+	 */
+
+	{0xfc,0x01},
+	{0x45,0x0c},
+
+	{0xfc,0x0b},
+	{0x21,0x00},	/* start AGC */
+	{0x22,0x18},	/* AGCMIN */
+	{0x23,0x58},	/* AGCMAX */
+	{0x24,0x0d}, 	/* G Th AGCMIN */
+	{0x25,0x30}, 	/* G Th AGCMAX */
+	{0x26,0x0d}, 	/* RB Th AGCMIN */
+	{0x27,0x30}, 	/* RB Th AGCMAX */
+
+	/*
+	 * NR
+	 */
+
+	{0xfc,0x01},
+	{0x4C,0x01},	/* NR Enable */
+	{0x49,0x15},	/* Sig_Th Mult */
+	{0x4B,0x0A},	/* Pre_Th Mult */
+
+	{0xfc,0x0b},
+	{0x28,0x00},	/* NR start AGC */
+	{0x29,0x00},	/* SIG Th AGCMIN H */
+	{0x2a,0x14},	/* SIG Th AGCMIN L */
+	{0x2b,0x00},	/* SIG Th AGCMAX H */
+	{0x2c,0x14},	/* SIG Th AGCMAX L */
+	{0x2d,0x00},	/* PRE Th AGCMIN H */
+	{0x2e,0x90},	/* PRE Th AGCMIN L */
+	{0x2f,0x01},	/* PRE Th AGCMAX H */
+	{0x30,0x00},	/* PRE Th AGCMAX L */
+	{0x31,0x00},	/* POST Th AGCMIN H */
+	{0x32,0xa0},	/* POST Th AGCMIN L */
+	{0x33,0x01},	/* POST Th AGCMAX H */
+	{0x34,0x10},	/* POST Th AGCMAX L */
+
+	/*
+	 * 1D-Y/C-SIGMA-LPF
+	 */
+
+	{0xfc,0x01},
+	{0x05,0xc0},
+
+	{0xfc,0x0b},
+	{0x35,0x00},	/* YLPF start AGC */
+	{0x36,0x40},	/* YLPF01 AGCMIN */
+	{0x37,0x60},	/* YLPF01 AGCMAX */
+	{0x38,0x00},	/* YLPF SIG01 Th AGCMINH */
+	{0x39,0x18},	/* YLPF SIG01 Th AGCMINL */
+	{0x3a,0x00},	/* YLPF SIG01 Th AGCMAXH */
+	{0x3b,0x40},	/* YLPF SIG01 Th AGCMAXH */
+	{0x3c,0x50},	/* YLPF02 AGCMIN */
+	{0x3d,0x60},	/* YLPF02 AGCMAX */
+	{0x3e,0x00},	/* YLPF SIG02 Th AGCMINH */
+	{0x3f,0x30},	/* YLPF SIG02 Th AGCMINL */
+	{0x40,0x00},	/* YLPF SIG02 Th AGCMAXH */
+	{0x41,0x40},	/* YLPF SIG02 Th AGCMAXH */
+	{0xd4,0x40},	/* CLPF AGCMIN */
+	{0xd5,0x60},	/* CLPF AGCMAX */
+	{0xd6,0xb0},	/* CLPF SIG01 Th AGCMIN */
+	{0xd7,0xf0},	/* CLPF SIG01 Th AGCMAX */
+	{0xd8,0xb0},	/* CLPF SIG02 Th AGCMIN */
+	{0xd9,0xf0},	/* CLPF SIG02 Th AGCMAX */
+
+	/*
+	 * COLOR SUPPRESS
+	 */
+
+	{0xfc,0x0b},
+	{0x08,0x58},	/* Color suppress AGC MIN */
+	{0x09,0x03},	/* Color suppress MIN H */
+	{0x0a,0x80},	/* Color suppress MIN L */
+
+	/*
+	 * SHADING
+	 */
+
+	{0xfc,0x09},
+	 //Shading file for 3BAFX
+	//s90000// shading off
+	// DSP9_SH_WIDTH_H
+	{0x01,0x06},
+	{0x02,0x40},
+	// DSP9_SH_HEIGHT_H
+	{0x03,0x04},
+	{0x04,0xB0},
+	// DSP9_SH_XCH_R
+	{0x05,0x03},
+	{0x06,0x1A},
+	{0x07,0x02},
+	{0x08,0x4E},
+	// DSP9_SH_XCH_G
+	{0x09,0x03},
+	{0x0A,0x27},
+	{0x0B,0x02},
+	{0x0C,0x11},
+	// DSP9_SH_XCH_B
+	{0x0D,0x03},
+	{0x0E,0x15},
+	{0x0F,0x01},
+	{0x10,0xE3},
+	// DSP9_SH_Del_eH_R
+	{0x1D,0x85},
+	{0x1E,0x55},
+	{0x1F,0x77},
+	{0x20,0x9E},
+	{0x23,0x7F},
+	{0x24,0xE6},
+	{0x21,0x7F},
+	{0x22,0xE6},
+	// DSP9_SH_Del_eH_G
+	{0x25,0x82},
+	{0x26,0x9A},
+	{0x27,0x78},
+	{0x28,0xC0},
+	{0x2B,0x76},
+	{0x2C,0x07},
+	{0x29,0x86},
+	{0x2A,0x09},
+	// DSP9_SH_Del_eH_B
+	{0x2D,0x85},
+	{0x2E,0x55},
+	{0x2F,0x75},
+	{0x30,0x6D},
+	{0x33,0x74},
+	{0x34,0xA2},
+	{0x31,0x84},
+	{0x32,0xA2},
+	// DSP9_SH_VAL_R0H
+	{0x35,0x01},
+	{0x36,0x01},
+	{0x37,0x01},
+	{0x38,0x14},
+	{0x39,0x01},
+	{0x3A,0x45},
+	{0x3B,0x01},
+	{0x3C,0x8A},
+	{0x3D,0x01},
+	{0x3E,0xA3},
+	{0x3F,0x01},
+	{0x40,0xB9},
+	{0x41,0x01},
+	{0x42,0xD9},
+	{0x43,0x01},
+	{0x44,0xF6},
+	// DSP9_SH_VAL_G0H
+	{0x45,0x01},
+	{0x46,0x00},
+	{0x47,0x01},
+	{0x48,0x0E},
+	{0x49,0x01},
+	{0x4A,0x34},
+	{0x4B,0x01},
+	{0x4C,0x68},
+	{0x4D,0x01},
+	{0x4E,0x76},
+	{0x4F,0x01},
+	{0x50,0x94},
+	{0x51,0x01},
+	{0x52,0xAB},
+	{0x53,0x01},
+	{0x54,0xC3},
+	// DSP9_SH_VAL_B0H
+	{0x55,0x01},
+	{0x56,0x00},
+	{0x57,0x01},
+	{0x58,0x0C},
+	{0x59,0x01},
+	{0x5A,0x2B},
+	{0x5B,0x01},
+	{0x5C,0x5D},
+	{0x5D,0x01},
+	{0x5E,0x70},
+	{0x5F,0x01},
+	{0x60,0x8A},
+	{0x61,0x01},
+	{0x62,0xA1},
+	{0x63,0x01},
+	{0x64,0xB3},
+	// DSP9_SH_M_R2_R1H
+	{0x65,0x00},
+	{0x66,0x98},
+	{0x67,0x2C},
+	{0x68,0x02},
+	{0x69,0x60},
+	{0x6A,0xB0},
+	{0x6B,0x05},
+	{0x6C,0x59},
+	{0x6D,0x8C},
+	{0x6E,0x07},
+	{0x6F,0x48},
+	{0x70,0x1B},
+	{0x71,0x09},
+	{0x72,0x82},
+	{0x73,0xC0},
+	{0x74,0x0C},
+	{0x75,0x09},
+	{0x76,0x7B},
+	{0x77,0x0E},
+	{0x78,0xDC},
+	{0x79,0x4D},
+	// DSP9_SH_M_R2_G1H
+	{0x7A,0x00},
+	{0x7B,0xAD},
+	{0x7C,0x76},
+	{0x7D,0x02},
+	{0x7E,0xB5},
+	{0x7F,0xD7},
+	{0x80,0x06},
+	{0x81,0x19},
+	{0x82,0x23},
+	{0x83,0x08},
+	{0x84,0x4C},
+	{0x85,0xE2},
+	{0x86,0x0A},
+	{0x87,0xD7},
+	{0x88,0x5C},
+	{0x89,0x0D},
+	{0x8A,0xB8},
+	{0x8B,0x90},
+	{0x8C,0x10},
+	{0x8D,0xF0},
+	{0x8E,0x7F},
+	// DSP9_SH_M_R2_B1H
+	{0x8F,0x00},
+	{0x90,0xC1},
+	{0x91,0xD0},
+	{0x92,0x03},
+	{0x93,0x07},
+	{0x94,0x3F},
+	{0x95,0x06},
+	{0x96,0xD0},
+	{0x97,0x4F},
+	{0x98,0x09},
+	{0x99,0x46},
+	{0x9A,0x32},
+	{0x9B,0x0C},
+	{0x9C,0x1C},
+	{0x9D,0xFE},
+	{0x9E,0x0F},
+	{0x9F,0x54},
+	{0xA0,0xB1},
+	{0xA1,0x12},
+	{0xA2,0xED},
+	{0xA3,0x4C},
+	// DSP9_SH_SUB_RR0H
+	{0xA4,0x6B},
+	{0xA5,0xAA},
+	{0xA6,0x23},
+	{0xA7,0xE3},
+	{0xA8,0x15},
+	{0xA9,0x88},
+	{0xAA,0x21},
+	{0xAB,0x20},
+	{0xAC,0x1C},
+	{0xAD,0xB6},
+	{0xAE,0x19},
+	{0xAF,0x55},
+	{0xB0,0x16},
+	{0xB1,0xAA},
+	// DSP9_SH_SUB_RG0H
+	{0xB2,0x5E},
+	{0xB3,0x74},
+	{0xB4,0x1F},
+	{0xB5,0x7C},
+	{0xB6,0x12},
+	{0xB7,0xE4},
+	{0xB8,0x1D},
+	{0xB9,0x10},
+	{0xBA,0x19},
+	{0xBB,0x30},
+	{0xBC,0x16},
+	{0xBD,0x39},
+	{0xBE,0x13},
+	{0xBF,0xE2},
+	// DSP9_SH_SUB_RB0H
+	{0xC0,0x54},
+	{0xC1,0x89},
+	{0xC2,0x1C},
+	{0xC3,0x2D},
+	{0xC4,0x10},
+	{0xC5,0xE8},
+	{0xC6,0x1A},
+	{0xC7,0x02},
+	{0xC8,0x16},
+	{0xC9,0x8A},
+	{0xCA,0x13},
+	{0xCB,0xE4},
+	{0xCC,0x11},
+	{0xCD,0xCC},
+
+	{0x00,0x02},  // Shading on
+
+	//==========================================================
+	//	X-SHADING
+	//==========================================================
+	{0xfc,0x1B},
+	{0x80,0x01},
+	{0x81,0x00},
+	{0x82,0x4C},
+	{0x83,0x00},
+	{0x84,0x86},
+	{0x85,0x03},
+	{0x86,0x5E},
+	{0x87,0x00},
+	{0x88,0x07},
+	{0x89,0xA4},
+	{0x90,0x00},
+	{0x91,0x12},
+	{0x92,0x00},
+	{0x93,0x12},
+	{0x94,0x00},
+	{0x95,0x12},
+	{0x96,0x00},
+	{0x97,0x12},
+	{0x98,0x00},
+	{0x99,0x12},
+	{0x9A,0x00},
+	{0x9B,0x12},
+	{0x9C,0x00},
+	{0x9D,0x12},
+	{0x9E,0x00},
+	{0x9F,0x12},
+	{0xA0,0x00},
+	{0xA1,0x12},
+	{0xA2,0x00},
+	{0xA3,0x12},
+	{0xA4,0x00},
+	{0xA5,0x12},
+	{0xA6,0x00},
+	{0xA7,0x12},
+	{0xA8,0x00},
+	{0xA9,0x12},
+	{0xAA,0x00},
+	{0xAB,0x12},
+	{0xAC,0x00},
+	{0xAD,0x12},
+	{0xAE,0x00},
+	{0xAF,0x12},
+	{0xB0,0x00},
+	{0xB1,0x12},
+	{0xB2,0x00},
+	{0xB3,0x12},
+	{0xB4,0x00},
+	{0xB5,0x12},
+	{0xB6,0x00},
+	{0xB7,0x15},
+	{0xB8,0x00},
+	{0xB9,0x12},
+	{0xBA,0x00},
+	{0xBB,0x12},
+	{0xBC,0x00},
+	{0xBD,0x12},
+	{0xBE,0x00},
+	{0xBF,0x12},
+	{0xC0,0x00},
+	{0xC1,0x12},
+	{0xC2,0x00},
+	{0xC3,0x12},
+	{0xC4,0x00},
+	{0xC5,0x12},
+	{0xC6,0x00},
+	{0xC7,0x12},
+	{0xC8,0x00},
+	{0xC9,0x12},
+	{0xCA,0x00},
+	{0xCB,0x12},
+	{0xCC,0x00},
+	{0xCD,0x12},
+	{0xCE,0x00},
+	{0xCF,0x12},
+	{0xD0,0x00},
+	{0xD1,0x12},
+	{0xD2,0x00},
+	{0xD3,0x12},
+	{0xD4,0x00},
+	{0xD5,0x12},
+		 // x-shading temp. correlation factor
+	{0xfc,0x0b},
+	{0xda,0x00},	// t0(3100K)
+	{0xdb,0xac},
+	{0xdc,0x01},	// tc(5100K)
+	{0xdd,0x30},	// default eeh
+
+	{0xfc,0x00},
+	{0x81,0x10}, 	// xshading tem
+
+	{0xfc,0x1b},
+	{0x80,0x01},	// X-Shading On
+
+	//==========================================================
+	//	AE WINDOW WEIGHT
+	//==========================================================
+	{0xfc,0x00},
+	{0x03,0x4b},	// AE Suppress On
+
+	{0xfc,0x06},
+	{0x01,0x35},	// UXGA AE Window
+	{0x03,0xc2},
+	{0x05,0x48},
+	{0x07,0xb8},
+	{0x31,0x2a},	// Subsampling AE Window
+	{0x33,0x61},
+	{0x35,0x28},
+	{0x37,0x5c},
+	{0x39,0x28},
+	{0x3B,0x5A},
+	{0x3D,0x10},	// 1c
+	{0x3F,0x44},
+
+	{0xfc,0x20},
+	{0x60,0x11},
+	{0x61,0x11},
+	{0x62,0x11},
+	{0x63,0x11},
+	{0x64,0x11},
+	{0x65,0x22},
+	{0x66,0x22},
+	{0x67,0x11},
+	{0x68,0x11},
+	{0x69,0x33},
+	{0x6a,0x33},
+	{0x6b,0x11},
+	{0x6c,0x12},
+	{0x6d,0x55},
+	{0x6e,0x55},
+	{0x6f,0x21},
+	{0x70,0x13},
+	{0x71,0x55},
+	{0x72,0x55},
+	{0x73,0x31},
+	{0x74,0x33},
+	{0x75,0x33},
+	{0x76,0x33},
+	{0x77,0x33},
+
+	//==========================================================
+	//	SAIT AWB
+	//==========================================================
+	//=================================
+	// White Point
+	//=================================
+	{0xfc,0x22},	// White Point (For Hue Control & MWB)
+	{0x01,0xD0},	// D65
+	{0x03,0x9B},
+	{0x05,0xC0},	// 5000K
+	{0x07,0xB8},
+	{0x09,0xA7},	// CWF
+	{0x0b,0xDC},
+	{0x0d,0x98},	// 3000K
+	{0x0f,0xE0},
+	{0x11,0x85},	// A
+	{0x12,0x00},
+	{0x13,0xF6},
+	{0x15,0x80},	// 2000K
+	{0x16,0x01},
+	{0x17,0x00},
+
+	//=================================
+	// Basic Setting
+	//=================================
+	{0xfc,0x22},
+	{0xA0,0x01},
+	{0xA1,0x3F},
+	{0xA2,0x0E},
+	{0xA3,0x65},
+	{0xA4,0x07},
+	{0xA5,0xF4},
+	{0xA6,0x11},
+	{0xA7,0xC8},
+	{0xA9,0x02},
+	{0xAA,0x43},
+	{0xAB,0x26},
+	{0xAC,0x1F},
+	{0xAD,0x02},
+	{0xAE,0x2C},
+	{0xAF,0x19},
+	{0xB0,0x0F},
+
+	{0x94,0x3C},
+	{0x95,0xCC},
+	{0x96,0x5C},
+	{0x97,0x4D},
+	{0xD0,0xA8},
+	{0xD1,0x29},
+	{0xD2,0x39},
+	{0xD3,0x22},
+	{0xD4,0x30},
+	{0xDB,0x29},
+	{0xDC,0x7E},
+	{0xDD,0x22},
+
+	{0xE7,0x00},
+	{0xE8,0xca},
+	{0xE9,0x00},
+	{0xEA,0x62},
+	{0xEB,0x00},
+	{0xEC,0x00},
+	{0xEE,0x97},
+
+	//=================================
+	// Pixel Filter Setting
+	//=================================
+	{0xFC,0x07},
+	{0x95,0x8F},
+
+	{0xfc,0x01},
+	{0xD3,0x4B},
+	{0xD4,0x00},
+	{0xD5,0x38},
+	{0xD6,0x00},
+	{0xD7,0x60},
+	{0xD8,0x00},
+	{0xD9,0x4E},
+	{0xDA,0x00},
+	{0xDB,0x27},
+	{0xDC,0x15},
+	{0xDD,0x23},
+	{0xDE,0xAD},
+	{0xDF,0x24},
+	{0xE0,0x01},
+	{0xE1,0x17},
+	{0xE2,0x4A},
+	{0xE3,0x36},
+	{0xE4,0x40},
+	{0xE5,0x40},
+	{0xE6,0x40},
+	{0xE7,0x40},
+	{0xE8,0x30},
+	{0xE9,0x3D},
+	{0xEA,0x17},
+	{0xEB,0x01},
+
+	//=================================
+	// Polygon AWB Region Tune
+	//=================================
+	{0xfc,0x22},
+	{0x18,0x00},	// 1
+	{0x19,0x5a},
+	{0x1a,0xf8},
+	{0x1b,0x00},	// 2
+	{0x1c,0x59},
+	{0x1d,0xCC},
+	{0x1e,0x00},	// 3
+	{0x1f,0x74},
+	{0x20,0xB3},
+	{0x21,0x00},	// 4
+	{0x22,0x86},
+	{0x23,0xA2},
+	{0x24,0x00},	// 5
+	{0x25,0x94},
+	{0x26,0x89},
+	{0x27,0x00},	// 6
+	{0x28,0xA6},
+	{0x29,0x76},
+	{0x2A,0x00},	// 7
+	{0x2B,0xd0},
+	{0x2C,0x5e},
+	{0x2D,0x00},	// 8
+	{0x2E,0xfa},
+	{0x2F,0x47},
+	{0x30,0x00},	// 9
+	{0x31,0xfD},
+	{0x32,0x5D},
+	{0x33,0x00},	// 10
+	{0x34,0xBB},
+	{0x35,0x7c},
+	{0x36,0x00},	// 11
+	{0x37,0xAD},
+	{0x38,0x88},
+	{0x39,0x00},	// 12
+	{0x3A,0x9A},
+	{0x3B,0xA3},
+	{0x3C,0x00},	// 13
+	{0x3D,0x7C},
+	{0x3E,0xDD},
+	{0x3F,0x00},	// 14
+	{0x40,0x00},
+	{0x41,0x00},
+
+	//=================================
+	// Moving Equation Weight
+	//=================================
+	{0xfc,0x22},
+	{0x98,0x07},
+
+	//=================================
+	// EIT Threshold
+	//=================================
+	{0xfc,0x22},
+	{0xb1,0x00},  	// {0xunny
+	{0xb2,0x03},
+	{0xb3,0x00},
+	{0xb4,0xc1},
+
+	{0xb5,0x00},	// Cloudy
+	{0xb6,0x05},
+	{0xb7,0xc9},
+	{0xb9,0x81},
+
+	{0xd7,0x00},	// Shade
+	{0xd8,0x35},
+	{0xd9,0x20},
+	{0xda,0x81},
+
+	//=================================
+	// Gain Offset
+	//=================================
+	{0xfc,0x00},
+	{0x79,0xF9},
+	{0x7A,0x02},	// Global AWB gain off{0xet
+
+	{0xfc,0x22},
+	{0x58,0xf6}, 	// D65 R Off{0xet
+	{0x59,0xff}, 	// D65 B Off{0xet
+	{0x5A,0xfa}, 	// 5000K R Off{0xet
+	{0x5B,0xFe}, 	// 5000K B Off{0xet
+	{0x5C,0xfb}, 	// CWF R Off{0xet
+	{0x5D,0xFe}, 	// CWF B Off{0xet
+	{0x5E,0xfb},	// 3000K R Off{0xet
+	{0x5F,0xFb},	// 3000K B Off{0xet
+	{0x60,0xfb},	// A R Off0xet
+	{0x61,0xfb},	// A B Off0xet
+	{0x62,0xfb}, 	// 2000K R Off0xet
+	{0x63,0xfb}, 	// 2000K B Off0xet
+
+	{0xde,0x00},	// LARGE OBJECT BUG FIX
+	{0xf0,0x6a},	// RB Ratio
+	//=================================
+	// Green Stablity Enhance
+	//=================================
+	{0xfc,0x22},
+	{0xb9,0x00},
+	{0xba,0x00},
+	{0xbb,0x00},
+	{0xbc,0x00},
+	{0xe5,0x01},
+	{0xe6,0xff},
+
+	{0xbd,0x90},
+
+	//==========================================================
+	//	Special Effect
+	//==========================================================
+	{0xfc,0x07},	// Special Effect
+	{0x30,0xc0},
+	{0x31,0x20},
+	{0x32,0x40},
+	{0x33,0xc0},
+	{0x34,0x00},
+	{0x35,0xb0},
+
+	{0xfc,0x00},
+	{0x73,0x21},	// Frame AE Enable, peter
+
+	{0xfc,0x04},
+	{0xc0,0x06},
+	{0xc1,0x70},
+	{0xFF,0xFF}	// REGISTER END
+};
+#else
+s5k4xa_t s5k4ba_reg[] =
+{
+//==========================================================
+//	CAMERA INITIAL (Analog & Clock Setting)
+//==========================================================
+	{0xfc, 0x07},
+	{0x66, 0x01},// WDT
+	{0xfc, 0x00},
+	{0x00, 0xaa},// For EDS Check
+	{0x21, 0x03},// peter0223 added
+
+	{0xfc, 0x01},
+	{0x04, 0x01},// ARM Clock Divider
+
+	{0xfc, 0x02},// Analog setting
+	{0x55, 0x1e},// LineADLC on(s551a), off(s550a)
+	{0x56, 0x10},// BPR 16code
+	{0x30, 0x82},// Analog offset (capture =?h)
+	{0x37, 0x25},// Global Gain (default:31)
+
+	{0x57, 0x80},// // LineADLC Roffset
+	{0x58, 0x80},//89	//90  // LineADLC Goffset
+	{0x59, 0x80},//90  // LineADLC offset don't care
+
+	{0x44, 0x64},//clamp en[6]=1 on
+	{0x4a, 0x30},//clamp level 0011h [7]~[4]
+
+	{0x2d, 0x48},// double shutter (default:00)
+	{0x4d, 0x08},// Voltage doubler (default:04)
+	{0x4e, 0x00},// IO current 8mA set
+	{0x4f, 0x8a},// IO current 48mA set
+
+	{0x66, 0x41},// 1st comp current 2uA
+	{0x43, 0xef},// ec_comp
+	{0x62, 0x60},// LD control , CFPN_EN off
+
+//==========================================================
+//	Table Set for Sub-Sampling
+//==========================================================
+	{0xfc, 0x03},
+	{0x01, 0x60},
+	//{0x2e, 0x00},
+	{0x2e, 0x03},//DHL
+	{0x05, 0x46},// Output Image Size Set for Capture
+	{0x07, 0xb6},
+	{0x0e, 0x04},
+	{0x12, 0x03},
+
+	{0xfc, 0x04},
+	{0xc5, 0x26},// Output Image Size Set for Preview
+	{0xc7, 0x5e},
+	{0xce, 0x04},
+	{0xd2, 0x04},
+	//{0xee, 0x00},//DHL
+	{0xee, 0x01},
+	{0xc0, 0x06},
+	{0xc1, 0x60},//frame_H
+	{0xc2, 0x02},
+	{0xc3, 0x8d},//frame_V
+
+	{0xfc, 0x07},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x8b},
+	{0x08, 0xf5},
+	{0x09, 0x00},
+	{0x0a, 0xb4},
+	{0x0b, 0x00},
+	{0x0c, 0xea},
+	{0x0d, 0x00},
+	{0x0e, 0x40},
+
+#if 1
+//==========================================================
+//	COMMAND SET
+//==========================================================
+	{0xfc, 0x00},
+	{0x70, 0x02},
+
+	{0xfc, 0x00},
+	{0x73, 0x11},//21 Frmae AE Enable, peter0223
+	{0x20, 0x02},// Change AWB Mode
+
+	{0xfc, 0x00},
+	{0x78, 0x6a},// AGC Max
+
+	{0xfc, 0x00},
+	{0x6c, 0xa0},// AE target
+	{0x6d, 0x00},
+
+	{0xfc, 0x20},
+	{0x16, 0x5a},// AGC frame AE start _for Prevating AE Hunting
+	{0x57, 0x18},// Stable_Frame_AE
+
+	{0xfc, 0x00},
+	{0x83, 0x06},//low condition shutter off // Double shutter off
+
+	{0xfc, 0x0b},
+	{0x5c, 0x69},//70	//AGC value to start shutter on/off suppress
+	{0x5d, 0x65},//60   //AGC value to start double shutter on/off suppress
+
+	{0xfc, 0x20},
+	{0x25, 0x00},// CINTR Min
+	{0x2a, 0x01},// forbidden
+	{0x2b, 0x02},// For Forbidden Area
+	{0x2c, 0x0a},
+	{0x2d, 0x00},// For Forbidden Area
+	{0x2e, 0x00},
+	{0x2f, 0x05},// forbidden
+	{0x14, 0x78},//70
+	{0x01, 0x00},// Stepless_Off
+
+	{0xfc, 0x00},
+	{0x29, 0x04},// Y level
+	{0x2a, 0x00},
+	{0x2b, 0x03},// C level
+	{0x2c, 0x80},//60
+
+	{0xfc, 0x07},
+	{0x37, 0x00},// Flicker
+
+	{0xfc, 0x00},
+	{0x72, 0xa0},// Flicker for 32MHz
+	{0x74, 0x08},// flicker 60Hz fix
+	{0xfc, 0x20},
+	{0x02, 0x12},//02 Flicker Dgain Mode
+	{0xfc, 0x00},
+	{0x62, 0x02},// Hue Control Enable
+
+	{0xfc, 0x01},
+	//{0x0c, 0x02},// Full YC Enable
+	{0x0C, 0x03},//Donghoon
+
+
+//==========================================================
+//	COLOR MATRIX
+//==========================================================
+	{0xfc, 0x01},	//DL gain 60
+	{0x51, 0x08},	//06	//08  07
+	{0x52, 0xe8},	//df	//9B  E7
+	{0x53, 0xfc},	//fd	//FC  FB
+	{0x54, 0x33},	//09	//07  B9
+	{0x55, 0xfe},	//00	//FF  00
+	{0x56, 0xe6},	//17	//5E  5F
+	{0x57, 0xfe},	//fe	//FD  FD
+	{0x58, 0x3d},	//4f	//0E  46
+	{0x59, 0x08},	//06	//07  05
+	{0x5a, 0x21},	//9b	//EE  E6
+	{0x5b, 0xfd},	//ff	//FF  00
+	{0x5c, 0xa3},	//17	//05  D3
+	{0x5d, 0xff},	//ff	//FF  FF
+	{0x5e, 0xbc},	//81	//7A  53
+	{0x5f, 0xfc},	//fd	//FC  FB
+	{0x60, 0x96},	//5b	//23  B1
+	{0x61, 0x07},	//07	//08  08
+	{0x62, 0xaf},	//24	//64  FD
+
+//==========================================================
+//	EDGE ENHANCEMENT
+//==========================================================
+	{0xfc, 0x05},
+	{0x12, 0x3d},
+	{0x13, 0x3b},
+	{0x14, 0x38},
+	{0x15, 0x3b},
+	{0x16, 0x3d},
+
+	{0x17, 0x3b},
+	{0x18, 0x05},
+	{0x19, 0x09},
+	{0x1a, 0x05},
+	{0x1b, 0x3b},
+
+	{0x1c, 0x38},
+	{0x1d, 0x09},
+	{0x1e, 0x1c},
+	{0x1f, 0x09},
+	{0x20, 0x38},
+
+	{0x21, 0x3b},
+	{0x22, 0x05},
+	{0x23, 0x09},
+	{0x24, 0x05},
+	{0x25, 0x3b},
+
+	{0x26, 0x3d},
+	{0x27, 0x3b},
+	{0x28, 0x38},
+	{0x29, 0x3b},
+	{0x2a, 0x3d},
+
+	{0xfc, 0x00},
+	{0x89, 0x00},// Edge Suppress On
+	{0xfc, 0x0b},
+	{0x42, 0x50},// Edge AGC MIN
+	{0x43, 0x60},// Edge AGC MAX
+	{0x45, 0x18},// positive gain AGC MIN
+	{0x49, 0x06},// positive gain AGC MAX
+	{0x4d, 0x18},// negative gain AGC MIN
+	{0x51, 0x06},// negative gain AGC MAX
+
+	{0xfc, 0x05},
+	{0x34, 0x28},// APTCLP
+	{0x35, 0x03},// APTSC
+	{0x36, 0x0b},// ENHANCE
+	{0x3f, 0x00},// NON-LIN
+	{0x42, 0x10},// EGFALL
+	{0x43, 0x00},// HLFALL
+	{0x45, 0xa0},// EGREF
+	{0x46, 0x7a},// HLREF
+	{0x47, 0x40},// LLREF
+	{0x48, 0x0c},
+	{0x49, 0x31},// CSSEL  EGSEL  CS_DLY
+
+	{0x40, 0x41},// Y delay
+
+	// New Wide Luma Edge
+	{0xfc, 0x1d},
+	{0x86, 0x00},
+	{0x87, 0x60},
+	{0x88, 0x01},
+	{0x89, 0x20},
+	{0x8a, 0x00},
+	{0x8b, 0x00},
+	{0x8c, 0x00},
+	{0x8d, 0x00},
+	{0x8e, 0x00},
+	{0x8f, 0x20},
+	{0x90, 0x00},
+	{0x91, 0x00},
+	{0x92, 0x00},
+	{0x93, 0x0a},
+	{0x94, 0x00},
+	{0x95, 0x00},
+	{0x96, 0x00},
+	{0x97, 0x20},
+	{0x98, 0x00},
+	{0x99, 0x00},
+	{0x9a, 0xff},
+	{0x9b, 0xea},
+	{0x9c, 0xaa},
+	{0x9d, 0xab},
+	{0x9e, 0xff},
+	{0x9f, 0xf1},
+	{0xa0, 0x55},
+	{0xa1, 0x56},
+	{0xa2, 0x07},
+
+	{0x85, 0x01},
+
+/*
+ * GAMMA
+ */
+
+	{0xfc, 0x1d},
+	{0x00, 0x0b},
+	{0x01, 0x18},
+	{0x02, 0x3d},
+	{0x03, 0x9c},
+	{0x04, 0x00},
+	{0x05, 0x0c},
+	{0x06, 0x76},
+	{0x07, 0xc2},
+	{0x08, 0x00},
+	{0x09, 0x56},
+	{0x0a, 0x34},
+	{0x0b, 0x60},
+	{0x0c, 0x85},
+	{0x0d, 0xa7},
+	{0x0e, 0xaa},
+	{0x0f, 0xc6},
+	{0x10, 0xe2},
+	{0x11, 0xfc},
+	{0x12, 0x13},
+	{0x13, 0xab},
+	{0x14, 0x29},
+	{0x15, 0x3c},
+	{0x16, 0x4b},
+	{0x17, 0x5a},
+	{0x18, 0xff},
+	{0x19, 0x69},
+	{0x1a, 0x78},
+	{0x1b, 0x84},
+	{0x1c, 0x91},
+	{0x1d, 0xff},
+	{0x1e, 0x9c},
+	{0x1f, 0xa7},
+	{0x20, 0xb2},
+	{0x21, 0xbd},
+	{0x22, 0xff},
+	{0x23, 0xc7},
+	{0x24, 0xd2},
+	{0x25, 0xdb},
+	{0x26, 0xe4},
+	{0x27, 0xff},
+	{0x28, 0xec},
+	{0x29, 0xf5},
+	{0x2a, 0xf0},
+	{0x2b, 0x0b},
+	{0x2c, 0x18},
+	{0x2d, 0x3d},
+	{0x2e, 0x9c},
+	{0x2f, 0x00},
+	{0x30, 0x0c},
+	{0x31, 0x76},
+	{0x32, 0xc2},
+	{0x33, 0x00},
+	{0x34, 0x56},
+	{0x35, 0x34},
+	{0x36, 0x60},
+	{0x37, 0x85},
+	{0x38, 0xa7},
+	{0x39, 0xaa},
+	{0x3a, 0xc6},
+	{0x3b, 0xe2},
+	{0x3c, 0xfc},
+	{0x3d, 0x13},
+	{0x3e, 0xab},
+	{0x3f, 0x29},
+	{0x40, 0x3c},
+	{0x41, 0x4b},
+	{0x42, 0x5a},
+	{0x43, 0xff},
+	{0x44, 0x69},
+	{0x45, 0x78},
+	{0x46, 0x84},
+	{0x47, 0x91},
+	{0x48, 0xff},
+	{0x49, 0x9c},
+	{0x4a, 0xa7},
+	{0x4b, 0xb2},
+	{0x4c, 0xbd},
+	{0x4d, 0xff},
+	{0x4e, 0xc7},
+	{0x4f, 0xd2},
+	{0x50, 0xdb},
+	{0x51, 0xe4},
+	{0x52, 0xff},
+	{0x53, 0xec},
+	{0x54, 0xf5},
+	{0x55, 0xf0},
+	{0x56, 0x0b},
+	{0x57, 0x18},
+	{0x58, 0x3d},
+	{0x59, 0x9c},
+	{0x5a, 0x00},
+	{0x5b, 0x0c},
+	{0x5c, 0x76},
+	{0x5d, 0xc2},
+	{0x5e, 0x00},
+	{0x5f, 0x56},
+	{0x60, 0x34},
+	{0x61, 0x60},
+	{0x62, 0x85},
+	{0x63, 0xa7},
+	{0x64, 0xaa},
+	{0x65, 0xc6},
+	{0x66, 0xe2},
+	{0x67, 0xfc},
+	{0x68, 0x13},
+	{0x69, 0xab},
+	{0x6a, 0x29},
+	{0x6b, 0x3c},
+	{0x6c, 0x4b},
+	{0x6d, 0x5a},
+	{0x6e, 0xff},
+	{0x6f, 0x69},
+	{0x70, 0x78},
+	{0x71, 0x84},
+	{0x72, 0x91},
+	{0x73, 0xff},
+	{0x74, 0x9c},
+	{0x75, 0xa7},
+	{0x76, 0xb2},
+	{0x77, 0xbd},
+	{0x78, 0xff},
+	{0x79, 0xc7},
+	{0x7a, 0xd2},
+	{0x7b, 0xdb},
+	{0x7c, 0xe4},
+	{0x7d, 0xff},
+	{0x7e, 0xec},
+	{0x7f, 0xf5},
+	{0x80, 0xf0},
+
+/*
+ * HUE CONTROL
+ */
+
+	{0xfc, 0x00},
+	{0x48, 0x40},		/* 2000K */
+	{0x49, 0x30},
+	{0x4a, 0x00},
+	{0x4b, 0x00},
+	{0x4c, 0x30},
+	{0x4d, 0x38},
+	{0x4e, 0x00},
+	{0x4f, 0x00},
+
+	{0x50, 0x40},		/* 3000K */
+	{0x51, 0x30},
+	{0x52, 0x00},
+	{0x53, 0x00},
+	{0x54, 0x30},
+	{0x55, 0x38},
+	{0x56, 0x00},
+	{0x57, 0x00},
+
+	{0x58, 0x3c},		/* 40 - 5100K */
+	{0x59, 0x30},		/* 4a, 40 */
+	{0x5a, 0x00},		/* 0c, 00 */
+	{0x5b, 0x00},		/* 00 */
+	{0x5c, 0x30},		/* 4a */
+	{0x5d, 0x38},		/* 40 */
+	{0x5e, 0x00},		/* f6, 15 */
+	{0x5f, 0xfc},		/* 00 */
+
+/*
+ * SUPPRESS FUNCTION
+ */
+
+	{0xfc, 0x00},
+	{0x7e, 0xf4},
+
+/*
+ * BPR
+ */
+
+	{0xfc, 0x0b},
+	{0x3d, 0x10},
+
+	{0xfc, 0x0b},
+	{0x0b, 0x00},
+	{0x0c, 0x40},
+	{0x0d, 0x5a},
+	{0x0e, 0x00},
+	{0x0f, 0x20},
+	{0x10, 0x00},
+	{0x11, 0x10},
+	{0x12, 0x00},
+	{0x13, 0x7f},
+	{0x14, 0x03},
+	{0x15, 0xff},
+	{0x16, 0x48},
+	{0x17, 0x60},
+	{0x18, 0x00},
+	{0x19, 0x00},
+	{0x1a, 0x00},
+	{0x1b, 0x20},
+	{0x1c, 0x00},
+	{0x1d, 0x00},
+	{0x1e, 0x00},
+	{0x1f, 0x20},
+
+/*
+ * GR/GB CORRECTION
+ */
+
+	{0xfc, 0x01},
+	{0x45, 0x0c},
+	{0xfc, 0x0b},
+	{0x21, 0x00},
+	{0x22, 0x40},
+	{0x23, 0x60},
+	{0x24, 0x0d},
+	{0x25, 0x20},
+	{0x26, 0x0d},
+	{0x27, 0x20},
+
+/*
+ * NR
+ */
+
+	{0xfc, 0x01},
+	{0x4c, 0x01},
+	{0x49, 0x15},
+	{0x4b, 0x0a},
+
+	{0xfc, 0x0b},
+	{0x28, 0x00},
+	{0x29, 0x00},
+	{0x2a, 0x14},
+	{0x2b, 0x00},
+	{0x2c, 0x14},
+	{0x2d, 0x00},
+	{0x2e, 0xD0},
+	{0x2f, 0x02},
+	{0x30, 0x00},
+	{0x31, 0x00},
+	{0x32, 0xa0},
+	{0x33, 0x00},
+	{0x34, 0xe0},
+
+/*
+ * 1D-Y/C-SIGMA-LPF
+ */
+
+	{0xfc, 0x01},
+	{0x05, 0xC0},
+
+	{0xfc, 0x0b},
+	{0x35, 0x00},
+	{0x36, 0x40},
+	{0x37, 0x60},
+	{0x38, 0x00},
+	{0x39, 0x18},
+	{0x3a, 0x00},
+	{0x3b, 0x40},
+	{0x3c, 0x50},
+	{0x3d, 0x60},
+	{0x3e, 0x00},
+	{0x3f, 0x30},
+	{0x40, 0x00},
+	{0x41, 0x40},
+	{0xd4, 0x40},
+	{0xd5, 0x60},
+	{0xd6, 0xb0},
+	{0xd7, 0xf0},
+	{0xd8, 0xb0},
+	{0xd9, 0xf0},
+
+/*
+ * COLOR SUPPRESS
+ */
+
+	{0xfc, 0x0b},
+	{0x08, 0x58},
+	{0x09, 0x03},
+	{0x0a, 0x00},
+
+/*
+ * SHADING
+ */
+
+	{0xfc, 0x09},
+
+	{0x01, 0x06},
+	{0x02, 0x40},
+
+	{0x03, 0x04},
+	{0x04, 0xB0},
+
+	{0x05, 0x03},
+	{0x06, 0x20},
+	{0x07, 0x02},
+	{0x08, 0x91},
+
+	{0x09, 0x03},
+	{0x0A, 0x25},
+	{0x0B, 0x02},
+	{0x0C, 0x64},
+
+	{0x0D, 0x03},
+	{0x0E, 0x0F},
+	{0x0F, 0x02},
+	{0x10, 0x4E},
+
+	{0x1D, 0x80},
+	{0x1E, 0x00},
+	{0x1F, 0x80},
+	{0x20, 0x00},
+	{0x23, 0x85},
+	{0x24, 0x52},
+	{0x21, 0x79},
+	{0x22, 0xE6},
+
+	{0x25, 0x80},
+	{0x26, 0x00},
+	{0x27, 0x80},
+	{0x28, 0x00},
+	{0x2B, 0x81},
+	{0x2C, 0x48},
+	{0x29, 0x81},
+	{0x2A, 0x48},
+
+	{0x2D, 0x80},
+	{0x2E, 0x00},
+	{0x2F, 0x80},
+	{0x30, 0x00},
+	{0x33, 0x7C},
+	{0x34, 0x45},
+	{0x31, 0x7D},
+	{0x32, 0x7D},
+
+	{0x35, 0x01},
+	{0x36, 0x00},
+	{0x37, 0x01},
+	{0x38, 0x11},
+	{0x39, 0x01},
+	{0x3A, 0x4E},
+	{0x3B, 0x01},
+	{0x3C, 0xAB},
+	{0x3D, 0x01},
+	{0x3E, 0xDC},
+	{0x3F, 0x02},
+	{0x40, 0x1A},
+	{0x41, 0x02},
+	{0x42, 0x6A},
+	{0x43, 0x02},
+	{0x44, 0xD3},
+
+	{0x45, 0x01},
+	{0x46, 0x00},
+	{0x47, 0x01},
+	{0x48, 0x0E},
+	{0x49, 0x01},
+	{0x4A, 0x40},
+	{0x4B, 0x01},
+	{0x4C, 0x8A},
+	{0x4D, 0x01},
+	{0x4E, 0xB5},
+	{0x4F, 0x01},
+	{0x50, 0xE8},
+	{0x51, 0x02},
+	{0x52, 0x27},
+	{0x53, 0x02},
+	{0x54, 0x84},
+
+	{0x55, 0x01},
+	{0x56, 0x00},
+	{0x57, 0x01},
+	{0x58, 0x0C},
+	{0x59, 0x01},
+	{0x5A, 0x37},
+	{0x5B, 0x01},
+	{0x5C, 0x74},
+	{0x5D, 0x01},
+	{0x5E, 0x96},
+	{0x5F, 0x01},
+	{0x60, 0xC9},
+	{0x61, 0x02},
+	{0x62, 0x04},
+	{0x63, 0x02},
+	{0x64, 0x4B},
+
+	{0x65, 0x00},
+	{0x66, 0x9A},
+	{0x67, 0x2D},
+	{0x68, 0x02},
+	{0x69, 0x68},
+	{0x6A, 0xB6},
+	{0x6B, 0x05},
+	{0x6C, 0x6B},
+	{0x6D, 0x99},
+	{0x6E, 0x07},
+	{0x6F, 0x60},
+	{0x70, 0xAD},
+	{0x71, 0x09},
+	{0x72, 0xA2},
+	{0x73, 0xD7},
+	{0x74, 0x0C},
+	{0x75, 0x32},
+	{0x76, 0x19},
+	{0x77, 0x0F},
+	{0x78, 0x0E},
+	{0x79, 0x70},
+
+	{0x7A, 0x00},
+	{0x7B, 0x9C},
+	{0x7C, 0x9F},
+	{0x7D, 0x02},
+	{0x7E, 0x72},
+	{0x7F, 0x7A},
+	{0x80, 0x05},
+	{0x81, 0x81},
+	{0x82, 0x94},
+	{0x83, 0x07},
+	{0x84, 0x7E},
+	{0x85, 0x97},
+	{0x86, 0x09},
+	{0x87, 0xC9},
+	{0x88, 0xEA},
+	{0x89, 0x0C},
+	{0x8A, 0x63},
+	{0x8B, 0x8C},
+	{0x8C, 0x0F},
+	{0x8D, 0x4B},
+	{0x8E, 0x7E},
+
+	{0x8F, 0x00},
+	{0x90, 0x9E},
+	{0x91, 0xBD},
+	{0x92, 0x02},
+	{0x93, 0x7A},
+	{0x94, 0xF5},
+	{0x95, 0x05},
+	{0x96, 0x94},
+	{0x97, 0xA8},
+	{0x98, 0x07},
+	{0x99, 0x98},
+	{0x9A, 0x8F},
+	{0x9B, 0x09},
+	{0x9C, 0xEB},
+	{0x9D, 0xD5},
+	{0x9E, 0x0C},
+	{0x9F, 0x8E},
+	{0xA0, 0x7A},
+	{0xA1, 0x0F},
+	{0xA2, 0x80},
+	{0xA3, 0x7D},
+
+	{0xA4, 0x6A},
+	{0xA5, 0x44},
+	{0xA6, 0x23},
+	{0xA7, 0x6C},
+	{0xA8, 0x15},
+	{0xA9, 0x40},
+	{0xAA, 0x20},
+	{0xAB, 0xB2},
+	{0xAC, 0x1C},
+	{0xAD, 0x56},
+	{0xAE, 0x19},
+	{0xAF, 0x01},
+	{0xB0, 0x16},
+	{0xB1, 0x5F},
+
+	{0xB2, 0x68},
+	{0xB3, 0x9C},
+	{0xB4, 0x22},
+	{0xB5, 0xDE},
+	{0xB6, 0x14},
+	{0xB7, 0xEC},
+	{0xB8, 0x20},
+	{0xB9, 0x30},
+	{0xBA, 0x1B},
+	{0xBB, 0xE5},
+	{0xBC, 0x18},
+	{0xBD, 0x9D},
+	{0xBE, 0x16},
+	{0xBF, 0x05},
+
+	{0xC0, 0x67},
+	{0xC1, 0x36},
+	{0xC2, 0x22},
+	{0xC3, 0x67},
+	{0xC4, 0x14},
+	{0xC5, 0xA4},
+	{0xC6, 0x1F},
+	{0xC7, 0xC2},
+	{0xC8, 0x1B},
+	{0xC9, 0x86},
+	{0xCA, 0x18},
+	{0xCB, 0x49},
+	{0xCC, 0x15},
+	{0xCD, 0xBA},
+
+	{0x00, 0x02},	/* shading on */
+
+/*
+ * X-SHADING
+ */
+
+	{0xfc, 0x1B},
+	{0x80, 0x01},
+	{0x81, 0x00},
+	{0x82, 0x4C},
+	{0x83, 0x00},
+	{0x84, 0x86},
+	{0x85, 0x03},
+	{0x86, 0x5E},
+	{0x87, 0x00},
+	{0x88, 0x07},
+	{0x89, 0xA4},
+	{0x90, 0x00},
+	{0x91, 0x88},
+	{0x92, 0x00},
+	{0x93, 0xC1},
+	{0x94, 0x00},
+	{0x95, 0xF7},
+	{0x96, 0x01},
+	{0x97, 0x21},
+	{0x98, 0x01},
+	{0x99, 0x37},
+	{0x9A, 0x01},
+	{0x9B, 0x0C},
+	{0x9C, 0x00},
+	{0x9D, 0xCE},
+	{0x9E, 0x00},
+	{0x9F, 0x3B},
+	{0xA0, 0x00},
+	{0xA1, 0x5B},
+	{0xA2, 0x00},
+	{0xA3, 0x7A},
+	{0xA4, 0x00},
+	{0xA5, 0x92},
+	{0xA6, 0x00},
+	{0xA7, 0x91},
+	{0xA8, 0x00},
+	{0xA9, 0x81},
+	{0xAA, 0x00},
+	{0xAB, 0x60},
+	{0xAC, 0x07},
+	{0xAD, 0xCB},
+	{0xAE, 0x07},
+	{0xAF, 0xC5},
+	{0xB0, 0x07},
+	{0xB1, 0xBB},
+	{0xB2, 0x07},
+	{0xB3, 0xAA},
+	{0xB4, 0x07},
+	{0xB5, 0xA9},
+	{0xB6, 0x07},
+	{0xB7, 0xB2},
+	{0xB8, 0x07},
+	{0xB9, 0xBF},
+	{0xBA, 0x07},
+	{0xBB, 0x5E},
+	{0xBC, 0x07},
+	{0xBD, 0x3C},
+	{0xBE, 0x06},
+	{0xBF, 0xF9},
+	{0xC0, 0x06},
+	{0xC1, 0xBD},
+	{0xC2, 0x06},
+	{0xC3, 0xB8},
+	{0xC4, 0x06},
+	{0xC5, 0xE2},
+	{0xC6, 0x07},
+	{0xC7, 0x1A},
+	{0xC8, 0x07},
+	{0xC9, 0x15},
+	{0xCA, 0x06},
+	{0xCB, 0xDE},
+	{0xCC, 0x06},
+	{0xCD, 0x9C},
+	{0xCE, 0x06},
+	{0xCF, 0x6F},
+	{0xD0, 0x06},
+	{0xD1, 0x5E},
+	{0xD2, 0x06},
+	{0xD3, 0x84},
+	{0xD4, 0x06},
+	{0xD5, 0xCA},
+
+	{0xfc, 0x0b},
+	{0xda, 0x00},
+	{0xdb, 0x9c},
+	{0xdc, 0x00},
+	{0xdd, 0xd1},
+
+	{0xfc, 0x1b},
+	{0x80, 0x01},
+
+/*
+ * AE WINDOW WEIGHT
+ */
+
+	{0xfc, 0x00},
+	{0x03, 0x4b},
+	{0xfc, 0x06},
+	{0x01, 0x35},
+	{0x03, 0xc2},
+	{0x05, 0x48},
+	{0x07, 0xb8},
+	{0x31, 0x2a},
+	{0x33, 0x61},
+	{0x35, 0x28},
+	{0x37, 0x5c},
+
+	{0xfc, 0x20},
+	{0x60, 0x11},
+	{0x61, 0x11},
+	{0x62, 0x11},
+	{0x63, 0x11},
+	{0x64, 0x11},
+	{0x65, 0x22},
+	{0x66, 0x22},
+	{0x67, 0x11},
+	{0x68, 0x11},
+	{0x69, 0x33},
+	{0x6a, 0x33},
+	{0x6b, 0x11},
+	{0x6c, 0x12},
+	{0x6d, 0x55},
+	{0x6e, 0x55},
+	{0x6f, 0x21},
+	{0x70, 0x13},
+	{0x71, 0x55},
+	{0x72, 0x55},
+	{0x73, 0x31},
+	{0x74, 0x33},
+	{0x75, 0x33},
+	{0x76, 0x33},
+	{0x77, 0x33},
+
+/*
+ * SAIT AWB
+ */
+
+	{0xfc, 0x00},
+	{0x7b, 0x00},
+
+	{0xfc, 0x07},
+	{0x3c, 0x10},
+	{0x3d, 0x10},
+	{0x3e, 0x10},
+	{0x3f, 0x10},
+
+	{0xfc, 0x01},
+	{0xc8, 0xe0},
+	{0xfc, 0x00},
+	{0x3e, 0x10},
+
+	{0xfc, 0x00},
+	{0x3e, 0x10},
+	{0x3d, 0x04},
+	{0x32, 0x02},
+	{0x81, 0x10},
+	{0xbc, 0xf0},
+	{0xfc, 0x22},
+	{0x8c, 0x04},
+	{0x8d, 0x06},
+
+	{0xfc, 0x07},
+	{0x97, 0x00},
+
+/*
+ * White Point
+ */
+
+	{0xfc, 0x22},
+	{0x01, 0xD8},
+	{0x03, 0xA1},
+	{0x05, 0xCA},
+	{0x07, 0xC8},
+	{0x09, 0xB3},
+	{0x0b, 0xE2},
+	{0x0d, 0xA0},
+	{0x0f, 0xF0},
+	{0x11, 0x94},
+	{0x12, 0x00},
+	{0x13, 0xFD},
+	{0x15, 0x88},
+	{0x16, 0x01},
+	{0x17, 0x10},
+
+/*
+ * Basic Setting
+ */
+
+	{0xfc, 0x22},
+	{0xA8, 0xFF},
+
+	{0xA0, 0x01},
+	{0xA1, 0x38},
+	{0xA2, 0x0E},
+	{0xA3, 0x6D},
+	{0xA4, 0x07},
+	{0xA5, 0xF5},
+	{0xA6, 0x11},
+	{0xA7, 0xBE},
+	{0xA9, 0x02},
+	{0xAA, 0xD2},
+	{0xAB, 0x00},
+	{0xAC, 0x00},
+	{0xAD, 0x02},
+	{0xAE, 0x3F},
+	{0xAF, 0x19},
+	{0xB0, 0x91},
+	{0x94, 0x3D},
+	{0x95, 0x00},
+	{0x96, 0x58},
+	{0x97, 0x80},
+	{0xD0, 0xA2},
+	{0xD1, 0x2E},
+	{0xD2, 0x4D},
+	{0xD3, 0x28},
+	{0xD4, 0x90},
+	{0xDB, 0x2E},
+	{0xDC, 0x7A},
+	{0xDD, 0x28},
+	{0xE7, 0x00},
+	{0xE8, 0xc7},
+	{0xE9, 0x00},
+	{0xEA, 0x62},
+	{0xEB, 0xD2},
+	{0xEC, 0xD9},
+	{0xEE, 0xA6},
+
+	{0xfc, 0x00},
+	{0x8a, 0x02},
+
+/*
+ * Pixel Filter Setting
+ */
+
+	{0xFC, 0x07},
+	{0x95, 0xCF},
+
+	{0xfc, 0x01},
+	{0xd3, 0x4f},
+	{0xd4, 0x00},
+	{0xd5, 0x3c},
+	{0xd6, 0x80},
+	{0xd7, 0x61},
+	{0xd8, 0x00},
+	{0xd9, 0x49},
+	{0xda, 0x00},
+	{0xdb, 0x24},
+	{0xdc, 0x4b},
+	{0xdd, 0x23},
+	{0xde, 0xf2},
+	{0xdf, 0x20},
+	{0xe0, 0x73},
+	{0xe1, 0x18},
+	{0xe2, 0x69},
+	{0xe3, 0x31},
+	{0xe4, 0x40},
+	{0xe5, 0x34},
+	{0xe6, 0x40},
+	{0xe7, 0x40},
+	{0xe8, 0x32},
+	{0xe9, 0x40},
+	{0xea, 0x1c},
+	{0xeb, 0x00},
+
+/*
+ * Polygon AWB Region Tune
+ */
+
+	/* AWB3 - Polygon Region */
+	{0xfc, 0x22},
+	{0x18, 0x00},
+	{0x19, 0x4b},
+	{0x1a, 0xfd},
+	{0x1b, 0x00},
+	{0x1c, 0x41},
+	{0x1d, 0xd9},
+	{0x1e, 0x00},
+	{0x1f, 0x66},
+	{0x20, 0xa9},
+	{0x21, 0x00},
+	{0x22, 0x8b},
+	{0x23, 0x82},
+	{0x24, 0x00},
+	{0x25, 0xa4},
+	{0x26, 0x6c},
+	{0x27, 0x00},
+	{0x28, 0xbd},
+	{0x29, 0x5d},
+	{0x2a, 0x00},
+	{0x2b, 0xdc},
+	{0x2c, 0x4d},
+	{0x2d, 0x00},
+	{0x2e, 0xdc},
+	{0x2f, 0x63},
+	{0x30, 0x00},
+	{0x31, 0xc1},
+	{0x32, 0x72},
+	{0x33, 0x00},
+	{0x34, 0xab},
+	{0x35, 0x84},
+	{0x36, 0x00},
+	{0x37, 0x99},
+	{0x38, 0xa0},
+	{0x39, 0x00},
+	{0x3a, 0x81},
+	{0x3b, 0xe9},
+	{0x3c, 0x00},
+	{0x3d, 0x00},
+	{0x3e, 0x00},
+	{0x3f, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+
+/*
+ * Moving Equation Weight
+ */
+
+	{0xfc, 0x22},
+	{0x98, 0x07},
+
+/*
+ * EIT Threshold
+ */
+
+	{0xfc, 0x22},
+	{0xb1, 0x00},
+	{0xb2, 0x02},
+	{0xb3, 0x00},
+	{0xb4, 0xC1},
+
+	{0xb5, 0x00},
+	{0xb6, 0x02},
+	{0xb7, 0x00},
+	{0xb9, 0xc2},
+
+	{0xd7, 0x00},
+	{0xd8, 0x35},
+	{0xd9, 0x20},
+	{0xda, 0x81},
+
+/*
+ * Gain Offset
+ */
+
+	{0xfc, 0x00},
+	{0x79, 0xf8},
+	{0x7a, 0x08},
+
+	{0xfc, 0x07},
+	{0x11, 0x01},
+
+	{0xfc, 0x22},
+	{0x58, 0xf8},
+	{0x59, 0x00},
+	{0x5A, 0xfc},
+	{0x5B, 0x00},
+	{0x5C, 0x00},
+	{0x5D, 0x00},
+	{0x5E, 0x00},
+	{0x5F, 0x00},
+	{0x60, 0x00},
+	{0x61, 0xf8},
+	{0x62, 0x00},
+	{0x63, 0xf0},
+
+	{0xde, 0x00},
+	{0xf0, 0x6a},
+
+/*
+ * Green Stablity Enhance
+ */
+
+	{0xfc, 0x22},
+	{0xb9, 0x00},
+	{0xba, 0x00},
+	{0xbb, 0x00},
+	{0xbc, 0x00},
+	{0xe5, 0x01},
+	{0xe6, 0xff},
+	{0xbd, 0x8c},
+
+/*
+ * Special Effect
+ */
+
+	{0xfc, 0x07},
+	{0x30, 0xc0},
+	{0x31, 0x20},
+	{0x32, 0x40},
+	{0x33, 0xc0},
+	{0x34, 0x00},
+	{0x35, 0xb0},
+#endif
+
+/*
+ * ETC
+ */
+
+	{0xfc, 0x01},
+	{0x01, 0x01},
+	{0x00, 0x90},
+	{0xfc, 0x02},
+	{0x03, 0x20},
+
+	{0xfc, 0x20},
+	{0x0f, 0x00},
+
+	{0xfc, 0x00},
+	{0x02, 0x09},
+
+	{0xfc, 0x01},
+	//{0x02, 0x00},
+	{0x02, 0x02},//Donghoon
+};
+#endif
+#else
+#error No samsung CIS moudule !
+#endif
+
+
+/* For VGA ( 640 x 480) on 4BA module */
+
+s5k4xa_t s5k4ba_reg_vga[] =
+{
+	// To do.
+};
+
+/* For SVGA ( 800 x 600) on 4BA module */
+
+s5k4xa_t s5k4ba_reg_svga[] =
+{
+	{0xfc,0x02},
+	{0x2d,0x48},
+	{0x44,0x63},
+
+	{0xfc,0x03},
+	{0x02,0x04},
+	{0xfc,0x20},
+	{0x14,0x70},
+
+	{0xfc,0x00},
+	{0x03,0x4b},		/* AE/AWB On */
+	{0x7e,0xf4},		/* Suppress On */
+	{0x89,0x03},		/* Edge Suppress On */
+
+	{0xfc,0x02},
+	{0x02,0x0e},		/* sensor BPRoff */
+
+	{0xfc,0x20},
+	{0x16,0x60},		/* Frame AE Start */
+
+	{0xfc,0x02},
+	{0x30,0x90},		/* Analog offset */
+	{0x37,0x0d},		/* Global Gain */
+	{0x60,0x00},		/* Blank_Adrs */
+	{0x45,0x0e},		/* CDS Timing for Average Sub_Sampling */
+	{0x47,0x2f},
+
+	{0xfc,0x01},
+	{0x9F,0x05},		/* B */
+	{0xA0,0x18},
+	{0xA1,0x42},
+	{0xA2,0xd7},
+	{0xA3,0x00},
+
+	{0xA4,0xB6},
+	{0xA5,0x3b},
+	{0xA6,0x88},
+	{0xA7,0xC8},
+	{0xA8,0x6A},
+
+	{0xfc,0x05},
+	{0x34,0x20},		/* APTCLP */
+	{0x35,0x08},		/* 9 - APTSC */
+
+	{0xfc,0x00},  		/* flash 0821 */
+	{0x32,0x04},  		/* AWB moving average 8 frame */
+
+	{0xfc,0x01},
+	{0x01,0x01}, 		/* Pclk inversion */
+
+	{0xfc,0x00},
+	{0x02,0x09},		/* 800 x 600 */
+
+
+	{0xFF,0xFF} /* REGISTER END */
+};
+
+/* For SXGA (1280 x 1024 = 1.3M) on 4BA module */
+
+s5k4xa_t s5k4ba_reg_sxga[] =
+{
+	// To do.
+};
+
+
+/* For UXGA (1600 x 1200 = 2M) on 4BA module */
+
+s5k4xa_t s5k4ba_reg_uxga[] =
+{
+	// To do.
+};
+
+
+/* For SQVGA on 4BA module */
+
+s5k4xa_t s5k4ba_reg_qsvga[] =
+{
+	/* Pclk inversion */
+	{0xfc,0x01},
+	{0x01,0x01},
+
+	/* To setting CbCr selection on Table 14h */
+	{0xfc, 0x14},
+	{0x5c, 0x00},
+
+	/* To load table_11 H4V4 */
+	{0xfc, 0x00},
+	{0x02, 0x0B}
+};
+
+#define S5K4BA_INIT_REGS	ARRAY_SIZE(s5k4ba_reg)
+#define S5K4BA_UXGA_REGS	ARRAY_SIZE(s5k4ba_reg_uxga)
+#define S5K4BA_SVGA_REGS	ARRAY_SIZE(s5k4ba_reg_svga)
+#define S5K4BA_VGA_REGS		ARRAY_SIZE(s5k4ba_reg_vga)
+#define S5K4BA_QSVGA_REGS	ARRAY_SIZE(s5k4ba_reg_qsvga)
+
+
+#define S5K4BA_RISC_REGS 0xEB
+#define S5K4BA_ISP_REGS 0xFB /* S5C7323X */
+#define S5K4BA_CIS_REGS 0x2F /* S5K437LA03 */
+
+
+#define S5K4BA_REGS (0x1000)
+
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/samsung/Makefile linux-2.6.29-rc3.owrt.om/drivers/media/video/samsung/Makefile
--- linux-2.6.29-rc3.owrt/drivers/media/video/samsung/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/samsung/Makefile	2009-05-10 22:27:59.000000000 +0200
@@ -0,0 +1,4 @@
+#
+# Samsung CIS camera module
+#
+obj-$(CONFIG_VIDEO_SAMSUNG_S5K4BA) += 4xa_sensor.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/media/video/videodev2_s3c.h linux-2.6.29-rc3.owrt.om/drivers/media/video/videodev2_s3c.h
--- linux-2.6.29-rc3.owrt/drivers/media/video/videodev2_s3c.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/media/video/videodev2_s3c.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,210 @@
+#ifndef __VIDEODEV2_S3C_H_
+#define __VIDEODEV2_S3C_H_
+
+#include <linux/videodev2.h>
+
+#define V4L2_INPUT_TYPE_MSDMA		3
+#define V4L2_INPUT_TYPE_INTERLACE	4
+
+/****************************************************************
+* struct v4l2_control
+* Control IDs defined by S3C
+*****************************************************************/
+/* Image Effect */
+#define V4L2_CID_ORIGINAL		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_ARBITRARY		(V4L2_CID_PRIVATE_BASE + 1)
+#define V4L2_CID_NEGATIVE 		(V4L2_CID_PRIVATE_BASE + 2)
+#define V4L2_CID_ART_FREEZE		(V4L2_CID_PRIVATE_BASE + 3)
+#define V4L2_CID_EMBOSSING		(V4L2_CID_PRIVATE_BASE + 4)
+#define V4L2_CID_SILHOUETTE		(V4L2_CID_PRIVATE_BASE + 5)
+
+/* Image Rotate */
+#define V4L2_CID_ROTATE_90		(V4L2_CID_PRIVATE_BASE + 6)
+#define V4L2_CID_ROTATE_180		(V4L2_CID_PRIVATE_BASE + 7)
+#define V4L2_CID_ROTATE_270		(V4L2_CID_PRIVATE_BASE + 8)
+#define V4L2_CID_ROTATE_BYPASS		(V4L2_CID_PRIVATE_BASE + 9)
+
+/* Zoom-in, Zoom-out */
+#define	V4L2_CID_ZOOMIN			(V4L2_CID_PRIVATE_BASE + 10)
+#define V4L2_CID_ZOOMOUT		(V4L2_CID_PRIVATE_BASE + 11)
+
+/****************************************************************
+*	I O C T L   C O D E S   F O R   V I D E O   D E V I C E S
+*    	 It's only for S3C
+*****************************************************************/
+#define VIDIOC_S_CAMERA_START 		_IO  ('V', BASE_VIDIOC_PRIVATE + 0)
+#define VIDIOC_S_CAMERA_STOP		_IO  ('V', BASE_VIDIOC_PRIVATE + 1)
+#define VIDIOC_MSDMA_START		_IOW ('V', BASE_VIDIOC_PRIVATE + 2, struct v4l2_msdma_format)
+#define VIDIOC_MSDMA_STOP		_IOW ('V', BASE_VIDIOC_PRIVATE + 3, struct v4l2_msdma_format)
+#define VIDIOC_S_MSDMA			_IOW ('V', BASE_VIDIOC_PRIVATE + 4, struct v4l2_msdma_format)
+#define VIDIOC_S_INTERLACE_MODE     	_IOW ('V', BASE_VIDIOC_PRIVATE + 5, struct v4l2_interlace_format)
+
+/*
+ *	INTERLACE MODE
+ */
+#define	S3C_VIDEO_DECODER_PAL		1	/* can decode PAL signal */
+#define	S3C_VIDEO_DECODER_NTSC		2	/* can decode NTSC */
+#define	S3C_VIDEO_DECODER_SECAM		4	/* can decode SECAM */
+#define	S3C_VIDEO_DECODER_AUTO		8	/* can autosense norm */
+#define	S3C_VIDEO_DECODER_CCIR		16	/* CCIR-601 pixel rate (720 pixels per line) instead of square pixel rate */
+
+#define S3C_DECODER_INIT		_IOW ('V', BASE_VIDIOC_PRIVATE + 14, struct s3c_video_decoder_init)	/* init internal registers at once */
+#define	S3C_DECODER_GET_CAPABILITIES	_IOR ('V', BASE_VIDIOC_PRIVATE + 6,  struct s3c_video_decoder_capability)
+#define	S3C_DECODER_GET_STATUS    	_IOR ('V', BASE_VIDIOC_PRIVATE + 7,  int)
+#define	S3C_DECODER_SET_NORM		_IOW ('V', BASE_VIDIOC_PRIVATE + 8,  int)
+#define	S3C_DECODER_SET_INPUT		_IOW ('V', BASE_VIDIOC_PRIVATE + 9,  int)					/* 0 <= input < #inputs */
+#define	S3C_DECODER_SET_OUTPUT		_IOW ('V', BASE_VIDIOC_PRIVATE + 10, int)					/* 0 <= output < #outputs */
+#define	S3C_DECODER_ENABLE_OUTPUT	_IOW ('V', BASE_VIDIOC_PRIVATE + 11, int)					/* boolean output enable control */
+#define	S3C_DECODER_SET_PICTURE   	_IOW ('V', BASE_VIDIOC_PRIVATE + 12, struct video_picture)
+#define	S3C_DECODER_SET_GPIO		_IOW ('V', BASE_VIDIOC_PRIVATE + 13, int)					/* switch general purpose pin */
+#define	S3C_DECODER_SET_VBI_BYPASS	_IOW ('V', BASE_VIDIOC_PRIVATE + 15, int)					/* switch vbi bypass */
+#define	S3C_DECODER_DUMP		_IO  ('V', BASE_VIDIOC_PRIVATE + 16)					/* debug hook */
+
+enum v4l2_msdma_input {
+	V4L2_MSDMA_CODEC = 1,
+	V4L2_MSDMA_PREVIEW = 2,
+};
+
+struct v4l2_msdma_format
+{
+	__u32         		width;		/* MSDMA INPUT : Source X size */
+	__u32			height;		/* MSDMA INPUT : Source Y size */
+	__u32			pixelformat;
+	enum v4l2_msdma_input  	input_path;
+};
+
+struct v4l2_interlace_format
+{
+	__u32 width;	/* INTERLACE INPUT : Source X size */
+	__u32 height;	/* INTERLACE INPUT : Source Y size */
+};
+
+struct s3c_video_decoder_init {
+	unsigned char len;
+	const unsigned char *data;
+};
+
+struct s3c_video_decoder_capability {	/* this name is too long */
+	__u32	flags;
+	int	inputs;			/* number of inputs */
+	int	outputs;		/* number of outputs */
+};
+
+static struct v4l2_input fimc_inputs[] = {
+	{
+		.index		= 0,
+		.name		= "S3C FIMC External Camera Input",
+		.type		= V4L2_INPUT_TYPE_CAMERA,
+		.audioset	= 1,
+		.tuner		= 0,
+		.std		= V4L2_STD_PAL_BG | V4L2_STD_NTSC_M,
+		.status		= 0,
+	},
+	{
+		.index		= 1,
+		.name		= "Memory Input (MSDMA)",
+		.type		= V4L2_INPUT_TYPE_MSDMA,
+		.audioset	= 2,
+		.tuner		= 0,
+		.std		= V4L2_STD_PAL_BG | V4L2_STD_NTSC_M,
+		.status		= 0,
+	}
+};
+
+static struct v4l2_output fimc_outputs[] = {
+	{
+		.index		= 0,
+		.name		= "Pingpong Memory Output",
+		.type		= 0,
+		.audioset	= 0,
+		.modulator	= 0,
+		.std		= 0,
+	},
+	{
+		.index		= 1,
+		.name		= "LCD FIFO Output",
+		.type		= 0,
+		.audioset	= 0,
+		.modulator	= 0,
+		.std		= 0,
+	}
+};
+
+const struct v4l2_fmtdesc fimc_codec_formats[] = {
+	{
+		.index		= 0,
+		.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.flags		= FORMAT_FLAGS_PACKED,
+		.description	= "16 bpp RGB, le",
+		.pixelformat	= V4L2_PIX_FMT_RGB565,
+	},
+	{
+		.index		= 1,
+		.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.flags		= FORMAT_FLAGS_PACKED,
+		.description	= "32 bpp RGB, le",
+		.pixelformat	= V4L2_PIX_FMT_BGR32,
+	},
+	{
+		.index		= 2,
+		.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.flags		= FORMAT_FLAGS_PLANAR,
+		.description	= "4:2:2, planar, Y-Cb-Cr",
+		.pixelformat	= V4L2_PIX_FMT_YUV422P,
+
+	},
+	{
+		.index		= 3,
+		.type		= V4L2_BUF_TYPE_VIDEO_CAPTURE,
+		.flags		= FORMAT_FLAGS_PLANAR,
+		.description	= "4:2:0, planar, Y-Cb-Cr",
+		.pixelformat	= V4L2_PIX_FMT_YUV420,
+	}
+};
+
+const struct v4l2_fmtdesc fimc_preview_formats[] = {
+	{
+		.index		= 0,
+		.type		= V4L2_BUF_TYPE_VIDEO_OVERLAY,
+		.flags		= FORMAT_FLAGS_PACKED,
+		.description	= "16 bpp RGB, le",
+		.pixelformat	= V4L2_PIX_FMT_RGB565,
+	},
+	{
+		.index		= 1,
+		.type		= V4L2_BUF_TYPE_VIDEO_OVERLAY,
+		.flags		= FORMAT_FLAGS_PACKED,
+		.description	= "24 bpp RGB, le",
+		.pixelformat	= V4L2_PIX_FMT_RGB24,
+	},
+	{
+		.index		= 2,
+		.type		= V4L2_BUF_TYPE_VIDEO_OVERLAY,
+		.flags		= FORMAT_FLAGS_PACKED,
+		.description	= "32 bpp RGB, le",
+		.pixelformat	= V4L2_PIX_FMT_BGR32,
+	},
+	{
+		.index		= 3,
+		.type		= V4L2_BUF_TYPE_VIDEO_OVERLAY,
+		.flags		= FORMAT_FLAGS_PLANAR,
+		.description	= "4:2:2, planar, Y-Cb-Cr",
+		.pixelformat	= V4L2_PIX_FMT_YUV422P,
+
+	},
+	{
+		.index		= 4,
+		.type		= V4L2_BUF_TYPE_VIDEO_OVERLAY,
+		.flags		= FORMAT_FLAGS_PLANAR,
+		.description	= "4:2:0, planar, Y-Cb-Cr",
+		.pixelformat	= V4L2_PIX_FMT_YUV420,
+	}
+};
+
+#define NUMBER_OF_PREVIEW_FORMATS  	ARRAY_SIZE(fimc_preview_formats)
+#define NUMBER_OF_CODEC_FORMATS	        ARRAY_SIZE(fimc_codec_formats)
+#define NUMBER_OF_INPUTS	        ARRAY_SIZE(fimc_inputs)
+#define NUMBER_OF_OUTPUTS	        ARRAY_SIZE(fimc_outputs)
+
+#endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-core.c linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-core.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-core.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,1457 @@
+/* Smedia Glamo 336x/337x driver
+ *
+ * (C) 2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/kernel_stat.h>
+#include <linux/spinlock.h>
+#include <linux/glamofb.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/div64.h>
+
+//#include <mach/regs-irq.h>
+
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+
+#include "glamo-regs.h"
+#include "glamo-core.h"
+
+#define RESSIZE(ressource) (((ressource)->end - (ressource)->start)+1)
+
+#define GLAMO_MEM_REFRESH_COUNT 0x100
+
+
+/*
+ * Glamo internal settings
+ *
+ * We run the memory interface from the faster PLLB on 2.6.28 kernels and
+ * above.  Couple of GTA02 users report trouble with memory bus when they
+ * upgraded from 2.6.24.  So this parameter allows reversion to 2.6.24
+ * scheme if their Glamo chip needs it.
+ *
+ * you can override the faster default on kernel commandline using
+ *
+ *   glamo3362.slow_memory=1
+ *
+ * for example
+ */
+
+static int slow_memory = 0;
+module_param(slow_memory, int, 0644);
+
+struct reg_range {
+	int start;
+	int count;
+	char *name;
+	char dump;
+};
+struct reg_range reg_range[] = {
+	{ 0x0000, 0x76,		"General",	1 },
+	{ 0x0200, 0x16,		"Host Bus",	1 },
+	{ 0x0300, 0x38,		"Memory",	1 },
+/*	{ 0x0400, 0x100,	"Sensor",	0 }, */
+/*		{ 0x0500, 0x300,	"ISP",		0 }, */
+/*		{ 0x0800, 0x400,	"JPEG",		0 }, */
+/*		{ 0x0c00, 0xcc,		"MPEG",		0 }, */
+	{ 0x1100, 0xb2,		"LCD 1",	1 },
+	{ 0x1200, 0x64,		"LCD 2",	1 },
+	{ 0x1400, 0x40,		"MMC",		1 },
+/*		{ 0x1500, 0x080,	"MPU 0",	0 },
+	{ 0x1580, 0x080,	"MPU 1",	0 },
+	{ 0x1600, 0x080,	"Cmd Queue",	0 },
+	{ 0x1680, 0x080,	"RISC CPU",	0 },
+	{ 0x1700, 0x400,	"2D Unit",	0 },
+	{ 0x1b00, 0x900,	"3D Unit",	0 }, */
+};
+
+static struct glamo_core *glamo_handle;
+
+static inline void __reg_write(struct glamo_core *glamo,
+				u_int16_t reg, u_int16_t val)
+{
+	writew(val, glamo->base + reg);
+}
+
+static inline u_int16_t __reg_read(struct glamo_core *glamo,
+				   u_int16_t reg)
+{
+	return readw(glamo->base + reg);
+}
+
+static void __reg_set_bit_mask(struct glamo_core *glamo,
+				u_int16_t reg, u_int16_t mask,
+				u_int16_t val)
+{
+	u_int16_t tmp;
+
+	val &= mask;
+
+	tmp = __reg_read(glamo, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	__reg_write(glamo, reg, tmp);
+}
+
+static void reg_set_bit_mask(struct glamo_core *glamo,
+				u_int16_t reg, u_int16_t mask,
+				u_int16_t val)
+{
+	spin_lock(&glamo->lock);
+	__reg_set_bit_mask(glamo, reg, mask, val);
+	spin_unlock(&glamo->lock);
+}
+
+static inline void __reg_set_bit(struct glamo_core *glamo,
+				 u_int16_t reg, u_int16_t bit)
+{
+	__reg_set_bit_mask(glamo, reg, bit, 0xffff);
+}
+
+static inline void __reg_clear_bit(struct glamo_core *glamo,
+				   u_int16_t reg, u_int16_t bit)
+{
+	__reg_set_bit_mask(glamo, reg, bit, 0);
+}
+
+static inline void glamo_vmem_write(struct glamo_core *glamo, u_int32_t addr,
+				    u_int16_t *src, int len)
+{
+	if (addr & 0x0001 || (unsigned long)src & 0x0001 || len & 0x0001) {
+		dev_err(&glamo->pdev->dev, "unaligned write(0x%08x, 0x%p, "
+			"0x%x)!!\n", addr, src, len);
+	}
+
+}
+
+static inline void glamo_vmem_read(struct glamo_core *glamo, u_int16_t *buf,
+				   u_int32_t addr, int len)
+{
+	if (addr & 0x0001 || (unsigned long) buf & 0x0001 || len & 0x0001) {
+		dev_err(&glamo->pdev->dev, "unaligned read(0x%p, 0x08%x, "
+			"0x%x)!!\n", buf, addr, len);
+	}
+
+
+}
+
+/***********************************************************************
+ * resources of sibling devices
+ ***********************************************************************/
+
+#if 0
+static struct resource glamo_core_resources[] = {
+	{
+		.start	= GLAMO_REGOFS_GENERIC,
+		.end	= GLAMO_REGOFS_GENERIC + 0x400,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= 0,
+		.end	= 0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device glamo_core_dev = {
+	.name		= "glamo-core",
+	.resource	= &glamo_core_resources,
+	.num_resources	= ARRAY_SIZE(glamo_core_resources),
+};
+#endif
+
+static struct resource glamo_jpeg_resources[] = {
+	{
+		.start	= GLAMO_REGOFS_JPEG,
+		.end	= GLAMO_REGOFS_MPEG - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_GLAMO_JPEG,
+		.end	= IRQ_GLAMO_JPEG,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device glamo_jpeg_dev = {
+	.name		= "glamo-jpeg",
+	.resource	= glamo_jpeg_resources,
+	.num_resources	= ARRAY_SIZE(glamo_jpeg_resources),
+};
+
+static struct resource glamo_mpeg_resources[] = {
+	{
+		.start	= GLAMO_REGOFS_MPEG,
+		.end	= GLAMO_REGOFS_LCD - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_GLAMO_MPEG,
+		.end	= IRQ_GLAMO_MPEG,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device glamo_mpeg_dev = {
+	.name		= "glamo-mpeg",
+	.resource	= glamo_mpeg_resources,
+	.num_resources	= ARRAY_SIZE(glamo_mpeg_resources),
+};
+
+static struct resource glamo_2d_resources[] = {
+	{
+		.start	= GLAMO_REGOFS_2D,
+		.end	= GLAMO_REGOFS_3D - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_GLAMO_2D,
+		.end	= IRQ_GLAMO_2D,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device glamo_2d_dev = {
+	.name		= "glamo-2d",
+	.resource	= glamo_2d_resources,
+	.num_resources	= ARRAY_SIZE(glamo_2d_resources),
+};
+
+static struct resource glamo_3d_resources[] = {
+	{
+		.start	= GLAMO_REGOFS_3D,
+		.end	= GLAMO_REGOFS_END - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device glamo_3d_dev = {
+	.name		= "glamo-3d",
+	.resource	= glamo_3d_resources,
+	.num_resources	= ARRAY_SIZE(glamo_3d_resources),
+};
+
+static struct platform_device glamo_spigpio_dev = {
+	.name		= "glamo-spi-gpio",
+};
+
+static struct resource glamo_fb_resources[] = {
+	/* FIXME: those need to be incremented by parent base */
+	{
+		.name	= "glamo-fb-regs",
+		.start	= GLAMO_REGOFS_LCD,
+		.end	= GLAMO_REGOFS_MMC - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "glamo-fb-mem",
+		.start	= GLAMO_OFFSET_FB,
+		.end	= GLAMO_OFFSET_FB + GLAMO_FB_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device glamo_fb_dev = {
+	.name		= "glamo-fb",
+	.resource	= glamo_fb_resources,
+	.num_resources	= ARRAY_SIZE(glamo_fb_resources),
+};
+
+static struct resource glamo_mmc_resources[] = {
+	{
+		/* FIXME: those need to be incremented by parent base */
+		.start	= GLAMO_REGOFS_MMC,
+		.end	= GLAMO_REGOFS_MPROC0 - 1,
+		.flags	= IORESOURCE_MEM
+	}, {
+		.start	= IRQ_GLAMO_MMC,
+		.end	= IRQ_GLAMO_MMC,
+		.flags	= IORESOURCE_IRQ,
+	}, { /* our data buffer for MMC transfers */
+		.start	= GLAMO_OFFSET_FB + GLAMO_FB_SIZE,
+		.end	= GLAMO_OFFSET_FB + GLAMO_FB_SIZE +
+				  GLAMO_MMC_BUFFER_SIZE - 1,
+		.flags	= IORESOURCE_MEM
+	},
+};
+
+struct glamo_mci_pdata glamo_mci_def_pdata = {
+	.gpio_detect		= 0,
+	.glamo_can_set_mci_power	= NULL, /* filled in from MFD platform data */
+	.ocr_avail	= MMC_VDD_20_21 |
+			  MMC_VDD_21_22 |
+			  MMC_VDD_22_23 |
+			  MMC_VDD_23_24 |
+			  MMC_VDD_24_25 |
+			  MMC_VDD_25_26 |
+			  MMC_VDD_26_27 |
+			  MMC_VDD_27_28 |
+			  MMC_VDD_28_29 |
+			  MMC_VDD_29_30 |
+			  MMC_VDD_30_31 |
+			  MMC_VDD_32_33,
+	.glamo_irq_is_wired	= NULL, /* filled in from MFD platform data */
+	.mci_suspending = NULL, /* filled in from MFD platform data */
+	.mci_all_dependencies_resumed = NULL, /* filled in from MFD platform data */
+};
+EXPORT_SYMBOL_GPL(glamo_mci_def_pdata);
+
+
+
+static void mangle_mem_resources(struct resource *res, int num_res,
+				 struct resource *parent)
+{
+	int i;
+
+	for (i = 0; i < num_res; i++) {
+		if (res[i].flags != IORESOURCE_MEM)
+			continue;
+		res[i].start += parent->start;
+		res[i].end += parent->start;
+		res[i].parent = parent;
+	}
+}
+
+/***********************************************************************
+ * IRQ demultiplexer
+ ***********************************************************************/
+#define irq2glamo(x)	(x - IRQ_GLAMO(0))
+
+static void glamo_ack_irq(unsigned int irq)
+{
+	/* clear interrupt source */
+	__reg_write(glamo_handle, GLAMO_REG_IRQ_CLEAR,
+		    1 << irq2glamo(irq));
+}
+
+static void glamo_mask_irq(unsigned int irq)
+{
+	u_int16_t tmp;
+
+	/* clear bit in enable register */
+	tmp = __reg_read(glamo_handle, GLAMO_REG_IRQ_ENABLE);
+	tmp &= ~(1 << irq2glamo(irq));
+	__reg_write(glamo_handle, GLAMO_REG_IRQ_ENABLE, tmp);
+}
+
+static void glamo_unmask_irq(unsigned int irq)
+{
+	u_int16_t tmp;
+
+	/* set bit in enable register */
+	tmp = __reg_read(glamo_handle, GLAMO_REG_IRQ_ENABLE);
+	tmp |= (1 << irq2glamo(irq));
+	__reg_write(glamo_handle, GLAMO_REG_IRQ_ENABLE, tmp);
+}
+
+static struct irq_chip glamo_irq_chip = {
+	.ack	= glamo_ack_irq,
+	.mask	= glamo_mask_irq,
+	.unmask	= glamo_unmask_irq,
+};
+
+static void glamo_irq_demux_handler(unsigned int irq, struct irq_desc *desc)
+{
+	const unsigned int cpu = smp_processor_id();
+
+	desc->status &= ~(IRQ_REPLAY | IRQ_WAITING);
+
+	if (unlikely(desc->status & IRQ_INPROGRESS)) {
+		desc->status |= (IRQ_PENDING | IRQ_MASKED);
+		desc->chip->mask(irq);
+		desc->chip->ack(irq);
+		return;
+	}
+
+	kstat_cpu(cpu).irqs[irq]++;
+	desc->chip->ack(irq);
+	desc->status |= IRQ_INPROGRESS;
+
+	do {
+		u_int16_t irqstatus;
+		int i;
+
+		if (unlikely((desc->status &
+				(IRQ_PENDING | IRQ_MASKED | IRQ_DISABLED)) ==
+				(IRQ_PENDING | IRQ_MASKED))) {
+			/* dealing with pending IRQ, unmasking */
+			desc->chip->unmask(irq);
+			desc->status &= ~IRQ_MASKED;
+		}
+
+		desc->status &= ~IRQ_PENDING;
+
+		/* read IRQ status register */
+		irqstatus = __reg_read(glamo_handle, GLAMO_REG_IRQ_STATUS);
+		for (i = 0; i < 9; i++)
+			if (irqstatus & (1 << i))
+				desc_handle_irq(IRQ_GLAMO(i),
+				    irq_desc+IRQ_GLAMO(i));
+
+	} while ((desc->status & (IRQ_PENDING | IRQ_DISABLED)) == IRQ_PENDING);
+
+	desc->status &= ~IRQ_INPROGRESS;
+}
+
+
+static ssize_t regs_write(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	unsigned long reg = simple_strtoul(buf, NULL, 10);
+	struct glamo_core *glamo = dev_get_drvdata(dev);
+
+	while (*buf && (*buf != ' '))
+		buf++;
+	if (*buf != ' ')
+		return -EINVAL;
+	while (*buf && (*buf == ' '))
+		buf++;
+	if (!*buf)
+		return -EINVAL;
+
+	printk(KERN_INFO"reg 0x%02lX <-- 0x%04lX\n",
+	       reg, simple_strtoul(buf, NULL, 10));
+
+	__reg_write(glamo, reg, simple_strtoul(buf, NULL, 10));
+
+	return count;
+}
+
+static ssize_t regs_read(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct glamo_core *glamo = dev_get_drvdata(dev);
+	int n, n1 = 0, r;
+	char * end = buf;
+
+	spin_lock(&glamo->lock);
+
+	for (r = 0; r < ARRAY_SIZE(reg_range); r++) {
+		if (!reg_range[r].dump)
+			continue;
+		n1 = 0;
+		end += sprintf(end, "\n%s\n", reg_range[r].name);
+		for (n = reg_range[r].start;
+		     n < reg_range[r].start + reg_range[r].count; n += 2) {
+			if (((n1++) & 7) == 0)
+				end += sprintf(end, "\n%04X:  ", n);
+			end += sprintf(end, "%04x ", __reg_read(glamo, n));
+		}
+		end += sprintf(end, "\n");
+		if (!attr) {
+			printk("%s", buf);
+			end = buf;
+		}
+	}
+	spin_unlock(&glamo->lock);
+
+	return end - buf;
+}
+
+static DEVICE_ATTR(regs, 0644, regs_read, regs_write);
+static struct attribute *glamo_sysfs_entries[] = {
+	&dev_attr_regs.attr,
+	NULL
+};
+static struct attribute_group glamo_attr_group = {
+	.name	= NULL,
+	.attrs	= glamo_sysfs_entries,
+};
+
+
+
+/***********************************************************************
+ * 'engine' support
+ ***********************************************************************/
+
+int __glamo_engine_enable(struct glamo_core *glamo, enum glamo_engine engine)
+{
+	switch (engine) {
+	case GLAMO_ENGINE_LCD:
+		__reg_set_bit_mask(glamo, GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_LCD,
+				   GLAMO_HOSTBUS2_MMIO_EN_LCD);
+		__reg_write(glamo, GLAMO_REG_CLOCK_LCD,
+			    GLAMO_CLOCK_LCD_EN_M5CLK |
+			    GLAMO_CLOCK_LCD_EN_DHCLK |
+			    GLAMO_CLOCK_LCD_EN_DMCLK |
+			    GLAMO_CLOCK_LCD_EN_DCLK |
+			    GLAMO_CLOCK_LCD_DG_M5CLK |
+			    GLAMO_CLOCK_LCD_DG_DMCLK);
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_GEN5_1,
+			    GLAMO_CLOCK_GEN51_EN_DIV_DHCLK |
+			    GLAMO_CLOCK_GEN51_EN_DIV_DMCLK |
+			    GLAMO_CLOCK_GEN51_EN_DIV_DCLK, 0xffff);
+		break;
+	case GLAMO_ENGINE_MMC:
+		__reg_set_bit_mask(glamo, GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_MMC,
+				   GLAMO_HOSTBUS2_MMIO_EN_MMC);
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_MMC,
+				   GLAMO_CLOCK_MMC_EN_M9CLK |
+				   GLAMO_CLOCK_MMC_EN_TCLK |
+				   GLAMO_CLOCK_MMC_DG_M9CLK |
+				   GLAMO_CLOCK_MMC_DG_TCLK, 0xffff);
+		/* enable the TCLK divider clk input */
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_GEN5_1,
+						 GLAMO_CLOCK_GEN51_EN_DIV_TCLK,
+						 GLAMO_CLOCK_GEN51_EN_DIV_TCLK);
+		break;
+	case GLAMO_ENGINE_2D:
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_2D,
+				   GLAMO_CLOCK_2D_EN_M7CLK |
+				   GLAMO_CLOCK_2D_EN_GCLK |
+				   GLAMO_CLOCK_2D_DG_M7CLK |
+				   GLAMO_CLOCK_2D_DG_GCLK, 0xffff);
+		__reg_set_bit_mask(glamo, GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_2D,
+				   GLAMO_HOSTBUS2_MMIO_EN_2D);
+		break;
+	case GLAMO_ENGINE_CMDQ:
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_2D,
+				   GLAMO_CLOCK_2D_EN_M6CLK, 0xffff);
+		__reg_set_bit_mask(glamo, GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_CQ,
+				   GLAMO_HOSTBUS2_MMIO_EN_CQ);
+		break;
+	/* FIXME: Implementation */
+	default:
+		break;
+	}
+
+	glamo->engine_enabled_bitfield |= 1 << engine;
+
+	return 0;
+}
+
+int glamo_engine_enable(struct glamo_core *glamo, enum glamo_engine engine)
+{
+	int ret;
+
+	spin_lock(&glamo->lock);
+
+	ret = __glamo_engine_enable(glamo, engine);
+
+	spin_unlock(&glamo->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(glamo_engine_enable);
+
+int __glamo_engine_disable(struct glamo_core *glamo, enum glamo_engine engine)
+{
+	switch (engine) {
+	case GLAMO_ENGINE_LCD:
+		/* remove pixel clock to LCM */
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_LCD,
+			    GLAMO_CLOCK_LCD_EN_DCLK, 0);
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_LCD,
+			    GLAMO_CLOCK_LCD_EN_DHCLK |
+			    GLAMO_CLOCK_LCD_EN_DMCLK, 0);
+		/* kill memory clock */
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_LCD,
+			    GLAMO_CLOCK_LCD_EN_M5CLK, 0);
+		/* stop dividing the clocks */
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_GEN5_1,
+			    GLAMO_CLOCK_GEN51_EN_DIV_DHCLK |
+			    GLAMO_CLOCK_GEN51_EN_DIV_DMCLK |
+			    GLAMO_CLOCK_GEN51_EN_DIV_DCLK, 0);
+		break;
+
+	case GLAMO_ENGINE_MMC:
+//		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_MMC,
+//						   GLAMO_CLOCK_MMC_EN_M9CLK |
+//						   GLAMO_CLOCK_MMC_EN_TCLK |
+//						   GLAMO_CLOCK_MMC_DG_M9CLK |
+//						   GLAMO_CLOCK_MMC_DG_TCLK, 0);
+		/* disable the TCLK divider clk input */
+//		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_GEN5_1,
+//					GLAMO_CLOCK_GEN51_EN_DIV_TCLK, 0);
+
+	default:
+		break;
+	}
+
+	glamo->engine_enabled_bitfield &= ~(1 << engine);
+
+	return 0;
+}
+int glamo_engine_disable(struct glamo_core *glamo, enum glamo_engine engine)
+{
+	int ret;
+
+	spin_lock(&glamo->lock);
+
+	ret = __glamo_engine_disable(glamo, engine);
+
+	spin_unlock(&glamo->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(glamo_engine_disable);
+
+static const u_int16_t engine_clock_regs[__NUM_GLAMO_ENGINES] = {
+	[GLAMO_ENGINE_LCD]	= GLAMO_REG_CLOCK_LCD,
+	[GLAMO_ENGINE_MMC]	= GLAMO_REG_CLOCK_MMC,
+	[GLAMO_ENGINE_ISP]	= GLAMO_REG_CLOCK_ISP,
+	[GLAMO_ENGINE_JPEG]	= GLAMO_REG_CLOCK_JPEG,
+	[GLAMO_ENGINE_3D]	= GLAMO_REG_CLOCK_3D,
+	[GLAMO_ENGINE_2D]	= GLAMO_REG_CLOCK_2D,
+	[GLAMO_ENGINE_MPEG_ENC] = GLAMO_REG_CLOCK_MPEG,
+	[GLAMO_ENGINE_MPEG_DEC] = GLAMO_REG_CLOCK_MPEG,
+};
+
+void glamo_engine_clkreg_set(struct glamo_core *glamo,
+			     enum glamo_engine engine,
+			     u_int16_t mask, u_int16_t val)
+{
+	reg_set_bit_mask(glamo, engine_clock_regs[engine], mask, val);
+}
+EXPORT_SYMBOL_GPL(glamo_engine_clkreg_set);
+
+u_int16_t glamo_engine_clkreg_get(struct glamo_core *glamo,
+				  enum glamo_engine engine)
+{
+	u_int16_t val;
+
+	spin_lock(&glamo->lock);
+	val = __reg_read(glamo, engine_clock_regs[engine]);
+	spin_unlock(&glamo->lock);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(glamo_engine_clkreg_get);
+
+struct glamo_script reset_regs[] = {
+	[GLAMO_ENGINE_LCD] = {
+		GLAMO_REG_CLOCK_LCD, GLAMO_CLOCK_LCD_RESET
+	},
+#if 0
+	[GLAMO_ENGINE_HOST] = {
+		GLAMO_REG_CLOCK_HOST, GLAMO_CLOCK_HOST_RESET
+	},
+	[GLAMO_ENGINE_MEM] = {
+		GLAMO_REG_CLOCK_MEM, GLAMO_CLOCK_MEM_RESET
+	},
+#endif
+	[GLAMO_ENGINE_MMC] = {
+		GLAMO_REG_CLOCK_MMC, GLAMO_CLOCK_MMC_RESET
+	},
+	[GLAMO_ENGINE_2D] = {
+		GLAMO_REG_CLOCK_2D, GLAMO_CLOCK_2D_RESET
+	},
+	[GLAMO_ENGINE_JPEG] = {
+		GLAMO_REG_CLOCK_JPEG, GLAMO_CLOCK_JPEG_RESET
+	},
+};
+
+void glamo_engine_reset(struct glamo_core *glamo, enum glamo_engine engine)
+{
+	struct glamo_script *rst;
+
+	if (engine >= ARRAY_SIZE(reset_regs)) {
+		dev_warn(&glamo->pdev->dev, "unknown engine %u ", engine);
+		return;
+	}
+
+	rst = &reset_regs[engine];
+
+	spin_lock(&glamo->lock);
+	__reg_set_bit(glamo, rst->reg, rst->val);
+	__reg_clear_bit(glamo, rst->reg, rst->val);
+	spin_unlock(&glamo->lock);
+}
+EXPORT_SYMBOL_GPL(glamo_engine_reset);
+
+void glamo_lcm_reset(int level)
+{
+	if (!glamo_handle)
+		return;
+
+	glamo_gpio_setpin(glamo_handle, GLAMO_GPIO4, level);
+	glamo_gpio_cfgpin(glamo_handle, GLAMO_GPIO4_OUTPUT);
+
+}
+EXPORT_SYMBOL_GPL(glamo_lcm_reset);
+
+enum glamo_pll {
+	GLAMO_PLL1,
+	GLAMO_PLL2,
+};
+
+static int glamo_pll_rate(struct glamo_core *glamo,
+			  enum glamo_pll pll)
+{
+	u_int16_t reg;
+	unsigned int div = 512;
+	/* FIXME: move osci into platform_data */
+	unsigned int osci = 32768;
+
+	if (osci == 32768)
+		div = 1;
+
+	switch (pll) {
+	case GLAMO_PLL1:
+		reg = __reg_read(glamo, GLAMO_REG_PLL_GEN1);
+		break;
+	case GLAMO_PLL2:
+		reg = __reg_read(glamo, GLAMO_REG_PLL_GEN3);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return (osci/div)*reg;
+}
+
+int glamo_engine_reclock(struct glamo_core *glamo,
+			 enum glamo_engine engine,
+			 int ps)
+{
+	int pll, khz;
+	u_int16_t reg, mask, val = 0;
+
+	if (!ps)
+		return 0;
+
+	switch (engine) {
+	case GLAMO_ENGINE_LCD:
+		pll = GLAMO_PLL1;
+		reg = GLAMO_REG_CLOCK_GEN7;
+		mask = 0xff;
+		break;
+	default:
+		dev_warn(&glamo->pdev->dev,
+			 "reclock of engine 0x%x not supported\n", engine);
+		return -EINVAL;
+		break;
+	}
+
+	pll = glamo_pll_rate(glamo, pll);
+	khz = 1000000000UL / ps;
+
+	if (khz)
+		val = (pll / khz) / 1000;
+
+	dev_dbg(&glamo->pdev->dev,
+			"PLL %d, kHZ %d, div %d\n", pll, khz, val);
+
+	if (val) {
+		val--;
+		reg_set_bit_mask(glamo, reg, mask, val);
+		mdelay(5); /* wait some time to stabilize */
+
+		return 0;
+	} else {
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL_GPL(glamo_engine_reclock);
+
+/***********************************************************************
+ * script support
+ ***********************************************************************/
+
+int glamo_run_script(struct glamo_core *glamo, struct glamo_script *script,
+		     int len, int may_sleep)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		struct glamo_script *line = &script[i];
+
+		switch (line->reg) {
+		case 0xffff:
+			return 0;
+		case 0xfffe:
+			if (may_sleep)
+				msleep(line->val);
+			else
+				mdelay(line->val * 4);
+			break;
+		case 0xfffd:
+			/* spin until PLLs lock */
+			while ((__reg_read(glamo, GLAMO_REG_PLL_GEN5) & 3) != 3)
+				;
+			break;
+
+		/*
+		 * couple of people reported artefacts with 2.6.28 changes, this
+		 * allows reversion to 2.6.24 settings
+		 */
+
+		case 0x200:
+			switch (slow_memory) {
+			/* choice 1 is the most conservative */
+			case 1: /* 3 waits on Async BB R & W, Use PLL 1 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xef0);
+				break;
+			case 2: /* 2 waits on Async BB R & W, Use PLL 1 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xea0);
+				break;
+			case 3: /* 1 waits on Async BB R & W, Use PLL 1 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xe50);
+				break;
+			case 4: /* 0 waits on Async BB R & W, Use PLL 1 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xe00);
+				break;
+
+			/* using PLL2 for memory bus increases CPU bandwidth significantly */
+			case 5: /* 3 waits on Async BB R & W, Use PLL 2 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xef3);
+				break;
+			case 6: /* 2 waits on Async BB R & W, Use PLL 2 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xea3);
+				break;
+			case 7: /* 1 waits on Async BB R & W, Use PLL 2 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xe53);
+				break;
+			/* default of 0 or >7 is fastest */
+			default: /* 0 waits on Async BB R & W, Use PLL 2 for mem bus */
+				__reg_write(glamo, script[i].reg, 0xe03);
+				break;
+			}
+			break;
+
+		default:
+			__reg_write(glamo, script[i].reg, script[i].val);
+			break;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(glamo_run_script);
+
+static struct glamo_script glamo_init_script[] = {
+	{ GLAMO_REG_CLOCK_HOST,		0x1000 },
+		{ 0xfffe, 2 },
+	{ GLAMO_REG_CLOCK_MEMORY, 	0x1000 },
+	{ GLAMO_REG_CLOCK_MEMORY,	0x2000 },
+	{ GLAMO_REG_CLOCK_LCD,		0x1000 },
+	{ GLAMO_REG_CLOCK_MMC,		0x1000 },
+	{ GLAMO_REG_CLOCK_ISP,		0x1000 },
+	{ GLAMO_REG_CLOCK_ISP,		0x3000 },
+	{ GLAMO_REG_CLOCK_JPEG,		0x1000 },
+	{ GLAMO_REG_CLOCK_3D,		0x1000 },
+	{ GLAMO_REG_CLOCK_3D,		0x3000 },
+	{ GLAMO_REG_CLOCK_2D,		0x1000 },
+	{ GLAMO_REG_CLOCK_2D,		0x3000 },
+	{ GLAMO_REG_CLOCK_RISC1,	0x1000 },
+	{ GLAMO_REG_CLOCK_MPEG,		0x3000 },
+	{ GLAMO_REG_CLOCK_MPEG,		0x3000 },
+	{ GLAMO_REG_CLOCK_MPROC,	0x1000 /*0x100f*/ },
+		{ 0xfffe, 2 },
+	{ GLAMO_REG_CLOCK_HOST,		0x0000 },
+	{ GLAMO_REG_CLOCK_MEMORY,	0x0000 },
+	{ GLAMO_REG_CLOCK_LCD,		0x0000 },
+	{ GLAMO_REG_CLOCK_MMC,		0x0000 },
+#if 0
+/* unused engines must be left in reset to stop MMC block read "blackouts" */
+	{ GLAMO_REG_CLOCK_ISP,		0x0000 },
+	{ GLAMO_REG_CLOCK_ISP,		0x0000 },
+	{ GLAMO_REG_CLOCK_JPEG,		0x0000 },
+	{ GLAMO_REG_CLOCK_3D,		0x0000 },
+	{ GLAMO_REG_CLOCK_3D,		0x0000 },
+	{ GLAMO_REG_CLOCK_2D,		0x0000 },
+	{ GLAMO_REG_CLOCK_2D,		0x0000 },
+	{ GLAMO_REG_CLOCK_RISC1,	0x0000 },
+	{ GLAMO_REG_CLOCK_MPEG,		0x0000 },
+	{ GLAMO_REG_CLOCK_MPEG,		0x0000 },
+#endif
+	{ GLAMO_REG_PLL_GEN1,		0x05db },	/* 48MHz */
+	{ GLAMO_REG_PLL_GEN3,		0x0aba },	/* 90MHz */
+	{ 0xfffd, 0 },
+	/*
+	 * b9 of this register MUST be zero to get any interrupts on INT#
+	 * the other set bits enable all the engine interrupt sources
+	 */
+	{ GLAMO_REG_IRQ_ENABLE,		0x01ff },
+	{ GLAMO_REG_CLOCK_GEN6,		0x2000 },
+	{ GLAMO_REG_CLOCK_GEN7,		0x0101 },
+	{ GLAMO_REG_CLOCK_GEN8,		0x0100 },
+	{ GLAMO_REG_CLOCK_HOST,		0x000d },
+	/*
+	 * b7..b4 = 0 = no wait states on read or write
+	 * b0 = 1 select PLL2 for Host interface, b1 = enable it
+	 */
+	{ 0x200,	0x0e03 /* this is replaced by script parser */ },
+	{ 0x202, 	0x07ff },
+	{ 0x212,	0x0000 },
+	{ 0x214,	0x4000 },
+	{ 0x216,	0xf00e },
+
+	/* S-Media recommended "set tiling mode to 512 mode for memory access
+	 * more efficiency when 640x480" */
+	{ GLAMO_REG_MEM_TYPE,		0x0c74 }, /* 8MB, 16 word pg wr+rd */
+	{ GLAMO_REG_MEM_GEN,		0xafaf }, /* 63 grants min + max */
+
+	{ GLAMO_REGOFS_HOSTBUS + 2,	0xffff }, /* enable  on MMIO*/
+
+	{ GLAMO_REG_MEM_TIMING1,	0x0108 },
+	{ GLAMO_REG_MEM_TIMING2,	0x0010 }, /* Taa = 3 MCLK */
+	{ GLAMO_REG_MEM_TIMING3,	0x0000 },
+	{ GLAMO_REG_MEM_TIMING4,	0x0000 }, /* CE1# delay fall/rise */
+	{ GLAMO_REG_MEM_TIMING5,	0x0000 }, /* UB# LB# */
+	{ GLAMO_REG_MEM_TIMING6,	0x0000 }, /* OE# */
+	{ GLAMO_REG_MEM_TIMING7,	0x0000 }, /* WE# */
+	{ GLAMO_REG_MEM_TIMING8,	0x1002 }, /* MCLK delay, was 0x1000 */
+	{ GLAMO_REG_MEM_TIMING9,	0x6006 },
+	{ GLAMO_REG_MEM_TIMING10,	0x00ff },
+	{ GLAMO_REG_MEM_TIMING11,	0x0001 },
+	{ GLAMO_REG_MEM_POWER1,		0x0020 },
+	{ GLAMO_REG_MEM_POWER2,		0x0000 },
+	{ GLAMO_REG_MEM_DRAM1,		0x0000 },
+		{ 0xfffe, 1 },
+	{ GLAMO_REG_MEM_DRAM1,		0xc100 },
+		{ 0xfffe, 1 },
+	{ GLAMO_REG_MEM_DRAM1,		0xe100 },
+	{ GLAMO_REG_MEM_DRAM2,		0x01d6 },
+	{ GLAMO_REG_CLOCK_MEMORY,	0x000b },
+	{ GLAMO_REG_GPIO_GEN1,		0x000f },
+	{ GLAMO_REG_GPIO_GEN2,		0x111e },
+	{ GLAMO_REG_GPIO_GEN3,		0xccc3 },
+	{ GLAMO_REG_GPIO_GEN4,		0x111e },
+	{ GLAMO_REG_GPIO_GEN5,		0x000f },
+};
+#if 0
+static struct glamo_script glamo_resume_script[] = {
+
+	{ GLAMO_REG_PLL_GEN1,		0x05db },	/* 48MHz */
+	{ GLAMO_REG_PLL_GEN3,		0x0aba },	/* 90MHz */
+	{ GLAMO_REG_DFT_GEN6, 1 },
+		{ 0xfffe, 100 },
+		{ 0xfffd, 0 },
+	{ 0x200,	0x0e03 },
+
+	/*
+	 * b9 of this register MUST be zero to get any interrupts on INT#
+	 * the other set bits enable all the engine interrupt sources
+	 */
+	{ GLAMO_REG_IRQ_ENABLE,		0x01ff },
+	{ GLAMO_REG_CLOCK_HOST,		0x0018 },
+	{ GLAMO_REG_CLOCK_GEN5_1, 0x18b1 },
+
+	{ GLAMO_REG_MEM_DRAM1,		0x0000 },
+		{ 0xfffe, 1 },
+	{ GLAMO_REG_MEM_DRAM1,		0xc100 },
+		{ 0xfffe, 1 },
+	{ GLAMO_REG_MEM_DRAM1,		0xe100 },
+	{ GLAMO_REG_MEM_DRAM2,		0x01d6 },
+	{ GLAMO_REG_CLOCK_MEMORY,	0x000b },
+};
+#endif
+
+enum glamo_power {
+	GLAMO_POWER_ON,
+	GLAMO_POWER_SUSPEND,
+};
+
+static void glamo_power(struct glamo_core *glamo,
+			enum glamo_power new_state)
+{
+	int n;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&glamo->lock, flags);
+
+	dev_info(&glamo->pdev->dev, "***** glamo_power -> %d\n", new_state);
+
+	/*
+Power management
+static const REG_VALUE_MASK_TYPE reg_powerOn[] =
+{
+    { REG_GEN_DFT6,     REG_BIT_ALL,    REG_DATA(1u << 0)           },
+    { REG_GEN_PLL3,     0u,             REG_DATA(1u << 13)          },
+    { REG_GEN_MEM_CLK,  REG_BIT_ALL,    REG_BIT_EN_MOCACLK          },
+    { REG_MEM_DRAM2,    0u,             REG_BIT_EN_DEEP_POWER_DOWN  },
+    { REG_MEM_DRAM1,    0u,             REG_BIT_SELF_REFRESH        }
+};
+
+static const REG_VALUE_MASK_TYPE reg_powerStandby[] =
+{
+    { REG_MEM_DRAM1,    REG_BIT_ALL,    REG_BIT_SELF_REFRESH    },
+    { REG_GEN_MEM_CLK,  0u,             REG_BIT_EN_MOCACLK      },
+    { REG_GEN_PLL3,     REG_BIT_ALL,    REG_DATA(1u << 13)      },
+    { REG_GEN_DFT5,     REG_BIT_ALL,    REG_DATA(1u << 0)       }
+};
+
+static const REG_VALUE_MASK_TYPE reg_powerSuspend[] =
+{
+    { REG_MEM_DRAM2,    REG_BIT_ALL,    REG_BIT_EN_DEEP_POWER_DOWN  },
+    { REG_GEN_MEM_CLK,  0u,             REG_BIT_EN_MOCACLK          },
+    { REG_GEN_PLL3,     REG_BIT_ALL,    REG_DATA(1u << 13)          },
+    { REG_GEN_DFT5,     REG_BIT_ALL,    REG_DATA(1u << 0)           }
+};
+*/
+
+	switch (new_state) {
+	case GLAMO_POWER_ON:
+
+		/*
+		 * glamo state on resume is nondeterministic in some
+		 * fundamental way, it has also been observed that the
+		 * Glamo reset pin can get asserted by, eg, touching it with
+		 * a scope probe.  So the only answer is to roll with it and
+		 * force an external reset on the Glamo during resume.
+		 */
+
+		(glamo->pdata->glamo_external_reset)(0);
+		udelay(10);
+		(glamo->pdata->glamo_external_reset)(1);
+		mdelay(5);
+
+		glamo_run_script(glamo, glamo_init_script,
+			 ARRAY_SIZE(glamo_init_script), 0);
+
+		break;
+
+	case GLAMO_POWER_SUSPEND:
+
+		/* nuke interrupts */
+		__reg_write(glamo, GLAMO_REG_IRQ_ENABLE, 0x200);
+
+		/* stash a copy of which engines were running */
+		glamo->engine_enabled_bitfield_suspend =
+						 glamo->engine_enabled_bitfield;
+
+		/* take down each engine before we kill mem and pll */
+		for (n = 0; n < __NUM_GLAMO_ENGINES; n++)
+			if (glamo->engine_enabled_bitfield & (1 << n))
+				__glamo_engine_disable(glamo, n);
+
+		/* enable self-refresh */
+
+		__reg_write(glamo, GLAMO_REG_MEM_DRAM1,
+					GLAMO_MEM_DRAM1_EN_DRAM_REFRESH |
+					GLAMO_MEM_DRAM1_EN_GATE_CKE |
+					GLAMO_MEM_DRAM1_SELF_REFRESH |
+					GLAMO_MEM_REFRESH_COUNT);
+		__reg_write(glamo, GLAMO_REG_MEM_DRAM1,
+					GLAMO_MEM_DRAM1_EN_MODEREG_SET |
+					GLAMO_MEM_DRAM1_EN_DRAM_REFRESH |
+					GLAMO_MEM_DRAM1_EN_GATE_CKE |
+					GLAMO_MEM_DRAM1_SELF_REFRESH |
+					GLAMO_MEM_REFRESH_COUNT);
+
+		/* force RAM into deep powerdown */
+
+		__reg_write(glamo, GLAMO_REG_MEM_DRAM2,
+					GLAMO_MEM_DRAM2_DEEP_PWRDOWN |
+					(7 << 6) | /* tRC */
+					(1 << 4) | /* tRP */
+					(1 << 2) | /* tRCD */
+					2); /* CAS latency */
+
+		/* disable clocks to memory */
+		__reg_write(glamo, GLAMO_REG_CLOCK_MEMORY, 0);
+
+		/* all dividers from OSCI */
+		__reg_set_bit_mask(glamo, GLAMO_REG_CLOCK_GEN5_1, 0x400, 0x400);
+
+		/* PLL2 into bypass */
+		__reg_set_bit_mask(glamo, GLAMO_REG_PLL_GEN3, 1 << 12, 1 << 12);
+
+		__reg_write(glamo, 0x200, 0x0e00);
+
+
+		/* kill PLLS 1 then 2 */
+		__reg_write(glamo, GLAMO_REG_DFT_GEN5, 0x0001);
+		__reg_set_bit_mask(glamo, GLAMO_REG_PLL_GEN3, 1 << 13, 1 << 13);
+
+		break;
+	}
+
+	spin_unlock_irqrestore(&glamo->lock, flags);
+}
+
+#if 0
+#define MEMDETECT_RETRY	6
+static unsigned int detect_memsize(struct glamo_core *glamo)
+{
+	int i;
+
+	/*static const u_int16_t pattern[] = {
+		0x1111, 0x8a8a, 0x2222, 0x7a7a,
+		0x3333, 0x6a6a, 0x4444, 0x5a5a,
+		0x5555, 0x4a4a, 0x6666, 0x3a3a,
+		0x7777, 0x2a2a, 0x8888, 0x1a1a
+	}; */
+
+	for (i = 0; i < MEMDETECT_RETRY; i++) {
+		switch (glamo->type) {
+		case 3600:
+			__reg_write(glamo, GLAMO_REG_MEM_TYPE, 0x0072);
+			__reg_write(glamo, GLAMO_REG_MEM_DRAM1, 0xc100);
+			break;
+		case 3650:
+			switch (glamo->revision) {
+			case GLAMO_CORE_REV_A0:
+				if (i & 1)
+					__reg_write(glamo, GLAMO_REG_MEM_TYPE,
+						    0x097a);
+				else
+					__reg_write(glamo, GLAMO_REG_MEM_TYPE,
+						    0x0173);
+
+				__reg_write(glamo, GLAMO_REG_MEM_DRAM1, 0x0000);
+				msleep(1);
+				__reg_write(glamo, GLAMO_REG_MEM_DRAM1, 0xc100);
+				break;
+			default:
+				if (i & 1)
+					__reg_write(glamo, GLAMO_REG_MEM_TYPE,
+						    0x0972);
+				else
+					__reg_write(glamo, GLAMO_REG_MEM_TYPE,
+						    0x0872);
+
+				__reg_write(glamo, GLAMO_REG_MEM_DRAM1, 0x0000);
+				msleep(1);
+				__reg_write(glamo, GLAMO_REG_MEM_DRAM1, 0xe100);
+				break;
+			}
+			break;
+		case 3700:
+			/* FIXME */
+		default:
+			break;
+		}
+
+#if 0
+		/* FIXME: finish implementation */
+		for (j = 0; j < 8; j++) {
+			__
+#endif
+	}
+
+	return 0;
+}
+#endif
+
+/* Find out if we can support this version of the Glamo chip */
+static int glamo_supported(struct glamo_core *glamo)
+{
+	u_int16_t dev_id, rev_id; /*, memsize; */
+
+	dev_id = __reg_read(glamo, GLAMO_REG_DEVICE_ID);
+	rev_id = __reg_read(glamo, GLAMO_REG_REVISION_ID);
+
+	switch (dev_id) {
+	case 0x3650:
+		switch (rev_id) {
+		case GLAMO_CORE_REV_A2:
+			break;
+		case GLAMO_CORE_REV_A0:
+		case GLAMO_CORE_REV_A1:
+		case GLAMO_CORE_REV_A3:
+			dev_warn(&glamo->pdev->dev, "untested core revision "
+				 "%04x, your mileage may vary\n", rev_id);
+			break;
+		default:
+			dev_warn(&glamo->pdev->dev, "unknown glamo revision "
+				 "%04x, your mileage may vary\n", rev_id);
+			/* maybe should abort ? */
+		}
+		break;
+	case 0x3600:
+	case 0x3700:
+	default:
+		dev_err(&glamo->pdev->dev, "unsupported Glamo device %04x\n",
+			dev_id);
+		return 0;
+	}
+
+	dev_dbg(&glamo->pdev->dev, "Detected Glamo core %04x Revision %04x "
+		 "(%uHz CPU / %uHz Memory)\n", dev_id, rev_id,
+		 glamo_pll_rate(glamo, GLAMO_PLL1),
+		 glamo_pll_rate(glamo, GLAMO_PLL2));
+
+	return 1;
+}
+
+static int __init glamo_probe(struct platform_device *pdev)
+{
+	int rc = 0, irq;
+	struct glamo_core *glamo;
+	struct platform_device *glamo_mmc_dev;
+
+	if (glamo_handle) {
+		dev_err(&pdev->dev,
+			"This driver supports only one instance\n");
+		return -EBUSY;
+	}
+
+	glamo = kmalloc(GFP_KERNEL, sizeof(*glamo));
+	if (!glamo)
+		return -ENOMEM;
+
+	spin_lock_init(&glamo->lock);
+	glamo_handle = glamo;
+	glamo->pdev = pdev;
+	glamo->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	glamo->irq = platform_get_irq(pdev, 0);
+	glamo->pdata = pdev->dev.platform_data;
+	if (!glamo->mem || !glamo->pdata) {
+		dev_err(&pdev->dev, "platform device with no MEM/PDATA ?\n");
+		rc = -ENOENT;
+		goto bail_free;
+	}
+
+	/* register a number of sibling devices whoise IOMEM resources
+	 * are siblings of pdev's IOMEM resource */
+#if 0
+	glamo_core_dev.dev.parent = &pdev.dev;
+	mangle_mem_resources(glamo_core_dev.resources,
+			     glamo_core_dev.num_resources, glamo->mem);
+	glamo_core_dev.resources[1].start = glamo->irq;
+	glamo_core_dev.resources[1].end = glamo->irq;
+	platform_device_register(&glamo_core_dev);
+#endif
+	/* only remap the generic, hostbus and memory controller registers */
+	glamo->base = ioremap(glamo->mem->start, 0x4000 /*GLAMO_REGOFS_VIDCAP*/);
+	if (!glamo->base) {
+		dev_err(&pdev->dev, "failed to ioremap() memory region\n");
+		goto bail_free;
+	}
+
+	platform_set_drvdata(pdev, glamo);
+
+	(glamo->pdata->glamo_external_reset)(0);
+	udelay(10);
+	(glamo->pdata->glamo_external_reset)(1);
+	mdelay(10);
+
+	/*
+	 * finally set the mfd interrupts up
+	 * can't do them earlier or sibling probes blow up
+	 */
+
+	for (irq = IRQ_GLAMO(0); irq <= IRQ_GLAMO(8); irq++) {
+		set_irq_chip(irq, &glamo_irq_chip);
+		set_irq_handler(irq, handle_level_irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	if (glamo->pdata->glamo_irq_is_wired &&
+	    !glamo->pdata->glamo_irq_is_wired()) {
+		set_irq_chained_handler(glamo->irq, glamo_irq_demux_handler);
+		set_irq_type(glamo->irq, IRQ_TYPE_EDGE_FALLING);
+		dev_info(&pdev->dev, "Glamo interrupt registered\n");
+		glamo->irq_works = 1;
+	} else {
+		dev_err(&pdev->dev, "Glamo interrupt not used\n");
+		glamo->irq_works = 0;
+	}
+
+
+	/* confirm it isn't insane version */
+	if (!glamo_supported(glamo)) {
+		dev_err(&pdev->dev, "This Glamo is not supported\n");
+		goto bail_irq;
+	}
+
+	/* sysfs */
+	rc = sysfs_create_group(&pdev->dev.kobj, &glamo_attr_group);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "cannot create sysfs group\n");
+		goto bail_irq;
+	}
+
+	/* init the chip with canned register set */
+
+	dev_dbg(&glamo->pdev->dev, "running init script\n");
+	glamo_run_script(glamo, glamo_init_script,
+			 ARRAY_SIZE(glamo_init_script), 1);
+
+	dev_info(&glamo->pdev->dev, "Glamo core PLL1: %uHz, PLL2: %uHz\n",
+		 glamo_pll_rate(glamo, GLAMO_PLL1),
+		 glamo_pll_rate(glamo, GLAMO_PLL2));
+
+	/* bring MCI specific stuff over from our MFD platform data */
+	glamo_mci_def_pdata.glamo_can_set_mci_power =
+					glamo->pdata->glamo_can_set_mci_power;
+	glamo_mci_def_pdata.glamo_mci_use_slow =
+					glamo->pdata->glamo_mci_use_slow;
+	glamo_mci_def_pdata.glamo_irq_is_wired =
+					glamo->pdata->glamo_irq_is_wired;
+
+	/* start creating the siblings */
+
+	glamo_2d_dev.dev.parent = &pdev->dev;
+	mangle_mem_resources(glamo_2d_dev.resource,
+			     glamo_2d_dev.num_resources, glamo->mem);
+	platform_device_register(&glamo_2d_dev);
+
+	glamo_3d_dev.dev.parent = &pdev->dev;
+	mangle_mem_resources(glamo_3d_dev.resource,
+			     glamo_3d_dev.num_resources, glamo->mem);
+	platform_device_register(&glamo_3d_dev);
+
+	glamo_jpeg_dev.dev.parent = &pdev->dev;
+	mangle_mem_resources(glamo_jpeg_dev.resource,
+			     glamo_jpeg_dev.num_resources, glamo->mem);
+	platform_device_register(&glamo_jpeg_dev);
+
+	glamo_mpeg_dev.dev.parent = &pdev->dev;
+	mangle_mem_resources(glamo_mpeg_dev.resource,
+			     glamo_mpeg_dev.num_resources, glamo->mem);
+	platform_device_register(&glamo_mpeg_dev);
+
+	glamo->pdata->glamo = glamo;
+	glamo_fb_dev.dev.parent = &pdev->dev;
+	glamo_fb_dev.dev.platform_data = glamo->pdata;
+	mangle_mem_resources(glamo_fb_dev.resource,
+			     glamo_fb_dev.num_resources, glamo->mem);
+	platform_device_register(&glamo_fb_dev);
+
+	glamo->pdata->spigpio_info->glamo = glamo;
+	glamo_spigpio_dev.dev.parent = &pdev->dev;
+	glamo_spigpio_dev.dev.platform_data = glamo->pdata->spigpio_info;
+	platform_device_register(&glamo_spigpio_dev);
+
+	glamo_mmc_dev = glamo->pdata->mmc_dev;
+	glamo_mmc_dev->name = "glamo-mci";
+	glamo_mmc_dev->dev.parent = &pdev->dev;
+	glamo_mmc_dev->resource = glamo_mmc_resources;
+	glamo_mmc_dev->num_resources = ARRAY_SIZE(glamo_mmc_resources); 
+
+	/* we need it later to give to the engine enable and disable */
+	glamo_mci_def_pdata.pglamo = glamo;
+	mangle_mem_resources(glamo_mmc_dev->resource,
+			     glamo_mmc_dev->num_resources, glamo->mem);
+	platform_device_register(glamo_mmc_dev);
+
+	/* only request the generic, hostbus and memory controller MMIO */
+	glamo->mem = request_mem_region(glamo->mem->start,
+					GLAMO_REGOFS_VIDCAP, "glamo-core");
+	if (!glamo->mem) {
+		dev_err(&pdev->dev, "failed to request memory region\n");
+		goto bail_irq;
+	}
+
+	return 0;
+
+bail_irq:
+	disable_irq(glamo->irq);
+	set_irq_chained_handler(glamo->irq, NULL);
+
+	for (irq = IRQ_GLAMO(0); irq <= IRQ_GLAMO(8); irq++) {
+		set_irq_flags(irq, 0);
+		set_irq_chip(irq, NULL);
+	}
+
+	iounmap(glamo->base);
+bail_free:
+	platform_set_drvdata(pdev, NULL);
+	glamo_handle = NULL;
+	kfree(glamo);
+
+	return rc;
+}
+
+static int glamo_remove(struct platform_device *pdev)
+{
+	struct glamo_core *glamo = platform_get_drvdata(pdev);
+	int irq;
+
+	disable_irq(glamo->irq);
+	set_irq_chained_handler(glamo->irq, NULL);
+
+	for (irq = IRQ_GLAMO(0); irq <= IRQ_GLAMO(8); irq++) {
+		set_irq_flags(irq, 0);
+		set_irq_chip(irq, NULL);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+	platform_device_unregister(&glamo_fb_dev);
+	platform_device_unregister(glamo->pdata->mmc_dev);
+	iounmap(glamo->base);
+	release_mem_region(glamo->mem->start, GLAMO_REGOFS_VIDCAP);
+	glamo_handle = NULL;
+	kfree(glamo);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int glamo_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	glamo_handle->suspending = 1;
+	glamo_power(glamo_handle, GLAMO_POWER_SUSPEND);
+
+	return 0;
+}
+
+static int glamo_resume(struct platform_device *pdev)
+{
+	glamo_power(glamo_handle, GLAMO_POWER_ON);
+	glamo_handle->suspending = 0;
+
+	return 0;
+}
+
+#else
+#define glamo_suspend NULL
+#define glamo_resume  NULL
+#endif
+
+static struct platform_driver glamo_driver = {
+	.probe		= glamo_probe,
+	.remove		= glamo_remove,
+	.suspend	= glamo_suspend,
+	.resume	= glamo_resume,
+	.driver		= {
+		.name	= "glamo3362",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __devinit glamo_init(void)
+{
+	return platform_driver_register(&glamo_driver);
+}
+
+static void __exit glamo_cleanup(void)
+{
+	platform_driver_unregister(&glamo_driver);
+}
+
+module_init(glamo_init);
+module_exit(glamo_cleanup);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("Smedia Glamo 336x/337x core/resource driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-core.h linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-core.h
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-core.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,92 @@
+#ifndef __GLAMO_CORE_H
+#define __GLAMO_CORE_H
+
+#include <asm/system.h>
+
+/* for the time being, we put the on-screen framebuffer into the lowest
+ * VRAM space.  This should make the code easily compatible with the various
+ * 2MB/4MB/8MB variants of the Smedia chips */
+#define GLAMO_OFFSET_VRAM	0x800000
+#define GLAMO_OFFSET_FB	(GLAMO_OFFSET_VRAM)
+
+/* we only allocate the minimum possible size for the framebuffer to make
+ * sure we have sufficient memory for other functions of the chip */
+//#define GLAMO_FB_SIZE	(640*480*4)	/* == 0x12c000 */
+#define GLAMO_INTERNAL_RAM_SIZE 0x800000
+#define GLAMO_MMC_BUFFER_SIZE (64 * 1024)
+#define GLAMO_FB_SIZE	(GLAMO_INTERNAL_RAM_SIZE - GLAMO_MMC_BUFFER_SIZE)
+
+struct glamo_core {
+	int irq;
+	int irq_works; /* 0 means PCB does not support Glamo IRQ */
+	struct resource *mem;
+	struct resource *mem_core;
+	void __iomem *base;
+	struct platform_device *pdev;
+	struct glamofb_platform_data *pdata;
+	u_int16_t type;
+	u_int16_t revision;
+	spinlock_t lock;
+	u32 engine_enabled_bitfield;
+	u32 engine_enabled_bitfield_suspend;
+	int suspending;
+};
+
+struct glamo_script {
+	u_int16_t reg;
+	u_int16_t val;
+};
+
+int glamo_run_script(struct glamo_core *glamo,
+		     struct glamo_script *script, int len, int may_sleep);
+
+enum glamo_engine {
+	GLAMO_ENGINE_CAPTURE,
+	GLAMO_ENGINE_ISP,
+	GLAMO_ENGINE_JPEG,
+	GLAMO_ENGINE_MPEG_ENC,
+	GLAMO_ENGINE_MPEG_DEC,
+	GLAMO_ENGINE_LCD,
+	GLAMO_ENGINE_CMDQ,
+	GLAMO_ENGINE_2D,
+	GLAMO_ENGINE_3D,
+	GLAMO_ENGINE_MMC,
+	GLAMO_ENGINE_MICROP0,
+	GLAMO_ENGINE_RISC,
+	GLAMO_ENGINE_MICROP1_MPEG_ENC,
+	GLAMO_ENGINE_MICROP1_MPEG_DEC,
+#if 0
+	GLAMO_ENGINE_H264_DEC,
+	GLAMO_ENGINE_RISC1,
+	GLAMO_ENGINE_SPI,
+#endif
+	__NUM_GLAMO_ENGINES
+};
+
+struct glamo_mci_pdata {
+	struct glamo_core * pglamo;
+	unsigned int	gpio_detect;
+	unsigned int	gpio_wprotect;
+	unsigned long	ocr_avail;
+	int		(*glamo_can_set_mci_power)(void);
+	/* glamo-mci asking if it should use the slow clock to card */
+	int		(*glamo_mci_use_slow)(void);
+	int		(*glamo_irq_is_wired)(void);
+	void		(*mci_suspending)(struct platform_device *dev);
+	int		(*mci_all_dependencies_resumed)(struct platform_device *dev);
+
+};
+
+int glamo_engine_enable(struct glamo_core *glamo, enum glamo_engine engine);
+int glamo_engine_disable(struct glamo_core *glamo, enum glamo_engine engine);
+void glamo_engine_reset(struct glamo_core *glamo, enum glamo_engine engine);
+int glamo_engine_reclock(struct glamo_core *glamo,
+			 enum glamo_engine engine, int ps);
+
+void glamo_engine_clkreg_set(struct glamo_core *glamo,
+			     enum glamo_engine engine,
+			     u_int16_t mask, u_int16_t val);
+
+u_int16_t glamo_engine_clkreg_get(struct glamo_core *glamo,
+				  enum glamo_engine engine);
+#endif /* __GLAMO_CORE_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-fb.c linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-fb.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-fb.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,1193 @@
+/* Smedia Glamo 336x/337x driver
+ *
+ * (C) 2007-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include <asm/div64.h>
+
+#ifdef CONFIG_PM
+#include <linux/pm.h>
+#endif
+
+#include <linux/glamofb.h>
+
+#include "glamo-regs.h"
+#include "glamo-core.h"
+
+#ifndef DEBUG
+#define GLAMO_LOG(...)
+#else
+#define GLAMO_LOG(...) \
+do { \
+	printk(KERN_DEBUG "in %s:%s:%d", __FILE__, __func__, __LINE__); \
+	printk(KERN_DEBUG __VA_ARGS__); \
+} while (0);
+#endif
+
+
+#define RESSIZE(ressource) (((ressource)->end - (ressource)->start)+1)
+
+struct glamofb_handle {
+	struct fb_info *fb;
+	struct device *dev;
+	struct resource *reg;
+	struct resource *fb_res;
+	char __iomem *base;
+	struct glamofb_platform_data *mach_info;
+	char __iomem *cursor_addr;
+	int cursor_on;
+	u_int32_t pseudo_pal[16];
+	spinlock_t lock_cmd;
+	int angle;	/* Current rotation angle */
+	int blank_mode;
+};
+
+/* 'sibling' spi device for lcm init */
+static struct platform_device glamo_spi_dev = {
+	.name		= "glamo-lcm-spi",
+};
+
+
+static int reg_read(struct glamofb_handle *glamo,
+			   u_int16_t reg)
+{
+	int i = 0;
+
+	for (i = 0; i != 2; i++)
+		nop();
+
+	return readw(glamo->base + reg);
+}
+
+static void reg_write(struct glamofb_handle *glamo,
+			     u_int16_t reg, u_int16_t val)
+{
+	int i = 0;
+
+	for (i = 0; i != 2; i++)
+		nop();
+
+	writew(val, glamo->base + reg);
+}
+
+static struct glamo_script glamo_regs[] = {
+	{ GLAMO_REG_LCD_MODE1, 0x0020 },
+	/* no display rotation, no hardware cursor, no dither, no gamma,
+	 * no retrace flip, vsync low-active, hsync low active,
+	 * no TVCLK, no partial display, hw dest color from fb,
+	 * no partial display mode, LCD1, software flip,  */
+	{ GLAMO_REG_LCD_MODE2, 0x9020 },
+	  /* video flip, no ptr, no ptr, dhclk off,
+	   * normal mode,  no cpuif,
+	   * res, serial msb first, single fb, no fr ctrl,
+	   * cpu if bits all zero, no crc
+	   * 0000 0000 0010  0000 */
+	{ GLAMO_REG_LCD_MODE3, 0x0b40 },
+	  /* src data rgb565, res, 18bit rgb666
+	   * 000 01 011 0100 0000 */
+	{ GLAMO_REG_LCD_POLARITY, 0x440c },
+	  /* DE high active, no cpu/lcd if, cs0 force low, a0 low active,
+	   * np cpu if, 9bit serial data, sclk rising edge latch data
+	   * 01 00 0 100 0 000 01 0 0 */
+	/* The following values assume 640*480@16bpp */
+	{ GLAMO_REG_LCD_A_BASE1, 0x0000 }, /* display A base address 15:0 */
+	{ GLAMO_REG_LCD_A_BASE2, 0x0000 }, /* display A base address 22:16 */
+	{ GLAMO_REG_LCD_B_BASE1, 0x6000 }, /* display B base address 15:0 */
+	{ GLAMO_REG_LCD_B_BASE2, 0x0009 }, /* display B base address 22:16 */
+	{ GLAMO_REG_LCD_CURSOR_BASE1, 0xC000 }, /* cursor base address 15:0 */
+	{ GLAMO_REG_LCD_CURSOR_BASE2, 0x0012 }, /* cursor base address 22:16 */
+	{ GLAMO_REG_LCD_COMMAND2, 0x0000 }, /* display page A */
+};
+
+static int glamofb_run_script(struct glamofb_handle *glamo,
+				struct glamo_script *script, int len)
+{
+	int i;
+
+	if (glamo->mach_info->glamo->suspending) {
+		dev_err(&glamo->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_run_script while "
+								 "suspended\n");
+		return -EBUSY;
+	}
+
+	for (i = 0; i < len; i++) {
+		struct glamo_script *line = &script[i];
+
+		if (line->reg == 0xffff)
+			return 0;
+		else if (line->reg == 0xfffe)
+			msleep(line->val);
+		else
+			reg_write(glamo, script[i].reg, script[i].val);
+	}
+
+	return 0;
+}
+
+static int glamofb_check_var(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	struct glamofb_handle *glamo = info->par;
+
+	if (glamo->mach_info->glamo->suspending) {
+		dev_err(&glamo->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_check_var while "
+								 "suspended\n");
+		return -EBUSY;
+	}
+
+	if (var->yres > glamo->mach_info->yres.max)
+		var->yres = glamo->mach_info->yres.max;
+	else if (var->yres < glamo->mach_info->yres.min)
+		var->yres = glamo->mach_info->yres.min;
+
+	if (var->xres > glamo->mach_info->xres.max)
+		var->xres = glamo->mach_info->xres.max;
+	else if (var->xres < glamo->mach_info->xres.min)
+		var->xres = glamo->mach_info->xres.min;
+
+	if (var->bits_per_pixel > glamo->mach_info->bpp.max)
+		var->bits_per_pixel = glamo->mach_info->bpp.max;
+	else if (var->bits_per_pixel < glamo->mach_info->bpp.min)
+		var->bits_per_pixel = glamo->mach_info->bpp.min;
+
+	/* FIXME: set rgb positions */
+	switch (var->bits_per_pixel) {
+	case 16:
+		switch (reg_read(glamo, GLAMO_REG_LCD_MODE3) & 0xc000) {
+		case GLAMO_LCD_SRC_RGB565:
+			var->red.offset		= 11;
+			var->green.offset	= 5;
+			var->blue.offset	= 0;
+			var->red.length		= 5;
+			var->green.length	= 6;
+			var->blue.length	= 5;
+			var->transp.length	= 0;
+			break;
+		case GLAMO_LCD_SRC_ARGB1555:
+			var->transp.offset	= 15;
+			var->red.offset		= 10;
+			var->green.offset	= 5;
+			var->blue.offset	= 0;
+			var->transp.length	= 1;
+			var->red.length		= 5;
+			var->green.length	= 5;
+			var->blue.length	= 5;
+			break;
+		case GLAMO_LCD_SRC_ARGB4444:
+			var->transp.offset	= 12;
+			var->red.offset		= 8;
+			var->green.offset	= 4;
+			var->blue.offset	= 0;
+			var->transp.length	= 4;
+			var->red.length		= 4;
+			var->green.length	= 4;
+			var->blue.length	= 4;
+			break;
+		}
+		break;
+	case 24:
+	case 32:
+	default:
+		/* The Smedia Glamo doesn't support anything but 16bit color */
+		printk(KERN_ERR
+		       "Smedia driver does not [yet?] support 24/32bpp\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void reg_set_bit_mask(struct glamofb_handle *glamo,
+			     u_int16_t reg, u_int16_t mask,
+			     u_int16_t val)
+{
+	u_int16_t tmp;
+
+	val &= mask;
+
+	tmp = reg_read(glamo, reg);
+	tmp &= ~mask;
+	tmp |= val;
+	reg_write(glamo, reg, tmp);
+}
+
+#define GLAMO_LCD_WIDTH_MASK 0x03FF
+#define GLAMO_LCD_HEIGHT_MASK 0x03FF
+#define GLAMO_LCD_PITCH_MASK 0x07FE
+#define GLAMO_LCD_HV_TOTAL_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_START_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_END_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_DISP_START_MASK 0x03FF
+#define GLAMO_LCD_HV_RETR_DISP_END_MASK 0x03FF
+
+enum orientation {ORIENTATION_PORTRAIT, ORIENTATION_LANDSCAPE};
+
+/* the caller has to enxure lock_cmd is held and we are in cmd mode */
+static void __rotate_lcd(struct glamofb_handle *glamo, __u32 rotation)
+{
+	int glamo_rot;
+
+	if (glamo->mach_info->glamo->suspending) {
+		dev_err(&glamo->mach_info->glamo->pdev->dev,
+				"IGNORING rotate_lcd while "
+								 "suspended\n");
+		return;
+	}
+
+	switch (rotation) {
+	case FB_ROTATE_UR:
+		glamo_rot = GLAMO_LCD_ROT_MODE_0;
+		glamo->angle = 0;
+		break;
+	case FB_ROTATE_CW:
+		glamo_rot = GLAMO_LCD_ROT_MODE_90;
+		glamo->angle = 90;
+		break;
+	case FB_ROTATE_UD:
+		glamo_rot = GLAMO_LCD_ROT_MODE_180;
+		glamo->angle = 180;
+		break;
+	case FB_ROTATE_CCW:
+		glamo_rot = GLAMO_LCD_ROT_MODE_270;
+		glamo->angle = 270;
+		break;
+	default:
+		glamo->angle = 0;
+		glamo_rot = GLAMO_LCD_ROT_MODE_0;
+		break;
+	}
+
+	reg_set_bit_mask(glamo,
+			 GLAMO_REG_LCD_WIDTH,
+			 GLAMO_LCD_ROT_MODE_MASK,
+			 glamo_rot);
+	reg_set_bit_mask(glamo,
+			 GLAMO_REG_LCD_MODE1,
+			 GLAMO_LCD_MODE1_ROTATE_EN,
+			 (glamo_rot != GLAMO_LCD_ROT_MODE_0) ?
+				 GLAMO_LCD_MODE1_ROTATE_EN : 0);
+}
+
+static enum orientation get_orientation(struct fb_var_screeninfo *var)
+{
+	if (var->xres <= var->yres)
+		return ORIENTATION_PORTRAIT;
+
+	return ORIENTATION_LANDSCAPE;
+}
+
+static int will_orientation_change(struct fb_var_screeninfo *var)
+{
+	enum orientation orient = get_orientation(var);
+
+	switch (orient) {
+	case ORIENTATION_LANDSCAPE:
+		if (var->rotate == FB_ROTATE_UR || var->rotate == FB_ROTATE_UD)
+			return 1;
+		break;
+	case ORIENTATION_PORTRAIT:
+		if (var->rotate == FB_ROTATE_CW || var->rotate == FB_ROTATE_CCW)
+			return 1;
+		break;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_MFD_GLAMO_FB_XGLAMO_WORKAROUND
+
+/*
+ * See https://docs.openmoko.org/trac/ticket/2255
+ * We have a hack for some Xglamo bugs in kernel code.
+ * If someone fixes xglamo we can remove this hack.
+ * We might make xglamo_hack_enabled 0 by default in the future.
+ */
+
+static unsigned xglamo_hack_enabled = 1;
+
+static ssize_t xglamo_hack_read(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", xglamo_hack_enabled);
+}
+
+static ssize_t xglamo_hack_write(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	unsigned long val;
+
+	if (!strict_strtoul(buf, 10, &val))
+		xglamo_hack_enabled = !!val;
+
+	return count;
+}
+
+static DEVICE_ATTR(xglamo_hack, S_IWUSR | S_IRUGO, xglamo_hack_read,
+		   xglamo_hack_write);
+
+static struct attribute *glamo_fb_sysfs_entries[] = {
+	&dev_attr_xglamo_hack.attr,
+	NULL
+};
+
+static struct attribute_group glamo_fb_attr_group = {
+	.name		= NULL,
+	.attrs		= glamo_fb_sysfs_entries,
+};
+
+/* This function implements the actual Xglamo hack. */
+
+static void glamofb_update_lcd_controller_hack(struct glamofb_handle *glamo,
+					       struct fb_var_screeninfo *var,
+					       int *xres, int *yres, int *pitch)
+{
+	int width, height;
+
+	if (glamo->angle == 90 || glamo->angle == 270) {
+		/*
+		 * But if we are going back to portrait mode from here,
+		 * we get inverted values from Xglamo
+		 */
+		if (!(var->rotate == FB_ROTATE_UR ||
+				var->rotate == FB_ROTATE_UD)) {
+			width = var->yres;
+			height = var->xres;
+		} else {
+			width = var->xres;
+			height = var->yres;
+		}
+
+	} else {
+		width = var->xres;
+		height = var->yres;
+	}
+
+	/* Portrait ? */
+	if (var->rotate == FB_ROTATE_UR || var->rotate == FB_ROTATE_UD) {
+		/* We don't need to set xres and yres in this particular case
+		 * because Xglamo does it for us */
+		if (!(glamo->angle == 90 || glamo->angle == 270)) {
+			var->xres = width;
+			var->yres = height;
+		}
+
+		var->xres_virtual = width;
+		var->yres_virtual = height * 2;
+		*pitch = width * var->bits_per_pixel / 8;
+	} else {
+		var->xres = height;
+		var->yres = width;
+		var->xres_virtual = height * 2;
+		var->yres_virtual = width;
+		*pitch = height * var->bits_per_pixel / 8;
+	}
+
+	*xres = width;
+	*yres = height;
+}
+#else
+#define xglamo_hack_enabled 0
+static void glamofb_update_lcd_controller_hack(struct glamofb_handle *glamo,
+					       struct fb_var_screeninfo *var,
+					       int *xres, int *yres, int *pitch)
+{
+}
+#endif
+
+static void glamofb_update_lcd_controller(struct glamofb_handle *glamo,
+					  struct fb_var_screeninfo *var)
+{
+	int sync, bp, disp, fp, total, xres, yres, pitch;
+	int uninitialized_var(orientation_changing);
+	unsigned long flags;
+
+	if (!glamo || !var)
+		return;
+
+	if (glamo->mach_info->glamo->suspending) {
+		dev_err(&glamo->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_update_lcd_controller while "
+								 "suspended\n");
+		return;
+	}
+
+	dev_dbg(&glamo->mach_info->glamo->pdev->dev,
+			  "glamofb_update_lcd_controller spin_lock_irqsave\n");
+	spin_lock_irqsave(&glamo->lock_cmd, flags);
+
+	if (glamofb_cmd_mode(glamo, 1))
+		goto out_unlock;
+
+	if (var->pixclock)
+		glamo_engine_reclock(glamo->mach_info->glamo,
+				     GLAMO_ENGINE_LCD,
+				     var->pixclock);
+
+	if (xglamo_hack_enabled) {
+		glamofb_update_lcd_controller_hack(glamo, var, &xres, &yres,
+						   &pitch);
+	} else {
+		xres = var->xres;
+		yres = var->yres;
+
+		orientation_changing = will_orientation_change(var);
+		/* Adjust the pitch according to new orientation to come. */
+		if (orientation_changing)
+			pitch = var->yres * var->bits_per_pixel / 8;
+		else
+			pitch = var->xres * var->bits_per_pixel / 8;
+	}
+
+	reg_set_bit_mask(glamo,
+			 GLAMO_REG_LCD_WIDTH,
+			 GLAMO_LCD_WIDTH_MASK,
+			 xres);
+	reg_set_bit_mask(glamo,
+			 GLAMO_REG_LCD_HEIGHT,
+			 GLAMO_LCD_HEIGHT_MASK,
+			 yres);
+	reg_set_bit_mask(glamo,
+			 GLAMO_REG_LCD_PITCH,
+			 GLAMO_LCD_PITCH_MASK,
+			 pitch);
+
+	/* honour the rotation request */
+	__rotate_lcd(glamo, var->rotate);
+
+	if (!xglamo_hack_enabled) {
+		/* update the reported geometry of the framebuffer. */
+		if (orientation_changing) {
+			var->xres_virtual = yres;
+			var->xres = yres;
+			var->xres_virtual *= 2;
+			var->yres_virtual = xres;
+			var->yres = xres;
+		} else {
+			var->xres_virtual = xres;
+			var->yres_virtual = yres;
+			var->yres_virtual *= 2;
+		}
+	}
+
+	/* update scannout timings */
+	sync = 0;
+	bp = sync + var->hsync_len;
+	disp = bp + var->left_margin;
+	fp = disp + xres;
+	total = fp + var->right_margin;
+
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_HORIZ_TOTAL,
+			 GLAMO_LCD_HV_TOTAL_MASK, total);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_HORIZ_RETR_START,
+			 GLAMO_LCD_HV_RETR_START_MASK, sync);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_HORIZ_RETR_END,
+			 GLAMO_LCD_HV_RETR_END_MASK, bp);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_HORIZ_DISP_START,
+			  GLAMO_LCD_HV_RETR_DISP_START_MASK, disp);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_HORIZ_DISP_END,
+			 GLAMO_LCD_HV_RETR_DISP_END_MASK, fp);
+
+	sync = 0;
+	bp = sync + var->vsync_len;
+	disp = bp + var->upper_margin;
+	fp = disp + yres;
+	total = fp + var->lower_margin;
+
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_VERT_TOTAL,
+			 GLAMO_LCD_HV_TOTAL_MASK, total);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_VERT_RETR_START,
+			  GLAMO_LCD_HV_RETR_START_MASK, sync);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_VERT_RETR_END,
+			 GLAMO_LCD_HV_RETR_END_MASK, bp);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_VERT_DISP_START,
+			 GLAMO_LCD_HV_RETR_DISP_START_MASK, disp);
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_VERT_DISP_END,
+			 GLAMO_LCD_HV_RETR_DISP_END_MASK, fp);
+
+	glamofb_cmd_mode(glamo, 0);
+
+out_unlock:
+	dev_dbg(&glamo->mach_info->glamo->pdev->dev,
+		      "glamofb_update_lcd_controller spin_unlock_irqrestore\n");
+	spin_unlock_irqrestore(&glamo->lock_cmd, flags);
+}
+
+static int glamofb_pan_display(struct fb_var_screeninfo *var,
+		struct fb_info *info)
+{
+	struct glamofb_handle *glamo = info->par;
+	u_int16_t page = var->yoffset / glamo->mach_info->yres.defval;
+	reg_write(glamo, GLAMO_REG_LCD_COMMAND2, page);
+
+	return 0;
+}
+
+static int glamofb_set_par(struct fb_info *info)
+{
+	struct glamofb_handle *glamo = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+
+	if (glamo->mach_info->glamo->suspending) {
+		dev_err(&glamo->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_set_par while "
+								 "suspended\n");
+		return -EBUSY;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		break;
+	default:
+		printk("Smedia driver doesn't support != 16bpp\n");
+		return -EINVAL;
+	}
+
+	info->fix.line_length = (var->xres * var->bits_per_pixel) / 8;
+
+	glamofb_update_lcd_controller(glamo, var);
+
+	return 0;
+}
+
+
+static void notify_blank(struct fb_info *info, int blank_mode)
+{
+	struct fb_event event;
+
+	event.info = info;
+	event.data = &blank_mode;
+	fb_notifier_call_chain(FB_EVENT_CONBLANK, &event);
+}
+
+
+static int glamofb_blank(int blank_mode, struct fb_info *info)
+{
+	struct glamofb_handle *gfb = info->par;
+	struct glamo_core *gcore = gfb->mach_info->glamo;
+
+	dev_dbg(gfb->dev, "glamofb_blank(%u)\n", blank_mode);
+
+	switch (blank_mode) {
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+		/* FIXME: add pdata hook/flag to indicate whether
+		 * we should already switch off pixel clock here */
+		break;
+	case FB_BLANK_POWERDOWN:
+		/* Simulating FB_BLANK_NORMAL allow turning off backlight */
+		if (gfb->blank_mode != FB_BLANK_NORMAL)
+			notify_blank(info, FB_BLANK_NORMAL);
+
+		/* LCM need notification before pixel clock is stopped */
+		notify_blank(info, blank_mode);
+
+		/* disable the pixel clock */
+		glamo_engine_clkreg_set(gcore, GLAMO_ENGINE_LCD,
+					GLAMO_CLOCK_LCD_EN_DCLK, 0);
+		gfb->blank_mode = blank_mode;
+		break;
+	case FB_BLANK_UNBLANK:
+	case FB_BLANK_NORMAL:
+		/* enable the pixel clock if off */
+		if (gfb->blank_mode == FB_BLANK_POWERDOWN)
+			glamo_engine_clkreg_set(gcore,
+					GLAMO_ENGINE_LCD,
+					GLAMO_CLOCK_LCD_EN_DCLK,
+					GLAMO_CLOCK_LCD_EN_DCLK);
+
+		notify_blank(info, blank_mode);
+		gfb->blank_mode = blank_mode;
+		break;
+	}
+
+	/* FIXME: once we have proper clock management in glamo-core,
+	 * we can determine if other units need MCLK1 or the PLL, and
+	 * disable it if not used. */
+	return 0;
+}
+
+static inline unsigned int chan_to_field(unsigned int chan,
+					 struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int glamofb_setcolreg(unsigned regno,
+			     unsigned red, unsigned green, unsigned blue,
+			     unsigned transp, struct fb_info *info)
+{
+	struct glamofb_handle *glamo = info->par;
+	unsigned int val;
+
+	if (glamo->mach_info->glamo->suspending) {
+		dev_err(&glamo->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_set_par while "
+								 "suspended\n");
+		return -EBUSY;
+	}
+
+	switch (glamo->fb->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+	case FB_VISUAL_DIRECTCOLOR:
+		/* true-colour, use pseuo-palette */
+
+		if (regno < 16) {
+			u32 *pal = glamo->fb->pseudo_palette;
+
+			val  = chan_to_field(red, &glamo->fb->var.red);
+			val |= chan_to_field(green, &glamo->fb->var.green);
+			val |= chan_to_field(blue, &glamo->fb->var.blue);
+
+			pal[regno] = val;
+		};
+		break;
+	default:
+		return 1; /* unknown type */
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_MFD_GLAMO_HWACCEL
+static inline void glamofb_vsync_wait(struct glamofb_handle *glamo,
+		int line, int size, int range)
+{
+	int count[2];
+
+	do {
+		count[0] = reg_read(glamo, GLAMO_REG_LCD_STATUS2) & 0x3ff;
+		count[1] = reg_read(glamo, GLAMO_REG_LCD_STATUS2) & 0x3ff;
+	} while (count[0] != count[1] ||
+			(line < count[0] + range &&
+			 size > count[0] - range) ||
+			count[0] < range * 2);
+}
+
+/*
+ * Enable/disable the hardware cursor mode altogether
+ * (for blinking and such, use glamofb_cursor()).
+ */
+static void glamofb_cursor_onoff(struct glamofb_handle *glamo, int on)
+{
+	int y, size;
+
+	if (glamo->cursor_on) {
+		y = reg_read(glamo, GLAMO_REG_LCD_CURSOR_Y_POS);
+		size = reg_read(glamo, GLAMO_REG_LCD_CURSOR_Y_SIZE);
+
+		glamofb_vsync_wait(glamo, y, size, 30);
+	}
+
+	reg_set_bit_mask(glamo, GLAMO_REG_LCD_MODE1,
+			GLAMO_LCD_MODE1_CURSOR_EN,
+			on ? GLAMO_LCD_MODE1_CURSOR_EN : 0);
+	glamo->cursor_on = on;
+
+	/* Hide the cursor by default */
+	reg_write(glamo, GLAMO_REG_LCD_CURSOR_X_SIZE, 0);
+}
+
+static int glamofb_cursor(struct fb_info *info, struct fb_cursor *cursor)
+{
+	struct glamofb_handle *glamo = info->par;
+	unsigned long flags;
+
+	spin_lock_irqsave(&glamo->lock_cmd, flags);
+
+	reg_write(glamo, GLAMO_REG_LCD_CURSOR_X_SIZE,
+			cursor->enable ? cursor->image.width : 0);
+
+	if (cursor->set & FB_CUR_SETPOS) {
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_X_POS,
+			  cursor->image.dx);
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_Y_POS,
+			  cursor->image.dy);
+	}
+
+	if (cursor->set & FB_CUR_SETCMAP) {
+		uint16_t fg = glamo->pseudo_pal[cursor->image.fg_color];
+		uint16_t bg = glamo->pseudo_pal[cursor->image.bg_color];
+
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_FG_COLOR, fg);
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_BG_COLOR, bg);
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_DST_COLOR, fg);
+	}
+
+	if (cursor->set & FB_CUR_SETHOT)
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_PRESET,
+				(cursor->hot.x << 8) | cursor->hot.y);
+
+	if ((cursor->set & FB_CUR_SETSIZE) ||
+	    (cursor->set & (FB_CUR_SETIMAGE | FB_CUR_SETSHAPE))) {
+		int x, y, pitch, op;
+		const uint8_t *pcol = cursor->image.data;
+		const uint8_t *pmsk = cursor->mask;
+		uint8_t __iomem *dst = glamo->cursor_addr;
+		uint8_t dcol = 0;
+		uint8_t dmsk = 0;
+		uint8_t byte = 0;
+
+		if (cursor->image.depth > 1) {
+			spin_unlock_irqrestore(&glamo->lock_cmd, flags);
+			return -EINVAL;
+		}
+
+		pitch = ((cursor->image.width + 7) >> 2) & ~1;
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_PITCH,
+			pitch);
+		reg_write(glamo, GLAMO_REG_LCD_CURSOR_Y_SIZE,
+			cursor->image.height);
+
+		for (y = 0; y < cursor->image.height; y++) {
+			byte = 0;
+			for (x = 0; x < cursor->image.width; x++) {
+				if ((x % 8) == 0) {
+					dcol = *pcol++;
+					dmsk = *pmsk++;
+				} else {
+					dcol >>= 1;
+					dmsk >>= 1;
+				}
+
+				if (cursor->rop == ROP_COPY)
+					op = (dmsk & 1) ?
+						(dcol & 1) ? 1 : 3 : 0;
+				else
+					op = ((dmsk & 1) << 1) |
+						((dcol & 1) << 0);
+				byte |= op << ((x & 3) << 1);
+
+				if (x % 4 == 3) {
+					writeb(byte, dst + x / 4);
+					byte = 0;
+				}
+			}
+			if (x % 4) {
+				writeb(byte, dst + x / 4);
+				byte = 0;
+			}
+
+			dst += pitch;
+		}
+	}
+
+	spin_unlock_irqrestore(&glamo->lock_cmd, flags);
+
+	return 0;
+}
+#endif
+
+static inline int glamofb_cmdq_empty(struct glamofb_handle *gfb)
+{
+	/* DGCMdQempty -- 1 == command queue is empty */
+	return reg_read(gfb, GLAMO_REG_LCD_STATUS1) & (1 << 15);
+}
+
+/* call holding gfb->lock_cmd  when locking, until you unlock */
+int glamofb_cmd_mode(struct glamofb_handle *gfb, int on)
+{
+	int timeout = 2000000;
+
+	if (gfb->mach_info->glamo->suspending) {
+		dev_err(&gfb->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_cmd_mode while "
+								 "suspended\n");
+		return -EBUSY;
+	}
+
+	dev_dbg(gfb->dev, "glamofb_cmd_mode(gfb=%p, on=%d)\n", gfb, on);
+	if (on) {
+		dev_dbg(gfb->dev, "%s: waiting for cmdq empty: ",
+			__func__);
+		while ((!glamofb_cmdq_empty(gfb)) && (timeout--))
+			/* yield() */;
+		if (timeout < 0) {
+			printk(KERN_ERR"*************"
+				       "glamofb cmd_queue never got empty"
+				       "*************\n");
+			return -EIO;
+		}
+		dev_dbg(gfb->dev, "empty!\n");
+
+		/* display the entire frame then switch to command */
+		reg_write(gfb, GLAMO_REG_LCD_COMMAND1,
+			  GLAMO_LCD_CMD_TYPE_DISP |
+			  GLAMO_LCD_CMD_DATA_FIRE_VSYNC);
+
+		/* wait until lcd idle */
+		dev_dbg(gfb->dev, "waiting for lcd idle: ");
+		timeout = 2000000;
+		while ((!reg_read(gfb, GLAMO_REG_LCD_STATUS2) & (1 << 12)) &&
+		      (timeout--))
+			/* yield() */;
+		if (timeout < 0) {
+			printk(KERN_ERR"*************"
+				       "glamofb lcd never idle"
+				       "*************\n");
+			return -EIO;
+		}
+
+		mdelay(100);
+
+		dev_dbg(gfb->dev, "cmd mode entered\n");
+
+	} else {
+		/* RGB interface needs vsync/hsync */
+		if (reg_read(gfb, GLAMO_REG_LCD_MODE3) & GLAMO_LCD_MODE3_RGB)
+			reg_write(gfb, GLAMO_REG_LCD_COMMAND1,
+				  GLAMO_LCD_CMD_TYPE_DISP |
+				  GLAMO_LCD_CMD_DATA_DISP_SYNC);
+
+		reg_write(gfb, GLAMO_REG_LCD_COMMAND1,
+			  GLAMO_LCD_CMD_TYPE_DISP |
+			  GLAMO_LCD_CMD_DATA_DISP_FIRE);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(glamofb_cmd_mode);
+
+
+int glamofb_cmd_write(struct glamofb_handle *gfb, u_int16_t val)
+{
+	int timeout = 200000;
+
+	if (gfb->mach_info->glamo->suspending) {
+		dev_err(&gfb->mach_info->glamo->pdev->dev,
+				"IGNORING glamofb_cmd_write while "
+								 "suspended\n");
+		return -EBUSY;
+	}
+
+	dev_dbg(gfb->dev, "%s: waiting for cmdq empty\n", __func__);
+	while ((!glamofb_cmdq_empty(gfb)) && (timeout--))
+		yield();
+	if (timeout < 0) {
+		printk(KERN_ERR"*************"
+				"glamofb cmd_queue never got empty"
+				"*************\n");
+		return 1;
+	}
+	dev_dbg(gfb->dev, "idle, writing 0x%04x\n", val);
+
+	reg_write(gfb, GLAMO_REG_LCD_COMMAND1, val);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(glamofb_cmd_write);
+
+static struct fb_ops glamofb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= glamofb_check_var,
+	.fb_pan_display	= glamofb_pan_display,
+	.fb_set_par	= glamofb_set_par,
+	.fb_blank	= glamofb_blank,
+	.fb_setcolreg	= glamofb_setcolreg,
+#ifdef CONFIG_MFD_GLAMO_HWACCEL
+	.fb_cursor	= glamofb_cursor,
+#endif
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+static int glamofb_init_regs(struct glamofb_handle *glamo)
+{
+	struct fb_info *info = glamo->fb;
+
+	glamofb_check_var(&info->var, info);
+	glamofb_run_script(glamo, glamo_regs, ARRAY_SIZE(glamo_regs));
+	glamofb_set_par(info);
+
+	return 0;
+}
+
+static int __init glamofb_probe(struct platform_device *pdev)
+{
+	int rc = -EIO;
+	struct fb_info *fbinfo;
+	struct glamofb_handle *glamofb;
+	struct glamofb_platform_data *mach_info = pdev->dev.platform_data;
+
+	printk(KERN_INFO "SMEDIA Glamo frame buffer driver (C) 2007 "
+		"Openmoko, Inc.\n");
+
+	fbinfo = framebuffer_alloc(sizeof(struct glamofb_handle), &pdev->dev);
+	if (!fbinfo)
+		return -ENOMEM;
+
+	glamofb = fbinfo->par;
+	glamofb->fb = fbinfo;
+	glamofb->dev = &pdev->dev;
+
+	glamofb->angle = 0;
+	glamofb->blank_mode = FB_BLANK_POWERDOWN;
+
+	strcpy(fbinfo->fix.id, "SMedia Glamo");
+
+	glamofb->reg = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+						    "glamo-fb-regs");
+	if (!glamofb->reg) {
+		dev_err(&pdev->dev, "platform device with no registers?\n");
+		rc = -ENOENT;
+		goto out_free;
+	}
+
+	glamofb->fb_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+							"glamo-fb-mem");
+	if (!glamofb->fb_res) {
+		dev_err(&pdev->dev, "platform device with no memory ?\n");
+		rc = -ENOENT;
+		goto out_free;
+	}
+
+	glamofb->reg = request_mem_region(glamofb->reg->start,
+					  RESSIZE(glamofb->reg), pdev->name);
+	if (!glamofb->reg) {
+		dev_err(&pdev->dev, "failed to request mmio region\n");
+		goto out_free;
+	}
+
+	glamofb->fb_res = request_mem_region(glamofb->fb_res->start,
+					     mach_info->fb_mem_size,
+					     pdev->name);
+	if (!glamofb->fb_res) {
+		dev_err(&pdev->dev, "failed to request vram region\n");
+		goto out_release_reg;
+	}
+
+	/* we want to remap only the registers required for this core
+	 * driver. */
+	glamofb->base = ioremap(glamofb->reg->start, RESSIZE(glamofb->reg));
+	if (!glamofb->base) {
+		dev_err(&pdev->dev, "failed to ioremap() mmio memory\n");
+		goto out_release_fb;
+	}
+	fbinfo->fix.smem_start = (unsigned long) glamofb->fb_res->start;
+	fbinfo->fix.smem_len = mach_info->fb_mem_size;
+
+	fbinfo->screen_base = ioremap(glamofb->fb_res->start,
+				       RESSIZE(glamofb->fb_res));
+	if (!fbinfo->screen_base) {
+		dev_err(&pdev->dev, "failed to ioremap() vram memory\n");
+		goto out_release_fb;
+	}
+	glamofb->cursor_addr = fbinfo->screen_base + 0x12C000;
+
+	platform_set_drvdata(pdev, glamofb);
+
+	glamofb->mach_info = pdev->dev.platform_data;
+
+	fbinfo->fix.visual = FB_VISUAL_TRUECOLOR;
+	fbinfo->fix.type = FB_TYPE_PACKED_PIXELS;
+	fbinfo->fix.type_aux = 0;
+	fbinfo->fix.xpanstep = 0;
+	fbinfo->fix.ypanstep = mach_info->yres.defval;
+	fbinfo->fix.ywrapstep = 0;
+	fbinfo->fix.accel = FB_ACCEL_GLAMO;
+
+	fbinfo->var.nonstd = 0;
+	fbinfo->var.activate = FB_ACTIVATE_NOW;
+	fbinfo->var.height = mach_info->height;
+	fbinfo->var.width = mach_info->width;
+	fbinfo->var.accel_flags = 0;	/* FIXME */
+	fbinfo->var.vmode = FB_VMODE_NONINTERLACED;
+
+	fbinfo->fbops = &glamofb_ops;
+	fbinfo->flags = FBINFO_FLAG_DEFAULT;
+	fbinfo->pseudo_palette = &glamofb->pseudo_pal;
+
+	fbinfo->var.xres = mach_info->xres.defval;
+	fbinfo->var.xres_virtual = mach_info->xres.defval;
+	fbinfo->var.yres = mach_info->yres.defval;
+	fbinfo->var.yres_virtual = mach_info->yres.defval * 2;
+	fbinfo->var.bits_per_pixel = mach_info->bpp.defval;
+
+	fbinfo->var.pixclock = mach_info->pixclock;
+	fbinfo->var.left_margin = mach_info->left_margin;
+	fbinfo->var.right_margin = mach_info->right_margin;
+	fbinfo->var.upper_margin = mach_info->upper_margin;
+	fbinfo->var.lower_margin = mach_info->lower_margin;
+	fbinfo->var.hsync_len = mach_info->hsync_len;
+	fbinfo->var.vsync_len = mach_info->vsync_len;
+
+	memset(fbinfo->screen_base, 0,
+			mach_info->xres.max *
+			mach_info->yres.max *
+			mach_info->bpp.max / 8);
+
+	glamo_engine_enable(mach_info->glamo, GLAMO_ENGINE_LCD);
+	glamo_engine_reset(mach_info->glamo, GLAMO_ENGINE_LCD);
+
+	dev_info(&pdev->dev, "spin_lock_init\n");
+	spin_lock_init(&glamofb->lock_cmd);
+	glamofb_init_regs(glamofb);
+#ifdef CONFIG_MFD_GLAMO_HWACCEL
+	glamofb_cursor_onoff(glamofb, 1);
+#endif
+
+#ifdef CONFIG_MFD_GLAMO_FB_XGLAMO_WORKAROUND
+	/* sysfs */
+	rc = sysfs_create_group(&pdev->dev.kobj, &glamo_fb_attr_group);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "cannot create sysfs group\n");
+		goto out_unmap_fb;
+	}
+#endif
+
+	rc = register_framebuffer(fbinfo);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to register framebuffer\n");
+		goto out_unmap_fb;
+	}
+
+	if (mach_info->spi_info) {
+		/* register the sibling spi device */
+		mach_info->spi_info->glamofb_handle = glamofb;
+		glamo_spi_dev.dev.parent = &pdev->dev;
+		glamo_spi_dev.dev.platform_data = mach_info->spi_info;
+		platform_device_register(&glamo_spi_dev);
+	}
+
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+		fbinfo->node, fbinfo->fix.id);
+
+	return 0;
+
+out_unmap_fb:
+	iounmap(fbinfo->screen_base);
+	iounmap(glamofb->base);
+out_release_fb:
+	release_mem_region(glamofb->fb_res->start, RESSIZE(glamofb->fb_res));
+out_release_reg:
+	release_mem_region(glamofb->reg->start, RESSIZE(glamofb->reg));
+out_free:
+	framebuffer_release(fbinfo);
+	return rc;
+}
+
+static int glamofb_remove(struct platform_device *pdev)
+{
+	struct glamofb_handle *glamofb = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	iounmap(glamofb->base);
+	release_mem_region(glamofb->reg->start, RESSIZE(glamofb->reg));
+	kfree(glamofb);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int glamofb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct glamofb_handle *gfb = platform_get_drvdata(pdev);
+
+	/* we need to stop anything touching our framebuffer */
+	fb_set_suspend(gfb->fb, 1);
+
+	/* seriously -- nobody is allowed to touch glamo memory when we
+	 * are suspended or we lock on nWAIT
+	 */
+	/* iounmap(gfb->fb->screen_base); */
+
+	return 0;
+}
+
+static int glamofb_resume(struct platform_device *pdev)
+{
+	struct glamofb_handle *gfb = platform_get_drvdata(pdev);
+	struct glamofb_platform_data *mach_info = pdev->dev.platform_data;
+
+	/* OK let's allow framebuffer ops again */
+	/* gfb->fb->screen_base = ioremap(gfb->fb_res->start,
+				       RESSIZE(gfb->fb_res)); */
+	glamo_engine_enable(mach_info->glamo, GLAMO_ENGINE_LCD);
+	glamo_engine_reset(mach_info->glamo, GLAMO_ENGINE_LCD);
+
+	printk(KERN_ERR"spin_lock_init\n");
+	spin_lock_init(&gfb->lock_cmd);
+	glamofb_init_regs(gfb);
+#ifdef CONFIG_MFD_GLAMO_HWACCEL
+	glamofb_cursor_onoff(gfb, 1);
+#endif
+
+	fb_set_suspend(gfb->fb, 0);
+
+	return 0;
+}
+#else
+#define glamofb_suspend NULL
+#define glamofb_resume  NULL
+#endif
+
+static struct platform_driver glamofb_driver = {
+	.probe		= glamofb_probe,
+	.remove		= glamofb_remove,
+	.suspend	= glamofb_suspend,
+	.resume	= glamofb_resume,
+	.driver		= {
+		.name	= "glamo-fb",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __devinit glamofb_init(void)
+{
+	return platform_driver_register(&glamofb_driver);
+}
+
+static void __exit glamofb_cleanup(void)
+{
+	platform_driver_unregister(&glamofb_driver);
+}
+
+module_init(glamofb_init);
+module_exit(glamofb_cleanup);
+
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_DESCRIPTION("Smedia Glamo 336x/337x framebuffer driver");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-gpio.c linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-gpio.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-gpio.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,62 @@
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+
+#include <linux/glamo-gpio.h>
+
+#include "glamo-core.h"
+#include "glamo-regs.h"
+
+void glamo_gpio_setpin(struct glamo_core *glamo, unsigned int pin,
+		       unsigned int value)
+{
+	unsigned int reg = REG_OF_GPIO(pin);
+	u_int16_t tmp;
+
+	spin_lock(&glamo->lock);
+	tmp = readw(glamo->base + reg);
+	if (value)
+		tmp |= OUTPUT_BIT(pin);
+	else
+		tmp &= ~OUTPUT_BIT(pin);
+	writew(tmp, glamo->base + reg);
+	spin_unlock(&glamo->lock);
+}
+EXPORT_SYMBOL(glamo_gpio_setpin);
+
+int glamo_gpio_getpin(struct glamo_core *glamo, unsigned int pin)
+{
+	return readw(REG_OF_GPIO(pin)) & INPUT_BIT(pin) ? 1 : 0;
+}
+EXPORT_SYMBOL(glamo_gpio_getpin);
+
+void glamo_gpio_cfgpin(struct glamo_core *glamo, unsigned int pinfunc)
+{
+	unsigned int reg = REG_OF_GPIO(pinfunc);
+	u_int16_t tmp;
+
+	spin_lock(&glamo->lock);
+	tmp = readw(glamo->base + reg);
+
+	if ((pinfunc & 0x00f0) == GLAMO_GPIO_F_FUNC) {
+		/* pin is a function pin: clear gpio bit */
+		tmp &= ~FUNC_BIT(pinfunc);
+	} else {
+		/* pin is gpio: set gpio bit */
+		tmp |= FUNC_BIT(pinfunc);
+
+		if (pinfunc & GLAMO_GPIO_F_IN) {
+			/* gpio input: set bit to disable output mode */
+			tmp |= GPIO_OUT_BIT(pinfunc);
+		} else if (pinfunc & GLAMO_GPIO_F_OUT) {
+			/* gpio output: clear bit to enable output mode */
+			tmp &= ~GPIO_OUT_BIT(pinfunc);
+		}
+	}
+	writew(tmp, glamo->base + reg);
+	spin_unlock(&glamo->lock);
+}
+EXPORT_SYMBOL(glamo_gpio_cfgpin);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-lcm-spi.c linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-lcm-spi.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-lcm-spi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-lcm-spi.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2007 Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * Smedia Glamo GPIO based SPI driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This driver currently only implements a minimum subset of the hardware
+ * features, esp. those features that are required to drive the jbt6k74
+ * LCM controller asic in the TD028TTEC1 LCM.
+ *
+*/
+
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/spi/glamo.h>
+
+#include <linux/glamofb.h>
+
+#include <mach/hardware.h>
+
+#include "glamo-core.h"
+#include "glamo-regs.h"
+
+struct glamo_spi {
+	struct spi_bitbang	bitbang;
+	struct spi_master	*master;
+	struct glamo_spi_info	*info;
+	struct device		*dev;
+};
+
+static inline struct glamo_spi *to_gs(struct spi_device *spi)
+{
+	return spi->controller_data;
+}
+
+static int glamo_spi_setupxfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	unsigned int bpw;
+
+	bpw = t ? t->bits_per_word : spi->bits_per_word;
+
+	if (bpw != 9 && bpw != 8) {
+		dev_err(&spi->dev, "invalid bits-per-word (%d)\n", bpw);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void glamo_spi_chipsel(struct spi_device *spi, int value)
+{
+#if 0
+	struct glamo_spi *gs = to_gs(spi);
+
+	dev_dbg(&spi->dev, "chipsel %d: spi=%p, gs=%p, info=%p, handle=%p\n",
+		value, spi, gs, gs->info, gs->info->glamofb_handle);
+
+	glamofb_cmd_mode(gs->info->glamofb_handle, value);
+#endif
+}
+
+static int glamo_spi_txrx(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct glamo_spi *gs = to_gs(spi);
+	const u_int16_t *ui16 = (const u_int16_t *) t->tx_buf;
+	u_int16_t nine_bits;
+	int i;
+
+	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, bpw %d, len %d\n",
+		t->tx_buf, t->rx_buf, t->bits_per_word, t->len);
+
+	if (spi->bits_per_word == 9)
+		nine_bits = (1 << 9);
+	else
+		nine_bits = 0;
+
+	if (t->len > 3 * sizeof(u_int16_t)) {
+		dev_err(&spi->dev, "this driver doesn't support "
+			"%u sized xfers\n", t->len);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < t->len/sizeof(u_int16_t); i++) {
+		/* actually transfer the data */
+#if 1
+		glamofb_cmd_write(gs->info->glamofb_handle,
+				  GLAMO_LCD_CMD_TYPE_SERIAL | nine_bits |
+				  (1 << 10) | (1 << 11) | (ui16[i] & 0x1ff));
+#endif
+		/* FIXME: fire ?!? */
+		if (i == 0 && (ui16[i] & 0x1ff) == 0x29) {
+			dev_dbg(&spi->dev, "leaving command mode\n");
+			glamofb_cmd_mode(gs->info->glamofb_handle, 0);
+		}
+	}
+
+	return t->len;
+}
+
+static int glamo_spi_setup(struct spi_device *spi)
+{
+	int ret;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 9;
+
+	/* FIXME: hardware can do this */
+	if (spi->mode & SPI_LSB_FIRST)
+		return -EINVAL;
+
+	ret = glamo_spi_setupxfer(spi, NULL);
+	if (ret < 0) {
+		dev_err(&spi->dev, "setupxfer returned %d\n", ret);
+		return ret;
+	}
+
+	dev_dbg(&spi->dev, "%s: mode %d, %u bpw\n",
+		__FUNCTION__, spi->mode, spi->bits_per_word);
+
+	return 0;
+}
+
+static int glamo_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct glamo_spi *sp;
+	int ret;
+	int i;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct glamo_spi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	sp = spi_master_get_devdata(master);
+	memset(sp, 0, sizeof(struct glamo_spi));
+
+	sp->master = spi_master_get(master);
+	sp->info = pdev->dev.platform_data;
+	if (!sp->info) {
+		dev_err(&pdev->dev, "can't operate without platform data\n");
+		ret = -EIO;
+		goto err_no_pdev;
+	}
+	dev_dbg(&pdev->dev, "sp->info(pdata) = %p\n", sp->info);
+
+	sp->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, sp);
+
+	sp->bitbang.master = sp->master;
+	sp->bitbang.setup_transfer = glamo_spi_setupxfer;
+	sp->bitbang.chipselect = glamo_spi_chipsel;
+	sp->bitbang.txrx_bufs = glamo_spi_txrx;
+	sp->bitbang.master->setup = glamo_spi_setup;
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (ret)
+		goto err_no_bitbang;
+
+	/* register the chips to go with the board */
+
+	glamofb_cmd_mode(sp->info->glamofb_handle, 1);
+
+	for (i = 0; i < sp->info->board_size; i++) {
+		dev_info(&pdev->dev, "registering %p: %s\n",
+			 &sp->info->board_info[i],
+			 sp->info->board_info[i].modalias);
+
+		sp->info->board_info[i].controller_data = sp;
+		spi_new_device(master, sp->info->board_info + i);
+	}
+
+	return 0;
+
+err_no_bitbang:
+	platform_set_drvdata(pdev, NULL);
+err_no_pdev:
+	spi_master_put(sp->bitbang.master);
+err:
+	return ret;
+
+}
+
+static int glamo_spi_remove(struct platform_device *pdev)
+{
+	struct glamo_spi *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+#define glamo_spi_suspend NULL
+#define glamo_spi_resume NULL
+
+static struct platform_driver glamo_spi_drv = {
+	.probe		= glamo_spi_probe,
+	.remove		= glamo_spi_remove,
+	.suspend	= glamo_spi_suspend,
+	.resume		= glamo_spi_resume,
+	.driver		= {
+		.name	= "glamo-lcm-spi",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init glamo_spi_init(void)
+{
+	return platform_driver_register(&glamo_spi_drv);
+}
+
+static void __exit glamo_spi_exit(void)
+{
+	platform_driver_unregister(&glamo_spi_drv);
+}
+
+module_init(glamo_spi_init);
+module_exit(glamo_spi_exit);
+
+MODULE_DESCRIPTION("Smedia Glamo 336x/337x LCM serial command SPI Driver");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>")
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-mci.c linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-mci.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-mci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-mci.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,1168 @@
+/*
+ *  linux/drivers/mmc/host/glamo-mmc.c - Glamo MMC driver
+ *
+ *  Copyright (C) 2007 Openmoko, Inc,  Andy Green <andy@openmoko.com>
+ *  Based on S3C MMC driver that was:
+ *  Copyright (C) 2004-2006 maintech GmbH, Thomas Kleffel <tk@maintech.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/pcf50633.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+
+#include <asm/dma.h>
+#include <asm/dma-mapping.h>
+#include <asm/io.h>
+
+#include "glamo-mci.h"
+#include "glamo-core.h"
+#include "glamo-regs.h"
+
+/* from glamo-core.c */
+extern struct glamo_mci_pdata glamo_mci_def_pdata;
+
+static spinlock_t clock_lock;
+
+#define DRIVER_NAME "glamo-mci"
+#define RESSIZE(ressource) (((ressource)->end - (ressource)->start) + 1)
+
+static void glamo_mci_send_request(struct mmc_host *mmc);
+
+/*
+ * Max SD clock rate
+ *
+ * held at /(3 + 1) due to concerns of 100R recommended series resistor
+ * allows 16MHz @ 4-bit --> 8MBytes/sec raw
+ *
+ * you can override this on kernel commandline using
+ *
+ *   glamo_mci.sd_max_clk=10000000
+ *
+ * for example
+ */
+
+static int sd_max_clk = 50000000 / 3;
+module_param(sd_max_clk, int, 0644);
+
+/*
+ * Slow SD clock rate
+ *
+ * you can override this on kernel commandline using
+ *
+ *   glamo_mci.sd_slow_ratio=8
+ *
+ * for example
+ *
+ * platform callback is used to decide effective clock rate, if not
+ * defined then max is used, if defined and returns nonzero, rate is
+ * divided by this factor
+ */
+
+static int sd_slow_ratio = 8;
+module_param(sd_slow_ratio, int, 0644);
+
+/*
+ * Post-power SD clock rate
+ *
+ * you can override this on kernel commandline using
+ *
+ *   glamo_mci.sd_post_power_clock=1000000
+ *
+ * for example
+ *
+ * After changing power to card, clock is held at this rate until first bulk
+ * transfer completes
+ */
+
+static int sd_post_power_clock = 1000000;
+module_param(sd_post_power_clock, int, 0644);
+
+
+/*
+ * SD Signal drive strength
+ *
+ * you can override this on kernel commandline using
+ *
+ *   glamo_mci.sd_drive=0
+ *
+ * for example
+ */
+
+static int sd_drive;
+module_param(sd_drive, int, 0644);
+
+/*
+ * SD allow SD clock to run while idle
+ *
+ * you can override this on kernel commandline using
+ *
+ *   glamo_mci.sd_idleclk=0
+ *
+ * for example
+ */
+
+static int sd_idleclk = 0; /* disallow idle clock by default */
+module_param(sd_idleclk, int, 0644);
+
+/* used to stash real idleclk state in suspend: we force it to run in there */
+static int suspend_sd_idleclk;
+
+
+unsigned char CRC7(u8 * pu8, int cnt)
+{
+	u8 crc = 0;
+
+	while (cnt--) {
+		int n;
+		u8 d = *pu8++;
+		for (n = 0; n < 8; n++) {
+			crc <<= 1;
+			if ((d & 0x80) ^ (crc & 0x80))
+				crc ^= 0x09;
+			d <<= 1;
+		}
+	}
+	return (crc << 1) | 1;
+}
+
+static int get_data_buffer(struct glamo_mci_host *host,
+			   volatile u32 *words, volatile u16 **pointer)
+{
+	struct scatterlist *sg;
+
+	*words = 0;
+	*pointer = NULL;
+
+	if (host->pio_active == XFER_NONE)
+		return -EINVAL;
+
+	if ((!host->mrq) || (!host->mrq->data))
+		return -EINVAL;
+
+	if (host->pio_sgptr >= host->mrq->data->sg_len) {
+		dev_dbg(&host->pdev->dev, "no more buffers (%i/%i)\n",
+		      host->pio_sgptr, host->mrq->data->sg_len);
+		return -EBUSY;
+	}
+	sg = &host->mrq->data->sg[host->pio_sgptr];
+
+	*words = sg->length >> 1; /* we are working with a 16-bit data bus */
+	*pointer = page_address(sg_page(sg)) + sg->offset;
+
+	BUG_ON(((long)(*pointer)) & 1);
+
+	host->pio_sgptr++;
+
+	/* dev_info(&host->pdev->dev, "new buffer (%i/%i)\n",
+	      host->pio_sgptr, host->mrq->data->sg_len); */
+	return 0;
+}
+
+static void do_pio_read(struct glamo_mci_host *host)
+{
+	int res;
+	u16 __iomem *from_ptr = host->base_data + (RESSIZE(host->mem_data) /
+							      sizeof(u16) / 2);
+#ifdef DEBUG
+	u16 * block;
+#endif
+
+	while (1) {
+		res = get_data_buffer(host, &host->pio_words, &host->pio_ptr);
+		if (res) {
+			host->pio_active = XFER_NONE;
+			host->complete_what = COMPLETION_FINALIZE;
+
+			dev_dbg(&host->pdev->dev, "pio_read(): "
+				"complete (no more data).\n");
+			return;
+		}
+
+		dev_dbg(&host->pdev->dev, "pio_read(): host->pio_words: %d\n",
+				host->pio_words);
+
+		host->pio_count += host->pio_words << 1;
+
+#ifdef DEBUG
+		block = (u16 *)host->pio_ptr;
+		res = host->pio_words << 1;
+#endif
+#if 0
+		/* u16-centric memcpy */
+		while (host->pio_words--)
+			*host->pio_ptr++ = *from_ptr++;
+#else
+		/* memcpy can be faster? */
+		memcpy((void *)host->pio_ptr, from_ptr, host->pio_words << 1);
+		host->pio_ptr += host->pio_words;
+#endif
+
+#ifdef DEBUG
+		print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_OFFSET, 16, 1,
+			       (void *)block, res, 1);
+#endif
+	}
+}
+
+static int do_pio_write(struct glamo_mci_host *host)
+{
+	int res = 0;
+	volatile u16 __iomem *to_ptr = host->base_data;
+	int err = 0;
+
+	dev_dbg(&host->pdev->dev, "pio_write():\n");
+	while (!res) {
+		res = get_data_buffer(host, &host->pio_words, &host->pio_ptr);
+		if (res)
+			continue;
+
+		dev_dbg(&host->pdev->dev, "pio_write():new source: [%i]@[%p]\n",
+			host->pio_words, host->pio_ptr);
+
+		host->pio_count += host->pio_words << 1;
+		while (host->pio_words--)
+			writew(*host->pio_ptr++, to_ptr++);
+	}
+
+	dev_dbg(&host->pdev->dev, "pio_write(): complete\n");
+	host->pio_active = XFER_NONE;
+	return err;
+}
+
+static void __glamo_mci_fix_card_div(struct glamo_mci_host *host, int div)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&clock_lock, flags);
+
+	if (div < 0) {
+		/* stop clock - remove clock from divider input */
+		writew(readw(glamo_mci_def_pdata.pglamo->base +
+		     GLAMO_REG_CLOCK_GEN5_1) & (~GLAMO_CLOCK_GEN51_EN_DIV_TCLK),
+		     glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_GEN5_1);
+
+		goto done;
+	} else {
+		/* set the nearest prescaler factor
+		*
+		* register shared with SCLK divisor -- no chance of race because
+		* we don't use sensor interface
+		*/
+		writew((readw(glamo_mci_def_pdata.pglamo->base +
+				GLAMO_REG_CLOCK_GEN8) & 0xff00) | div,
+		       glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_GEN8);
+		/* enable clock to divider input */
+		writew(readw(glamo_mci_def_pdata.pglamo->base +
+			GLAMO_REG_CLOCK_GEN5_1) | GLAMO_CLOCK_GEN51_EN_DIV_TCLK,
+		     glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_GEN5_1);
+	}
+
+	if (host->force_slow_during_powerup)
+		div = host->clk_rate / sd_post_power_clock;
+	else
+		if (host->pdata->glamo_mci_use_slow)
+			if ((host->pdata->glamo_mci_use_slow)())
+				div = div * sd_slow_ratio;
+
+	if (div > 255)
+		div = 255;
+
+	/*
+	 * set the nearest prescaler factor
+	 *
+	 * register shared with SCLK divisor -- no chance of race because
+	 * we don't use sensor interface
+	 */
+	writew((readw(glamo_mci_def_pdata.pglamo->base +
+			GLAMO_REG_CLOCK_GEN8) & 0xff00) | div,
+		glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_GEN8);
+	/* enable clock to divider input */
+	writew(readw(glamo_mci_def_pdata.pglamo->base +
+		GLAMO_REG_CLOCK_GEN5_1) | GLAMO_CLOCK_GEN51_EN_DIV_TCLK,
+		glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_GEN5_1);
+
+done:
+	spin_unlock_irqrestore(&clock_lock, flags);
+}
+
+static int __glamo_mci_set_card_clock(struct glamo_mci_host *host, int freq,
+								  int *division)
+{
+	int div = 0;
+	int real_rate = 0;
+
+	if (freq) {
+		/* Set clock */
+		for (div = 0; div < 256; div++) {
+			real_rate = host->clk_rate / (div + 1);
+			if (real_rate <= freq)
+				break;
+		}
+		if (div > 255)
+			div = 255;
+
+		if (division)
+			*division = div;
+
+		__glamo_mci_fix_card_div(host, div);
+
+	} else {
+		/* stop clock */
+		if (division)
+			*division = 0xff;
+
+		if (!sd_idleclk && !host->force_slow_during_powerup)
+			/* clock off */
+			__glamo_mci_fix_card_div(host, -1);
+	}
+
+	return real_rate;
+}
+
+
+static void glamo_mci_irq_worker(struct work_struct *work)
+{
+	struct glamo_mci_host *host =
+			    container_of(work, struct glamo_mci_host, irq_work);
+	struct mmc_command *cmd = host->mrq->cmd;
+
+	if (host->pio_active == XFER_READ)
+		do_pio_read(host);
+
+	host->mrq->data->bytes_xfered = host->pio_count;
+	dev_dbg(&host->pdev->dev, "count=%d\n", host->pio_count);
+
+	/* issue STOP if we have been given one to use */
+	if (host->mrq->stop) {
+		host->cmd_is_stop = 1;
+		glamo_mci_send_request(host->mmc);
+		host->cmd_is_stop = 0;
+	}
+
+	if (!sd_idleclk && !host->force_slow_during_powerup)
+		/* clock off */
+		__glamo_mci_fix_card_div(host, -1);
+
+	host->complete_what = COMPLETION_NONE;
+	host->mrq = NULL;
+	mmc_request_done(host->mmc, cmd->mrq);
+}
+
+static void glamo_mci_irq_host(struct glamo_mci_host *host)
+{
+	u16 status;
+	struct mmc_command *cmd;
+	unsigned long iflags;
+
+	if (host->suspending) { /* bad news, dangerous time */
+		dev_err(&host->pdev->dev, "****glamo_mci_irq before resumed\n");
+		return;
+	}
+
+	if (!host->mrq)
+		return;
+	cmd = host->mrq->cmd;
+	if (!cmd)
+		return;
+
+	spin_lock_irqsave(&host->complete_lock, iflags);
+
+	status = readw(host->base + GLAMO_REG_MMC_RB_STAT1);
+	dev_dbg(&host->pdev->dev, "status = 0x%04x\n", status);
+
+	/* ack this interrupt source */
+	writew(GLAMO_IRQ_MMC,
+	       glamo_mci_def_pdata.pglamo->base + GLAMO_REG_IRQ_CLEAR);
+
+	/* we ignore a data timeout report if we are also told the data came */
+	if (status & GLAMO_STAT1_MMC_RB_DRDY)
+		status &= ~GLAMO_STAT1_MMC_DTOUT;
+
+	if (status & (GLAMO_STAT1_MMC_RTOUT |
+		      GLAMO_STAT1_MMC_DTOUT))
+		cmd->error = -ETIMEDOUT;
+	if (status & (GLAMO_STAT1_MMC_BWERR |
+		      GLAMO_STAT1_MMC_BRERR))
+		cmd->error = -EILSEQ;
+	if (cmd->error) {
+		dev_info(&host->pdev->dev, "Error after cmd: 0x%x\n", status);
+		goto done;
+	}
+
+	/*
+	 * disable the initial slow start after first bulk transfer
+	 */
+	if (host->force_slow_during_powerup)
+		host->force_slow_during_powerup--;
+
+	/*
+	 * we perform the memcpy out of Glamo memory outside of IRQ context
+	 * so we don't block other interrupts
+	 */
+	schedule_work(&host->irq_work);
+
+	goto leave;
+
+done:
+	host->complete_what = COMPLETION_NONE;
+	host->mrq = NULL;
+	mmc_request_done(host->mmc, cmd->mrq);
+leave:
+	spin_unlock_irqrestore(&host->complete_lock, iflags);
+}
+
+static void glamo_mci_irq(unsigned int irq, struct irq_desc *desc)
+{
+	struct glamo_mci_host *host = (struct glamo_mci_host *)
+				      desc->handler_data;
+
+	if (host)
+		glamo_mci_irq_host(host);
+
+}
+
+static int glamo_mci_send_command(struct glamo_mci_host *host,
+				  struct mmc_command *cmd)
+{
+	u8 u8a[6];
+	u16 fire = 0;
+
+	/* if we can't do it, reject as busy */
+	if (!readw(host->base + GLAMO_REG_MMC_RB_STAT1) &
+	     GLAMO_STAT1_MMC_IDLE) {
+		host->mrq = NULL;
+		cmd->error = -EBUSY;
+		mmc_request_done(host->mmc, host->mrq);
+		return -EBUSY;
+	}
+
+	/* create an array in wire order for CRC computation */
+	u8a[0] = 0x40 | (cmd->opcode & 0x3f);
+	u8a[1] = (u8)(cmd->arg >> 24);
+	u8a[2] = (u8)(cmd->arg >> 16);
+	u8a[3] = (u8)(cmd->arg >> 8);
+	u8a[4] = (u8)cmd->arg;
+	u8a[5] = CRC7(&u8a[0], 5); /* CRC7 on first 5 bytes of packet */
+
+	/* issue the wire-order array including CRC in register order */
+	writew((u8a[4] << 8) | u8a[5], host->base + GLAMO_REG_MMC_CMD_REG1);
+	writew((u8a[2] << 8) | u8a[3], host->base + GLAMO_REG_MMC_CMD_REG2);
+	writew((u8a[0] << 8) | u8a[1], host->base + GLAMO_REG_MMC_CMD_REG3);
+
+	/* command index toggle */
+	fire |= (host->ccnt & 1) << 12;
+
+	/* set type of command */
+	switch (mmc_cmd_type(cmd)) {
+	case MMC_CMD_BC:
+		fire |= GLAMO_FIRE_MMC_CMDT_BNR;
+		break;
+	case MMC_CMD_BCR:
+		fire |= GLAMO_FIRE_MMC_CMDT_BR;
+		break;
+	case MMC_CMD_AC:
+		fire |= GLAMO_FIRE_MMC_CMDT_AND;
+		break;
+	case MMC_CMD_ADTC:
+		fire |= GLAMO_FIRE_MMC_CMDT_AD;
+		break;
+	}
+	/*
+	 * if it expects a response, set the type expected
+	 *
+	 * R1, Length  : 48bit, Normal response
+	 * R1b, Length : 48bit, same R1, but added card busy status
+	 * R2, Length  : 136bit (really 128 bits with CRC snipped)
+	 * R3, Length  : 48bit (OCR register value)
+	 * R4, Length  : 48bit, SDIO_OP_CONDITION, Reverse SDIO Card
+	 * R5, Length  : 48bit, IO_RW_DIRECTION, Reverse SDIO Card
+	 * R6, Length  : 48bit (RCA register)
+	 * R7, Length  : 48bit (interface condition, VHS(voltage supplied),
+	 *                     check pattern, CRC7)
+	 */
+	switch (mmc_resp_type(cmd)) {
+	case MMC_RSP_R6: /* same index as R7 and R1 */
+		fire |= GLAMO_FIRE_MMC_RSPT_R1;
+		break;
+	case MMC_RSP_R1B:
+		fire |= GLAMO_FIRE_MMC_RSPT_R1b;
+		break;
+	case MMC_RSP_R2:
+		fire |= GLAMO_FIRE_MMC_RSPT_R2;
+		break;
+	case MMC_RSP_R3:
+		fire |= GLAMO_FIRE_MMC_RSPT_R3;
+		break;
+	/* R4 and R5 supported by chip not defined in linux/mmc/core.h (sdio) */
+	}
+	/*
+	 * From the command index, set up the command class in the host ctrllr
+	 *
+	 * missing guys present on chip but couldn't figure out how to use yet:
+	 *     0x0 "stream read"
+	 *     0x9 "cancel running command"
+	 */
+	switch (cmd->opcode) {
+	case MMC_READ_SINGLE_BLOCK:
+		fire |= GLAMO_FIRE_MMC_CC_SBR; /* single block read */
+		break;
+	case MMC_SWITCH: /* 64 byte payload */
+	case 0x33: /* observed issued by MCI */
+	case MMC_READ_MULTIPLE_BLOCK:
+		/* we will get an interrupt off this */
+		if (!cmd->mrq->stop)
+			/* multiblock no stop */
+			fire |= GLAMO_FIRE_MMC_CC_MBRNS;
+		else
+			 /* multiblock with stop */
+			fire |= GLAMO_FIRE_MMC_CC_MBRS;
+		break;
+	case MMC_WRITE_BLOCK:
+		fire |= GLAMO_FIRE_MMC_CC_SBW; /* single block write */
+		break;
+	case MMC_WRITE_MULTIPLE_BLOCK:
+		if (cmd->mrq->stop)
+			 /* multiblock with stop */
+			fire |= GLAMO_FIRE_MMC_CC_MBWS;
+		else
+// 			 /* multiblock NO stop-- 'RESERVED'? */
+			fire |= GLAMO_FIRE_MMC_CC_MBWNS;
+		break;
+	case MMC_STOP_TRANSMISSION:
+		fire |= GLAMO_FIRE_MMC_CC_STOP; /* STOP */
+		break;
+	default:
+		fire |= GLAMO_FIRE_MMC_CC_BASIC; /* "basic command" */
+		break;
+	}
+
+	/* always largest timeout */
+	writew(0xfff, host->base + GLAMO_REG_MMC_TIMEOUT);
+
+	/* Generate interrupt on txfer */
+	writew((readw(host->base + GLAMO_REG_MMC_BASIC) & 0x3e) |
+		   0x0800 | GLAMO_BASIC_MMC_NO_CLK_RD_WAIT |
+		   GLAMO_BASIC_MMC_EN_COMPL_INT | (sd_drive << 6),
+		   host->base + GLAMO_REG_MMC_BASIC);
+
+	/* send the command out on the wire */
+	/* dev_info(&host->pdev->dev, "Using FIRE %04X\n", fire); */
+	writew(fire, host->base + GLAMO_REG_MMC_CMD_FIRE);
+	cmd->error = 0;
+	return 0;
+}
+
+static int glamo_mci_prepare_pio(struct glamo_mci_host *host,
+				 struct mmc_data *data)
+{
+	/*
+	 * the S-Media-internal RAM offset for our MMC buffer
+	 * Read is halfway up the buffer and write is at the start
+	 */
+	if (data->flags & MMC_DATA_READ) {
+		writew((u16)(GLAMO_FB_SIZE + (RESSIZE(host->mem_data) / 2)),
+			   host->base + GLAMO_REG_MMC_WDATADS1);
+		writew((u16)((GLAMO_FB_SIZE +
+					(RESSIZE(host->mem_data) / 2)) >> 16),
+			   host->base + GLAMO_REG_MMC_WDATADS2);
+	} else {
+		writew((u16)GLAMO_FB_SIZE, host->base +
+					       GLAMO_REG_MMC_RDATADS1);
+		writew((u16)(GLAMO_FB_SIZE >> 16), host->base +
+						       GLAMO_REG_MMC_RDATADS2);
+	}
+
+	/* set up the block info */
+	writew(data->blksz, host->base + GLAMO_REG_MMC_DATBLKLEN);
+	writew(data->blocks, host->base + GLAMO_REG_MMC_DATBLKCNT);
+	dev_dbg(&host->pdev->dev, "(blksz=%d, count=%d)\n",
+				   data->blksz, data->blocks);
+	host->pio_sgptr = 0;
+	host->pio_words = 0;
+	host->pio_count = 0;
+	host->pio_active = 0;
+	/* if write, prep the write into the shared RAM before the command */
+	if (data->flags & MMC_DATA_WRITE) {
+		host->pio_active = XFER_WRITE;
+		return do_pio_write(host);
+	}
+	host->pio_active = XFER_READ;
+	return 0;
+}
+
+static void glamo_mci_send_request(struct mmc_host *mmc)
+{
+	struct glamo_mci_host *host = mmc_priv(mmc);
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_command *cmd = host->cmd_is_stop ? mrq->stop : mrq->cmd;
+	u16 * pu16 = (u16 *)&cmd->resp[0];
+	u16 * reg_resp = (u16 *)(host->base + GLAMO_REG_MMC_CMD_RSP1);
+	u16 status;
+	int n;
+	int timeout = 1000000;
+	int insanity_timeout = 1000000;
+
+	if (host->suspending) {
+		dev_err(&host->pdev->dev, "IGNORING glamo_mci_send_request while "
+								 "suspended\n");
+		cmd->error = -EIO;
+		if (cmd->data)
+			cmd->data->error = -EIO;
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	host->ccnt++;
+	/*
+	 * somehow 2.6.24 MCI manages to issue MMC_WRITE_BLOCK *without* the
+	 * MMC_DATA_WRITE flag, WTF?  Work around the madness.
+	 */
+	if (cmd->opcode == MMC_WRITE_BLOCK)
+		if (mrq->data)
+			mrq->data->flags |= MMC_DATA_WRITE;
+
+	 /* this guy has data to read/write? */
+	if ((!host->cmd_is_stop) && cmd->data) {
+		int res;
+		host->dcnt++;
+		res = glamo_mci_prepare_pio(host, cmd->data);
+		if (res) {
+			cmd->error = -EIO;
+			cmd->data->error = -EIO;
+			mmc_request_done(mmc, mrq);
+			return;
+		}
+	}
+
+	dev_dbg(&host->pdev->dev,"cmd 0x%x, "
+		 "arg 0x%x data=%p mrq->stop=%p flags 0x%x\n",
+		 cmd->opcode, cmd->arg, cmd->data, cmd->mrq->stop,
+		 cmd->flags);
+
+	/* resume requested clock rate
+	 * scale it down by sd_slow_ratio if platform requests it
+	 */
+	__glamo_mci_fix_card_div(host, host->clk_div);
+
+	if (glamo_mci_send_command(host, cmd))
+		goto bail;
+
+	/* we are deselecting card?  because it isn't going to ack then... */
+	if ((cmd->opcode == 7) && (cmd->arg == 0))
+		goto done;
+
+	/*
+	 * we must spin until response is ready or timed out
+	 * -- we don't get interrupts unless there is a bulk rx
+	 */
+	do
+		status = readw(host->base + GLAMO_REG_MMC_RB_STAT1);
+	while (((((status >> 15) & 1) != (host->ccnt & 1)) ||
+		(!(status & (GLAMO_STAT1_MMC_RB_RRDY |
+			     GLAMO_STAT1_MMC_RTOUT |
+			     GLAMO_STAT1_MMC_DTOUT |
+			     GLAMO_STAT1_MMC_BWERR |
+			     GLAMO_STAT1_MMC_BRERR)))) && (insanity_timeout--));
+
+	if (insanity_timeout < 0)
+		dev_info(&host->pdev->dev, "command timeout, continuing\n");
+
+	if (status & (GLAMO_STAT1_MMC_RTOUT |
+		      GLAMO_STAT1_MMC_DTOUT))
+		cmd->error = -ETIMEDOUT;
+	if (status & (GLAMO_STAT1_MMC_BWERR |
+		      GLAMO_STAT1_MMC_BRERR))
+		cmd->error = -EILSEQ;
+
+	if (host->cmd_is_stop)
+		goto bail;
+
+	if (cmd->error) {
+		dev_info(&host->pdev->dev, "Error after cmd: 0x%x\n", status);
+		goto done;
+	}
+	/*
+	 * mangle the response registers in two different exciting
+	 * undocumented ways discovered by trial and error
+	 */
+	if (mmc_resp_type(cmd) == MMC_RSP_R2)
+		/* grab the response */
+		for (n = 0; n < 8; n++) /* super mangle power 1 */
+			pu16[n ^ 6] = readw(&reg_resp[n]);
+	else
+		for (n = 0; n < 3; n++) /* super mangle power 2 */
+			pu16[n] = (readw(&reg_resp[n]) >> 8) |
+				  (readw(&reg_resp[n + 1]) << 8);
+	/*
+	 * if we don't have bulk data to take care of, we're done
+	 */
+	if (!cmd->data)
+		goto done;
+	if (!(cmd->data->flags & (MMC_DATA_READ | MMC_DATA_WRITE)))
+		goto done;
+
+	/*
+	 * Otherwise can can use the interrupt as async completion --
+	 * if there is read data coming, or we wait for write data to complete,
+	 * exit without mmc_request_done() as the payload interrupt
+	 * will service it
+	 */
+	dev_dbg(&host->pdev->dev, "Waiting for payload data\n");
+	/*
+	 * if the glamo INT# line isn't wired (*cough* it can happen)
+	 * I'm afraid we have to spin on the IRQ status bit and "be
+	 * our own INT# line"
+	 */
+	if (!glamo_mci_def_pdata.pglamo->irq_works) {
+		/*
+		 * we have faith we will get an "interrupt"...
+		 * but something insane like suspend problems can mean
+		 * we spin here forever, so we timeout after a LONG time
+		 */
+		while ((!(readw(glamo_mci_def_pdata.pglamo->base +
+			 GLAMO_REG_IRQ_STATUS) & GLAMO_IRQ_MMC)) &&
+		       (timeout--))
+			;
+
+		if (timeout < 0) {
+			if (cmd->data->error)
+				cmd->data->error = -ETIMEDOUT;
+			dev_err(&host->pdev->dev, "Payload timeout\n");
+			goto bail;
+		}
+
+		/* yay we are an interrupt controller! -- call the ISR
+		 * it will stop clock to card
+		 */
+		glamo_mci_irq_host(host);
+	}
+	return;
+
+done:
+	host->complete_what = COMPLETION_NONE;
+	host->mrq = NULL;
+	mmc_request_done(host->mmc, cmd->mrq);
+bail:
+	if (!sd_idleclk && !host->force_slow_during_powerup)
+		/* stop the clock to card */
+		__glamo_mci_fix_card_div(host, -1);
+}
+
+static void glamo_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct glamo_mci_host *host = mmc_priv(mmc);
+
+	host->cmd_is_stop = 0;
+	host->mrq = mrq;
+	glamo_mci_send_request(mmc);
+}
+
+#if 1
+static void glamo_mci_reset(struct glamo_mci_host *host)
+{
+	if (host->suspending) {
+		dev_err(&host->pdev->dev, "IGNORING glamo_mci_reset while "
+								 "suspended\n");
+		return;
+	}
+	dev_dbg(&host->pdev->dev, "******* glamo_mci_reset\n");
+	/* reset MMC controller */
+	writew(GLAMO_CLOCK_MMC_RESET | GLAMO_CLOCK_MMC_DG_TCLK |
+		   GLAMO_CLOCK_MMC_EN_TCLK | GLAMO_CLOCK_MMC_DG_M9CLK |
+		   GLAMO_CLOCK_MMC_EN_M9CLK,
+		   glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_MMC);
+	udelay(10);
+	/* and disable reset */
+	writew(GLAMO_CLOCK_MMC_DG_TCLK |
+		   GLAMO_CLOCK_MMC_EN_TCLK | GLAMO_CLOCK_MMC_DG_M9CLK |
+		   GLAMO_CLOCK_MMC_EN_M9CLK,
+		   glamo_mci_def_pdata.pglamo->base + GLAMO_REG_CLOCK_MMC);
+}
+#endif
+static inline int glamo_mci_get_mv(int vdd)
+{
+	int mv = 1650;
+
+	if (vdd > 7)
+		mv += 350 + 100 * (vdd - 8);
+
+	return mv;
+}
+
+static void glamo_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct glamo_mci_host *host = mmc_priv(mmc);
+	struct regulator *regulator;
+	int n = 0;
+	int div;
+	int powering = 0;
+	int mv;
+
+	if (host->suspending) {
+		dev_err(&host->pdev->dev, "IGNORING glamo_mci_set_ios while "
+								 "suspended\n");
+		return;
+	}
+
+	regulator = host->regulator;
+
+	/* Set power */
+	switch(ios->power_mode) {
+	case MMC_POWER_UP:
+		if (host->pdata->glamo_can_set_mci_power()) {
+			mv = glamo_mci_get_mv(ios->vdd);
+			regulator_set_voltage(regulator, mv * 1000, mv * 1000);
+			regulator_enable(regulator);
+		}
+		break;
+	case MMC_POWER_ON:
+		/*
+		 * we should use very slow clock until first bulk
+		 * transfer completes OK
+		 */
+		host->force_slow_during_powerup = 1;
+
+		if (host->vdd_current != ios->vdd) {
+			if (host->pdata->glamo_can_set_mci_power()) {
+				mv = glamo_mci_get_mv(ios->vdd);
+				regulator_set_voltage(regulator, mv * 1000, mv * 1000);
+				printk(KERN_INFO "SD power -> %dmV\n", mv);
+			}
+			host->vdd_current = ios->vdd;
+		}
+		if (host->power_mode_current == MMC_POWER_OFF) {
+			glamo_engine_enable(glamo_mci_def_pdata.pglamo,
+							      GLAMO_ENGINE_MMC);
+			powering = 1;
+		}
+		break;
+
+	case MMC_POWER_OFF:
+	default:
+		if (host->power_mode_current == MMC_POWER_OFF)
+			break;
+		/* never want clocking with dead card */
+		__glamo_mci_fix_card_div(host, -1);
+
+		glamo_engine_disable(glamo_mci_def_pdata.pglamo,
+				     GLAMO_ENGINE_MMC);
+		regulator_disable(regulator);
+		host->vdd_current = -1;
+		break;
+	}
+	host->power_mode_current = ios->power_mode;
+
+	host->real_rate = __glamo_mci_set_card_clock(host, ios->clock, &div);
+	host->clk_div = div;
+
+	/* after power-up, we are meant to give it >= 74 clocks so it can
+	 * initialize itself.  Doubt any modern cards need it but anyway...
+	 */
+	if (powering)
+		mdelay(1);
+
+	if (!sd_idleclk && !host->force_slow_during_powerup)
+		/* stop the clock to card, because we are idle until transfer */
+		__glamo_mci_fix_card_div(host, -1);
+
+	if ((ios->power_mode == MMC_POWER_ON) ||
+	    (ios->power_mode == MMC_POWER_UP)) {
+		dev_info(&host->pdev->dev,
+			"powered (vdd = %d) clk: %lukHz div=%d (req: %ukHz). "
+			"Bus width=%d\n",(int)ios->vdd,
+			host->real_rate / 1000, (int)host->clk_div,
+			ios->clock / 1000, (int)ios->bus_width);
+	} else
+		dev_info(&host->pdev->dev, "glamo_mci_set_ios: power down.\n");
+
+	/* set bus width */
+	host->bus_width = ios->bus_width;
+	if (host->bus_width == MMC_BUS_WIDTH_4)
+		n = GLAMO_BASIC_MMC_EN_4BIT_DATA;
+	writew((readw(host->base + GLAMO_REG_MMC_BASIC) &
+					  (~(GLAMO_BASIC_MMC_EN_4BIT_DATA |
+					     GLAMO_BASIC_MMC_EN_DR_STR0 |
+					     GLAMO_BASIC_MMC_EN_DR_STR1))) | n |
+			       sd_drive << 6, host->base + GLAMO_REG_MMC_BASIC);
+}
+
+
+/*
+ * no physical write protect supported by us
+ */
+static int glamo_mci_get_ro(struct mmc_host *mmc)
+{
+	return 0;
+}
+
+static struct mmc_host_ops glamo_mci_ops = {
+	.request	= glamo_mci_request,
+	.set_ios	= glamo_mci_set_ios,
+	.get_ro		= glamo_mci_get_ro,
+};
+
+static int glamo_mci_probe(struct platform_device *pdev)
+{
+	struct mmc_host 	*mmc;
+	struct glamo_mci_host 	*host;
+	int ret;
+
+	dev_info(&pdev->dev, "glamo_mci driver (C)2007 Openmoko, Inc\n");
+
+	mmc = mmc_alloc_host(sizeof(struct glamo_mci_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto probe_out;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+	host->pdev = pdev;
+	host->pdata = &glamo_mci_def_pdata;
+	host->power_mode_current = MMC_POWER_OFF;
+
+	host->complete_what = COMPLETION_NONE;
+	host->pio_active = XFER_NONE;
+
+	spin_lock_init(&host->complete_lock);
+	INIT_WORK(&host->irq_work, glamo_mci_irq_worker);
+
+	host->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!host->mem) {
+		dev_err(&pdev->dev,
+			"failed to get io memory region resouce.\n");
+
+		ret = -ENOENT;
+		goto probe_free_host;
+	}
+
+	host->mem = request_mem_region(host->mem->start,
+		RESSIZE(host->mem), pdev->name);
+
+	if (!host->mem) {
+		dev_err(&pdev->dev, "failed to request io memory region.\n");
+		ret = -ENOENT;
+		goto probe_free_host;
+	}
+
+	host->base = ioremap(host->mem->start, RESSIZE(host->mem));
+	if (!host->base) {
+		dev_err(&pdev->dev, "failed to ioremap() io memory region.\n");
+		ret = -EINVAL;
+		goto probe_free_mem_region;
+	}
+
+	host->regulator = regulator_get(&pdev->dev, "SD_3V3");
+	if (!host->regulator) {
+		dev_err(&pdev->dev, "Cannot proceed without regulator.\n");
+		return -ENODEV;
+	}
+
+	/* set the handler for our bit of the shared chip irq register */
+	set_irq_handler(IRQ_GLAMO(GLAMO_IRQIDX_MMC), glamo_mci_irq);
+	/* stash host as our handler's private data */
+	set_irq_data(IRQ_GLAMO(GLAMO_IRQIDX_MMC), host);
+
+	/* Get ahold of our data buffer we use for data in and out on MMC */
+	host->mem_data = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!host->mem_data) {
+		dev_err(&pdev->dev,
+			"failed to get io memory region resource.\n");
+		ret = -ENOENT;
+		goto probe_iounmap;
+	}
+
+	host->mem_data = request_mem_region(host->mem_data->start,
+		RESSIZE(host->mem_data), pdev->name);
+
+	if (!host->mem_data) {
+		dev_err(&pdev->dev, "failed to request io memory region.\n");
+		ret = -ENOENT;
+		goto probe_iounmap;
+	}
+	host->base_data = ioremap(host->mem_data->start,
+					  RESSIZE(host->mem_data));
+	host->data_max_size = RESSIZE(host->mem_data);
+
+	if (host->base_data == 0) {
+		dev_err(&pdev->dev, "failed to ioremap() io memory region.\n");
+		ret = -EINVAL;
+		goto probe_free_mem_region_data;
+	}
+
+	host->vdd_current = 0;
+	host->clk_rate = 50000000; /* really it's 49152000 */
+	host->clk_div = 16;
+
+	/* explain our host controller capabilities */
+	mmc->ops 	= &glamo_mci_ops;
+	mmc->ocr_avail	= host->pdata->ocr_avail;
+	mmc->caps	= MMC_CAP_4_BIT_DATA |
+			  MMC_CAP_MMC_HIGHSPEED |
+			  MMC_CAP_SD_HIGHSPEED;
+	mmc->f_min 	= host->clk_rate / 256;
+	mmc->f_max 	= sd_max_clk;
+
+	mmc->max_blk_count	= (1 << 16) - 1; /* GLAMO_REG_MMC_RB_BLKCNT */
+	mmc->max_blk_size	= (1 << 12) - 1; /* GLAMO_REG_MMC_RB_BLKLEN */
+	mmc->max_req_size	= RESSIZE(host->mem_data) / 2;
+	mmc->max_seg_size	= mmc->max_req_size;
+	mmc->max_phys_segs	= 1; /* hw doesn't talk about segs??? */
+	mmc->max_hw_segs	= 1;
+
+	dev_info(&host->pdev->dev, "probe: mapped mci_base:%p irq:%u.\n",
+		host->base, host->irq);
+
+	platform_set_drvdata(pdev, mmc);
+
+	glamo_engine_enable(glamo_mci_def_pdata.pglamo, GLAMO_ENGINE_MMC);
+	glamo_mci_reset(host);
+
+	if ((ret = mmc_add_host(mmc))) {
+		dev_err(&pdev->dev, "failed to add mmc host.\n");
+		goto probe_free_mem_region_data;
+	}
+
+	dev_info(&pdev->dev,"initialisation done.\n");
+	return 0;
+
+ probe_free_mem_region_data:
+	release_mem_region(host->mem_data->start, RESSIZE(host->mem_data));
+
+ probe_iounmap:
+	iounmap(host->base);
+
+ probe_free_mem_region:
+	release_mem_region(host->mem->start, RESSIZE(host->mem));
+
+ probe_free_host:
+	mmc_free_host(mmc);
+ probe_out:
+	return ret;
+}
+
+static int glamo_mci_remove(struct platform_device *pdev)
+{
+	struct mmc_host 	*mmc  = platform_get_drvdata(pdev);
+	struct glamo_mci_host 	*host = mmc_priv(mmc);
+	struct regulator *regulator;
+
+	mmc_remove_host(mmc);
+	/* stop using our handler, revert it to default */
+	set_irq_handler(IRQ_GLAMO(GLAMO_IRQIDX_MMC), handle_level_irq);
+	iounmap(host->base);
+	iounmap(host->base_data);
+	release_mem_region(host->mem->start, RESSIZE(host->mem));
+	release_mem_region(host->mem_data->start, RESSIZE(host->mem_data));
+
+	regulator = host->regulator;
+	regulator_put(regulator);
+	
+	mmc_free_host(mmc);
+
+	glamo_engine_disable(glamo_mci_def_pdata.pglamo, GLAMO_ENGINE_MMC);
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+static int glamo_mci_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct glamo_mci_host 	*host = mmc_priv(mmc);
+	int ret;
+
+	cancel_work_sync(&host->irq_work);
+
+	/*
+	 * possible workaround for SD corruption during suspend - resume
+	 * make sure the clock was running during suspend and consequently
+	 * resume
+	 */
+	__glamo_mci_fix_card_div(host, host->clk_div);
+
+	/* we are going to do more commands to override this in
+	 * mmc_suspend_host(), so we need to change sd_idleclk for the
+	 * duration as well
+	 */
+	suspend_sd_idleclk = sd_idleclk;
+	sd_idleclk = 1;
+
+	ret = mmc_suspend_host(mmc, state);
+
+	host->suspending++;
+	/* so that when we resume, we use any modified max rate */
+	mmc->f_max = sd_max_clk;
+
+	return ret;
+}
+
+int glamo_mci_resume(struct platform_device *dev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(dev);
+	struct glamo_mci_host 	*host = mmc_priv(mmc);
+	int ret;
+
+	sd_idleclk = 1;
+
+	glamo_engine_enable(host->pdata->pglamo, GLAMO_ENGINE_MMC);
+	glamo_mci_reset(host);
+
+	host->suspending--;
+
+	ret = mmc_resume_host(mmc);
+
+	/* put sd_idleclk back to pre-suspend state */
+	sd_idleclk = suspend_sd_idleclk;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(glamo_mci_resume);
+
+#else /* CONFIG_PM */
+#define glamo_mci_suspend NULL
+#define glamo_mci_resume NULL
+#endif /* CONFIG_PM */
+
+
+static struct platform_driver glamo_mci_driver =
+{
+	.driver.name	= "glamo-mci",
+	.probe		= glamo_mci_probe,
+	.remove		= glamo_mci_remove,
+	.suspend	= glamo_mci_suspend,
+	.resume		= glamo_mci_resume,
+};
+
+static int __init glamo_mci_init(void)
+{
+	spin_lock_init(&clock_lock);
+	platform_driver_register(&glamo_mci_driver);
+	return 0;
+}
+
+static void __exit glamo_mci_exit(void)
+{
+	platform_driver_unregister(&glamo_mci_driver);
+}
+
+module_init(glamo_mci_init);
+module_exit(glamo_mci_exit);
+
+MODULE_DESCRIPTION("Glamo MMC/SD Card Interface driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-mci.h linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-mci.h
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-mci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-mci.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,84 @@
+/*
+ *  linux/drivers/mmc/host/glamo-mmc.h - GLAMO MCI driver
+ *
+ *  Copyright (C) 2007-2008 Openmoko, Inc, Andy Green <andy@openmoko.com>
+ *   based on S3C MMC driver -->
+ *  Copyright (C) 2004-2006 Thomas Kleffel, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/regulator/consumer.h>
+
+enum glamo_mci_waitfor {
+	COMPLETION_NONE,
+	COMPLETION_FINALIZE,
+	COMPLETION_CMDSENT,
+	COMPLETION_RSPFIN,
+	COMPLETION_XFERFINISH,
+	COMPLETION_XFERFINISH_RSPFIN,
+};
+
+struct glamo_mci_host {
+	struct platform_device	*pdev;
+	struct glamo_mci_pdata  *pdata;
+	struct mmc_host		*mmc;
+	struct resource		*mem;
+	struct resource		*mem_data;
+	struct clk		*clk;
+	void __iomem		*base;
+	u16 __iomem		*base_data;
+	int			irq;
+	int			irq_cd;
+	int			dma;
+	int 			data_max_size;
+
+	int 			suspending;
+
+	int			power_mode_current;
+	unsigned int		vdd_current;
+
+	unsigned long		clk_rate;
+	unsigned long		clk_div;
+	unsigned long		real_rate;
+	u8			prescaler;
+
+	int			force_slow_during_powerup;
+
+	unsigned		sdiimsk;
+	int			dodma;
+
+	volatile int		dmatogo;
+
+	struct mmc_request	*mrq;
+	int			cmd_is_stop;
+	struct work_struct	irq_work;
+
+	spinlock_t		complete_lock;
+	volatile enum 		glamo_mci_waitfor
+				complete_what;
+
+	volatile int		dma_complete;
+
+	volatile u32		pio_sgptr;
+	volatile u32		pio_words;
+	volatile u32		pio_count;
+	volatile u16		*pio_ptr;
+#define XFER_NONE 0
+#define XFER_READ 1
+#define XFER_WRITE 2
+	volatile u32		pio_active;
+
+	int			bus_width;
+
+	char 			dbgmsg_cmd[301];
+	char 			dbgmsg_dat[301];
+	volatile char		*status;
+
+	unsigned int		ccnt, dcnt;
+	struct tasklet_struct	pio_tasklet;
+
+	struct regulator 	*regulator;
+};
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-regs.h linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-regs.h
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-regs.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,632 @@
+#ifndef _GLAMO_REGS_H
+#define _GLAMO_REGS_H
+
+/* Smedia Glamo 336x/337x driver
+ *
+ * (C) 2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+enum glamo_regster_offsets {
+	GLAMO_REGOFS_GENERIC	= 0x0000,
+	GLAMO_REGOFS_HOSTBUS	= 0x0200,
+	GLAMO_REGOFS_MEMORY	= 0x0300,
+	GLAMO_REGOFS_VIDCAP	= 0x0400,
+	GLAMO_REGOFS_ISP	= 0x0500,
+	GLAMO_REGOFS_JPEG	= 0x0800,
+	GLAMO_REGOFS_MPEG	= 0x0c00,
+	GLAMO_REGOFS_LCD	= 0x1100,
+	GLAMO_REGOFS_MMC	= 0x1400,
+	GLAMO_REGOFS_MPROC0	= 0x1500,
+	GLAMO_REGOFS_MPROC1	= 0x1580,
+	GLAMO_REGOFS_CMDQUEUE	= 0x1600,
+	GLAMO_REGOFS_RISC	= 0x1680,
+	GLAMO_REGOFS_2D		= 0x1700,
+	GLAMO_REGOFS_3D		= 0x1b00,
+	GLAMO_REGOFS_END	= 0x2400,
+};
+
+
+enum glamo_register_generic {
+	GLAMO_REG_GCONF1	= 0x0000,
+	GLAMO_REG_GCONF2	= 0x0002,
+#define	GLAMO_REG_DEVICE_ID	GLAMO_REG_GCONF2
+	GLAMO_REG_GCONF3	= 0x0004,
+#define	GLAMO_REG_REVISION_ID	GLAMO_REG_GCONF3
+	GLAMO_REG_IRQ_GEN1	= 0x0006,
+#define GLAMO_REG_IRQ_ENABLE	GLAMO_REG_IRQ_GEN1
+	GLAMO_REG_IRQ_GEN2	= 0x0008,
+#define GLAMO_REG_IRQ_SET	GLAMO_REG_IRQ_GEN2
+	GLAMO_REG_IRQ_GEN3	= 0x000a,
+#define GLAMO_REG_IRQ_CLEAR	GLAMO_REG_IRQ_GEN3
+	GLAMO_REG_IRQ_GEN4	= 0x000c,
+#define GLAMO_REG_IRQ_STATUS	GLAMO_REG_IRQ_GEN4
+	GLAMO_REG_CLOCK_HOST	= 0x0010,
+	GLAMO_REG_CLOCK_MEMORY	= 0x0012,
+	GLAMO_REG_CLOCK_LCD	= 0x0014,
+	GLAMO_REG_CLOCK_MMC	= 0x0016,
+	GLAMO_REG_CLOCK_ISP	= 0x0018,
+	GLAMO_REG_CLOCK_JPEG	= 0x001a,
+	GLAMO_REG_CLOCK_3D	= 0x001c,
+	GLAMO_REG_CLOCK_2D	= 0x001e,
+	GLAMO_REG_CLOCK_RISC1	= 0x0020,	/* 3365 only? */
+	GLAMO_REG_CLOCK_RISC2	= 0x0022,	/* 3365 only? */
+	GLAMO_REG_CLOCK_MPEG	= 0x0024,
+	GLAMO_REG_CLOCK_MPROC	= 0x0026,
+
+	GLAMO_REG_CLOCK_GEN5_1	= 0x0030,
+	GLAMO_REG_CLOCK_GEN5_2	= 0x0032,
+	GLAMO_REG_CLOCK_GEN6	= 0x0034,
+	GLAMO_REG_CLOCK_GEN7	= 0x0036,
+	GLAMO_REG_CLOCK_GEN8	= 0x0038,
+	GLAMO_REG_CLOCK_GEN9	= 0x003a,
+	GLAMO_REG_CLOCK_GEN10	= 0x003c,
+	GLAMO_REG_CLOCK_GEN11	= 0x003e,
+	GLAMO_REG_PLL_GEN1	= 0x0040,
+	GLAMO_REG_PLL_GEN2	= 0x0042,
+	GLAMO_REG_PLL_GEN3	= 0x0044,
+	GLAMO_REG_PLL_GEN4	= 0x0046,
+	GLAMO_REG_PLL_GEN5	= 0x0048,
+	GLAMO_REG_GPIO_GEN1	= 0x0050,
+	GLAMO_REG_GPIO_GEN2	= 0x0052,
+	GLAMO_REG_GPIO_GEN3	= 0x0054,
+	GLAMO_REG_GPIO_GEN4	= 0x0056,
+	GLAMO_REG_GPIO_GEN5	= 0x0058,
+	GLAMO_REG_GPIO_GEN6	= 0x005a,
+	GLAMO_REG_GPIO_GEN7	= 0x005c,
+	GLAMO_REG_GPIO_GEN8	= 0x005e,
+	GLAMO_REG_GPIO_GEN9	= 0x0060,
+	GLAMO_REG_GPIO_GEN10	= 0x0062,
+	GLAMO_REG_DFT_GEN1	= 0x0070,
+	GLAMO_REG_DFT_GEN2	= 0x0072,
+	GLAMO_REG_DFT_GEN3	= 0x0074,
+	GLAMO_REG_DFT_GEN4	= 0x0076,
+
+	GLAMO_REG_DFT_GEN5	= 0x01e0,
+	GLAMO_REG_DFT_GEN6	= 0x01f0,
+};
+
+#define GLAMO_REG_HOSTBUS(x)	(GLAMO_REGOFS_HOSTBUS-2+(x*2))
+
+#define REG_MEM(x)		(GLAMO_REGOFS_MEMORY+(x))
+#define GLAMO_REG_MEM_TIMING(x)	(GLAMO_REG_MEM_TIMING1-2+(x*2))
+
+enum glamo_register_mem {
+	GLAMO_REG_MEM_TYPE	= REG_MEM(0x00),
+	GLAMO_REG_MEM_GEN	= REG_MEM(0x02),
+	GLAMO_REG_MEM_TIMING1	= REG_MEM(0x04),
+	GLAMO_REG_MEM_TIMING2	= REG_MEM(0x06),
+	GLAMO_REG_MEM_TIMING3	= REG_MEM(0x08),
+	GLAMO_REG_MEM_TIMING4	= REG_MEM(0x0a),
+	GLAMO_REG_MEM_TIMING5	= REG_MEM(0x0c),
+	GLAMO_REG_MEM_TIMING6	= REG_MEM(0x0e),
+	GLAMO_REG_MEM_TIMING7	= REG_MEM(0x10),
+	GLAMO_REG_MEM_TIMING8	= REG_MEM(0x12),
+	GLAMO_REG_MEM_TIMING9	= REG_MEM(0x14),
+	GLAMO_REG_MEM_TIMING10	= REG_MEM(0x16),
+	GLAMO_REG_MEM_TIMING11	= REG_MEM(0x18),
+	GLAMO_REG_MEM_POWER1	= REG_MEM(0x1a),
+	GLAMO_REG_MEM_POWER2	= REG_MEM(0x1c),
+	GLAMO_REG_MEM_LCD_BUF1	= REG_MEM(0x1e),
+	GLAMO_REG_MEM_LCD_BUF2	= REG_MEM(0x20),
+	GLAMO_REG_MEM_LCD_BUF3	= REG_MEM(0x22),
+	GLAMO_REG_MEM_LCD_BUF4	= REG_MEM(0x24),
+	GLAMO_REG_MEM_BIST1	= REG_MEM(0x26),
+	GLAMO_REG_MEM_BIST2	= REG_MEM(0x28),
+	GLAMO_REG_MEM_BIST3	= REG_MEM(0x2a),
+	GLAMO_REG_MEM_BIST4	= REG_MEM(0x2c),
+	GLAMO_REG_MEM_BIST5	= REG_MEM(0x2e),
+	GLAMO_REG_MEM_MAH1	= REG_MEM(0x30),
+	GLAMO_REG_MEM_MAH2	= REG_MEM(0x32),
+	GLAMO_REG_MEM_DRAM1	= REG_MEM(0x34),
+	GLAMO_REG_MEM_DRAM2	= REG_MEM(0x36),
+	GLAMO_REG_MEM_CRC	= REG_MEM(0x38),
+};
+
+#define GLAMO_MEM_TYPE_MASK	0x03
+
+enum glamo_reg_mem_dram1 {
+	/* b0 - b10 == refresh period, 1 -> 2048 clocks */
+	GLAMO_MEM_DRAM1_EN_GATE_CLK	= (1 << 11),
+	GLAMO_MEM_DRAM1_SELF_REFRESH	= (1 << 12),
+	GLAMO_MEM_DRAM1_EN_GATE_CKE	= (1 << 13),
+	GLAMO_MEM_DRAM1_EN_DRAM_REFRESH	= (1 << 14),
+	GLAMO_MEM_DRAM1_EN_MODEREG_SET	= (1 << 15),
+};
+
+enum glamo_reg_mem_dram2 {
+	GLAMO_MEM_DRAM2_DEEP_PWRDOWN	= (1 << 12),
+};
+
+enum glamo_irq_index {
+	GLAMO_IRQIDX_HOSTBUS	= 0,
+	GLAMO_IRQIDX_JPEG	= 1,
+	GLAMO_IRQIDX_MPEG	= 2,
+	GLAMO_IRQIDX_MPROC1	= 3,
+	GLAMO_IRQIDX_MPROC0	= 4,
+	GLAMO_IRQIDX_CMDQUEUE	= 5,
+	GLAMO_IRQIDX_2D		= 6,
+	GLAMO_IRQIDX_MMC	= 7,
+	GLAMO_IRQIDX_RISC	= 8,
+};
+
+enum glamo_irq {
+	GLAMO_IRQ_HOSTBUS	= (1 << GLAMO_IRQIDX_HOSTBUS),
+	GLAMO_IRQ_JPEG		= (1 << GLAMO_IRQIDX_JPEG),
+	GLAMO_IRQ_MPEG		= (1 << GLAMO_IRQIDX_MPEG),
+	GLAMO_IRQ_MPROC1	= (1 << GLAMO_IRQIDX_MPROC1),
+	GLAMO_IRQ_MPROC0	= (1 << GLAMO_IRQIDX_MPROC0),
+	GLAMO_IRQ_CMDQUEUE	= (1 << GLAMO_IRQIDX_CMDQUEUE),
+	GLAMO_IRQ_2D		= (1 << GLAMO_IRQIDX_2D),
+	GLAMO_IRQ_MMC		= (1 << GLAMO_IRQIDX_MMC),
+	GLAMO_IRQ_RISC		= (1 << GLAMO_IRQIDX_RISC),
+};
+
+enum glamo_reg_clock_host {
+	GLAMO_CLOCK_HOST_DG_BCLK	= 0x0001,
+	GLAMO_CLOCK_HOST_DG_M0CLK	= 0x0004,
+	GLAMO_CLOCK_HOST_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_mem {
+	GLAMO_CLOCK_MEM_DG_M1CLK	= 0x0001,
+	GLAMO_CLOCK_MEM_EN_M1CLK	= 0x0002,
+	GLAMO_CLOCK_MEM_DG_MOCACLK	= 0x0004,
+	GLAMO_CLOCK_MEM_EN_MOCACLK	= 0x0008,
+	GLAMO_CLOCK_MEM_RESET		= 0x1000,
+	GLAMO_CLOCK_MOCA_RESET		= 0x2000,
+};
+
+enum glamo_reg_clock_lcd {
+	GLAMO_CLOCK_LCD_DG_DCLK		= 0x0001,
+	GLAMO_CLOCK_LCD_EN_DCLK		= 0x0002,
+	GLAMO_CLOCK_LCD_DG_DMCLK	= 0x0004,
+	GLAMO_CLOCK_LCD_EN_DMCLK	= 0x0008,
+	//
+	GLAMO_CLOCK_LCD_EN_DHCLK	= 0x0020,
+	GLAMO_CLOCK_LCD_DG_M5CLK	= 0x0040,
+	GLAMO_CLOCK_LCD_EN_M5CLK	= 0x0080,
+	GLAMO_CLOCK_LCD_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_mmc {
+	GLAMO_CLOCK_MMC_DG_TCLK		= 0x0001,
+	GLAMO_CLOCK_MMC_EN_TCLK		= 0x0002,
+	GLAMO_CLOCK_MMC_DG_M9CLK	= 0x0004,
+	GLAMO_CLOCK_MMC_EN_M9CLK	= 0x0008,
+	GLAMO_CLOCK_MMC_RESET		= 0x1000,
+};
+
+enum glamo_reg_basic_mmc {
+	/* set to disable CRC error rejection */
+	GLAMO_BASIC_MMC_DISABLE_CRC	= 0x0001,
+	/* enable completion interrupt */
+	GLAMO_BASIC_MMC_EN_COMPL_INT	= 0x0002,
+	/* stop MMC clock while enforced idle waiting for data from card */
+	GLAMO_BASIC_MMC_NO_CLK_RD_WAIT	= 0x0004,
+	/* 0 = 1-bit bus to card, 1 = use 4-bit bus (has to be negotiated) */
+	GLAMO_BASIC_MMC_EN_4BIT_DATA	= 0x0008,
+	/* enable 75K pullups on D3..D0 */
+	GLAMO_BASIC_MMC_EN_DATA_PUPS	= 0x0010,
+	/* enable 75K pullup on CMD */
+	GLAMO_BASIC_MMC_EN_CMD_PUP	= 0x0020,
+	/* IO drive strength 00=weak -> 11=strongest */
+	GLAMO_BASIC_MMC_EN_DR_STR0	= 0x0040,
+	GLAMO_BASIC_MMC_EN_DR_STR1	= 0x0080,
+	/* TCLK delay stage A, 0000 = 500ps --> 1111 = 8ns */
+	GLAMO_BASIC_MMC_EN_TCLK_DLYA0	= 0x0100,
+	GLAMO_BASIC_MMC_EN_TCLK_DLYA1	= 0x0200,
+	GLAMO_BASIC_MMC_EN_TCLK_DLYA2	= 0x0400,
+	GLAMO_BASIC_MMC_EN_TCLK_DLYA3	= 0x0800,
+	/* TCLK delay stage B (cumulative), 0000 = 500ps --> 1111 = 8ns */
+	GLAMO_BASIC_MMC_EN_TCLK_DLYB0	= 0x1000,
+	GLAMO_BASIC_MMC_EN_TCLK_DLYB1	= 0x2000,
+	GLAMO_BASIC_MMC_EN_TCLK_DLYB2	= 0x4000,
+	GLAMO_BASIC_MMC_EN_TCLK_DLYB3	= 0x8000,
+};
+
+enum glamo_reg_stat1_mmc {
+	/* command "counter" (really: toggle) */
+	GLAMO_STAT1_MMC_CMD_CTR	= 0x8000,
+	/* engine is idle */
+	GLAMO_STAT1_MMC_IDLE	= 0x4000,
+	/* readback response is ready */
+	GLAMO_STAT1_MMC_RB_RRDY	= 0x0200,
+	/* readback data is ready */
+	GLAMO_STAT1_MMC_RB_DRDY	= 0x0100,
+	/* no response timeout */
+	GLAMO_STAT1_MMC_RTOUT	= 0x0020,
+	/* no data timeout */
+	GLAMO_STAT1_MMC_DTOUT	= 0x0010,
+	/* CRC error on block write */
+	GLAMO_STAT1_MMC_BWERR	= 0x0004,
+	/* CRC error on block read */
+	GLAMO_STAT1_MMC_BRERR	= 0x0002
+};
+
+enum glamo_reg_fire_mmc {
+	/* command "counter" (really: toggle)
+	 * the STAT1 register reflects this so you can ensure you don't look
+	 * at status for previous command
+	 */
+	GLAMO_FIRE_MMC_CMD_CTR	= 0x8000,
+	/* sets kind of response expected */
+	GLAMO_FIRE_MMC_RES_MASK	= 0x0700,
+	/* sets command type */
+	GLAMO_FIRE_MMC_TYP_MASK	= 0x00C0,
+	/* sets command class */
+	GLAMO_FIRE_MMC_CLS_MASK	= 0x000F,
+};
+
+enum glamo_fire_mmc_response_types {
+	GLAMO_FIRE_MMC_RSPT_R1	= 0x0000,
+	GLAMO_FIRE_MMC_RSPT_R1b	= 0x0100,
+	GLAMO_FIRE_MMC_RSPT_R2	= 0x0200,
+	GLAMO_FIRE_MMC_RSPT_R3	= 0x0300,
+	GLAMO_FIRE_MMC_RSPT_R4	= 0x0400,
+	GLAMO_FIRE_MMC_RSPT_R5	= 0x0500,
+};
+
+enum glamo_fire_mmc_command_types {
+	/* broadcast, no response */
+	GLAMO_FIRE_MMC_CMDT_BNR	= 0x0000,
+	/* broadcast, with response */
+	GLAMO_FIRE_MMC_CMDT_BR	= 0x0040,
+	/* addressed, no data */
+	GLAMO_FIRE_MMC_CMDT_AND	= 0x0080,
+	/* addressed, with data */
+	GLAMO_FIRE_MMC_CMDT_AD	= 0x00C0,
+};
+
+enum glamo_fire_mmc_command_class {
+	/* "Stream Read" */
+	GLAMO_FIRE_MMC_CC_STRR	= 0x0000,
+	/* Single Block Read */
+	GLAMO_FIRE_MMC_CC_SBR	= 0x0001,
+	/* Multiple Block Read With Stop */
+	GLAMO_FIRE_MMC_CC_MBRS	= 0x0002,
+	/* Multiple Block Read No Stop */
+	GLAMO_FIRE_MMC_CC_MBRNS	= 0x0003,
+	/* RESERVED for "Stream Write" */
+	GLAMO_FIRE_MMC_CC_STRW	= 0x0004,
+	/* "Stream Write" */
+	GLAMO_FIRE_MMC_CC_SBW	= 0x0005,
+	/* RESERVED for Multiple Block Write With Stop */
+	GLAMO_FIRE_MMC_CC_MBWS	= 0x0006,
+	/* Multiple Block Write No Stop */
+	GLAMO_FIRE_MMC_CC_MBWNS	= 0x0007,
+	/* STOP command */
+	GLAMO_FIRE_MMC_CC_STOP	= 0x0008,
+	/* Cancel on Running Command */
+	GLAMO_FIRE_MMC_CC_CANCL	= 0x0009,
+	/* "Basic Command" */
+	GLAMO_FIRE_MMC_CC_BASIC	= 0x000a,
+};
+
+/* these are offsets from the start of the MMC register region */
+enum glamo_register_mmc {
+	/* MMC command, b15..8 = cmd arg b7..0; b7..1 = CRC; b0 = end bit */
+	GLAMO_REG_MMC_CMD_REG1	= 0x00,
+	/* MMC command, b15..0 = cmd arg b23 .. 8 */
+	GLAMO_REG_MMC_CMD_REG2	= 0x02,
+	/* MMC command, b15=start, b14=transmission,
+	 * b13..8=cmd idx, b7..0=cmd arg b31..24
+	 */
+	GLAMO_REG_MMC_CMD_REG3	= 0x04,
+	GLAMO_REG_MMC_CMD_FIRE	= 0x06,
+	GLAMO_REG_MMC_CMD_RSP1	= 0x10,
+	GLAMO_REG_MMC_CMD_RSP2	= 0x12,
+	GLAMO_REG_MMC_CMD_RSP3	= 0x14,
+	GLAMO_REG_MMC_CMD_RSP4	= 0x16,
+	GLAMO_REG_MMC_CMD_RSP5	= 0x18,
+	GLAMO_REG_MMC_CMD_RSP6	= 0x1a,
+	GLAMO_REG_MMC_CMD_RSP7	= 0x1c,
+	GLAMO_REG_MMC_CMD_RSP8	= 0x1e,
+	GLAMO_REG_MMC_RB_STAT1	= 0x20,
+	GLAMO_REG_MMC_RB_BLKCNT	= 0x22,
+	GLAMO_REG_MMC_RB_BLKLEN	= 0x24,
+	GLAMO_REG_MMC_BASIC	= 0x30,
+	GLAMO_REG_MMC_RDATADS1	= 0x34,
+	GLAMO_REG_MMC_RDATADS2	= 0x36,
+	GLAMO_REG_MMC_WDATADS1	= 0x38,
+	GLAMO_REG_MMC_WDATADS2	= 0x3a,
+	GLAMO_REG_MMC_DATBLKCNT	= 0x3c,
+	GLAMO_REG_MMC_DATBLKLEN	= 0x3e,
+	GLAMO_REG_MMC_TIMEOUT	= 0x40,
+
+};
+
+enum glamo_reg_clock_isp {
+	GLAMO_CLOCK_ISP_DG_I1CLK	= 0x0001,
+	GLAMO_CLOCK_ISP_EN_I1CLK	= 0x0002,
+	GLAMO_CLOCK_ISP_DG_CCLK		= 0x0004,
+	GLAMO_CLOCK_ISP_EN_CCLK		= 0x0008,
+	//
+	GLAMO_CLOCK_ISP_EN_SCLK		= 0x0020,
+	GLAMO_CLOCK_ISP_DG_M2CLK	= 0x0040,
+	GLAMO_CLOCK_ISP_EN_M2CLK	= 0x0080,
+	GLAMO_CLOCK_ISP_DG_M15CLK	= 0x0100,
+	GLAMO_CLOCK_ISP_EN_M15CLK	= 0x0200,
+	GLAMO_CLOCK_ISP1_RESET		= 0x1000,
+	GLAMO_CLOCK_ISP2_RESET		= 0x2000,
+};
+
+enum glamo_reg_clock_jpeg {
+	GLAMO_CLOCK_JPEG_DG_JCLK	= 0x0001,
+	GLAMO_CLOCK_JPEG_EN_JCLK	= 0x0002,
+	GLAMO_CLOCK_JPEG_DG_M3CLK	= 0x0004,
+	GLAMO_CLOCK_JPEG_EN_M3CLK	= 0x0008,
+	GLAMO_CLOCK_JPEG_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_2d {
+	GLAMO_CLOCK_2D_DG_GCLK		= 0x0001,
+	GLAMO_CLOCK_2D_EN_GCLK		= 0x0002,
+	GLAMO_CLOCK_2D_DG_M7CLK		= 0x0004,
+	GLAMO_CLOCK_2D_EN_M7CLK		= 0x0008,
+	GLAMO_CLOCK_2D_DG_M6CLK		= 0x0010,
+	GLAMO_CLOCK_2D_EN_M6CLK		= 0x0020,
+	GLAMO_CLOCK_2D_RESET		= 0x1000,
+	GLAMO_CLOCK_2D_CQ_RESET		= 0x2000,
+};
+
+enum glamo_reg_clock_3d {
+	GLAMO_CLOCK_3D_DG_ECLK		= 0x0001,
+	GLAMO_CLOCK_3D_EN_ECLK		= 0x0002,
+	GLAMO_CLOCK_3D_DG_RCLK		= 0x0004,
+	GLAMO_CLOCK_3D_EN_RCLK		= 0x0008,
+	GLAMO_CLOCK_3D_DG_M8CLK		= 0x0010,
+	GLAMO_CLOCK_3D_EN_M8CLK		= 0x0020,
+	GLAMO_CLOCK_3D_BACK_RESET	= 0x1000,
+	GLAMO_CLOCK_3D_FRONT_RESET	= 0x2000,
+};
+
+enum glamo_reg_clock_mpeg {
+	GLAMO_CLOCK_MPEG_DG_X0CLK	= 0x0001,
+	GLAMO_CLOCK_MPEG_EN_X0CLK	= 0x0002,
+	GLAMO_CLOCK_MPEG_DG_X1CLK	= 0x0004,
+	GLAMO_CLOCK_MPEG_EN_X1CLK	= 0x0008,
+	GLAMO_CLOCK_MPEG_DG_X2CLK	= 0x0010,
+	GLAMO_CLOCK_MPEG_EN_X2CLK	= 0x0020,
+	GLAMO_CLOCK_MPEG_DG_X3CLK	= 0x0040,
+	GLAMO_CLOCK_MPEG_EN_X3CLK	= 0x0080,
+	GLAMO_CLOCK_MPEG_DG_X4CLK	= 0x0100,
+	GLAMO_CLOCK_MPEG_EN_X4CLK	= 0x0200,
+	GLAMO_CLOCK_MPEG_DG_X6CLK	= 0x0400,
+	GLAMO_CLOCK_MPEG_EN_X6CLK	= 0x0800,
+	GLAMO_CLOCK_MPEG_ENC_RESET	= 0x1000,
+	GLAMO_CLOCK_MPEG_DEC_RESET	= 0x2000,
+};
+
+enum glamo_reg_clock51 {
+	GLAMO_CLOCK_GEN51_EN_DIV_MCLK	= 0x0001,
+	GLAMO_CLOCK_GEN51_EN_DIV_SCLK	= 0x0002,
+	GLAMO_CLOCK_GEN51_EN_DIV_JCLK	= 0x0004,
+	GLAMO_CLOCK_GEN51_EN_DIV_DCLK	= 0x0008,
+	GLAMO_CLOCK_GEN51_EN_DIV_DMCLK	= 0x0010,
+	GLAMO_CLOCK_GEN51_EN_DIV_DHCLK	= 0x0020,
+	GLAMO_CLOCK_GEN51_EN_DIV_GCLK	= 0x0040,
+	GLAMO_CLOCK_GEN51_EN_DIV_TCLK	= 0x0080,
+	/* FIXME: higher bits */
+};
+
+enum glamo_reg_hostbus2 {
+	GLAMO_HOSTBUS2_MMIO_EN_ISP	= 0x0001,
+	GLAMO_HOSTBUS2_MMIO_EN_JPEG	= 0x0002,
+	GLAMO_HOSTBUS2_MMIO_EN_MPEG	= 0x0004,
+	GLAMO_HOSTBUS2_MMIO_EN_LCD	= 0x0008,
+	GLAMO_HOSTBUS2_MMIO_EN_MMC	= 0x0010,
+	GLAMO_HOSTBUS2_MMIO_EN_MICROP0	= 0x0020,
+	GLAMO_HOSTBUS2_MMIO_EN_MICROP1	= 0x0040,
+	GLAMO_HOSTBUS2_MMIO_EN_CQ	= 0x0080,
+	GLAMO_HOSTBUS2_MMIO_EN_RISC	= 0x0100,
+	GLAMO_HOSTBUS2_MMIO_EN_2D	= 0x0200,
+	GLAMO_HOSTBUS2_MMIO_EN_3D	= 0x0400,
+};
+
+/* LCD Controller */
+
+#define REG_LCD(x)	(x)
+enum glamo_reg_lcd {
+	GLAMO_REG_LCD_MODE1		= REG_LCD(0x00),
+	GLAMO_REG_LCD_MODE2		= REG_LCD(0x02),
+	GLAMO_REG_LCD_MODE3		= REG_LCD(0x04),
+	GLAMO_REG_LCD_WIDTH		= REG_LCD(0x06),
+	GLAMO_REG_LCD_HEIGHT		= REG_LCD(0x08),
+	GLAMO_REG_LCD_POLARITY		= REG_LCD(0x0a),
+	GLAMO_REG_LCD_A_BASE1		= REG_LCD(0x0c),
+	GLAMO_REG_LCD_A_BASE2		= REG_LCD(0x0e),
+	GLAMO_REG_LCD_B_BASE1		= REG_LCD(0x10),
+	GLAMO_REG_LCD_B_BASE2		= REG_LCD(0x12),
+	GLAMO_REG_LCD_C_BASE1		= REG_LCD(0x14),
+	GLAMO_REG_LCD_C_BASE2		= REG_LCD(0x16),
+	GLAMO_REG_LCD_PITCH		= REG_LCD(0x18),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_TOTAL	= REG_LCD(0x1c),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_RETR_START	= REG_LCD(0x20),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_RETR_END	= REG_LCD(0x24),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_DISP_START	= REG_LCD(0x28),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_DISP_END	= REG_LCD(0x2c),
+	/* RES */
+	GLAMO_REG_LCD_VERT_TOTAL	= REG_LCD(0x30),
+	/* RES */
+	GLAMO_REG_LCD_VERT_RETR_START	= REG_LCD(0x34),
+	/* RES */
+	GLAMO_REG_LCD_VERT_RETR_END	= REG_LCD(0x38),
+	/* RES */
+	GLAMO_REG_LCD_VERT_DISP_START	= REG_LCD(0x3c),
+	/* RES */
+	GLAMO_REG_LCD_VERT_DISP_END	= REG_LCD(0x40),
+	/* RES */
+	GLAMO_REG_LCD_POL		= REG_LCD(0x44),
+	GLAMO_REG_LCD_DATA_START	= REG_LCD(0x46),
+	GLAMO_REG_LCD_FRATE_CONTRO	= REG_LCD(0x48),
+	GLAMO_REG_LCD_DATA_CMD_HDR	= REG_LCD(0x4a),
+	GLAMO_REG_LCD_SP_START		= REG_LCD(0x4c),
+	GLAMO_REG_LCD_SP_END		= REG_LCD(0x4e),
+	GLAMO_REG_LCD_CURSOR_BASE1	= REG_LCD(0x50),
+	GLAMO_REG_LCD_CURSOR_BASE2	= REG_LCD(0x52),
+	GLAMO_REG_LCD_CURSOR_PITCH	= REG_LCD(0x54),
+	GLAMO_REG_LCD_CURSOR_X_SIZE	= REG_LCD(0x56),
+	GLAMO_REG_LCD_CURSOR_Y_SIZE	= REG_LCD(0x58),
+	GLAMO_REG_LCD_CURSOR_X_POS	= REG_LCD(0x5a),
+	GLAMO_REG_LCD_CURSOR_Y_POS	= REG_LCD(0x5c),
+	GLAMO_REG_LCD_CURSOR_PRESET	= REG_LCD(0x5e),
+	GLAMO_REG_LCD_CURSOR_FG_COLOR	= REG_LCD(0x60),
+	/* RES */
+	GLAMO_REG_LCD_CURSOR_BG_COLOR	= REG_LCD(0x64),
+	/* RES */
+	GLAMO_REG_LCD_CURSOR_DST_COLOR	= REG_LCD(0x68),
+	/* RES */
+	GLAMO_REG_LCD_STATUS1		= REG_LCD(0x80),
+	GLAMO_REG_LCD_STATUS2		= REG_LCD(0x82),
+	GLAMO_REG_LCD_STATUS3		= REG_LCD(0x84),
+	GLAMO_REG_LCD_STATUS4		= REG_LCD(0x86),
+	/* RES */
+	GLAMO_REG_LCD_COMMAND1		= REG_LCD(0xa0),
+	GLAMO_REG_LCD_COMMAND2		= REG_LCD(0xa2),
+	/* RES */
+	GLAMO_REG_LCD_WFORM_DELAY1	= REG_LCD(0xb0),
+	GLAMO_REG_LCD_WFORM_DELAY2	= REG_LCD(0xb2),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_CORR	= REG_LCD(0x100),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_R_ENTRY01	= REG_LCD(0x110),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY23	= REG_LCD(0x112),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY45	= REG_LCD(0x114),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY67	= REG_LCD(0x116),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY8	= REG_LCD(0x118),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_G_ENTRY01	= REG_LCD(0x130),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY23	= REG_LCD(0x132),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY45	= REG_LCD(0x134),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY67	= REG_LCD(0x136),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY8	= REG_LCD(0x138),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_B_ENTRY01	= REG_LCD(0x150),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY23	= REG_LCD(0x152),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY45	= REG_LCD(0x154),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY67	= REG_LCD(0x156),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY8	= REG_LCD(0x158),
+	/* RES */
+	GLAMO_REG_LCD_SRAM_DRIVING1	= REG_LCD(0x160),
+	GLAMO_REG_LCD_SRAM_DRIVING2	= REG_LCD(0x162),
+	GLAMO_REG_LCD_SRAM_DRIVING3	= REG_LCD(0x164),
+};
+
+enum glamo_reg_lcd_mode1 {
+	GLAMO_LCD_MODE1_PWRSAVE		= 0x0001,
+	GLAMO_LCD_MODE1_PARTIAL_PRT	= 0x0002,
+	GLAMO_LCD_MODE1_HWFLIP		= 0x0004,
+	GLAMO_LCD_MODE1_LCD2		= 0x0008,
+	/* RES */
+	GLAMO_LCD_MODE1_PARTIAL_MODE	= 0x0020,
+	GLAMO_LCD_MODE1_CURSOR_DSTCOLOR	= 0x0040,
+	GLAMO_LCD_MODE1_PARTIAL_ENABLE	= 0x0080,
+	GLAMO_LCD_MODE1_TVCLK_IN_ENABLE	= 0x0100,
+	GLAMO_LCD_MODE1_HSYNC_HIGH_ACT	= 0x0200,
+	GLAMO_LCD_MODE1_VSYNC_HIGH_ACT	= 0x0400,
+	GLAMO_LCD_MODE1_HSYNC_FLIP	= 0x0800,
+	GLAMO_LCD_MODE1_GAMMA_COR_EN	= 0x1000,
+	GLAMO_LCD_MODE1_DITHER_EN	= 0x2000,
+	GLAMO_LCD_MODE1_CURSOR_EN	= 0x4000,
+	GLAMO_LCD_MODE1_ROTATE_EN	= 0x8000,
+};
+
+enum glamo_reg_lcd_mode2 {
+	GLAMO_LCD_MODE2_CRC_CHECK_EN	= 0x0001,
+	GLAMO_LCD_MODE2_DCMD_PER_LINE	= 0x0002,
+	GLAMO_LCD_MODE2_NOUSE_BDEF	= 0x0004,
+	GLAMO_LCD_MODE2_OUT_POS_MODE	= 0x0008,
+	GLAMO_LCD_MODE2_FRATE_CTRL_EN	= 0x0010,
+	GLAMO_LCD_MODE2_SINGLE_BUFFER	= 0x0020,
+	GLAMO_LCD_MODE2_SER_LSB_TO_MSB	= 0x0040,
+	/* FIXME */
+};
+
+enum glamo_reg_lcd_mode3 {
+	/* LCD color source data format */
+	GLAMO_LCD_SRC_RGB565		= 0x0000,
+	GLAMO_LCD_SRC_ARGB1555		= 0x4000,
+	GLAMO_LCD_SRC_ARGB4444		= 0x8000,
+	/* interface type */
+	GLAMO_LCD_MODE3_LCD		= 0x1000,
+	GLAMO_LCD_MODE3_RGB		= 0x0800,
+	GLAMO_LCD_MODE3_CPU		= 0x0000,
+	/* mode */
+	GLAMO_LCD_MODE3_RGB332		= 0x0000,
+	GLAMO_LCD_MODE3_RGB444		= 0x0100,
+	GLAMO_LCD_MODE3_RGB565		= 0x0200,
+	GLAMO_LCD_MODE3_RGB666		= 0x0300,
+	/* depth */
+	GLAMO_LCD_MODE3_6BITS		= 0x0000,
+	GLAMO_LCD_MODE3_8BITS		= 0x0010,
+	GLAMO_LCD_MODE3_9BITS		= 0x0020,
+	GLAMO_LCD_MODE3_16BITS		= 0x0030,
+	GLAMO_LCD_MODE3_18BITS		= 0x0040,
+};
+
+enum glamo_lcd_rot_mode {
+        GLAMO_LCD_ROT_MODE_0            = 0x0000,
+        GLAMO_LCD_ROT_MODE_180          = 0x2000,
+        GLAMO_LCD_ROT_MODE_MIRROR       = 0x4000,
+        GLAMO_LCD_ROT_MODE_FLIP         = 0x6000,
+        GLAMO_LCD_ROT_MODE_90           = 0x8000,
+        GLAMO_LCD_ROT_MODE_270          = 0xa000,
+};
+#define GLAMO_LCD_ROT_MODE_MASK         0xe000
+
+enum glamo_lcd_cmd_type {
+	GLAMO_LCD_CMD_TYPE_DISP		= 0x0000,
+	GLAMO_LCD_CMD_TYPE_PARALLEL	= 0x4000,
+	GLAMO_LCD_CMD_TYPE_SERIAL	= 0x8000,
+	GLAMO_LCD_CMD_TYPE_SERIAL_DIRECT= 0xc000,
+};
+#define GLAMO_LCD_CMD_TYPE_MASK		0xc000
+
+enum glamo_lcd_cmds {
+	GLAMO_LCD_CMD_DATA_DISP_FIRE	= 0x00,
+	GLAMO_LCD_CMD_DATA_DISP_SYNC	= 0x01,		/* RGB only */
+	/* switch to command mode, no display */
+	GLAMO_LCD_CMD_DATA_FIRE_NO_DISP	= 0x02,
+	/* display until VSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_VSYNC	= 0x11,
+	/* display until HSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_HSYNC	= 0x12,
+	/* display until VSYNC, 1 black frame, VSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_VSYNC_B	= 0x13,
+	/* don't care about display and switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_FREE	= 0x14,		/* RGB only */
+	/* don't care about display, keep data display but disable data,
+	 * and switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_FREE_D	= 0x15,		/* RGB only */
+};
+
+enum glamo_core_revisions {
+	GLAMO_CORE_REV_A0		= 0x0000,
+	GLAMO_CORE_REV_A1		= 0x0001,
+	GLAMO_CORE_REV_A2		= 0x0002,
+	GLAMO_CORE_REV_A3		= 0x0003,
+};
+
+#endif /* _GLAMO_REGS_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-spi-gpio.c linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-spi-gpio.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/glamo-spi-gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/glamo-spi-gpio.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2007 Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *
+ * Smedia Glamo GPIO based SPI driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This driver currently only implements a minimum subset of the hardware
+ * features, esp. those features that are required to drive the jbt6k74
+ * LCM controller asic in the TD028TTEC1 LCM.
+ *
+*/
+
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/spi/glamo.h>
+
+#include <linux/glamofb.h>
+
+#include <mach/hardware.h>
+
+#include "glamo-core.h"
+#include "glamo-regs.h"
+
+struct glamo_spigpio {
+	struct spi_bitbang		bitbang;
+	struct spi_master		*master;
+	struct glamo_spigpio_info	*info;
+	struct glamo_core		*glamo;
+};
+
+static inline struct glamo_spigpio *to_sg(struct spi_device *spi)
+{
+	return dev_get_drvdata(&spi->master->dev);
+}
+
+static inline void setsck(struct spi_device *dev, int on)
+{
+	struct glamo_spigpio *sg = to_sg(dev);
+	glamo_gpio_setpin(sg->glamo, sg->info->pin_clk, on ? 1 : 0);
+}
+
+static inline void setmosi(struct spi_device *dev, int on)
+{
+	struct glamo_spigpio *sg = to_sg(dev);
+	glamo_gpio_setpin(sg->glamo, sg->info->pin_mosi, on ? 1 : 0);
+}
+
+static inline u32 getmiso(struct spi_device *dev)
+{
+	struct glamo_spigpio *sg = to_sg(dev);
+	if (sg->info->pin_miso)
+		return glamo_gpio_getpin(sg->glamo, sg->info->pin_miso) ? 1 : 0;
+	else
+		return 0;
+}
+
+#define spidelay(x) ndelay(x)
+
+#define EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+static u32 glamo_spigpio_txrx_mode0(struct spi_device *spi,
+				    unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+}
+
+static u32 glamo_spigpio_txrx_mode1(struct spi_device *spi,
+				    unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+}
+
+static u32 glamo_spigpio_txrx_mode2(struct spi_device *spi,
+				    unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+}
+
+static u32 glamo_spigpio_txrx_mode3(struct spi_device *spi,
+				    unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+}
+
+
+#if 0
+static int glamo_spigpio_setupxfer(struct spi_device *spi,
+				   struct spi_transfer *t)
+{
+	struct glamo_spi *gs = to_sg(spi);
+	unsigned int bpw;
+
+	bpw = t ? t->bits_per_word : spi->bits_per_word;
+
+	if (bpw != 9 && bpw != 8) {
+		dev_err(&spi->dev, "invalid bits-per-word (%d)\n", bpw);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+static void glamo_spigpio_chipsel(struct spi_device *spi, int value)
+{
+	struct glamo_spigpio *gs = to_sg(spi);
+#if 0
+	dev_dbg(&spi->dev, "chipsel %d: spi=%p, gs=%p, info=%p, handle=%p\n",
+		value, spi, gs, gs->info, gs->info->glamo);
+#endif
+	glamo_gpio_setpin(gs->glamo, gs->info->pin_cs, value ? 0 : 1);
+}
+
+
+static int glamo_spigpio_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct glamo_spigpio *sp;
+	int ret;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(struct glamo_spigpio));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "failed to allocate spi master\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	sp = spi_master_get_devdata(master);
+	platform_set_drvdata(pdev, sp);
+	sp->info = pdev->dev.platform_data;
+	if (!sp->info) {
+		dev_err(&pdev->dev, "can't operate without platform data\n");
+		ret = -EIO;
+		goto err_no_pdev;
+	}
+
+	master->num_chipselect = 1;
+	master->bus_num = 2; /* FIXME: use dynamic number */
+
+	sp->master = spi_master_get(master);
+	sp->glamo = sp->info->glamo;
+
+	sp->bitbang.master = sp->master;
+	sp->bitbang.chipselect = glamo_spigpio_chipsel;
+	sp->bitbang.txrx_word[SPI_MODE_0] = glamo_spigpio_txrx_mode0;
+	sp->bitbang.txrx_word[SPI_MODE_1] = glamo_spigpio_txrx_mode1;
+	sp->bitbang.txrx_word[SPI_MODE_2] = glamo_spigpio_txrx_mode2;
+	sp->bitbang.txrx_word[SPI_MODE_3] = glamo_spigpio_txrx_mode3;
+
+	/* set state of spi pins */
+	glamo_gpio_setpin(sp->glamo, sp->info->pin_clk, 0);
+	glamo_gpio_setpin(sp->glamo, sp->info->pin_mosi, 0);
+	glamo_gpio_setpin(sp->glamo, sp->info->pin_cs, 1);
+
+	glamo_gpio_cfgpin(sp->glamo, sp->info->pin_clk);
+	glamo_gpio_cfgpin(sp->glamo, sp->info->pin_mosi);
+	glamo_gpio_cfgpin(sp->glamo, sp->info->pin_cs);
+	if (sp->info->pin_miso)
+		glamo_gpio_cfgpin(sp->glamo, sp->info->pin_miso);
+
+	/* bring the LCM panel out of reset if it isn't already */
+
+	glamo_gpio_setpin(sp->glamo, GLAMO_GPIO4, 1);
+	glamo_gpio_cfgpin(sp->glamo, GLAMO_GPIO4_OUTPUT);
+	msleep(90);
+
+#if 0
+	sp->dev = &pdev->dev;
+
+	sp->bitbang.setup_transfer = glamo_spi_setupxfer;
+	sp->bitbang.txrx_bufs = glamo_spi_txrx;
+	sp->bitbang.master->setup = glamo_spi_setup;
+#endif
+
+	dev_set_drvdata(&sp->master->dev, sp);
+
+	ret = spi_bitbang_start(&sp->bitbang);
+	if (ret)
+		goto err_no_bitbang;
+
+	return 0;
+
+err_no_bitbang:
+	platform_set_drvdata(pdev, NULL);
+err_no_pdev:
+	spi_master_put(sp->bitbang.master);
+err:
+	return ret;
+
+}
+
+static int glamo_spigpio_remove(struct platform_device *pdev)
+{
+	struct glamo_spigpio *sp = platform_get_drvdata(pdev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+/*#define glamo_spigpio_suspend NULL
+#define glamo_spigpio_resume NULL
+*/
+
+
+#ifdef CONFIG_PM
+static int glamo_spigpio_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+static int glamo_spigpio_resume(struct platform_device *pdev)
+{
+	struct glamo_spigpio *sp = platform_get_drvdata(pdev);
+
+	if (!sp)
+		return 0;
+
+	/* set state of spi pins */
+	glamo_gpio_setpin(sp->glamo, sp->info->pin_clk, 0);
+	glamo_gpio_setpin(sp->glamo, sp->info->pin_mosi, 0);
+	glamo_gpio_setpin(sp->glamo, sp->info->pin_cs, 1);
+
+	glamo_gpio_cfgpin(sp->glamo, sp->info->pin_clk);
+	glamo_gpio_cfgpin(sp->glamo, sp->info->pin_mosi);
+	glamo_gpio_cfgpin(sp->glamo, sp->info->pin_cs);
+	if (sp->info->pin_miso)
+		glamo_gpio_cfgpin(sp->glamo, sp->info->pin_miso);
+
+	return 0;
+}
+#endif
+
+static struct platform_driver glamo_spi_drv = {
+	.probe		= glamo_spigpio_probe,
+	.remove		= glamo_spigpio_remove,
+#ifdef CONFIG_PM
+	.suspend_late	= glamo_spigpio_suspend,
+	.resume_early	= glamo_spigpio_resume,
+#endif
+	.driver		= {
+		.name	= "glamo-spi-gpio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init glamo_spi_init(void)
+{
+	return platform_driver_register(&glamo_spi_drv);
+}
+
+static void __exit glamo_spi_exit(void)
+{
+	platform_driver_unregister(&glamo_spi_drv);
+}
+
+module_init(glamo_spi_init);
+module_exit(glamo_spi_exit);
+
+MODULE_DESCRIPTION("Smedia Glamo 336x/337x LCM serial command SPI Driver");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>")
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/Kconfig linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,57 @@
+config MFD_GLAMO
+	bool "Smedia Glamo 336x/337x support"
+	help
+	  This enables the core driver for the Smedia Glamo 336x/337x
+	  multi-function device.  It includes irq_chip demultiplex as
+	  well as clock / power management and GPIO support.
+
+config MFD_GLAMO_FB
+	tristate "Smedia Glamo 336x/337x framebuffer support"
+	depends on FB && MFD_GLAMO
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Frame buffer driver for the LCD controller in the Smedia Glamo
+	  336x/337x.
+
+	  This driver is also available as a module ( = code which can be
+	  inserted and removed from the running kernel whenever you want). The
+	  module will be called glamofb. If you want to compile it as a module,
+	  say M here and read <file:Documentation/modules.txt>.
+
+	  If unsure, say N.
+
+config MFD_GLAMO_FB_XGLAMO_WORKAROUND
+	bool "Smedia Glamo 336x/337x Xglamo rotation workaround"
+	depends on MFD_GLAMO_FB
+	help
+	  This is a workaround for a Xglamo bug. This should be fixed
+	  in Xglamo and not in kernel space.
+
+	  If unsure, say N.
+
+
+config MFD_GLAMO_SPI_GPIO
+       tristate "Glamo GPIO SPI bitbang support"
+       depends on MFD_GLAMO
+       help
+         Enable a bitbanging SPI adapter driver for the Smedia Glamo.
+
+config MFD_GLAMO_SPI_FB
+       tristate "Glamo LCM control channel SPI support"
+       depends on MFD_GLAMO_FB
+       help
+         Enable a bitbanging SPI adapter driver for the Smedia Glamo LCM
+	 control channel.  This SPI interface is frequently used to
+	 interconnect the LCM control interface.
+
+config MFD_GLAMO_MCI
+	tristate "Glamo S3C SD/MMC Card Interface support"
+	depends on MFD_GLAMO && MMC
+	help
+	  This selects a driver for the MCI interface found in
+	  the S-Media GLAMO chip, as used in Openmoko
+	  neo1973 GTA-02.
+
+	  If unsure, say N.
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/glamo/Makefile linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/Makefile
--- linux-2.6.29-rc3.owrt/drivers/mfd/glamo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/glamo/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,12 @@
+#
+# Makefile for the Smedia Glamo framebuffer driver
+#
+
+obj-$(CONFIG_MFD_GLAMO)			+= glamo-core.o glamo-gpio.o
+obj-$(CONFIG_MFD_GLAMO_SPI)		+= glamo-spi.o
+obj-$(CONFIG_MFD_GLAMO_SPI_GPIO) 	+= glamo-spi-gpio.o
+
+obj-$(CONFIG_MFD_GLAMO_FB)		+= glamo-fb.o
+obj-$(CONFIG_MFD_GLAMO_SPI_FB)		+= glamo-lcm-spi.o
+obj-$(CONFIG_MFD_GLAMO_MCI)		+= glamo-mci.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/Kconfig linux-2.6.29-rc3.owrt.om/drivers/mfd/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/mfd/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -240,6 +240,33 @@
 	 Say yes here if you want to include support GPIO for pins on
 	 the PCF50633 chip.
 
+
+config MFD_PCF50606
+        tristate "Support for NXP PCF50606"
+        depends on I2C
+        help
+          Say yes here if you have NXP PCF50606 chip on your board.
+          This core driver provides register access and IRQ handling
+          facilities, and registers devices for the various functions
+          so that function-specific drivers can bind to them.
+
+config PCF50606_ADC
+        tristate "Support for NXP PCF50606 ADC"
+        depends on MFD_PCF50606
+        help
+         Say yes here if you want to include support for ADC in the
+         NXP PCF50606 chip.
+
+config PCF50606_GPO
+        tristate "Support for NXP PCF50606 GPO"
+        depends on MFD_PCF50606
+        help
+         Say yes here if you want to include support GPO for pins on
+         the PCF50606 chip.
+
+
+source "drivers/mfd/glamo/Kconfig"
+
 endmenu
 
 menu "Multimedia Capabilities Port drivers"
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/Makefile linux-2.6.29-rc3.owrt.om/drivers/mfd/Makefile
--- linux-2.6.29-rc3.owrt/drivers/mfd/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_MFD_SM501)		+= sm501.o
 obj-$(CONFIG_MFD_ASIC3)		+= asic3.o
+obj-$(CONFIG_MFD_GLAMO)		+= glamo/
 
 obj-$(CONFIG_HTC_EGPIO)		+= htc-egpio.o
 obj-$(CONFIG_HTC_PASIC3)	+= htc-pasic3.o
@@ -40,4 +41,8 @@
 
 obj-$(CONFIG_MFD_PCF50633)	+= pcf50633-core.o
 obj-$(CONFIG_PCF50633_ADC)	+= pcf50633-adc.o
-obj-$(CONFIG_PCF50633_GPIO)	+= pcf50633-gpio.o
\ No newline at end of file
+obj-$(CONFIG_PCF50633_GPIO)	+= pcf50633-gpio.o
+
+obj-$(CONFIG_MFD_PCF50606)	+= pcf50606-core.o
+obj-$(CONFIG_PCF50606_ADC)	+= pcf50606-adc.o
+obj-$(CONFIG_PCF50606_GPO)	+= pcf50606-gpo.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/pcf50606-adc.c linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50606-adc.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/pcf50606-adc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50606-adc.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,279 @@
+/* Philips PCF50606 ADC Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte, Andy Green, Werner Almesberger and Matt Hsu
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  NOTE: This driver does not yet support subtractive ADC mode, which means
+ *  you can do only one measurement per read request.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/completion.h>
+
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/mfd/pcf50606/adc.h>
+
+struct pcf50606_adc_request {
+	int mux;
+	int result;
+	void (*callback)(struct pcf50606 *, void *, int);
+	void *callback_param;
+
+	/* Used in case of sync requests */
+	struct completion completion;
+
+};
+
+#define PCF50606_MAX_ADC_FIFO_DEPTH 8
+
+struct pcf50606_adc {
+	struct pcf50606 *pcf;
+
+	/* Private stuff */
+	struct pcf50606_adc_request *queue[PCF50606_MAX_ADC_FIFO_DEPTH];
+	int queue_head;
+	int queue_tail;
+	struct mutex queue_mutex;
+};
+
+static inline struct pcf50606_adc *__to_adc(struct pcf50606 *pcf)
+{
+	return platform_get_drvdata(pcf->adc_pdev);
+}
+
+static void adc_setup(struct pcf50606 *pcf, int channel)
+{
+	channel &= PCF50606_ADCC2_ADCMUX_MASK;
+
+	/* start ADC conversion of selected channel */
+	pcf50606_reg_write(pcf, PCF50606_REG_ADCC2, channel |
+		    PCF50606_ADCC2_ADCSTART | PCF50606_ADCC2_RES_10BIT);
+
+}
+
+static void trigger_next_adc_job_if_any(struct pcf50606 *pcf)
+{
+	struct pcf50606_adc *adc = __to_adc(pcf);
+	int head, tail;
+
+	mutex_lock(&adc->queue_mutex);
+
+	head = adc->queue_head;
+	tail = adc->queue_tail;
+
+	if (!adc->queue[head])
+		goto out;
+
+	adc_setup(pcf, adc->queue[head]->mux);
+out:
+	mutex_unlock(&adc->queue_mutex);
+}
+
+static int
+adc_enqueue_request(struct pcf50606 *pcf, struct pcf50606_adc_request *req)
+{
+	struct pcf50606_adc *adc = __to_adc(pcf);
+	int head, tail;
+
+	mutex_lock(&adc->queue_mutex);
+	head = adc->queue_head;
+	tail = adc->queue_tail;
+
+	if (adc->queue[tail]) {
+		mutex_unlock(&adc->queue_mutex);
+		return -EBUSY;
+	}
+
+	adc->queue[tail] = req;
+
+	adc->queue_tail =
+		(tail + 1) & (PCF50606_MAX_ADC_FIFO_DEPTH - 1);
+
+	mutex_unlock(&adc->queue_mutex);
+
+	trigger_next_adc_job_if_any(pcf);
+
+	return 0;
+}
+
+static void
+pcf50606_adc_sync_read_callback(struct pcf50606 *pcf, void *param, int result)
+{
+	struct pcf50606_adc_request *req;
+
+	/*We know here that the passed param is an adc_request object */
+	req = (struct pcf50606_adc_request *)param;
+
+	req->result = result;
+	complete(&req->completion);
+}
+
+int pcf50606_adc_sync_read(struct pcf50606 *pcf, int mux)
+{
+
+	struct pcf50606_adc_request *req;
+	int result;
+
+	/* req is freed when the result is ready, in irq handler*/
+	req = kzalloc(sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	req->mux = mux;
+	req->callback =  pcf50606_adc_sync_read_callback;
+	req->callback_param = req;
+	init_completion(&req->completion);
+
+	adc_enqueue_request(pcf, req);
+
+	if (wait_for_completion_timeout(&req->completion, 5 * HZ) == 5 * HZ) {
+		dev_err(pcf->dev, "ADC read timed out \n");
+	}
+
+	result = req->result;
+
+	return result;
+}
+EXPORT_SYMBOL_GPL(pcf50606_adc_sync_read);
+
+int pcf50606_adc_async_read(struct pcf50606 *pcf, int mux,
+			     void (*callback)(struct pcf50606 *, void *, int),
+			     void *callback_param)
+{
+	struct pcf50606_adc_request *req;
+
+	/* req is freed when the result is ready, in pcf50606_work*/
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	req->mux = mux;
+	req->callback = callback;
+	req->callback_param = callback_param;
+
+	adc_enqueue_request(pcf, req);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pcf50606_adc_async_read);
+
+static int adc_result(struct pcf50606 *pcf)
+{
+	u16 ret = (pcf50606_reg_read(pcf, PCF50606_REG_ADCS1) << 2) |
+			(pcf50606_reg_read(pcf, PCF50606_REG_ADCS2) & 0x03);
+
+	dev_dbg(pcf->dev, "adc result = %d\n", ret);
+
+	return ret;
+}
+
+static void pcf50606_adc_irq(int irq, void *data)
+{
+	struct pcf50606_adc *adc = data;
+	struct pcf50606 *pcf = adc->pcf;
+	struct pcf50606_adc_request *req;
+	int head;
+
+	mutex_lock(&adc->queue_mutex);
+	head = adc->queue_head;
+
+	req = adc->queue[head];
+	if (WARN_ON(!req)) {
+		dev_err(pcf->dev, "pcf50606-adc irq: ADC queue empty!\n");
+		mutex_unlock(&adc->queue_mutex);
+		return;
+	}
+
+	adc->queue[head] = NULL;
+	adc->queue_head = (head + 1) &
+				      (PCF50606_MAX_ADC_FIFO_DEPTH - 1);
+
+	mutex_unlock(&adc->queue_mutex);
+
+	req->callback(pcf, req->callback_param, adc_result(pcf));
+	kfree(req);
+
+	trigger_next_adc_job_if_any(pcf);
+}
+
+static int __devinit pcf50606_adc_probe(struct platform_device *pdev)
+{
+	struct pcf50606_subdev_pdata *pdata = pdev->dev.platform_data;
+	struct pcf50606_adc *adc;
+
+	adc = kzalloc(sizeof(*adc), GFP_KERNEL);
+	if (!adc)
+		return -ENOMEM;
+
+	adc->pcf = pdata->pcf;
+	platform_set_drvdata(pdev, adc);
+
+	pcf50606_register_irq(pdata->pcf, PCF50606_IRQ_ADCRDY,
+					pcf50606_adc_irq, adc);
+
+	mutex_init(&adc->queue_mutex);
+
+	return 0;
+}
+
+static int __devexit pcf50606_adc_remove(struct platform_device *pdev)
+{
+	struct pcf50606_adc *adc = platform_get_drvdata(pdev);
+	int i, head;
+
+	pcf50606_free_irq(adc->pcf, PCF50606_IRQ_ADCRDY);
+
+	mutex_lock(&adc->queue_mutex);
+	head = adc->queue_head;
+
+	if (WARN_ON(adc->queue[head]))
+		dev_err(adc->pcf->dev,
+			"adc driver removed with request pending\n");
+
+	for (i = 0; i < PCF50606_MAX_ADC_FIFO_DEPTH; i++)
+		kfree(adc->queue[i]);
+
+	mutex_unlock(&adc->queue_mutex);
+	kfree(adc);
+
+	return 0;
+}
+
+struct platform_driver pcf50606_adc_driver = {
+	.driver = {
+		.name = "pcf50606-adc",
+	},
+	.probe = pcf50606_adc_probe,
+	.remove = __devexit_p(pcf50606_adc_remove),
+};
+
+static int __init pcf50606_adc_init(void)
+{
+		return platform_driver_register(&pcf50606_adc_driver);
+}
+module_init(pcf50606_adc_init);
+
+static void __exit pcf50606_adc_exit(void)
+{
+		platform_driver_unregister(&pcf50606_adc_driver);
+}
+module_exit(pcf50606_adc_exit);
+
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_DESCRIPTION("PCF50606 adc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pcf50606-adc");
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/pcf50606-core.c linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50606-core.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/pcf50606-core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50606-core.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,680 @@
+/* Philips PCF50606 Power Management Unit (PMU) driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ *	    Matt Hsu <matt@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <linux/mfd/pcf50606/core.h>
+
+static int __pcf50606_read(struct pcf50606 *pcf, u8 reg, int num, u8 *data)
+{
+	int ret;
+
+	ret = i2c_smbus_read_i2c_block_data(pcf->i2c_client, reg,
+				num, data);
+	if (ret < 0)
+		dev_err(pcf->dev, "Error reading %d regs at %d\n", num, reg);
+
+	return ret;
+}
+
+static int __pcf50606_write(struct pcf50606 *pcf, u8 reg, int num, u8 *data)
+{
+	int ret;
+
+	ret = i2c_smbus_write_i2c_block_data(pcf->i2c_client, reg,
+				num, data);
+	if (ret < 0)
+		dev_err(pcf->dev, "Error writing %d regs at %d\n", num, reg);
+
+	return ret;
+
+}
+
+/* Read a block of upto 32 regs  */
+int pcf50606_read_block(struct pcf50606 *pcf, u8 reg,
+					int nr_regs, u8 *data)
+{
+	int ret;
+
+	mutex_lock(&pcf->lock);
+	ret = __pcf50606_read(pcf, reg, nr_regs, data);
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcf50606_read_block);
+
+/* Write a block of upto 32 regs  */
+int pcf50606_write_block(struct pcf50606 *pcf , u8 reg,
+					int nr_regs, u8 *data)
+{
+	int ret;
+
+	mutex_lock(&pcf->lock);
+	ret = __pcf50606_write(pcf, reg, nr_regs, data);
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcf50606_write_block);
+
+u8 pcf50606_reg_read(struct pcf50606 *pcf, u8 reg)
+{
+	u8 val;
+
+	mutex_lock(&pcf->lock);
+	__pcf50606_read(pcf, reg, 1, &val);
+	mutex_unlock(&pcf->lock);
+
+	return val;
+}
+EXPORT_SYMBOL_GPL(pcf50606_reg_read);
+
+int pcf50606_reg_write(struct pcf50606 *pcf, u8 reg, u8 val)
+{
+	int ret;
+
+	mutex_lock(&pcf->lock);
+	ret = __pcf50606_write(pcf, reg, 1, &val);
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcf50606_reg_write);
+
+int pcf50606_reg_set_bit_mask(struct pcf50606 *pcf, u8 reg, u8 mask, u8 val)
+{
+	int ret;
+	u8 tmp;
+
+	val &= mask;
+
+	mutex_lock(&pcf->lock);
+	ret = __pcf50606_read(pcf, reg, 1, &tmp);
+	if (ret < 0)
+		goto out;
+
+	tmp &= ~mask;
+	tmp |= val;
+	ret = __pcf50606_write(pcf, reg, 1, &tmp);
+
+out:
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcf50606_reg_set_bit_mask);
+
+int pcf50606_reg_clear_bits(struct pcf50606 *pcf, u8 reg, u8 val)
+{
+	int ret;
+	u8 tmp;
+
+	mutex_lock(&pcf->lock);
+	ret = __pcf50606_read(pcf, reg, 1, &tmp);
+	if (ret < 0)
+		goto out;
+
+	tmp &= ~val;
+	ret = __pcf50606_write(pcf, reg, 1, &tmp);
+
+out:
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pcf50606_reg_clear_bits);
+
+/* sysfs attributes */
+static ssize_t show_dump_regs(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	struct pcf50606 *pcf = dev_get_drvdata(dev);
+	u8 dump[16];
+	int n, n1, idx = 0;
+	char *buf1 = buf;
+	static u8 address_no_read[] = { /* must be ascending */
+		PCF50606_REG_INT1,
+		PCF50606_REG_INT2,
+		PCF50606_REG_INT3,
+		0 /* terminator */
+	};
+
+	for (n = 0; n < 256; n += sizeof(dump)) {
+		for (n1 = 0; n1 < sizeof(dump); n1++)
+			if (n == address_no_read[idx]) {
+				idx++;
+				dump[n1] = 0x00;
+			} else
+				dump[n1] = pcf50606_reg_read(pcf, n + n1);
+
+		hex_dump_to_buffer(dump, sizeof(dump), 16, 1, buf1, 128, 0);
+		buf1 += strlen(buf1);
+		*buf1++ = '\n';
+		*buf1 = '\0';
+	}
+
+	return buf1 - buf;
+}
+static DEVICE_ATTR(dump_regs, 0400, show_dump_regs, NULL);
+
+static ssize_t show_resume_reason(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct pcf50606 *pcf = dev_get_drvdata(dev);
+	int n;
+
+	n = sprintf(buf, "%02x%02x%02x\n",
+				pcf->resume_reason[0],
+				pcf->resume_reason[1],
+				pcf->resume_reason[2]);
+
+	return n;
+}
+static DEVICE_ATTR(resume_reason, 0400, show_resume_reason, NULL);
+
+static struct attribute *pcf_sysfs_entries[] = {
+	&dev_attr_dump_regs.attr,
+	&dev_attr_resume_reason.attr,
+	NULL,
+};
+
+static struct attribute_group pcf_attr_group = {
+	.name	= NULL,			/* put in device directory */
+	.attrs	= pcf_sysfs_entries,
+};
+
+int pcf50606_register_irq(struct pcf50606 *pcf, int irq,
+			void (*handler) (int, void *), void *data)
+{
+	if (irq < 0 || irq > PCF50606_NUM_IRQ || !handler)
+		return -EINVAL;
+
+	if (WARN_ON(pcf->irq_handler[irq].handler))
+		return -EBUSY;
+
+	mutex_lock(&pcf->lock);
+	pcf->irq_handler[irq].handler = handler;
+	pcf->irq_handler[irq].data = data;
+	mutex_unlock(&pcf->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pcf50606_register_irq);
+
+int pcf50606_free_irq(struct pcf50606 *pcf, int irq)
+{
+	if (irq < 0 || irq > PCF50606_NUM_IRQ)
+		return -EINVAL;
+
+	mutex_lock(&pcf->lock);
+	pcf->irq_handler[irq].handler = NULL;
+	mutex_unlock(&pcf->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pcf50606_free_irq);
+
+static int __pcf50606_irq_mask_set(struct pcf50606 *pcf, int irq, u8 mask)
+{
+	u8 reg, bits, tmp;
+	int ret = 0, idx;
+
+	idx = irq >> 3;
+	reg =  PCF50606_REG_INT1M + idx;
+	bits = 1 << (irq & 0x07);
+
+	mutex_lock(&pcf->lock);
+
+	if (mask) {
+		ret = __pcf50606_read(pcf, reg, 1, &tmp);
+		if (ret < 0)
+			goto out;
+
+		tmp |= bits;
+
+		ret = __pcf50606_write(pcf, reg, 1, &tmp);
+		if (ret < 0)
+			goto out;
+
+		pcf->mask_regs[idx] &= ~bits;
+		pcf->mask_regs[idx] |= bits;
+	} else {
+		ret = __pcf50606_read(pcf, reg, 1, &tmp);
+		if (ret < 0)
+			goto out;
+
+		tmp &= ~bits;
+
+		ret = __pcf50606_write(pcf, reg, 1, &tmp);
+		if (ret < 0)
+			goto out;
+
+		pcf->mask_regs[idx] &= ~bits;
+	}
+out:
+	mutex_unlock(&pcf->lock);
+
+	return ret;
+}
+
+int pcf50606_irq_mask(struct pcf50606 *pcf, int irq)
+{
+	dev_info(pcf->dev, "Masking IRQ %d\n", irq);
+
+	return __pcf50606_irq_mask_set(pcf, irq, 1);
+}
+EXPORT_SYMBOL_GPL(pcf50606_irq_mask);
+
+int pcf50606_irq_unmask(struct pcf50606 *pcf, int irq)
+{
+	dev_info(pcf->dev, "Unmasking IRQ %d\n", irq);
+
+	return __pcf50606_irq_mask_set(pcf, irq, 0);
+}
+EXPORT_SYMBOL_GPL(pcf50606_irq_unmask);
+
+int pcf50606_irq_mask_get(struct pcf50606 *pcf, int irq)
+{
+	u8 reg, bits;
+
+	reg =  (irq / 8);
+	bits = (1 << (irq % 8));
+
+	return pcf->mask_regs[reg] & bits;
+}
+EXPORT_SYMBOL_GPL(pcf50606_irq_mask_get);
+
+static void pcf50606_irq_call_handler(struct pcf50606 *pcf,
+					int irq)
+{
+	if (pcf->irq_handler[irq].handler)
+		pcf->irq_handler[irq].handler(irq, pcf->irq_handler[irq].data);
+}
+
+#define PCF50606_ONKEY1S_TIMEOUT 	8
+
+#define PCF50606_REG_MBCS1		0x2c
+
+static void pcf50606_irq_worker(struct work_struct *work)
+{
+	struct pcf50606 *pcf;
+	int ret, i, j;
+	u8 pcf_int[3], chgstat;
+
+	pcf = container_of(work, struct pcf50606, irq_work);
+
+	/* Read the 3 INT regs in one transaction */
+	ret = pcf50606_read_block(pcf, PCF50606_REG_INT1,
+						ARRAY_SIZE(pcf_int), pcf_int);
+	if (ret != ARRAY_SIZE(pcf_int)) {
+		dev_info(pcf->dev, "Error reading INT registers\n");
+		
+		/*
+		 * If this doesn't ACK the interrupt to the chip, we'll be
+		 * called once again as we're level triggered.
+		 */
+		goto out;
+	}
+
+	/* We immediately read the charger status. We thus make sure
+	 * only of CHGINS/CHGRM interrupt handlers are called */
+	if (pcf_int[1] & (PCF50606_INT2_CHGINS | PCF50606_INT2_CHGRM)) {
+		chgstat = pcf50606_reg_read(pcf, PCF50606_REG_MBCS1);
+		if (chgstat & (0x1 << 4))
+			pcf_int[1] &= ~(1 << PCF50606_INT2_CHGRM);
+		else
+			pcf_int[1] &= ~(1 << PCF50606_INT2_CHGINS);
+	}
+	
+	dev_dbg(pcf->dev, "INT1=0x%02x INT2=0x%02x INT3=0x%02x\n",
+				pcf_int[0], pcf_int[1], pcf_int[2]);
+
+	/* Some revisions of the chip don't have a 8s standby mode on
+	 * ONKEY1S press. We try to manually do it in such cases. */
+	if (pcf_int[0] & PCF50606_INT1_SECOND && pcf->onkey1s_held) {
+		dev_info(pcf->dev, "ONKEY1S held for %d secs\n",
+							pcf->onkey1s_held);
+		if (pcf->onkey1s_held++ == PCF50606_ONKEY1S_TIMEOUT)
+			if (pcf->pdata->force_shutdown)
+				pcf->pdata->force_shutdown(pcf);
+	}
+
+	if (pcf_int[0] & PCF50606_INT1_ONKEY1S) {
+		dev_info(pcf->dev, "ONKEY1S held\n");
+		pcf->onkey1s_held = 1 ;
+
+		/* Unmask IRQ_SECOND */
+		pcf50606_reg_clear_bits(pcf, PCF50606_REG_INT1M,
+						PCF50606_INT1_SECOND);
+
+		/* Unmask IRQ_ONKEYF */
+		pcf50606_reg_clear_bits(pcf, PCF50606_REG_INT1M,
+						PCF50606_INT1_ONKEYF);
+	}
+
+	if ((pcf_int[0] & PCF50606_INT1_ONKEYR) && pcf->onkey1s_held) {
+		pcf->onkey1s_held = 0;
+
+		/* Mask SECOND and ONKEYF interrupts */
+		if (pcf->mask_regs[0] & PCF50606_INT1_SECOND)
+			pcf50606_reg_set_bit_mask(pcf,
+					PCF50606_REG_INT1M,
+					PCF50606_INT1_SECOND,
+					PCF50606_INT1_SECOND);
+
+		if (pcf->mask_regs[0] & PCF50606_INT1_ONKEYF)
+			pcf50606_reg_set_bit_mask(pcf,
+					PCF50606_REG_INT1M,
+					PCF50606_INT1_ONKEYF,
+					PCF50606_INT1_ONKEYF);
+	}
+
+	/* Have we just resumed ? */
+	if (pcf->is_suspended) {
+
+		pcf->is_suspended = 0;
+
+		/* Set the resume reason filtering out non resumers */
+		for (i = 0; i < ARRAY_SIZE(pcf_int); i++)
+			pcf->resume_reason[i] = pcf_int[i] &
+						pcf->pdata->resumers[i];
+
+		/* Make sure we don't pass on ONKEY events to
+		 * userspace now */
+		pcf_int[1] &= ~(PCF50606_INT1_ONKEYR | PCF50606_INT1_ONKEYF);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(pcf_int); i++) {
+		/* Unset masked interrupts */
+		pcf_int[i] &= ~pcf->mask_regs[i];
+
+		for (j = 0; j < 8 ; j++)
+			if (pcf_int[i] & (1 << j))
+				pcf50606_irq_call_handler(pcf, (i * 8) + j);
+	}
+
+out:
+	put_device(pcf->dev);
+	enable_irq(pcf->irq);
+}
+
+static irqreturn_t pcf50606_irq(int irq, void *data)
+{
+	struct pcf50606 *pcf = data;
+
+	get_device(pcf->dev);
+	disable_irq(pcf->irq);
+	schedule_work(&pcf->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static void
+pcf50606_client_dev_register(struct pcf50606 *pcf, const char *name,
+						struct platform_device **pdev)
+{
+	struct pcf50606_subdev_pdata subdev_pdata;
+	int ret;
+
+	*pdev = platform_device_alloc(name, -1);
+	if (!*pdev) {
+		dev_err(pcf->dev, "Falied to allocate %s\n", name);
+		return;
+	}
+
+	subdev_pdata.pcf = pcf;
+	platform_device_add_data(*pdev, &subdev_pdata, sizeof(subdev_pdata));
+
+	(*pdev)->dev.parent = pcf->dev;
+
+	ret = platform_device_add(*pdev);
+	if (ret) {
+		dev_err(pcf->dev, "Failed to register %s: %d\n", name, ret);
+		platform_device_put(*pdev);
+		*pdev = NULL;
+	}
+}
+
+#ifdef CONFIG_PM
+static int pcf50606_suspend(struct device *dev, pm_message_t state)
+{
+	struct pcf50606 *pcf;
+	int ret, i;
+	u8 res[3];
+
+	pcf = dev_get_drvdata(dev);
+
+	/* Make sure our interrupt handlers are not called
+	 * henceforth */
+	disable_irq(pcf->irq);
+
+	/* Make sure that any running IRQ worker has quit */
+	cancel_work_sync(&pcf->irq_work);
+
+	/* Save the masks */
+	ret = pcf50606_read_block(pcf, PCF50606_REG_INT1M,
+				ARRAY_SIZE(pcf->suspend_irq_masks),
+						pcf->suspend_irq_masks);
+	if (ret < 0) {
+		dev_err(pcf->dev, "error saving irq masks\n");
+		goto out;
+	}
+	
+	/* Write wakeup irq masks */
+	for (i = 0; i < ARRAY_SIZE(res); i++)
+		res[i] = ~pcf->pdata->resumers[i];
+
+	ret = pcf50606_write_block(pcf, PCF50606_REG_INT1M,
+					ARRAY_SIZE(res), &res[0]);
+	if (ret < 0) {
+		dev_err(pcf->dev, "error writing wakeup irq masks\n");
+		goto out;
+	}
+
+	pcf->is_suspended = 1;
+
+out:
+	return ret;
+}
+
+static int pcf50606_resume(struct device *dev)
+{
+	struct pcf50606 *pcf;
+	int ret;
+
+	pcf = dev_get_drvdata(dev);
+
+	/* Write the saved mask registers */
+	ret = pcf50606_write_block(pcf, PCF50606_REG_INT1M,
+				ARRAY_SIZE(pcf->suspend_irq_masks),
+					pcf->suspend_irq_masks);
+	if (ret < 0)
+		dev_err(pcf->dev, "Error restoring saved suspend masks\n");
+
+	get_device(pcf->dev);
+
+	/*
+	 * Clear any pending interrupts and set resume reason if any.
+	 * This will leave with enable_irq()
+	 */
+	pcf50606_irq_worker(&pcf->irq_work);
+
+	return 0;
+}
+#else
+#define pcf50606_suspend NULL
+#define pcf50606_resume NULL
+#endif
+
+static int pcf50606_probe(struct i2c_client *client,
+				const struct i2c_device_id *ids)
+{
+	struct pcf50606 *pcf;
+	struct pcf50606_platform_data *pdata = client->dev.platform_data;
+	int i, ret = 0;
+	int version, variant;
+
+	pcf = kzalloc(sizeof(*pcf), GFP_KERNEL);
+	if (!pcf)
+		return -ENOMEM;
+
+	pcf->pdata = pdata;
+
+	mutex_init(&pcf->lock);
+
+	i2c_set_clientdata(client, pcf);
+	pcf->dev = &client->dev;
+	pcf->i2c_client = client;
+	pcf->irq = client->irq;
+
+	INIT_WORK(&pcf->irq_work, pcf50606_irq_worker);
+
+	version = pcf50606_reg_read(pcf, 0);
+	variant = pcf50606_reg_read(pcf, 1);
+	if (version < 0 || variant < 0) {
+		dev_err(pcf->dev, "Unable to probe pcf50606\n");
+		ret = -ENODEV;
+		goto err;
+	}
+
+	dev_info(pcf->dev, "Probed device version %d variant %d\n",
+							version, variant);
+	/* Enable all inteerupts except RTC SECOND */
+	pcf->mask_regs[0] = 0x40;
+	pcf50606_reg_write(pcf, PCF50606_REG_INT1M, pcf->mask_regs[0]);
+	pcf50606_reg_write(pcf, PCF50606_REG_INT2M, 0x00);
+	pcf50606_reg_write(pcf, PCF50606_REG_INT3M, 0x00);
+
+	pcf50606_client_dev_register(pcf, "pcf50606-input",
+						&pcf->input_pdev);
+	pcf50606_client_dev_register(pcf, "pcf50606-rtc",
+						&pcf->rtc_pdev);
+	pcf50606_client_dev_register(pcf, "pcf50606-mbc",
+						&pcf->mbc_pdev);
+	pcf50606_client_dev_register(pcf, "pcf50606-adc",
+						&pcf->adc_pdev);
+	pcf50606_client_dev_register(pcf, "pcf50606-wdt",
+						&pcf->wdt_pdev);
+	for (i = 0; i < PCF50606_NUM_REGULATORS; i++) {
+		struct platform_device *pdev;
+
+		pdev = platform_device_alloc("pcf50606-regltr", i);
+		if (!pdev) {
+			dev_err(pcf->dev, "Cannot create regulator\n");
+			continue;
+		}
+	
+		pdev->dev.parent = pcf->dev;
+		pdev->dev.platform_data = &pdata->reg_init_data[i];
+		pdev->dev.driver_data = pcf;
+		pcf->regulator_pdev[i] = pdev;
+
+		platform_device_add(pdev);
+	}
+
+	if (client->irq) {
+		set_irq_handler(client->irq, handle_level_irq);
+		ret = request_irq(client->irq, pcf50606_irq,
+				IRQF_TRIGGER_LOW, "pcf50606", pcf);
+
+		if (ret) {
+			dev_err(pcf->dev, "Failed to request IRQ %d\n", ret);
+			goto err;
+		}
+	} else {
+		dev_err(pcf->dev, "No IRQ configured\n");
+		goto err;
+	}
+
+	if (enable_irq_wake(client->irq) < 0)
+		dev_err(pcf->dev, "IRQ %u cannot be enabled as wake-up source"
+			"in this hardware revision", client->irq);
+
+	ret = sysfs_create_group(&client->dev.kobj, &pcf_attr_group);
+	if (ret)
+		dev_err(pcf->dev, "error creating sysfs entries\n");
+
+	if (pdata->probe_done)
+		pdata->probe_done(pcf);
+
+	return 0;
+
+err:
+	kfree(pcf);
+	return ret;
+}
+
+static int pcf50606_remove(struct i2c_client *client)
+{
+	struct pcf50606 *pcf = i2c_get_clientdata(client);
+	int i;
+
+	free_irq(pcf->irq, pcf);
+
+	platform_device_unregister(pcf->input_pdev);
+	platform_device_unregister(pcf->rtc_pdev);
+	platform_device_unregister(pcf->mbc_pdev);
+	platform_device_unregister(pcf->adc_pdev);
+
+	for (i = 0; i < PCF50606_NUM_REGULATORS; i++)
+		platform_device_unregister(pcf->regulator_pdev[i]);
+
+	kfree(pcf);
+
+	return 0;
+}
+
+static struct i2c_device_id pcf50606_id_table[] = {
+	{"pcf50606", 0x08},
+};
+
+static struct i2c_driver pcf50606_driver = {
+	.driver = {
+		.name	= "pcf50606",
+		.suspend = pcf50606_suspend,
+		.resume	= pcf50606_resume,
+	},
+	.id_table = pcf50606_id_table,
+	.probe = pcf50606_probe,
+	.remove = pcf50606_remove,
+};
+
+static int __init pcf50606_init(void)
+{
+	return i2c_add_driver(&pcf50606_driver);
+}
+
+static void pcf50606_exit(void)
+{
+	i2c_del_driver(&pcf50606_driver);
+}
+
+MODULE_DESCRIPTION("I2C chip driver for NXP PCF50606 PMU");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_LICENSE("GPL");
+
+module_init(pcf50606_init);
+module_exit(pcf50606_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/pcf50606-gpo.c linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50606-gpo.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/pcf50606-gpo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50606-gpo.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,119 @@
+/* Philips PCF50606 GPO Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte, Andy Green Werner Almesberger and Matt Hsu
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/mfd/pcf50606/gpo.h>
+
+void pcf50606_gpo_set_active(struct pcf50606 *pcf, int gpo, int val)
+{
+	u8 reg, value, mask;
+
+	reg = gpo;
+	value = val;
+	mask = 0x07;
+
+	if (gpo == PCF50606_GPO2) {
+		value = val << 4;
+		mask = 0x07 << 4;
+	}
+	pcf50606_reg_set_bit_mask(pcf, reg, mask, value);
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo_set_active);
+
+int pcf50606_gpo_get_active(struct pcf50606 *pcf, int gpo)
+{
+	u8 reg, value, shift = 0;
+
+	reg = gpo;
+	if (gpo == PCF50606_GPO2)
+		shift = 4;
+	
+	value = pcf50606_reg_read(pcf, reg);
+
+	return (value >> shift) & 0x07;
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo_get_active);
+
+void pcf50606_gpo_set_standby(struct pcf50606 *pcf, int gpo, int val)
+{
+	u8 reg;
+
+	if (gpo == PCF50606_GPO1 || gpo == PCF50606_GPO2) {
+		dev_err(pcf->dev, "Can't set standby settings for GPO[12]n");
+		return;
+	}
+
+	reg = gpo;
+
+	pcf50606_reg_set_bit_mask(pcf, gpo, 0x07 << 3, val);
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo_set_standby);
+
+int pcf50606_gpo_get_standby(struct pcf50606 *pcf, int gpo)
+{
+	u8 reg, value;
+
+	if (gpo == PCF50606_GPO1 || gpo == PCF50606_GPO2) {
+		dev_err(pcf->dev, "Can't get standby settings for GPO[12]n");
+		return -EINVAL;
+	}
+
+	reg = gpo;
+	value = pcf50606_reg_read(pcf, reg);
+
+	return (value >> 3) & 0x07;
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo_get_standby);
+
+void pcf50606_gpo_invert_set(struct pcf50606 *pcf, int gpo, int invert)
+{
+	u8 reg, value, mask;
+
+	reg = gpo;
+	value = !!invert << 6;
+	mask = 0x01 << 6;
+
+	if (gpo == PCF50606_GPO1) {
+		mask = 0x01 << 4;
+		value = !!invert << 4;
+	}
+	else if (gpo == PCF50606_GPO2) {
+		mask = 0x01 << 7;
+		value = !!invert << 7;
+	}
+
+	pcf50606_reg_set_bit_mask(pcf, reg, mask, value);
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo_invert_set);
+
+int pcf50606_gpo_invert_get(struct pcf50606 *pcf, int gpo)
+{
+	u8 reg, value, shift;
+
+	reg = gpo;
+	shift = 6;
+
+	if (gpo == PCF50606_GPO1)
+		shift = 4;
+	else if (gpo == PCF50606_GPO2)
+		shift = 7;
+
+	value =  pcf50606_reg_read(pcf, reg);
+
+	return (value >> shift) & 0x01;
+}
+EXPORT_SYMBOL_GPL(pcf50606_gpo_invert_get);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mfd/pcf50633-core.c linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50633-core.c
--- linux-2.6.29-rc3.owrt/drivers/mfd/pcf50633-core.c	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mfd/pcf50633-core.c	2009-05-10 22:28:00.000000000 +0200
@@ -346,6 +346,8 @@
 		goto out;
 	}
 
+	pcf50633_reg_write(pcf, PCF50633_REG_OOCSHDWN,	0x04 );  /* defeat 8s death from lowsys on A5 */
+
 	/* We immediately read the usb and adapter status. We thus make sure
 	 * only of USBINS/USBREM IRQ handlers are called */
 	if (pcf_int[0] & (PCF50633_INT1_USBINS | PCF50633_INT1_USBREM)) {
@@ -445,6 +447,7 @@
 
 	get_device(pcf->dev);
 	disable_irq(pcf->irq);
+
 	schedule_work(&pcf->irq_work);
 
 	return IRQ_HANDLED;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/Kconfig linux-2.6.29-rc3.owrt.om/drivers/misc/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/misc/Kconfig	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -225,4 +225,10 @@
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 
+config MACH_NEO1973
+	bool
+	help
+	  Common machine code for Openmoko GTAxx hardware
+
 endif # MISC_DEVICES
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/Makefile linux-2.6.29-rc3.owrt.om/drivers/misc/Makefile
--- linux-2.6.29-rc3.owrt/drivers/misc/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -20,3 +20,8 @@
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-y				+= eeprom/
+obj-$(CONFIG_MACH_SMDK6410)	+= smdk6410-sleeptest.o
+obj-$(CONFIG_MACH_NEO1973)      += neo1973_version.o \
+                                   neo1973_pm_host.o \
+                                   neo1973_pm_resume_reason.o
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_charging_led.c linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_charging_led.c
--- linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_charging_led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_charging_led.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,106 @@
+/*
+ * Charging LED sysfs for the FIC Neo1973 GSM Phone
+ * (currently only implemented in GTA02 but ready for GTA01 implementation)
+ *
+ * (C) 2008 by Openmoko Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License charging_led 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+#include <asm/arch/gta02.h>
+
+static enum neo1973_charging_led_modes charging_mode;
+
+static char *charging_led_mode_names[] = {
+	"Disabled",
+	"Aux LED",
+	"Power LED"
+};
+
+static ssize_t charging_led_read(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%03X\n", gta02_get_pcb_revision());
+}
+
+static ssize_t charging_led_read(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%03X\n", gta02_get_pcb_revision());
+}
+
+
+static DEVICE_ATTR(pcb, 0644, charging_led_read, charging_led_write);
+
+static struct attribute *neo1973_charging_led_sysfs_entries[] = {
+	&dev_attr_pcb.attr,
+	NULL
+};
+
+static struct attribute_group neo1973_charging_led_attr_group = {
+	.name	= NULL,
+	.attrs	= neo1973_charging_led_sysfs_entries,
+};
+
+static int __init neo1973_charging_led_probe(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "starting\n");
+
+	switch (machine_arch_type) {
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	case MACH_TYPE_NEO1973_GTA01:
+		return -EINVAL;
+#endif /* CONFIG_MACH_NEO1973_GTA01 */
+	default:
+		break;
+	}
+
+	return sysfs_create_group(&pdev->dev.kobj,
+					     &neo1973_charging_led_attr_group);
+}
+
+static int neo1973_charging_led_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &neo1973_charging_led_attr_group);
+	return 0;
+}
+
+static struct platform_driver neo1973_charging_led_driver = {
+	.probe		= neo1973_charging_led_probe,
+	.remove		= neo1973_charging_led_remove,
+	.driver		= {
+		.name		= "neo1973-charging-led",
+	},
+};
+
+static int __devinit neo1973_charging_led_init(void)
+{
+	return platform_driver_register(&neo1973_charging_led_driver);
+}
+
+static void neo1973_charging_led_exit(void)
+{
+	platform_driver_unregister(&neo1973_charging_led_driver);
+}
+
+module_init(neo1973_charging_led_init);
+module_exit(neo1973_charging_led_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Neo1973 PCB charging_led");
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_host.c linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_host.c
--- linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_host.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_host.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,109 @@
+/*
+ * Bluetooth PM code for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2007 by Openmoko Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+#include <mach/gta02.h>
+#include <linux/mfd/pcf50633/gpio.h>
+
+static ssize_t pm_host_read(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	return sprintf(buf, "%d\n",
+		       pcf50633_gpio_get(gta02_pcf, PCF50633_GPO)
+		       				== PCF50633_GPOCFG_GPOSEL_1);
+}
+
+static ssize_t pm_host_write(struct device *dev, struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	unsigned long on = simple_strtoul(buf, NULL, 10);
+	u8 val;
+
+	if (on)
+		val = PCF50633_GPOCFG_GPOSEL_1;
+	else
+		val = PCF50633_GPOCFG_GPOSEL_0;
+
+
+	pcf50633_gpio_set(gta02_pcf, PCF50633_GPO, val);
+
+	return count;
+}
+
+static DEVICE_ATTR(hostmode, 0644, pm_host_read, pm_host_write);
+
+static struct attribute *neo1973_pm_host_sysfs_entries[] = {
+	&dev_attr_hostmode.attr,
+	NULL
+};
+
+static struct attribute_group neo1973_pm_host_attr_group = {
+	.name	= NULL,
+	.attrs	= neo1973_pm_host_sysfs_entries,
+};
+
+static int __init neo1973_pm_host_probe(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "starting\n");
+
+	switch (machine_arch_type) {
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	case MACH_TYPE_NEO1973_GTA01:
+		return -EINVAL;
+#endif /* CONFIG_MACH_NEO1973_GTA01 */
+	default:
+		break;
+	}
+
+	return sysfs_create_group(&pdev->dev.kobj, &neo1973_pm_host_attr_group);
+}
+
+static int neo1973_pm_host_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &neo1973_pm_host_attr_group);
+	return 0;
+}
+
+static struct platform_driver neo1973_pm_host_driver = {
+	.probe		= neo1973_pm_host_probe,
+	.remove		= neo1973_pm_host_remove,
+	.driver		= {
+		.name		= "neo1973-pm-host",
+	},
+};
+
+static int __devinit neo1973_pm_host_init(void)
+{
+	return platform_driver_register(&neo1973_pm_host_driver);
+}
+
+static void neo1973_pm_host_exit(void)
+{
+	platform_driver_unregister(&neo1973_pm_host_driver);
+}
+
+module_init(neo1973_pm_host_init);
+module_exit(neo1973_pm_host_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Neo1973 USB Host Power Management");
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_resume_reason.c linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_resume_reason.c
--- linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_resume_reason.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_resume_reason.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,147 @@
+/*
+ * Resume reason sysfs for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2008 by Openmoko Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License resume_reason 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+#include <mach/gta02.h>
+#include <linux/mfd/pcf50633/core.h>
+#endif
+
+static unsigned int *gstatus4_mapped;
+static char *resume_reasons[][17] = { { /* GTA01 */
+	"EINT00_NULL",
+	"EINT01_GSM",
+	"EINT02_NULL",
+	"EINT03_NULL",
+	"EINT04_JACK",
+	"EINT05_SDCARD",
+	"EINT06_AUXKEY",
+	"EINT07_HOLDKEY",
+	"EINT08_NULL",
+	"EINT09_NULL",
+	"EINT10_NULL",
+	"EINT11_NULL",
+	"EINT12_NULL",
+	"EINT13_NULL",
+	"EINT14_NULL",
+	"EINT15_NULL",
+	NULL
+}, { /* GTA02 */
+	"EINT00_ACCEL1",
+	"EINT01_GSM",
+	"EINT02_BLUETOOTH",
+	"EINT03_DEBUGBRD",
+	"EINT04_JACK",
+	"EINT05_WLAN",
+	"EINT06_AUXKEY",
+	"EINT07_HOLDKEY",
+	"EINT08_ACCEL2",
+	"EINT09_PMU",
+	"EINT10_NULL",
+	"EINT11_NULL",
+	"EINT12_GLAMO",
+	"EINT13_NULL",
+	"EINT14_NULL",
+	"EINT15_NULL",
+	NULL
+} };
+
+static ssize_t resume_reason_read(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	int bit = 0;
+	char *end = buf;
+	int gta = !!machine_is_neo1973_gta02();
+
+	for (bit = 0; resume_reasons[gta][bit]; bit++) {
+		if ((*gstatus4_mapped) & (1 << bit))
+			end += sprintf(end, "* %s\n", resume_reasons[gta][bit]);
+		else
+			end += sprintf(end, "  %s\n", resume_reasons[gta][bit]);
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+		if ((gta) && (bit == 9)); /* PMU */
+//			end += pcf50633_report_resumers(gta02_pcf_pdata.pcf, end);
+#endif
+	}
+
+	return end - buf;
+}
+
+
+static DEVICE_ATTR(resume_reason, 0644, resume_reason_read, NULL);
+
+static struct attribute *neo1973_resume_reason_sysfs_entries[] = {
+	&dev_attr_resume_reason.attr,
+	NULL
+};
+
+static struct attribute_group neo1973_resume_reason_attr_group = {
+	.name	= NULL,
+	.attrs	= neo1973_resume_reason_sysfs_entries,
+};
+
+static int __init neo1973_resume_reason_probe(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "starting\n");
+
+	gstatus4_mapped = ioremap(0x560000BC /* GSTATUS4 */, 0x4);
+	if (!gstatus4_mapped) {
+		dev_err(&pdev->dev, "failed to ioremap() memory region\n");
+		return -EINVAL;
+	}
+
+	return sysfs_create_group(&pdev->dev.kobj,
+					    &neo1973_resume_reason_attr_group);
+}
+
+static int neo1973_resume_reason_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &neo1973_resume_reason_attr_group);
+	iounmap(gstatus4_mapped);
+	return 0;
+}
+
+static struct platform_driver neo1973_resume_reason_driver = {
+	.probe		= neo1973_resume_reason_probe,
+	.remove		= neo1973_resume_reason_remove,
+	.driver		= {
+		.name		= "neo1973-resume",
+	},
+};
+
+static int __devinit neo1973_resume_reason_init(void)
+{
+	return platform_driver_register(&neo1973_resume_reason_driver);
+}
+
+static void neo1973_resume_reason_exit(void)
+{
+	platform_driver_unregister(&neo1973_resume_reason_driver);
+}
+
+module_init(neo1973_resume_reason_init);
+module_exit(neo1973_resume_reason_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Neo1973 resume_reason");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_usbhost.c linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_usbhost.c
--- linux-2.6.29-rc3.owrt/drivers/misc/neo1973_pm_usbhost.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_pm_usbhost.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,132 @@
+/*
+ * Bluetooth PM code for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2007 by OpenMoko Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+#include <asm/arch/gta02.h>
+#include <linux/pcf50633.h>
+#endif
+
+static ssize_t pm_usbhost_read(struct device *dev, struct device_attribute *attr,
+		       char *buf)
+{
+	return sprintf(buf, "%d\n",
+		       pcf50633_gpio_get(pcf50633_global, PCF50633_GPO));
+}
+
+static ssize_t pm_usbhost_write(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	unsigned long on = simple_strtoul(buf, NULL, 10);
+
+	pcf50633_gpio_set(pcf50633_global, PCF50633_GPO, on);
+
+	return count;
+}
+
+static DEVICE_ATTR(hostmode, 0644, pm_usbhost_read, pm_usbhost_write);
+
+#ifdef CONFIG_PM
+static int neo1973_usbhost_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	dev_dbg(&pdev->dev, "suspending\n");
+	/* FIXME: The PMU should save the PMU status, and the GPIO code should
+	 * preserve the GPIO level, so there shouldn't be anything left to do
+	 * for us, should there? */
+
+	return 0;
+}
+
+static int neo1973_usbhost_resume(struct platform_device *pdev)
+{
+	dev_dbg(&pdev->dev, "resuming\n");
+
+	return 0;
+}
+#else
+#define neo1973_usbhost_suspend	NULL
+#define neo1973_usbhost_resume	NULL
+#endif
+
+static struct attribute *neo1973_usbhost_sysfs_entries[] = {
+	&dev_attr_hostmode.attr,
+	NULL
+};
+
+static struct attribute_group neo1973_usbhost_attr_group = {
+	.name	= NULL,
+	.attrs	= neo1973_usbhost_sysfs_entries,
+};
+
+static int __init neo1973_usbhost_probe(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "starting\n");
+
+	switch (machine_arch_type) {
+
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	case MACH_TYPE_NEO1973_GTA01:
+		return -EINVAL;
+#endif /* CONFIG_MACH_NEO1973_GTA01 */
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+	case MACH_TYPE_NEO1973_GTA02:
+/* race */
+/*		pcf50633_gpio_set(pcf50633_global, PCF50633_GPO, 0); */
+		break;
+#endif /* CONFIG_MACH_NEO1973_GTA02 */
+	}
+
+	return sysfs_create_group(&pdev->dev.kobj, &neo1973_usbhost_attr_group);
+}
+
+static int neo1973_usbhost_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &neo1973_usbhost_attr_group);
+
+	return 0;
+}
+
+static struct platform_driver neo1973_usbhost_driver = {
+	.probe		= neo1973_usbhost_probe,
+	.remove		= neo1973_usbhost_remove,
+	.suspend	= neo1973_usbhost_suspend,
+	.resume		= neo1973_usbhost_resume,
+	.driver		= {
+		.name		= "neo1973-pm-host",
+	},
+};
+
+static int __devinit neo1973_usbhost_init(void)
+{
+	return platform_driver_register(&neo1973_usbhost_driver);
+}
+
+static void neo1973_usbhost_exit(void)
+{
+	platform_driver_unregister(&neo1973_usbhost_driver);
+}
+
+module_init(neo1973_usbhost_init);
+module_exit(neo1973_usbhost_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Neo1973 USB Host Power Management");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/neo1973_version.c linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_version.c
--- linux-2.6.29-rc3.owrt/drivers/misc/neo1973_version.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/neo1973_version.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,90 @@
+/*
+ * PCB version sysfs for the FIC Neo1973 GSM Phone
+ *
+ * (C) 2007 by Openmoko Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+
+#ifdef CONFIG_MACH_NEO1973_GTA02
+#include <mach/gta02.h>
+
+static ssize_t version_read(struct device *dev, struct device_attribute *attr,
+			    char *buf)
+{
+	return sprintf(buf, "0x%03X\n", gta02_get_pcb_revision());
+}
+
+
+static DEVICE_ATTR(pcb, 0644, version_read, NULL);
+
+static struct attribute *neo1973_version_sysfs_entries[] = {
+	&dev_attr_pcb.attr,
+	NULL
+};
+
+static struct attribute_group neo1973_version_attr_group = {
+	.name	= NULL,
+	.attrs	= neo1973_version_sysfs_entries,
+};
+
+static int __init neo1973_version_probe(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "starting\n");
+
+	switch (machine_arch_type) {
+#ifdef CONFIG_MACH_NEO1973_GTA01
+	case MACH_TYPE_NEO1973_GTA01:
+		return -EINVAL;
+#endif /* CONFIG_MACH_NEO1973_GTA01 */
+	default:
+		break;
+	}
+
+	return sysfs_create_group(&pdev->dev.kobj, &neo1973_version_attr_group);
+}
+
+static int neo1973_version_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &neo1973_version_attr_group);
+	return 0;
+}
+
+static struct platform_driver neo1973_version_driver = {
+	.probe		= neo1973_version_probe,
+	.remove		= neo1973_version_remove,
+	.driver		= {
+		.name		= "neo1973-version",
+	},
+};
+
+static int __devinit neo1973_version_init(void)
+{
+	return platform_driver_register(&neo1973_version_driver);
+}
+
+static void neo1973_version_exit(void)
+{
+	platform_driver_unregister(&neo1973_version_driver);
+}
+
+module_init(neo1973_version_init);
+module_exit(neo1973_version_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("Neo1973 PCB version");
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/misc/smdk6410-sleeptest.c linux-2.6.29-rc3.owrt.om/drivers/misc/smdk6410-sleeptest.c
--- linux-2.6.29-rc3.owrt/drivers/misc/smdk6410-sleeptest.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/misc/smdk6410-sleeptest.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,65 @@
+/* linux/drivers/misc/smdk6410-sleeptest.c
+ *
+ * Copyright 2008 Simtec Electronics
+ *	Ben Dooks <ben@simtec.co.uk>
+ *	http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+
+#include <plat/gpio-cfg.h>
+
+static irqreturn_t sleep_action(int irq, void *pw)
+{
+	printk(KERN_INFO "%s: irq %d\n", __func__, irq);
+	return IRQ_HANDLED;
+}
+
+static void sleep_setup(unsigned int irq, unsigned int gpio)
+{
+	int ret;
+
+	WARN_ON(s3c_gpio_cfgpin(gpio, S3C_GPIO_SFN(2)) < 0);
+	WARN_ON(s3c_gpio_setpull(gpio, S3C_GPIO_PULL_UP) < 0);
+
+	ret = request_irq(irq, sleep_action, IRQF_TRIGGER_FALLING,
+			  "sleep", NULL);
+	if (ret < 0)
+		printk(KERN_ERR "%s: request_irq() failed\n", __func__);
+
+	ret = set_irq_wake(irq, 1);
+	if (ret < 0)
+		printk(KERN_ERR "%s: set_irq_wake() failed\n", __func__);
+}
+
+static void sleep_led(unsigned int gpio)
+{
+//	gpio_request(gpio, "sleep led");
+//	gpio_direction_output(gpio, 0);
+}
+
+static __init int smdk6410_sleeptest_init(void)
+{
+	sleep_setup(IRQ_EINT(10), S3C64XX_GPN(10));
+//	sleep_led(S3C64XX_GPN(15));
+//	sleep_led(S3C64XX_GPN(14));
+//	sleep_led(S3C64XX_GPN(13));
+//	sleep_led(S3C64XX_GPN(12));
+
+	return 0;
+}
+
+module_init(smdk6410_sleeptest_init);
+
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/core/core.c linux-2.6.29-rc3.owrt.om/drivers/mmc/core/core.c
--- linux-2.6.29-rc3.owrt/drivers/mmc/core/core.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/core/core.c	2009-05-10 22:28:00.000000000 +0200
@@ -58,10 +58,11 @@
 /*
  * Internal function. Flush all scheduled work from the MMC work queue.
  */
-static void mmc_flush_scheduled_work(void)
+void mmc_flush_scheduled_work(void)
 {
 	flush_workqueue(workqueue);
 }
+EXPORT_SYMBOL_GPL(mmc_flush_scheduled_work);
 
 /**
  *	mmc_request_done - finish processing an MMC request
@@ -572,7 +573,13 @@
  */
 static void mmc_power_up(struct mmc_host *host)
 {
-	int bit = fls(host->ocr_avail) - 1;
+	int bit;
+
+	/* If ocr is set, we use it */
+	if (host->ocr)
+		bit = ffs(host->ocr) - 1;
+	else
+		bit = fls(host->ocr_avail) - 1;
 
 	host->ios.vdd = bit;
 	if (mmc_host_is_spi(host)) {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/Kconfig linux-2.6.29-rc3.owrt.om/drivers/mmc/host/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/Kconfig	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -48,6 +48,18 @@
 
 	  If unsure, say N.
 
+config MMC_SDHCI_S3C
+	tristate "SDHCI support on Samsung S3C SoC"
+	depends on MMC_SDHCI && (PLAT_S3C24XX || PLAT_S3C64XX)
+	help
+	  This selects the Secure Digital Host Controller Interface (SDHCI)
+	  often referrered to as the HSMMC block in some of the Samsung S3C
+	  range of SoC.
+
+	  If you have a controller with this interface, say Y or M here.
+
+	  If unsure, say N.
+
 config MMC_RICOH_MMC
 	tristate "Ricoh MMC Controller Disabler  (EXPERIMENTAL)"
 	depends on MMC_SDHCI_PCI
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/Makefile linux-2.6.29-rc3.owrt.om/drivers/mmc/host/Makefile
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/Makefile	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -11,6 +11,7 @@
 obj-$(CONFIG_MMC_IMX)		+= imxmmc.o
 obj-$(CONFIG_MMC_SDHCI)		+= sdhci.o
 obj-$(CONFIG_MMC_SDHCI_PCI)	+= sdhci-pci.o
+obj-$(CONFIG_MMC_SDHCI_S3C)	+= sdhci-s3c.o
 obj-$(CONFIG_MMC_RICOH_MMC)	+= ricoh_mmc.o
 obj-$(CONFIG_MMC_WBSD)		+= wbsd.o
 obj-$(CONFIG_MMC_AU1X)		+= au1xmmc.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/s3cmci.c linux-2.6.29-rc3.owrt.om/drivers/mmc/host/s3cmci.c
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/s3cmci.c	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/s3cmci.c	2009-05-10 22:28:00.000000000 +0200
@@ -2,6 +2,7 @@
  *  linux/drivers/mmc/s3cmci.h - Samsung S3C MCI driver
  *
  *  Copyright (C) 2004-2006 maintech GmbH, Thomas Kleffel <tk@maintech.de>
+ *  Copyright (C) 2007 Harald Welte <laforge@gnumonks.org>
  *
  * Current driver maintained by Ben Dooks and Simtec Electronics
  *  Copyright (C) 2008 Simtec Electronics <ben-linux@fluff.org>
@@ -24,9 +25,18 @@
 
 #include <mach/regs-sdi.h>
 #include <mach/regs-gpio.h>
+#include <mach/hardware.h>
 
 #include <plat/mci.h>
 
+#include <asm/dma.h>
+#include <asm/dma-mapping.h>
+
+#include <asm/io.h>
+#include <mach/regs-gpio.h>
+#include <mach/mci.h>
+#include <mach/dma.h>
+
 #include "s3cmci.h"
 
 #define DRIVER_NAME "s3c-mci"
@@ -47,6 +57,9 @@
 static const int dbgmap_info  = dbg_info | dbg_conf;
 static const int dbgmap_debug = dbg_err | dbg_debug;
 
+static int f_max = -1; /* override maximum frequency limit */
+static int persist; /* keep interface alive across suspend/resume */
+
 #define dbg(host, channels, args...)		  \
 	do {					  \
 	if (dbgmap_err & channels) 		  \
@@ -280,8 +293,11 @@
 		 * an even multiple of 4. */
 		if (fifo >= host->pio_bytes)
 			fifo = host->pio_bytes;
-		else
+		else {
 			fifo -= fifo & 3;
+			if (!fifo)
+				break;
+		}
 
 		host->pio_bytes -= fifo;
 		host->pio_count += fifo;
@@ -353,8 +369,11 @@
 		 * words, so round down to an even multiple of 4. */
 		if (fifo >= host->pio_bytes)
 			fifo = host->pio_bytes;
-		else
+		else {
 			fifo -= fifo & 3;
+			if (!fifo)
+				break;
+		}
 
 		host->pio_bytes -= fifo;
 		host->pio_count += fifo;
@@ -373,7 +392,6 @@
 {
 	struct s3cmci_host *host = (struct s3cmci_host *) data;
 
-
 	disable_irq(host->irq);
 
 	if (host->pio_active == XFER_WRITE)
@@ -614,7 +632,6 @@
 
 	spin_unlock_irqrestore(&host->complete_lock, iflags);
 	return IRQ_HANDLED;
-
 }
 
 /*
@@ -789,12 +806,11 @@
 
 	last_source = source;
 
-	s3c2410_dma_devconfig(host->dma, source, 3,
+	s3c2410_dma_devconfig(host->dma, source,
 			      host->mem->start + host->sdidata);
 
 	if (!setup_ok) {
-		s3c2410_dma_config(host->dma, 4,
-			(S3C2410_DCON_HWTRIG | S3C2410_DCON_CH0_SDI));
+		s3c2410_dma_config(host->dma, 4);
 		s3c2410_dma_set_buffdone_fn(host->dma,
 					    s3cmci_dma_done_callback);
 		s3c2410_dma_setflags(host->dma, S3C2410_DMAF_AUTOSTART);
@@ -1027,6 +1043,7 @@
 			dbg(host, dbg_err, "data prepare error %d\n", res);
 			cmd->error = res;
 			cmd->data->error = res;
+			cmd->data->error = -EIO;
 
 			mmc_request_done(mmc, mrq);
 			return;
@@ -1264,10 +1281,8 @@
 	host->is2440	= is2440;
 
 	host->pdata = pdev->dev.platform_data;
-	if (!host->pdata) {
-		pdev->dev.platform_data = &s3cmci_def_pdata;
+	if (!host->pdata)
 		host->pdata = &s3cmci_def_pdata;
-	}
 
 	spin_lock_init(&host->complete_lock);
 	tasklet_init(&host->pio_tasklet, pio_tasklet, (unsigned long) host);
@@ -1380,6 +1395,18 @@
 	mmc->f_min 	= host->clk_rate / (host->clk_div * 256);
 	mmc->f_max 	= host->clk_rate / host->clk_div;
 
+	if (f_max >= 0) {
+		unsigned f = f_max;
+
+		if (f < mmc->f_min)
+			f = mmc->f_min;
+		if (mmc->f_max > f) {
+			dev_info(&pdev->dev, "f_max lowered from %u to %u Hz\n",
+			    mmc->f_max, f);
+			mmc->f_max = f;
+		}
+	}
+
 	if (host->pdata->ocr_avail)
 		mmc->ocr_avail = host->pdata->ocr_avail;
 
@@ -1492,18 +1519,60 @@
 
 #ifdef CONFIG_PM
 
+static int save_regs(struct mmc_host *mmc)
+{
+	struct s3cmci_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	unsigned from;
+	u32 *to = host->saved;
+
+	mmc_flush_scheduled_work();
+
+	local_irq_save(flags);
+	for (from = S3C2410_SDICON; from != S3C2410_SDIIMSK+4; from += 4)
+		if (from != host->sdidata)
+			*to++ = readl(host->base + from);
+	BUG_ON(to-host->saved != ARRAY_SIZE(host->saved));
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int restore_regs(struct mmc_host *mmc)
+{
+	struct s3cmci_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	unsigned to;
+	u32 *from = host->saved;
+
+	/*
+	 * Before we begin with the necromancy, make sure we don't
+	 * inadvertently start something we'll regret microseconds later.
+	 */
+	from[S3C2410_SDICMDCON - S3C2410_SDICON] = 0;
+
+	local_irq_save(flags);
+	for (to = S3C2410_SDICON; to != S3C2410_SDIIMSK+4; to += 4)
+		if (to != host->sdidata)
+			writel(*from++, host->base + to);
+	BUG_ON(from-host->saved != ARRAY_SIZE(host->saved));
+	local_irq_restore(flags);
+
+	return 0;
+}
+
 static int s3cmci_suspend(struct platform_device *dev, pm_message_t state)
 {
 	struct mmc_host *mmc = platform_get_drvdata(dev);
 
-	return  mmc_suspend_host(mmc, state);
+	return persist ? save_regs(mmc) : mmc_suspend_host(mmc, state);
 }
 
 static int s3cmci_resume(struct platform_device *dev)
 {
 	struct mmc_host *mmc = platform_get_drvdata(dev);
 
-	return mmc_resume_host(mmc);
+	return persist ? restore_regs(mmc) : mmc_resume_host(mmc);
 }
 
 #else /* CONFIG_PM */
@@ -1561,9 +1630,13 @@
 module_init(s3cmci_init);
 module_exit(s3cmci_exit);
 
+module_param(f_max, int, 0644);
+module_param(persist, int, 0644);
+
 MODULE_DESCRIPTION("Samsung S3C MMC/SD Card Interface driver");
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Thomas Kleffel <tk@maintech.de>, Ben Dooks <ben-linux@fluff.org>");
 MODULE_ALIAS("platform:s3c2410-sdi");
 MODULE_ALIAS("platform:s3c2412-sdi");
 MODULE_ALIAS("platform:s3c2440-sdi");
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/s3cmci.h linux-2.6.29-rc3.owrt.om/drivers/mmc/host/s3cmci.h
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/s3cmci.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/s3cmci.h	2009-05-10 22:28:00.000000000 +0200
@@ -8,6 +8,10 @@
  * published by the Free Software Foundation.
  */
 
+
+#include <mach/regs-sdi.h>
+#include <linux/regulator/consumer.h>
+
 /* FIXME: DMA Resource management ?! */
 #define S3CMCI_DMA 0
 
@@ -68,7 +72,16 @@
 	unsigned int		ccnt, dcnt;
 	struct tasklet_struct	pio_tasklet;
 
+	/*
+	 * Here's where we save the registers during suspend. Note that we skip
+	 * SDIDATA, which is at different positions on 2410 and 2440, so
+	 * there's no "+1" in the array size.
+	 */
+	u32			saved[(S3C2410_SDIIMSK-S3C2410_SDICON)/4];
+
 #ifdef CONFIG_CPU_FREQ
 	struct notifier_block	freq_transition;
 #endif
+
+	struct regulator *regulator;
 };
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci.c linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci.c
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci.c	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci.c	2009-05-10 22:28:00.000000000 +0200
@@ -78,6 +78,11 @@
 		readl(host->ioaddr + SDHCI_CAPABILITIES),
 		readl(host->ioaddr + SDHCI_MAX_CURRENT));
 
+	if (host->flags & SDHCI_USE_ADMA)
+		printk(KERN_DEBUG DRIVER_NAME ": ADMA Err: 0x%08x | ADMA Ptr: 0x%08x\n",
+		       readl(host->ioaddr + SDHCI_ADMA_ERROR),
+		       readl(host->ioaddr + SDHCI_ADMA_ADDRESS));
+
 	printk(KERN_DEBUG DRIVER_NAME ": ===========================================\n");
 }
 
@@ -736,6 +741,23 @@
 	writew(mode, host->ioaddr + SDHCI_TRANSFER_MODE);
 }
 
+static void shdci_check_dma_overrun(struct sdhci_host *host, struct mmc_data *data)
+{
+	u32 dma_pos = readl(host->ioaddr + SDHCI_DMA_ADDRESS);
+	u32 dma_start = sg_dma_address(data->sg);
+	u32 dma_end = dma_start + data->sg->length;
+
+	/* Test whether we ended up moving more data than
+	 * was originally requested. */
+
+	if (dma_pos <= dma_end)
+		return;
+
+	printk(KERN_ERR "%s: dma overrun, dma %08x, req %08x..%08x\n",
+	       mmc_hostname(host->mmc), dma_pos,
+	       dma_start, dma_end);
+}
+
 static void sdhci_finish_data(struct sdhci_host *host)
 {
 	struct mmc_data *data;
@@ -749,6 +771,8 @@
 		if (host->flags & SDHCI_USE_ADMA)
 			sdhci_adma_table_post(host, data);
 		else {
+			shdci_check_dma_overrun(host, data);
+
 			dma_unmap_sg(mmc_dev(host->mmc), data->sg,
 				data->sg_len, (data->flags & MMC_DATA_READ) ?
 					DMA_FROM_DEVICE : DMA_TO_DEVICE);
@@ -888,13 +912,18 @@
 
 static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 {
+	if (clock == host->clock)
+		return;
+
+	host->ops->change_clock(host, clock);
+}
+
+void sdhci_change_clock(struct sdhci_host *host, unsigned int clock)
+{
 	int div;
 	u16 clk;
 	unsigned long timeout;
 
-	if (clock == host->clock)
-		return;
-
 	writew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);
 
 	if (clock == 0)
@@ -931,6 +960,8 @@
 	host->clock = clock;
 }
 
+EXPORT_SYMBOL_GPL(sdhci_set_clock);
+
 static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
 {
 	u8 pwr;
@@ -1004,12 +1035,13 @@
 #endif
 
 	host->mrq = mrq;
-
+/*
 	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)
 		|| (host->flags & SDHCI_DEVICE_DEAD)) {
 		host->mrq->cmd->error = -ENOMEDIUM;
 		tasklet_schedule(&host->finish_tasklet);
 	} else
+*/
 		sdhci_send_command(host, mrq->cmd);
 
 	mmiowb();
@@ -1038,6 +1070,9 @@
 		sdhci_init(host);
 	}
 
+	if (host->ops->set_ios)
+		host->ops->set_ios(host, ios);
+
 	sdhci_set_clock(host, ios->clock);
 
 	if (ios->power_mode == MMC_POWER_OFF)
@@ -1141,7 +1176,7 @@
 	host = (struct sdhci_host*)param;
 
 	spin_lock_irqsave(&host->lock, flags);
-
+/*
 	if (!(readl(host->ioaddr + SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)) {
 		if (host->mrq) {
 			printk(KERN_ERR "%s: Card removed during transfer!\n",
@@ -1156,7 +1191,7 @@
 			tasklet_schedule(&host->finish_tasklet);
 		}
 	}
-
+*/
 	spin_unlock_irqrestore(&host->lock, flags);
 
 	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
@@ -1288,11 +1323,24 @@
 	 *       controllers.
 	 */
 	if (host->cmd->flags & MMC_RSP_BUSY) {
+		u32 present;
+
 		if (host->cmd->data)
 			DBG("Cannot wait for busy signal when also "
 				"doing a data transfer");
-		else
+		else if (!(host->quirks & SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY))
 			return;
+
+		/* The Samsung SDHCI does not seem to provide an INT_DATA_END
+		 * when the system goes non-busy, so check the state of the
+		 * transfer by reading SDHCI_PRESENT_STATE to see if the
+		 * controller is ready
+		 */
+
+		present = readl(host->ioaddr + SDHCI_PRESENT_STATE);
+		DBG("busy? present %08x, intstat %08x\n", present, intmask);
+
+		/* fall through and take the SDHCI_INT_RESPONSE */
 	}
 
 	if (intmask & SDHCI_INT_RESPONSE)
@@ -1609,17 +1657,23 @@
 		mmc_dev(host->mmc)->dma_mask = &host->dma_mask;
 	}
 
-	host->max_clk =
-		(caps & SDHCI_CLOCK_BASE_MASK) >> SDHCI_CLOCK_BASE_SHIFT;
+	if (host->ops->get_max_clock)
+		host->max_clk = host->ops->get_max_clock(host);
+	else {
+		host->max_clk =	(caps & SDHCI_CLOCK_BASE_MASK) >> SDHCI_CLOCK_BASE_SHIFT;
+		host->max_clk *= 1000000;
+	}
 	if (host->max_clk == 0) {
 		printk(KERN_ERR "%s: Hardware doesn't specify base clock "
 			"frequency.\n", mmc_hostname(mmc));
 		return -ENODEV;
 	}
-	host->max_clk *= 1000000;
 
-	host->timeout_clk =
-		(caps & SDHCI_TIMEOUT_CLK_MASK) >> SDHCI_TIMEOUT_CLK_SHIFT;
+	if (host->ops->get_timeout_clock)
+		host->timeout_clk = host->ops->get_timeout_clock(host);
+	else
+		host->timeout_clk =
+			(caps & SDHCI_TIMEOUT_CLK_MASK) >> SDHCI_TIMEOUT_CLK_SHIFT;
 	if (host->timeout_clk == 0) {
 		printk(KERN_ERR "%s: Hardware doesn't specify timeout clock "
 			"frequency.\n", mmc_hostname(mmc));
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci.h linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci.h
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci.h	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci.h	2009-05-10 22:28:00.000000000 +0200
@@ -57,6 +57,7 @@
 #define  SDHCI_DATA_AVAILABLE	0x00000800
 #define  SDHCI_CARD_PRESENT	0x00010000
 #define  SDHCI_WRITE_PROTECT	0x00080000
+#define  SDHCI_DATA_BIT(x)	(1 << ((x) + 20))
 
 #define SDHCI_HOST_CONTROL 	0x28
 #define  SDHCI_CTRL_LED		0x01
@@ -210,6 +211,8 @@
 #define SDHCI_QUIRK_BROKEN_SMALL_PIO			(1<<13)
 /* Controller supports high speed but doesn't have the caps bit set */
 #define SDHCI_QUIRK_FORCE_HIGHSPEED			(1<<14)
+/* Controller does not provide transfer-complete interrupt when not busy */
+#define SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY		(1<<15)
 
 	int			irq;		/* Device IRQ */
 	void __iomem *		ioaddr;		/* Mapped address */
@@ -267,6 +270,14 @@
 
 struct sdhci_ops {
 	int		(*enable_dma)(struct sdhci_host *host);
+	unsigned int	(*get_max_clock)(struct sdhci_host *host);
+	unsigned int	(*get_timeout_clock)(struct sdhci_host *host);
+
+	void		(*change_clock)(struct sdhci_host *host,
+					unsigned int clock);
+
+	void		(*set_ios)(struct sdhci_host *host,
+				   struct mmc_ios *ios);
 };
 
 
@@ -274,6 +285,8 @@
 	size_t priv_size);
 extern void sdhci_free_host(struct sdhci_host *host);
 
+extern void sdhci_change_clock(struct sdhci_host *host, unsigned int clock);
+
 static inline void *sdhci_priv(struct sdhci_host *host)
 {
 	return (void *)host->private;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci-pci.c linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci-pci.c
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci-pci.c	2009-05-10 22:08:43.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci-pci.c	2009-05-10 22:28:00.000000000 +0200
@@ -391,6 +391,7 @@
 
 static struct sdhci_ops sdhci_pci_ops = {
 	.enable_dma	= sdhci_pci_enable_dma,
+	.change_clock	= sdhci_change_clock,
 };
 
 /*****************************************************************************\
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci-s3c.c linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci-s3c.c
--- linux-2.6.29-rc3.owrt/drivers/mmc/host/sdhci-s3c.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/mmc/host/sdhci-s3c.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,419 @@
+/* linux/drivers/mmc/host/sdhci-s3c.c
+ *
+ * Copyright 2008 Openmoko Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * SDHCI (HSMMC) support for Samsung SoC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <linux/mmc/host.h>
+
+#include <plat/regs-sdhci.h>
+#include <plat/sdhci.h>
+
+#include "sdhci.h"
+
+#define MAX_BUS_CLK	(4)
+
+struct sdhci_s3c {
+	struct sdhci_host	*host;
+	struct platform_device	*pdev;
+	struct resource		*ioarea;
+	struct s3c_sdhci_platdata *pdata;
+	unsigned int		cur_clk;
+
+	struct clk		*clk_io;	/* clock for io bus */
+	struct clk		*clk_bus[MAX_BUS_CLK];
+};
+
+static inline struct sdhci_s3c *to_s3c(struct sdhci_host *host)
+{
+	return sdhci_priv(host);
+}
+
+static u32 get_curclk(u32 ctrl2)
+{
+	ctrl2 &= S3C_SDHCI_CTRL2_SELBASECLK_MASK;
+	ctrl2 >>= S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+
+	return ctrl2;
+}
+
+static void sdhci_s3c_check_sclk(struct sdhci_host *host)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	u32 tmp = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
+
+	if (get_curclk(tmp) != ourhost->cur_clk) {
+		dev_dbg(&ourhost->pdev->dev, "restored ctrl2 clock setting\n");
+
+		tmp &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;
+		tmp |= ourhost->cur_clk << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+		writel(tmp, host->ioaddr + 0x80);
+	}
+}
+
+static unsigned int sdhci_s3c_get_max_clk(struct sdhci_host *host)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	struct clk *busclk;
+	unsigned int rate, max;
+	int clk;
+
+	/* note, a reset will reset the clock source */
+
+	sdhci_s3c_check_sclk(host);
+
+	for (max = 0, clk = 0; clk < MAX_BUS_CLK; clk++) {
+		busclk = ourhost->clk_bus[clk];
+		if (!busclk)
+			continue;
+
+		rate = clk_get_rate(busclk);
+		if (rate > max)
+			max = rate;
+	}
+
+	return max;
+}
+
+static unsigned int sdhci_s3c_get_timeout_clk(struct sdhci_host *host)
+{
+	return sdhci_s3c_get_max_clk(host) / 1000000;
+}
+
+static void sdhci_s3c_set_ios(struct sdhci_host *host,
+			      struct mmc_ios *ios)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	struct s3c_sdhci_platdata *pdata = ourhost->pdata;
+	int width;
+
+	sdhci_s3c_check_sclk(host);
+
+	if (ios->power_mode != MMC_POWER_OFF) {
+		switch (ios->bus_width) {
+		case MMC_BUS_WIDTH_4:
+			width = 4;
+			break;
+		case MMC_BUS_WIDTH_1:
+			width = 1;
+			break;
+		default:
+			BUG();
+		}
+
+		if (pdata->cfg_gpio)
+			pdata->cfg_gpio(ourhost->pdev, width);
+	}
+
+	if (pdata->cfg_card)
+		pdata->cfg_card(ourhost->pdev, host->ioaddr,
+				ios, host->mmc->card);
+}
+
+static unsigned int sdhci_s3c_consider_clock(struct sdhci_s3c *ourhost,
+					     unsigned int src,
+					     unsigned int wanted)
+{
+	unsigned long rate;
+	struct clk *clksrc = ourhost->clk_bus[src];
+	int div;
+
+	if (!clksrc)
+		return UINT_MAX;
+
+	rate = clk_get_rate(clksrc);
+
+	for (div = 1; div < 256; div *= 2) {
+		if ((rate / div) <= wanted)
+			break;
+	}
+
+	dev_dbg(&ourhost->pdev->dev, "clk %d: rate %ld, want %d, got %ld\n",
+		src, rate, wanted, rate / div);
+
+	return (wanted - (rate / div));
+}
+
+static void sdhci_s3c_change_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct sdhci_s3c *ourhost = to_s3c(host);
+	unsigned int best = UINT_MAX;
+	unsigned int delta;
+	int best_src = 0;
+	int src;
+	u32 ctrl;
+
+	for (src = 0; src < MAX_BUS_CLK; src++) {
+		delta = sdhci_s3c_consider_clock(ourhost, src, clock);
+		if (delta < best) {
+			best = delta;
+			best_src = src;
+		}
+	}
+
+	dev_dbg(&ourhost->pdev->dev,
+		"selected source %d, clock %d, delta %d\n",
+		 best_src, clock, best);
+
+	/* turn clock off to card before changing clock source */
+	writew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);
+
+	/* select the new clock source */
+
+	if (ourhost->cur_clk != best_src) {
+		struct clk *clk = ourhost->clk_bus[best_src];
+
+		ourhost->cur_clk = best_src;
+		host->max_clk = clk_get_rate(clk);
+		host->timeout_clk = host->max_clk / 1000000;
+
+		ctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);
+		ctrl &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;
+		ctrl |= best_src << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;
+		writel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);
+	}
+
+	sdhci_change_clock(host, clock);
+}
+
+static struct sdhci_ops sdhci_s3c_ops = {
+	.get_max_clock		= sdhci_s3c_get_max_clk,
+	.get_timeout_clock	= sdhci_s3c_get_timeout_clk,
+	.change_clock		= sdhci_s3c_change_clock,
+	.set_ios		= sdhci_s3c_set_ios,
+};
+
+/*
+ * call this when you need sd stack to recognize insertion or removal of card
+ * that can't be told by SDHCI regs
+ */
+
+void sdhci_s3c_force_presence_change(struct platform_device *pdev)
+{
+	struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+
+	dev_info(&pdev->dev, "sdhci_s3c_force_presence_change called\n");
+	mmc_detect_change(pdata->sdhci_host->mmc, msecs_to_jiffies(200));
+}
+EXPORT_SYMBOL_GPL(sdhci_s3c_force_presence_change);
+
+
+static int __devinit sdhci_s3c_probe(struct platform_device *pdev)
+{
+	struct s3c_sdhci_platdata *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct sdhci_host *host;
+	struct sdhci_s3c *sc;
+	struct resource *res;
+	int ret, irq, ptr, clks;
+
+	if (!pdata) {
+		dev_err(dev, "no device data specified\n");
+		return -ENOENT;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(dev, "no irq specified\n");
+		return irq;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "no memory specified\n");
+		return -ENOENT;
+	}
+
+	host = sdhci_alloc_host(dev, sizeof(struct sdhci_s3c));
+	if (IS_ERR(host)) {
+		dev_err(dev, "sdhci_alloc_host() failed\n");
+		return PTR_ERR(host);
+	}
+
+	pdata->sdhci_host = host;
+
+	sc = sdhci_priv(host);
+
+	sc->host = host;
+	sc->pdev = pdev;
+	sc->pdata = pdata;
+
+	platform_set_drvdata(pdev, host);
+
+	sc->clk_io = clk_get(dev, "hsmmc");
+	if (IS_ERR(sc->clk_io)) {
+		dev_err(dev, "failed to get io clock\n");
+		ret = PTR_ERR(sc->clk_io);
+		goto err_io_clk;
+	}
+
+	/* enable the local io clock and keep it running for the moment. */
+	clk_enable(sc->clk_io);
+
+	for (clks = 0, ptr = 0; ptr < MAX_BUS_CLK; ptr++) {
+		struct clk *clk;
+		char *name = pdata->clocks[ptr];
+
+		if (name == NULL)
+			continue;
+
+		clk = clk_get(dev, name);
+		if (IS_ERR(clk)) {
+			dev_err(dev, "failed to get clock %s\n", name);
+			continue;
+		}
+
+		clks++;
+		sc->clk_bus[ptr] = clk;
+		clk_enable(clk);
+
+		dev_info(dev, "clock source %d: %s (%ld Hz)\n",
+			 ptr, name, clk_get_rate(clk));
+	}
+
+	if (clks == 0) {
+		dev_err(dev, "failed to find any bus clocks\n");
+		ret = -ENOENT;
+		goto err_no_busclks;
+	}
+
+	sc->ioarea = request_mem_region(res->start, resource_size(res),
+					mmc_hostname(host->mmc));
+	if (!sc->ioarea) {
+		dev_err(dev, "failed to reserve register area\n");
+		ret = -ENXIO;
+		goto err_req_regs;
+	}
+
+	host->ioaddr = ioremap_nocache(res->start, resource_size(res));
+	if (!host->ioaddr) {
+		dev_err(dev, "failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_regs;
+	}
+
+	/* Ensure we have minimal gpio selected CMD/CLK/Detect */
+	if (pdata->cfg_gpio)
+		pdata->cfg_gpio(pdev, 0);
+
+	sdhci_s3c_check_sclk(host);
+
+	host->hw_name = "samsung-hsmmc";
+	host->ops = &sdhci_s3c_ops;
+	host->quirks = 0;
+	host->irq = irq;
+
+	/* Setup quirks for the controller */
+
+	/* Currently with ADMA enabled we are getting some length
+	 * interrupts that are not being dealt with, do disable
+	 * ADMA until this is sorted out. */
+	host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;
+	host->quirks |= SDHCI_QUIRK_32BIT_ADMA_SIZE;
+
+	/* It seems we do not get an DATA transfer complete on non-busy
+	 * transfers, not sure if this is a problem with this specific
+	 * SDHCI block, or a missing configuration that needs to be set. */
+	host->quirks |= SDHCI_QUIRK_NO_TCIRQ_ON_NOT_BUSY;
+
+	host->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |
+			 SDHCI_QUIRK_32BIT_DMA_SIZE);
+
+	ret = sdhci_add_host(host);
+	if (ret) {
+		dev_err(dev, "sdhci_add_host() failed\n");
+		goto err_add_host;
+	}
+
+	return 0;
+
+ err_add_host:
+	release_resource(sc->ioarea);
+	kfree(sc->ioarea);
+
+ err_req_regs:
+	for (ptr = 0; ptr < MAX_BUS_CLK; ptr++) {
+		clk_disable(sc->clk_bus[ptr]);
+		clk_put(sc->clk_bus[ptr]);
+	}
+
+ err_no_busclks:
+	clk_disable(sc->clk_io);
+	clk_put(sc->clk_io);
+
+ err_io_clk:
+	sdhci_free_host(host);
+
+	return ret;
+}
+
+static int __devexit sdhci_s3c_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int sdhci_s3c_suspend(struct platform_device *dev, pm_message_t pm)
+{
+	struct sdhci_host *host = platform_get_drvdata(dev);
+
+	sdhci_suspend_host(host, pm);
+	return 0;
+}
+
+static int sdhci_s3c_resume(struct platform_device *dev)
+{
+	struct sdhci_host *host = platform_get_drvdata(dev);
+
+	sdhci_resume_host(host);
+	return 0;
+}
+
+#else
+#define sdhci_s3c_suspend NULL
+#define sdhci_s3c_resume NULL
+#endif
+
+static struct platform_driver sdhci_s3c_driver = {
+	.probe		= sdhci_s3c_probe,
+	.remove		= __devexit_p(sdhci_s3c_remove),
+	.suspend	= sdhci_s3c_suspend,
+	.resume	        = sdhci_s3c_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-sdhci",
+	},
+};
+
+static int __init sdhci_s3c_init(void)
+{
+	return platform_driver_register(&sdhci_s3c_driver);
+}
+
+static void __exit sdhci_s3c_exit(void)
+{
+	platform_driver_unregister(&sdhci_s3c_driver);
+}
+
+module_init(sdhci_s3c_init);
+module_exit(sdhci_s3c_exit);
+
+MODULE_DESCRIPTION("Samsung SDHCI (HSMMC) glue");
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:s3c-sdhci");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/mtd/nand/s3c2410.c linux-2.6.29-rc3.owrt.om/drivers/mtd/nand/s3c2410.c
--- linux-2.6.29-rc3.owrt/drivers/mtd/nand/s3c2410.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/mtd/nand/s3c2410.c	2009-05-10 22:28:00.000000000 +0200
@@ -231,8 +231,6 @@
 		BUG();
 	}
 
-	dev_dbg(info->device, "NF_CONF is 0x%lx\n", cfg);
-
 	local_irq_save(flags);
 
 	cfg = readl(info->regs + S3C2410_NFCONF);
@@ -240,6 +238,8 @@
 	cfg |= set;
 	writel(cfg, info->regs + S3C2410_NFCONF);
 
+	dev_dbg(info->device, "NF_CONF is 0x%lx\n", cfg);
+
 	local_irq_restore(flags);
 
 	return 0;
@@ -438,7 +438,7 @@
 	if ((diff0 & ~(1<<fls(diff0))) == 0)
 		return 1;
 
-	return -1;
+	return -EBADMSG;
 }
 
 /* ECC functions
@@ -530,7 +530,12 @@
 static void s3c2440_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
 {
 	struct s3c2410_nand_info *info = s3c2410_nand_mtd_toinfo(mtd);
+	u8 *ptr = buf + (len & ~3);
+	int i;
+
 	readsl(info->regs + S3C2440_NFDATA, buf, len / 4);
+	for (i = 0; i != (len & 3); i++)
+		ptr[i] = readb(info->regs + S3C2440_NFDATA);
 }
 
 static void s3c2410_nand_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
@@ -645,17 +650,31 @@
 }
 
 #ifdef CONFIG_MTD_PARTITIONS
+const char *part_probes[] = { "cmdlinepart", NULL };
 static int s3c2410_nand_add_partition(struct s3c2410_nand_info *info,
 				      struct s3c2410_nand_mtd *mtd,
 				      struct s3c2410_nand_set *set)
 {
+	struct mtd_partition *part_info;
+	int nr_part = 0;
+
 	if (set == NULL)
 		return add_mtd_device(&mtd->mtd);
 
-	if (set->nr_partitions > 0 && set->partitions != NULL) {
-		return add_mtd_partitions(&mtd->mtd, set->partitions, set->nr_partitions);
+	if (set->nr_partitions == 0) {
+		mtd->mtd.name = set->name;
+		nr_part = parse_mtd_partitions(&mtd->mtd, part_probes,
+						&part_info, 0);
+	} else {
+		if (set->nr_partitions > 0 && set->partitions != NULL) {
+			nr_part = set->nr_partitions;
+			part_info = set->partitions;
+		}
 	}
 
+	if (nr_part > 0 && part_info)
+		return add_mtd_partitions(&mtd->mtd, part_info, nr_part);
+
 	return add_mtd_device(&mtd->mtd);
 }
 #else
@@ -684,9 +703,13 @@
 	chip->select_chip  = s3c2410_nand_select_chip;
 	chip->chip_delay   = 50;
 	chip->priv	   = nmtd;
-	chip->options	   = 0;
 	chip->controller   = &info->controller;
 
+	if (set->flags & S3C2410_NAND_BBT)
+		chip->options	   = NAND_USE_FLASH_BBT;
+	else
+		chip->options	   = 0;
+
 	switch (info->cpu_type) {
 	case TYPE_S3C2410:
 		chip->IO_ADDR_W = regs + S3C2410_NFDATA;
@@ -726,7 +749,7 @@
 	nmtd->mtd.owner    = THIS_MODULE;
 	nmtd->set	   = set;
 
-	if (hardware_ecc) {
+	if (!info->platform->software_ecc && hardware_ecc) {
 		chip->ecc.calculate = s3c2410_nand_calculate_ecc;
 		chip->ecc.correct   = s3c2410_nand_correct_data;
 		chip->ecc.mode	    = NAND_ECC_HW;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/net/ppp_deflate.c linux-2.6.29-rc3.owrt.om/drivers/net/ppp_deflate.c
--- linux-2.6.29-rc3.owrt/drivers/net/ppp_deflate.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/net/ppp_deflate.c	2009-05-10 22:28:00.000000000 +0200
@@ -306,7 +306,7 @@
 
 	if (state) {
 		zlib_inflateEnd(&state->strm);
-		kfree(state->strm.workspace);
+		vfree(state->strm.workspace);
 		kfree(state);
 	}
 }
@@ -346,8 +346,7 @@
 
 	state->w_size         = w_size;
 	state->strm.next_out  = NULL;
-	state->strm.workspace = kmalloc(zlib_inflate_workspacesize(),
-					GFP_KERNEL|__GFP_REPEAT);
+	state->strm.workspace = vmalloc(zlib_inflate_workspacesize());
 	if (state->strm.workspace == NULL)
 		goto out_free;
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/net/wireless/libertas/if_sdio.c linux-2.6.29-rc3.owrt.om/drivers/net/wireless/libertas/if_sdio.c
--- linux-2.6.29-rc3.owrt/drivers/net/wireless/libertas/if_sdio.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/net/wireless/libertas/if_sdio.c	2009-05-10 22:28:00.000000000 +0200
@@ -49,6 +49,7 @@
 
 static const struct sdio_device_id if_sdio_ids[] = {
 	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_LIBERTAS) },
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_88W8688) },
 	{ /* end: all zeroes */						},
 };
 
@@ -73,7 +74,12 @@
 		.helper = "sd8686_helper.bin",
 		.firmware = "sd8686.bin",
 	},
-};
+	{
+		/* 8688 */
+		.model = 0x10,
+		.helper = "sd8688_helper.bin",
+		.firmware = "sd8688.bin",
+	},};
 
 struct if_sdio_packet {
 	struct if_sdio_packet	*next;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/pnp/Kconfig linux-2.6.29-rc3.owrt.om/drivers/pnp/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/pnp/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/pnp/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -5,7 +5,7 @@
 menuconfig PNP
 	bool "Plug and Play support"
 	depends on HAS_IOMEM
-	depends on ISA || ACPI
+	depends on ISA || ACPI || SDIO
 	---help---
 	  Plug and Play (PnP) is a standard for peripherals which allows those
 	  peripherals to be configured by software, e.g. assign IRQ's or other
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/pnp/resource.c linux-2.6.29-rc3.owrt.om/drivers/pnp/resource.c
--- linux-2.6.29-rc3.owrt/drivers/pnp/resource.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/pnp/resource.c	2009-05-10 22:28:00.000000000 +0200
@@ -436,6 +436,7 @@
 		}
 	}
 
+#if 0
 	/* check if the resource is already in use, skip if the
 	 * device is active because it itself may be in use */
 	if (!dev->active) {
@@ -443,6 +444,7 @@
 			return 0;
 		free_dma(*dma);
 	}
+#endif
 
 	/* check for conflicts with other pnp devices */
 	pnp_for_each_dev(tdev) {
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/bq27000_battery.c linux-2.6.29-rc3.owrt.om/drivers/power/bq27000_battery.c
--- linux-2.6.29-rc3.owrt/drivers/power/bq27000_battery.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/power/bq27000_battery.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,474 @@
+/*
+ * Driver for batteries with bq27000 chips inside via HDQ
+ *
+ * Copyright 2008 Openmoko, Inc
+ * Andy Green <andy@openmoko.com>
+ *
+ * based on ds2760 driver, original copyright notice for that --->
+ *
+ * Copyright  2007 Anton Vorontsov
+ *	       2004-2007 Matt Reimer
+ *	       2004 Szabolcs Gyurko
+ *
+ * Use consistent with the GNU GPL is permitted,
+ * provided that this copyright notice is
+ * preserved in its entirety in all copies and derived works.
+ *
+ * Author:  Anton Vorontsov <cbou@mail.ru>
+ *	    February 2007
+ *
+ *	    Matt Reimer <mreimer@vpop.net>
+ *	    April 2004, 2005, 2007
+ *
+ *	    Szabolcs Gyurko <szabolcs.gyurko@tlt.hu>
+ *	    September 2004
+ */
+
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/bq27000_battery.h>
+
+enum bq27000_regs {
+	/* RAM regs */
+		/* read-write after this */
+	BQ27000_CTRL = 0, /* Device Control Register */
+	BQ27000_MODE, /* Device Mode Register */
+	BQ27000_AR_L, /* At-Rate H L */
+	BQ27000_AR_H,
+		/* read-only after this */
+	BQ27000_ARTTE_L, /* At-Rate Time To Empty H L */
+	BQ27000_ARTTE_H,
+	BQ27000_TEMP_L, /* Reported Temperature H L */
+	BQ27000_TEMP_H,
+	BQ27000_VOLT_L, /* Reported Voltage H L */
+	BQ27000_VOLT_H,
+	BQ27000_FLAGS, /* Status Flags */
+	BQ27000_RSOC, /* Relative State of Charge */
+	BQ27000_NAC_L, /* Nominal Available Capacity H L */
+	BQ27000_NAC_H,
+	BQ27000_CACD_L, /* Discharge Compensated H L */
+	BQ27000_CACD_H,
+	BQ27000_CACT_L, /* Temperature Compensated H L */
+	BQ27000_CACT_H,
+	BQ27000_LMD_L, /* Last measured discharge H L */
+	BQ27000_LMD_H,
+	BQ27000_AI_L, /* Average Current H L */
+	BQ27000_AI_H,
+	BQ27000_TTE_L, /* Time to Empty H L */
+	BQ27000_TTE_H,
+	BQ27000_TTF_L, /* Time to Full H L */
+	BQ27000_TTF_H,
+	BQ27000_SI_L, /* Standby Current H L */
+	BQ27000_SI_H,
+	BQ27000_STTE_L, /* Standby Time To Empty H L */
+	BQ27000_STTE_H,
+	BQ27000_MLI_L, /* Max Load Current H L */
+	BQ27000_MLI_H,
+	BQ27000_MLTTE_L, /* Max Load Time To Empty H L */
+	BQ27000_MLTTE_H,
+	BQ27000_SAE_L, /* Available Energy H L */
+	BQ27000_SAE_H,
+	BQ27000_AP_L, /* Available Power H L */
+	BQ27000_AP_H,
+	BQ27000_TTECP_L, /* Time to Empty at Constant Power H L */
+	BQ27000_TTECP_H,
+	BQ27000_CYCL_L, /* Cycle count since learning cycle H L */
+	BQ27000_CYCL_H,
+	BQ27000_CYCT_L, /* Cycle Count Total H L */
+	BQ27000_CYCT_H,
+	BQ27000_CSOC, /* Compensated State Of Charge */
+	/* EEPROM regs */
+		/* read-write after this */
+	BQ27000_EE_EE_EN = 0x6e, /* EEPROM Program Enable */
+	BQ27000_EE_ILMD = 0x76, /* Initial Last Measured Discharge High Byte */
+	BQ27000_EE_SEDVF, /* Scaled EDVF Threshold */
+	BQ27000_EE_SEDV1, /* Scaled EDV1 Threshold */
+	BQ27000_EE_ISLC, /* Initial Standby Load Current */
+	BQ27000_EE_DMFSD, /* Digital Magnitude Filter and Self Discharge */
+	BQ27000_EE_TAPER, /* Aging Estimate Enable, Charge Termination Taper */
+	BQ27000_EE_PKCFG, /* Pack Configuration Values */
+	BQ27000_EE_IMLC, /* Initial Max Load Current or ID #3 */
+	BQ27000_EE_DCOMP, /* Discharge rate compensation constants or ID #2 */
+	BQ27000_EE_TCOMP, /* Temperature Compensation constants or ID #1 */
+};
+
+enum bq27000_status_flags {
+	BQ27000_STATUS_CHGS = 0x80, /* 1 = being charged */
+	BQ27000_STATUS_NOACT = 0x40, /* 1 = no activity */
+	BQ27000_STATUS_IMIN = 0x20, /* 1 = Lion taper current mode */
+	BQ27000_STATUS_CI = 0x10, /* 1 = capacity likely  innacurate */
+	BQ27000_STATUS_CALIP = 0x08, /* 1 = calibration in progress */
+	BQ27000_STATUS_VDQ = 0x04, /* 1 = capacity should be accurate */
+	BQ27000_STATUS_EDV1 = 0x02, /* 1 = end of discharge.. <6% left */
+	BQ27000_STATUS_EDVF = 0x01, /* 1 = no, it's really empty now */
+};
+
+#define NANOVOLTS_UNIT 3750
+
+struct bq27000_bat_regs {
+	int		ai;
+	int		flags;
+	int		lmd;
+	int		rsoc;
+	int		temp;
+	int		tte;
+	int		ttf;
+	int		volt;
+};
+
+struct bq27000_device_info {
+	struct device *dev;
+	struct power_supply bat;
+	struct power_supply ac;
+	struct power_supply usb;
+	struct delayed_work work;
+	struct bq27000_platform_data *pdata;
+
+	struct bq27000_bat_regs regs;
+};
+
+static unsigned int cache_time = 5000;
+module_param(cache_time, uint, 0644);
+MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
+
+/*
+ * reading 16 bit values over HDQ has a special hazard where the
+ * hdq device firmware can update the 16-bit register during the time we
+ * read the two halves.  TI document SLUS556D recommends the algorithm here
+ * to avoid trouble
+ */
+
+static int hdq_read16(struct bq27000_device_info *di, int address)
+{
+	int acc;
+	int high;
+	int retries = 3;
+
+	while (retries--) {
+
+		high = (di->pdata->hdq_read)(address + 1); /* high part */
+
+		if (high < 0)
+			return high;
+		acc = (di->pdata->hdq_read)(address);
+		if (acc < 0)
+			return acc;
+
+		/* confirm high didn't change between reading it and low */
+		if (high == (di->pdata->hdq_read)(address + 1))
+			return (high << 8) | acc;
+	}
+
+	return -ETIME;
+}
+
+static void bq27000_battery_external_power_changed(struct power_supply *psy)
+{
+	struct bq27000_device_info *di = container_of(psy, struct bq27000_device_info, bat);
+
+	dev_dbg(di->dev, "%s\n", __FUNCTION__);
+	schedule_delayed_work(&di->work, 0);
+}
+
+static int bq27000_battery_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
+{
+	int n;
+	struct bq27000_device_info *di = container_of(psy, struct bq27000_device_info, bat);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+
+		if (!di->pdata->get_charger_online_status)
+			goto use_bat;
+		if ((di->pdata->get_charger_online_status)()) {
+			/*
+			 * charger is definitively present
+			 * we report our state in terms of what it says it
+			 * is doing
+			 */
+			if (!di->pdata->get_charger_active_status)
+				goto use_bat;
+
+			if ((di->pdata->get_charger_active_status)()) {
+				val->intval = POWER_SUPPLY_STATUS_CHARGING;
+				break;
+			}
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		}
+
+		/*
+		 * platform provided definite indication of charger presence,
+		 * and it is telling us it isn't there... but we are on so we
+		 * must be running from battery --->
+		 */
+
+		val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+
+use_bat:
+		/*
+		 * either the charger is not connected, or the
+		 * platform doesn't give info about charger, use battery state
+		 * but... battery state can be out of date by 4 seconds or
+		 * so... use the platform callbacks if possible.
+		 */
+
+		/* no real activity on the battery */
+		if (di->regs.ai < 2) {
+			if (!di->regs.ttf)
+				val->intval = POWER_SUPPLY_STATUS_FULL;
+			else
+				val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+			break;
+		}
+		/* power is actually going in or out... */
+		if (di->regs.flags < 0)
+			return di->regs.flags;
+		if (di->regs.flags & BQ27000_STATUS_CHGS)
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_UNKNOWN;
+		/* Do we have accurate readings... */
+		if (di->regs.flags < 0)
+			return di->regs.flags;
+		if (di->regs.flags & BQ27000_STATUS_VDQ)
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		if (di->regs.volt < 0)
+			return di->regs.volt;
+		/* mV -> uV */
+		val->intval = di->regs.volt * 1000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		if (di->regs.flags < 0)
+			return di->regs.flags;
+		if (di->regs.flags & BQ27000_STATUS_CHGS)
+			n = -NANOVOLTS_UNIT;
+		else
+			n = NANOVOLTS_UNIT;
+		if (di->regs.ai < 0)
+			return di->regs.ai;
+		val->intval = (di->regs.ai * n) / di->pdata->rsense_mohms;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		if (di->regs.lmd < 0)
+			return di->regs.lmd;
+		val->intval = (di->regs.lmd * 3570) / di->pdata->rsense_mohms;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		if (di->regs.temp < 0)
+			return di->regs.temp;
+		/* K (in 0.25K units) is 273.15 up from C (in 0.1C)*/
+		/* 10926 = 27315 * 4 / 10 */
+		val->intval = (((long)di->regs.temp * 10l) - 10926) / 4;
+		break;
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = di->regs.rsoc;
+		if (val->intval < 0)
+			return val->intval;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = !(di->regs.rsoc < 0);
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		if (di->regs.tte < 0)
+			return di->regs.tte;
+		val->intval = 60 * di->regs.tte;
+		break;
+	case POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:
+		if (di->regs.ttf < 0)
+			return di->regs.ttf;
+		val->intval = 60 * di->regs.ttf;
+		break;
+	case POWER_SUPPLY_PROP_ONLINE:
+		if (di->pdata->get_charger_online_status)
+			val->intval = (di->pdata->get_charger_online_status)();
+		else
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void bq27000_battery_work(struct work_struct *work)
+{
+	struct bq27000_device_info *di =
+		container_of(work, struct bq27000_device_info, work.work);
+
+	if ((di->pdata->hdq_initialized)()) {
+		struct bq27000_bat_regs regs;
+
+		regs.ai    = hdq_read16(di, BQ27000_AI_L);
+		regs.flags = (di->pdata->hdq_read)(BQ27000_FLAGS);
+		regs.lmd   = hdq_read16(di, BQ27000_LMD_L);
+		regs.rsoc  = (di->pdata->hdq_read)(BQ27000_RSOC);
+		regs.temp  = hdq_read16(di, BQ27000_TEMP_L);
+		regs.tte   = hdq_read16(di, BQ27000_TTE_L);
+		regs.ttf   = hdq_read16(di, BQ27000_TTF_L);
+		regs.volt  = hdq_read16(di, BQ27000_VOLT_L);
+
+		if (memcmp (&regs, &di->regs, sizeof(regs)) != 0) {
+			di->regs = regs;
+			power_supply_changed(&di->bat);
+		}
+	}
+
+	if (!schedule_delayed_work(&di->work, cache_time))
+		dev_err(di->dev, "battery service reschedule failed\n");
+}
+
+static enum power_supply_property bq27000_battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW,
+	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_ONLINE
+};
+
+static int bq27000_battery_probe(struct platform_device *pdev)
+{
+	int retval = 0;
+	struct bq27000_device_info *di;
+	struct bq27000_platform_data *pdata;
+
+	dev_info(&pdev->dev, "BQ27000 Battery Driver (C) 2008 Openmoko, Inc\n");
+
+	di = kzalloc(sizeof(*di), GFP_KERNEL);
+	if (!di) {
+		retval = -ENOMEM;
+		goto di_alloc_failed;
+	}
+
+	platform_set_drvdata(pdev, di);
+
+	pdata = pdev->dev.platform_data;
+	di->dev		= &pdev->dev;
+	/* di->w1_dev	     = pdev->dev.parent; */
+	di->bat.name	   = pdata->name;
+	di->bat.type	   = POWER_SUPPLY_TYPE_BATTERY;
+	di->bat.properties     = bq27000_battery_props;
+	di->bat.num_properties = ARRAY_SIZE(bq27000_battery_props);
+	di->bat.get_property   = bq27000_battery_get_property;
+	di->bat.external_power_changed =
+				  bq27000_battery_external_power_changed;
+	di->bat.use_for_apm = 1;
+	di->pdata = pdata;
+
+	retval = power_supply_register(&pdev->dev, &di->bat);
+	if (retval) {
+		dev_err(di->dev, "failed to register battery\n");
+		goto batt_failed;
+	}
+
+	INIT_DELAYED_WORK(&di->work, bq27000_battery_work);
+
+	if (!schedule_delayed_work(&di->work, 0))
+		dev_err(di->dev, "failed to schedule bq27000_battery_work\n");
+
+	return 0;
+
+batt_failed:
+	kfree(di);
+di_alloc_failed:
+	return retval;
+}
+
+static int bq27000_battery_remove(struct platform_device *pdev)
+{
+	struct bq27000_device_info *di = platform_get_drvdata(pdev);
+
+	cancel_delayed_work(&di->work);
+
+	power_supply_unregister(&di->bat);
+
+	return 0;
+}
+
+void bq27000_charging_state_change(struct platform_device *pdev)
+{
+	struct bq27000_device_info *di = platform_get_drvdata(pdev);
+
+	if (!di)
+	    return;
+}
+EXPORT_SYMBOL_GPL(bq27000_charging_state_change);
+
+#ifdef CONFIG_PM
+
+static int bq27000_battery_suspend(struct platform_device *pdev,
+				  pm_message_t state)
+{
+	struct bq27000_device_info *di = platform_get_drvdata(pdev);
+
+	cancel_delayed_work(&di->work);
+	return 0;
+}
+
+static int bq27000_battery_resume(struct platform_device *pdev)
+{
+	struct bq27000_device_info *di = platform_get_drvdata(pdev);
+
+	schedule_delayed_work(&di->work, 0);
+	return 0;
+}
+
+#else
+
+#define bq27000_battery_suspend NULL
+#define bq27000_battery_resume NULL
+
+#endif /* CONFIG_PM */
+
+static struct platform_driver bq27000_battery_driver = {
+	.driver = {
+		.name = "bq27000-battery",
+	},
+	.probe	  = bq27000_battery_probe,
+	.remove   = bq27000_battery_remove,
+	.suspend  = bq27000_battery_suspend,
+	.resume	  = bq27000_battery_resume,
+};
+
+static int __init bq27000_battery_init(void)
+{
+	return platform_driver_register(&bq27000_battery_driver);
+}
+
+static void __exit bq27000_battery_exit(void)
+{
+	platform_driver_unregister(&bq27000_battery_driver);
+}
+
+module_init(bq27000_battery_init);
+module_exit(bq27000_battery_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("bq27000 battery driver");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/gta01_battery.c linux-2.6.29-rc3.owrt.om/drivers/power/gta01_battery.c
--- linux-2.6.29-rc3.owrt/drivers/power/gta01_battery.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/power/gta01_battery.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,117 @@
+/*
+ * Dumb driver for gta01 battery
+ *
+ * Copyright 2009 Openmoko, Inc
+ * Balaji Rao <balajirrao@openmoko.org>
+ */
+
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/gta01_battery.h>
+
+struct gta01_battery {
+	struct power_supply psy;
+	struct gta01_bat_platform_data *pdata;
+};
+
+static enum power_supply_property gta01_bat_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+};
+
+static int gta01_bat_get_property(struct power_supply *psy,
+				       enum power_supply_property psp,
+				       union power_supply_propval *val)
+{
+	struct gta01_battery *bat = container_of(psy, struct gta01_battery, psy);
+	
+	switch(psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		if (bat->pdata->get_charging_status())
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = bat->pdata->get_voltage();
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = bat->pdata->get_current();
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = 1; /* You must never run GTA01 without battery. */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void gta01_bat_ext_changed(struct power_supply *psy)
+{
+	struct gta01_battery *bat = container_of(psy, struct gta01_battery, psy);
+	power_supply_changed(&bat->psy);
+}
+
+static int gta01_battery_probe(struct platform_device *pdev)
+{
+	struct gta01_battery *gta01_bat;
+
+	gta01_bat = kzalloc(sizeof(*gta01_bat), GFP_KERNEL);
+	if (!gta01_bat)
+		return -ENOMEM;
+
+	gta01_bat->psy.name = "battery";
+	gta01_bat->psy.type = POWER_SUPPLY_TYPE_BATTERY;
+	gta01_bat->psy.properties = gta01_bat_props;
+	gta01_bat->psy.num_properties = ARRAY_SIZE(gta01_bat_props);
+	gta01_bat->psy.get_property = gta01_bat_get_property;
+	gta01_bat->psy.external_power_changed = gta01_bat_ext_changed;
+
+	gta01_bat->pdata = pdev->dev.platform_data;
+	power_supply_register(&pdev->dev, &gta01_bat->psy);
+
+	return 0;
+}
+
+static int gta01_battery_remove(struct platform_device *pdev)
+{
+	struct gta01_battery *bat = platform_get_drvdata(pdev);
+
+	power_supply_unregister(&bat->psy);
+	kfree(bat);
+
+	return 0;
+}
+
+static struct platform_driver gta01_battery_driver = {
+	.driver = {
+		.name = "gta01_battery",
+	},
+	.probe	  = gta01_battery_probe,
+	.remove   = gta01_battery_remove,
+};
+
+static int __init gta01_battery_init(void)
+{
+	return platform_driver_register(&gta01_battery_driver);
+}
+
+static void __exit gta01_battery_exit(void)
+{
+	platform_driver_unregister(&gta01_battery_driver);
+}
+
+module_init(gta01_battery_init);
+module_exit(gta01_battery_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_DESCRIPTION("gta01 battery driver");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/hdq.c linux-2.6.29-rc3.owrt.om/drivers/power/hdq.c
--- linux-2.6.29-rc3.owrt/drivers/power/hdq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/power/hdq.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,515 @@
+/*
+ * HDQ generic GPIO bitbang driver using FIQ
+ *
+ * (C) 2006-2007 by Openmoko, Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/hdq.h>
+
+#define HDQ_READ 0
+#define HDQ_WRITE 0x80
+
+enum hdq_bitbang_states {
+	HDQB_IDLE = 0,
+	HDQB_TX_BREAK,
+	HDQB_TX_BREAK_RECOVERY,
+	HDQB_ADS_CALC,
+	HDQB_ADS_LOW,
+	HDQB_ADS_HIGH,
+	HDQB_WAIT_RX,
+	HDQB_DATA_RX_LOW,
+	HDQB_DATA_RX_HIGH,
+	HDQB_WAIT_TX,
+};
+
+static struct hdq_priv {
+	u8 hdq_probed; /* nonzero after HDQ driver probed */
+	struct mutex hdq_lock; /* if you want to use hdq, you have to take lock */
+	unsigned long hdq_gpio_pin; /* GTA02 = GPD14 which pin to meddle with */
+	u8 hdq_ads; /* b7..b6 = register address, b0 = r/w */
+	u8 hdq_tx_data; /* data to tx for write action */
+	u8 hdq_rx_data; /* data received in read action */
+	u8 hdq_request_ctr; /* incremented by "user" to request a transfer */
+	u8 hdq_transaction_ctr; /* incremented after each transfer */
+	u8 hdq_error; /* 0 = no error */
+	u8 hdq_ctr;
+	u8 hdq_ctr2;
+	u8 hdq_bit;
+	u8 hdq_shifter;
+	u8 hdq_tx_data_done;
+	enum hdq_bitbang_states hdq_state;
+	int reported_error;
+
+	struct hdq_platform_data *pdata;
+} hdq_priv;
+
+
+static void hdq_bad(void)
+{
+	if (!hdq_priv.reported_error)
+		printk(KERN_ERR "HDQ error: %d\n", hdq_priv.hdq_error);
+	hdq_priv.reported_error = 1;
+}
+
+static void hdq_good(void)
+{
+	if (hdq_priv.reported_error)
+		printk(KERN_INFO "HDQ responds again\n");
+	hdq_priv.reported_error = 0;
+}
+
+int hdq_fiq_handler(void)
+{
+	if (!hdq_priv.hdq_probed)
+		return 0;
+
+	switch (hdq_priv.hdq_state) {
+	case HDQB_IDLE:
+		if (hdq_priv.hdq_request_ctr == hdq_priv.hdq_transaction_ctr)
+			break;
+		hdq_priv.hdq_ctr = 250 / HDQ_SAMPLE_PERIOD_US;
+		hdq_priv.pdata->gpio_set(0);
+		hdq_priv.pdata->gpio_dir_out();
+		hdq_priv.hdq_tx_data_done = 0;
+		hdq_priv.hdq_state = HDQB_TX_BREAK;
+		break;
+
+	case HDQB_TX_BREAK: /* issue low for > 190us */
+		if (--hdq_priv.hdq_ctr == 0) {
+			hdq_priv.hdq_ctr = 60 / HDQ_SAMPLE_PERIOD_US;
+			hdq_priv.hdq_state = HDQB_TX_BREAK_RECOVERY;
+			hdq_priv.pdata->gpio_set(1);
+		}
+		break;
+
+	case HDQB_TX_BREAK_RECOVERY: /* issue low for > 40us */
+		if (--hdq_priv.hdq_ctr)
+			break;
+		hdq_priv.hdq_shifter = hdq_priv.hdq_ads;
+		hdq_priv.hdq_bit = 8; /* 8 bits of ads / rw */
+		hdq_priv.hdq_tx_data_done = 0; /* doing ads */
+		/* fallthru on last one */
+	case HDQB_ADS_CALC:
+		if (hdq_priv.hdq_shifter & 1)
+			hdq_priv.hdq_ctr = 50 / HDQ_SAMPLE_PERIOD_US;
+		else
+			hdq_priv.hdq_ctr = 120 / HDQ_SAMPLE_PERIOD_US;
+		/* carefully precompute the other phase length */
+		hdq_priv.hdq_ctr2 = (210 - (hdq_priv.hdq_ctr * HDQ_SAMPLE_PERIOD_US)) /
+				HDQ_SAMPLE_PERIOD_US;
+		hdq_priv.hdq_state = HDQB_ADS_LOW;
+		hdq_priv.hdq_shifter >>= 1;
+		hdq_priv.hdq_bit--;
+		hdq_priv.pdata->gpio_set(0);
+		break;
+
+	case HDQB_ADS_LOW:
+		if (--hdq_priv.hdq_ctr)
+			break;
+		hdq_priv.pdata->gpio_set(1);
+		hdq_priv.hdq_state = HDQB_ADS_HIGH;
+		break;
+
+	case HDQB_ADS_HIGH:
+		if (--hdq_priv.hdq_ctr2 > 1) /* account for HDQB_ADS_CALC */
+			break;
+		if (hdq_priv.hdq_bit) { /* more bits to do */
+			hdq_priv.hdq_state = HDQB_ADS_CALC;
+			break;
+		}
+		/* no more bits, wait it out until hdq_priv.hdq_ctr2 exhausted */
+		if (hdq_priv.hdq_ctr2)
+			break;
+		/* ok no more bits and very last state */
+		hdq_priv.hdq_ctr = 60 / HDQ_SAMPLE_PERIOD_US;
+		/* FIXME 0 = read */
+		if (hdq_priv.hdq_ads & 0x80) { /* write the byte out */
+			 /* set delay before payload */
+			hdq_priv.hdq_ctr = 300 / HDQ_SAMPLE_PERIOD_US;
+ 			/* already high, no need to write */
+			hdq_priv.hdq_state = HDQB_WAIT_TX;
+			break;
+		}
+		/* read the next byte */
+		hdq_priv.hdq_bit = 8; /* 8 bits of data */
+		hdq_priv.hdq_ctr = 2500 / HDQ_SAMPLE_PERIOD_US;
+		hdq_priv.hdq_state = HDQB_WAIT_RX;
+		hdq_priv.pdata->gpio_dir_in();
+		break;
+
+	case HDQB_WAIT_TX: /* issue low for > 40us */
+		if (--hdq_priv.hdq_ctr)
+			break;
+		if (!hdq_priv.hdq_tx_data_done) { /* was that the data sent? */
+			hdq_priv.hdq_tx_data_done++;
+			hdq_priv.hdq_shifter = hdq_priv.hdq_tx_data;
+			hdq_priv.hdq_bit = 8; /* 8 bits of data */
+			hdq_priv.hdq_state = HDQB_ADS_CALC; /* start sending */
+			break;
+		}
+		hdq_priv.hdq_error = 0;
+		hdq_priv.hdq_transaction_ctr = hdq_priv.hdq_request_ctr;
+		hdq_priv.hdq_state = HDQB_IDLE; /* all tx is done */
+		/* idle in input mode, it's pulled up by 10K */
+		hdq_priv.pdata->gpio_dir_in();
+		break;
+
+	case HDQB_WAIT_RX: /* wait for battery to talk to us */
+		if (hdq_priv.pdata->gpio_get() == 0) {
+			/* it talks to us! */
+			hdq_priv.hdq_ctr2 = 1;
+			hdq_priv.hdq_bit = 8; /* 8 bits of data */
+			/* timeout */
+			hdq_priv.hdq_ctr = 500 / HDQ_SAMPLE_PERIOD_US;
+			hdq_priv.hdq_state = HDQB_DATA_RX_LOW;
+			break;
+		}
+		if (--hdq_priv.hdq_ctr == 0) { /* timed out, error */
+			hdq_priv.hdq_error = 1;
+			hdq_priv.hdq_transaction_ctr = hdq_priv.hdq_request_ctr;
+			hdq_priv.hdq_state = HDQB_IDLE; /* abort */
+		}
+		break;
+
+	/*
+	 * HDQ basically works by measuring the low time of the bit cell
+	 * 32-50us --> '1', 80 - 145us --> '0'
+	 */
+
+	case HDQB_DATA_RX_LOW:
+		if (hdq_priv.pdata->gpio_get()) {
+			hdq_priv.hdq_rx_data >>= 1;
+			if (hdq_priv.hdq_ctr2 <= (65 / HDQ_SAMPLE_PERIOD_US))
+				hdq_priv.hdq_rx_data |= 0x80;
+
+			if (--hdq_priv.hdq_bit == 0) {
+				hdq_priv.hdq_error = 0;
+				hdq_priv.hdq_transaction_ctr =
+							hdq_priv.hdq_request_ctr;
+
+				hdq_priv.hdq_state = HDQB_IDLE;
+			} else
+				hdq_priv.hdq_state = HDQB_DATA_RX_HIGH;
+			/* timeout */
+			hdq_priv.hdq_ctr = 1000 / HDQ_SAMPLE_PERIOD_US;
+			hdq_priv.hdq_ctr2 = 1;
+			break;
+		}
+		hdq_priv.hdq_ctr2++;
+		if (--hdq_priv.hdq_ctr)
+			break;
+		 /* timed out, error */
+		hdq_priv.hdq_error = 2;
+		hdq_priv.hdq_transaction_ctr = hdq_priv.hdq_request_ctr;
+		hdq_priv.hdq_state = HDQB_IDLE; /* abort */
+		break;
+
+	case HDQB_DATA_RX_HIGH:
+		if (!hdq_priv.pdata->gpio_get()) {
+			/* it talks to us! */
+			hdq_priv.hdq_ctr2 = 1;
+			/* timeout */
+			hdq_priv.hdq_ctr = 400 / HDQ_SAMPLE_PERIOD_US;
+			hdq_priv.hdq_state = HDQB_DATA_RX_LOW;
+			break;
+		}
+		if (--hdq_priv.hdq_ctr)
+			break;
+		/* timed out, error */
+		hdq_priv.hdq_error = 3;
+		hdq_priv.hdq_transaction_ctr = hdq_priv.hdq_request_ctr;
+
+		/* we're in input mode already */
+		hdq_priv.hdq_state = HDQB_IDLE; /* abort */
+		break;
+	}
+
+	/* Are we interested in keeping the FIQ source alive ? */
+	if (hdq_priv.hdq_state != HDQB_IDLE)
+		return 1;
+	else
+		return 0;
+}
+static int fiq_busy(void)
+{
+	int request = (volatile u8)hdq_priv.hdq_request_ctr;
+	int transact = (volatile u8)hdq_priv.hdq_transaction_ctr;
+
+
+	return (request != transact);
+}
+
+int hdq_initialized(void)
+{
+	return hdq_priv.hdq_probed;
+}
+EXPORT_SYMBOL_GPL(hdq_initialized);
+
+int hdq_read(int address)
+{
+	int count_sleeps = 5;
+	int ret = -ETIME;
+
+	if (!hdq_priv.hdq_probed)
+		return -EINVAL;
+
+	mutex_lock(&hdq_priv.hdq_lock);
+
+	hdq_priv.hdq_error = 0;
+	hdq_priv.hdq_ads = address | HDQ_READ;
+	hdq_priv.hdq_request_ctr++;
+	hdq_priv.pdata->kick_fiq();
+	/*
+	 * FIQ takes care of it while we block our calling process
+	 * But we're not spinning -- other processes run normally while
+	 * we wait for the result
+	 */
+	while (count_sleeps--) {
+		msleep(10); /* valid transaction always completes in < 10ms */
+
+		if (fiq_busy())
+			continue;
+
+		if (hdq_priv.hdq_error) {
+			hdq_bad();
+			goto done; /* didn't see a response in good time */
+		}
+		hdq_good();
+
+		ret = hdq_priv.hdq_rx_data;
+		goto done;
+	}
+
+done:
+	mutex_unlock(&hdq_priv.hdq_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(hdq_read);
+
+int hdq_write(int address, u8 data)
+{
+	int count_sleeps = 5;
+	int ret = -ETIME;
+
+	if (!hdq_priv.hdq_probed)
+		return -EINVAL;
+
+	mutex_lock(&hdq_priv.hdq_lock);
+
+	hdq_priv.hdq_error = 0;
+	hdq_priv.hdq_ads = address | HDQ_WRITE;
+	hdq_priv.hdq_tx_data = data;
+	hdq_priv.hdq_request_ctr++;
+	hdq_priv.pdata->kick_fiq();
+	/*
+	 * FIQ takes care of it while we block our calling process
+	 * But we're not spinning -- other processes run normally while
+	 * we wait for the result
+	 */
+	while (count_sleeps--) {
+		msleep(10); /* valid transaction always completes in < 10ms */
+
+		if (fiq_busy())
+			continue; /* something bad with FIQ */
+
+		if (hdq_priv.hdq_error) {
+			hdq_bad();
+			goto done; /* didn't see a response in good time */
+		}
+		hdq_good();
+
+		ret = 0;
+		goto done;
+	}
+
+done:
+	mutex_unlock(&hdq_priv.hdq_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(hdq_write);
+
+/* sysfs */
+
+static ssize_t hdq_sysfs_dump(struct device *dev, struct device_attribute *attr,
+			 char *buf)
+{
+	int n;
+	int v;
+	u8 u8a[128]; /* whole address space for HDQ */
+	char *end = buf;
+
+	if (!hdq_priv.hdq_probed)
+		return -EINVAL;
+
+	/* the dump does not take care about 16 bit regs, because at this
+	 * bus level we don't know about the chip details
+	 */
+	for (n = 0; n < sizeof(u8a); n++) {
+		v = hdq_read(n);
+		if (v < 0)
+			goto bail;
+		u8a[n] = v;
+	}
+
+	for (n = 0; n < sizeof(u8a); n += 16) {
+		hex_dump_to_buffer(u8a + n, sizeof(u8a), 16, 1, end, 4096, 0);
+		end += strlen(end);
+		*end++ = '\n';
+		*end = '\0';
+	}
+	return (end - buf);
+
+bail:
+	return sprintf(buf, "ERROR %d\n", v);
+}
+
+/* you write by <address> <data>, eg, "34 128" */
+
+#define atoi(str) simple_strtoul(((str != NULL) ? str : ""), NULL, 0)
+
+static ssize_t hdq_sysfs_write(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	const char *end = buf + count;
+	int address = atoi(buf);
+
+	if (!hdq_priv.hdq_probed)
+		return -EINVAL;
+
+	while ((buf != end) && (*buf != ' '))
+		buf++;
+	if (buf >= end)
+		return 0;
+	while ((buf < end) && (*buf == ' '))
+		buf++;
+	if (buf >= end)
+		return 0;
+
+	hdq_write(address, atoi(buf));
+
+	return count;
+}
+
+static DEVICE_ATTR(dump, 0400, hdq_sysfs_dump, NULL);
+static DEVICE_ATTR(write, 0600, NULL, hdq_sysfs_write);
+
+static struct attribute *hdq_sysfs_entries[] = {
+	&dev_attr_dump.attr,
+	&dev_attr_write.attr,
+	NULL
+};
+
+static struct attribute_group hdq_attr_group = {
+	.name	= "hdq",
+	.attrs	= hdq_sysfs_entries,
+};
+
+
+#ifdef CONFIG_PM
+static int hdq_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	/* after 18s of this, the battery monitor will also go to sleep */
+	hdq_priv.pdata->gpio_dir_in();
+	hdq_priv.pdata->disable_fiq();
+	return 0;
+}
+
+static int hdq_resume(struct platform_device *pdev)
+{
+	hdq_priv.pdata->gpio_set(1);
+	hdq_priv.pdata->gpio_dir_out();
+	hdq_priv.pdata->enable_fiq();
+	return 0;
+}
+#endif
+
+static int __init hdq_probe(struct platform_device *pdev)
+{
+	struct resource *r = platform_get_resource(pdev, 0, 0);
+	int ret;
+	struct hdq_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!r || !pdata)
+		return -EINVAL;
+		
+	platform_set_drvdata(pdev, NULL);
+
+	mutex_init(&hdq_priv.hdq_lock);
+
+	/* set our HDQ comms pin from the platform data */
+	hdq_priv.hdq_gpio_pin = r->start;
+	hdq_priv.pdata = pdata;
+
+	hdq_priv.pdata->gpio_set(1);
+	hdq_priv.pdata->gpio_dir_out();
+
+	/* Initialize FIQ */
+	if (hdq_priv.pdata->enable_fiq() < 0) {
+		dev_err(&pdev->dev, "Could not enable FIQ source\n");
+		return -EINVAL;
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &hdq_attr_group);
+	if (ret)
+		return ret;
+
+	hdq_priv.hdq_probed = 1; /* we are ready to do stuff now */
+
+	/*
+	 * if wanted, users can defer registration of devices
+	 * that depend on HDQ until after we register, and can use our
+	 * device as parent so suspend-resume ordering is correct
+	 */
+	if (pdata->attach_child_devices)
+		(pdata->attach_child_devices)(&pdev->dev);
+
+	hdq_priv.pdata = pdata;
+
+	return 0;
+}
+
+static int hdq_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &hdq_attr_group);
+	return 0;
+}
+
+static struct platform_driver hdq_driver = {
+	.probe		= hdq_probe,
+	.remove		= hdq_remove,
+#ifdef CONFIG_PM
+	.suspend	= hdq_suspend,
+	.resume		= hdq_resume,
+#endif
+	.driver		= {
+		.name		= "hdq",
+	},
+};
+
+static int __init hdq_init(void)
+{
+	return platform_driver_register(&hdq_driver);
+}
+
+static void __exit hdq_exit(void)
+{
+ 	platform_driver_unregister(&hdq_driver);
+}
+
+module_init(hdq_init);
+module_exit(hdq_exit);
+
+MODULE_AUTHOR("Andy Green <andy@openmoko.com>");
+MODULE_DESCRIPTION("HDQ driver");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/Kconfig linux-2.6.29-rc3.owrt.om/drivers/power/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/power/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/power/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -88,4 +88,27 @@
 	help
 	 Say Y to include support for NXP PCF50633 Main Battery Charger.
 
+config BATTERY_BQ27000_HDQ
+	tristate "BQ27000 HDQ battery monitor driver"
+	help
+	  Say Y to enable support for the battery on the Neo Freerunner
+
+config HDQ_GPIO_BITBANG
+	bool "Generic gpio based HDQ bitbang"
+	help
+	  Say Y to enable supoort for generic gpio based HDQ bitbang driver.
+	  This can not be built as a module.
+
+config CHARGER_PCF50606
+	tristate "Support for NXP PCF50606 MBC"
+	depends on MFD_PCF50606
+	help
+	 Say Y to include support for NXP PCF50606 Battery Charger.
+
+config BATTERY_GTA01
+	tristate "GTA01 battery driver"
+	help
+	  Say Y here to enable this dumb driver for dumb gta01 batteries
+
 endif # POWER_SUPPLY
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/Makefile linux-2.6.29-rc3.owrt.om/drivers/power/Makefile
--- linux-2.6.29-rc3.owrt/drivers/power/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/power/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -25,4 +25,10 @@
 obj-$(CONFIG_BATTERY_WM97XX)	+= wm97xx_battery.o
 obj-$(CONFIG_BATTERY_BQ27x00)	+= bq27x00_battery.o
 obj-$(CONFIG_BATTERY_DA9030)	+= da9030_battery.o
-obj-$(CONFIG_CHARGER_PCF50633)	+= pcf50633-charger.o
\ No newline at end of file
+obj-$(CONFIG_CHARGER_PCF50633)	+= pcf50633-charger.o
+obj-$(CONFIG_CHARGER_PCF50606)	+= pcf50606-charger.o
+obj-$(CONFIG_BATTERY_PALMTX)	+= palmtx_battery.o
+obj-$(CONFIG_BATTERY_BQ27000_HDQ)	+= bq27000_battery.o
+obj-$(CONFIG_BATTERY_GTA01)	+= gta01_battery.o
+
+obj-$(CONFIG_HDQ_GPIO_BITBANG)  += hdq.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/pcf50606-charger.c linux-2.6.29-rc3.owrt.om/drivers/power/pcf50606-charger.c
--- linux-2.6.29-rc3.owrt/drivers/power/pcf50606-charger.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/power/pcf50606-charger.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,244 @@
+/* NXP PCF50606 Main Battery Charger Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte, Andy Green and Werner Almesberger
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/mfd/pcf50606/mbc.h>
+
+struct pcf50606_mbc {
+	struct pcf50606 *pcf;
+
+	int charger_online;
+	struct power_supply charger;
+};
+
+void pcf50606_charge_fast(struct pcf50606 *pcf, int on)
+{
+	struct pcf50606_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);
+
+	/*
+	 * This is a fix to work around boot-time ordering problems if
+	 * the s3c2410_udc is initialized before the pcf50606 mbc is
+	 * ready.
+	 */
+	if (!mbc)
+		return;
+
+	if (on) {
+		pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_MBCC1,
+				 PCF50606_MBCC1_AUTOFST,
+				 PCF50606_MBCC1_AUTOFST);\
+			mbc->charger_online = 1;
+	} else {
+		/* disable automatic fast-charge */
+		pcf50606_reg_clear_bits(pcf, PCF50606_REG_MBCC1,
+					PCF50606_MBCC1_AUTOFST);
+		/* switch to idle mode to abort existing charge process */
+		pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_MBCC1,
+				PCF50606_MBCC1_CHGMOD_MASK,
+				PCF50606_MBCC1_CHGMOD_IDLE);
+			mbc->charger_online = 0;
+	}
+}
+EXPORT_SYMBOL_GPL(pcf50606_charge_fast);
+
+static ssize_t
+show_chgmode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf50606_mbc *mbc = dev_get_drvdata(dev);
+
+	u8 mbcc1 = pcf50606_reg_read(mbc->pcf, PCF50606_REG_MBCC1);
+	u8 chgmod = (mbcc1 & PCF50606_MBCC1_CHGMOD_MASK);
+
+	return sprintf(buf, "%d\n", chgmod);
+}
+
+static ssize_t set_chgmode(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct pcf50606_mbc *mbc = dev_get_drvdata(dev);
+	u_int8_t mbcc1 = pcf50606_reg_read(mbc->pcf, PCF50606_REG_MBCC1);
+
+	mbcc1 &= ~PCF50606_MBCC1_CHGMOD_MASK;
+
+	if (!strcmp(buf, "qualification"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_QUAL;
+	else if (!strcmp(buf, "pre"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_PRE;
+	else if (!strcmp(buf, "trickle"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_TRICKLE;
+	else if (!strcmp(buf, "fast_cccv"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_FAST_CCCV;
+	/* We don't allow the other fast modes for security reasons */
+	else if (!strcmp(buf, "idle"))
+		mbcc1 |= PCF50606_MBCC1_CHGMOD_IDLE;
+	else
+		return -EINVAL;
+
+	pcf50606_reg_write(mbc->pcf, PCF50606_REG_MBCC1, mbcc1);
+
+	return count;
+}
+
+static DEVICE_ATTR(chgmode, S_IRUGO, show_chgmode, set_chgmode);
+
+
+static struct attribute *pcf50606_mbc_sysfs_entries[] = {
+	&dev_attr_chgmode.attr,
+	NULL,
+};
+
+static struct attribute_group mbc_attr_group = {
+	.name	= NULL,			/* put in device directory */
+	.attrs	= pcf50606_mbc_sysfs_entries,
+};
+
+static void
+pcf50606_mbc_irq_handler(int irq, void *data)
+{
+	struct pcf50606_mbc *mbc = data;
+
+	power_supply_changed(&mbc->charger);
+
+	if (mbc->pcf->pdata->mbc_event_callback)
+		mbc->pcf->pdata->mbc_event_callback(mbc->pcf, irq);
+}
+
+static int charger_get_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			union power_supply_propval *val)
+{
+	struct pcf50606_mbc *mbc = container_of(psy, struct pcf50606_mbc, charger);
+	int ret = 0;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval =  mbc->charger_online;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static enum power_supply_property power_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static const u8 mbc_irq_handlers[] = {
+	PCF50606_IRQ_CHGINS,
+	PCF50606_IRQ_CHGRM,
+	PCF50606_IRQ_CHGFOK,
+	PCF50606_IRQ_CHGERR,
+	PCF50606_IRQ_CHGFRDY,
+	PCF50606_IRQ_CHGPROT,
+};
+
+static int __devinit pcf50606_mbc_probe(struct platform_device *pdev)
+{
+	struct pcf50606_mbc *mbc;
+	struct pcf50606_subdev_pdata *pdata = pdev->dev.platform_data;
+	int ret;
+	int i;
+	u8 oocs;
+
+	mbc = kzalloc(sizeof(*mbc), GFP_KERNEL);
+	if (!mbc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, mbc);
+	mbc->pcf = pdata->pcf;
+
+	/* Set up IRQ handlers */
+	for (i = 0; i < ARRAY_SIZE(mbc_irq_handlers); i++)
+		pcf50606_register_irq(mbc->pcf, mbc_irq_handlers[i],
+					pcf50606_mbc_irq_handler, mbc);
+
+	mbc->charger.name		= "charger";
+	mbc->charger.type		= POWER_SUPPLY_TYPE_MAINS;
+	mbc->charger.properties		= power_props;
+	mbc->charger.num_properties	= ARRAY_SIZE(power_props);
+	mbc->charger.get_property	= &charger_get_property;
+	mbc->charger.supplied_to	= mbc->pcf->pdata->batteries;
+	mbc->charger.num_supplicants	= mbc->pcf->pdata->num_batteries;
+
+	ret = power_supply_register(&pdev->dev, &mbc->charger);
+	if (ret) {
+		dev_err(mbc->pcf->dev, "failed to register charger\n");
+		kfree(mbc);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &mbc_attr_group);
+	if (ret)
+		dev_err(mbc->pcf->dev, "failed to create sysfs entries\n");
+
+	oocs = pcf50606_reg_read(mbc->pcf, PCF50606_REG_OOCS);
+	if (oocs & PCF50606_OOCS_CHGOK)
+		pcf50606_mbc_irq_handler(PCF50606_IRQ_CHGINS, mbc);
+
+	return 0;
+}
+
+static int __devexit pcf50606_mbc_remove(struct platform_device *pdev)
+{
+	struct pcf50606_mbc *mbc = platform_get_drvdata(pdev);
+	int i;
+
+	/* Remove IRQ handlers */
+	for (i = 0; i < ARRAY_SIZE(mbc_irq_handlers); i++)
+		pcf50606_free_irq(mbc->pcf, mbc_irq_handlers[i]);
+
+	power_supply_unregister(&mbc->charger);
+
+	kfree(mbc);
+
+	return 0;
+}
+
+static struct platform_driver pcf50606_mbc_driver = {
+	.driver = {
+		.name = "pcf50606-mbc",
+	},
+	.probe = pcf50606_mbc_probe,
+	.remove = __devexit_p(pcf50606_mbc_remove),
+};
+
+static int __init pcf50606_mbc_init(void)
+{
+	return platform_driver_register(&pcf50606_mbc_driver);
+}
+module_init(pcf50606_mbc_init);
+
+static void __exit pcf50606_mbc_exit(void)
+{
+	platform_driver_unregister(&pcf50606_mbc_driver);
+}
+module_exit(pcf50606_mbc_exit);
+
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_DESCRIPTION("PCF50606 mbc driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pcf50606-mbc");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/power/pcf50633-charger.c linux-2.6.29-rc3.owrt.om/drivers/power/pcf50633-charger.c
--- linux-2.6.29-rc3.owrt/drivers/power/pcf50633-charger.c	2009-05-10 22:08:44.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/power/pcf50633-charger.c	2009-05-10 22:28:00.000000000 +0200
@@ -36,6 +36,9 @@
 
 	struct power_supply usb;
 	struct power_supply adapter;
+	struct power_supply ac;
+
+	struct delayed_work charging_restart_work;
 };
 
 int pcf50633_mbc_usb_curlim_set(struct pcf50633 *pcf, int ma)
@@ -43,15 +46,24 @@
 	struct pcf50633_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);
 	int ret = 0;
 	u8 bits;
+	int charging_start = 1;
+	u8 mbcs2, chgmod;
+	unsigned int mbcc5;
 
-	if (ma >= 1000)
+	if (ma >= 1000) {
 		bits = PCF50633_MBCC7_USB_1000mA;
-	else if (ma >= 500)
+		ma = 1000;
+	} else if (ma >= 500) {
 		bits = PCF50633_MBCC7_USB_500mA;
-	else if (ma >= 100)
+		ma = 500;
+	} else if (ma >= 100) {
 		bits = PCF50633_MBCC7_USB_100mA;
-	else
+		ma = 100;
+	} else {
 		bits = PCF50633_MBCC7_USB_SUSPEND;
+		charging_start = 0;
+		ma = 0;
+	}
 
 	ret = pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC7,
 					PCF50633_MBCC7_USB_MASK, bits);
@@ -60,6 +72,37 @@
 	else
 		dev_info(pcf->dev, "usb curlim to %d mA\n", ma);
 
+	/*
+	 * We limit the charging current to be the USB current limit.
+	 * The reason is that on pcf50633, when it enters PMU Standby mode,
+	 * which it does when the device goes "off", the USB current limit
+	 * reverts to the variant default.  In at least one common case, that
+	 * default is 500mA.  By setting the charging current to be the same
+	 * as the USB limit we set here before PMU standby, we enforce it only
+	 * using the correct amount of current even when the USB current limit
+	 * gets reset to the wrong thing
+	 */
+
+	mbcc5 = (ma << 8) / mbc->pcf->pdata->chg_ref_current_ma;
+	if (mbcc5 > 255)
+		mbcc5 = 255;
+	pcf50633_reg_write(mbc->pcf, PCF50633_REG_MBCC5, mbcc5);
+
+	mbcs2 = pcf50633_reg_read(pcf, PCF50633_REG_MBCS2);
+	chgmod = (mbcs2 & PCF50633_MBCS2_MBC_MASK);
+
+	/* If chgmod == BATFULL, setting chgena has no effect.
+	 * We need to set resume instead.
+	 */
+	if (chgmod != PCF50633_MBCS2_MBC_BAT_FULL)
+		pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC1,
+				PCF50633_MBCC1_CHGENA, PCF50633_MBCC1_CHGENA);
+	else
+		pcf50633_reg_set_bit_mask(pcf, PCF50633_REG_MBCC1,
+				PCF50633_MBCC1_RESUME, PCF50633_MBCC1_RESUME);
+
+	mbc->usb_active = charging_start;
+	
 	power_supply_changed(&mbc->usb);
 
 	return ret;
@@ -84,21 +127,6 @@
 }
 EXPORT_SYMBOL_GPL(pcf50633_mbc_get_status);
 
-void pcf50633_mbc_set_status(struct pcf50633 *pcf, int what, int status)
-{
-	struct pcf50633_mbc *mbc = platform_get_drvdata(pcf->mbc_pdev);
-
-	if (what & PCF50633_MBC_USB_ONLINE)
-		mbc->usb_online = !!status;
-	if (what & PCF50633_MBC_USB_ACTIVE)
-		mbc->usb_active = !!status;
-	if (what & PCF50633_MBC_ADAPTER_ONLINE)
-		mbc->adapter_online = !!status;
-	if (what & PCF50633_MBC_ADAPTER_ACTIVE)
-		mbc->adapter_active = !!status;
-}
-EXPORT_SYMBOL_GPL(pcf50633_mbc_set_status);
-
 static ssize_t
 show_chgmode(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -149,9 +177,44 @@
 
 static DEVICE_ATTR(usb_curlim, S_IRUGO | S_IWUSR, show_usblim, set_usblim);
 
+static ssize_t
+show_chglim(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf50633_mbc *mbc = dev_get_drvdata(dev);
+	u8 mbcc5 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC5);
+	unsigned int ma;
+
+	ma = (mbc->pcf->pdata->chg_ref_current_ma *  mbcc5) >> 8;
+
+	return sprintf(buf, "%u\n", ma);
+}
+
+static ssize_t set_chglim(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct pcf50633_mbc *mbc = dev_get_drvdata(dev);
+	unsigned long ma;
+	unsigned int mbcc5;
+	int ret;
+
+	ret = strict_strtoul(buf, 10, &ma);
+	if (ret)
+		return -EINVAL;
+
+	mbcc5 = (ma << 8) / mbc->pcf->pdata->chg_ref_current_ma;
+	if (mbcc5 > 255)
+		mbcc5 = 255;
+	pcf50633_reg_write(mbc->pcf, PCF50633_REG_MBCC5, mbcc5);
+
+	return count;
+}
+
+static DEVICE_ATTR(chg_curlim, S_IRUGO | S_IWUSR, show_chglim, set_chglim);
+
 static struct attribute *pcf50633_mbc_sysfs_entries[] = {
 	&dev_attr_chgmode.attr,
 	&dev_attr_usb_curlim.attr,
+	&dev_attr_chg_curlim.attr,
 	NULL,
 };
 
@@ -160,10 +223,44 @@
 	.attrs	= pcf50633_mbc_sysfs_entries,
 };
 
+/* MBC state machine switches into charging mode when the battery voltage
+ * falls below 96% of a battery float voltage. But the voltage drop in Li-ion
+ * batteries is marginal(1~2 %) till about 80% of its capacity - which means,
+ * after a BATFULL, charging won't be restarted until 80%.
+ *
+ * This work_struct function restarts charging every few seconds and makes
+ * sure we don't discharge too much
+ */
+
+static void pcf50633_mbc_charging_restart(struct work_struct *work)
+{
+	struct pcf50633_mbc *mbc;
+	u8 mbcs2, chgmod;
+
+	mbc = container_of(work, struct pcf50633_mbc,
+				charging_restart_work.work);
+
+	mbcs2 = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCS2);
+	chgmod = (mbcs2 & PCF50633_MBCS2_MBC_MASK);
+
+	if (chgmod != PCF50633_MBCS2_MBC_BAT_FULL)
+		return;
+
+	/* Restart charging */
+	pcf50633_reg_set_bit_mask(mbc->pcf, PCF50633_REG_MBCC1,
+				PCF50633_MBCC1_RESUME, PCF50633_MBCC1_RESUME);
+	mbc->usb_active = 1;
+	power_supply_changed(&mbc->usb);
+
+	dev_info(mbc->pcf->dev, "Charging restarted\n");
+}
+
 static void
 pcf50633_mbc_irq_handler(int irq, void *data)
 {
 	struct pcf50633_mbc *mbc = data;
+	int chg_restart_interval = 
+			mbc->pcf->pdata->charging_restart_interval;
 
 	/* USB */
 	if (irq == PCF50633_IRQ_USBINS) {
@@ -171,7 +268,8 @@
 	} else if (irq == PCF50633_IRQ_USBREM) {
 		mbc->usb_online = 0;
 		mbc->usb_active = 0;
-		pcf50633_mbc_usb_curlim_set(mbc->pcf, 0);
+		pcf50633_mbc_usb_curlim_set(mbc->pcf, 0);		
+		cancel_delayed_work_sync(&mbc->charging_restart_work);
 	}
 
 	/* Adapter */
@@ -186,10 +284,18 @@
 	if (irq == PCF50633_IRQ_BATFULL) {
 		mbc->usb_active = 0;
 		mbc->adapter_active = 0;
-	}
+
+		if (chg_restart_interval > 0)
+			schedule_delayed_work(&mbc->charging_restart_work,
+							chg_restart_interval);
+	} else if (irq == PCF50633_IRQ_USBLIMON)
+		mbc->usb_active = 0;
+	else if (irq == PCF50633_IRQ_USBLIMOFF)
+		mbc->usb_active = 1;
 
 	power_supply_changed(&mbc->usb);
 	power_supply_changed(&mbc->adapter);
+	power_supply_changed(&mbc->ac);
 
 	if (mbc->pcf->pdata->mbc_event_callback)
 		mbc->pcf->pdata->mbc_event_callback(mbc->pcf, irq);
@@ -199,7 +305,7 @@
 			enum power_supply_property psp,
 			union power_supply_propval *val)
 {
-	struct pcf50633_mbc *mbc = container_of(psy, struct pcf50633_mbc, usb);
+	struct pcf50633_mbc *mbc = container_of(psy, struct pcf50633_mbc, adapter);
 	int ret = 0;
 
 	switch (psp) {
@@ -219,10 +325,34 @@
 {
 	struct pcf50633_mbc *mbc = container_of(psy, struct pcf50633_mbc, usb);
 	int ret = 0;
+	u8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &
+						PCF50633_MBCC7_USB_MASK;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_ONLINE:
+		val->intval = mbc->usb_online &&
+			       	(usblim <= PCF50633_MBCC7_USB_500mA);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int ac_get_property(struct power_supply *psy,
+			enum power_supply_property psp,
+			union power_supply_propval *val)
+{
+	struct pcf50633_mbc *mbc = container_of(psy, struct pcf50633_mbc, ac);
+	int ret = 0;
+	u8 usblim = pcf50633_reg_read(mbc->pcf, PCF50633_REG_MBCC7) &
+						PCF50633_MBCC7_USB_MASK;
 
 	switch (psp) {
 	case POWER_SUPPLY_PROP_ONLINE:
-		val->intval = mbc->usb_online;
+		val->intval = mbc->usb_online &&
+			       	(usblim == PCF50633_MBCC7_USB_1000mA);
 		break;
 	default:
 		ret = -EINVAL;
@@ -287,6 +417,17 @@
 	mbc->usb.supplied_to		= mbc->pcf->pdata->batteries;
 	mbc->usb.num_supplicants	= mbc->pcf->pdata->num_batteries;
 
+	mbc->ac.name			= "ac";
+	mbc->ac.type			= POWER_SUPPLY_TYPE_MAINS;
+	mbc->ac.properties		= power_props;
+	mbc->ac.num_properties		= ARRAY_SIZE(power_props);
+	mbc->ac.get_property		= ac_get_property;
+	mbc->ac.supplied_to		= mbc->pcf->pdata->batteries;
+	mbc->ac.num_supplicants		= mbc->pcf->pdata->num_batteries;
+
+	INIT_DELAYED_WORK(&mbc->charging_restart_work,
+				pcf50633_mbc_charging_restart);
+
 	ret = power_supply_register(&pdev->dev, &mbc->adapter);
 	if (ret) {
 		dev_err(mbc->pcf->dev, "failed to register adapter\n");
@@ -302,6 +443,15 @@
 		return ret;
 	}
 
+	ret = power_supply_register(&pdev->dev, &mbc->ac);
+	if (ret) {
+		dev_err(mbc->pcf->dev, "failed to register ac\n");
+		power_supply_unregister(&mbc->adapter);
+		power_supply_unregister(&mbc->usb);
+		kfree(mbc);
+		return ret;
+	}
+	
 	ret = sysfs_create_group(&pdev->dev.kobj, &mbc_attr_group);
 	if (ret)
 		dev_err(mbc->pcf->dev, "failed to create sysfs entries\n");
@@ -327,6 +477,8 @@
 	power_supply_unregister(&mbc->usb);
 	power_supply_unregister(&mbc->adapter);
 
+	cancel_delayed_work_sync(&mbc->charging_restart_work);
+
 	kfree(mbc);
 
 	return 0;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/regulator/core.c linux-2.6.29-rc3.owrt.om/drivers/regulator/core.c
--- linux-2.6.29-rc3.owrt/drivers/regulator/core.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/regulator/core.c	2009-05-10 22:28:00.000000000 +0200
@@ -1102,18 +1102,19 @@
 	struct regulator_dev *rdev = regulator->rdev;
 	int ret = 0;
 
-	mutex_lock(&rdev->mutex);
-	if (regulator->enabled == 1) {
-		ret = _regulator_disable(rdev);
-		if (ret == 0)
-			regulator->uA_load = 0;
-	} else if (WARN(regulator->enabled <= 0,
-			"unbalanced disables for supply %s\n",
-			regulator->supply_name))
-		ret = -EIO;
-	if (ret == 0)
-		regulator->enabled--;
-	mutex_unlock(&rdev->mutex);
+	if (!regulator->enabled) {
+		printk(KERN_ERR "%s: not in use by this consumer\n",
+			__func__);
+		WARN_ON(1);
+		return 0;
+	}
+
+	mutex_lock(&regulator->rdev->mutex);
+	regulator->enabled = 0;
+	regulator->uA_load = 0;
+	ret = _regulator_disable(regulator->rdev);
+	mutex_unlock(&regulator->rdev->mutex);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(regulator_disable);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/regulator/Kconfig linux-2.6.29-rc3.owrt.om/drivers/regulator/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/regulator/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/regulator/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -80,4 +80,10 @@
 	 Say Y here to support the voltage regulators and convertors
 	 on PCF50633
 
+config REGULATOR_PCF50606
+	bool "PCF50606 regulator driver"
+        depends on MFD_PCF50606
+	help
+	 Say Y here to support the voltage regulators and convertors
+	 on PCF50606
 endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/regulator/Makefile linux-2.6.29-rc3.owrt.om/drivers/regulator/Makefile
--- linux-2.6.29-rc3.owrt/drivers/regulator/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/regulator/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -12,5 +12,6 @@
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_DA903X)	+= da903x.o
 obj-$(CONFIG_REGULATOR_PCF50633) += pcf50633-regulator.o
+obj-$(CONFIG_REGULATOR_PCF50606) += pcf50606-regulator.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/regulator/pcf50606-regulator.c linux-2.6.29-rc3.owrt.om/drivers/regulator/pcf50606-regulator.c
--- linux-2.6.29-rc3.owrt/drivers/regulator/pcf50606-regulator.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/regulator/pcf50606-regulator.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,380 @@
+/* NXP PCF50606 PMIC Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte and Andy Green and Werner Almesberger
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/mfd/pcf50606/pmic.h>
+
+#define PCF50606_REGULATOR(_name, _id) 		\
+	{					\
+		.name = _name, 			\
+		.id = _id,			\
+		.ops = &pcf50606_regulator_ops,	\
+		.type = REGULATOR_VOLTAGE, 	\
+		.owner = THIS_MODULE, 		\
+	}
+
+static const u8 pcf50606_regulator_registers[PCF50606_NUM_REGULATORS] = {
+	[PCF50606_REGULATOR_DCD]	= PCF50606_REG_DCDC1,
+	[PCF50606_REGULATOR_DCDE]	= PCF50606_REG_DCDEC1,
+	[PCF50606_REGULATOR_DCUD]	= PCF50606_REG_DCUDC1,
+	[PCF50606_REGULATOR_D1REG]	= PCF50606_REG_D1REGC1,
+	[PCF50606_REGULATOR_D2REG]	= PCF50606_REG_D2REGC1,
+	[PCF50606_REGULATOR_D3REG]	= PCF50606_REG_D3REGC1,
+	[PCF50606_REGULATOR_LPREG]	= PCF50606_REG_LPREGC1,
+	[PCF50606_REGULATOR_IOREG]	= PCF50606_REG_IOREGC,
+};
+
+static u8 dcudc_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	if (millivolts > 5500)
+		return 0x1f;
+	if (millivolts <= 3300) {
+		millivolts -= 900;
+		return millivolts/300;
+	}
+	if (millivolts < 4000)
+		return 0x0f;
+	else {
+		millivolts -= 4000;
+		return millivolts/100;
+	}
+}
+
+static unsigned int dcudc_2voltage(u8 bits)
+{
+	bits &= 0x1f;
+	if (bits < 0x08)
+		return 900 + bits * 300;
+	else if (bits < 0x10)
+		return 3300;
+	else
+		return 4000 + bits * 100;
+}
+
+static u8 dcdec_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	else if (millivolts > 3300)
+		return 0x0f;
+
+	millivolts -= 900;
+	return millivolts/300;
+}
+
+static unsigned int dcdec_2voltage(u8 bits)
+{
+	bits &= 0x0f;
+	return 900 + bits*300;
+}
+
+static u8 dcdc_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	else if (millivolts > 3600)
+		return 0x1f;
+
+	if (millivolts < 1500) {
+		millivolts -= 900;
+		return millivolts/25;
+	} else {
+		millivolts -= 1500;
+		return 0x18 + millivolts/300;
+	}
+}
+
+static unsigned int dcdc_2voltage(u8 bits)
+{
+	bits &= 0x1f;
+	if ((bits & 0x18) == 0x18)
+		return 1500 + ((bits & 0x7) * 300);
+	else
+		return 900 + (bits * 25);
+}
+
+static u8 dx_voltage(unsigned int millivolts)
+{
+	if (millivolts < 900)
+		return 0;
+	else if (millivolts > 3300)
+		return 0x18;
+
+	millivolts -= 900;
+	return millivolts/100;
+}
+
+static unsigned int dx_2voltage(u8 bits)
+{
+	bits &= 0x1f;
+	return 900 + (bits * 100);
+}
+
+static int pcf50606_regulator_set_voltage(struct regulator_dev *rdev,
+						int min_uV, int max_uV)
+{
+	struct pcf50606 *pcf;
+	int regulator_id, millivolts, rc;
+	u8 volt_bits, regnr;
+
+	pcf = rdev_get_drvdata(rdev);
+
+	regulator_id = rdev_get_id(rdev);
+	if (regulator_id >= PCF50606_NUM_REGULATORS)
+		return -EINVAL;
+
+	millivolts = min_uV / 1000;
+
+	switch (regulator_id) {
+	case PCF50606_REGULATOR_DCD:
+		volt_bits = dcdc_voltage(millivolts);
+		rc = pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_DCDC1, 0x1f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCDE:
+		volt_bits = dcdec_voltage(millivolts);
+		rc = pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_DCDEC1, 0x0f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCUD:
+		volt_bits = dcudc_voltage(millivolts);
+		rc = pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_DCUDC1, 0x1f,
+				      volt_bits);
+		break;
+	case PCF50606_REGULATOR_D1REG:
+	case PCF50606_REGULATOR_D2REG:
+	case PCF50606_REGULATOR_D3REG:
+		regnr = PCF50606_REG_D1REGC1 +
+		       		(regulator_id - PCF50606_REGULATOR_D1REG);
+		volt_bits = dx_voltage(millivolts);
+		rc = pcf50606_reg_set_bit_mask(pcf, regnr, 0x1f, volt_bits);
+		break;
+	case PCF50606_REGULATOR_LPREG:
+		volt_bits = dx_voltage(millivolts);
+		rc = pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_LPREGC1, 0x1f,
+					      volt_bits);
+		break;
+	case PCF50606_REGULATOR_IOREG:
+		if (millivolts < 1800)
+			return -EINVAL;
+		volt_bits = dx_voltage(millivolts);
+		rc = pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_IOREGC, 0x1f,
+					      volt_bits);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
+static int pcf50606_regulator_get_voltage(struct regulator_dev *rdev)
+{
+	struct pcf50606 *pcf;
+	u8 volt_bits, regnr;
+	int rc = 0, regulator_id;
+
+
+	pcf = rdev_get_drvdata(rdev);
+
+	regulator_id = rdev_get_id(rdev);
+	if (regulator_id >= PCF50606_NUM_REGULATORS)
+		return -EINVAL;
+
+	switch (regulator_id) {
+	case PCF50606_REGULATOR_DCD:
+		volt_bits = pcf50606_reg_read(pcf, PCF50606_REG_DCDC1) & 0x1f;
+		rc = dcdc_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCDE:
+		volt_bits = pcf50606_reg_read(pcf, PCF50606_REG_DCDEC1) & 0x0f;
+		rc = dcdec_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_DCUD:
+		volt_bits = pcf50606_reg_read(pcf, PCF50606_REG_DCUDC1) & 0x1f;
+		rc = dcudc_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_D1REG:
+	case PCF50606_REGULATOR_D2REG:
+	case PCF50606_REGULATOR_D3REG:
+		regnr = PCF50606_REG_D1REGC1 + (regulator_id - PCF50606_REGULATOR_D1REG);
+		volt_bits = pcf50606_reg_read(pcf, regnr) & 0x1f;
+		if (volt_bits > 0x18)
+			volt_bits = 0x18;
+		rc = dx_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_LPREG:
+		volt_bits = pcf50606_reg_read(pcf, PCF50606_REG_LPREGC1) & 0x1f;
+		if (volt_bits > 0x18)
+			volt_bits = 0x18;
+		rc = dx_2voltage(volt_bits);
+		break;
+	case PCF50606_REGULATOR_IOREG:
+		volt_bits = pcf50606_reg_read(pcf, PCF50606_REG_IOREGC) & 0x1f;
+		if (volt_bits > 0x18)
+			volt_bits = 0x18;
+		rc = dx_2voltage(volt_bits);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return rc * 1000;
+
+}
+
+static int pcf50606_regulator_enable(struct regulator_dev *rdev)
+{
+	struct pcf50606 *pcf = rdev_get_drvdata(rdev);
+	int regulator_id;
+	u8 regnr;
+
+	regulator_id = rdev_get_id(rdev);
+	if (regulator_id >= PCF50606_NUM_REGULATORS)
+		return -EINVAL;
+	
+	regnr = pcf50606_regulator_registers[regulator_id];
+
+	return pcf50606_reg_set_bit_mask(pcf, regnr, 0xe0, 0xe0);
+}
+
+static int pcf50606_regulator_disable(struct regulator_dev *rdev)
+{
+	struct pcf50606 *pcf = rdev_get_drvdata(rdev);
+	int regulator_id;
+	u8 regnr;
+
+	regulator_id = rdev_get_id(rdev);
+	if (regulator_id >= PCF50606_NUM_REGULATORS)
+		return -EINVAL;
+
+	/* IOREG cannot be powered off since it powers the PMU I2C */
+	if (regulator_id == PCF50606_REGULATOR_IOREG)
+		return -EINVAL;
+	
+	regnr = pcf50606_regulator_registers[regulator_id];
+
+	return pcf50606_reg_set_bit_mask(pcf, regnr, 0xe0, 0);
+}
+
+static int pcf50606_regulator_is_enabled(struct regulator_dev *rdev)
+{
+	struct pcf50606 *pcf = rdev_get_drvdata(rdev);
+	int regulator_id = rdev_get_id(rdev);
+	u8 regnr, val;
+
+	regulator_id = rdev_get_id(rdev);
+	if (regulator_id >= PCF50606_NUM_REGULATORS)
+		return -EINVAL;
+
+	/* the *ENA register is always one after the *OUT register */
+	regnr = pcf50606_regulator_registers[regulator_id];
+	val = (pcf50606_reg_read(pcf, regnr) & 0xe0) >> 5;
+
+	/* PWREN1 = 1, PWREN2 = 1, see table 16 of datasheet */
+	if (val == 0 || val == 5)
+		return 0;
+
+	return 1;
+}
+
+static struct regulator_ops pcf50606_regulator_ops = {
+	.set_voltage = pcf50606_regulator_set_voltage,
+	.get_voltage = pcf50606_regulator_get_voltage,
+	.enable = pcf50606_regulator_enable,
+	.disable = pcf50606_regulator_disable,
+	.is_enabled = pcf50606_regulator_is_enabled,
+};
+
+static struct regulator_desc regulators[] = {
+	[PCF50606_REGULATOR_DCD] =
+		PCF50606_REGULATOR("dcd", PCF50606_REGULATOR_DCD),
+	[PCF50606_REGULATOR_DCDE] =
+		PCF50606_REGULATOR("dcde", PCF50606_REGULATOR_DCDE),
+	[PCF50606_REGULATOR_DCUD] =
+		PCF50606_REGULATOR("dcud", PCF50606_REGULATOR_DCUD),
+	[PCF50606_REGULATOR_D1REG] =
+		PCF50606_REGULATOR("d1reg", PCF50606_REGULATOR_D1REG),
+	[PCF50606_REGULATOR_D2REG] =
+		PCF50606_REGULATOR("d2reg", PCF50606_REGULATOR_D2REG),
+	[PCF50606_REGULATOR_D3REG] =
+		PCF50606_REGULATOR("d3reg", PCF50606_REGULATOR_D3REG),
+	[PCF50606_REGULATOR_LPREG] =
+		PCF50606_REGULATOR("lpreg", PCF50606_REGULATOR_LPREG),
+	[PCF50606_REGULATOR_IOREG] =
+		PCF50606_REGULATOR("ioreg", PCF50606_REGULATOR_IOREG),
+};
+
+static int __devinit pcf50606_regulator_probe(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev;
+	struct pcf50606 *pcf;
+
+	/* Already set by core driver */
+	pcf = platform_get_drvdata(pdev);
+
+	rdev = regulator_register(&regulators[pdev->id], &pdev->dev, pcf);
+	if (IS_ERR(rdev))
+		return PTR_ERR(rdev);
+
+	if (pcf->pdata->regulator_registered)
+		pcf->pdata->regulator_registered(pcf, pdev->id);
+
+	return 0;
+}
+
+static int __devexit pcf50606_regulator_remove(struct platform_device *pdev)
+{
+	struct regulator_dev *rdev = platform_get_drvdata(pdev);
+
+	regulator_unregister(rdev);
+
+	return 0;
+}
+
+static struct platform_driver pcf50606_regulator_driver = {
+	.driver = {
+		.name = "pcf50606-regltr",
+	},
+	.probe = pcf50606_regulator_probe,
+	.remove = __devexit_p(pcf50606_regulator_remove),
+};
+
+static int __init pcf50606_regulator_init(void)
+{
+	return platform_driver_register(&pcf50606_regulator_driver);
+}
+module_init(pcf50606_regulator_init);
+
+static void __exit pcf50606_regulator_exit(void)
+{
+	platform_driver_unregister(&pcf50606_regulator_driver);
+}
+module_exit(pcf50606_regulator_exit);
+
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_DESCRIPTION("PCF50606 regulator driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pcf50606-regulator");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/rtc/Kconfig linux-2.6.29-rc3.owrt.om/drivers/rtc/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/rtc/Kconfig	2009-05-10 22:08:44.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/rtc/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -223,6 +223,13 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-pcf8583.
 
+config RTC_DRV_PCF50606
+	depends on MFD_PCF50606
+	tristate "Philips PCF50606"
+	help
+	  If you say yes here you get support for the Philips PCF50606
+	  PMU's RTC.
+
 config RTC_DRV_M41T80
 	tristate "ST M41T65/M41T80/81/82/83/84/85/87"
 	help
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/rtc/Makefile linux-2.6.29-rc3.owrt.om/drivers/rtc/Makefile
--- linux-2.6.29-rc3.owrt/drivers/rtc/Makefile	2009-05-10 22:08:44.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/rtc/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -76,3 +76,4 @@
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
 obj-$(CONFIG_RTC_DRV_PCF50633)	+= rtc-pcf50633.o
+obj-$(CONFIG_RTC_DRV_PCF50606)	+= rtc-pcf50606.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/rtc/rtc-pcf50606.c linux-2.6.29-rc3.owrt.om/drivers/rtc/rtc-pcf50606.c
--- linux-2.6.29-rc3.owrt/drivers/rtc/rtc-pcf50606.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/rtc/rtc-pcf50606.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,335 @@
+/* NXP PCF50606 RTC Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte, Andy Green and Werner Almesberger
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/err.h>
+
+#include <linux/mfd/pcf50606/core.h>
+
+#define PCF50606_REG_RTCSC	0x0a /* Second */
+#define PCF50606_REG_RTCMN	0x0b /* Minute */
+#define PCF50606_REG_RTCHR	0x0c /* Hour */
+#define PCF50606_REG_RTCWD	0x0d /* Weekday */
+#define PCF50606_REG_RTCDT	0x0e /* Day */
+#define PCF50606_REG_RTCMT	0x0f /* Month */
+#define PCF50606_REG_RTCYR	0x10 /* Year */
+#define PCF50606_REG_RTCSCA	0x11 /* Alarm Second */
+#define PCF50606_REG_RTCMNA	0x12 /* Alarm Minute */
+#define PCF50606_REG_RTCHRA	0x13 /* Alarm Hour */
+#define PCF50606_REG_RTCWDA	0x14 /* Alarm Weekday */
+#define PCF50606_REG_RTCDTA	0x15 /* Alarm Day */
+#define PCF50606_REG_RTCMTA	0x16 /* Alarm Month */
+#define PCF50606_REG_RTCYRA	0x17 /* Alarm Year */
+
+enum pcf50606_time_indexes {
+	PCF50606_TI_SEC,
+	PCF50606_TI_MIN,
+	PCF50606_TI_HOUR,
+	PCF50606_TI_WKDAY,
+	PCF50606_TI_DAY,
+	PCF50606_TI_MONTH,
+	PCF50606_TI_YEAR,
+	PCF50606_TI_EXTENT /* always last */
+};
+
+struct pcf50606_time {
+	u_int8_t time[PCF50606_TI_EXTENT];
+};
+
+struct pcf50606_rtc {
+	int alarm_enabled;
+	int second_enabled;
+
+	struct pcf50606 *pcf;
+	struct rtc_device *rtc_dev;
+};
+
+static void pcf2rtc_time(struct rtc_time *rtc, struct pcf50606_time *pcf)
+{
+	rtc->tm_sec = bcd2bin(pcf->time[PCF50606_TI_SEC]);
+	rtc->tm_min = bcd2bin(pcf->time[PCF50606_TI_MIN]);
+	rtc->tm_hour = bcd2bin(pcf->time[PCF50606_TI_HOUR]);
+	rtc->tm_wday = bcd2bin(pcf->time[PCF50606_TI_WKDAY]);
+	rtc->tm_mday = bcd2bin(pcf->time[PCF50606_TI_DAY]);
+	rtc->tm_mon = bcd2bin(pcf->time[PCF50606_TI_MONTH]) - 1;
+	rtc->tm_year = bcd2bin(pcf->time[PCF50606_TI_YEAR]) + 100;
+}
+
+static void rtc2pcf_time(struct pcf50606_time *pcf, struct rtc_time *rtc)
+{
+	pcf->time[PCF50606_TI_SEC] = bin2bcd(rtc->tm_sec);
+	pcf->time[PCF50606_TI_MIN] = bin2bcd(rtc->tm_min);
+	pcf->time[PCF50606_TI_HOUR] = bin2bcd(rtc->tm_hour);
+	pcf->time[PCF50606_TI_WKDAY] = bin2bcd(rtc->tm_wday);
+	pcf->time[PCF50606_TI_DAY] = bin2bcd(rtc->tm_mday);
+	pcf->time[PCF50606_TI_MONTH] = bin2bcd(rtc->tm_mon + 1);
+	pcf->time[PCF50606_TI_YEAR] = bin2bcd(rtc->tm_year % 100);
+}
+
+static int
+pcf50606_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
+{
+	struct pcf50606_rtc *rtc = dev_get_drvdata(dev);
+
+	switch (cmd) {
+	case RTC_AIE_OFF:
+		rtc->alarm_enabled = 0;
+		pcf50606_irq_mask(rtc->pcf, PCF50606_IRQ_ALARM);
+		return 0;
+	case RTC_AIE_ON:
+		rtc->alarm_enabled = 1;
+		pcf50606_irq_unmask(rtc->pcf, PCF50606_IRQ_ALARM);
+		return 0;
+	case RTC_UIE_OFF:
+		rtc->second_enabled = 0;
+		pcf50606_irq_mask(rtc->pcf, PCF50606_IRQ_SECOND);
+		return 0;
+	case RTC_UIE_ON:
+		rtc->second_enabled = 1;
+		pcf50606_irq_unmask(rtc->pcf, PCF50606_IRQ_SECOND);
+		return 0;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static int pcf50606_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct pcf50606_rtc *rtc;
+	struct pcf50606_time pcf_tm;
+	int ret;
+
+	rtc = dev_get_drvdata(dev);
+
+	ret = pcf50606_read_block(rtc->pcf, PCF50606_REG_RTCSC,
+					    PCF50606_TI_EXTENT,
+					    &pcf_tm.time[0]);
+	if (ret != PCF50606_TI_EXTENT) {
+		dev_err(dev, "Failed to read time\n");
+		return -EIO;
+	}
+
+	dev_dbg(dev, "PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\n",
+		pcf_tm.time[PCF50606_TI_DAY],
+		pcf_tm.time[PCF50606_TI_MONTH],
+		pcf_tm.time[PCF50606_TI_YEAR],
+		pcf_tm.time[PCF50606_TI_HOUR],
+		pcf_tm.time[PCF50606_TI_MIN],
+		pcf_tm.time[PCF50606_TI_SEC]);
+
+	pcf2rtc_time(tm, &pcf_tm);
+
+	dev_dbg(dev, "RTC_TIME: %u.%u.%u %u:%u:%u\n",
+		tm->tm_mday, tm->tm_mon, tm->tm_year,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return rtc_valid_tm(tm);
+}
+
+static int pcf50606_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct pcf50606_rtc *rtc;
+	struct pcf50606_time pcf_tm;
+	int second_masked, alarm_masked, ret = 0;
+
+	rtc = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "RTC_TIME: %u.%u.%u %u:%u:%u\n",
+		tm->tm_mday, tm->tm_mon, tm->tm_year,
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	rtc2pcf_time(&pcf_tm, tm);
+
+	dev_dbg(dev, "PCF_TIME: %02x.%02x.%02x %02x:%02x:%02x\n",
+		pcf_tm.time[PCF50606_TI_DAY],
+		pcf_tm.time[PCF50606_TI_MONTH],
+		pcf_tm.time[PCF50606_TI_YEAR],
+		pcf_tm.time[PCF50606_TI_HOUR],
+		pcf_tm.time[PCF50606_TI_MIN],
+		pcf_tm.time[PCF50606_TI_SEC]);
+
+
+	second_masked = pcf50606_irq_mask_get(rtc->pcf, PCF50606_IRQ_SECOND);
+	alarm_masked = pcf50606_irq_mask_get(rtc->pcf, PCF50606_IRQ_ALARM);
+
+	if (!second_masked)
+		pcf50606_irq_mask(rtc->pcf, PCF50606_IRQ_SECOND);
+	if (!alarm_masked)
+		pcf50606_irq_mask(rtc->pcf, PCF50606_IRQ_ALARM);
+
+	/* Returns 0 on success */
+	ret = pcf50606_write_block(rtc->pcf, PCF50606_REG_RTCSC,
+					     PCF50606_TI_EXTENT,
+					     &pcf_tm.time[0]);
+
+	if (!second_masked)
+		pcf50606_irq_unmask(rtc->pcf, PCF50606_IRQ_SECOND);
+	if (!alarm_masked)
+		pcf50606_irq_unmask(rtc->pcf, PCF50606_IRQ_ALARM);
+
+	return ret;
+}
+
+static int pcf50606_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct pcf50606_rtc *rtc;
+	struct pcf50606_time pcf_tm;
+	int ret = 0;
+
+	rtc = dev_get_drvdata(dev);
+
+	alrm->enabled = rtc->alarm_enabled;
+
+	ret = pcf50606_read_block(rtc->pcf, PCF50606_REG_RTCSCA,
+				PCF50606_TI_EXTENT, &pcf_tm.time[0]);
+	if (ret != PCF50606_TI_EXTENT) {
+		dev_err(dev, "Failed to read time\n");
+		return -EIO;
+	}
+
+	pcf2rtc_time(&alrm->time, &pcf_tm);
+
+	return rtc_valid_tm(&alrm->time);
+}
+
+static int pcf50606_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct pcf50606_rtc *rtc;
+	struct pcf50606_time pcf_tm;
+	int alarm_masked, ret = 0;
+
+	rtc = dev_get_drvdata(dev);
+
+	rtc2pcf_time(&pcf_tm, &alrm->time);
+
+	/* do like mktime does and ignore tm_wday */
+	pcf_tm.time[PCF50606_TI_WKDAY] = 7;
+
+	alarm_masked = pcf50606_irq_mask_get(rtc->pcf, PCF50606_IRQ_ALARM);
+
+	/* disable alarm interrupt */
+	if (!alarm_masked)
+		pcf50606_irq_mask(rtc->pcf, PCF50606_IRQ_ALARM);
+
+	/* Returns 0 on success */
+	ret = pcf50606_write_block(rtc->pcf, PCF50606_REG_RTCSCA,
+				PCF50606_TI_EXTENT, &pcf_tm.time[0]);
+
+	if (!alarm_masked)
+		pcf50606_irq_unmask(rtc->pcf, PCF50606_IRQ_ALARM);
+
+	return ret;
+}
+
+static struct rtc_class_ops pcf50606_rtc_ops = {
+	.ioctl		= pcf50606_rtc_ioctl,
+	.read_time	= pcf50606_rtc_read_time,
+	.set_time	= pcf50606_rtc_set_time,
+	.read_alarm	= pcf50606_rtc_read_alarm,
+	.set_alarm	= pcf50606_rtc_set_alarm,
+};
+
+static void pcf50606_rtc_irq(int irq, void *data)
+{
+	struct pcf50606_rtc *rtc = data;
+
+	switch (irq) {
+	case PCF50606_IRQ_ALARM:
+		rtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);
+		break;
+	case PCF50606_IRQ_SECOND:
+		rtc_update_irq(rtc->rtc_dev, 1, RTC_UF | RTC_IRQF);
+		break;
+	}
+}
+
+static int __devinit pcf50606_rtc_probe(struct platform_device *pdev)
+{
+	struct pcf50606_subdev_pdata *pdata;
+	struct pcf50606_rtc *rtc;
+
+	
+	rtc = kzalloc(sizeof(*rtc), GFP_KERNEL);
+	if (!rtc)
+		return -ENOMEM;
+
+	pdata = pdev->dev.platform_data;
+	rtc->pcf = pdata->pcf;
+	platform_set_drvdata(pdev, rtc);
+	rtc->rtc_dev = rtc_device_register("pcf50606-rtc", &pdev->dev,
+				&pcf50606_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(rtc->rtc_dev)) {
+		kfree(rtc);
+		return PTR_ERR(rtc->rtc_dev);
+	}
+
+	pcf50606_register_irq(rtc->pcf, PCF50606_IRQ_ALARM,
+					pcf50606_rtc_irq, rtc);
+	pcf50606_register_irq(rtc->pcf, PCF50606_IRQ_SECOND,
+					pcf50606_rtc_irq, rtc);
+
+	return 0;
+}
+
+
+static int __devexit pcf50606_rtc_remove(struct platform_device *pdev)
+{
+	struct pcf50606_rtc *rtc;
+
+	rtc = platform_get_drvdata(pdev);
+	
+	pcf50606_free_irq(rtc->pcf, PCF50606_IRQ_ALARM);
+	pcf50606_free_irq(rtc->pcf, PCF50606_IRQ_SECOND);
+	
+	rtc_device_unregister(rtc->rtc_dev);
+
+	kfree(rtc);
+
+	return 0;
+}
+
+
+static struct platform_driver pcf50606_rtc_driver = {
+	.driver = {
+		.name = "pcf50606-rtc",
+	},
+	.probe = pcf50606_rtc_probe,
+	.remove = __devexit_p(pcf50606_rtc_remove),
+};
+
+static int __init pcf50606_rtc_init(void)
+{
+	return platform_driver_register(&pcf50606_rtc_driver);
+}
+module_init(pcf50606_rtc_init);
+
+static void __exit pcf50606_rtc_exit(void)
+{
+	platform_driver_unregister(&pcf50606_rtc_driver);
+}
+module_exit(pcf50606_rtc_exit);
+
+MODULE_DESCRIPTION("PCF50606 RTC driver");
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_LICENSE("GPL");
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/rtc/rtc-pcf50633.c linux-2.6.29-rc3.owrt.om/drivers/rtc/rtc-pcf50633.c
--- linux-2.6.29-rc3.owrt/drivers/rtc/rtc-pcf50633.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/rtc/rtc-pcf50633.c	2009-05-10 22:28:00.000000000 +0200
@@ -58,6 +58,7 @@
 struct pcf50633_rtc {
 	int alarm_enabled;
 	int second_enabled;
+	int alarm_pending;
 
 	struct pcf50633 *pcf;
 	struct rtc_device *rtc_dev;
@@ -70,7 +71,7 @@
 	rtc->tm_hour = bcd2bin(pcf->time[PCF50633_TI_HOUR]);
 	rtc->tm_wday = bcd2bin(pcf->time[PCF50633_TI_WKDAY]);
 	rtc->tm_mday = bcd2bin(pcf->time[PCF50633_TI_DAY]);
-	rtc->tm_mon = bcd2bin(pcf->time[PCF50633_TI_MONTH]);
+	rtc->tm_mon = bcd2bin(pcf->time[PCF50633_TI_MONTH]) - 1;
 	rtc->tm_year = bcd2bin(pcf->time[PCF50633_TI_YEAR]) + 100;
 }
 
@@ -81,7 +82,7 @@
 	pcf->time[PCF50633_TI_HOUR] = bin2bcd(rtc->tm_hour);
 	pcf->time[PCF50633_TI_WKDAY] = bin2bcd(rtc->tm_wday);
 	pcf->time[PCF50633_TI_DAY] = bin2bcd(rtc->tm_mday);
-	pcf->time[PCF50633_TI_MONTH] = bin2bcd(rtc->tm_mon);
+	pcf->time[PCF50633_TI_MONTH] = bin2bcd(rtc->tm_mon + 1);
 	pcf->time[PCF50633_TI_YEAR] = bin2bcd(rtc->tm_year % 100);
 }
 
@@ -209,6 +210,7 @@
 	rtc = dev_get_drvdata(dev);
 
 	alrm->enabled = rtc->alarm_enabled;
+	alrm->pending = rtc->alarm_pending;
 
 	ret = pcf50633_read_block(rtc->pcf, PCF50633_REG_RTCSCA,
 				PCF50633_TI_EXTENT, &pcf_tm.time[0]);
@@ -244,9 +246,12 @@
 	/* Returns 0 on success */
 	ret = pcf50633_write_block(rtc->pcf, PCF50633_REG_RTCSCA,
 				PCF50633_TI_EXTENT, &pcf_tm.time[0]);
+	if (!alrm->enabled)
+		rtc->alarm_pending = 0;
 
-	if (!alarm_masked)
+	if (!alarm_masked || alrm->enabled)
 		pcf50633_irq_unmask(rtc->pcf, PCF50633_IRQ_ALARM);
+	rtc->alarm_enabled = alrm->enabled;
 
 	return ret;
 }
@@ -267,6 +272,7 @@
 	switch (irq) {
 	case PCF50633_IRQ_ALARM:
 		rtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);
+		rtc->alarm_pending = 1;
 		break;
 	case PCF50633_IRQ_SECOND:
 		rtc_update_irq(rtc->rtc_dev, 1, RTC_UF | RTC_IRQF);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/serial/s3c2410.c linux-2.6.29-rc3.owrt.om/drivers/serial/s3c2410.c
--- linux-2.6.29-rc3.owrt/drivers/serial/s3c2410.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/serial/s3c2410.c	2009-05-10 22:28:00.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/serial.h>
 
 #include <asm/irq.h>
+
 #include <mach/hardware.h>
 
 #include <plat/regs-serial.h>
@@ -85,6 +86,7 @@
 
 static int s3c2410_serial_probe(struct platform_device *dev)
 {
+	dbg("s3c2410_serial_probe: dev=%p\n", dev);
 	return s3c24xx_serial_probe(dev, &s3c2410_uart_inf);
 }
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/serial/s3c6400.c linux-2.6.29-rc3.owrt.om/drivers/serial/s3c6400.c
--- linux-2.6.29-rc3.owrt/drivers/serial/s3c6400.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/serial/s3c6400.c	2009-05-10 22:28:00.000000000 +0200
@@ -102,6 +102,7 @@
 	.name		= "Samsung S3C6400 UART",
 	.type		= PORT_S3C6400,
 	.fifosize	= 64,
+	.has_divslot	= 1,
 	.rx_fifomask	= S3C2440_UFSTAT_RXMASK,
 	.rx_fifoshift	= S3C2440_UFSTAT_RXSHIFT,
 	.rx_fifofull	= S3C2440_UFSTAT_RXFULL,
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/serial/samsung.c linux-2.6.29-rc3.owrt.om/drivers/serial/samsung.c
--- linux-2.6.29-rc3.owrt/drivers/serial/samsung.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/serial/samsung.c	2009-05-10 22:28:00.000000000 +0200
@@ -50,6 +50,10 @@
 #include <mach/map.h>
 
 #include <plat/regs-serial.h>
+#if defined(CONFIG_MACH_NEO1973) && !defined(CONFIG_CPU_S3C6410)
+#include <mach/regs-gpio.h>
+#include <mach/regs-clock.h>
+#endif
 
 #include "samsung.h"
 
@@ -235,8 +239,8 @@
 		port->icount.rx++;
 
 		if (unlikely(uerstat & S3C2410_UERSTAT_ANY)) {
-			dbg("rxerr: port ch=0x%02x, rxs=0x%08x\n",
-			    ch, uerstat);
+			printk(KERN_DEBUG "rxerr: port=%d ch=0x%02x, rxs=0x%08x\n",
+			    port->line, ch, uerstat);
 
 			/* check for break */
 			if (uerstat & S3C2410_UERSTAT_BREAK) {
@@ -265,8 +269,8 @@
 		if (uart_handle_sysrq_char(port, ch))
 			goto ignore_char;
 
-		uart_insert_char(port, uerstat, S3C2410_UERSTAT_OVERRUN,
-				 ch, flag);
+		if ((uerstat & port->ignore_status_mask & ~S3C2410_UERSTAT_OVERRUN) == 0)
+			tty_insert_flip_char(tty, ch, flag);
 
  ignore_char:
 		continue;
@@ -508,6 +512,7 @@
 struct baud_calc {
 	struct s3c24xx_uart_clksrc	*clksrc;
 	unsigned int			 calc;
+	unsigned int			 divslot;
 	unsigned int			 quot;
 	struct clk			*src;
 };
@@ -517,6 +522,7 @@
 				   struct s3c24xx_uart_clksrc *clksrc,
 				   unsigned int baud)
 {
+	struct s3c24xx_uart_port *ourport = to_ourport(port);
 	unsigned long rate;
 
 	calc->src = clk_get(port->dev, clksrc->name);
@@ -527,8 +533,24 @@
 	rate /= clksrc->divisor;
 
 	calc->clksrc = clksrc;
-	calc->quot = (rate + (8 * baud)) / (16 * baud);
-	calc->calc = (rate / (calc->quot * 16));
+
+	if (ourport->info->has_divslot) {
+		unsigned long div = rate / baud;
+
+		/* The UDIVSLOT register on the newer UARTs allows us to
+		 * get a divisor adjustment of 1/16th on the baud clock.
+		 *
+		 * We don't keep the UDIVSLOT value (the 16ths we calculated
+		 * by not multiplying the baud by 16) as it is easy enough
+		 * to recalculate.
+		 */
+
+		calc->quot = div / 16;
+		calc->calc = rate / div;
+	} else {
+		calc->quot = (rate + (8 * baud)) / (16 * baud);
+		calc->calc = (rate / (calc->quot * 16));
+	}
 
 	calc->quot--;
 	return 1;
@@ -611,6 +633,30 @@
 	return best->quot;
 }
 
+/* udivslot_table[]
+ *
+ * This table takes the fractional value of the baud divisor and gives
+ * the recommended setting for the UDIVSLOT register.
+ */
+static u16 udivslot_table[16] = {
+	[0] = 0x0000,
+	[1] = 0x0080,
+	[2] = 0x0808,
+	[3] = 0x0888,
+	[4] = 0x2222,
+	[5] = 0x4924,
+	[6] = 0x4A52,
+	[7] = 0x54AA,
+	[8] = 0x5555,
+	[9] = 0xD555,
+	[10] = 0xD5D5,
+	[11] = 0xDDD5,
+	[12] = 0xDDDD,
+	[13] = 0xDFDD,
+	[14] = 0xDFDF,
+	[15] = 0xFFDF,
+};
+
 static void s3c24xx_serial_set_termios(struct uart_port *port,
 				       struct ktermios *termios,
 				       struct ktermios *old)
@@ -623,6 +669,7 @@
 	unsigned int baud, quot;
 	unsigned int ulcon;
 	unsigned int umcon;
+	unsigned int udivslot = 0;
 
 	/*
 	 * We don't support modem control lines.
@@ -644,6 +691,7 @@
 	/* check to see if we need  to change clock source */
 
 	if (ourport->clksrc != clksrc || ourport->baudclk != clk) {
+		dbg("selecting clock %p\n", clk);
 		s3c24xx_serial_setsource(port, clksrc);
 
 		if (ourport->baudclk != NULL && !IS_ERR(ourport->baudclk)) {
@@ -658,6 +706,13 @@
 		ourport->baudclk_rate = clk ? clk_get_rate(clk) : 0;
 	}
 
+	if (ourport->info->has_divslot) {
+		unsigned int div = ourport->baudclk_rate / baud;
+
+		udivslot = udivslot_table[div & 15];
+		dbg("udivslot = %04x (div %d)\n", udivslot, div & 15);
+	}
+
 	switch (termios->c_cflag & CSIZE) {
 	case CS5:
 		dbg("config: 5bits/char\n");
@@ -697,12 +752,16 @@
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	dbg("setting ulcon to %08x, brddiv to %d\n", ulcon, quot);
+	dbg("setting ulcon to %08x, brddiv to %d, udivslot %08x\n",
+	    ulcon, quot, udivslot);
 
 	wr_regl(port, S3C2410_ULCON, ulcon);
 	wr_regl(port, S3C2410_UBRDIV, quot);
 	wr_regl(port, S3C2410_UMCON, umcon);
 
+	if (ourport->info->has_divslot)
+		wr_regl(port, S3C2443_DIVSLOT, udivslot);
+
 	dbg("uart: ulcon = 0x%08x, ucon = 0x%08x, ufcon = 0x%08x\n",
 	    rd_regl(port, S3C2410_ULCON),
 	    rd_regl(port, S3C2410_UCON),
@@ -887,6 +946,70 @@
 #endif
 };
 
+#ifdef CONFIG_MACH_NEO1973_GTA02
+static void s3c24xx_serial_force_debug_port_up(void)
+{
+	struct s3c24xx_uart_port *ourport = &s3c24xx_serial_ports[
+							 CONFIG_DEBUG_S3C_UART];
+	struct s3c24xx_uart_clksrc *clksrc = NULL;
+	struct clk *clk = NULL;
+	unsigned long tmp;
+
+	s3c24xx_serial_getclk(&ourport->port, &clksrc, &clk, 115200);
+
+	tmp = __raw_readl(S3C2410_CLKCON);
+
+	/* re-start uart clocks */
+	tmp |= S3C2410_CLKCON_UART0;
+	tmp |= S3C2410_CLKCON_UART1;
+	tmp |= S3C2410_CLKCON_UART2;
+
+	__raw_writel(tmp, S3C2410_CLKCON);
+	udelay(10);
+
+	s3c24xx_serial_setsource(&ourport->port, clksrc);
+
+	if (ourport->baudclk != NULL && !IS_ERR(ourport->baudclk)) {
+		clk_disable(ourport->baudclk);
+		ourport->baudclk  = NULL;
+	}
+
+	clk_enable(clk);
+
+	ourport->clksrc = clksrc;
+	ourport->baudclk = clk;
+}
+
+static void s3c2410_printascii(const char *sz)
+{
+	struct s3c24xx_uart_port *ourport = &s3c24xx_serial_ports[
+							 CONFIG_DEBUG_S3C_UART];
+	struct uart_port *port = &ourport->port;
+
+	/* 8 N 1 */
+	wr_regl(port, S3C2410_ULCON, (rd_regl(port, S3C2410_ULCON)) | 3);
+	/* polling mode */
+	wr_regl(port, S3C2410_UCON, (rd_regl(port, S3C2410_UCON) & ~0xc0f) | 5);
+	/* disable FIFO */
+	wr_regl(port, S3C2410_UFCON, (rd_regl(port, S3C2410_UFCON) & ~0x01));
+	/* fix baud rate */
+	wr_regl(port, S3C2410_UBRDIV, 26);
+
+	while (*sz) {
+		int timeout = 10000000;
+
+		/* spin on it being busy */
+		while ((!(rd_regl(port, S3C2410_UTRSTAT) & 2)) && timeout--)
+			;
+
+		/* transmit register */
+		wr_regl(port, S3C2410_UTXH, *sz);
+
+		sz++;
+	}
+}
+#endif
+
 /* s3c24xx_serial_resetport
  *
  * wrapper to call the specific reset for this port (reset the fifos
@@ -937,13 +1060,17 @@
 		struct ktermios *termios;
 		struct tty_struct *tty;
 
-		if (uport->info == NULL)
+		if (uport->info == NULL) {
+			printk(KERN_WARNING "%s: info NULL\n", __func__);
 			goto exit;
+		}
 
 		tty = uport->info->port.tty;
 
-		if (tty == NULL)
+		if (tty == NULL) {
+			printk(KERN_WARNING "%s: tty is NULL\n", __func__);
 			goto exit;
+		}
 
 		termios = tty->termios;
 
@@ -1092,6 +1219,7 @@
 
 	ourport = &s3c24xx_serial_ports[probe_index];
 	probe_index++;
+	init_resume_dependency_list(&ourport->resume_dependency);
 
 	dbg("%s: initialising port %p...\n", __func__, ourport);
 
@@ -1148,6 +1276,16 @@
 	return 0;
 }
 
+void s3c24xx_serial_register_resume_dependency(struct resume_dependency *
+					      resume_dependency, int uart_index)
+{
+	struct s3c24xx_uart_port *ourport = &s3c24xx_serial_ports[uart_index];
+
+	register_resume_dependency(&ourport->resume_dependency,
+							     resume_dependency);
+}
+EXPORT_SYMBOL(s3c24xx_serial_register_resume_dependency);
+
 static int s3c24xx_serial_resume(struct platform_device *dev)
 {
 	struct uart_port *port = s3c24xx_dev_to_port(&dev->dev);
@@ -1159,6 +1297,9 @@
 		clk_disable(ourport->clk);
 
 		uart_resume_port(&s3c24xx_uart_drv, port);
+
+		callback_all_resume_dependencies(&ourport->resume_dependency);
+
 	}
 
 	return 0;
@@ -1169,6 +1310,12 @@
 			struct s3c24xx_uart_info *info)
 {
 	dbg("s3c24xx_serial_init(%p,%p)\n", drv, info);
+#ifdef CONFIG_MACH_NEO1973_GTA02
+	/* set up the emergency debug UART functions */
+
+	printk_emergency_debug_spew_init = s3c24xx_serial_force_debug_port_up;
+	printk_emergency_debug_spew_send_string = s3c2410_printascii;
+#endif
 
 #ifdef CONFIG_PM
 	drv->suspend = s3c24xx_serial_suspend;
@@ -1208,6 +1355,13 @@
 #ifdef CONFIG_SERIAL_SAMSUNG_CONSOLE
 
 static struct uart_port *cons_uart;
+static int cons_silenced;
+
+void s3c24xx_serial_console_set_silence(int silenced)
+{
+	cons_silenced = silenced;
+}
+EXPORT_SYMBOL(s3c24xx_serial_console_set_silence);
 
 static int
 s3c24xx_serial_console_txrdy(struct uart_port *port, unsigned int ufcon)
@@ -1232,9 +1386,21 @@
 s3c24xx_serial_console_putchar(struct uart_port *port, int ch)
 {
 	unsigned int ufcon = rd_regl(cons_uart, S3C2410_UFCON);
+	unsigned int umcon = rd_regl(cons_uart, S3C2410_UMCON);
+
+	if (cons_silenced)
+		return;
+
+	/* If auto HW flow control enabled, temporarily turn it off */
+	if (umcon & S3C2410_UMCOM_AFC)
+		wr_regl(port, S3C2410_UMCON, (umcon & !S3C2410_UMCOM_AFC));
+
 	while (!s3c24xx_serial_console_txrdy(port, ufcon))
 		barrier();
 	wr_regb(cons_uart, S3C2410_UTXH, ch);
+
+	if (umcon & S3C2410_UMCOM_AFC)
+		wr_regl(port, S3C2410_UMCON, umcon);
 }
 
 static void
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/serial/samsung.h linux-2.6.29-rc3.owrt.om/drivers/serial/samsung.h
--- linux-2.6.29-rc3.owrt/drivers/serial/samsung.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/serial/samsung.h	2009-05-10 22:28:00.000000000 +0200
@@ -10,6 +10,8 @@
  * published by the Free Software Foundation.
 */
 
+#include <linux/resume-dependency.h>
+
 struct s3c24xx_uart_info {
 	char			*name;
 	unsigned int		type;
@@ -21,6 +23,10 @@
 	unsigned long		tx_fifoshift;
 	unsigned long		tx_fifofull;
 
+	/* uart port features */
+
+	unsigned int		has_divslot:1;
+
 	/* clock source control */
 
 	int (*get_clksrc)(struct uart_port *, struct s3c24xx_uart_clksrc *clk);
@@ -48,6 +54,8 @@
 #ifdef CONFIG_CPU_FREQ
 	struct notifier_block		freq_transition;
 #endif
+
+	struct resume_dependency	resume_dependency;
 };
 
 /* conversion functions */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/spi/Kconfig linux-2.6.29-rc3.owrt.om/drivers/spi/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/spi/Kconfig	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/spi/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -257,6 +257,15 @@
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
+config SPI_S3C64XX_GPIO
+	tristate "Samsung S3C64XX series SPI by GPIO"
+	depends on ARCH_S3C64XX && EXPERIMENTAL
+	select SPI_BITBANG
+	help
+	  SPI driver for Samsung S3C64XX series ARM SoCs using
+	  GPIO lines to provide the SPI bus. This can be used where
+	  the inbuilt hardware cannot provide the transfer mode, or
+	  where the board is using non hardware connected pins.
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/spi/Makefile linux-2.6.29-rc3.owrt.om/drivers/spi/Makefile
--- linux-2.6.29-rc3.owrt/drivers/spi/Makefile	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/spi/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -31,6 +31,7 @@
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_S3C64XX_GPIO)		+= spi_s3c64xx_gpio.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/spi/spi_bitbang.c linux-2.6.29-rc3.owrt.om/drivers/spi/spi_bitbang.c
--- linux-2.6.29-rc3.owrt/drivers/spi/spi_bitbang.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/spi/spi_bitbang.c	2009-05-10 22:28:00.000000000 +0200
@@ -264,6 +264,123 @@
  * Drivers can provide word-at-a-time i/o primitives, or provide
  * transfer-at-a-time ones to leverage dma or fifo hardware.
  */
+
+/* Synchronous non blocking transfer */ 
+int
+spi_bitbang_transfer_sync(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_bitbang *bitbang = spi_master_get_devdata(spi->master);
+	struct spi_transfer *t;
+	unsigned long flags;
+	int cs_change = 1;
+	int status;
+	int nsecs;
+	int (*setup_transfer)(struct spi_device *, struct spi_transfer *);
+
+	/* FIXME this is made-up ... the correct value is known to
+	 * word-at-a-time bitbang code, and presumably chipselect()
+	 * should enforce these requirements too?
+	 */
+	nsecs = 100;
+	cs_change = 1;
+	status = 0;
+	setup_transfer = NULL;
+
+	local_irq_save(flags);
+	list_for_each_entry (t, &m->transfers, transfer_list) {
+		/* override or restore speed and wordsize */
+		if (t->speed_hz || t->bits_per_word) {
+			setup_transfer = bitbang->setup_transfer;
+			if (!setup_transfer) {
+				status = -ENOPROTOOPT;
+				break;
+			}
+		}
+		if (setup_transfer) {
+			status = setup_transfer(spi, t);
+			if (status < 0)
+				break;
+		}
+		
+		/* set up default clock polarity, and activate chip;
+		 * this implicitly updates clock and spi modes as
+		 * previously recorded for this device via setup().
+		 * (and also deselects any other chip that might be
+		 * selected ...)
+		 */
+		
+		if (cs_change) {
+			bitbang->chipselect(spi, BITBANG_CS_ACTIVE);
+			ndelay(nsecs);
+		}
+
+		cs_change = t->cs_change;
+		if (!t->tx_buf && !t->rx_buf && t->len) {
+			status = -EINVAL;
+			break;
+		}
+		
+		/* transfer data.  the lower level code handles any
+		 * new dma mappings it needs. our caller always gave
+		 * us dma-safe buffers.
+		 */
+		if (t->len) {
+			/* REVISIT dma API still needs a designated
+			 * DMA_ADDR_INVALID; ~0 might be better.
+			 */
+			if (!m->is_dma_mapped)
+				t->rx_dma = t->tx_dma = 0;
+			status = bitbang->txrx_bufs(spi, t);
+		}
+
+		if (status > 0)
+			m->actual_length += status;
+		if (status != t->len) {
+			/* always report some kind of error */
+			if (status >= 0)
+				status = -EREMOTEIO;
+			break;
+		}
+		status = 0;
+			/* protocol tweaks before next transfer */
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+			if (!cs_change)
+			continue;
+		if (t->transfer_list.next == &m->transfers)
+			break;
+			/* sometimes a short mid-message deselect of the chip
+		 * may be needed to terminate a mode or command
+		 */
+		ndelay(nsecs);
+		bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
+		ndelay(nsecs);
+	}
+	
+	m->status = status;
+	if (m->complete)
+		m->complete(m->context);
+
+	/* restore speed and wordsize */
+	if (setup_transfer)
+		setup_transfer(spi, NULL);
+
+	/* normally deactivate chipselect ... unless no error and
+	 * cs_change has hinted that the next message will probably
+	 * be for this chip too.
+	 */
+	if (!(status == 0 && cs_change)) {
+		ndelay(nsecs);
+		bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
+		ndelay(nsecs);
+	}
+
+	local_irq_restore(flags);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(spi_bitbang_transfer_sync);
+
 static void bitbang_work(struct work_struct *work)
 {
 	struct spi_bitbang	*bitbang =
@@ -274,120 +391,13 @@
 	bitbang->busy = 1;
 	while (!list_empty(&bitbang->queue)) {
 		struct spi_message	*m;
-		struct spi_device	*spi;
-		unsigned		nsecs;
-		struct spi_transfer	*t = NULL;
-		unsigned		tmp;
-		unsigned		cs_change;
-		int			status;
-		int			(*setup_transfer)(struct spi_device *,
-						struct spi_transfer *);
 
 		m = container_of(bitbang->queue.next, struct spi_message,
 				queue);
 		list_del_init(&m->queue);
-		spin_unlock_irqrestore(&bitbang->lock, flags);
-
-		/* FIXME this is made-up ... the correct value is known to
-		 * word-at-a-time bitbang code, and presumably chipselect()
-		 * should enforce these requirements too?
-		 */
-		nsecs = 100;
-
-		spi = m->spi;
-		tmp = 0;
-		cs_change = 1;
-		status = 0;
-		setup_transfer = NULL;
-
-		list_for_each_entry (t, &m->transfers, transfer_list) {
-
-			/* override or restore speed and wordsize */
-			if (t->speed_hz || t->bits_per_word) {
-				setup_transfer = bitbang->setup_transfer;
-				if (!setup_transfer) {
-					status = -ENOPROTOOPT;
-					break;
-				}
-			}
-			if (setup_transfer) {
-				status = setup_transfer(spi, t);
-				if (status < 0)
-					break;
-			}
-
-			/* set up default clock polarity, and activate chip;
-			 * this implicitly updates clock and spi modes as
-			 * previously recorded for this device via setup().
-			 * (and also deselects any other chip that might be
-			 * selected ...)
-			 */
-			if (cs_change) {
-				bitbang->chipselect(spi, BITBANG_CS_ACTIVE);
-				ndelay(nsecs);
-			}
-			cs_change = t->cs_change;
-			if (!t->tx_buf && !t->rx_buf && t->len) {
-				status = -EINVAL;
-				break;
-			}
-
-			/* transfer data.  the lower level code handles any
-			 * new dma mappings it needs. our caller always gave
-			 * us dma-safe buffers.
-			 */
-			if (t->len) {
-				/* REVISIT dma API still needs a designated
-				 * DMA_ADDR_INVALID; ~0 might be better.
-				 */
-				if (!m->is_dma_mapped)
-					t->rx_dma = t->tx_dma = 0;
-				status = bitbang->txrx_bufs(spi, t);
-			}
-			if (status > 0)
-				m->actual_length += status;
-			if (status != t->len) {
-				/* always report some kind of error */
-				if (status >= 0)
-					status = -EREMOTEIO;
-				break;
-			}
-			status = 0;
-
-			/* protocol tweaks before next transfer */
-			if (t->delay_usecs)
-				udelay(t->delay_usecs);
-
-			if (!cs_change)
-				continue;
-			if (t->transfer_list.next == &m->transfers)
-				break;
-
-			/* sometimes a short mid-message deselect of the chip
-			 * may be needed to terminate a mode or command
-			 */
-			ndelay(nsecs);
-			bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
-			ndelay(nsecs);
-		}
-
-		m->status = status;
-		m->complete(m->context);
-
-		/* restore speed and wordsize */
-		if (setup_transfer)
-			setup_transfer(spi, NULL);
-
-		/* normally deactivate chipselect ... unless no error and
-		 * cs_change has hinted that the next message will probably
-		 * be for this chip too.
-		 */
-		if (!(status == 0 && cs_change)) {
-			ndelay(nsecs);
-			bitbang->chipselect(spi, BITBANG_CS_INACTIVE);
-			ndelay(nsecs);
-		}
 
+		spin_unlock_irqrestore(&bitbang->lock, flags);
+		spi_bitbang_transfer_sync(m->spi, m);
 		spin_lock_irqsave(&bitbang->lock, flags);
 	}
 	bitbang->busy = 0;
@@ -459,6 +469,9 @@
 
 	if (!bitbang->master->transfer)
 		bitbang->master->transfer = spi_bitbang_transfer;
+	if (!bitbang->master->transfer_sync && bitbang->non_blocking_transfer)
+		bitbang->master->transfer_sync = spi_bitbang_transfer_sync;
+
 	if (!bitbang->txrx_bufs) {
 		bitbang->use_dma = 0;
 		bitbang->txrx_bufs = spi_bitbang_bufs;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/spi/spi_s3c24xx_gpio.c linux-2.6.29-rc3.owrt.om/drivers/spi/spi_s3c24xx_gpio.c
--- linux-2.6.29-rc3.owrt/drivers/spi/spi_s3c24xx_gpio.c	2009-05-10 22:04:49.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/spi/spi_s3c24xx_gpio.c	2009-05-10 22:28:00.000000000 +0200
@@ -91,7 +91,7 @@
 	struct s3c2410_spigpio *sg = spidev_to_sg(dev);
 
 	if (sg->info && sg->info->chip_select)
-		(sg->info->chip_select)(sg->info, value);
+		(sg->info->chip_select)(sg->info, dev->chip_select, value);
 }
 
 static int s3c2410_spigpio_probe(struct platform_device *dev)
@@ -112,14 +112,17 @@
 
 	platform_set_drvdata(dev, sp);
 
-	/* copy in the plkatform data */
+	/* copy in the platform data */
 	info = sp->info = dev->dev.platform_data;
 
+	master->num_chipselect = info->num_chipselect;
+
 	/* setup spi bitbang adaptor */
 	sp->bitbang.master = spi_master_get(master);
 	sp->bitbang.master->bus_num = info->bus_num;
 	sp->bitbang.master->num_chipselect = info->num_chipselect;
 	sp->bitbang.chipselect = s3c2410_spigpio_chipselect;
+	sp->bitbang.non_blocking_transfer = info->non_blocking_transfer;
 
 	sp->bitbang.txrx_word[SPI_MODE_0] = s3c2410_spigpio_txrx_mode0;
 	sp->bitbang.txrx_word[SPI_MODE_1] = s3c2410_spigpio_txrx_mode1;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/spi/spi_s3c64xx_gpio.c linux-2.6.29-rc3.owrt.om/drivers/spi/spi_s3c64xx_gpio.c
--- linux-2.6.29-rc3.owrt/drivers/spi/spi_s3c64xx_gpio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/spi/spi_s3c64xx_gpio.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,187 @@
+/* linux/drivers/spi/spi_s3c64xx_gpio.c
+ *
+ * Copyright (c) 2009 Openmoko Inc.
+ * Author: Matt Hsu <matt_hsu@openmoko.org>
+ *
+ * S3C64XX GPIO-SPI driver.
+ * This driver is based on spi_s3c24xx_gpio.c
+ *
+ * Copyright (c) 2006 Ben Dooks
+ * Copyright (c) 2006 Simtec Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <plat/gpio-cfg.h>
+#include <mach/spi-gpio.h>
+
+struct s3c64xx_spigpio {
+	struct spi_bitbang 		bitbang;
+	struct s3c64xx_spigpio_info 	*info;
+	struct platform_device 		*dev;
+};
+
+static inline struct s3c64xx_spigpio *spidev_to_sg(struct spi_device *spi)
+{
+	return dev_get_drvdata(&spi->master->dev);
+}
+
+static inline void setsck(struct spi_device *dev, int on)
+{
+	struct s3c64xx_spigpio *sg = spidev_to_sg(dev);
+	gpio_direction_output(sg->info->pin_clk, on ? 1 : 0);
+}
+
+static inline void setmosi(struct spi_device *dev, int on)
+{
+	struct s3c64xx_spigpio *sg = spidev_to_sg(dev);
+	gpio_direction_output(sg->info->pin_mosi, on ? 1 : 0);
+}
+
+static inline u32 getmiso(struct spi_device *dev)
+{
+	struct s3c64xx_spigpio *sg = spidev_to_sg(dev);
+	return gpio_direction_input(sg->info->pin_miso) ? 1 : 0;
+}
+
+#define spidelay(x) ndelay(x)
+
+#define	EXPAND_BITBANG_TXRX
+#include <linux/spi/spi_bitbang.h>
+
+static u32 s3c64xx_spigpio_txrx_mode0(struct spi_device *spi,
+				      unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
+}
+
+static u32 s3c64xx_spigpio_txrx_mode1(struct spi_device *spi,
+				      unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
+}
+
+static u32 s3c64xx_spigpio_txrx_mode2(struct spi_device *spi,
+				      unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
+}
+
+static u32 s3c64xx_spigpio_txrx_mode3(struct spi_device *spi,
+				      unsigned nsecs, u32 word, u8 bits)
+{
+	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
+}
+static void s3c64xx_spigpio_chipselect(struct spi_device *dev, int value)
+{
+	struct s3c64xx_spigpio *sg = spidev_to_sg(dev);
+
+	if (sg && sg->info && sg->info->chip_select)
+		(sg->info->chip_select)(sg->info, dev->chip_select, value);
+}
+
+static int s3c64xx_spigpio_probe(struct platform_device *dev)
+{
+	struct s3c64xx_spigpio_info *info;
+	struct spi_master	*master;
+	struct s3c64xx_spigpio 	*spi;
+
+	int ret;
+
+	master = spi_alloc_master(&dev->dev, sizeof(struct s3c64xx_spigpio));
+	if (master == NULL) {
+		dev_err(&dev->dev, "failed to allocate spi master\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	spi = spi_master_get_devdata(master);
+
+	/* copy in the platform data */
+	info = spi->info = dev->dev.platform_data;
+
+	master->num_chipselect = info->num_chipselect;
+
+	/* setup spi bitbang adaptor */
+	spi->bitbang.master = spi_master_get(master);
+	spi->bitbang.master->bus_num = info->bus_num;
+
+	spi->bitbang.chipselect = s3c64xx_spigpio_chipselect;
+
+	spi->bitbang.txrx_word[SPI_MODE_0] = s3c64xx_spigpio_txrx_mode0;
+	spi->bitbang.txrx_word[SPI_MODE_1] = s3c64xx_spigpio_txrx_mode1;
+	spi->bitbang.txrx_word[SPI_MODE_2] = s3c64xx_spigpio_txrx_mode2;
+	spi->bitbang.txrx_word[SPI_MODE_3] = s3c64xx_spigpio_txrx_mode3;
+
+	/* set state of spi pins. */
+	gpio_direction_output(info->pin_clk, 0);
+	s3c_gpio_cfgpin(info->pin_clk, S3C_GPIO_OUTPUT);
+
+	dev_set_drvdata(&master->dev, spi);
+
+	ret = spi_bitbang_start(&spi->bitbang);
+	if (ret)
+		goto err_no_bitbang;
+
+	return 0;
+
+ err_no_bitbang:
+	spi_master_put(spi->bitbang.master);
+ err:
+	return ret;
+}
+
+static int s3c64xx_spigpio_remove(struct platform_device *dev)
+{
+	struct s3c64xx_spigpio *sp = platform_get_drvdata(dev);
+
+	spi_bitbang_stop(&sp->bitbang);
+	spi_master_put(sp->bitbang.master);
+
+	return 0;
+}
+
+#define s3c64xx_spigpio_suspend NULL
+#define s3c64xx_spigpio_resume NULL
+
+static struct platform_driver s3c64xx_spigpio_drv = {
+	.probe		= s3c64xx_spigpio_probe,
+	.remove		= s3c64xx_spigpio_remove,
+	.suspend	= s3c64xx_spigpio_suspend,
+	.resume		= s3c64xx_spigpio_resume,
+	.driver		= {
+		.name	= "spi_s3c64xx_gpio",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init s3c64xx_spigpio_init(void)
+{
+	return platform_driver_register(&s3c64xx_spigpio_drv);
+}
+
+static void __exit s3c64xx_spigpio_exit(void)
+{
+	platform_driver_unregister(&s3c64xx_spigpio_drv);
+}
+
+module_init(s3c64xx_spigpio_init);
+module_exit(s3c64xx_spigpio_exit);
+
+MODULE_DESCRIPTION("S3C64XX GPIO-SPI Driver");
+MODULE_AUTHOR("Matt Hsu, <matt_hsu@openmoko.org>");
+MODULE_LICENSE("GPLv2");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/alarm.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/alarm.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/alarm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/alarm.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,567 @@
+/* drivers/rtc/alarm.c
+ *
+ * Copyright (C) 2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/mach/time.h>
+#include <linux/android_alarm.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/spinlock.h>
+#include <linux/sysdev.h>
+#include <linux/wakelock.h>
+
+#define ANDROID_ALARM_PRINT_ERRORS (1U << 0)
+#define ANDROID_ALARM_PRINT_INIT_STATUS (1U << 1)
+#define ANDROID_ALARM_PRINT_INFO (1U << 2)
+#define ANDROID_ALARM_PRINT_IO (1U << 3)
+#define ANDROID_ALARM_PRINT_INT (1U << 4)
+#define ANDROID_ALARM_PRINT_FLOW (1U << 5)
+
+#if 0
+#define ANDROID_ALARM_DPRINTF_MASK (~0)
+#define ANDROID_ALARM_DPRINTF(debug_level_mask, args...) \
+	do { \
+		if (ANDROID_ALARM_DPRINTF_MASK & debug_level_mask) { \
+			printk(args); \
+		} \
+	} while (0)
+#else
+#define ANDROID_ALARM_DPRINTF(args...)
+#endif
+
+#define ANDROID_ALARM_WAKEUP_MASK ( \
+	ANDROID_ALARM_RTC_WAKEUP_MASK | \
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+
+/* support old usespace code */
+#define ANDROID_ALARM_SET_OLD               _IOW('a', 2, time_t) /* set alarm */
+#define ANDROID_ALARM_SET_AND_WAIT_OLD      _IOW('a', 3, time_t)
+
+static struct rtc_device *alarm_rtc_dev;
+static int alarm_opened;
+static DEFINE_SPINLOCK(alarm_slock);
+static DEFINE_MUTEX(alarm_setrtc_mutex);
+static struct wake_lock alarm_wake_lock;
+static struct wake_lock alarm_rtc_wake_lock;
+static DECLARE_WAIT_QUEUE_HEAD(alarm_wait_queue);
+static uint32_t alarm_pending;
+static uint32_t alarm_enabled;
+static uint32_t wait_pending;
+static struct platform_device *alarm_platform_dev;
+static struct hrtimer alarm_timer[ANDROID_ALARM_TYPE_COUNT];
+static struct timespec alarm_time[ANDROID_ALARM_TYPE_COUNT];
+static struct timespec elapsed_rtc_delta;
+
+static void alarm_start_hrtimer(enum android_alarm_type alarm_type)
+{
+	struct timespec hr_alarm_time;
+	if (!(alarm_enabled & (1U << alarm_type)))
+		return;
+	hr_alarm_time = alarm_time[alarm_type];
+	if (alarm_type == ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP ||
+	    alarm_type == ANDROID_ALARM_ELAPSED_REALTIME)
+		set_normalized_timespec(&hr_alarm_time,
+			hr_alarm_time.tv_sec + elapsed_rtc_delta.tv_sec,
+			hr_alarm_time.tv_nsec + elapsed_rtc_delta.tv_nsec);
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
+		"alarm start hrtimer %d at %ld.%09ld\n",
+		alarm_type, hr_alarm_time.tv_sec, hr_alarm_time.tv_nsec);
+	hrtimer_start(&alarm_timer[alarm_type],
+		      timespec_to_ktime(hr_alarm_time), HRTIMER_MODE_ABS);
+}
+
+static long alarm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rv = 0;
+	unsigned long flags;
+	int i;
+	struct timespec new_alarm_time;
+	struct timespec new_rtc_time;
+	struct timespec tmp_time;
+	struct rtc_time rtc_new_rtc_time;
+	enum android_alarm_type alarm_type = ANDROID_ALARM_IOCTL_TO_TYPE(cmd);
+	uint32_t alarm_type_mask = 1U << alarm_type;
+
+	if (alarm_type >= ANDROID_ALARM_TYPE_COUNT)
+		return -EINVAL;
+
+	if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_GET_TIME(0)) {
+		if ((file->f_flags & O_ACCMODE) == O_RDONLY)
+			return -EPERM;
+		if (file->private_data == NULL &&
+		    cmd != ANDROID_ALARM_SET_RTC) {
+			spin_lock_irqsave(&alarm_slock, flags);
+			if (alarm_opened) {
+				spin_unlock_irqrestore(&alarm_slock, flags);
+				return -EBUSY;
+			}
+			alarm_opened = 1;
+			file->private_data = (void *)1;
+			spin_unlock_irqrestore(&alarm_slock, flags);
+		}
+	}
+
+	switch (ANDROID_ALARM_BASE_CMD(cmd)) {
+	case ANDROID_ALARM_CLEAR(0):
+		spin_lock_irqsave(&alarm_slock, flags);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO,
+				      "alarm %d clear\n", alarm_type);
+		hrtimer_try_to_cancel(&alarm_timer[alarm_type]);
+		if (alarm_pending) {
+			alarm_pending &= ~alarm_type_mask;
+			if (!alarm_pending && !wait_pending)
+				wake_unlock(&alarm_wake_lock);
+		}
+		alarm_enabled &= ~alarm_type_mask;
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		break;
+
+	case ANDROID_ALARM_SET_OLD:
+	case ANDROID_ALARM_SET_AND_WAIT_OLD:
+		if (get_user(new_alarm_time.tv_sec, (int __user *)arg)) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		new_alarm_time.tv_nsec = 0;
+		goto from_old_alarm_set;
+
+	case ANDROID_ALARM_SET_AND_WAIT(0):
+	case ANDROID_ALARM_SET(0):
+		if (copy_from_user(&new_alarm_time, (void __user *)arg,
+		    sizeof(new_alarm_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+from_old_alarm_set:
+		spin_lock_irqsave(&alarm_slock, flags);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO,
+			"alarm %d set %ld.%09ld\n", alarm_type,
+			new_alarm_time.tv_sec, new_alarm_time.tv_nsec);
+		alarm_time[alarm_type] = new_alarm_time;
+		alarm_enabled |= alarm_type_mask;
+		alarm_start_hrtimer(alarm_type);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (ANDROID_ALARM_BASE_CMD(cmd) != ANDROID_ALARM_SET_AND_WAIT(0)
+		    && cmd != ANDROID_ALARM_SET_AND_WAIT_OLD)
+			break;
+		/* fall though */
+	case ANDROID_ALARM_WAIT:
+		spin_lock_irqsave(&alarm_slock, flags);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO, "alarm wait\n");
+		if (!alarm_pending && wait_pending) {
+			wake_unlock(&alarm_wake_lock);
+			wait_pending = 0;
+		}
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		rv = wait_event_interruptible(alarm_wait_queue, alarm_pending);
+		if (rv)
+			goto err1;
+		spin_lock_irqsave(&alarm_slock, flags);
+		rv = alarm_pending;
+		wait_pending = 1;
+		alarm_pending = 0;
+		if (rv & ANDROID_ALARM_WAKEUP_MASK)
+			wake_unlock(&alarm_rtc_wake_lock);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		break;
+	case ANDROID_ALARM_SET_RTC:
+		if (copy_from_user(&new_rtc_time, (void __user *)arg,
+		    sizeof(new_rtc_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		rtc_time_to_tm(new_rtc_time.tv_sec, &rtc_new_rtc_time);
+
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_IO,
+			"set rtc %ld %ld - rtc %02d:%02d:%02d %02d/%02d/%04d\n",
+			new_rtc_time.tv_sec, new_rtc_time.tv_nsec,
+			rtc_new_rtc_time.tm_hour, rtc_new_rtc_time.tm_min,
+			rtc_new_rtc_time.tm_sec, rtc_new_rtc_time.tm_mon + 1,
+			rtc_new_rtc_time.tm_mday,
+			rtc_new_rtc_time.tm_year + 1900);
+
+		mutex_lock(&alarm_setrtc_mutex);
+		spin_lock_irqsave(&alarm_slock, flags);
+		for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++)
+			hrtimer_try_to_cancel(&alarm_timer[i]);
+		getnstimeofday(&tmp_time);
+		elapsed_rtc_delta = timespec_sub(elapsed_rtc_delta,
+					timespec_sub(tmp_time, new_rtc_time));
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		rv = do_settimeofday(&new_rtc_time);
+		spin_lock_irqsave(&alarm_slock, flags);
+		for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++)
+			alarm_start_hrtimer(i);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (rv < 0) {
+			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_ERRORS,
+					      "Failed to set time\n");
+			mutex_unlock(&alarm_setrtc_mutex);
+			goto err1;
+		}
+		rv = rtc_set_time(alarm_rtc_dev, &rtc_new_rtc_time);
+		spin_lock_irqsave(&alarm_slock, flags);
+		alarm_pending |= ANDROID_ALARM_TIME_CHANGE_MASK;
+		wake_up(&alarm_wait_queue);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		mutex_unlock(&alarm_setrtc_mutex);
+		if (rv < 0) {
+			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_ERRORS,
+			    "Failed to set RTC, time will be lost on reboot\n");
+			goto err1;
+		}
+		break;
+	case ANDROID_ALARM_GET_TIME(0):
+		mutex_lock(&alarm_setrtc_mutex);
+		spin_lock_irqsave(&alarm_slock, flags);
+		if (alarm_type != ANDROID_ALARM_SYSTEMTIME) {
+			getnstimeofday(&tmp_time);
+			if (alarm_type >= ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP)
+				tmp_time = timespec_sub(tmp_time,
+							elapsed_rtc_delta);
+		} else
+			ktime_get_ts(&tmp_time);
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		mutex_unlock(&alarm_setrtc_mutex);
+		if (copy_to_user((void __user *)arg, &tmp_time,
+		    sizeof(tmp_time))) {
+			rv = -EFAULT;
+			goto err1;
+		}
+		break;
+
+	default:
+		rv = -EINVAL;
+		goto err1;
+	}
+err1:
+	return rv;
+}
+
+static int alarm_open(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static int alarm_release(struct inode *inode, struct file *file)
+{
+	int i;
+	unsigned long flags;
+
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (file->private_data != 0) {
+		for (i = 0; i < ANDROID_ALARM_TYPE_COUNT; i++) {
+			uint32_t alarm_type_mask = 1U << i;
+			if (alarm_enabled & alarm_type_mask) {
+				ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+					"alarm_release: clear alarm, "
+					"pending %d\n",
+					!!(alarm_pending & alarm_type_mask));
+				alarm_enabled &= ~alarm_type_mask;
+			}
+			spin_unlock_irqrestore(&alarm_slock, flags);
+			hrtimer_cancel(&alarm_timer[i]);
+			spin_lock_irqsave(&alarm_slock, flags);
+		}
+		if (alarm_pending | wait_pending) {
+			if (alarm_pending)
+				ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+					"alarm_release: clear pending alarms "
+					"%x\n", alarm_pending);
+			wake_unlock(&alarm_wake_lock);
+			wait_pending = 0;
+			alarm_pending = 0;
+		}
+		alarm_opened = 0;
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return 0;
+}
+
+static enum hrtimer_restart alarm_timer_triggered(struct hrtimer *timer)
+{
+	unsigned long flags;
+	enum android_alarm_type alarm_type = (timer - alarm_timer);
+	uint32_t alarm_type_mask = 1U << alarm_type;
+
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INT,
+			      "alarm_timer_triggered type %d\n", alarm_type);
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (alarm_enabled & alarm_type_mask) {
+		wake_lock_timeout(&alarm_wake_lock, 5 * HZ);
+		alarm_enabled &= ~alarm_type_mask;
+		alarm_pending |= alarm_type_mask;
+		wake_up(&alarm_wait_queue);
+	}
+	spin_unlock_irqrestore(&alarm_slock, flags);
+	return HRTIMER_NORESTART;
+}
+
+static void alarm_triggered_func(void *p)
+{
+	struct rtc_device *rtc = alarm_rtc_dev;
+	if (!(rtc->irq_data & RTC_AF))
+		return;
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INT, "rtc alarm triggered\n");
+	wake_lock_timeout(&alarm_rtc_wake_lock, 1 * HZ);
+}
+
+int alarm_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	int                 err = 0;
+	unsigned long       flags;
+	struct rtc_wkalrm   rtc_alarm;
+	struct rtc_time     rtc_current_rtc_time;
+	unsigned long       rtc_current_time;
+	unsigned long       rtc_alarm_time;
+	struct timespec     rtc_current_timespec;
+	struct timespec     rtc_delta;
+	struct timespec     elapsed_realtime_alarm_time;
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
+			      "alarm_suspend(%p, %d)\n", pdev, state.event);
+	spin_lock_irqsave(&alarm_slock, flags);
+	if (alarm_pending && !wake_lock_active(&alarm_wake_lock)) {
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+				      "alarm pending\n");
+		err = -EBUSY;
+		goto err1;
+	}
+	if (alarm_enabled & ANDROID_ALARM_WAKEUP_MASK) {
+		spin_unlock_irqrestore(&alarm_slock, flags);
+		if (alarm_enabled & ANDROID_ALARM_RTC_WAKEUP_MASK)
+			hrtimer_cancel(&alarm_timer[ANDROID_ALARM_RTC_WAKEUP]);
+		if (alarm_enabled & ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK)
+			hrtimer_cancel(&alarm_timer[
+					ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP]);
+
+		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
+		rtc_current_timespec.tv_nsec = 0;
+		rtc_tm_to_time(&rtc_current_rtc_time,
+			       &rtc_current_timespec.tv_sec);
+		save_time_delta(&rtc_delta, &rtc_current_timespec);
+		set_normalized_timespec(&elapsed_realtime_alarm_time,
+			alarm_time[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP]
+			.tv_sec + elapsed_rtc_delta.tv_sec,
+			alarm_time[ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP]
+			.tv_nsec + elapsed_rtc_delta.tv_nsec);
+		if ((alarm_enabled & ANDROID_ALARM_RTC_WAKEUP_MASK) &&
+		    (!(alarm_enabled &
+		       ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK) ||
+		     timespec_compare(&alarm_time[ANDROID_ALARM_RTC_WAKEUP],
+				      &elapsed_realtime_alarm_time) < 0))
+			rtc_alarm_time = timespec_sub(
+					alarm_time[ANDROID_ALARM_RTC_WAKEUP],
+					rtc_delta).tv_sec;
+		else
+			rtc_alarm_time = timespec_sub(
+				elapsed_realtime_alarm_time, rtc_delta).tv_sec;
+		rtc_time_to_tm(rtc_alarm_time, &rtc_alarm.time);
+		rtc_alarm.enabled = 1;
+		rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+		rtc_read_time(alarm_rtc_dev, &rtc_current_rtc_time);
+		rtc_tm_to_time(&rtc_current_rtc_time, &rtc_current_time);
+		ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+			"rtc alarm set at %ld, now %ld, rtc delta %ld.%09ld\n",
+			rtc_alarm_time, rtc_current_time,
+			rtc_delta.tv_sec, rtc_delta.tv_nsec);
+		if (rtc_current_time + 1 >= rtc_alarm_time) {
+			ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+					      "alarm about to go off\n");
+			memset(&rtc_alarm, 0, sizeof(rtc_alarm));
+			rtc_alarm.enabled = 0;
+			rtc_set_alarm(alarm_rtc_dev, &rtc_alarm);
+
+			spin_lock_irqsave(&alarm_slock, flags);
+			wake_lock_timeout(&alarm_rtc_wake_lock, 2 * HZ);
+			alarm_start_hrtimer(ANDROID_ALARM_RTC_WAKEUP);
+			alarm_start_hrtimer(
+				ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);
+			err = -EBUSY;
+			spin_unlock_irqrestore(&alarm_slock, flags);
+		}
+	} else {
+err1:
+		spin_unlock_irqrestore(&alarm_slock, flags);
+	}
+	return err;
+}
+
+int alarm_resume(struct platform_device *pdev)
+{
+	struct rtc_wkalrm alarm;
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_FLOW,
+			      "alarm_resume(%p)\n", pdev);
+	if (alarm_enabled & ANDROID_ALARM_WAKEUP_MASK) {
+		memset(&alarm, 0, sizeof(alarm));
+		alarm.enabled = 0;
+		rtc_set_alarm(alarm_rtc_dev, &alarm);
+		alarm_start_hrtimer(ANDROID_ALARM_RTC_WAKEUP);
+		alarm_start_hrtimer(ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP);
+	}
+	return 0;
+}
+
+static struct rtc_task alarm_rtc_task = {
+	.func = alarm_triggered_func
+};
+
+static struct file_operations alarm_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = alarm_ioctl,
+	.open = alarm_open,
+	.release = alarm_release,
+};
+
+static struct miscdevice alarm_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "alarm",
+	.fops = &alarm_fops,
+};
+
+static int rtc_alarm_add_device(struct device *dev,
+				struct class_interface *class_intf)
+{
+	int err;
+	struct rtc_device *rtc = to_rtc_device(dev);
+
+	mutex_lock(&alarm_setrtc_mutex);
+
+	if (alarm_rtc_dev) {
+		err = -EBUSY;
+		goto err1;
+	}
+
+	err = misc_register(&alarm_device);
+	if (err)
+		goto err1;
+	alarm_platform_dev =
+		platform_device_register_simple("alarm", -1, NULL, 0);
+	if (IS_ERR(alarm_platform_dev)) {
+		err = PTR_ERR(alarm_platform_dev);
+		goto err2;
+	}
+	err = rtc_irq_register(rtc, &alarm_rtc_task);
+	if (err)
+		goto err3;
+	alarm_rtc_dev = rtc;
+	mutex_unlock(&alarm_setrtc_mutex);
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO, "alarm: parent %p\n",
+			      alarm_platform_dev->dev.power.pm_parent);
+	return 0;
+
+err3:
+	platform_device_unregister(alarm_platform_dev);
+err2:
+	misc_deregister(&alarm_device);
+err1:
+	mutex_unlock(&alarm_setrtc_mutex);
+	return err;
+}
+
+static void rtc_alarm_remove_device(struct device *dev,
+				    struct class_interface *class_intf)
+{
+	if (dev == &alarm_rtc_dev->dev) {
+		rtc_irq_unregister(alarm_rtc_dev, &alarm_rtc_task);
+		platform_device_unregister(alarm_platform_dev);
+		misc_deregister(&alarm_device);
+		alarm_rtc_dev = NULL;
+	}
+}
+
+static struct class_interface rtc_alarm_interface = {
+	.add_dev = &rtc_alarm_add_device,
+	.remove_dev = &rtc_alarm_remove_device,
+};
+
+static struct platform_driver alarm_driver = {
+	.suspend = alarm_suspend,
+	.resume = alarm_resume,
+	.driver = {
+		.name = "alarm"
+	}
+};
+
+static int __init alarm_late_init(void)
+{
+	unsigned long   flags;
+	struct timespec system_time;
+
+	/* this needs to run after the rtc is read at boot */
+	spin_lock_irqsave(&alarm_slock, flags);
+	/* We read the current rtc and system time so we can later calulate
+	 * elasped realtime to be (boot_systemtime + rtc - boot_rtc) ==
+	 * (rtc - (boot_rtc - boot_systemtime))
+	 */
+	getnstimeofday(&elapsed_rtc_delta);
+	ktime_get_ts(&system_time);
+	elapsed_rtc_delta = timespec_sub(elapsed_rtc_delta, system_time);
+	spin_unlock_irqrestore(&alarm_slock, flags);
+
+	ANDROID_ALARM_DPRINTF(ANDROID_ALARM_PRINT_INFO,
+		"alarm_late_init: rtc to elapsed realtime delta %ld.%09ld\n",
+		elapsed_rtc_delta.tv_sec, elapsed_rtc_delta.tv_nsec);
+	return 0;
+}
+
+static int __init alarm_init(void)
+{
+	int err;
+	int i;
+
+	for (i = 0; i < ANDROID_ALARM_SYSTEMTIME; i++) {
+		hrtimer_init(&alarm_timer[i], CLOCK_REALTIME, HRTIMER_MODE_ABS);
+		alarm_timer[i].function = alarm_timer_triggered;
+	}
+	hrtimer_init(&alarm_timer[ANDROID_ALARM_SYSTEMTIME],
+		     CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	alarm_timer[ANDROID_ALARM_SYSTEMTIME].function = alarm_timer_triggered;
+	err = platform_driver_register(&alarm_driver);
+	if (err < 0)
+		goto err1;
+	wake_lock_init(&alarm_wake_lock, WAKE_LOCK_SUSPEND, "alarm");
+	wake_lock_init(&alarm_rtc_wake_lock, WAKE_LOCK_SUSPEND, "alarm_rtc");
+	rtc_alarm_interface.class = rtc_class;
+	err = class_interface_register(&rtc_alarm_interface);
+	if (err < 0)
+		goto err2;
+
+	return 0;
+
+err2:
+	wake_lock_destroy(&alarm_rtc_wake_lock);
+	wake_lock_destroy(&alarm_wake_lock);
+	platform_driver_unregister(&alarm_driver);
+err1:
+	return err;
+}
+
+static void  __exit alarm_exit(void)
+{
+	class_interface_unregister(&rtc_alarm_interface);
+	wake_lock_destroy(&alarm_rtc_wake_lock);
+	wake_lock_destroy(&alarm_wake_lock);
+	platform_driver_unregister(&alarm_driver);
+}
+
+late_initcall(alarm_late_init);
+module_init(alarm_init);
+module_exit(alarm_exit);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/binder.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/binder.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/binder.c	2009-05-10 22:08:44.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/binder.c	2009-05-10 22:28:00.000000000 +0200
@@ -54,7 +54,7 @@
 #define SZ_4M                               0x400000
 #endif
 
-#ifndef __i386__
+#if !defined(__i386__) && !defined(__arm__)
 #define FORBIDDEN_MMAP_FLAGS                (VM_WRITE | VM_EXEC)
 #else
 #define FORBIDDEN_MMAP_FLAGS                (VM_WRITE)
@@ -2649,14 +2649,14 @@
 {
 	struct binder_proc *proc = vma->vm_private_data;
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
-		printk(KERN_INFO "binder: %d open vm area %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, vma->vm_page_prot.pgprot);
+		printk(KERN_INFO "binder: %d open vm area %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, vma->vm_page_prot);
 	dump_stack();
 }
 static void binder_vma_close(struct vm_area_struct *vma)
 {
 	struct binder_proc *proc = vma->vm_private_data;
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
-		printk(KERN_INFO "binder: %d close vm area %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, vma->vm_page_prot.pgprot);
+		printk(KERN_INFO "binder: %d close vm area %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, vma->vm_page_prot);
 	proc->vma = NULL;
 }
 
@@ -2677,7 +2677,7 @@
 		vma->vm_end = vma->vm_start + SZ_4M;
 
 	if (binder_debug_mask & BINDER_DEBUG_OPEN_CLOSE)
-		printk(KERN_INFO "binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, vma->vm_page_prot.pgprot);
+		printk(KERN_INFO "binder_mmap: %d %lx-%lx (%ld K) vma %lx pagep %lx\n", proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, vma->vm_page_prot);
 
 	if (vma->vm_flags & FORBIDDEN_MMAP_FLAGS) {
 		ret = -EPERM;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/consoleearlysuspend.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/consoleearlysuspend.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/consoleearlysuspend.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/consoleearlysuspend.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,78 @@
+/* kernel/power/consoleearlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/console.h>
+#include <linux/earlysuspend.h>
+#include <linux/kbd_kern.h>
+#include <linux/module.h>
+#include <linux/vt_kern.h>
+#include <linux/wait.h>
+
+#define EARLY_SUSPEND_CONSOLE	(MAX_NR_CONSOLES-1)
+
+static int orig_fgconsole;
+static void console_early_suspend(struct early_suspend *h)
+{
+	acquire_console_sem();
+	orig_fgconsole = fg_console;
+	if (vc_allocate(EARLY_SUSPEND_CONSOLE))
+		goto err;
+	if (set_console(EARLY_SUSPEND_CONSOLE))
+		goto err;
+	release_console_sem();
+
+	if (vt_waitactive(EARLY_SUSPEND_CONSOLE))
+		pr_warning("console_early_suspend: Can't switch VCs.\n");
+	return;
+err:
+	pr_warning("console_early_suspend: Can't set console\n");
+	release_console_sem();
+}
+
+static void console_late_resume(struct early_suspend *h)
+{
+	int ret;
+	acquire_console_sem();
+	ret = set_console(orig_fgconsole);
+	release_console_sem();
+	if (ret) {
+		pr_warning("console_late_resume: Can't set console.\n");
+		return;
+	}
+
+	if (vt_waitactive(orig_fgconsole))
+		pr_warning("console_late_resume: Can't switch VCs.\n");
+}
+
+static struct early_suspend console_early_suspend_desc = {
+	.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+	.suspend = console_early_suspend,
+	.resume = console_late_resume,
+};
+
+static int __init console_early_suspend_init(void)
+{
+	register_early_suspend(&console_early_suspend_desc);
+	return 0;
+}
+
+static void  __exit console_early_suspend_exit(void)
+{
+	unregister_early_suspend(&console_early_suspend_desc);
+}
+
+module_init(console_early_suspend_init);
+module_exit(console_early_suspend_exit);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/earlysuspend.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/earlysuspend.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/earlysuspend.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/earlysuspend.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,178 @@
+/* kernel/power/earlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/rtc.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_USER_STATE = 1U << 0,
+	DEBUG_SUSPEND = 1U << 2,
+};
+static int debug_mask = DEBUG_USER_STATE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(early_suspend_lock);
+static LIST_HEAD(early_suspend_handlers);
+static void early_suspend(struct work_struct *work);
+static void late_resume(struct work_struct *work);
+static DECLARE_WORK(early_suspend_work, early_suspend);
+static DECLARE_WORK(late_resume_work, late_resume);
+static DEFINE_SPINLOCK(state_lock);
+enum {
+	SUSPEND_REQUESTED = 0x1,
+	SUSPENDED = 0x2,
+	SUSPEND_REQUESTED_AND_SUSPENDED = SUSPEND_REQUESTED | SUSPENDED,
+};
+static int state;
+
+void register_early_suspend(struct early_suspend *handler)
+{
+	struct list_head *pos;
+
+	mutex_lock(&early_suspend_lock);
+	list_for_each(pos, &early_suspend_handlers) {
+		struct early_suspend *e;
+		e = list_entry(pos, struct early_suspend, link);
+		if (e->level > handler->level)
+			break;
+	}
+	list_add_tail(&handler->link, pos);
+	if ((state & SUSPENDED) && handler->suspend)
+		handler->suspend(handler);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(register_early_suspend);
+
+void unregister_early_suspend(struct early_suspend *handler)
+{
+	mutex_lock(&early_suspend_lock);
+	list_del(&handler->link);
+	mutex_unlock(&early_suspend_lock);
+}
+EXPORT_SYMBOL(unregister_early_suspend);
+
+static void early_suspend(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPEND_REQUESTED)
+		state |= SUSPENDED;
+	else
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("early_suspend: abort, state %d\n", state);
+		mutex_unlock(&early_suspend_lock);
+		goto abort;
+	}
+
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("early_suspend: call handlers\n");
+	list_for_each_entry(pos, &early_suspend_handlers, link) {
+		if (pos->suspend != NULL)
+			pos->suspend(pos);
+	}
+	mutex_unlock(&early_suspend_lock);
+
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("early_suspend: sync\n");
+
+	sys_sync();
+abort:
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPEND_REQUESTED_AND_SUSPENDED)
+		wake_unlock(&main_wake_lock);
+	spin_unlock_irqrestore(&state_lock, irqflags);
+}
+
+static void late_resume(struct work_struct *work)
+{
+	struct early_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	mutex_lock(&early_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == SUSPENDED)
+		state &= ~SUSPENDED;
+	else
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("late_resume: abort, state %d\n", state);
+		goto abort;
+	}
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("late_resume: call handlers\n");
+	list_for_each_entry_reverse(pos, &early_suspend_handlers, link)
+		if (pos->resume != NULL)
+			pos->resume(pos);
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("late_resume: done\n");
+abort:
+	mutex_unlock(&early_suspend_lock);
+}
+
+void request_suspend_state(suspend_state_t new_state)
+{
+	unsigned long irqflags;
+	int old_sleep;
+
+	spin_lock_irqsave(&state_lock, irqflags);
+	old_sleep = state & SUSPEND_REQUESTED;
+	if (debug_mask & DEBUG_USER_STATE) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		pr_info("request_suspend_state: %s (%d->%d) at %lld "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n",
+			new_state != PM_SUSPEND_ON ? "sleep" : "wakeup",
+			requested_suspend_state, new_state,
+			ktime_to_ns(ktime_get()),
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	if (!old_sleep && new_state != PM_SUSPEND_ON) {
+		state |= SUSPEND_REQUESTED;
+		queue_work(suspend_work_queue, &early_suspend_work);
+	} else if (old_sleep && new_state == PM_SUSPEND_ON) {
+		state &= ~SUSPEND_REQUESTED;
+		wake_lock(&main_wake_lock);
+		queue_work(suspend_work_queue, &late_resume_work);
+	}
+	requested_suspend_state = new_state;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+}
+
+suspend_state_t get_suspend_state(void)
+{
+	return requested_suspend_state;
+}
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/fbearlysuspend.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/fbearlysuspend.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/fbearlysuspend.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/fbearlysuspend.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,153 @@
+/* kernel/power/fbearlysuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/earlysuspend.h>
+#include <linux/module.h>
+#include <linux/wait.h>
+
+#include "power.h"
+
+static wait_queue_head_t fb_state_wq;
+static DEFINE_SPINLOCK(fb_state_lock);
+static enum {
+	FB_STATE_STOPPED_DRAWING,
+	FB_STATE_REQUEST_STOP_DRAWING,
+	FB_STATE_DRAWING_OK,
+} fb_state;
+
+/* tell userspace to stop drawing, wait for it to stop */
+static void stop_drawing_early_suspend(struct early_suspend *h)
+{
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	fb_state = FB_STATE_REQUEST_STOP_DRAWING;
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+
+	wake_up_all(&fb_state_wq);
+	ret = wait_event_timeout(fb_state_wq,
+				 fb_state == FB_STATE_STOPPED_DRAWING,
+				 HZ);
+	if (unlikely(fb_state != FB_STATE_STOPPED_DRAWING))
+		pr_warning("stop_drawing_early_suspend: timeout waiting for "
+			   "userspace to stop drawing\n");
+}
+
+/* tell userspace to start drawing */
+static void start_drawing_late_resume(struct early_suspend *h)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	fb_state = FB_STATE_DRAWING_OK;
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+	wake_up(&fb_state_wq);
+}
+
+static struct early_suspend stop_drawing_early_suspend_desc = {
+	.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING,
+	.suspend = stop_drawing_early_suspend,
+	.resume = start_drawing_late_resume,
+};
+
+static ssize_t wait_for_fb_sleep_show(struct kobject *kobj,
+				      struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	int ret;
+
+	ret = wait_event_interruptible(fb_state_wq,
+				       fb_state != FB_STATE_DRAWING_OK);
+	if (ret && fb_state == FB_STATE_DRAWING_OK)
+		return ret;
+	else
+		s += sprintf(buf, "sleeping");
+	return s - buf;
+}
+
+static ssize_t wait_for_fb_wake_show(struct kobject *kobj,
+				     struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	int ret;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&fb_state_lock, irq_flags);
+	if (fb_state == FB_STATE_REQUEST_STOP_DRAWING) {
+		fb_state = FB_STATE_STOPPED_DRAWING;
+		wake_up(&fb_state_wq);
+	}
+	spin_unlock_irqrestore(&fb_state_lock, irq_flags);
+
+	ret = wait_event_interruptible(fb_state_wq,
+				       fb_state == FB_STATE_DRAWING_OK);
+	if (ret && fb_state != FB_STATE_DRAWING_OK)
+		return ret;
+	else
+		s += sprintf(buf, "awake");
+
+	return s - buf;
+}
+
+#define power_ro_attr(_name) \
+static struct kobj_attribute _name##_attr = {	\
+	.attr	= {				\
+		.name = __stringify(_name),	\
+		.mode = 0444,			\
+	},					\
+	.show	= _name##_show,			\
+	.store	= NULL,		\
+}
+
+power_ro_attr(wait_for_fb_sleep);
+power_ro_attr(wait_for_fb_wake);
+
+static struct attribute *g[] = {
+	&wait_for_fb_sleep_attr.attr,
+	&wait_for_fb_wake_attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = g,
+};
+
+static int __init android_power_init(void)
+{
+	int ret;
+
+	init_waitqueue_head(&fb_state_wq);
+	fb_state = FB_STATE_DRAWING_OK;
+
+	ret = sysfs_create_group(power_kobj, &attr_group);
+	if (ret) {
+		pr_err("android_power_init: sysfs_create_group failed\n");
+		return ret;
+	}
+
+	register_early_suspend(&stop_drawing_early_suspend_desc);
+	return 0;
+}
+
+static void  __exit android_power_exit(void)
+{
+	unregister_early_suspend(&stop_drawing_early_suspend_desc);
+	sysfs_remove_group(power_kobj, &attr_group);
+}
+
+module_init(android_power_init);
+module_exit(android_power_exit);
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/Kconfig linux-2.6.29-rc3.owrt.om/drivers/staging/android/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/staging/android/Kconfig	2009-05-10 22:08:44.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -83,4 +83,80 @@
 	---help---
 	  Register processes to be killed when memory is low
 
+config ANDROID_HAS_WAKELOCK
+	bool
+
+config ANDROID_HAS_EARLYSUSPEND
+	bool
+
+config ANDROID_WAKELOCK
+	bool "Wake lock"
+	depends on PM && RTC_CLASS
+	default n
+	select ANDROID_HAS_WAKELOCK
+	---help---
+	  Enable wakelocks. When user space request a sleep state the
+	  sleep request will be delayed until no wake locks are held.
+
+config ANDROID_WAKELOCK_STAT
+	bool "Wake lock stats"
+	depends on WAKELOCK
+	default y
+	---help---
+	  Report wake lock stats in /proc/wakelocks
+
+config ANDROID_USER_WAKELOCK
+	bool "Userspace wake locks"
+	depends on ANDROID_WAKELOCK
+	default y
+	---help---
+	  User-space wake lock api. Write "lockname" or "lockname timeout"
+	  to /sys/power/wake_lock lock and if needed create a wake lock.
+	  Write "lockname" to /sys/power/wake_unlock to unlock a user wake
+	  lock.
+
+config ANDROID_EARLYSUSPEND
+	bool "Early suspend"
+	depends on ANDROID_WAKELOCK
+	default y
+	select ANDROID_HAS_EARLYSUSPEND
+	---help---
+	  Call early suspend handlers when the user requested sleep state
+	  changes.
+
+choice
+	prompt "User-space screen access"
+	default ANDROID_FB_EARLYSUSPEND if !FRAMEBUFFER_CONSOLE
+	default ANDROID_CONSOLE_EARLYSUSPEND
+	depends on ANDROID_HAS_EARLYSUSPEND
+
+	config NO_USER_SPACE_SCREEN_ACCESS_CONTROL
+		bool "None"
+
+	config ANDROID_CONSOLE_EARLYSUSPEND
+		bool "Console switch on early-suspend"
+		depends on ANDROID_HAS_EARLYSUSPEND && VT
+		---help---
+		  Register early suspend handler to perform a console switch to
+		  when user-space should stop drawing to the screen and a switch
+		  back when it should resume.
+
+	config ANDROID_FB_EARLYSUSPEND
+		bool "Sysfs interface"
+		depends on ANDROID_HAS_EARLYSUSPEND
+		---help---
+		  Register early suspend handler that notifies and waits for
+		  user-space through sysfs when user-space should stop drawing
+		  to the screen and notifies user-space when it should resume.
+endchoice
+
+config ANDROID_POWER_ALARM
+	bool "Android alarm driver"
+	depends on ANDROID_WAKELOCK
+	default y
+
+config ANDROID_PARANOID_NETWORK
+	bool "Only allow certain groups to create sockets"
+	default y
+
 endmenu
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/Makefile linux-2.6.29-rc3.owrt.om/drivers/staging/android/Makefile
--- linux-2.6.29-rc3.owrt/drivers/staging/android/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -3,3 +3,9 @@
 obj-$(CONFIG_ANDROID_RAM_CONSOLE)	+= ram_console.o
 obj-$(CONFIG_ANDROID_TIMED_GPIO)	+= timed_gpio.o
 obj-$(CONFIG_ANDROID_LOW_MEMORY_KILLER)	+= lowmemorykiller.o
+obj-$(CONFIG_ANDROID_POWER_ALARM)	+= alarm.o
+obj-$(CONFIG_ANDROID_WAKELOCK)		+= wakelock.o
+obj-$(CONFIG_ANDROID_USER_WAKELOCK)	+= userwakelock.o
+obj-$(CONFIG_ANDROID_EARLYSUSPEND)	+= earlysuspend.o
+obj-$(CONFIG_ANDROID_CONSOLE_EARLYSUSPEND)	+= consoleearlysuspend.o
+obj-$(CONFIG_ANDROID_FB_EARLYSUSPEND)		+= fbearlysuspend.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/power.h linux-2.6.29-rc3.owrt.om/drivers/staging/android/power.h
--- linux-2.6.29-rc3.owrt/drivers/staging/android/power.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/power.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1 @@
+#include "../../../kernel/power/power.h"
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/timed_gpio.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/timed_gpio.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/timed_gpio.c	2009-05-10 22:08:44.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/timed_gpio.c	2009-05-10 22:28:00.000000000 +0200
@@ -18,7 +18,7 @@
 #include <linux/platform_device.h>
 #include <linux/hrtimer.h>
 #include <linux/err.h>
-#include <asm/arch/gpio.h>
+#include <linux/gpio.h>
 
 #include "timed_gpio.h"
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/userwakelock.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/userwakelock.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/userwakelock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/userwakelock.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,245 @@
+/* kernel/power/userwakelock.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/ctype.h>
+#include <linux/module.h>
+#include <linux/wakelock.h>
+
+#include "power.h"
+
+enum {
+	DEBUG_FAILURE	= BIT(0),
+	DEBUG_ERROR	= BIT(1),
+	DEBUG_NEW	= BIT(2),
+	DEBUG_ACCESS	= BIT(3),
+	DEBUG_LOOKUP	= BIT(4),
+};
+static int debug_mask = DEBUG_FAILURE;
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+static DEFINE_MUTEX(tree_lock);
+
+struct user_wake_lock {
+	struct rb_node		node;
+	struct wake_lock	wake_lock;
+	char			name[0];
+};
+struct rb_root user_wake_locks;
+
+static struct user_wake_lock *lookup_wake_lock_name(
+	const char *buf, int allocate, long *timeoutptr)
+{
+	struct rb_node **p = &user_wake_locks.rb_node;
+	struct rb_node *parent = NULL;
+	struct user_wake_lock *l;
+	int diff;
+	u64 timeout;
+	int name_len;
+	const char *arg;
+
+	/* Find length of lock name and start of optional timeout string */
+	arg = buf;
+	while (*arg && !isspace(*arg))
+		arg++;
+	name_len = arg - buf;
+	if (!name_len)
+		goto bad_arg;
+	while (isspace(*arg))
+		arg++;
+
+	/* Process timeout string */
+	if (timeoutptr && *arg) {
+		timeout = simple_strtoull(arg, (char **)&arg, 0);
+		while (isspace(*arg))
+			arg++;
+		if (*arg)
+			goto bad_arg;
+		/* convert timeout from nanoseconds to jiffies > 0 */
+		timeout += (NSEC_PER_SEC / HZ) - 1;
+		do_div(timeout, (NSEC_PER_SEC / HZ));
+		if (timeout <= 0)
+			timeout = 1;
+		*timeoutptr = timeout;
+	} else if (*arg)
+		goto bad_arg;
+	else if (timeoutptr)
+		*timeoutptr = 0;
+
+	/* Lookup wake lock in rbtree */
+	while (*p) {
+		parent = *p;
+		l = rb_entry(parent, struct user_wake_lock, node);
+		diff = strncmp(buf, l->name, name_len);
+		if (!diff && l->name[name_len])
+			diff = -1;
+		if (debug_mask & DEBUG_ERROR)
+			pr_info("lookup_wake_lock_name: compare %.*s %s %d\n",
+				name_len, buf, l->name, diff);
+
+		if (diff < 0)
+			p = &(*p)->rb_left;
+		else if (diff > 0)
+			p = &(*p)->rb_right;
+		else
+			return l;
+	}
+
+	/* Allocate and add new wakelock to rbtree */
+	if (!allocate) {
+		if (debug_mask & DEBUG_ERROR)
+			pr_info("lookup_wake_lock_name: %.*s not found\n",
+				name_len, buf);
+		return ERR_PTR(-EINVAL);
+	}
+	l = kzalloc(sizeof(*l) + name_len + 1, GFP_KERNEL);
+	if (l == NULL) {
+		if (debug_mask & DEBUG_FAILURE)
+			pr_err("lookup_wake_lock_name: failed to allocate "
+				"memory for %.*s\n", name_len, buf);
+		return ERR_PTR(-ENOMEM);
+	}
+	memcpy(l->name, buf, name_len);
+	if (debug_mask & DEBUG_NEW)
+		pr_info("lookup_wake_lock_name: new wake lock %s\n", l->name);
+	wake_lock_init(&l->wake_lock, WAKE_LOCK_SUSPEND, l->name);
+	rb_link_node(&l->node, parent, p);
+	rb_insert_color(&l->node, &user_wake_locks);
+	return l;
+
+bad_arg:
+	if (debug_mask & DEBUG_ERROR)
+		pr_info("lookup_wake_lock_name: wake lock, %.*s, bad arg, %s\n",
+			name_len, buf, arg);
+	return ERR_PTR(-EINVAL);
+}
+
+ssize_t wake_lock_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = buf + PAGE_SIZE;
+	struct rb_node *n;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+
+	for (n = rb_first(&user_wake_locks); n != NULL; n = rb_next(n)) {
+		l = rb_entry(n, struct user_wake_lock, node);
+		if (wake_lock_active(&l->wake_lock))
+			s += scnprintf(s, end - s, "%s ", l->name);
+	}
+	s += scnprintf(s, end - s, "\n");
+
+	mutex_unlock(&tree_lock);
+	return (s - buf);
+}
+
+ssize_t wake_full_lock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	long timeout;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 1, &timeout);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto bad_name;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_full_lock_store: %s, timeout %ld\n", l->name, timeout);
+
+	if (timeout == 0)
+		timeout = INT_MAX;
+
+	if (timeout)
+		wake_lock_timeout(&l->wake_lock, timeout);
+bad_name:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
+ssize_t wake_lock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	long timeout;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 1, &timeout);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto bad_name;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_lock_store: %s, timeout %ld\n", l->name, timeout);
+
+	if (timeout)
+		wake_lock_timeout(&l->wake_lock, timeout);
+	else
+		wake_lock(&l->wake_lock);
+bad_name:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
+
+ssize_t wake_unlock_show(
+	struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	char *s = buf;
+	char *end = buf + PAGE_SIZE;
+	struct rb_node *n;
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+
+	for (n = rb_first(&user_wake_locks); n != NULL; n = rb_next(n)) {
+		l = rb_entry(n, struct user_wake_lock, node);
+		if (!wake_lock_active(&l->wake_lock))
+			s += scnprintf(s, end - s, "%s ", l->name);
+	}
+	s += scnprintf(s, end - s, "\n");
+
+	mutex_unlock(&tree_lock);
+	return (s - buf);
+}
+
+ssize_t wake_unlock_store(
+	struct kobject *kobj, struct kobj_attribute *attr,
+	const char *buf, size_t n)
+{
+	struct user_wake_lock *l;
+
+	mutex_lock(&tree_lock);
+	l = lookup_wake_lock_name(buf, 0, NULL);
+	if (IS_ERR(l)) {
+		n = PTR_ERR(l);
+		goto not_found;
+	}
+
+	if (debug_mask & DEBUG_ACCESS)
+		pr_info("wake_unlock_store: %s\n", l->name);
+
+	wake_unlock(&l->wake_lock);
+not_found:
+	mutex_unlock(&tree_lock);
+	return n;
+}
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/staging/android/wakelock.c linux-2.6.29-rc3.owrt.om/drivers/staging/android/wakelock.c
--- linux-2.6.29-rc3.owrt/drivers/staging/android/wakelock.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/staging/android/wakelock.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,605 @@
+/* kernel/power/wakelock.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+#include <linux/suspend.h>
+#include <linux/syscalls.h> /* sys_sync */
+#include <linux/wakelock.h>
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+#include <linux/proc_fs.h>
+#endif
+#include "power.h"
+
+enum {
+	DEBUG_EXIT_SUSPEND = 1U << 0,
+	DEBUG_WAKEUP = 1U << 1,
+	DEBUG_SUSPEND = 1U << 2,
+	DEBUG_EXPIRE = 1U << 3,
+	DEBUG_WAKE_LOCK = 1U << 4,
+};
+static int debug_mask = DEBUG_EXIT_SUSPEND | DEBUG_WAKEUP;
+
+module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+
+#define WAKE_LOCK_TYPE_MASK              (0x0f)
+#define WAKE_LOCK_INITIALIZED            (1U << 8)
+#define WAKE_LOCK_ACTIVE                 (1U << 9)
+#define WAKE_LOCK_AUTO_EXPIRE            (1U << 10)
+#define WAKE_LOCK_PREVENTING_SUSPEND     (1U << 11)
+
+static DEFINE_SPINLOCK(list_lock);
+static LIST_HEAD(inactive_locks);
+static struct list_head active_wake_locks[WAKE_LOCK_TYPE_COUNT];
+static int current_event_num;
+struct workqueue_struct *suspend_work_queue;
+struct wake_lock main_wake_lock;
+suspend_state_t requested_suspend_state = PM_SUSPEND_MEM;
+static struct wake_lock unknown_wakeup;
+
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+static struct wake_lock deleted_wake_locks;
+static ktime_t last_sleep_time_update;
+static int wait_for_wakeup;
+
+int get_expired_time(struct wake_lock *lock, ktime_t *expire_time)
+{
+	struct timespec ts;
+	struct timespec kt;
+	struct timespec tomono;
+	struct timespec delta;
+	unsigned long seq;
+	long timeout;
+
+	if (!(lock->flags & WAKE_LOCK_AUTO_EXPIRE))
+		return 0;
+	do {
+		seq = read_seqbegin(&xtime_lock);
+		timeout = lock->expires - jiffies;
+		if (timeout > 0)
+			return 0;
+		kt = current_kernel_time();
+		tomono = wall_to_monotonic;
+	} while (read_seqretry(&xtime_lock, seq));
+	jiffies_to_timespec(-timeout, &delta);
+	set_normalized_timespec(&ts, kt.tv_sec + tomono.tv_sec - delta.tv_sec,
+				kt.tv_nsec + tomono.tv_nsec - delta.tv_nsec);
+	*expire_time = timespec_to_ktime(ts);
+	return 1;
+}
+
+
+static int print_lock_stat(char *buf, struct wake_lock *lock)
+{
+	int lock_count = lock->stat.count;
+	int expire_count = lock->stat.expire_count;
+	ktime_t active_time = ktime_set(0, 0);
+	ktime_t total_time = lock->stat.total_time;
+	ktime_t max_time = lock->stat.max_time;
+	ktime_t prevent_suspend_time = lock->stat.prevent_suspend_time;
+	if (lock->flags & WAKE_LOCK_ACTIVE) {
+		ktime_t now, add_time;
+		int expired = get_expired_time(lock, &now);
+		if (!expired)
+			now = ktime_get();
+		add_time = ktime_sub(now, lock->stat.last_time);
+		lock_count++;
+		if (!expired)
+			active_time = add_time;
+		else
+			expire_count++;
+		total_time = ktime_add(total_time, add_time);
+		if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND)
+			prevent_suspend_time = ktime_add(prevent_suspend_time,
+					ktime_sub(now, last_sleep_time_update));
+		if (add_time.tv64 > max_time.tv64)
+			max_time = add_time;
+	}
+
+	return sprintf(buf, "\"%s\"\t%d\t%d\t%d\t%lld\t%lld\t%lld\t%lld\t"
+		       "%lld\n", lock->name, lock_count, expire_count,
+		       lock->stat.wakeup_count, ktime_to_ns(active_time),
+		       ktime_to_ns(total_time),
+		       ktime_to_ns(prevent_suspend_time), ktime_to_ns(max_time),
+		       ktime_to_ns(lock->stat.last_time));
+}
+
+
+static int wakelocks_read_proc(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	unsigned long irqflags;
+	struct wake_lock *lock;
+	int len = 0;
+	char *p = page;
+	int type;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+
+	p += sprintf(p, "name\tcount\texpire_count\twake_count\tactive_since"
+		     "\ttotal_time\tsleep_time\tmax_time\tlast_change\n");
+	list_for_each_entry(lock, &inactive_locks, link) {
+		p += print_lock_stat(p, lock);
+	}
+	for (type = 0; type < WAKE_LOCK_TYPE_COUNT; type++) {
+		list_for_each_entry(lock, &active_wake_locks[type], link)
+			p += print_lock_stat(p, lock);
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+
+	*start = page + off;
+
+	len = p - page;
+	if (len > off)
+		len -= off;
+	else
+		len = 0;
+
+	return len < count ? len  : count;
+}
+
+static void wake_unlock_stat_locked(struct wake_lock *lock, int expired)
+{
+	ktime_t duration;
+	ktime_t now;
+	if (!(lock->flags & WAKE_LOCK_ACTIVE))
+		return;
+	if (get_expired_time(lock, &now))
+		expired = 1;
+	else
+		now = ktime_get();
+	lock->stat.count++;
+	if (expired)
+		lock->stat.expire_count++;
+	duration = ktime_sub(now, lock->stat.last_time);
+	lock->stat.total_time = ktime_add(lock->stat.total_time, duration);
+	if (ktime_to_ns(duration) > ktime_to_ns(lock->stat.max_time))
+		lock->stat.max_time = duration;
+	lock->stat.last_time = ktime_get();
+	if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND) {
+		duration = ktime_sub(now, last_sleep_time_update);
+		lock->stat.prevent_suspend_time = ktime_add(
+			lock->stat.prevent_suspend_time, duration);
+		lock->flags &= ~WAKE_LOCK_PREVENTING_SUSPEND;
+	}
+}
+
+static void update_sleep_wait_stats_locked(int done)
+{
+	struct wake_lock *lock;
+	ktime_t now, etime, elapsed, add;
+	int expired;
+
+	now = ktime_get();
+	elapsed = ktime_sub(now, last_sleep_time_update);
+	list_for_each_entry(lock, &active_wake_locks[WAKE_LOCK_SUSPEND], link) {
+		expired = get_expired_time(lock, &etime);
+		if (lock->flags & WAKE_LOCK_PREVENTING_SUSPEND) {
+			if (expired)
+				add = ktime_sub(etime, last_sleep_time_update);
+			else
+				add = elapsed;
+			lock->stat.prevent_suspend_time = ktime_add(
+				lock->stat.prevent_suspend_time, add);
+		}
+		if (done || expired)
+			lock->flags &= ~WAKE_LOCK_PREVENTING_SUSPEND;
+		else
+			lock->flags |= WAKE_LOCK_PREVENTING_SUSPEND;
+	}
+	last_sleep_time_update = now;
+}
+#endif
+
+
+static void expire_wake_lock(struct wake_lock *lock)
+{
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	wake_unlock_stat_locked(lock, 1);
+#endif
+	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
+	list_del(&lock->link);
+	list_add(&lock->link, &inactive_locks);
+	if (debug_mask & (DEBUG_WAKE_LOCK | DEBUG_EXPIRE))
+		pr_info("expired wake lock %s\n", lock->name);
+}
+
+static void print_active_locks(int type)
+{
+	unsigned long irqflags;
+	struct wake_lock *lock;
+
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	spin_lock_irqsave(&list_lock, irqflags);
+	list_for_each_entry(lock, &active_wake_locks[type], link) {
+		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
+			long timeout = lock->expires - jiffies;
+			if (timeout <= 0)
+				pr_info("wake lock %s, expired\n", lock->name);
+			else
+				pr_info("active wake lock %s, time left %ld\n",
+					lock->name, timeout);
+		} else
+			pr_info("active wake lock %s\n", lock->name);
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+
+static long has_wake_lock_locked(int type)
+{
+	struct wake_lock *lock, *n;
+	long max_timeout = 0;
+
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	list_for_each_entry_safe(lock, n, &active_wake_locks[type], link) {
+		if (lock->flags & WAKE_LOCK_AUTO_EXPIRE) {
+			long timeout = lock->expires - jiffies;
+			if (timeout <= 0)
+				expire_wake_lock(lock);
+			else if (timeout > max_timeout)
+				max_timeout = timeout;
+		} else
+			return -1;
+	}
+	return max_timeout;
+}
+
+long has_wake_lock(int type)
+{
+	long ret;
+	unsigned long irqflags;
+	spin_lock_irqsave(&list_lock, irqflags);
+	ret = has_wake_lock_locked(type);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+	return ret;
+}
+
+static void suspend(struct work_struct *work)
+{
+	int ret;
+	int entry_event_num;
+
+	if (has_wake_lock(WAKE_LOCK_SUSPEND)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("suspend: abort suspend\n");
+		return;
+	}
+
+	entry_event_num = current_event_num;
+	sys_sync();
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("suspend: enter suspend\n");
+	ret = pm_suspend(requested_suspend_state);
+	if (debug_mask & DEBUG_EXIT_SUSPEND) {
+		struct timespec ts;
+		struct rtc_time tm;
+		getnstimeofday(&ts);
+		rtc_time_to_tm(ts.tv_sec, &tm);
+		pr_info("suspend: exit suspend, ret = %d "
+			"(%d-%02d-%02d %02d:%02d:%02d.%09lu UTC)\n", ret,
+			tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec, ts.tv_nsec);
+	}
+	/* Openmoko needs more times to resume and a timeout is necessary
+	 * in any case */
+	if (current_event_num == entry_event_num) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("suspend: pm_suspend returned with no event\n");
+		wake_lock_timeout(&unknown_wakeup, HZ / 2);
+	} else {
+		/* create a temp lock to avoid autosuspend */
+		wake_lock_timeout(&unknown_wakeup, 5 * HZ);
+	}
+}
+
+static DECLARE_WORK(suspend_work, suspend);
+
+static void expire_wake_locks(unsigned long data)
+{
+	long has_lock;
+	unsigned long irqflags;
+	if (debug_mask & DEBUG_EXPIRE)
+		pr_info("expire_wake_locks: start\n");
+	if (debug_mask & DEBUG_SUSPEND)
+		print_active_locks(WAKE_LOCK_SUSPEND);
+	spin_lock_irqsave(&list_lock, irqflags);
+	has_lock = has_wake_lock_locked(WAKE_LOCK_SUSPEND);
+	if (debug_mask & DEBUG_EXPIRE)
+		pr_info("expire_wake_locks: done, has_lock %ld\n", has_lock);
+	if (has_lock == 0)
+		queue_work(suspend_work_queue, &suspend_work);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+static DEFINE_TIMER(expire_timer, expire_wake_locks, 0, 0);
+
+static int power_suspend_late(struct platform_device *pdev, pm_message_t state)
+{
+	int ret = has_wake_lock(WAKE_LOCK_SUSPEND) ? -EAGAIN : 0;
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	wait_for_wakeup = 1;
+#endif
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("power_suspend_late return %d\n", ret);
+	return ret;
+}
+
+static struct platform_driver power_driver = {
+	.driver.name = "power",
+	.suspend_late = power_suspend_late,
+};
+static struct platform_device power_device = {
+	.name = "power",
+};
+
+void wake_lock_init(struct wake_lock *lock, int type, const char *name)
+{
+	unsigned long irqflags = 0;
+
+	if (name)
+		lock->name = name;
+	BUG_ON(!lock->name);
+
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_lock_init name=%s\n", lock->name);
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	lock->stat.count = 0;
+	lock->stat.expire_count = 0;
+	lock->stat.wakeup_count = 0;
+	lock->stat.total_time = ktime_set(0, 0);
+	lock->stat.prevent_suspend_time = ktime_set(0, 0);
+	lock->stat.max_time = ktime_set(0, 0);
+	lock->stat.last_time = ktime_set(0, 0);
+#endif
+	lock->flags = (type & WAKE_LOCK_TYPE_MASK) | WAKE_LOCK_INITIALIZED;
+
+	INIT_LIST_HEAD(&lock->link);
+	spin_lock_irqsave(&list_lock, irqflags);
+	list_add(&lock->link, &inactive_locks);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_lock_init);
+
+void wake_lock_destroy(struct wake_lock *lock)
+{
+	unsigned long irqflags;
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_lock_destroy name=%s\n", lock->name);
+	spin_lock_irqsave(&list_lock, irqflags);
+	lock->flags &= ~WAKE_LOCK_INITIALIZED;
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	if (lock->stat.count) {
+		deleted_wake_locks.stat.count += lock->stat.count;
+		deleted_wake_locks.stat.expire_count += lock->stat.expire_count;
+		deleted_wake_locks.stat.total_time =
+			ktime_add(deleted_wake_locks.stat.total_time,
+				  lock->stat.total_time);
+		deleted_wake_locks.stat.prevent_suspend_time =
+			ktime_add(deleted_wake_locks.stat.prevent_suspend_time,
+				  lock->stat.prevent_suspend_time);
+		deleted_wake_locks.stat.max_time =
+			ktime_add(deleted_wake_locks.stat.max_time,
+				  lock->stat.max_time);
+	}
+#endif
+	list_del(&lock->link);
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_lock_destroy);
+
+static void wake_lock_internal(
+	struct wake_lock *lock, long timeout, int has_timeout)
+{
+	int type;
+	unsigned long irqflags;
+	long expire_in;
+
+	spin_lock_irqsave(&list_lock, irqflags);
+	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+	BUG_ON(type >= WAKE_LOCK_TYPE_COUNT);
+	BUG_ON(!(lock->flags & WAKE_LOCK_INITIALIZED));
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	if (type == WAKE_LOCK_SUSPEND && wait_for_wakeup) {
+		if (debug_mask & DEBUG_WAKEUP)
+			pr_info("wakeup wake lock: %s\n", lock->name);
+		wait_for_wakeup = 0;
+		lock->stat.wakeup_count++;
+	}
+	if ((lock->flags & WAKE_LOCK_AUTO_EXPIRE) &&
+	    (long)(lock->expires - jiffies) <= 0) {
+		wake_unlock_stat_locked(lock, 0);
+		lock->stat.last_time = ktime_get();
+	}
+#endif
+	if (!(lock->flags & WAKE_LOCK_ACTIVE)) {
+		lock->flags |= WAKE_LOCK_ACTIVE;
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+		lock->stat.last_time = ktime_get();
+#endif
+	}
+	list_del(&lock->link);
+	if (has_timeout) {
+		if (debug_mask & DEBUG_WAKE_LOCK)
+			pr_info("wake_lock: %s, type %d, timeout %ld.%03lu\n",
+				lock->name, type, timeout / HZ,
+				(timeout % HZ) * MSEC_PER_SEC / HZ);
+		lock->expires = jiffies + timeout;
+		lock->flags |= WAKE_LOCK_AUTO_EXPIRE;
+		list_add_tail(&lock->link, &active_wake_locks[type]);
+	} else {
+		if (debug_mask & DEBUG_WAKE_LOCK)
+			pr_info("wake_lock: %s, type %d\n", lock->name, type);
+		lock->expires = LONG_MAX;
+		lock->flags &= ~WAKE_LOCK_AUTO_EXPIRE;
+		list_add(&lock->link, &active_wake_locks[type]);
+	}
+	if (type == WAKE_LOCK_SUSPEND) {
+		current_event_num++;
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+		if (lock == &main_wake_lock)
+			update_sleep_wait_stats_locked(1);
+		else if (!wake_lock_active(&main_wake_lock))
+			update_sleep_wait_stats_locked(0);
+#endif
+		if (has_timeout)
+			expire_in = has_wake_lock_locked(type);
+		else
+			expire_in = -1;
+		if (expire_in > 0) {
+			if (debug_mask & DEBUG_EXPIRE)
+				pr_info("wake_lock: %s, start expire timer, "
+					"%ld\n", lock->name, expire_in);
+			mod_timer(&expire_timer, jiffies + expire_in);
+		} else {
+			if (del_timer(&expire_timer))
+				if (debug_mask & DEBUG_EXPIRE)
+					pr_info("wake_lock: %s, stop expire timer\n",
+						lock->name);
+			if (expire_in == 0)
+				queue_work(suspend_work_queue, &suspend_work);
+		}
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+
+void wake_lock(struct wake_lock *lock)
+{
+	wake_lock_internal(lock, 0, 0);
+}
+EXPORT_SYMBOL(wake_lock);
+
+void wake_lock_timeout(struct wake_lock *lock, long timeout)
+{
+	wake_lock_internal(lock, timeout, 1);
+}
+EXPORT_SYMBOL(wake_lock_timeout);
+
+void wake_unlock(struct wake_lock *lock)
+{
+	int type;
+	unsigned long irqflags;
+	spin_lock_irqsave(&list_lock, irqflags);
+	type = lock->flags & WAKE_LOCK_TYPE_MASK;
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	wake_unlock_stat_locked(lock, 0);
+#endif
+	if (debug_mask & DEBUG_WAKE_LOCK)
+		pr_info("wake_unlock: %s\n", lock->name);
+	lock->flags &= ~(WAKE_LOCK_ACTIVE | WAKE_LOCK_AUTO_EXPIRE);
+	list_del(&lock->link);
+	list_add(&lock->link, &inactive_locks);
+	if (type == WAKE_LOCK_SUSPEND) {
+		long has_lock = has_wake_lock_locked(type);
+		if (has_lock > 0) {
+			if (debug_mask & DEBUG_EXPIRE)
+				pr_info("wake_unlock: %s, start expire timer, "
+					"%ld\n", lock->name, has_lock);
+			mod_timer(&expire_timer, jiffies + has_lock);
+		} else {
+			if (del_timer(&expire_timer))
+				if (debug_mask & DEBUG_EXPIRE)
+					pr_info("wake_unlock: %s, stop expire "
+						"timer\n", lock->name);
+			if (has_lock == 0)
+				queue_work(suspend_work_queue, &suspend_work);
+		}
+		if (lock == &main_wake_lock) {
+			if (debug_mask & DEBUG_SUSPEND)
+				print_active_locks(WAKE_LOCK_SUSPEND);
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+			update_sleep_wait_stats_locked(0);
+#endif
+		}
+	}
+	spin_unlock_irqrestore(&list_lock, irqflags);
+}
+EXPORT_SYMBOL(wake_unlock);
+
+int wake_lock_active(struct wake_lock *lock)
+{
+	return !!(lock->flags & WAKE_LOCK_ACTIVE);
+}
+EXPORT_SYMBOL(wake_lock_active);
+
+static int __init wakelocks_init(void)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(active_wake_locks); i++)
+		INIT_LIST_HEAD(&active_wake_locks[i]);
+
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	wake_lock_init(&deleted_wake_locks, WAKE_LOCK_SUSPEND,
+			"deleted_wake_locks");
+#endif
+	wake_lock_init(&main_wake_lock, WAKE_LOCK_SUSPEND, "main");
+	wake_lock(&main_wake_lock);
+	wake_lock_init(&unknown_wakeup, WAKE_LOCK_SUSPEND, "unknown_wakeups");
+
+	ret = platform_device_register(&power_device);
+	if (ret) {
+		pr_err("wakelocks_init: platform_device_register failed\n");
+		goto err_platform_device_register;
+	}
+	ret = platform_driver_register(&power_driver);
+	if (ret) {
+		pr_err("wakelocks_init: platform_driver_register failed\n");
+		goto err_platform_driver_register;
+	}
+
+	suspend_work_queue = create_singlethread_workqueue("suspend");
+	if (suspend_work_queue == NULL) {
+		ret = -ENOMEM;
+		goto err_suspend_work_queue;
+	}
+
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	create_proc_read_entry("wakelocks", S_IRUGO, NULL,
+				wakelocks_read_proc, NULL);
+#endif
+
+	return 0;
+
+err_suspend_work_queue:
+	platform_driver_unregister(&power_driver);
+err_platform_driver_register:
+	platform_device_unregister(&power_device);
+err_platform_device_register:
+	wake_lock_destroy(&unknown_wakeup);
+	wake_lock_destroy(&main_wake_lock);
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	wake_lock_destroy(&deleted_wake_locks);
+#endif
+	return ret;
+}
+
+static void  __exit wakelocks_exit(void)
+{
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	remove_proc_entry("wakelocks", NULL);
+#endif
+	destroy_workqueue(suspend_work_queue);
+	platform_driver_unregister(&power_driver);
+	platform_device_unregister(&power_device);
+	wake_lock_destroy(&unknown_wakeup);
+	wake_lock_destroy(&main_wake_lock);
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	wake_lock_destroy(&deleted_wake_locks);
+#endif
+}
+
+core_initcall(wakelocks_init);
+module_exit(wakelocks_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/composite.c linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/composite.c
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/composite.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/composite.c	2009-05-10 22:28:00.000000000 +0200
@@ -1046,7 +1046,11 @@
 /*-------------------------------------------------------------------------*/
 
 static struct usb_gadget_driver composite_driver = {
+#ifdef	CONFIG_USB_GADGET_DUALSPEED
 	.speed		= USB_SPEED_HIGH,
+#else
+	.speed		= USB_SPEED_FULL,
+#endif
 
 	.bind		= composite_bind,
 	.unbind		= __exit_p(composite_unbind),
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/epautoconf.c linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/epautoconf.c
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/epautoconf.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/epautoconf.c	2009-05-10 22:28:00.000000000 +0200
@@ -275,6 +275,18 @@
 		ep = find_ep (gadget, "ep1-bulk");
 		if (ep && ep_matches (gadget, ep, desc))
 			return ep;
+	} else if (gadget_is_s3c64xx(gadget)) {
+		if (USB_ENDPOINT_XFER_INT == type) {
+			/* single buffering is enough */
+			ep = find_ep(gadget, "ep3-int");
+			if (ep && ep_matches(gadget, ep, desc))
+				return ep;
+		} else if (USB_ENDPOINT_XFER_BULK == type
+				&& (USB_DIR_IN & desc->bEndpointAddress)) {
+			ep = find_ep(gadget, "ep2-bulk");
+			if (ep && ep_matches(gadget, ep, desc))
+				return ep;
+		}
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/ether.c linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/ether.c
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/ether.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/ether.c	2009-05-10 22:28:00.000000000 +0200
@@ -122,11 +122,16 @@
  * Instead:  allocate your own, using normal USB-IF procedures.
  */
 
+#if 0
 /* Thanks to NetChip Technologies for donating this product ID.
  * It's for devices with only CDC Ethernet configurations.
  */
 #define CDC_VENDOR_NUM		0x0525	/* NetChip */
 #define CDC_PRODUCT_NUM		0xa4a1	/* Linux-USB Ethernet Gadget */
+#else
+#define CDC_VENDOR_NUM	0x1457		/* First International Computer */
+#define CDC_PRODUCT_NUM	0x5117		/* Linux-USB Ethernet Gadget */
+#endif
 
 /* For hardware that can't talk CDC, we use the same vendor ID that
  * ARM Linux has used for ethernet-over-usb, both with sa1100 and
@@ -147,8 +152,8 @@
  * used with CDC Ethernet, Linux 2.4 hosts will need updates to choose
  * the non-RNDIS configuration.
  */
-#define RNDIS_VENDOR_NUM	0x0525	/* NetChip */
-#define RNDIS_PRODUCT_NUM	0xa4a2	/* Ethernet/RNDIS Gadget */
+#define RNDIS_VENDOR_NUM	0x1457	/* NetChip */
+#define RNDIS_PRODUCT_NUM	0x5122	/* Ethernet/RNDIS Gadget */
 
 /*-------------------------------------------------------------------------*/
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/f_rndis.c linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/f_rndis.c
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/f_rndis.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/f_rndis.c	2009-05-10 22:28:00.000000000 +0200
@@ -437,7 +437,8 @@
 		DBG(cdev, "rndis req%02x.%02x v%04x i%04x l%d\n",
 			ctrl->bRequestType, ctrl->bRequest,
 			w_value, w_index, w_length);
-		req->zero = 0;
+		req->zero = value < w_length
+				&& (value % cdev->gadget->ep0->maxpacket) == 0;
 		req->length = value;
 		value = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);
 		if (value < 0)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/gadget_chips.h linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/gadget_chips.h
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/gadget_chips.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/gadget_chips.h	2009-05-10 22:28:00.000000000 +0200
@@ -104,6 +104,12 @@
 #define gadget_is_s3c2410(g)    0
 #endif
 
+#ifdef CONFIG_USB_GADGET_S3C_OTGD_HS
+#define gadget_is_s3c64xx(g)    !strcmp("s3c-otg-device", (g)->name)
+#else
+#define gadget_is_s3c64xx(g)    0
+#endif
+
 #ifdef CONFIG_USB_GADGET_AT91
 #define gadget_is_at91(g)	!strcmp("at91_udc", (g)->name)
 #else
@@ -231,6 +237,8 @@
 		return 0x22;
 	else if (gadget_is_ci13xxx(gadget))
 		return 0x23;
+	else if (gadget_is_s3c64xx(gadget))
+		return 0x24;
 	return -ENOENT;
 }
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/Kconfig linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/Kconfig	2009-05-10 22:08:45.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -291,6 +291,22 @@
 	boolean "S3C2410 udc debug messages"
 	depends on USB_GADGET_S3C2410
 
+config USB_GADGET_S3C_OTGD_HS
+       boolean "S3C high speed(2.0, dual-speed) USB OTG device"
+       depends on (CPU_S3C6400 || CPU_S3C6410)
+       select USB_GADGET_SELECTED
+       select USB_GADGET_DUALSPEED
+       help
+               Say "y" to link the driver statically, or "m" to build a
+               dynamically linked module called "s3c_udc_hs" and force all
+               gadget drivers to also be dynamically linked.
+
+config USB_S3C
+       tristate
+       depends on USB_GADGET_S3C_FS && USB_GADGET_S3C_HS && USB_GADGET_S3C_OTGD_HS
+       default USB_GADGET
+       select USB_GADGET_SELECTED
+
 #
 # Controllers available in both integrated and discrete versions
 #
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/Makefile linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/Makefile
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -19,6 +19,7 @@
 obj-$(CONFIG_USB_ATMEL_USBA)	+= atmel_usba_udc.o
 obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
+obj-$(CONFIG_USB_GADGET_S3C_OTGD_HS)	+= s3c_hs_otg.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX)	+= ci13xxx_udc.o
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/s3c2410_udc.c linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/s3c2410_udc.c
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/s3c2410_udc.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/s3c2410_udc.c	2009-05-10 22:28:00.000000000 +0200
@@ -134,6 +134,8 @@
 	return 0;
 }
 #endif
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FS
 static int s3c2410_udc_debugfs_seq_show(struct seq_file *m, void *p)
 {
 	u32 addr_reg,pwr_reg,ep_int_reg,usb_int_reg;
@@ -197,6 +199,7 @@
 	.release	= single_release,
 	.owner		= THIS_MODULE,
 };
+#endif
 
 /* io macros */
 
@@ -843,6 +846,7 @@
 	u32			ep_csr1;
 	u32			idx;
 
+handle_ep_again:
 	if (likely (!list_empty(&ep->queue)))
 		req = list_entry(ep->queue.next,
 				struct s3c2410_request, queue);
@@ -882,6 +886,8 @@
 
 		if ((ep_csr1 & S3C2410_UDC_OCSR1_PKTRDY) && req) {
 			s3c2410_udc_read_fifo(ep,req);
+			if (s3c2410_udc_fifo_count_out())
+				goto handle_ep_again;
 		}
 	}
 }
@@ -1707,6 +1713,7 @@
 	if (driver->disconnect)
 		driver->disconnect(&udc->gadget);
 
+	driver->unbind(&udc->gadget);
 	device_del(&udc->gadget.dev);
 	udc->driver = NULL;
 
@@ -1897,6 +1904,7 @@
 		udc->vbus = 1;
 	}
 
+#ifdef CONFIG_USB_GADGET_DEBUG_FS
 	if (s3c2410_udc_debugfs_root) {
 		udc->regs_info = debugfs_create_file("registers", S_IRUGO,
 				s3c2410_udc_debugfs_root,
@@ -1904,6 +1912,7 @@
 		if (!udc->regs_info)
 			dev_warn(dev, "debugfs file creation failed\n");
 	}
+#endif
 
 	dev_dbg(dev, "probe ok\n");
 
@@ -2013,12 +2022,14 @@
 
 	dprintk(DEBUG_NORMAL, "%s: version %s\n", gadget_name, DRIVER_VERSION);
 
+#ifdef CONFIG_USB_GADGET_DEBUG_FS
 	s3c2410_udc_debugfs_root = debugfs_create_dir(gadget_name, NULL);
 	if (IS_ERR(s3c2410_udc_debugfs_root)) {
 		printk(KERN_ERR "%s: debugfs dir creation failed %ld\n",
 			gadget_name, PTR_ERR(s3c2410_udc_debugfs_root));
 		s3c2410_udc_debugfs_root = NULL;
 	}
+#endif
 
 	retval = platform_driver_register(&udc_driver_2410);
 	if (retval)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/s3c_hs_otg.c linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/s3c_hs_otg.c
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/s3c_hs_otg.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/s3c_hs_otg.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,1874 @@
+/*
+ * drivers/usb/gadget/s3c_hs_otg.c
+ * Samsung S3C on-chip full/high speed USB OTG 2.0 device controllers
+ *
+ * Copyright (C) 2008 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "s3c-udc.h"
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/map.h>
+#include <plat/regs-clock.h>
+#include <plat/regs-usb-hs-otg.h>
+#include <plat/regs-sys.h>
+#include <plat/devs.h>
+
+static char *state_names[] = {
+	"WAIT_FOR_SETUP",
+	"DATA_STATE_XMIT",
+	"DATA_STATE_NEED_ZLP",
+	"WAIT_FOR_OUT_STATUS",
+	"DATA_STATE_RECV"
+};
+
+#define S3C_USB_DBG_LEVEL 0
+
+#define DBG(level, fmt, args...) do { \
+	if (level >= S3C_USB_DBG_LEVEL) { \
+		printk(KERN_INFO "[%s] " fmt, \
+				__func__, ##args); \
+	} } while (0)
+
+
+#define	DRIVER_DESC "Samsung Dual-speed USB 2.0 OTG Device Controller"
+#define DRIVER_AUTHOR "Samsung Electronics"
+#define	DRIVER_VERSION "04 Dec 2008"
+
+
+struct s3c_udc	*the_controller;
+
+static const char driver_name[] = "s3c-otg-device";
+static const char driver_desc[] = DRIVER_DESC;
+static const char ep0name[] = "ep0-control";
+
+static u32 tx_ep_num = 2;
+
+static u32 ep0_fifo_size = EP0_FIFO_SIZE;
+static u32 ep_fifo_size =  EP_FIFO_SIZE;
+static u32 ep_fifo_size2 = EP_FIFO_SIZE2;
+
+struct usb_ctrlrequest ctrl;
+static int reset_available = 1;
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+
+static const char proc_node_name[] = "driver/otg";
+
+static int
+udc_proc_read(char *page, char **start, off_t off, int count,
+	      int *eof, void *_dev)
+{
+	char *buf = page;
+	struct s3c_udc *dev = _dev;
+	char *next = buf;
+	unsigned size = count;
+	unsigned long flags;
+	int t;
+
+	if (off != 0)
+		return 0;
+
+	local_irq_save(flags);
+
+	/* basic device status */
+	t = scnprintf(next, size,
+		      DRIVER_DESC "\n"
+		      "%s version: %s\n"
+		      "Gadget driver: %s\n"
+		      "\n",
+		      driver_name, DRIVER_VERSION,
+		      dev->driver ? dev->driver->driver.name : "(none)");
+	size -= t;
+	next += t;
+
+	local_irq_restore(flags);
+	*eof = 1;
+	return count - size;
+}
+
+#define create_proc_files() \
+	create_proc_read_entry(proc_node_name, 0, NULL, udc_proc_read, dev)
+#define remove_proc_files() \
+	remove_proc_entry(proc_node_name, NULL)
+
+#else	/* !CONFIG_USB_GADGET_DEBUG_FILES */
+
+#define create_proc_files() do {} while (0)
+#define remove_proc_files() do {} while (0)
+
+#endif	/* CONFIG_USB_GADGET_DEBUG_FILES */
+
+
+static u32 s3c_otg_readl(struct s3c_udc *dev, u32 reg)
+{
+	return __raw_readl((u32)dev->reg_base + reg);
+}
+
+static void s3c_otg_writel(struct s3c_udc *dev, u32 val, u32 reg)
+{
+	__raw_writel(val, ((u32)dev->reg_base) + reg);
+}
+
+static void s3c_otg_orl(struct s3c_udc *dev, u32 val, u32 reg)
+{
+	u32 temp = __raw_readl(((u32)dev->reg_base) + reg);
+
+	__raw_writel(val|temp, ((u32)dev->reg_base) + reg);
+}
+
+/*
+ *	retire a request
+ */
+static void s3c_otg_done(struct s3c_ep *ep, struct s3c_request *req, int status)
+{
+	unsigned int stopped = ep->stopped;
+
+	DBG(1, "%s %p, stopped = %d\n", ep->ep.name, ep, stopped);
+	list_del_init(&req->queue);
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	if (status && (status != -ESHUTDOWN))
+		DBG(2, "complete %s stat %d len %u/%u\n",
+			ep->ep.name, status, req->req.actual, req->req.length);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+
+	spin_unlock(&ep->dev->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&ep->dev->lock);
+
+	ep->stopped = stopped;
+}
+
+/*
+ * 	dequeue ALL requests
+ */
+void s3c_otg_nuke(struct s3c_ep *ep, int status)
+{
+	struct s3c_request *req;
+
+	DBG(1, "%s %p\n", ep->ep.name, ep);
+
+	/* called with irqs blocked */
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+		s3c_otg_done(ep, req, status);
+	}
+}
+
+static void s3c_otg_ep_control(int ep, int dir, u32 val, int update)
+{
+	u32 epctrl;
+
+	switch (ep) {
+	case 0:
+		if (dir)
+			epctrl = (u32)S3C_UDC_OTG_DIEPCTL0;
+		else
+			epctrl = (u32)S3C_UDC_OTG_DOEPCTL0;
+		break;
+	case 1:
+		if (dir)
+			epctrl = -EOPNOTSUPP;
+		else
+			epctrl = (u32)S3C_UDC_OTG_DOEPCTL1;
+		break;
+	case 2:
+		if (dir)
+			epctrl = (u32)S3C_UDC_OTG_DIEPCTL2;
+		else
+			epctrl = -EOPNOTSUPP;
+		break;
+	case 3:
+		if (dir)
+			epctrl = (u32)S3C_UDC_OTG_DIEPCTL3;
+		else
+			epctrl = -EOPNOTSUPP;
+		break;
+	default:
+		DBG(3, "ep%d is unused Endpoint", ep);
+		return;
+	}
+
+	if (epctrl < 0) {
+		DBG(3, "ep%d - %s is invalid direction\n",
+				ep, dir ? "IN" : "OUT");
+		return;
+	}
+
+	if (update)
+		s3c_otg_orl(the_controller, val, epctrl);
+	else
+		s3c_otg_writel(the_controller, val, epctrl);
+}
+
+static int s3c_otg_write_packet(struct s3c_ep *ep,
+		struct s3c_request *req, int max)
+{
+	u32 *buf;
+	int length;
+	int count;
+	u32 fifo = ep->fifo;
+	u32 epsize;
+
+	buf = req->req.buf + req->req.actual;
+	prefetch(buf);
+
+	length = req->req.length - req->req.actual;
+	length = min(length, max);
+	req->req.actual += length;
+
+	DBG(1, "%s: %d/%d, fifo=0x%x\n", ep->ep.name, length, max, fifo);
+
+	switch (ep_index(ep)) {
+	case 0:
+		epsize = (u32)S3C_UDC_OTG_DIEPTSIZ0;
+		break;
+	case 2:
+		epsize = (u32)S3C_UDC_OTG_DIEPTSIZ2;
+		break;
+	case 3:
+		epsize = (u32)S3C_UDC_OTG_DIEPTSIZ3;
+		break;
+	default:
+		DBG(3, "ep%d is unused Endpoint", ep_index(ep));
+		return 0;
+	}
+
+	s3c_otg_writel(ep->dev, PKT_CNT(0x1)|XFERSIZE(length), epsize);
+	s3c_otg_ep_control(ep_index(ep), USB_DIR_IN,
+			DEPCTL_EPENA|DEPCTL_CNAK, 1);
+
+	for (count = 0; count < length; count += 4)
+		s3c_otg_writel(ep->dev, *buf++, fifo);
+
+	return length;
+}
+
+static int s3c_otg_write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+
+	max = ep_maxpacket(ep);
+	count = s3c_otg_write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (count != max) {
+		is_last = 1;
+	} else {
+		if ((req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+
+	DBG(2, "wrote %s %d bytes%s %d left %p\n",
+			ep->ep.name, count,	is_last ? "/L" : "",
+			req->req.length - req->req.actual, req);
+
+	/* requests complete when all IN data is in the FIFO */
+	return is_last;
+}
+
+static int s3c_otg_read_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 csr;
+	u32 *buf;
+	unsigned bufferspace;
+	unsigned count;
+	unsigned is_short;
+	unsigned bytes;
+	u32 fifo = ep->fifo;
+
+	csr = s3c_otg_readl(ep->dev, S3C_UDC_OTG_GRXSTSP);
+	bytes = BYTE_COUNT(csr);
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	if (EP_NUM(csr) == 0) {
+		count = bytes / 4 + (bytes % 4 ? 1 : 0);
+		req->req.actual += min(bytes, bufferspace);
+	} else {
+		count = 0;
+		bytes = 0;
+	}
+
+	is_short = (bytes < ep->ep.maxpacket);
+
+	DBG(2, "read %s %d bytes%s %d/%d\n",
+		  ep->ep.name, bytes, is_short ? "/S" : "",
+		  req->req.actual, req->req.length);
+
+	while (count--) {
+		u32 byte = s3c_otg_readl(ep->dev, fifo);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				DBG(3, "%s overflow %d\n", ep->ep.name, count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace -= 4;
+		}
+	}
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length)
+		return 1;
+
+	return 0;
+}
+
+static int s3c_otg_write_ep0(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret;
+	int need_zlp = 0;
+
+	if (list_empty(&ep->queue))
+		req = NULL;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (!req) {
+		DBG(2, "NULL REQ\n");
+		return 0;
+	}
+
+	DBG(2, "length = 0x%x, actual = 0x%x\n",
+			req->req.length, req->req.actual);
+
+	if (req->req.length == 0) {
+		dev->ep0state = WAIT_FOR_SETUP;
+		s3c_otg_done(ep, req, 0);
+		return 1;
+	}
+
+	/* Next write will end with the packet size, */
+	/* so we need Zero-length-packet */
+	if (req->req.length - req->req.actual == ep0_fifo_size)
+		need_zlp = 1;
+
+	ret = s3c_otg_write_fifo_ep0(ep, req);
+
+	if ((ret == 1) && !need_zlp) {
+		/* Last packet */
+		DBG(1, "finished, waiting for status\n");
+		dev->ep0state = WAIT_FOR_SETUP;
+	}
+
+	if (need_zlp) {
+		DBG(1, "Need ZLP!\n");
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+
+	if (ret)
+		s3c_otg_done(ep, req, 0);
+
+	return ret;
+}
+
+static int first_time = 1;
+
+static int s3c_otg_read_ep0(struct s3c_udc *dev)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep = &dev->ep[0];
+	int ret;
+
+	if (!list_empty(&ep->queue))
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+	else {
+		DBG(3, "---> BUG\n");
+		BUG();
+		return 0;
+	}
+
+	DBG(2, "length = 0x%x, actual = 0x%x\n",
+			req->req.length, req->req.actual);
+
+	if (req->req.length == 0) {
+		dev->ep0state = WAIT_FOR_SETUP;
+		first_time = 1;
+		s3c_otg_done(ep, req, 0);
+		return 1;
+	}
+
+	if (!req->req.actual && first_time) {
+		first_time = 0;
+		return 1;
+	}
+
+	ret = s3c_otg_read_fifo_ep0(ep, req);
+
+	if (ret)
+		s3c_otg_done(ep, req, 0);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	first_time = 1;
+
+	return ret;
+}
+
+static void s3c_otg_kick_ep0(struct s3c_udc *dev, struct s3c_ep *ep)
+{
+	int res = 0;
+
+	DBG(1, "ep_is_in = %d\n", ep_is_in(ep));
+
+	if (ep_is_in(ep)) {
+		dev->ep0state = DATA_STATE_XMIT;
+		while (!res)
+			res = s3c_otg_write_ep0(dev);
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		s3c_otg_read_ep0(dev);
+	}
+}
+
+/*
+ * Write request to FIFO
+ */
+static int s3c_otg_write_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 max;
+	u32 gintmsk;
+	unsigned count;
+	int is_last = 0;
+	int is_short = 0;
+
+	gintmsk = s3c_otg_readl(ep->dev, S3C_UDC_OTG_GINTMSK);
+
+	max = le16_to_cpu(ep->desc->wMaxPacketSize);
+	count = s3c_otg_write_packet(ep, req, max);
+
+	/* last packet is usually short (or a zlp) */
+	if (count != max) {
+		is_last = 1;
+		is_short = 1;
+	} else {
+		if ((req->req.length != req->req.actual) || req->req.zero)
+			is_last = 0;
+		else
+			is_last = 1;
+
+		/* interrupt/iso maxpacket may not fill the fifo */
+		is_short = (max < ep_maxpacket(ep));
+	}
+
+	DBG(2, "wrote %s %d bytes%s%s %d/%d\n",
+			ep->ep.name, count,
+			is_last ? "/L" : "", is_short ? "/S" : "",
+			req->req.actual, req->req.length);
+
+	/* requests complete when all IN data is in the FIFO */
+	if (is_last) {
+		if (ep_index(ep) == 0) {
+			DBG(3, "--> EP0 must not come here!\n");
+			BUG();
+		}
+
+		s3c_otg_writel(ep->dev, gintmsk & (~INT_TX_FIFO_EMPTY),
+				(u32)S3C_UDC_OTG_GINTMSK);
+		s3c_otg_done(ep, req, 0);
+
+		return 1;
+	}
+
+	s3c_otg_writel(ep->dev, gintmsk|INT_TX_FIFO_EMPTY,
+			(u32)S3C_UDC_OTG_GINTMSK);
+
+	return 0;
+}
+
+/*
+ * Read to request from FIFO (max read == bytes in fifo)
+ */
+static int s3c_otg_read_fifo(struct s3c_ep *ep, struct s3c_request *req)
+{
+	u32 csr;
+	u32 gintmsk;
+	u32 *buf;
+	unsigned bufferspace;
+	unsigned count;
+	unsigned is_short = 0;
+	unsigned bytes;
+	u32 fifo = ep->fifo;
+
+	csr = s3c_otg_readl(ep->dev, S3C_UDC_OTG_GRXSTSP);
+	bytes = BYTE_COUNT(csr);
+	gintmsk = readl(S3C_UDC_OTG_GINTMSK);
+
+	if (!bytes) {
+		DBG(2, "%d bytes\n", bytes);
+		s3c_otg_orl(ep->dev, INT_RX_FIFO_NOT_EMPTY,
+				(u32)S3C_UDC_OTG_GINTMSK);
+		return 0;
+	}
+
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+
+	count = bytes / 4 + (bytes % 4 ? 1 : 0);
+	req->req.actual += min(bytes, bufferspace);
+
+	is_short = (bytes < ep->ep.maxpacket);
+
+	DBG(2, "read %s %d bytes%s %d/%d\n",
+			ep->ep.name, bytes, is_short ? "/S" : "",
+			req->req.actual, req->req.length);
+
+	while (count--) {
+		u32 byte = s3c_otg_readl(ep->dev, fifo);
+
+		if (unlikely(bufferspace == 0)) {
+			/* this happens when the driver's buffer
+			 * is smaller than what the host sent.
+			 * discard the extra data.
+			 */
+			if (req->req.status != -EOVERFLOW)
+				DBG(3, "%s overflow %d\n", ep->ep.name, count);
+			req->req.status = -EOVERFLOW;
+		} else {
+			*buf++ = byte;
+			bufferspace -= 4;
+		}
+	}
+
+	s3c_otg_writel(ep->dev, gintmsk|INT_RX_FIFO_NOT_EMPTY,
+			(u32)S3C_UDC_OTG_GINTMSK);
+
+	/* completion */
+	if (is_short || req->req.actual == req->req.length) {
+		s3c_otg_done(ep, req, 0);
+		return 1;
+	}
+
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+static struct usb_request *s3c_otg_alloc_request(
+		struct usb_ep *ep, gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+
+	if (!ep)
+		return NULL;
+
+	DBG(1, "%s %p\n", ep->name, ep);
+
+	req = kzalloc(sizeof *req, gfp_flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void s3c_otg_free_request(struct usb_ep *ep, struct usb_request *_req)
+{
+	struct s3c_request *req;
+
+	if (!ep)
+		return;
+
+	DBG(1, "%s %p\n", ep->name, ep);
+
+	if (!_req)
+		return;
+
+	req = container_of(_req, struct s3c_request, req);
+
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+/*
+ * Queue one request
+ *  Kickstart transfer if needed
+ */
+static int s3c_otg_queue(struct usb_ep *_ep,
+		struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct s3c_request *req;
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+	u32 csr;
+
+	req = container_of(_req, struct s3c_request, req);
+	if (!_req || !_req->complete || !_req->buf
+			|| !list_empty(&req->queue)) {
+		DBG(3, "bad params\n");
+		return -EINVAL;
+	}
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || (!ep->desc && ep->ep.name != ep0name)) {
+		DBG(3, "bad ep\n");
+		return -EINVAL;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DBG(3, "bogus device state %p\n", dev->driver);
+		return -ESHUTDOWN;
+	}
+
+	DBG(2, "%s queue req %p, len %d buf %p\n",
+			_ep->name, _req, _req->length, _req->buf);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	DBG(2, "ep=%d, Q empty=%d, stopped=%d\n",
+			ep_index(ep), list_empty(&ep->queue), ep->stopped);
+
+	/* kickstart this i/o queue? */
+	if (list_empty(&ep->queue) && !ep->stopped) {
+		if (ep_index(ep) == 0) {
+			list_add_tail(&req->queue, &ep->queue);
+			s3c_otg_kick_ep0(dev, ep);
+			req = NULL;
+		} else if (ep_is_in(ep)) {
+			csr = s3c_otg_readl(ep->dev, S3C_UDC_OTG_GINTSTS);
+
+			if ((csr & INT_TX_FIFO_EMPTY) &&
+			   (s3c_otg_write_fifo(ep, req) == 1))
+				req = NULL;
+			else
+				tx_ep_num = ep_index(ep);
+		} else {
+			csr = s3c_otg_readl(ep->dev, S3C_UDC_OTG_GINTSTS);
+
+			if ((csr & INT_RX_FIFO_NOT_EMPTY) &&
+			   (s3c_otg_read_fifo(ep, req) == 1))
+				req = NULL;
+		}
+	}
+
+	/* pio or dma irq handler advances the queue. */
+	if (req)
+		list_add_tail(&req->queue, &ep->queue);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/*
+ * dequeue JUST ONE request
+ */
+static int s3c_otg_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct s3c_ep *ep;
+	struct s3c_request *req;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || ep->ep.name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	s3c_otg_done(ep, req, -ECONNRESET);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	return 0;
+}
+
+static int s3c_otg_set_halt(struct usb_ep *_ep, int value)
+{
+	return 0;
+}
+
+static int s3c_otg_fifo_status(struct usb_ep *_ep)
+{
+	int count = 0;
+	struct s3c_ep *ep;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep) {
+		DBG(3, "bad ep\n");
+		return -ENODEV;
+	}
+
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if (ep_is_in(ep))
+		return -EOPNOTSUPP;
+
+	return count;
+}
+
+static void s3c_otg_fifo_flush(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
+		DBG(3, "bad ep\n");
+		return;
+	}
+}
+
+static int s3c_otg_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct s3c_ep *ep;
+	struct s3c_udc *dev;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+	    || desc->bDescriptorType != USB_DT_ENDPOINT
+	    || ep->bEndpointAddress != desc->bEndpointAddress
+	    || ep_maxpacket(ep) < le16_to_cpu(desc->wMaxPacketSize)) {
+		DBG(3, "bad ep or descriptor\n");
+		return -EINVAL;
+	}
+
+	/* xfer types must match, except that interrupt ~= bulk */
+	if (ep->bmAttributes != desc->bmAttributes
+			&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK
+			&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
+		DBG(3, "%s type mismatch\n", _ep->name);
+		return -EINVAL;
+	}
+
+	/* hardware _could_ do smaller, but driver doesn't */
+	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
+			&& le16_to_cpu(desc->wMaxPacketSize)
+			!= ep_maxpacket(ep))
+			|| !desc->wMaxPacketSize) {
+		DBG(3, "bad %s maxpacket\n", _ep->name);
+		return -ERANGE;
+	}
+
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		DBG(3, "bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	ep->stopped = 0;
+	ep->desc = desc;
+	ep->pio_irqs = 0;
+	ep->ep.maxpacket = le16_to_cpu(desc->wMaxPacketSize);
+
+	/* Reset halt state */
+	s3c_otg_set_halt(_ep, 0);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DBG(2, "enabled %s, stopped = %d, maxpacket = %d\n",
+		_ep->name, ep->stopped, ep->ep.maxpacket);
+	return 0;
+}
+
+static int s3c_otg_ep_disable(struct usb_ep *_ep)
+{
+	struct s3c_ep *ep;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct s3c_ep, ep);
+	if (!_ep || !ep->desc) {
+		DBG(3, "%s not enabled\n", _ep ? ep->ep.name : NULL);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+
+	/* Nuke all pending requests */
+	s3c_otg_nuke(ep, -ESHUTDOWN);
+
+	ep->desc = 0;
+	ep->stopped = 1;
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	DBG(2, "disabled %s\n", _ep->name);
+	return 0;
+}
+
+static struct usb_ep_ops s3c_ep_ops = {
+	.enable = s3c_otg_ep_enable,
+	.disable = s3c_otg_ep_disable,
+
+	.alloc_request = s3c_otg_alloc_request,
+	.free_request = s3c_otg_free_request,
+
+	.queue = s3c_otg_queue,
+	.dequeue = s3c_otg_dequeue,
+
+	.set_halt = s3c_otg_set_halt,
+	.fifo_status = s3c_otg_fifo_status,
+	.fifo_flush = s3c_otg_fifo_flush,
+};
+
+void s3c_otg_set_ep(struct s3c_udc *dev, enum usb_device_speed speed)
+{
+	u32 ep0_mps = DEPCTL0_MPS_64;
+
+	if (speed == USB_SPEED_FULL) {
+		ep0_fifo_size = 8;
+		ep_fifo_size = 64;
+		ep_fifo_size2 = 64;
+
+		ep0_mps = DEPCTL0_MPS_8;
+	}
+
+	dev->gadget.speed = speed;
+
+	dev->ep[0].ep.maxpacket = ep0_fifo_size;
+	dev->ep[1].ep.maxpacket = ep_fifo_size;
+	dev->ep[2].ep.maxpacket = ep_fifo_size;
+	dev->ep[3].ep.maxpacket = ep_fifo_size;
+	dev->ep[4].ep.maxpacket = ep_fifo_size;
+	dev->ep[5].ep.maxpacket = ep_fifo_size2;
+	dev->ep[6].ep.maxpacket = ep_fifo_size2;
+	dev->ep[7].ep.maxpacket = ep_fifo_size2;
+	dev->ep[8].ep.maxpacket = ep_fifo_size2;
+
+	/* EP0 - Control */
+	s3c_otg_ep_control(0, USB_DIR_OUT, ep0_mps, 1);
+	s3c_otg_ep_control(0, USB_DIR_IN, ep0_mps, 1);
+
+	/* EP1 - Bulk Data OUT */
+	s3c_otg_ep_control(1, USB_DIR_OUT, ep_fifo_size, 1);
+
+	/* EP2 - Bulk Data IN */
+	s3c_otg_ep_control(2, USB_DIR_IN, ep_fifo_size, 1);
+
+	/* EP3 - INTR Data IN */
+	s3c_otg_ep_control(3, USB_DIR_IN, ep_fifo_size, 1);
+
+	DBG(2, "%s Speed Detection\n",
+			speed == USB_SPEED_HIGH ? "High" : "Full");
+}
+
+/*
+ * set the USB address for this device
+ *
+ * Called from control endpoint function
+ * after it decodes a set address setup packet.
+ */
+static void s3c_otg_set_address(struct s3c_udc *dev, unsigned char addr)
+{
+	s3c_otg_orl(dev, DEVICE_ADDR(addr), S3C_UDC_OTG_DCFG);
+	s3c_otg_ep_control(0, USB_DIR_IN, DEPCTL_EPENA|DEPCTL_CNAK, 1);
+
+	DBG(2, "USB OTG 2.0 Device Address=%d\n", addr);
+
+	dev->usb_address = addr;
+}
+
+static inline int s3c_otg_read_setup(struct s3c_ep *ep, u32 *ctrl, int max)
+{
+	int bytes;
+	int count;
+	u32 csr = s3c_otg_readl(ep->dev, S3C_UDC_OTG_GRXSTSP);
+
+	bytes = BYTE_COUNT(csr);
+
+	/* 32 bits interface */
+	count = bytes / 4;
+
+	while (count--)
+		*ctrl++ = s3c_otg_readl(ep->dev, S3C_UDC_OTG_EP0_FIFO);
+
+	return bytes;
+}
+
+static void s3c_otg_setup(struct s3c_udc *dev)
+{
+	struct s3c_ep *ep = &dev->ep[0];
+	int bytes;
+	int is_in;
+	int ret;
+
+	/* Nuke all previous transfers */
+	s3c_otg_nuke(ep, -EPROTO);
+
+	/* read control req from fifo (8 bytes) */
+	bytes = s3c_otg_read_setup(ep, (u32 *)&ctrl, 8);
+
+	DBG(2, "SETUP REQ %02x %02x %04x %04x %d\n",
+			ctrl.bRequestType, ctrl.bRequest,
+			ctrl.wValue, ctrl.wIndex, ctrl.wLength);
+
+	/* Set direction of EP0 */
+	if (ctrl.bRequestType & USB_DIR_IN) {
+		ep->bEndpointAddress |= USB_DIR_IN;
+		is_in = 1;
+	} else {
+		ep->bEndpointAddress &= ~USB_DIR_IN;
+		is_in = 0;
+	}
+
+	dev->req_pending = 1;
+
+	/* Handle some SETUP packets ourselves */
+	switch (ctrl.bRequest) {
+	case USB_REQ_SET_ADDRESS:
+		if (ctrl.bRequestType != (USB_TYPE_STANDARD|USB_RECIP_DEVICE))
+			break;
+
+		s3c_otg_set_address(dev, ctrl.wValue);
+		return;
+
+	case USB_REQ_SET_INTERFACE:
+		DBG(2, "USB_REQ_SET_INTERFACE (%d)\n", ctrl.wValue);
+		/* FALLTHROUGH */
+
+	case USB_REQ_SET_CONFIGURATION:
+		DBG(2, "USB_REQ_SET_CONFIGURATION (%d)\n", ctrl.wValue);
+
+		s3c_otg_ep_control(0, USB_DIR_IN,
+				DEPCTL_EPENA|DEPCTL_CNAK, 1);
+		s3c_otg_ep_control(1, USB_DIR_OUT,
+				DEPCTL_EPDIS|DEPCTL_CNAK|
+				DEPCTL_BULK_TYPE|DEPCTL_USBACTEP, 1);
+		s3c_otg_ep_control(2, USB_DIR_IN,
+				DEPCTL_BULK_TYPE|DEPCTL_USBACTEP, 1);
+		s3c_otg_ep_control(3, USB_DIR_IN,
+				DEPCTL_BULK_TYPE|DEPCTL_USBACTEP, 1);
+
+		reset_available = 1;
+		dev->req_config = 1;
+		break;
+
+	case USB_REQ_GET_DESCRIPTOR:
+		DBG(2, "USB_REQ_GET_DESCRIPTOR\n");
+		break;
+
+	case USB_REQ_GET_CONFIGURATION:
+		DBG(2, "USB_REQ_GET_CONFIGURATION\n");
+		break;
+
+	case USB_REQ_GET_STATUS:
+		DBG(2, "USB_REQ_GET_STATUS\n");
+		s3c_otg_ep_control(0, USB_DIR_IN, DEPCTL_EPENA|DEPCTL_CNAK, 1);
+		break;
+
+	case USB_REQ_CLEAR_FEATURE:
+		DBG(2, "USB_REQ_CLEAR_FEATURE\n");
+		break;
+
+	case USB_REQ_SET_FEATURE:
+		DBG(2, "USB_REQ_SET_FEATURE\n");
+		break;
+
+	default:
+		DBG(3, "Default of ctrl.bRequest=0x%x\n", ctrl.bRequest);
+		break;
+	}
+
+	if (dev->driver) {
+		/* device-2-host (IN) or no data setup command,
+		 * process immediately */
+		spin_unlock(&dev->lock);
+
+		DBG(1, "usb_ctrlrequest will be passed to fsg_setup()\n");
+
+		ret = dev->driver->setup(&dev->gadget, &ctrl);
+		spin_lock(&dev->lock);
+
+		if (ret < 0) {
+			/* setup processing failed, force stall */
+			DBG(3, "gadget setup FAILED (stalling) - %d\n", ret);
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/*
+ * handle ep0 interrupt
+ */
+static void s3c_otg_handle_ep0(struct s3c_udc *dev)
+{
+	if (dev->ep0state == WAIT_FOR_SETUP)
+		s3c_otg_setup(dev);
+	else
+		DBG(3, "strange state!! - %s\n", state_names[dev->ep0state]);
+}
+
+static void s3c_otg_handle_ep_out(struct s3c_udc *dev, u32 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req;
+
+	if (unlikely(!(ep->desc))) {
+		/* Throw packet away.. */
+		DBG(3, "No descriptor?!?\n");
+		return;
+	}
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (unlikely(!req))
+		DBG(2, "NULL REQ on OUT EP-%d\n", ep_num);
+	else
+		s3c_otg_read_fifo(ep, req);
+}
+
+static void s3c_otg_handle_ep_in(struct s3c_udc *dev, u32 ep_num)
+{
+	struct s3c_ep *ep = &dev->ep[ep_num];
+	struct s3c_request *req;
+
+	if (list_empty(&ep->queue))
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct s3c_request, queue);
+
+	if (unlikely(!req)) {
+		DBG(2, "NULL REQ on IN EP-%d\n", ep_num);
+		return;
+	} else
+		s3c_otg_write_fifo(ep, req);
+}
+
+static void s3c_otg_handle_ep(struct s3c_udc *dev, u32 gintmsk)
+{
+	u32 csr;
+	u32 packet_status;
+	u32 ep_num;
+	u32 bytes = 0;
+
+	gintmsk &= ~INT_RX_FIFO_NOT_EMPTY;
+	s3c_otg_writel(dev, gintmsk, S3C_UDC_OTG_GINTMSK);
+
+	csr = s3c_otg_readl(dev, S3C_UDC_OTG_GRXSTSR);
+
+	packet_status = PKT_STS(csr);
+	bytes = BYTE_COUNT(csr);
+	ep_num = EP_NUM(csr);
+
+	switch (packet_status) {
+	case SETUP_PKT_RECEIVED:
+		DBG(2, "SETUP received : %d bytes\n", bytes);
+		if (!bytes)
+			break;
+
+		s3c_otg_handle_ep0(dev);
+		gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+		break;
+
+	case OUT_PKT_RECEIVED:
+		if (!bytes)
+			break;
+
+		if (ep_num == 0) {
+			DBG(2, "CONTROL OUT received : %d bytes\n", bytes);
+
+			dev->ep0state = DATA_STATE_RECV;
+			s3c_otg_read_ep0(dev);
+
+			gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+		} else if (ep_num == 1) {
+			DBG(2, " Bulk OUT received : %d bytes\n", bytes);
+
+			s3c_otg_handle_ep_out(dev, 1);
+			gintmsk = s3c_otg_readl(dev,S3C_UDC_OTG_GINTMSK);
+
+			s3c_otg_ep_control(1, USB_DIR_OUT, DEPCTL_CNAK, 1);
+		} else
+			DBG(2, "Unused EP%d: %d bytes\n", ep_num, bytes);
+		break;
+
+	case SETUP_COMPLETED:
+		DBG(2, "SETUP_COMPLETED\n");
+		s3c_otg_ep_control(0, USB_DIR_OUT, DEPCTL_CNAK, 1);
+		break;
+
+	case OUT_COMPLELTED:
+		DBG(2, "OUT_COMPLELTED - ep%d\n", ep_num);
+		s3c_otg_ep_control(ep_num, USB_DIR_OUT, DEPCTL_CNAK, 1);
+		break;
+
+	default:
+		gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+		s3c_otg_ep_control(0, USB_DIR_OUT, DEPCTL_CNAK, 1);
+		DBG(1, "reserved packet received : scr=0x%08X bytes\n", csr);
+		break;
+	}
+
+	if (!bytes) {
+		csr = s3c_otg_readl(dev, S3C_UDC_OTG_GRXSTSP);
+		gintmsk |= INT_RX_FIFO_NOT_EMPTY;
+	}
+
+	s3c_otg_writel(dev, gintmsk, S3C_UDC_OTG_GINTMSK);
+}
+
+/*
+ * disable USB device controller
+ */
+static void s3c_otg_disable(struct s3c_udc *dev)
+{
+	s3c_otg_set_address(dev, 0);
+
+	dev->ep0state = WAIT_FOR_SETUP;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	dev->usb_address = 0;
+
+	s3c_otg_orl(dev, ANALOG_PWR_DOWN, S3C_USBOTG_PHYPWR);
+}
+
+/*
+ * initialize software state
+ */
+static void s3c_otg_reinit(struct s3c_udc *dev)
+{
+	u32 i;
+
+	/* device/ep0 records init */
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+	dev->ep0state = WAIT_FOR_SETUP;
+
+	/* basic endpoint records init */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+		struct s3c_ep *ep = &dev->ep[i];
+
+		if (i != 0)
+			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
+
+		ep->desc = 0;
+		ep->stopped = 0;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->pio_irqs = 0;
+	}
+}
+
+#define GUSBCFG_INIT	(PHY_CLK_480M|TXFIFO_RE_EN| \
+		TURN_AROUND|HNP_DISABLE|SRP_DISABLE|ULPI_DDR| \
+		HS_UTMI|INTERF_UTMI|PHY_INTERF_16|TIME_OUT_CAL)
+
+#define GINTMSK_INIT	(INT_RESUME|INT_ENUMDONE| \
+		INT_RESET|INT_SUSPEND|INT_RX_FIFO_NOT_EMPTY)
+
+#define DOEPMSK_INIT	(AHB_ERROR)
+
+#define DIEPMSK_INIT	(IN_EP_TIMEOUT|AHB_ERROR)
+
+#define GAHBCFG_INIT	(PTXFE_HALF|NPTXFE_HALF| \
+		MODE_SLAVE|BURST_INCR16|GBL_INT_UNMASK)
+
+static void s3c_otg_config(struct s3c_udc *dev)
+{
+	u32 reg;
+
+	/* OTG USB configuration */
+	s3c_otg_writel(dev, GUSBCFG_INIT, S3C_UDC_OTG_GUSBCFG);
+
+	/* Soft-reset OTG Core and then unreset again */
+	s3c_otg_writel(dev, CORE_SOFT_RESET, S3C_UDC_OTG_GRSTCTL);
+
+	/* Put the OTG device core in the disconnected state */
+	s3c_otg_orl(dev, SOFT_DISCONNECT, S3C_UDC_OTG_DCTL);
+
+	udelay(20);
+
+	/* Make the OTG device core exit from the disconnected state */
+	reg = s3c_otg_readl(dev, S3C_UDC_OTG_DCTL);
+	s3c_otg_writel(dev, reg & ~SOFT_DISCONNECT, S3C_UDC_OTG_DCTL);
+
+	/* Configure OTG Core to initial settings of device mode */
+	s3c_otg_orl(dev, EP_MIS_CNT(0x1)|SPEED_2_HIGH, S3C_UDC_OTG_DCFG);
+
+	udelay(1000);
+
+	/* Unmask the core interrupts */
+	s3c_otg_writel(dev, GINTMSK_INIT, S3C_UDC_OTG_GINTMSK);
+
+	/* Set NAK bit of EP0, EP1, EP2 */
+	s3c_otg_ep_control(0, USB_DIR_OUT,
+			DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL0_MPS_64, 0);
+	s3c_otg_ep_control(0, USB_DIR_IN,
+			DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL0_MPS_64, 0);
+	s3c_otg_ep_control(1, USB_DIR_OUT,
+			DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE, 0);
+	s3c_otg_ep_control(2, USB_DIR_IN,
+			DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE, 0);
+	s3c_otg_ep_control(3, USB_DIR_IN,
+			DEPCTL_EPDIS|DEPCTL_SNAK|DEPCTL_BULK_TYPE, 0);
+
+	/* Unmask EP interrupts */
+	s3c_otg_writel(dev, S3C_UDC_INT_IN_EP0
+			|S3C_UDC_INT_IN_EP2
+			|S3C_UDC_INT_IN_EP3
+			|S3C_UDC_INT_OUT_EP0
+			|S3C_UDC_INT_OUT_EP1,
+			S3C_UDC_OTG_DAINTMSK);
+
+	/* Unmask device OUT EP common interrupts */
+	s3c_otg_writel(dev, DOEPMSK_INIT, S3C_UDC_OTG_DOEPMSK);
+
+	/* Unmask device IN EP common interrupts */
+	s3c_otg_writel(dev, DIEPMSK_INIT, S3C_UDC_OTG_DIEPMSK);
+
+	/* Set Rx FIFO Size */
+	s3c_otg_writel(dev, RX_FIFO_SIZE, S3C_UDC_OTG_GRXFSIZ);
+
+	/* Set Non Periodic Tx FIFO Size */
+	s3c_otg_writel(dev, NPTX_FIFO_SIZE|NPTX_FIFO_START_ADDR,
+			(u32)S3C_UDC_OTG_GNPTXFSIZ);
+
+	/* Clear NAK bit of EP0 For Slave mode */
+	s3c_otg_ep_control(0, USB_DIR_OUT, DEPCTL_EPDIS|DEPCTL_CNAK, 0);
+
+	/* Initialize OTG Link Core */
+	s3c_otg_writel(dev, GAHBCFG_INIT, S3C_UDC_OTG_GAHBCFG);
+}
+
+static int s3c_otg_enable(struct s3c_udc *dev)
+{
+	/* USB_SIG_MASK */
+	__raw_writel(S3C64XX_OTHERS_USBMASK | __raw_readl(S3C64XX_OTHERS),
+								S3C64XX_OTHERS);
+
+	/* Initializes OTG Phy. */
+	s3c_otg_writel(dev, SUSPEND_DISABLE, S3C_USBOTG_PHYPWR);
+	
+	s3c_otg_writel(dev, dev->phyclk, S3C_USBOTG_PHYCLK);
+
+	s3c_otg_writel(dev, SW_RST_ON, S3C_USBOTG_RSTCON);
+	udelay(50);
+
+	s3c_otg_writel(dev, SW_RST_OFF, S3C_USBOTG_RSTCON);
+	udelay(50);
+
+	s3c_otg_config(dev);
+
+	DBG(2, "S3C USB 2.0 OTG Controller Core Initialized\n");
+
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	return 0;
+}
+
+/*
+ *	usb client interrupt handler.
+ */
+static irqreturn_t s3c_otg_irq(int irq, void *_dev)
+{
+	struct s3c_udc *dev = _dev;
+	u32 intr_status;
+	u32 usb_status;
+	u32 gintmsk;
+
+	spin_lock(&dev->lock);
+
+	intr_status = s3c_otg_readl(dev, S3C_UDC_OTG_GINTSTS);
+	gintmsk = s3c_otg_readl(dev, S3C_UDC_OTG_GINTMSK);
+
+	DBG(1, "GINTSTS=0x%x(on state %s), GINTMSK : 0x%x\n",
+			intr_status, state_names[dev->ep0state], gintmsk);
+
+	if (!intr_status) {
+		spin_unlock(&dev->lock);
+		return IRQ_HANDLED;
+	}
+
+	if (intr_status & INT_ENUMDONE) {
+		DBG(2, "Speed Detection interrupt\n");
+		s3c_otg_writel(dev, INT_ENUMDONE, S3C_UDC_OTG_GINTSTS);
+
+		usb_status = ENUM_SPEED(s3c_otg_readl(dev, S3C_UDC_OTG_DSTS));
+
+		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ))
+			s3c_otg_set_ep(dev, USB_SPEED_FULL);
+		else
+			s3c_otg_set_ep(dev, USB_SPEED_HIGH);
+	}
+
+	if (intr_status & INT_EARLY_SUSPEND) {
+		DBG(2, "Early suspend interrupt\n");
+		s3c_otg_writel(dev, INT_EARLY_SUSPEND, S3C_UDC_OTG_GINTSTS);
+	}
+
+	if (intr_status & INT_SUSPEND) {
+		DBG(2, "Suspend interrupt\n");
+		s3c_otg_writel(dev, INT_SUSPEND, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->suspend) {
+			dev->driver->suspend(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESUME) {
+		DBG(2, "Resume interrupt\n");
+		s3c_otg_writel(dev, INT_RESUME, S3C_UDC_OTG_GINTSTS);
+
+		if (dev->gadget.speed != USB_SPEED_UNKNOWN
+		    && dev->driver
+		    && dev->driver->resume) {
+			dev->driver->resume(&dev->gadget);
+		}
+	}
+
+	if (intr_status & INT_RESET) {
+		DBG(2, "Reset interrupt\n");
+		s3c_otg_writel(dev, INT_RESET, S3C_UDC_OTG_GINTSTS);
+
+		usb_status = s3c_otg_readl(dev, S3C_UDC_OTG_GOTGCTL);
+
+		if (usb_status | (A_SESSION_VALID|B_SESSION_VALID)) {
+			if (reset_available) {
+				s3c_otg_config(dev);
+				dev->ep0state = WAIT_FOR_SETUP;
+				reset_available = 0;
+			}
+		} else {
+			reset_available = 1;
+			DBG(2, "RESET handling skipped\n");
+		}
+	}
+
+	if (intr_status & INT_RX_FIFO_NOT_EMPTY) {
+		s3c_otg_handle_ep(dev, gintmsk);
+		spin_unlock(&dev->lock);
+
+		return IRQ_HANDLED;
+	}
+
+
+	if (intr_status & INT_TX_FIFO_EMPTY) {
+		DBG(2, "INT_TX_FIFO_EMPTY ep_num=%d\n",	tx_ep_num);
+		s3c_otg_handle_ep_in(dev, tx_ep_num);
+	}
+
+	spin_unlock(&dev->lock);
+
+	return IRQ_HANDLED;
+}
+
+static void s3c_otg_stop_activity(struct s3c_udc *dev,
+		struct usb_gadget_driver *driver)
+{
+	int i;
+
+	/* don't disconnect drivers more than once */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = 0;
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+
+	/* prevent new request submissions, kill any outstanding requests  */
+	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
+		struct s3c_ep *ep = &dev->ep[i];
+		ep->stopped = 1;
+		s3c_otg_nuke(ep, -ESHUTDOWN);
+	}
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock(&dev->lock);
+		driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	/* re-init driver-visible data structures */
+	s3c_otg_reinit(dev);
+}
+
+/*
+ * Register the gadget driver. Used by gadget drivers when
+ * registering themselves with the controller.
+ */
+int usb_gadget_register_driver(struct usb_gadget_driver *driver)
+{
+	struct s3c_udc *dev = the_controller;
+	int retval;
+
+	if (!driver
+	    || driver->speed != USB_SPEED_HIGH
+	    || !driver->bind
+	    || !driver->setup)
+		return -EINVAL;
+
+	if (!dev) {
+		DBG(3, "No device\n");
+		return -ENODEV;
+	}
+
+	if (dev->driver) {
+		DBG(3, "Already bound to %s\n", driver->driver.name);
+		return -EBUSY;
+	}
+
+	/* first hook up the driver ... */
+	dev->driver = driver;
+	dev->gadget.dev.driver = &driver->driver;
+	retval = device_add(&dev->gadget.dev);
+
+	if (retval) { /* TODO */
+		DBG(3, "target device_add failed, error %d\n", retval);
+		return retval;
+	}
+
+	retval = driver->bind(&dev->gadget);
+	if (retval) {
+		DBG(3, "%s: bind to driver %s --> error %d\n",
+				dev->gadget.name, driver->driver.name, retval);
+		device_del(&dev->gadget.dev);
+
+		dev->driver = 0;
+		dev->gadget.dev.driver = 0;
+		return retval;
+	}
+
+	dev_info(&dev->gadget.dev, "Registered gadget driver '%s'\n",
+							   driver->driver.name);
+	s3c_otg_enable(dev);
+
+	enable_irq(IRQ_OTG);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_register_driver);
+
+/*
+  Unregister entry point for the peripheral controller driver.
+*/
+int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
+{
+	struct s3c_udc *dev = the_controller;
+	unsigned long flags;
+
+	if (!dev)
+		return -ENODEV;
+
+	if (!driver || driver != dev->driver)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	dev->driver = 0;
+	s3c_otg_stop_activity(dev, driver);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	if (driver->unbind)
+		driver->unbind(&dev->gadget);
+
+	device_del(&dev->gadget.dev);
+
+	disable_irq(IRQ_OTG);
+
+	dev_info(&dev->gadget.dev, "Unregistered gadget driver '%s'\n",
+							   driver->driver.name);
+
+	s3c_otg_disable(dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_gadget_unregister_driver);
+
+/*
+ * 	device-scoped parts of the api to the usb controller hardware
+ */
+static int s3c_otg_get_frame(struct usb_gadget *gadget)
+{
+	u32 frame = s3c_otg_readl(the_controller, S3C_UDC_OTG_DSTS);
+	return FRAME_CNT(frame);
+}
+
+static int s3c_otg_wakeup(struct usb_gadget *gadget)
+{
+	return -EOPNOTSUPP;
+}
+
+static int s3c_otg_set_selfpowered(
+		struct usb_gadget *gadget, int is_selfpowered)
+{
+	return -EOPNOTSUPP;
+}
+
+static int s3c_otg_pullup(struct usb_gadget *gadget, int is_on)
+{
+	return -EOPNOTSUPP;
+}
+
+static int s3c_otg_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	return -EOPNOTSUPP;
+}
+
+static int s3c_otg_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+{
+	return -EOPNOTSUPP;
+}
+
+static const struct usb_gadget_ops s3c_udc_ops = {
+	.get_frame = s3c_otg_get_frame,
+	.wakeup = s3c_otg_wakeup,
+	.set_selfpowered = s3c_otg_set_selfpowered,
+	.vbus_session = s3c_otg_vbus_session,
+	.vbus_draw = s3c_otg_vbus_draw,
+	.pullup = s3c_otg_pullup,
+};
+
+static void nop_release(struct device *dev)
+{
+	DBG(2, "%s\n", dev->bus_id);
+}
+
+static struct s3c_udc memory = {
+	.usb_address = 0,
+	.gadget = {
+		   .ops = &s3c_udc_ops,
+		   .ep0 = &memory.ep[0].ep,
+		   .name = driver_name,
+		   .dev = {
+			   .bus_id = "gadget",
+			   .release = nop_release,
+			   },
+		   },
+	.ep[0] = {
+		  .ep = {
+			 .name = ep0name,
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP0_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 0,
+		  .bmAttributes = 0,
+
+		  .ep_type = ep_control,
+		  .fifo = (u32) S3C_UDC_OTG_EP0_FIFO,
+		  },
+	.ep[1] = {
+		  .ep = {
+			 .name = "ep1-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = 1,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .ep_type = ep_bulk_out,
+		  .fifo = (u32) S3C_UDC_OTG_EP1_FIFO,
+		  },
+	.ep[2] = {
+		  .ep = {
+			 .name = "ep2-bulk",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 2,
+		  .bmAttributes = USB_ENDPOINT_XFER_BULK,
+
+		  .ep_type = ep_bulk_in,
+		  .fifo = (u32) S3C_UDC_OTG_EP2_FIFO,
+		  },
+
+	.ep[3] = {
+		  .ep = {
+			 .name = "ep3-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 3,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (u32) S3C_UDC_OTG_EP3_FIFO,
+		  },
+	.ep[4] = {
+		  .ep = {
+			 .name = "ep4-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 4,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (u32) S3C_UDC_OTG_EP4_FIFO,
+		  },
+	.ep[5] = {
+		  .ep = {
+			 .name = "ep5-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 5,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (u32) S3C_UDC_OTG_EP5_FIFO,
+		  },
+	.ep[6] = {
+		  .ep = {
+			 .name = "ep6-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 6,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (u32) S3C_UDC_OTG_EP6_FIFO,
+		  },
+	.ep[7] = {
+		  .ep = {
+			 .name = "ep7-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 7,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (u32) S3C_UDC_OTG_EP7_FIFO,
+		  },
+	.ep[8] = {
+		  .ep = {
+			 .name = "ep8-int",
+			 .ops = &s3c_ep_ops,
+			 .maxpacket = EP_FIFO_SIZE2,
+			 },
+		  .dev = &memory,
+
+		  .bEndpointAddress = USB_DIR_IN | 8,
+		  .bmAttributes = USB_ENDPOINT_XFER_INT,
+
+		  .ep_type = ep_interrupt,
+		  .fifo = (u32) S3C_UDC_OTG_EP8_FIFO,
+		  },
+};
+
+static struct clk *otg_clock;
+
+/*
+ * binds to the platform device
+ */
+static int s3c_otg_probe(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = &memory;
+	struct s3c_plat_otg_data *pdata = pdev->dev.platform_data;
+	int retval;
+
+	dev->reg_base = ioremap(pdev->resource[0].start,
+			pdev->resource[0].end - pdev->resource[0].start);
+	if (dev->reg_base == NULL) {
+		dev_err(&pdev->dev, "Unable to map USB OTG physical regs\n");
+		return -ENOMEM;
+	}
+
+
+	DBG(2, "%p\n", pdev);
+
+	spin_lock_init(&dev->lock);
+	dev->dev = pdev;
+
+	device_initialize(&dev->gadget.dev);
+	dev->gadget.dev.parent = &pdev->dev;
+
+	dev->gadget.is_dualspeed = 1;
+	dev->gadget.is_otg = 0;
+	dev->gadget.is_a_peripheral = 0;
+	dev->gadget.b_hnp_enable = 0;
+	dev->gadget.a_hnp_support = 0;
+	dev->gadget.a_alt_hnp_support = 0;
+
+	dev->phyclk = pdata->phyclk;
+
+	the_controller = dev;
+	platform_set_drvdata(pdev, dev);
+
+	otg_clock = clk_get(&pdev->dev, "otg");
+	if (otg_clock == NULL) {
+		DBG(3, "failed to find otg clock source\n");
+		return -ENOENT;
+	}
+	clk_enable(otg_clock);
+
+	s3c_otg_reinit(dev);
+
+	local_irq_disable();
+
+	/* irq setup after old hardware state is cleaned up */
+	retval = request_irq(pdev->resource[1].start, s3c_otg_irq,
+			IRQF_DISABLED, driver_name, dev);
+
+	if (retval != 0) {
+		DBG(3, "%s: can't get irq %i - %d\n",
+				driver_name, IRQ_OTG, retval);
+		return -EBUSY;
+	}
+
+	disable_irq(IRQ_OTG);
+	local_irq_enable();
+	create_proc_files();
+
+	return retval;
+}
+
+static int s3c_otg_remove(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = platform_get_drvdata(pdev);
+
+	if (otg_clock != NULL) {
+		clk_disable(otg_clock);
+		clk_put(otg_clock);
+		otg_clock = NULL;
+	}
+
+	remove_proc_files();
+	usb_gadget_unregister_driver(dev->driver);
+
+	free_irq(IRQ_OTG, dev);
+
+	platform_set_drvdata(pdev, 0);
+
+	the_controller = 0;
+
+	if (dev->reg_base)
+		iounmap(dev->reg_base);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_otg_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct s3c_udc *dev = the_controller;
+
+	if (dev->driver) {
+		disable_irq(IRQ_OTG);
+		s3c_otg_disable(dev);
+		clk_disable(otg_clock);
+	}
+
+	return 0;
+}
+
+static int s3c_otg_resume(struct platform_device *pdev)
+{
+	struct s3c_udc *dev = the_controller;
+
+	if (dev->driver) {
+		clk_enable(otg_clock);
+		s3c_otg_enable(dev);
+		s3c_otg_reinit(dev);
+		enable_irq(IRQ_OTG);
+	}
+
+	return 0;
+}
+#else
+#define s3c_otg_suspend NULL
+#define s3c_otg_resume  NULL
+#endif
+
+/*-------------------------------------------------------------------------*/
+static struct platform_driver s3c_otg_driver = {
+	.probe		= s3c_otg_probe,
+	.remove		= s3c_otg_remove,
+	.suspend	= s3c_otg_suspend,
+	.resume		= s3c_otg_resume,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c-otg-usbgadget",
+	},
+};
+
+static int __init otg_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&s3c_otg_driver);
+	if (!ret)
+		printk(KERN_INFO "Loaded %s version %s %s\n",
+				driver_name, DRIVER_VERSION, "(Slave Mode)");
+
+	return ret;
+}
+
+static void __exit otg_exit(void)
+{
+	platform_driver_unregister(&s3c_otg_driver);
+	printk(KERN_INFO "Unloaded %s version %s\n",
+			driver_name, DRIVER_VERSION);
+}
+
+module_init(otg_init);
+module_exit(otg_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/gadget/s3c-udc.h linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/s3c-udc.h
--- linux-2.6.29-rc3.owrt/drivers/usb/gadget/s3c-udc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/gadget/s3c-udc.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,132 @@
+/*
+ * drivers/usb/gadget/s3c-udc.h
+ * Samsung S3C on-chip full/high speed USB device controllers
+ *
+ * Copyright (C) 2008 Samsung Electronics
+ * Minkyu Kang <mk7.kang@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __S3C_UDC_H
+#define __S3C_UDC_H
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <asm/byteorder.h>
+#include <linux/io.h>
+#include <asm/dma.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/unaligned.h>
+#include <mach/hardware.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+/* Max packet size */
+#if defined(CONFIG_USB_GADGET_S3C_FS)
+#define EP0_FIFO_SIZE		8
+#define EP_FIFO_SIZE		64
+#define S3C_MAX_ENDPOINTS	5
+#elif defined(CONFIG_USB_GADGET_S3C_HS)
+#define EP0_FIFO_SIZE		64
+#define EP_FIFO_SIZE		512
+#define EP_FIFO_SIZE2		1024
+#define S3C_MAX_ENDPOINTS	9
+#else
+#define EP0_FIFO_SIZE		64
+#define EP_FIFO_SIZE		512
+#define EP_FIFO_SIZE2		1024
+#define S3C_MAX_ENDPOINTS	16
+#endif
+
+#define WAIT_FOR_SETUP          0
+#define DATA_STATE_XMIT         1
+#define DATA_STATE_NEED_ZLP     2
+#define WAIT_FOR_OUT_STATUS     3
+#define DATA_STATE_RECV         4
+
+enum ep_type {
+	ep_control, ep_bulk_in, ep_bulk_out, ep_interrupt
+};
+
+struct s3c_ep {
+	struct usb_ep ep;
+	struct s3c_udc *dev;
+
+	const struct usb_endpoint_descriptor *desc;
+	struct list_head queue;
+	unsigned long pio_irqs;
+
+	u8 stopped;
+	u8 bEndpointAddress;
+	u8 bmAttributes;
+
+	u32 ep_type;
+	u32 fifo;
+#ifdef CONFIG_USB_GADGET_S3C_FS
+	u32 csr1;
+	u32 csr2;
+#endif
+};
+
+struct s3c_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+struct s3c_udc {
+	struct usb_gadget gadget;
+	struct usb_gadget_driver *driver;
+	struct platform_device *dev;
+	spinlock_t lock;
+	u32 * reg_base;
+
+	int phyclk;
+	int ep0state;
+	struct s3c_ep ep[S3C_MAX_ENDPOINTS];
+
+	unsigned char usb_address;
+
+	unsigned req_pending:1;
+	unsigned req_std:1;
+	unsigned req_config:1;
+};
+
+extern struct s3c_udc *the_controller;
+
+#define ep_is_in(EP)		(((EP)->bEndpointAddress & USB_DIR_IN) \
+								== USB_DIR_IN)
+#define ep_index(EP) 		((EP)->bEndpointAddress & 0xF)
+#define ep_maxpacket(EP) 	((EP)->ep.maxpacket)
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/host/ohci-hcd.c linux-2.6.29-rc3.owrt.om/drivers/usb/host/ohci-hcd.c
--- linux-2.6.29-rc3.owrt/drivers/usb/host/ohci-hcd.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/host/ohci-hcd.c	2009-05-10 22:28:00.000000000 +0200
@@ -997,7 +997,7 @@
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
 #endif
 
-#ifdef CONFIG_ARCH_S3C2410
+#ifdef CONFIG_PLAT_S3C
 #include "ohci-s3c2410.c"
 #define PLATFORM_DRIVER		ohci_hcd_s3c2410_driver
 #endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/host/ohci-s3c2410.c linux-2.6.29-rc3.owrt.om/drivers/usb/host/ohci-s3c2410.c
--- linux-2.6.29-rc3.owrt/drivers/usb/host/ohci-s3c2410.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/host/ohci-s3c2410.c	2009-05-10 22:28:00.000000000 +0200
@@ -21,9 +21,9 @@
 
 #include <linux/platform_device.h>
 #include <linux/clk.h>
-
 #include <mach/hardware.h>
-#include <mach/usb-control.h>
+#include <mach/regs-gpio.h>
+#include <plat/usb-control.h>
 
 #define valid_port(idx) ((idx) == 1 || (idx) == 2)
 
@@ -58,9 +58,8 @@
 		info->hcd	= hcd;
 		info->report_oc = s3c2410_hcd_oc;
 
-		if (info->enable_oc != NULL) {
+		if (info->enable_oc != NULL)
 			(info->enable_oc)(info, 1);
-		}
 	}
 }
 
@@ -74,9 +73,8 @@
 		info->report_oc = NULL;
 		info->hcd	= NULL;
 
-		if (info->enable_oc != NULL) {
+		if (info->enable_oc != NULL)
 			(info->enable_oc)(info, 0);
-		}
 	}
 
 	clk_disable(clk);
@@ -90,14 +88,14 @@
 */
 
 static int
-ohci_s3c2410_hub_status_data (struct usb_hcd *hcd, char *buf)
+ohci_s3c2410_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct s3c2410_hcd_info *info = to_s3c2410_info(hcd);
 	struct s3c2410_hcd_port *port;
 	int orig;
 	int portno;
 
-	orig  = ohci_hub_status_data (hcd, buf);
+	orig  = ohci_hub_status_data(hcd, buf);
 
 	if (info == NULL)
 		return orig;
@@ -147,7 +145,7 @@
  * request.
 */
 
-static int ohci_s3c2410_hub_control (
+static int ohci_s3c2410_hub_control(
 	struct usb_hcd	*hcd,
 	u16		typeReq,
 	u16		wValue,
@@ -201,9 +199,8 @@
 			dev_dbg(hcd->self.controller,
 				"ClearPortFeature: OVER_CURRENT\n");
 
-			if (valid_port(wIndex)) {
+			if (valid_port(wIndex))
 				info->port[wIndex-1].oc_status = 0;
-			}
 
 			goto out;
 
@@ -244,28 +241,28 @@
 		desc->wHubCharacteristics |= cpu_to_le16(0x0001);
 
 		if (info->enable_oc) {
-			desc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_OCPM);
-			desc->wHubCharacteristics |=  cpu_to_le16(0x0008|0x0001);
+			desc->wHubCharacteristics &=
+					~cpu_to_le16(HUB_CHAR_OCPM);
+			desc->wHubCharacteristics |=
+					cpu_to_le16(0x0008|0x0001);
 		}
 
-		dev_dbg(hcd->self.controller, "wHubCharacteristics after 0x%04x\n",
+		dev_dbg(hcd->self.controller,
+			"wHubCharacteristics after 0x%04x\n",
 			desc->wHubCharacteristics);
 
 		return ret;
 
 	case GetPortStatus:
 		/* check port status */
-
 		dev_dbg(hcd->self.controller, "GetPortStatus(%d)\n", wIndex);
 
 		if (valid_port(wIndex)) {
-			if (info->port[wIndex-1].oc_changed) {
+			if (info->port[wIndex-1].oc_changed)
 				*data |= cpu_to_le32(RH_PS_OCIC);
-			}
 
-			if (info->port[wIndex-1].oc_status) {
+			if (info->port[wIndex-1].oc_status)
 				*data |= cpu_to_le32(RH_PS_POCI);
-			}
 		}
 	}
 
@@ -308,6 +305,42 @@
 	local_irq_restore(flags);
 }
 
+/* switching of USB pads */
+static ssize_t show_usb_mode(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	if (__raw_readl(S3C24XX_MISCCR) & S3C2410_MISCCR_USBHOST)
+		return sprintf(buf, "host\n");
+
+	return sprintf(buf, "device\n");
+}
+
+static ssize_t set_usb_mode(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	if (!strncmp(buf, "host", 4)) {
+		printk(KERN_WARNING "s3c2410: changing usb to host\n");
+		s3c2410_modify_misccr(S3C2410_MISCCR_USBHOST,
+				      S3C2410_MISCCR_USBHOST);
+		/* FIXME:
+		 * - call machine-specific disable-pullup function i
+		 * - enable +Vbus (if hardware supports it)
+		 */
+		s3c2410_gpio_setpin(S3C2410_GPB9, 0);
+	} else if (!strncmp(buf, "device", 6)) {
+		printk(KERN_WARNING "s3c2410: changing usb to device\n");
+		s3c2410_modify_misccr(S3C2410_MISCCR_USBHOST, 0);
+		s3c2410_gpio_setpin(S3C2410_GPB9, 1);
+	} else {
+		printk(KERN_WARNING "s3c2410: unknown mode\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(usb_mode, S_IRUGO | S_IWUSR, show_usb_mode, set_usb_mode);
+
 /* may be called without controller electrically present */
 /* may be called with controller, bus, and devices active */
 
@@ -323,8 +356,9 @@
 */
 
 static void
-usb_hcd_s3c2410_remove (struct usb_hcd *hcd, struct platform_device *dev)
+usb_hcd_s3c2410_remove(struct usb_hcd *hcd, struct platform_device *dev)
 {
+	device_remove_file(&dev->dev, &dev_attr_usb_mode);
 	usb_remove_hcd(hcd);
 	s3c2410_stop_hc(dev);
 	iounmap(hcd->regs);
@@ -341,8 +375,8 @@
  * through the hotplug entry's driver_data.
  *
  */
-static int usb_hcd_s3c2410_probe (const struct hc_driver *driver,
-				  struct platform_device *dev)
+static int usb_hcd_s3c2410_probe(const struct hc_driver *driver,
+				 struct platform_device *dev)
 {
 	struct usb_hcd *hcd = NULL;
 	int retval;
@@ -392,9 +426,16 @@
 	if (retval != 0)
 		goto err_ioremap;
 
+	retval = device_create_file(&dev->dev, &dev_attr_usb_mode);
+	if (retval != 0)
+		goto err_hcd;
+
 	return 0;
 
- err_ioremap:
+err_hcd:
+	usb_remove_hcd(hcd);
+
+err_ioremap:
 	s3c2410_stop_hc(dev);
 	iounmap(hcd->regs);
 	clk_put(usb_clk);
@@ -413,17 +454,19 @@
 /*-------------------------------------------------------------------------*/
 
 static int
-ohci_s3c2410_start (struct usb_hcd *hcd)
+ohci_s3c2410_start(struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 	int ret;
 
-	if ((ret = ohci_init(ohci)) < 0)
+	ret = ohci_init(ohci);
+	if (ret < 0)
 		return ret;
 
-	if ((ret = ohci_run (ohci)) < 0) {
-		err ("can't start %s", hcd->self.bus_name);
-		ohci_stop (hcd);
+	ret = ohci_run(ohci);
+	if (ret < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
 		return ret;
 	}
 
@@ -488,15 +531,23 @@
 	return 0;
 }
 
+static int ohci_hcd_s3c2410_drv_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	ohci_finish_controller_resume(hcd);
+	return 0;
+}
+
 static struct platform_driver ohci_hcd_s3c2410_driver = {
 	.probe		= ohci_hcd_s3c2410_drv_probe,
 	.remove		= ohci_hcd_s3c2410_drv_remove,
 	.shutdown	= usb_hcd_platform_shutdown,
 	/*.suspend	= ohci_hcd_s3c2410_drv_suspend, */
-	/*.resume	= ohci_hcd_s3c2410_drv_resume, */
+	.resume		= ohci_hcd_s3c2410_drv_resume,
 	.driver		= {
 		.owner	= THIS_MODULE,
-		.name	= "s3c2410-ohci",
+		.name	= "s3c-ohci",
 	},
 };
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/usb/Kconfig linux-2.6.29-rc3.owrt.om/drivers/usb/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/usb/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/usb/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -31,7 +31,7 @@
 	default y if SA1111
 	default y if ARCH_OMAP
 	default y if ARCH_LH7A404
-	default y if ARCH_S3C2410
+	default y if PLAT_S3C
 	default y if PXA27x
 	default y if PXA3xx
 	default y if ARCH_EP93XX
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/backlight/gta01_bl.c linux-2.6.29-rc3.owrt.om/drivers/video/backlight/gta01_bl.c
--- linux-2.6.29-rc3.owrt/drivers/video/backlight/gta01_bl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/video/backlight/gta01_bl.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,269 @@
+/*
+ *  Backlight Driver for FIC GTA01 (Neo1973) GSM Phone
+ *
+ * Copyright (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ *  based on corgi_cl.c, Copyright (c) 2004-2006 Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Javi Roman <javiroman@kernel-labs.org>:
+ * 	implement PWM, instead of simple on/off switching
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/clk.h>
+
+#include <mach/hardware.h>
+#include <mach/gta01.h>
+#include <plat/pwm.h>
+
+#include <plat/regs-timer.h>
+#include <asm/plat-s3c24xx/neo1973.h>
+
+static struct backlight_properties gta01bl_prop;
+static struct backlight_device *gta01_backlight_device;
+static struct gta01bl_machinfo *bl_machinfo;
+
+static unsigned long gta01bl_flags;
+
+struct gta01bl_data {
+	int intensity;
+	struct mutex mutex;
+	struct clk *clk;
+	struct s3c2410_pwm pwm;
+};
+
+static struct gta01bl_data gta01bl;
+
+static int gta01bl_defer_resume_backlight;
+
+#define GTA01BL_SUSPENDED     0x01
+#define GTA01BL_BATTLOW       0x02
+
+/* On the GTA01 / Neo1973, we use a 50 or 66MHz PCLK, which gives
+ * us a 6.25..8.25MHz DIV8 clock, which is further divided by a
+ * prescaler of 4, resulting in a 1.56..2.06MHz tick.  This results in a
+ * minimum frequency of 24..31Hz.  At 400Hz, we need to set the count
+ * to something like 3906..5156, providing us a way sufficient resolution
+ * for display brightness adjustment. */
+#define GTA01BL_COUNTER 5156
+
+static int gta01bl_send_intensity(struct backlight_device *bd)
+{
+	int intensity = bd->props.brightness;
+
+	if (bd->props.power != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (bd->props.fb_blank != FB_BLANK_UNBLANK)
+		intensity = 0;
+	if (gta01bl_flags & GTA01BL_SUSPENDED)
+		intensity = 0;
+	if (gta01bl_flags & GTA01BL_BATTLOW)
+		intensity &= bl_machinfo->limit_mask;
+
+	mutex_lock(&gta01bl.mutex);
+#ifdef GTA01_BACKLIGHT_ONOFF_ONLY
+	if (intensity)
+		neo1973_gpb_setpin(GTA01_GPIO_BACKLIGHT, 1);
+	else
+		neo1973_gpb_setpin(GTA01_GPIO_BACKLIGHT, 0);
+#else
+	if (intensity == bd->props.max_brightness) {
+		neo1973_gpb_setpin(GTA01_GPIO_BACKLIGHT, 1);
+		s3c2410_gpio_cfgpin(GTA01_GPIO_BACKLIGHT, S3C2410_GPIO_OUTPUT);
+	} else  {
+		s3c2410_pwm_duty_cycle(intensity & 0xffff, &gta01bl.pwm);
+		s3c2410_gpio_cfgpin(GTA01_GPIO_BACKLIGHT, S3C2410_GPB0_TOUT0);
+	}
+#endif
+	mutex_unlock(&gta01bl.mutex);
+
+	gta01bl.intensity = intensity;
+	return 0;
+}
+
+static int gta01bl_init_hw(void)
+{
+	int rc;
+
+	rc = s3c2410_pwm_init(&gta01bl.pwm);
+	if (rc)
+		return rc;
+
+	gta01bl.pwm.timerid = PWM0;
+	gta01bl.pwm.prescaler = (4 - 1);
+	gta01bl.pwm.divider = S3C2410_TCFG1_MUX0_DIV8;
+	gta01bl.pwm.counter = GTA01BL_COUNTER;
+	gta01bl.pwm.comparer = gta01bl.pwm.counter;
+
+	rc = s3c2410_pwm_enable(&gta01bl.pwm);
+	if (rc)
+		return rc;
+
+	s3c2410_pwm_start(&gta01bl.pwm);
+
+	gta01bl_prop.max_brightness = gta01bl.pwm.counter;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int gta01bl_suspend(struct platform_device *dev, pm_message_t state)
+{
+	gta01bl_flags |= GTA01BL_SUSPENDED;
+	gta01bl_send_intensity(gta01_backlight_device);
+	neo1973_gpb_setpin(GTA01_GPIO_BACKLIGHT, 0);
+	s3c2410_gpio_cfgpin(GTA01_GPIO_BACKLIGHT, S3C2410_GPIO_OUTPUT);
+	return 0;
+}
+
+void gta01bl_deferred_resume(void)
+{
+	mutex_lock(&gta01bl.mutex);
+	gta01bl_init_hw();
+	mutex_unlock(&gta01bl.mutex);
+
+	gta01bl_flags &= ~GTA01BL_SUSPENDED;
+	gta01bl_send_intensity(gta01_backlight_device);
+}
+EXPORT_SYMBOL_GPL(gta01bl_deferred_resume);
+
+static int gta01bl_resume(struct platform_device *dev)
+{
+	if (!gta01bl_defer_resume_backlight)
+		gta01bl_deferred_resume();
+	return 0;
+}
+#else
+#define gta01bl_suspend	NULL
+#define gta01bl_resume	NULL
+#endif
+
+static int gta01bl_get_intensity(struct backlight_device *bd)
+{
+	return gta01bl.intensity;
+}
+
+static int gta01bl_set_intensity(struct backlight_device *bd)
+{
+	gta01bl_send_intensity(gta01_backlight_device);
+	return 0;
+}
+
+/*
+ * Called when the battery is low to limit the backlight intensity.
+ * If limit==0 clear any limit, otherwise limit the intensity
+ */
+void gta01bl_limit_intensity(int limit)
+{
+	if (limit)
+		gta01bl_flags |= GTA01BL_BATTLOW;
+	else
+		gta01bl_flags &= ~GTA01BL_BATTLOW;
+	gta01bl_send_intensity(gta01_backlight_device);
+}
+EXPORT_SYMBOL_GPL(gta01bl_limit_intensity);
+
+
+static struct backlight_ops gta01bl_ops = {
+	.get_brightness = gta01bl_get_intensity,
+	.update_status  = gta01bl_set_intensity,
+};
+
+static int __init gta01bl_probe(struct platform_device *pdev)
+{
+	struct gta01bl_machinfo *machinfo = pdev->dev.platform_data;
+	int rc;
+
+#ifdef GTA01_BACKLIGHT_ONOFF_ONLY
+	s3c2410_gpio_cfgpin(GTA01_GPIO_BACKLIGHT, S3C2410_GPIO_OUTPUT);
+	gta01bl_prop.max_brightness = 1;
+#else
+	rc = gta01bl_init_hw();
+	if (rc < 0)
+		return rc;
+#endif
+	mutex_init(&gta01bl.mutex);
+
+	if (!machinfo->limit_mask)
+		machinfo->limit_mask = -1;
+
+	gta01bl_defer_resume_backlight = machinfo->defer_resume_backlight;
+
+	gta01_backlight_device = backlight_device_register("gta01-bl",
+							   &pdev->dev, NULL,
+							   &gta01bl_ops);
+	if (IS_ERR(gta01_backlight_device))
+		return PTR_ERR(gta01_backlight_device);
+
+	gta01bl_prop.power = FB_BLANK_UNBLANK;
+	gta01bl_prop.brightness = gta01bl_prop.max_brightness;
+	memcpy(&gta01_backlight_device->props,
+	       &gta01bl_prop, sizeof(gta01bl_prop));
+	gta01bl_send_intensity(gta01_backlight_device);
+
+	return 0;
+}
+
+static int gta01bl_remove(struct platform_device *dev)
+{
+#ifndef GTA01_BACKLIGHT_ONOFF_ONLY
+	s3c2410_pwm_disable(&gta01bl.pwm);
+#endif
+	backlight_device_unregister(gta01_backlight_device);
+	mutex_destroy(&gta01bl.mutex);
+
+	s3c2410_gpio_cfgpin(GTA01_GPIO_BACKLIGHT, S3C2410_GPIO_OUTPUT);
+	neo1973_gpb_setpin(GTA01_GPIO_BACKLIGHT, 1);
+
+	return 0;
+}
+
+static struct platform_driver gta01bl_driver = {
+	.probe		= gta01bl_probe,
+	.remove		= gta01bl_remove,
+	.suspend	= gta01bl_suspend,
+	.resume		= gta01bl_resume,
+	.driver		= {
+		.name	= "gta01-bl",
+	},
+};
+
+static int __init gta01bl_init(void)
+{
+	return platform_driver_register(&gta01bl_driver);
+}
+
+static void __exit gta01bl_exit(void)
+{
+	platform_driver_unregister(&gta01bl_driver);
+}
+
+module_init(gta01bl_init);
+module_exit(gta01bl_exit);
+
+MODULE_DESCRIPTION("FIC GTA01 (Neo1973) Backlight Driver");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/backlight/Kconfig linux-2.6.29-rc3.owrt.om/drivers/video/backlight/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/video/backlight/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/backlight/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -149,6 +149,13 @@
 	  the PWL module of OMAP1 processors.  Say Y if your board
 	  uses this hardware.
 
+config BACKLIGHT_GTA01
+	tristate "FIC Neo1973 GTA01 Backlight Driver"
+	depends on BACKLIGHT_CLASS_DEVICE && MACH_NEO1973_GTA01
+	default y
+	help
+	  If you have a FIC Neo1973 GTA01, say y to enable the backlight driver.
+
 config BACKLIGHT_HP680
 	tristate "HP Jornada 680 Backlight Driver"
 	depends on BACKLIGHT_CLASS_DEVICE && SH_HP6XX
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/backlight/Makefile linux-2.6.29-rc3.owrt.om/drivers/video/backlight/Makefile
--- linux-2.6.29-rc3.owrt/drivers/video/backlight/Makefile	2009-05-10 22:08:45.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/backlight/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -12,6 +12,8 @@
 obj-$(CONFIG_BACKLIGHT_CLASS_DEVICE) += backlight.o
 obj-$(CONFIG_BACKLIGHT_ATMEL_PWM)    += atmel-pwm-bl.o
 obj-$(CONFIG_BACKLIGHT_GENERIC)	+= generic_bl.o
+obj-$(CONFIG_BACKLIGHT_CORGI)	+= corgi_bl.o
+obj-$(CONFIG_BACKLIGHT_GTA01)	+= gta01_bl.o
 obj-$(CONFIG_BACKLIGHT_HP680)	+= hp680_bl.o
 obj-$(CONFIG_BACKLIGHT_LOCOMO)	+= locomolcd.o
 obj-$(CONFIG_BACKLIGHT_OMAP1)	+= omap1_bl.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/console/fbcon.c linux-2.6.29-rc3.owrt.om/drivers/video/console/fbcon.c
--- linux-2.6.29-rc3.owrt/drivers/video/console/fbcon.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/console/fbcon.c	2009-05-10 22:28:00.000000000 +0200
@@ -373,6 +373,9 @@
 	int c;
 	int mode;
 
+	if (info->state != FBINFO_STATE_RUNNING)
+		return;
+
 	acquire_console_sem();
 	if (ops && ops->currcon != -1)
 		vc = vc_cons[ops->currcon].d;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/display/jbt6k74.c linux-2.6.29-rc3.owrt.om/drivers/video/display/jbt6k74.c
--- linux-2.6.29-rc3.owrt/drivers/video/display/jbt6k74.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/video/display/jbt6k74.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,768 @@
+/* Linux kernel driver for the tpo JBT6K74-AS LCM ASIC
+ *
+ * Copyright (C) 2006-2007 by Openmoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>,
+ * 	   Stefan Schmidt <stefan@openmoko.org>
+ * Copyright (C) 2008 by Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/jbt6k74.h>
+#include <linux/fb.h>
+#include <linux/time.h>
+
+enum jbt_register {
+	JBT_REG_SLEEP_IN		= 0x10,
+	JBT_REG_SLEEP_OUT		= 0x11,
+
+	JBT_REG_DISPLAY_OFF		= 0x28,
+	JBT_REG_DISPLAY_ON		= 0x29,
+
+	JBT_REG_RGB_FORMAT		= 0x3a,
+	JBT_REG_QUAD_RATE		= 0x3b,
+
+	JBT_REG_POWER_ON_OFF		= 0xb0,
+	JBT_REG_BOOSTER_OP		= 0xb1,
+	JBT_REG_BOOSTER_MODE		= 0xb2,
+	JBT_REG_BOOSTER_FREQ		= 0xb3,
+	JBT_REG_OPAMP_SYSCLK		= 0xb4,
+	JBT_REG_VSC_VOLTAGE		= 0xb5,
+	JBT_REG_VCOM_VOLTAGE		= 0xb6,
+	JBT_REG_EXT_DISPL		= 0xb7,
+	JBT_REG_OUTPUT_CONTROL		= 0xb8,
+	JBT_REG_DCCLK_DCEV		= 0xb9,
+	JBT_REG_DISPLAY_MODE1		= 0xba,
+	JBT_REG_DISPLAY_MODE2		= 0xbb,
+	JBT_REG_DISPLAY_MODE		= 0xbc,
+	JBT_REG_ASW_SLEW		= 0xbd,
+	JBT_REG_DUMMY_DISPLAY		= 0xbe,
+	JBT_REG_DRIVE_SYSTEM		= 0xbf,
+
+	JBT_REG_SLEEP_OUT_FR_A		= 0xc0,
+	JBT_REG_SLEEP_OUT_FR_B		= 0xc1,
+	JBT_REG_SLEEP_OUT_FR_C		= 0xc2,
+	JBT_REG_SLEEP_IN_LCCNT_D	= 0xc3,
+	JBT_REG_SLEEP_IN_LCCNT_E	= 0xc4,
+	JBT_REG_SLEEP_IN_LCCNT_F	= 0xc5,
+	JBT_REG_SLEEP_IN_LCCNT_G	= 0xc6,
+
+	JBT_REG_GAMMA1_FINE_1		= 0xc7,
+	JBT_REG_GAMMA1_FINE_2		= 0xc8,
+	JBT_REG_GAMMA1_INCLINATION	= 0xc9,
+	JBT_REG_GAMMA1_BLUE_OFFSET	= 0xca,
+
+	/* VGA */
+	JBT_REG_BLANK_CONTROL		= 0xcf,
+	JBT_REG_BLANK_TH_TV		= 0xd0,
+	JBT_REG_CKV_ON_OFF		= 0xd1,
+	JBT_REG_CKV_1_2			= 0xd2,
+	JBT_REG_OEV_TIMING		= 0xd3,
+	JBT_REG_ASW_TIMING_1		= 0xd4,
+	JBT_REG_ASW_TIMING_2		= 0xd5,
+
+	/* QVGA */
+	JBT_REG_BLANK_CONTROL_QVGA	= 0xd6,
+	JBT_REG_BLANK_TH_TV_QVGA	= 0xd7,
+	JBT_REG_CKV_ON_OFF_QVGA		= 0xd8,
+	JBT_REG_CKV_1_2_QVGA		= 0xd9,
+	JBT_REG_OEV_TIMING_QVGA		= 0xde,
+	JBT_REG_ASW_TIMING_1_QVGA	= 0xdf,
+	JBT_REG_ASW_TIMING_2_QVGA	= 0xe0,
+
+
+	JBT_REG_HCLOCK_VGA		= 0xec,
+	JBT_REG_HCLOCK_QVGA		= 0xed,
+
+};
+
+enum jbt_state {
+	JBT_STATE_DEEP_STANDBY,
+	JBT_STATE_SLEEP,
+	JBT_STATE_NORMAL,
+	JBT_STATE_QVGA_NORMAL,
+};
+
+static const char *jbt_state_names[] = {
+	[JBT_STATE_DEEP_STANDBY]	= "deep-standby",
+	[JBT_STATE_SLEEP]		= "sleep",
+	[JBT_STATE_NORMAL]		= "normal",
+	[JBT_STATE_QVGA_NORMAL]		= "qvga-normal",
+};
+
+struct jbt_info {
+	enum jbt_state state, normal_state;
+	struct spi_device *spi_dev;
+	struct mutex lock;		/* protects tx_buf and reg_cache */
+	struct notifier_block fb_notif;
+	u16 tx_buf[8];
+	u16 reg_cache[0xEE];
+	struct timespec last_sleep;
+};
+
+#define JBT_COMMAND	0x000
+#define JBT_DATA	0x100
+
+static inline unsigned int timespec_sub_ms(struct timespec lhs,
+					struct timespec rhs)
+{
+	struct timespec ts = timespec_sub(lhs, rhs);
+	return (ts.tv_sec * MSEC_PER_SEC) + (ts.tv_nsec / NSEC_PER_MSEC);
+}
+
+static int jbt_reg_write_nodata(struct jbt_info *jbt, u8 reg)
+{
+	int rc;
+
+	jbt->tx_buf[0] = JBT_COMMAND | reg;
+	rc = spi_write(jbt->spi_dev, (u8 *)jbt->tx_buf,
+		       1*sizeof(u16));
+	if (rc == 0)
+		jbt->reg_cache[reg] = 0;
+	else
+		printk(KERN_ERR"jbt_reg_write_nodata spi_write ret %d\n",
+		       rc);
+
+	return rc;
+}
+
+
+static int jbt_reg_write(struct jbt_info *jbt, u8 reg, u8 data)
+{
+	int rc;
+
+	jbt->tx_buf[0] = JBT_COMMAND | reg;
+	jbt->tx_buf[1] = JBT_DATA | data;
+	rc = spi_write(jbt->spi_dev, (u8 *)jbt->tx_buf,
+		       2*sizeof(u16));
+	if (rc == 0)
+		jbt->reg_cache[reg] = data;
+	else
+		printk(KERN_ERR"jbt_reg_write spi_write ret %d\n", rc);
+
+	return rc;
+}
+
+static int jbt_reg_write16(struct jbt_info *jbt, u8 reg, u16 data)
+{
+	int rc;
+
+	jbt->tx_buf[0] = JBT_COMMAND | reg;
+	jbt->tx_buf[1] = JBT_DATA | (data >> 8);
+	jbt->tx_buf[2] = JBT_DATA | (data & 0xff);
+
+	rc = spi_write(jbt->spi_dev, (u8 *)jbt->tx_buf,
+		       3*sizeof(u16));
+	if (rc == 0)
+		jbt->reg_cache[reg] = data;
+	else
+		printk(KERN_ERR"jbt_reg_write16 spi_write ret %d\n", rc);
+
+	return rc;
+}
+
+static int jbt_init_regs(struct jbt_info *jbt)
+{
+	int rc;
+
+	dev_dbg(&jbt->spi_dev->dev, "entering %cVGA mode\n",
+			jbt->normal_state == JBT_STATE_QVGA_NORMAL ? 'Q' : ' ');
+
+	rc = jbt_reg_write(jbt, JBT_REG_DISPLAY_MODE1, 0x01);
+	rc |= jbt_reg_write(jbt, JBT_REG_DISPLAY_MODE2, 0x00);
+	rc |= jbt_reg_write(jbt, JBT_REG_RGB_FORMAT, 0x60);
+	rc |= jbt_reg_write(jbt, JBT_REG_DRIVE_SYSTEM, 0x10);
+	rc |= jbt_reg_write(jbt, JBT_REG_BOOSTER_OP, 0x56);
+	rc |= jbt_reg_write(jbt, JBT_REG_BOOSTER_MODE, 0x33);
+	rc |= jbt_reg_write(jbt, JBT_REG_BOOSTER_FREQ, 0x11);
+	rc |= jbt_reg_write(jbt, JBT_REG_OPAMP_SYSCLK, 0x02);
+	rc |= jbt_reg_write(jbt, JBT_REG_VSC_VOLTAGE, 0x2b);
+	rc |= jbt_reg_write(jbt, JBT_REG_VCOM_VOLTAGE, 0x40);
+	rc |= jbt_reg_write(jbt, JBT_REG_EXT_DISPL, 0x03);
+	rc |= jbt_reg_write(jbt, JBT_REG_DCCLK_DCEV, 0x04);
+	/*
+	 * default of 0x02 in JBT_REG_ASW_SLEW responsible for 72Hz requirement
+	 * to avoid red / blue flicker
+	 */
+	rc |= jbt_reg_write(jbt, JBT_REG_ASW_SLEW, 0x04);
+	rc |= jbt_reg_write(jbt, JBT_REG_DUMMY_DISPLAY, 0x00);
+
+	rc |= jbt_reg_write(jbt, JBT_REG_SLEEP_OUT_FR_A, 0x11);
+	rc |= jbt_reg_write(jbt, JBT_REG_SLEEP_OUT_FR_B, 0x11);
+	rc |= jbt_reg_write(jbt, JBT_REG_SLEEP_OUT_FR_C, 0x11);
+	rc |= jbt_reg_write16(jbt, JBT_REG_SLEEP_IN_LCCNT_D, 0x2040);
+	rc |= jbt_reg_write16(jbt, JBT_REG_SLEEP_IN_LCCNT_E, 0x60c0);
+	rc |= jbt_reg_write16(jbt, JBT_REG_SLEEP_IN_LCCNT_F, 0x1020);
+	rc |= jbt_reg_write16(jbt, JBT_REG_SLEEP_IN_LCCNT_G, 0x60c0);
+
+	rc |= jbt_reg_write16(jbt, JBT_REG_GAMMA1_FINE_1, 0x5533);
+	rc |= jbt_reg_write(jbt, JBT_REG_GAMMA1_FINE_2, 0x00);
+	rc |= jbt_reg_write(jbt, JBT_REG_GAMMA1_INCLINATION, 0x00);
+	rc |= jbt_reg_write(jbt, JBT_REG_GAMMA1_BLUE_OFFSET, 0x00);
+
+	if (jbt->normal_state != JBT_STATE_QVGA_NORMAL) {
+		rc |= jbt_reg_write16(jbt, JBT_REG_HCLOCK_VGA, 0x1f0);
+		rc |= jbt_reg_write(jbt, JBT_REG_BLANK_CONTROL, 0x02);
+		rc |= jbt_reg_write16(jbt, JBT_REG_BLANK_TH_TV, 0x0804);
+
+		rc |= jbt_reg_write(jbt, JBT_REG_CKV_ON_OFF, 0x01);
+		rc |= jbt_reg_write16(jbt, JBT_REG_CKV_1_2, 0x0000);
+
+		rc |= jbt_reg_write16(jbt, JBT_REG_OEV_TIMING, 0x0d0e);
+		rc |= jbt_reg_write16(jbt, JBT_REG_ASW_TIMING_1, 0x11a4);
+		rc |= jbt_reg_write(jbt, JBT_REG_ASW_TIMING_2, 0x0e);
+	} else {
+		rc |= jbt_reg_write16(jbt, JBT_REG_HCLOCK_QVGA, 0x00ff);
+		rc |= jbt_reg_write(jbt, JBT_REG_BLANK_CONTROL_QVGA, 0x02);
+		rc |= jbt_reg_write16(jbt, JBT_REG_BLANK_TH_TV_QVGA, 0x0804);
+
+		rc |= jbt_reg_write(jbt, JBT_REG_CKV_ON_OFF_QVGA, 0x01);
+		rc |= jbt_reg_write16(jbt, JBT_REG_CKV_1_2_QVGA, 0x0008);
+
+		rc |= jbt_reg_write16(jbt, JBT_REG_OEV_TIMING_QVGA, 0x050a);
+		rc |= jbt_reg_write16(jbt, JBT_REG_ASW_TIMING_1_QVGA, 0x0a19);
+		rc |= jbt_reg_write(jbt, JBT_REG_ASW_TIMING_2_QVGA, 0x0a);
+	}
+
+	return rc ? -EIO : 0;
+}
+
+static int standby_to_sleep(struct jbt_info *jbt)
+{
+	int rc;
+
+	/* three times command zero */
+	rc = jbt_reg_write_nodata(jbt, 0x00);
+	mdelay(1);
+	rc |= jbt_reg_write_nodata(jbt, 0x00);
+	mdelay(1);
+	rc |= jbt_reg_write_nodata(jbt, 0x00);
+	mdelay(1);
+
+	/* deep standby out */
+	rc |= jbt_reg_write(jbt, JBT_REG_POWER_ON_OFF, 0x11);
+	mdelay(1);
+	rc = jbt_reg_write(jbt, JBT_REG_DISPLAY_MODE, 0x28);
+
+	/* (re)initialize register set */
+	rc |= jbt_init_regs(jbt);
+
+	return rc ? -EIO : 0;
+}
+
+static int sleep_to_normal(struct jbt_info *jbt)
+{
+	int rc;
+
+	/* Make sure we are 120 ms after SLEEP_OUT */
+	unsigned int sleep_time = timespec_sub_ms(current_kernel_time(),
+							jbt->last_sleep);
+	if (sleep_time < 120)
+		mdelay(120 - sleep_time);
+
+	if (jbt->normal_state == JBT_STATE_NORMAL) {
+		/* RGB I/F on, RAM wirte off, QVGA through, SIGCON enable */
+		rc = jbt_reg_write(jbt, JBT_REG_DISPLAY_MODE, 0x80);
+
+		/* Quad mode off */
+		rc |= jbt_reg_write(jbt, JBT_REG_QUAD_RATE, 0x00);
+	} else {
+		/* RGB I/F on, RAM wirte off, QVGA through, SIGCON enable */
+		rc = jbt_reg_write(jbt, JBT_REG_DISPLAY_MODE, 0x81);
+
+		/* Quad mode on */
+		rc |= jbt_reg_write(jbt, JBT_REG_QUAD_RATE, 0x22);
+	}
+
+	/* AVDD on, XVDD on */
+	rc |= jbt_reg_write(jbt, JBT_REG_POWER_ON_OFF, 0x16);
+
+	/* Output control */
+	rc |= jbt_reg_write16(jbt, JBT_REG_OUTPUT_CONTROL, 0xfff9);
+
+	/* Turn on display */
+	rc |= jbt_reg_write_nodata(jbt, JBT_REG_DISPLAY_ON);
+
+	/* Sleep mode off */
+	rc |= jbt_reg_write_nodata(jbt, JBT_REG_SLEEP_OUT);
+	jbt->last_sleep = current_kernel_time();
+
+	/* Allow the booster and display controller to restart stably */
+	mdelay(5);
+
+	return rc ? -EIO : 0;
+}
+
+static int normal_to_sleep(struct jbt_info *jbt)
+{
+	int rc;
+
+	/* Make sure we are 120 ms after SLEEP_OUT */
+	unsigned int sleep_time = timespec_sub_ms(current_kernel_time(),
+							jbt->last_sleep);
+	if (sleep_time < 120)
+		mdelay(120 - sleep_time);
+
+	rc = jbt_reg_write_nodata(jbt, JBT_REG_DISPLAY_OFF);
+	rc |= jbt_reg_write16(jbt, JBT_REG_OUTPUT_CONTROL, 0x8002);
+	rc |= jbt_reg_write_nodata(jbt, JBT_REG_SLEEP_IN);
+	jbt->last_sleep = current_kernel_time();
+
+	/* Allow the internal circuits to stop automatically */
+	mdelay(5);
+
+	return rc ? -EIO : 0;
+}
+
+static int sleep_to_standby(struct jbt_info *jbt)
+{
+	return jbt_reg_write(jbt, JBT_REG_POWER_ON_OFF, 0x00);
+}
+
+/* frontend function */
+int jbt6k74_enter_state(struct jbt_info *jbt, enum jbt_state new_state)
+{
+	int rc = -EINVAL;
+
+	dev_dbg(&jbt->spi_dev->dev, "entering (old_state=%s, new_state=%s)\n",
+			jbt_state_names[jbt->state],
+			jbt_state_names[new_state]);
+
+	mutex_lock(&jbt->lock);
+
+	if (new_state == JBT_STATE_NORMAL ||
+			new_state == JBT_STATE_QVGA_NORMAL)
+		jbt->normal_state = new_state;
+
+	switch (jbt->state) {
+	case JBT_STATE_DEEP_STANDBY:
+		switch (new_state) {
+		case JBT_STATE_DEEP_STANDBY:
+			rc = 0;
+			break;
+		case JBT_STATE_SLEEP:
+			rc = standby_to_sleep(jbt);
+			break;
+		case JBT_STATE_NORMAL:
+			/* first transition into sleep */
+			rc = standby_to_sleep(jbt);
+			/* then transition into normal */
+			rc |= sleep_to_normal(jbt);
+			break;
+		case JBT_STATE_QVGA_NORMAL:
+			/* first transition into sleep */
+			rc = standby_to_sleep(jbt);
+			/* then transition into normal */
+			rc |= sleep_to_normal(jbt);
+			break;
+		}
+		break;
+	case JBT_STATE_SLEEP:
+		switch (new_state) {
+		case JBT_STATE_SLEEP:
+			rc = 0;
+			break;
+		case JBT_STATE_DEEP_STANDBY:
+			rc = sleep_to_standby(jbt);
+			break;
+		case JBT_STATE_NORMAL:
+		case JBT_STATE_QVGA_NORMAL:
+			rc = sleep_to_normal(jbt);
+			break;
+		}
+		break;
+	case JBT_STATE_NORMAL:
+		switch (new_state) {
+		case JBT_STATE_NORMAL:
+			rc = 0;
+			break;
+		case JBT_STATE_DEEP_STANDBY:
+			/* first transition into sleep */
+			rc = normal_to_sleep(jbt);
+			/* then transition into deep standby */
+			rc |= sleep_to_standby(jbt);
+			break;
+		case JBT_STATE_SLEEP:
+			rc = normal_to_sleep(jbt);
+			break;
+		case JBT_STATE_QVGA_NORMAL:
+			/* first transition into sleep */
+			rc = normal_to_sleep(jbt);
+			/* second transition into deep standby */
+			rc |= sleep_to_standby(jbt);
+			/* third transition into sleep */
+			rc |= standby_to_sleep(jbt);
+			/* fourth transition into normal */
+			rc |= sleep_to_normal(jbt);
+			break;
+		}
+		break;
+	case JBT_STATE_QVGA_NORMAL:
+		switch (new_state) {
+		case JBT_STATE_QVGA_NORMAL:
+			rc = 0;
+			break;
+		case JBT_STATE_DEEP_STANDBY:
+			/* first transition into sleep */
+			rc = normal_to_sleep(jbt);
+			/* then transition into deep standby */
+			rc |= sleep_to_standby(jbt);
+			break;
+		case JBT_STATE_SLEEP:
+			rc = normal_to_sleep(jbt);
+			break;
+		case JBT_STATE_NORMAL:
+			/* first transition into sleep */
+			rc = normal_to_sleep(jbt);
+			/* second transition into deep standby */
+			rc |= sleep_to_standby(jbt);
+			/* third transition into sleep */
+			rc |= standby_to_sleep(jbt);
+			/* fourth transition into normal */
+			rc |= sleep_to_normal(jbt);
+			break;
+		}
+		break;
+	}
+
+	if (rc == 0)
+		jbt->state = new_state;
+	else
+		dev_err(&jbt->spi_dev->dev, "Failed enter state '%s')\n",
+				jbt_state_names[new_state]);
+
+	mutex_unlock(&jbt->lock);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(jbt6k74_enter_state);
+
+static ssize_t state_read(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct jbt_info *jbt = dev_get_drvdata(dev);
+
+	if (jbt->state >= ARRAY_SIZE(jbt_state_names))
+		return -EIO;
+
+	return sprintf(buf, "%s\n", jbt_state_names[jbt->state]);
+}
+
+static ssize_t state_write(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct jbt_info *jbt = dev_get_drvdata(dev);
+	int i, rc;
+
+	for (i = 0; i < ARRAY_SIZE(jbt_state_names); i++) {
+		if (!strncmp(buf, jbt_state_names[i],
+			     strlen(jbt_state_names[i]))) {
+			rc = jbt6k74_enter_state(jbt, i);
+			if (rc)
+				return rc;
+			return count;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static DEVICE_ATTR(state, 0644, state_read, state_write);
+
+static int reg_by_string(const char *name)
+{
+	if (!strcmp(name, "gamma_fine1"))
+		return JBT_REG_GAMMA1_FINE_1;
+	else if (!strcmp(name, "gamma_fine2"))
+		return JBT_REG_GAMMA1_FINE_2;
+	else if (!strcmp(name, "gamma_inclination"))
+		return JBT_REG_GAMMA1_INCLINATION;
+	else
+		return JBT_REG_GAMMA1_BLUE_OFFSET;
+}
+
+static ssize_t gamma_read(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct jbt_info *jbt = dev_get_drvdata(dev);
+	int reg = reg_by_string(attr->attr.name);
+	u16 val;
+
+	mutex_lock(&jbt->lock);
+	val = jbt->reg_cache[reg];
+	mutex_unlock(&jbt->lock);
+
+	return sprintf(buf, "0x%04x\n", val);
+}
+
+static ssize_t gamma_write(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct jbt_info *jbt = dev_get_drvdata(dev);
+	int reg = reg_by_string(attr->attr.name);
+	unsigned long val = simple_strtoul(buf, NULL, 10);
+
+	dev_info(dev, "writing gama %lu\n", val & 0xff);
+
+	mutex_lock(&jbt->lock);
+	jbt_reg_write(jbt, reg, val & 0xff);
+	mutex_unlock(&jbt->lock);
+
+	return count;
+}
+
+static ssize_t reset_write(struct device *dev, struct device_attribute *attr,
+			   const char *buf, size_t count)
+{
+	int rc;
+	struct jbt_info *jbt = dev_get_drvdata(dev);
+	struct jbt6k74_platform_data *pdata = jbt->spi_dev->dev.platform_data;
+
+	dev_info(dev, "reset\n");
+
+	mutex_lock(&jbt->lock);
+
+	jbt->state = JBT_STATE_DEEP_STANDBY;
+
+	/* hard reset the jbt6k74 */
+	(pdata->reset)(0, 0);
+	mdelay(1);
+	(pdata->reset)(0, 1);
+	mdelay(120);
+
+	rc = jbt_reg_write_nodata(jbt, 0x01);
+	if (rc < 0)
+		dev_err(&jbt->spi_dev->dev, "cannot soft reset\n");
+	mdelay(120);
+
+	mutex_unlock(&jbt->lock);
+
+	jbt6k74_enter_state(jbt, jbt->normal_state);
+
+	return count;
+}
+
+static DEVICE_ATTR(gamma_fine1, 0644, gamma_read, gamma_write);
+static DEVICE_ATTR(gamma_fine2, 0644, gamma_read, gamma_write);
+static DEVICE_ATTR(gamma_inclination, 0644, gamma_read, gamma_write);
+static DEVICE_ATTR(gamma_blue_offset, 0644, gamma_read, gamma_write);
+static DEVICE_ATTR(reset, 0600, NULL, reset_write);
+
+static struct attribute *jbt_sysfs_entries[] = {
+	&dev_attr_state.attr,
+	&dev_attr_gamma_fine1.attr,
+	&dev_attr_gamma_fine2.attr,
+	&dev_attr_gamma_inclination.attr,
+	&dev_attr_gamma_blue_offset.attr,
+	&dev_attr_reset.attr,
+	NULL,
+};
+
+static struct attribute_group jbt_attr_group = {
+	.name	= NULL,
+	.attrs	= jbt_sysfs_entries,
+};
+
+static int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data)
+{
+	struct jbt_info *jbt;
+	struct fb_event *evdata = data;
+	int fb_blank;
+
+	jbt = container_of(self, struct jbt_info, fb_notif);
+
+	dev_dbg(&jbt->spi_dev->dev, "event=%lu\n", event);
+
+	if (event != FB_EVENT_BLANK && event != FB_EVENT_CONBLANK)
+		return 0;
+
+	fb_blank = *(int *)evdata->data;
+	switch (fb_blank) {
+	case FB_BLANK_UNBLANK:
+		dev_dbg(&jbt->spi_dev->dev, "unblank\n");
+		jbt6k74_enter_state(jbt, jbt->normal_state);
+		break;
+	case FB_BLANK_NORMAL:
+		dev_dbg(&jbt->spi_dev->dev, "blank\n");
+		break;
+	case FB_BLANK_VSYNC_SUSPEND:
+		dev_dbg(&jbt->spi_dev->dev, "vsync suspend\n");
+		break;
+	case FB_BLANK_HSYNC_SUSPEND:
+		dev_dbg(&jbt->spi_dev->dev, "hsync suspend\n");
+		break;
+	case FB_BLANK_POWERDOWN:
+		dev_dbg(&jbt->spi_dev->dev, "powerdown\n");
+		jbt6k74_enter_state(jbt, JBT_STATE_SLEEP);
+		break;
+	}
+
+	return 0;
+}
+
+/* linux device model infrastructure */
+
+static int __devinit jbt_probe(struct spi_device *spi)
+{
+	int rc;
+	struct jbt_info *jbt;
+	struct jbt6k74_platform_data *pdata = spi->dev.platform_data;
+
+	/* the controller doesn't have a MISO pin; we can't do detection */
+
+	spi->mode = SPI_CPOL | SPI_CPHA;
+	spi->bits_per_word = 9;
+
+	rc = spi_setup(spi);
+	if (rc < 0) {
+		dev_err(&spi->dev,
+			"error during spi_setup of jbt6k74 driver\n");
+		return rc;
+	}
+
+	jbt = kzalloc(sizeof(*jbt), GFP_KERNEL);
+	if (!jbt)
+		return -ENOMEM;
+
+	jbt->spi_dev = spi;
+	jbt->normal_state = JBT_STATE_NORMAL;
+	jbt->state = JBT_STATE_DEEP_STANDBY;
+	jbt->last_sleep = current_kernel_time();
+	mutex_init(&jbt->lock);
+
+	dev_set_drvdata(&spi->dev, jbt);
+
+	rc = jbt6k74_enter_state(jbt, JBT_STATE_NORMAL);
+	if (rc < 0) {
+		dev_err(&spi->dev, "cannot enter NORMAL state\n");
+		goto err_free_drvdata;
+	}
+
+	rc = sysfs_create_group(&spi->dev.kobj, &jbt_attr_group);
+	if (rc < 0) {
+		dev_err(&spi->dev, "cannot create sysfs group\n");
+		goto err_standby;
+	}
+
+	jbt->fb_notif.notifier_call = fb_notifier_callback;
+	rc = fb_register_client(&jbt->fb_notif);
+	if (rc < 0) {
+		dev_err(&spi->dev, "cannot register notifier\n");
+		goto err_sysfs;
+	}
+
+	if (pdata->probe_completed)
+		(pdata->probe_completed)(&spi->dev);
+
+	return 0;
+
+err_sysfs:
+	sysfs_remove_group(&spi->dev.kobj, &jbt_attr_group);
+err_standby:
+	jbt6k74_enter_state(jbt, JBT_STATE_DEEP_STANDBY);
+err_free_drvdata:
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(jbt);
+
+	return rc;
+}
+
+static int __devexit jbt_remove(struct spi_device *spi)
+{
+	struct jbt_info *jbt = dev_get_drvdata(&spi->dev);
+
+	/* We don't want to switch off the display in case the user
+	 * accidentially onloads the module (whose use count normally is 0) */
+	jbt6k74_enter_state(jbt, jbt->normal_state);
+
+	fb_unregister_client(&jbt->fb_notif);
+	sysfs_remove_group(&spi->dev.kobj, &jbt_attr_group);
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(jbt);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int jbt_suspend(struct spi_device *spi, pm_message_t state)
+{
+	struct jbt_info *jbt = dev_get_drvdata(&spi->dev);
+
+	jbt6k74_enter_state(jbt, JBT_STATE_DEEP_STANDBY);
+
+	dev_info(&spi->dev, "suspended\n");
+
+	return 0;
+}
+
+int jbt6k74_resume(struct spi_device *spi)
+{
+	struct jbt_info *jbt = dev_get_drvdata(&spi->dev);
+	struct jbt6k74_platform_data *pdata = spi->dev.platform_data;
+
+	jbt6k74_enter_state(jbt, jbt->normal_state);
+
+	if (pdata->resuming)
+		(pdata->resuming)(0);
+
+	dev_info(&spi->dev, "resumed\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(jbt6k74_resume);
+
+#else
+#define jbt_suspend	NULL
+#define jbt6k74_resume	NULL
+#endif
+
+static struct spi_driver jbt6k74_driver = {
+	.driver = {
+		.name	= "jbt6k74",
+		.owner	= THIS_MODULE,
+	},
+
+	.probe	 = jbt_probe,
+	.remove	 = __devexit_p(jbt_remove),
+	.suspend = jbt_suspend,
+	.resume	 = jbt6k74_resume,
+};
+
+static int __init jbt_init(void)
+{
+	return spi_register_driver(&jbt6k74_driver);
+}
+
+static void __exit jbt_exit(void)
+{
+	spi_unregister_driver(&jbt6k74_driver);
+}
+
+MODULE_DESCRIPTION("SPI driver for tpo JBT6K74-AS LCM control interface");
+MODULE_AUTHOR("Harald Welte <laforge@openmoko.org>");
+MODULE_LICENSE("GPL");
+
+module_init(jbt_init);
+module_exit(jbt_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/display/Kconfig linux-2.6.29-rc3.owrt.om/drivers/video/display/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/video/display/Kconfig	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/display/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -21,4 +21,23 @@
 comment "Display hardware drivers"
 	depends on DISPLAY_SUPPORT
 
+config DISPLAY_JBT6K74
+	tristate "TPO JBT6K74-AS TFT display ASIC control interface"
+	depends on SPI_MASTER && SYSFS
+	help
+	  SPI driver for the control interface of TFT panels containing
+	  the TPO JBT6K74-AS controller ASIC, such as the TPO TD028TTEC1
+	  TFT diplay module used in the FIC/Openmoko Neo1973 GSM phones.
+
+	  The control interface is required for display operation, as it
+	  controls power management, display timing and gamma calibration.
+
+config DISPLAY_L1K002
+	tristate "TP0 L1K0-02 TFT ASIC control interface"
+	depends on SPI_MASTER && SYSFS
+	help
+	  The control interface of this LTPS TFT panel is based on SPI bitbang driver.
+	  It controls display timing and gamma calibration. TP0 LPJ028T007A LCM uses this IC
+	  as its controller in the Openmoko GTA03 GSM phone.
+
 endmenu
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/display/l1k002.c linux-2.6.29-rc3.owrt.om/drivers/video/display/l1k002.c
--- linux-2.6.29-rc3.owrt/drivers/video/display/l1k002.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/video/display/l1k002.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,278 @@
+/*
+ *  Copyright (C) 2009 Openmoko, Inc.
+ *
+ *  Author: Matt Hsu <matt_hsu@openmoko.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or (at
+ *  your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+
+#include <linux/l1k002.h>
+
+struct l1k002_data {
+	struct spi_device *spi;
+	struct mutex lock;
+	u8 mosi_buf[2];
+	u8 reg_cache[0x40];
+};
+
+enum l1k002_regs_table {
+
+	L1K002_REG_SYNCP_SEL 		= 0x02,
+	L1K002_REG_VSTS 		= 0x03,
+	L1K002_REG_HSTS 		= 0x04,
+	L1K002_REG_MISC 		= 0x07,
+	L1K002_REG_CMDR 		= 0x08,
+	L1K002_REG_IN_DATA_TIMING 	= 0x09,
+	L1K002_REG_ENGR_OTP 		= 0x0b,
+	L1K002_REG_VGLS 		= 0x0c,
+	L1K002_REG_DISP_8_9		= 0x0d,
+	L1K002_REG_DISP_0_7		= 0x0e,
+	L1K002_REG_HTOTAL_8_10		= 0x0f,
+	L1K002_REG_HTOTAL_0_7 		= 0x10,
+	L1K002_REG_WCKH 		= 0x20,
+	L1K002_REG_GCKH 		= 0x21,
+	L1K002_REG_DCKH 		= 0x22,
+	L1K002_REG_WENBV 		= 0x23,
+	L1K002_REG_DCKV 		= 0x25,
+	L1K002_REG_WCKV 		= 0x27,
+	L1K002_REG_DA_VCOM 		= 0x2a,
+	L1K002_REG_PVH 			= 0x2b,
+	L1K002_REG_NVH_NVL 		= 0x2c,
+	L1K002_REG_GC1 			= 0x2d,
+	L1K002_REG_GC2  		= 0x2e,
+	L1K002_REG_GC3  		= 0x2f,
+	L1K002_REG_GC4  		= 0x30,
+	L1K002_REG_GC5  		= 0x31,
+	L1K002_REG_GC6  		= 0x32,
+	L1K002_REG_GC7  		= 0x33,
+	L1K002_REG_GC8 			= 0x34,
+	L1K002_REG_GC9  		= 0x35,
+	L1K002_REG_GC10 		= 0x36,
+	L1K002_REG_GC11	 		= 0x37,
+	L1K002_REG_GC12 		= 0x38,
+	L1K002_REG_GC13 		= 0x39,
+	L1K002_REG_GC14 		= 0x3a,
+	L1K002_REG_GC15 		= 0x3b,
+};
+
+static int l1k002_reg_write(struct l1k002_data *l1k002, u8 reg, u8 data)
+{
+	int ret;
+
+	mutex_lock(&l1k002->lock);
+
+	l1k002->mosi_buf[0] = reg;
+	l1k002->mosi_buf[1] = data;
+
+	ret = spi_write(l1k002->spi, (u8 *)l1k002->mosi_buf, 2*sizeof(u8));
+	if (ret == 0)
+		l1k002->reg_cache[reg] = data;
+	else
+		dev_err(&l1k002->spi->dev, "reg spi_write ret: %d\n", ret);
+
+	mutex_unlock(&l1k002->lock);
+	return ret;
+}
+
+static int l1k002_init_reg(struct l1k002_data *l1k002)
+{
+	int ret;
+
+	/* software reset */
+	ret = l1k002_reg_write(l1k002, L1K002_REG_CMDR, 0x01);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_CMDR, 0x00);
+
+	/* setup color mode and direction */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_MISC, 0xd9);
+
+	/* dclk initial */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_SYNCP_SEL, 0x00);
+
+	/* start vertical data */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_VSTS, 0x04);
+
+	/* start horizonal data */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_HSTS, 0x14);
+
+	/* setup hsnc, vsnc, data_enable */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_IN_DATA_TIMING, 0x03);
+	/* enable engineering mode and OTP */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_ENGR_OTP, 0x18);
+
+	/* display area */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_VGLS, 0x41);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_DISP_8_9, 0x02);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_DISP_0_7, 0x80);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_HTOTAL_8_10, 0x02);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_HTOTAL_0_7, 0x08);
+
+	/* CKH pulse config */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_WCKH, 0x3c);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GCKH, 0x0c);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_DCKH, 0x10);
+
+	/* ENBV config */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_WENBV, 0x38);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_DCKV, 0x3c);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_WCKV, 0xdb);
+
+	/* driving voltage */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_DA_VCOM, 0x66);
+
+	/* gamma output voltage level */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_PVH, 0x70);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_NVH_NVL, 0x70);
+
+	/* gamma correction */
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC1, 0x15);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC2, 0xaa);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC3, 0xbf);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC4, 0x86);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC5, 0x11);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC6, 0x5e);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC7, 0xb6);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC8, 0x16);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC9, 0x4e);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC10, 0x78);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC11, 0xbf);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC12, 0xec);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC13, 0x10);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC14, 0x30);
+	ret |= l1k002_reg_write(l1k002, L1K002_REG_GC15, 0xff);
+
+	ret |= l1k002_reg_write(l1k002, 0x07, 0xc9);
+
+	if (ret == 0)
+		dev_info(&l1k002->spi->dev, "initialize OK \n");
+	else
+		dev_err(&l1k002->spi->dev, "initialize failed ret: %d\n", ret);
+	return ret;
+}
+
+static int l1k002_probe(struct spi_device *spi)
+{
+	int ret;
+	struct l1k002_data *l1k002;
+	struct l1k002_platform_data *l1k002_pdata = spi->dev.platform_data;
+
+	if (l1k002_pdata == NULL) {
+		dev_err(&spi->dev,
+			"no platform data available \n");
+		return -EINVAL;
+	}
+
+	spi->mode = SPI_CPOL | SPI_CPHA;
+	spi->bits_per_word = 8;
+
+	ret = spi_setup(spi);
+	if (ret < 0) {
+		dev_err(&spi->dev,
+			"error during spi_setup of l1k002 driver\n");
+		return ret;
+	}
+
+	l1k002 = kzalloc(sizeof(*l1k002), GFP_KERNEL);
+	if (!l1k002)
+		return -ENOMEM;
+
+	l1k002->spi = spi;
+	dev_set_drvdata(&spi->dev, l1k002);
+
+	mutex_init(&l1k002->lock);
+
+	/* hard reset l1k002 */
+	(l1k002_pdata->pwr_onoff)(1);
+
+	ret = l1k002_init_reg(l1k002);
+	if (ret)
+		goto err_free;
+
+	/* FIXME: sysfs should be added here */
+
+	return 0;
+
+err_free:
+	kfree(l1k002);
+	return ret;
+}
+
+static int __devexit l1k002_remove(struct spi_device *spi)
+{
+	struct l1k002 *l1k002 = dev_get_drvdata(&spi->dev);
+
+	dev_set_drvdata(&spi->dev, NULL);
+	kfree(l1k002);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int l1k002_suspend(struct spi_device *spi, pm_message_t state)
+{
+	struct l1k002_platform_data *l1k002_pdata = spi->dev.platform_data;
+
+	/* l1k002 doesn't have sleep mode
+	 * it should be powered down as entering suspend state
+	 */
+	(l1k002_pdata->pwr_onoff)(0);
+	return 0;
+}
+
+static int l1k002_resume(struct spi_device *spi)
+{
+	struct l1k002_platform_data *l1k002_pdata = spi->dev.platform_data;
+	struct l1k002_data *l1k002 = dev_get_drvdata(&spi->dev);
+
+	(l1k002_pdata->pwr_onoff)(1);
+	return l1k002_init_reg(l1k002);
+}
+#else
+#define l1k002_suspend 	NULL
+#define l1k002_resume 	NULL
+#endif
+
+static struct spi_driver l1k002_driver = {
+	.driver = {
+		.name	= "l1k002",
+		.owner	= THIS_MODULE,
+	},
+
+	.probe	 = l1k002_probe,
+	.remove	 = __devexit_p(l1k002_remove),
+	.suspend = l1k002_suspend,
+	.resume	 = l1k002_resume,
+};
+
+static int __init l1k002_init(void)
+{
+	return spi_register_driver(&l1k002_driver);
+}
+
+static void __exit l1k002_exit(void)
+{
+	spi_unregister_driver(&l1k002_driver);
+}
+
+MODULE_AUTHOR("Matt Hsu <matt_hsu@openmoko.org>");
+MODULE_LICENSE("GPL v2");
+
+module_init(l1k002_init);
+module_exit(l1k002_exit);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/display/Makefile linux-2.6.29-rc3.owrt.om/drivers/video/display/Makefile
--- linux-2.6.29-rc3.owrt/drivers/video/display/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/display/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -3,4 +3,6 @@
 display-objs				:= display-sysfs.o
 
 obj-$(CONFIG_DISPLAY_SUPPORT)		+= display.o
+obj-$(CONFIG_DISPLAY_JBT6K74)		+= jbt6k74.o
+obj-$(CONFIG_DISPLAY_L1K002)		+= l1k002.o
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/Kconfig linux-2.6.29-rc3.owrt.om/drivers/video/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/video/Kconfig	2009-05-10 22:08:45.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -1924,6 +1924,30 @@
 	depends on FB_TMIO
 	default y
 
+config FB_S3C
+	tristate "Samsung S3C framebuffer support"
+	depends on FB && ARCH_S3C64XX
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+	  Frame buffer driver for the built-in FB controller in the Samsung
+	  SoC line from the S3C2443 onwards, including the S3C2416, S3C2450,
+	  and the S3C64XX series such as the S3C6400 and S3C6410.
+
+	  These chips all have the same basic framebuffer design with the
+	  actual capabilities depending on the chip. For instance the S3C6400
+	  and S3C6410 support 4 hardware windows whereas the S3C24XX series
+	  currently only have two.
+
+	  Currently the support is only for the S3C6400 and S3C6410 SoCs.
+
+config FB_S3C_DEBUG_REGWRITE
+       bool "Debug register writes"
+       depends on FB_S3C
+       ---help---
+         Show all register writes via printk(KERN_DEBUG)
+
 config FB_S3C2410
 	tristate "S3C2410 LCD framebuffer support"
 	depends on FB && ARCH_S3C2410
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/Makefile linux-2.6.29-rc3.owrt.om/drivers/video/Makefile
--- linux-2.6.29-rc3.owrt/drivers/video/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -109,6 +109,7 @@
 obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
 obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
 obj-$(CONFIG_FB_IMX)              += imxfb.o
+obj-$(CONFIG_FB_S3C)		  += s3c-fb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
 obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/s3c2410fb.c linux-2.6.29-rc3.owrt.om/drivers/video/s3c2410fb.c
--- linux-2.6.29-rc3.owrt/drivers/video/s3c2410fb.c	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/video/s3c2410fb.c	2009-05-10 22:28:00.000000000 +0200
@@ -1017,6 +1017,8 @@
 
 	s3c2410fb_init_registers(fbinfo);
 
+	s3c2410fb_set_par(fbinfo);
+
 	return 0;
 }
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/video/s3c-fb.c linux-2.6.29-rc3.owrt.om/drivers/video/s3c-fb.c
--- linux-2.6.29-rc3.owrt/drivers/video/s3c-fb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/video/s3c-fb.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,1036 @@
+/* linux/drivers/video/s3c-fb.c
+ *
+ * Copyright 2008 Openmoko Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * Samsung SoC Framebuffer driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/gfp.h>
+#include <linux/clk.h>
+#include <linux/fb.h>
+#include <linux/io.h>
+
+#include <mach/map.h>
+#include <mach/regs-fb.h>
+#include <plat/fb.h>
+
+/* This driver will export a number of framebuffer interfaces depending
+ * on the configuration passed in via the platform data. Each fb instance
+ * maps to a hardware window. Currently there is no support for runtime
+ * setting of the alpha-blending functions that each window has, so only
+ * window 0 is actually useful.
+ *
+ * Window 0 is treated specially, it is used for the basis of the LCD
+ * output timings and as the control for the output power-down state.
+*/
+
+/* note, some of the functions that get called are derived from including
+ * <mach/regs-fb.h> as they are specific to the architecture that the code
+ * is being built for.
+*/
+
+#ifdef CONFIG_FB_S3C_DEBUG_REGWRITE
+#undef writel
+#define writel(v, r) do { \
+	printk(KERN_DEBUG "%s: %08x => %p\n", __func__, (unsigned int)v, r); \
+	__raw_writel(v, r); } while(0)
+#endif /* FB_S3C_DEBUG_REGWRITE */
+
+struct s3c_fb;
+
+/**
+ * struct s3c_fb_win - per window private data for each framebuffer.
+ * @windata: The platform data supplied for the window configuration.
+ * @parent: The hardware that this window is part of.
+ * @fbinfo: Pointer pack to the framebuffer info for this window.
+ * @palette_buffer: Buffer/cache to hold palette entries.
+ * @pseudo_palette: For use in TRUECOLOUR modes for entries 0..15/
+ * @index: The window number of this window.
+ * @palette: The bitfields for changing r/g/b into a hardware palette entry.
+ */
+struct s3c_fb_win {
+	struct s3c_fb_pd_win	*windata;
+	struct s3c_fb		*parent;
+	struct fb_info		*fbinfo;
+	struct s3c_fb_palette	 palette;
+
+	u32			*palette_buffer;
+	u32			 pseudo_palette[16];
+	unsigned int		 index;
+};
+
+/**
+ * struct s3c_fb - overall hardware state of the hardware
+ * @dev: The device that we bound to, for printing, etc.
+ * @regs_res: The resource we claimed for the IO registers.
+ * @bus_clk: The clk (hclk) feeding our interface and possibly pixclk.
+ * @regs: The mapped hardware registers.
+ * @enabled: A bitmask of enabled hardware windows.
+ * @pdata: The platform configuration data passed with the device.
+ * @windows: The hardware windows that have been claimed.
+ */
+struct s3c_fb {
+	struct device		*dev;
+	struct resource		*regs_res;
+	struct clk		*bus_clk;
+	void __iomem		*regs;
+
+	unsigned char		 enabled;
+
+	struct s3c_fb_platdata	*pdata;
+	struct s3c_fb_win	*windows[S3C_FB_MAX_WIN];
+};
+
+/**
+ * s3c_fb_win_has_palette() - determine if a mode has a palette
+ * @win: The window number being queried.
+ * @bpp: The number of bits per pixel to test.
+ *
+ * Work out if the given window supports palletised data at the specified bpp.
+ */
+static int s3c_fb_win_has_palette(unsigned int win, unsigned int bpp)
+{
+	return s3c_fb_win_pal_size(win) <= (1 << bpp);
+}
+
+/**
+ * s3c_fb_check_var() - framebuffer layer request to verify a given mode.
+ * @var: The screen information to verify.
+ * @info: The framebuffer device.
+ *
+ * Framebuffer layer call to verify the given information and allow us to
+ * update various information depending on the hardware capabilities.
+ */
+static int s3c_fb_check_var(struct fb_var_screeninfo *var,
+			    struct fb_info *info)
+{
+	struct s3c_fb_win *win = info->par;
+	struct s3c_fb_pd_win *windata = win->windata;
+	struct s3c_fb *sfb = win->parent;
+
+	dev_dbg(sfb->dev, "checking parameters\n");
+
+	var->xres_virtual = max((unsigned int)windata->virtual_x, var->xres);
+	var->yres_virtual = max((unsigned int)windata->virtual_y, var->yres);
+
+	if (!s3c_fb_validate_win_bpp(win->index, var->bits_per_pixel)) {
+		dev_dbg(sfb->dev, "win %d: unsupported bpp %d\n",
+			win->index, var->bits_per_pixel);
+		return -EINVAL;
+	}
+
+	/* always ensure these are zero, for drop through cases below */
+	var->transp.offset = 0;
+	var->transp.length = 0;
+
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 2:
+	case 4:
+	case 8:
+		if (!s3c_fb_win_has_palette(win->index, var->bits_per_pixel)) {
+			/* non palletised, A:1,R:2,G:3,B:2 mode */
+			var->red.offset		= 4;
+			var->green.offset	= 2;
+			var->blue.offset	= 0;
+			var->red.length		= 5;
+			var->green.length	= 3;
+			var->blue.length	= 2;
+			var->transp.offset	= 7;
+			var->transp.length	= 1;
+		} else {
+			var->red.offset	= 0;
+			var->red.length	= var->bits_per_pixel;
+			var->green	= var->red;
+			var->blue	= var->red;
+		}
+		break;
+
+	case 19:
+		/* 666 with one bit alpha/transparency */
+		var->transp.offset	= 18;
+		var->transp.length	= 1;
+	case 18:
+		var->bits_per_pixel	= 32;
+
+		/* 666 format */
+		var->red.offset		= 12;
+		var->green.offset	= 6;
+		var->blue.offset	= 0;
+		var->red.length		= 6;
+		var->green.length	= 6;
+		var->blue.length	= 6;
+		break;
+
+	case 16:
+		/* 16 bpp, 565 format */
+		var->red.offset		= 11;
+		var->green.offset	= 5;
+		var->blue.offset	= 0;
+		var->red.length		= 5;
+		var->green.length	= 6;
+		var->blue.length	= 5;
+		break;
+
+	case 28:
+	case 25:
+		var->transp.length	= var->bits_per_pixel - 24;
+		var->transp.offset	= 24;
+		/* drop through */
+	case 24:
+		/* our 24bpp is unpacked, so 32bpp */
+		var->bits_per_pixel	= 32;
+	case 32:
+		var->red.offset		= 16;
+		var->red.length		= 8;
+		var->green.offset	= 8;
+		var->green.length	= 8;
+		var->blue.offset	= 0;
+		var->blue.length	= 8;
+		break;
+
+	default:
+		dev_err(sfb->dev, "invalid bpp\n");
+	}
+
+	dev_dbg(sfb->dev, "%s: verified parameters\n", __func__);
+	return 0;
+}
+
+/**
+ * s3c_fb_calc_pixclk() - calculate the divider to create the pixel clock.
+ * @sfb: The hardware state.
+ * @pixclock: The pixel clock wanted, in picoseconds.
+ *
+ * Given the specified pixel clock, work out the necessary divider to get
+ * close to the output frequency.
+ */
+static int s3c_fb_calc_pixclk(struct s3c_fb *sfb, unsigned int pixclk)
+{
+	unsigned long clk = clk_get_rate(sfb->bus_clk);
+	unsigned long long tmp;
+	unsigned int result;
+
+	tmp = (unsigned long long)clk;
+	tmp *= pixclk;
+
+	do_div(tmp, 1000000000UL);
+	result = (unsigned int)tmp / 1000;
+
+	dev_dbg(sfb->dev, "pixclk=%u, clk=%lu, div=%d (%lu)\n",
+		pixclk, clk, result, clk / result);
+
+	return result;
+}
+
+/**
+ * s3c_fb_align_word() - align pixel count to word boundary
+ * @bpp: The number of bits per pixel
+ * @pix: The value to be aligned.
+ *
+ * Align the given pixel count so that it will start on an 32bit word
+ * boundary.
+ */
+static int s3c_fb_align_word(unsigned int bpp, unsigned int pix)
+{
+	int pix_per_word;
+
+	if (bpp > 16)
+		return pix;
+
+	pix_per_word = (8 * 32) / bpp;
+	return ALIGN(pix, pix_per_word);
+}
+
+/**
+ * s3c_fb_set_par() - framebuffer request to set new framebuffer state.
+ * @info: The framebuffer to change.
+ *
+ * Framebuffer layer request to set a new mode for the specified framebuffer
+ */
+static int s3c_fb_set_par(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct s3c_fb_win *win = info->par;
+	struct s3c_fb *sfb = win->parent;
+	void __iomem *regs = sfb->regs;
+	int win_no = win->index;
+	u32 data;
+	u32 pagewidth;
+	int clkdiv;
+
+	dev_dbg(sfb->dev, "setting framebuffer parameters\n");
+
+	switch (var->bits_per_pixel) {
+	case 32:
+	case 24:
+	case 16:
+	case 12:
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+		break;
+	case 8:
+		if (s3c_fb_win_has_palette(win_no, 8))
+			info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		else
+			info->fix.visual = FB_VISUAL_TRUECOLOR;
+		break;
+	case 1:
+		info->fix.visual = FB_VISUAL_MONO01;
+		break;
+	default:
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+		break;
+	}
+
+	info->fix.line_length = (var->xres_virtual * var->bits_per_pixel) / 8;
+
+	/* disable the window whilst we update it */
+	writel(0, regs + WINCON(win_no));
+
+	/* use window 0 as the basis for the lcd output timings */
+
+	if (win_no == 0) {
+		clkdiv = s3c_fb_calc_pixclk(sfb, var->pixclock);
+
+		data = sfb->pdata->vidcon0;
+		data &= ~(VIDCON0_CLKVAL_F_MASK | VIDCON0_CLKDIR);
+
+		if (clkdiv > 1)
+			data |= VIDCON0_CLKVAL_F(clkdiv-1) | VIDCON0_CLKDIR;
+		else
+			data &= ~VIDCON0_CLKDIR;	/* 1:1 clock */
+
+		/* write the timing data to the panel */
+
+		data |= VIDCON0_ENVID | VIDCON0_ENVID_F;
+		writel(data, regs + VIDCON0);
+
+		data = VIDTCON0_VBPD(var->upper_margin - 1) |
+		       VIDTCON0_VFPD(var->lower_margin - 1) |
+		       VIDTCON0_VSPW(var->vsync_len - 1);
+
+		writel(data, regs + VIDTCON0);
+
+		data = VIDTCON1_HBPD(var->left_margin - 1) |
+		       VIDTCON1_HFPD(var->right_margin - 1) |
+		       VIDTCON1_HSPW(var->hsync_len - 1);
+
+		writel(data, regs + VIDTCON1);
+
+		data = VIDTCON2_LINEVAL(var->yres - 1) |
+		       VIDTCON2_HOZVAL(var->xres - 1);
+		writel(data, regs + VIDTCON2);
+	}
+
+	/* write the buffer address */
+
+	writel(info->fix.smem_start, regs + VIDW_BUF_START(win_no));
+
+	data = info->fix.smem_start + info->fix.line_length * var->yres;
+	writel(data, regs + VIDW_BUF_END(win_no));
+
+	pagewidth = (var->xres * var->bits_per_pixel) >> 3;
+	data = VIDW_BUF_SIZE_OFFSET(info->fix.line_length - pagewidth) |
+	       VIDW_BUF_SIZE_PAGEWIDTH(pagewidth);
+	writel(data, regs + VIDW_BUF_SIZE(win_no));
+
+	/* write 'OSD' registers to control position of framebuffer */
+
+	data = VIDOSDxA_TOPLEFT_X(0) | VIDOSDxA_TOPLEFT_Y(0);
+	writel(data, regs + VIDOSD_A(win_no));
+
+	data = VIDOSDxB_BOTRIGHT_X(s3c_fb_align_word(var->bits_per_pixel,
+						     var->xres - 1)) |
+	       VIDOSDxB_BOTRIGHT_Y(var->yres - 1);
+
+	writel(data, regs + VIDOSD_B(win_no));
+
+	data = var->xres * var->yres;
+	if (s3c_fb_has_osd_d(win_no)) {
+		writel(data, regs + VIDOSD_D(win_no));
+		writel(0, regs + VIDOSD_C(win_no));
+	} else
+		writel(data, regs + VIDOSD_C(win_no));
+
+	data = WINCONx_ENWIN;
+
+	/* note, since we have to round up the bits-per-pixel, we end up
+	 * relying on the bitfield information for r/g/b/a to work out
+	 * exactly which mode of operation is intended. */
+
+	switch (var->bits_per_pixel) {
+	case 1:
+		data |= WINCON0_BPPMODE_1BPP;
+		data |= WINCONx_BITSWP;
+		data |= WINCONx_BURSTLEN_4WORD;
+		break;
+	case 2:
+		data |= WINCON0_BPPMODE_2BPP;
+		data |= WINCONx_BITSWP;
+		data |= WINCONx_BURSTLEN_8WORD;
+		break;
+	case 4:
+		data |= WINCON0_BPPMODE_4BPP;
+		data |= WINCONx_BITSWP;
+		data |= WINCONx_BURSTLEN_8WORD;
+		break;
+	case 8:
+		if (var->transp.length != 0)
+			data |= WINCON1_BPPMODE_8BPP_1232;
+		else
+			data |= WINCON0_BPPMODE_8BPP_PALETTE;
+		data |= WINCONx_BURSTLEN_8WORD;
+		data |= WINCONx_BYTSWP;
+		break;
+	case 16:
+		if (var->transp.length != 0)
+			data |= WINCON1_BPPMODE_16BPP_A1555;
+		else
+			data |= WINCON0_BPPMODE_16BPP_565;
+		data |= WINCONx_HAWSWP;
+		data |= WINCONx_BURSTLEN_16WORD;
+		break;
+	case 24:
+	case 32:
+		if (var->red.length == 6) {
+			if (var->transp.length != 0)
+				data |= WINCON1_BPPMODE_19BPP_A1666;
+			else
+				data |= WINCON1_BPPMODE_18BPP_666;
+		} else if (var->transp.length != 0)
+			data |= WINCON1_BPPMODE_25BPP_A1888;
+		else
+			data |= WINCON0_BPPMODE_24BPP_888;
+
+		data |= WINCONx_BURSTLEN_16WORD;
+		break;
+	}
+
+	writel(data, regs + WINCON(win_no));
+	writel(0x0, regs + WINxMAP(win_no));
+
+	return 0;
+}
+
+/**
+ * s3c_fb_update_palette() - set or schedule a palette update.
+ * @sfb: The hardware information.
+ * @win: The window being updated.
+ * @reg: The palette index being changed.
+ * @value: The computed palette value.
+ *
+ * Change the value of a palette register, either by directly writing to
+ * the palette (this requires the palette RAM to be disconnected from the
+ * hardware whilst this is in progress) or schedule the update for later.
+ *
+ * At the moment, since we have no VSYNC interrupt support, we simply set
+ * the palette entry directly.
+ */
+static void s3c_fb_update_palette(struct s3c_fb *sfb,
+				  struct s3c_fb_win *win,
+				  unsigned int reg,
+				  u32 value)
+{
+	void __iomem *palreg;
+	u32 palcon;
+
+	palreg = sfb->regs + s3c_fb_pal_reg(win->index, reg);
+
+	dev_dbg(sfb->dev, "%s: win %d, reg %d (%p): %08x\n",
+		__func__, win->index, reg, palreg, value);
+
+	win->palette_buffer[reg] = value;
+
+	palcon = readl(sfb->regs + WPALCON);
+	writel(palcon | WPALCON_PAL_UPDATE, sfb->regs + WPALCON);
+
+	if (s3c_fb_pal_is16(win->index))
+		writew(value, palreg);
+	else
+		writel(value, palreg);
+
+	writel(palcon, sfb->regs + WPALCON);
+}
+
+static inline unsigned int chan_to_field(unsigned int chan,
+					 struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+/**
+ * s3c_fb_setcolreg() - framebuffer layer request to change palette.
+ * @regno: The palette index to change.
+ * @red: The red field for the palette data.
+ * @green: The green field for the palette data.
+ * @blue: The blue field for the palette data.
+ * @trans: The transparency (alpha) field for the palette data.
+ * @info: The framebuffer being changed.
+ */
+static int s3c_fb_setcolreg(unsigned regno,
+			    unsigned red, unsigned green, unsigned blue,
+			    unsigned transp, struct fb_info *info)
+{
+	struct s3c_fb_win *win = info->par;
+	struct s3c_fb *sfb = win->parent;
+	unsigned int val;
+
+	dev_dbg(sfb->dev, "%s: win %d: %d => rgb=%d/%d/%d\n",
+		__func__, win->index, regno, red, green, blue);
+
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/* true-colour, use pseudo-palette */
+
+		if (regno < 16) {
+			u32 *pal = info->pseudo_palette;
+
+			val  = chan_to_field(red,   &info->var.red);
+			val |= chan_to_field(green, &info->var.green);
+			val |= chan_to_field(blue,  &info->var.blue);
+
+			pal[regno] = val;
+		}
+		break;
+
+	case FB_VISUAL_PSEUDOCOLOR:
+		if (regno < s3c_fb_win_pal_size(win->index)) {
+			val  = chan_to_field(red, &win->palette.r);
+			val |= chan_to_field(green, &win->palette.g);
+			val |= chan_to_field(blue, &win->palette.b);
+
+			s3c_fb_update_palette(sfb, win, regno, val);
+		}
+
+		break;
+
+	default:
+		return 1;	/* unknown type */
+	}
+
+	return 0;
+}
+
+/**
+ * s3c_fb_enable() - Set the state of the main LCD output
+ * @sfb: The main framebuffer state.
+ * @enable: The state to set.
+ */
+static void s3c_fb_enable(struct s3c_fb *sfb, int enable)
+{
+	u32 vidcon0 = readl(sfb->regs + VIDCON0);
+
+	if (enable)
+		vidcon0 |= VIDCON0_ENVID | VIDCON0_ENVID_F;
+	else {
+		/* see the note in the framebuffer datasheet about
+		 * why you cannot take both of these bits down at the
+		 * same time. */
+
+		if (!(vidcon0 & VIDCON0_ENVID))
+			return;
+
+		vidcon0 |= VIDCON0_ENVID;
+		vidcon0 &= ~VIDCON0_ENVID_F;
+	}
+
+	writel(vidcon0, sfb->regs + VIDCON0);
+}
+
+/**
+ * s3c_fb_blank() - blank or unblank the given window
+ * @blank_mode: The blank state from FB_BLANK_*
+ * @info: The framebuffer to blank.
+ *
+ * Framebuffer layer request to change the power state.
+ */
+static int s3c_fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct s3c_fb_win *win = info->par;
+	struct s3c_fb *sfb = win->parent;
+	unsigned int index = win->index;
+	u32 wincon;
+
+	dev_dbg(sfb->dev, "blank mode %d\n", blank_mode);
+
+	wincon = readl(sfb->regs + WINCON(index));
+
+	switch (blank_mode) {
+	case FB_BLANK_POWERDOWN:
+		wincon &= ~WINCONx_ENWIN;
+		sfb->enabled &= ~(1 << index);
+		/* fall through to FB_BLANK_NORMAL */
+
+	case FB_BLANK_NORMAL:
+		/* disable the DMA and display 0x0 (black) */
+		writel(WINxMAP_MAP | WINxMAP_MAP_COLOUR(0x0),
+		       sfb->regs + WINxMAP(index));
+		break;
+
+	case FB_BLANK_UNBLANK:
+		writel(0x0, sfb->regs + WINxMAP(index));
+		wincon |= WINCONx_ENWIN;
+		sfb->enabled |= (1 << index);
+		break;
+
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	default:
+		return 1;
+	}
+
+	writel(wincon, sfb->regs + WINCON(index));
+
+	/* Check the enabled state to see if we need to be running the
+	 * main LCD interface, as if there are no active windows then
+	 * it is highly likely that we also do not need to output
+	 * anything.
+	 */
+
+	/* We could do something like the following code, but the current
+	 * system of using framebuffer events means that we cannot make
+	 * the distinction between just window 0 being inactive and all
+	 * the windows being down.
+	 *
+	 * s3c_fb_enable(sfb, sfb->enabled ? 1 : 0);
+	*/
+
+	/* we're stuck with this until we can do something about overriding
+	 * the power control using the blanking event for a single fb.
+	 */
+	if (index == 0)
+		s3c_fb_enable(sfb, blank_mode != FB_BLANK_POWERDOWN ? 1 : 0);
+
+	return 0;
+}
+
+static struct fb_ops s3c_fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= s3c_fb_check_var,
+	.fb_set_par	= s3c_fb_set_par,
+	.fb_blank	= s3c_fb_blank,
+	.fb_setcolreg	= s3c_fb_setcolreg,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+};
+
+/**
+ * s3c_fb_alloc_memory() - allocate display memory for framebuffer window
+ * @sfb: The base resources for the hardware.
+ * @win: The window to initialise memory for.
+ *
+ * Allocate memory for the given framebuffer.
+ */
+static int __devinit s3c_fb_alloc_memory(struct s3c_fb *sfb,
+					 struct s3c_fb_win *win)
+{
+	struct s3c_fb_pd_win *windata = win->windata;
+	unsigned int real_size, virt_size, size;
+	struct fb_info *fbi = win->fbinfo;
+	dma_addr_t map_dma;
+
+	dev_dbg(sfb->dev, "allocating memory for display\n");
+
+	real_size = windata->win_mode.xres * windata->win_mode.yres;
+	virt_size = windata->virtual_x * windata->virtual_y;
+
+	dev_dbg(sfb->dev, "real_size=%u (%u.%u), virt_size=%u (%u.%u)\n",
+		real_size, windata->win_mode.xres, windata->win_mode.yres,
+		virt_size, windata->virtual_x, windata->virtual_y);
+
+	size = (real_size > virt_size) ? real_size : virt_size;
+	size *= (windata->max_bpp > 16) ? 32 : windata->max_bpp;
+	size /= 8;
+
+	fbi->fix.smem_len = size;
+	size = PAGE_ALIGN(size);
+
+	dev_dbg(sfb->dev, "want %u bytes for window\n", size);
+
+	fbi->screen_base = dma_alloc_writecombine(sfb->dev, size,
+						  &map_dma, GFP_KERNEL);
+	if (!fbi->screen_base)
+		return -ENOMEM;
+
+	dev_dbg(sfb->dev, "mapped %x to %p\n",
+		(unsigned int)map_dma, fbi->screen_base);
+
+	memset(fbi->screen_base, 0x0, size);
+	fbi->fix.smem_start = map_dma;
+
+	return 0;
+}
+
+/**
+ * s3c_fb_free_memory() - free the display memory for the given window
+ * @sfb: The base resources for the hardware.
+ * @win: The window to free the display memory for.
+ *
+ * Free the display memory allocated by s3c_fb_alloc_memory().
+ */
+static void s3c_fb_free_memory(struct s3c_fb *sfb, struct s3c_fb_win *win)
+{
+	struct fb_info *fbi = win->fbinfo;
+
+	dma_free_writecombine(sfb->dev, PAGE_ALIGN(fbi->fix.smem_len),
+			      fbi->screen_base, fbi->fix.smem_start);
+}
+
+/**
+ * s3c_fb_release_win() - release resources for a framebuffer window.
+ * @win: The window to cleanup the resources for.
+ *
+ * Release the resources that where claimed for the hardware window,
+ * such as the framebuffer instance and any memory claimed for it.
+ */
+static void s3c_fb_release_win(struct s3c_fb *sfb, struct s3c_fb_win *win)
+{
+	fb_dealloc_cmap(&win->fbinfo->cmap);
+	unregister_framebuffer(win->fbinfo);
+	s3c_fb_free_memory(sfb, win);
+}
+
+/**
+ * s3c_fb_probe_win() - register an hardware window
+ * @sfb: The base resources for the hardware
+ * @res: Pointer to where to place the resultant window.
+ *
+ * Allocate and do the basic initialisation for one of the hardware's graphics
+ * windows.
+ */
+static int __devinit s3c_fb_probe_win(struct s3c_fb *sfb, unsigned int win_no,
+				      struct s3c_fb_win **res)
+{
+	struct fb_var_screeninfo *var;
+	struct fb_videomode *initmode;
+	struct s3c_fb_pd_win *windata;
+	struct s3c_fb_win *win;
+	struct fb_info *fbinfo;
+	int palette_size;
+	int ret;
+
+	dev_dbg(sfb->dev, "probing window %d\n", win_no);
+
+	palette_size = s3c_fb_win_pal_size(win_no);
+
+	fbinfo = framebuffer_alloc(sizeof(struct s3c_fb_win) +
+				   palette_size * sizeof(u32), sfb->dev);
+	if (!fbinfo) {
+		dev_err(sfb->dev, "failed to allocate framebuffer\n");
+		return -ENOENT;
+	}
+
+	windata = sfb->pdata->win[win_no];
+	initmode = &windata->win_mode;
+
+	WARN_ON(windata->max_bpp == 0);
+	WARN_ON(windata->win_mode.xres == 0);
+	WARN_ON(windata->win_mode.yres == 0);
+
+	win = fbinfo->par;
+	var = &fbinfo->var;
+	win->fbinfo = fbinfo;
+	win->parent = sfb;
+	win->windata = windata;
+	win->index = win_no;
+	win->palette_buffer = (u32 *)(win + 1);
+
+	ret = s3c_fb_alloc_memory(sfb, win);
+	if (ret) {
+		dev_err(sfb->dev, "failed to allocate display memory\n");
+		goto err_framebuffer;
+	}
+
+	/* setup the r/b/g positions for the window's palette */
+	s3c_fb_init_palette(win_no, &win->palette);
+
+	/* setup the initial video mode from the window */
+	fb_videomode_to_var(&fbinfo->var, initmode);
+
+	fbinfo->fix.type	= FB_TYPE_PACKED_PIXELS;
+	fbinfo->fix.accel	= FB_ACCEL_NONE;
+	fbinfo->var.activate	= FB_ACTIVATE_NOW;
+	fbinfo->var.vmode	= FB_VMODE_NONINTERLACED;
+	fbinfo->var.bits_per_pixel = windata->default_bpp;
+	fbinfo->fbops		= &s3c_fb_ops;
+	fbinfo->flags		= FBINFO_FLAG_DEFAULT;
+	fbinfo->pseudo_palette  = &win->pseudo_palette;
+
+	/* prepare to actually start the framebuffer */
+
+	ret = s3c_fb_check_var(&fbinfo->var, fbinfo);
+	if (ret < 0) {
+		dev_err(sfb->dev, "check_var failed on initial video params\n");
+		goto err_alloc_mem;
+	}
+
+	/* create initial colour map */
+
+	ret = fb_alloc_cmap(&fbinfo->cmap, s3c_fb_win_pal_size(win_no), 1);
+	if (ret == 0)
+		fb_set_cmap(&fbinfo->cmap, fbinfo);
+	else
+		dev_err(sfb->dev, "failed to allocate fb cmap\n");
+
+	s3c_fb_set_par(fbinfo);
+
+	dev_dbg(sfb->dev, "about to register framebuffer\n");
+
+	/* run the check_var and set_par on our configuration. */
+
+	ret = register_framebuffer(fbinfo);
+	if (ret < 0) {
+		dev_err(sfb->dev, "failed to register framebuffer\n");
+		goto err_alloc_mem;
+	}
+
+	*res = win;
+	dev_info(sfb->dev, "window %d: fb %s\n", win_no, fbinfo->fix.id);
+
+	return 0;
+
+err_alloc_mem:
+	s3c_fb_free_memory(sfb, win);
+
+err_framebuffer:
+	unregister_framebuffer(fbinfo);
+	return ret;
+}
+
+/**
+ * s3c_fb_clear_win() - clear hardware window registers.
+ * @sfb: The base resources for the hardware.
+ * @win: The window to process.
+ *
+ * Reset the specific window registers to a known state.
+ */
+static void s3c_fb_clear_win(struct s3c_fb *sfb, int win)
+{
+	void __iomem *regs = sfb->regs;
+
+	writel(0, regs + WINCON(win));
+	writel(0xffffff, regs + WxKEYCONy(win, 0));
+	writel(0xffffff, regs + WxKEYCONy(win, 1));
+
+	writel(0, regs + VIDOSD_A(win));
+	writel(0, regs + VIDOSD_B(win));
+	writel(0, regs + VIDOSD_C(win));
+}
+
+static int __devinit s3c_fb_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct s3c_fb_platdata *pd;
+	struct s3c_fb *sfb;
+	struct resource *res;
+	int win;
+	int ret = 0;
+
+	pd = pdev->dev.platform_data;
+	if (!pd) {
+		dev_err(dev, "no platform data specified\n");
+		return -EINVAL;
+	}
+
+	sfb = kzalloc(sizeof(struct s3c_fb), GFP_KERNEL);
+	if (!sfb) {
+		dev_err(dev, "no memory for framebuffers\n");
+		return -ENOMEM;
+	}
+
+	sfb->dev = dev;
+	sfb->pdata = pd;
+
+	sfb->bus_clk = clk_get(dev, "lcd");
+	if (IS_ERR(sfb->bus_clk)) {
+		dev_err(dev, "failed to get bus clock\n");
+		goto err_sfb;
+	}
+
+	clk_enable(sfb->bus_clk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to find registers\n");
+		ret = -ENOENT;
+		goto err_clk;
+	}
+
+	sfb->regs_res = request_mem_region(res->start, resource_size(res),
+					   dev_name(dev));
+	if (!sfb->regs_res) {
+		dev_err(dev, "failed to claim register region\n");
+		ret = -ENOENT;
+		goto err_clk;
+	}
+
+	sfb->regs = ioremap(res->start, resource_size(res));
+	if (!sfb->regs) {
+		dev_err(dev, "failed to map registers\n");
+		ret = -ENXIO;
+		goto err_req_region;
+	}
+
+	dev_dbg(dev, "got resources (regs %p), probing windows\n", sfb->regs);
+
+	/* setup gpio and output polarity controls */
+
+	pd->setup_gpio();
+
+	writel(pd->vidcon1, sfb->regs + VIDCON1);
+
+	/* zero all windows before we do anything */
+
+	for (win = 0; win < S3C_FB_MAX_WIN; win++)
+		s3c_fb_clear_win(sfb, win);
+
+	/* we have the register setup, start allocating framebuffers */
+
+	for (win = 0; win < S3C_FB_MAX_WIN; win++) {
+		if (!pd->win[win])
+			continue;
+
+		ret = s3c_fb_probe_win(sfb, win, &sfb->windows[win]);
+		if (ret < 0) {
+			dev_err(dev, "failed to create window %d\n", win);
+			for (; win >= 0; win--)
+				s3c_fb_release_win(sfb, sfb->windows[win]);
+			goto err_ioremap;
+		}
+	}
+
+	platform_set_drvdata(pdev, sfb);
+
+	return 0;
+
+err_ioremap:
+	iounmap(sfb->regs);
+
+err_req_region:
+	release_resource(sfb->regs_res);
+	kfree(sfb->regs_res);
+
+err_clk:
+	clk_disable(sfb->bus_clk);
+	clk_put(sfb->bus_clk);
+
+err_sfb:
+	kfree(sfb);
+	return ret;
+}
+
+/**
+ * s3c_fb_remove() - Cleanup on module finalisation
+ * @pdev: The platform device we are bound to.
+ *
+ * Shutdown and then release all the resources that the driver allocated
+ * on initialisation.
+ */
+static int __devexit s3c_fb_remove(struct platform_device *pdev)
+{
+	struct s3c_fb *sfb = platform_get_drvdata(pdev);
+	int win;
+
+	for (win = 0; win <= S3C_FB_MAX_WIN; win++)
+		s3c_fb_release_win(sfb, sfb->windows[win]);
+
+	iounmap(sfb->regs);
+
+	clk_disable(sfb->bus_clk);
+	clk_put(sfb->bus_clk);
+
+	release_resource(sfb->regs_res);
+	kfree(sfb->regs_res);
+
+	kfree(sfb);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int s3c_fb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct s3c_fb *sfb = platform_get_drvdata(pdev);
+	struct s3c_fb_win *win;
+	int win_no;
+
+	for (win_no = S3C_FB_MAX_WIN; win_no >= 0; win_no--) {
+		win = sfb->windows[win_no];
+		if (!win)
+			continue;
+
+		/* use the blank function to push into power-down */
+		s3c_fb_blank(FB_BLANK_POWERDOWN, win->fbinfo);
+	}
+
+	clk_disable(sfb->bus_clk);
+	return 0;
+}
+
+static int s3c_fb_resume(struct platform_device *pdev)
+{
+	struct s3c_fb *sfb = platform_get_drvdata(pdev);
+	struct s3c_fb_win *win;
+	int win_no;
+
+	clk_enable(sfb->bus_clk);
+
+	for (win_no = 0; win_no < S3C_FB_MAX_WIN; win_no++) {
+		win = sfb->windows[win_no];
+		if (!win)
+			continue;
+
+		dev_dbg(&pdev->dev, "resuming window %d\n", win_no);
+		s3c_fb_set_par(win->fbinfo);
+	}
+
+	return 0;
+}
+#else
+#define s3c_fb_suspend NULL
+#define s3c_fb_resume  NULL
+#endif
+
+static struct platform_driver s3c_fb_driver = {
+	.probe		= s3c_fb_probe,
+	.remove		= s3c_fb_remove,
+	.suspend	= s3c_fb_suspend,
+	.resume		= s3c_fb_resume,
+	.driver		= {
+		.name	= "s3c-fb",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init s3c_fb_init(void)
+{
+	return platform_driver_register(&s3c_fb_driver);
+}
+
+static void __exit s3c_fb_cleanup(void)
+{
+	platform_driver_unregister(&s3c_fb_driver);
+}
+
+module_init(s3c_fb_init);
+module_exit(s3c_fb_cleanup);
+
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("Samsung S3C SoC Framebuffer driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:s3c-fb");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/watchdog/Kconfig linux-2.6.29-rc3.owrt.om/drivers/watchdog/Kconfig
--- linux-2.6.29-rc3.owrt/drivers/watchdog/Kconfig	2009-05-10 22:08:45.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/watchdog/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -154,6 +154,13 @@
 	  The driver can be built as a module by choosing M, and will
 	  be called s3c2410_wdt
 
+config PCF50606_WATCHDOG
+	depends on MFD_PCF50606
+	tristate "Philips PCF50606 watchdog"
+	help
+	  If you say yes here you get support for the Philips PCF50606
+	  PMU's watchdog.
+
 config SA1100_WATCHDOG
 	tristate "SA1100/PXA2xx watchdog"
 	depends on ARCH_SA1100 || ARCH_PXA
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/watchdog/Makefile linux-2.6.29-rc3.owrt.om/drivers/watchdog/Makefile
--- linux-2.6.29-rc3.owrt/drivers/watchdog/Makefile	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/drivers/watchdog/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -34,6 +34,7 @@
 obj-$(CONFIG_IXP4XX_WATCHDOG) += ixp4xx_wdt.o
 obj-$(CONFIG_KS8695_WATCHDOG) += ks8695_wdt.o
 obj-$(CONFIG_S3C2410_WATCHDOG) += s3c2410_wdt.o
+obj-$(CONFIG_PCF50606_WATCHDOG) += pcf50606_wdt.o
 obj-$(CONFIG_SA1100_WATCHDOG) += sa1100_wdt.o
 obj-$(CONFIG_MPCORE_WATCHDOG) += mpcore_wdt.o
 obj-$(CONFIG_EP93XX_WATCHDOG) += ep93xx_wdt.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/drivers/watchdog/pcf50606_wdt.c linux-2.6.29-rc3.owrt.om/drivers/watchdog/pcf50606_wdt.c
--- linux-2.6.29-rc3.owrt/drivers/watchdog/pcf50606_wdt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/drivers/watchdog/pcf50606_wdt.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,223 @@
+/* Philips PCF50606 Watchdog Timer Driver
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * Author: Balaji Rao <balajirrao@openmoko.org>
+ * All rights reserved.
+ *
+ * Broken down from monstrous PCF50606 driver mainly by
+ * Harald Welte, Matt Hsu, Andy Green and Werner Almesberger
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/rtc.h>
+#include <linux/bcd.h>
+#include <linux/err.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/platform_device.h>
+
+#include <linux/mfd/pcf50606/core.h>
+
+static struct pcf50606 *pcf = NULL;
+static unsigned long wdt_status;
+
+#define WDT_IN_USE        0
+#define WDT_OK_TO_CLOSE   1
+#define WDT_REGION_INITED 2
+#define WDT_DEVICE_INITED 3
+
+static int allow_close;
+#define CLOSE_STATE_NOT		0x0000
+#define CLOSE_STATE_ALLOW	0x2342
+
+#define PCF50606_REG_OOCC1 	0x08
+#define PCF50606_REG_OOCS 	0x01
+
+#define PCF50606_OOCS_WDTEXP 	0x80
+#define PCF50606_OOCC1_WDTRST 	0x08
+
+static void pcf50606_wdt_start(void)
+{
+	pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_OOCC1, PCF50606_OOCC1_WDTRST,
+			 PCF50606_OOCC1_WDTRST);
+}
+
+static void pcf50606_wdt_stop(void)
+{
+	pcf50606_reg_clear_bits(pcf, PCF50606_REG_OOCS, PCF50606_OOCS_WDTEXP);
+}
+
+static void pcf50606_wdt_keepalive(void)
+{
+	pcf50606_wdt_start();
+}
+
+static int pcf50606_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(WDT_IN_USE, &wdt_status))
+		return -EBUSY;
+
+	pcf50606_wdt_start();
+
+	return nonseekable_open(inode, file);
+}
+
+static int pcf50606_wdt_release(struct inode *inode, struct file *file)
+{
+	if (allow_close == CLOSE_STATE_ALLOW)
+		pcf50606_wdt_stop();
+	else {
+		printk(KERN_CRIT "Unexpected close, not stopping watchdog!\n");
+		pcf50606_wdt_keepalive();
+	}
+
+	allow_close = CLOSE_STATE_NOT;
+	clear_bit(WDT_IN_USE, &wdt_status);
+
+	return 0;
+}
+
+static ssize_t pcf50606_wdt_write(struct file *file, const char __user *data,
+				  size_t len, loff_t *ppos)
+{
+	if (len) {
+		size_t i;
+
+		for (i = 0; i != len; i++) {
+			char c;
+			if (get_user(c, data + i))
+				return -EFAULT;
+			if (c == 'V')
+				allow_close = CLOSE_STATE_ALLOW;
+		}
+		pcf50606_wdt_keepalive();
+	}
+
+	return len;
+}
+
+static struct watchdog_info pcf50606_wdt_ident = {
+	.options	= WDIOF_MAGICCLOSE,
+	.firmware_version = 0,
+	.identity	= "PCF50606 Watchdog",
+};
+
+static int pcf50606_wdt_ioctl(struct inode *inode, struct file *file,
+			      unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &pcf50606_wdt_ident,
+				    sizeof(pcf50606_wdt_ident)) ? -EFAULT : 0;
+		break;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+	case WDIOC_KEEPALIVE:
+		pcf50606_wdt_keepalive();
+		return 0;
+	case WDIOC_GETTIMEOUT:
+		return put_user(8, p);
+	default:
+		return -ENOIOCTLCMD;
+	}
+}
+
+static struct file_operations pcf50606_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= &pcf50606_wdt_write,
+	.ioctl		= &pcf50606_wdt_ioctl,
+	.open		= &pcf50606_wdt_open,
+	.release	= &pcf50606_wdt_release,
+};
+
+static struct miscdevice pcf50606_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &pcf50606_wdt_fops,
+};
+
+static void pcf50606_wdt_irq(int irq, void *unused)
+{
+	pcf50606_reg_set_bit_mask(pcf, PCF50606_REG_OOCC1,
+				 PCF50606_OOCC1_WDTRST,
+				 PCF50606_OOCC1_WDTRST);
+}
+
+int __init pcf50606_wdt_probe(struct platform_device *pdev)
+{
+	struct pcf50606_subdev_pdata *pdata;
+	int err;
+
+	if (pcf) {
+		dev_err(pcf->dev, "Only one instance of WDT supported\n");
+		return -ENODEV;
+	}
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "No platform data available\n");
+		return -EINVAL;
+	}
+
+	pcf = pdata->pcf;
+
+	err = misc_register(&pcf50606_wdt_miscdev);
+	if (err) {
+		dev_err(&pdev->dev, "cannot register miscdev on "
+		       "minor=%d (%d)\n", WATCHDOG_MINOR, err);
+		return err;
+	}
+	set_bit(WDT_DEVICE_INITED, &wdt_status);
+
+	pcf50606_register_irq(pcf, PCF50606_IRQ_CHGWD10S, pcf50606_wdt_irq, NULL);
+
+	return 0;
+}
+
+static int __devexit pcf50606_wdt_remove(struct platform_device *pdev)
+{
+	pcf50606_free_irq(pcf, PCF50606_IRQ_CHGWD10S);
+	misc_deregister(&pcf50606_wdt_miscdev);
+	pcf = NULL;
+
+	return 0;
+}
+
+struct platform_driver pcf50606_wdt_driver = {
+	.driver = {
+		.name = "pcf50606-wdt",
+	},
+	.probe = pcf50606_wdt_probe,
+	.remove = __devexit_p(pcf50606_wdt_remove),
+};
+
+static int __init pcf50606_wdt_init(void)
+{
+		return platform_driver_register(&pcf50606_wdt_driver);
+}
+module_init(pcf50606_wdt_init);
+
+static void __exit pcf50606_wdt_exit(void)
+{
+		platform_driver_unregister(&pcf50606_wdt_driver);
+}
+module_exit(pcf50606_wdt_exit);
+
+MODULE_AUTHOR("Balaji Rao <balajirrao@openmoko.org>");
+MODULE_DESCRIPTION("PCF50606 wdt driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pcf50606-wdt");
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/fs/jffs2/background.c linux-2.6.29-rc3.owrt.om/fs/jffs2/background.c
--- linux-2.6.29-rc3.owrt/fs/jffs2/background.c	2009-05-10 22:08:58.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/fs/jffs2/background.c	2009-05-10 22:28:00.000000000 +0200
@@ -95,13 +95,17 @@
 			spin_unlock(&c->erase_completion_lock);
 			
 
-		/* This thread is purely an optimisation. But if it runs when
-		   other things could be running, it actually makes things a
-		   lot worse. Use yield() and put it at the back of the runqueue
-		   every time. Especially during boot, pulling an inode in
-		   with read_inode() is much preferable to having the GC thread
-		   get there first. */
-		yield();
+		/* Problem - immediately after bootup, the GCD spends a lot
+		 * of time in places like jffs2_kill_fragtree(); so much so
+		 * that userspace processes (like gdm and X) are starved
+		 * despite plenty of cond_resched()s and renicing.  Yield()
+		 * doesn't help, either (presumably because userspace and GCD
+		 * are generally competing for a higher latency resource -
+		 * disk).
+		 * This forces the GCD to slow the hell down.   Pulling an
+		 * inode in with read_inode() is much preferable to having
+		 * the GC thread get there first. */
+		schedule_timeout_interruptible(msecs_to_jiffies(50));
 
 		/* Put_super will send a SIGKILL and then wait on the sem.
 		 */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/asm-arm/plat-s3c24xx/neo1973.h linux-2.6.29-rc3.owrt.om/include/asm-arm/plat-s3c24xx/neo1973.h
--- linux-2.6.29-rc3.owrt/include/asm-arm/plat-s3c24xx/neo1973.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/asm-arm/plat-s3c24xx/neo1973.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ * include/asm-arm/plat-s3c24xx/neo1973.h
+ *
+ * Common utility code for GTA01 and GTA02
+ *
+ * Copyright (C) 2008 by Openmoko, Inc.
+ * Author: Holger Hans Peter Freyther <freyther@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef NEO1973_H
+#define NEO1973_H
+
+void neo1973_gpb_add_shadow_gpio(unsigned int gpio);
+void neo1973_gpb_setpin(unsigned int pin, unsigned to);
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/asm-arm/plat-s3c24xx/regs-iis.h linux-2.6.29-rc3.owrt.om/include/asm-arm/plat-s3c24xx/regs-iis.h
--- linux-2.6.29-rc3.owrt/include/asm-arm/plat-s3c24xx/regs-iis.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/asm-arm/plat-s3c24xx/regs-iis.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/* arch/arm/mach-s3c2410/include/mach/regs-iis.h
- *
- * Copyright (c) 2003 Simtec Electronics <linux@simtec.co.uk>
- *		      http://www.simtec.co.uk/products/SWLINUX/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * S3C2410 IIS register definition
-*/
-
-#ifndef __ASM_ARCH_REGS_IIS_H
-#define __ASM_ARCH_REGS_IIS_H
-
-#define S3C2410_IISCON	 (0x00)
-
-#define S3C2410_IISCON_LRINDEX	  (1<<8)
-#define S3C2410_IISCON_TXFIFORDY  (1<<7)
-#define S3C2410_IISCON_RXFIFORDY  (1<<6)
-#define S3C2410_IISCON_TXDMAEN	  (1<<5)
-#define S3C2410_IISCON_RXDMAEN	  (1<<4)
-#define S3C2410_IISCON_TXIDLE	  (1<<3)
-#define S3C2410_IISCON_RXIDLE	  (1<<2)
-#define S3C2410_IISCON_PSCEN	  (1<<1)
-#define S3C2410_IISCON_IISEN	  (1<<0)
-
-#define S3C2410_IISMOD	 (0x04)
-
-#define S3C2440_IISMOD_MPLL	  (1<<9)
-#define S3C2410_IISMOD_SLAVE	  (1<<8)
-#define S3C2410_IISMOD_NOXFER	  (0<<6)
-#define S3C2410_IISMOD_RXMODE	  (1<<6)
-#define S3C2410_IISMOD_TXMODE	  (2<<6)
-#define S3C2410_IISMOD_TXRXMODE	  (3<<6)
-#define S3C2410_IISMOD_LR_LLOW	  (0<<5)
-#define S3C2410_IISMOD_LR_RLOW	  (1<<5)
-#define S3C2410_IISMOD_IIS	  (0<<4)
-#define S3C2410_IISMOD_MSB	  (1<<4)
-#define S3C2410_IISMOD_8BIT	  (0<<3)
-#define S3C2410_IISMOD_16BIT	  (1<<3)
-#define S3C2410_IISMOD_BITMASK	  (1<<3)
-#define S3C2410_IISMOD_256FS	  (0<<2)
-#define S3C2410_IISMOD_384FS	  (1<<2)
-#define S3C2410_IISMOD_16FS	  (0<<0)
-#define S3C2410_IISMOD_32FS	  (1<<0)
-#define S3C2410_IISMOD_48FS	  (2<<0)
-#define S3C2410_IISMOD_FS_MASK	  (3<<0)
-
-#define S3C2410_IISPSR		(0x08)
-#define S3C2410_IISPSR_INTMASK	(31<<5)
-#define S3C2410_IISPSR_INTSHIFT	(5)
-#define S3C2410_IISPSR_EXTMASK	(31<<0)
-#define S3C2410_IISPSR_EXTSHFIT	(0)
-
-#define S3C2410_IISFCON  (0x0c)
-
-#define S3C2410_IISFCON_TXDMA	  (1<<15)
-#define S3C2410_IISFCON_RXDMA	  (1<<14)
-#define S3C2410_IISFCON_TXENABLE  (1<<13)
-#define S3C2410_IISFCON_RXENABLE  (1<<12)
-#define S3C2410_IISFCON_TXMASK	  (0x3f << 6)
-#define S3C2410_IISFCON_TXSHIFT	  (6)
-#define S3C2410_IISFCON_RXMASK	  (0x3f)
-#define S3C2410_IISFCON_RXSHIFT	  (0)
-
-#define S3C2400_IISFCON_TXDMA     (1<<11)
-#define S3C2400_IISFCON_RXDMA     (1<<10)
-#define S3C2400_IISFCON_TXENABLE  (1<<9)
-#define S3C2400_IISFCON_RXENABLE  (1<<8)
-#define S3C2400_IISFCON_TXMASK	  (0x07 << 4)
-#define S3C2400_IISFCON_TXSHIFT	  (4)
-#define S3C2400_IISFCON_RXMASK	  (0x07)
-#define S3C2400_IISFCON_RXSHIFT	  (0)
-
-#define S3C2410_IISFIFO  (0x10)
-#endif /* __ASM_ARCH_REGS_IIS_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/asm-arm/plat-s3c24xx/regs-s3c2412-iis.h linux-2.6.29-rc3.owrt.om/include/asm-arm/plat-s3c24xx/regs-s3c2412-iis.h
--- linux-2.6.29-rc3.owrt/include/asm-arm/plat-s3c24xx/regs-s3c2412-iis.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/asm-arm/plat-s3c24xx/regs-s3c2412-iis.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,72 +0,0 @@
-/* linux/include/asm-arm/plat-s3c24xx/regs-s3c2412-iis.h
- *
- * Copyright 2007 Simtec Electronics <linux@simtec.co.uk>
- *	http://armlinux.simtec.co.uk/
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * S3C2412 IIS register definition
-*/
-
-#ifndef __ASM_ARCH_REGS_S3C2412_IIS_H
-#define __ASM_ARCH_REGS_S3C2412_IIS_H
-
-#define S3C2412_IISCON			(0x00)
-#define S3C2412_IISMOD			(0x04)
-#define S3C2412_IISFIC			(0x08)
-#define S3C2412_IISPSR			(0x0C)
-#define S3C2412_IISTXD			(0x10)
-#define S3C2412_IISRXD			(0x14)
-
-#define S3C2412_IISCON_LRINDEX		(1 << 11)
-#define S3C2412_IISCON_TXFIFO_EMPTY	(1 << 10)
-#define S3C2412_IISCON_RXFIFO_EMPTY	(1 << 9)
-#define S3C2412_IISCON_TXFIFO_FULL	(1 << 8)
-#define S3C2412_IISCON_RXFIFO_FULL	(1 << 7)
-#define S3C2412_IISCON_TXDMA_PAUSE	(1 << 6)
-#define S3C2412_IISCON_RXDMA_PAUSE	(1 << 5)
-#define S3C2412_IISCON_TXCH_PAUSE	(1 << 4)
-#define S3C2412_IISCON_RXCH_PAUSE	(1 << 3)
-#define S3C2412_IISCON_TXDMA_ACTIVE	(1 << 2)
-#define S3C2412_IISCON_RXDMA_ACTIVE	(1 << 1)
-#define S3C2412_IISCON_IIS_ACTIVE	(1 << 0)
-
-#define S3C2412_IISMOD_MASTER_INTERNAL	(0 << 10)
-#define S3C2412_IISMOD_MASTER_EXTERNAL	(1 << 10)
-#define S3C2412_IISMOD_SLAVE		(2 << 10)
-#define S3C2412_IISMOD_MASTER_MASK	(3 << 10)
-#define S3C2412_IISMOD_MODE_TXONLY	(0 << 8)
-#define S3C2412_IISMOD_MODE_RXONLY	(1 << 8)
-#define S3C2412_IISMOD_MODE_TXRX	(2 << 8)
-#define S3C2412_IISMOD_MODE_MASK	(3 << 8)
-#define S3C2412_IISMOD_LR_LLOW		(0 << 7)
-#define S3C2412_IISMOD_LR_RLOW		(1 << 7)
-#define S3C2412_IISMOD_SDF_IIS		(0 << 5)
-#define S3C2412_IISMOD_SDF_MSB		(0 << 5)
-#define S3C2412_IISMOD_SDF_LSB		(0 << 5)
-#define S3C2412_IISMOD_SDF_MASK		(3 << 5)
-#define S3C2412_IISMOD_RCLK_256FS	(0 << 3)
-#define S3C2412_IISMOD_RCLK_512FS	(1 << 3)
-#define S3C2412_IISMOD_RCLK_384FS	(2 << 3)
-#define S3C2412_IISMOD_RCLK_768FS	(3 << 3)
-#define S3C2412_IISMOD_RCLK_MASK 	(3 << 3)
-#define S3C2412_IISMOD_BCLK_32FS	(0 << 1)
-#define S3C2412_IISMOD_BCLK_48FS	(1 << 1)
-#define S3C2412_IISMOD_BCLK_16FS	(2 << 1)
-#define S3C2412_IISMOD_BCLK_24FS	(3 << 1)
-#define S3C2412_IISMOD_BCLK_MASK	(3 << 1)
-#define S3C2412_IISMOD_8BIT		(1 << 0)
-
-#define S3C2412_IISPSR_PSREN		(1 << 15)
-
-#define S3C2412_IISFIC_TXFLUSH		(1 << 15)
-#define S3C2412_IISFIC_RXFLUSH		(1 << 7)
-#define S3C2412_IISFIC_TXCOUNT(x)	(((x) >>  8) & 0xf)
-#define S3C2412_IISFIC_RXCOUNT(x)	(((x) >>  0) & 0xf)
-
-
-
-#endif /* __ASM_ARCH_REGS_S3C2412_IIS_H */
-
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/android_aid.h linux-2.6.29-rc3.owrt.om/include/linux/android_aid.h
--- linux-2.6.29-rc3.owrt/include/linux/android_aid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/android_aid.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,25 @@
+/* include/linux/android_aid.h
+ *
+ * Copyright (C) 2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_AID_H
+#define _LINUX_ANDROID_AID_H
+
+/* AIDs that the kernel treats differently */
+#define AID_NET_BT_ADMIN 3001
+#define AID_NET_BT       3002
+#define AID_INET         3003
+#define AID_NET_RAW      3004
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/android_alarm.h linux-2.6.29-rc3.owrt.om/include/linux/android_alarm.h
--- linux-2.6.29-rc3.owrt/include/linux/android_alarm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/android_alarm.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,62 @@
+/* include/linux/android_alarm.h
+ *
+ * Copyright (C) 2006-2007 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_ANDROID_ALARM_H
+#define _LINUX_ANDROID_ALARM_H
+
+#include <linux/ioctl.h>
+#include <linux/time.h>
+
+enum android_alarm_type {
+	/* return code bit numbers or set alarm arg */
+	ANDROID_ALARM_RTC_WAKEUP,
+	ANDROID_ALARM_RTC,
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+	ANDROID_ALARM_ELAPSED_REALTIME,
+	ANDROID_ALARM_SYSTEMTIME,
+
+	ANDROID_ALARM_TYPE_COUNT,
+
+	/* return code bit numbers */
+	/* ANDROID_ALARM_TIME_CHANGE = 16 */
+};
+
+enum android_alarm_return_flags {
+	ANDROID_ALARM_RTC_WAKEUP_MASK = 1U << ANDROID_ALARM_RTC_WAKEUP,
+	ANDROID_ALARM_RTC_MASK = 1U << ANDROID_ALARM_RTC,
+	ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP_MASK =
+				1U << ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP,
+	ANDROID_ALARM_ELAPSED_REALTIME_MASK =
+				1U << ANDROID_ALARM_ELAPSED_REALTIME,
+	ANDROID_ALARM_SYSTEMTIME_MASK = 1U << ANDROID_ALARM_SYSTEMTIME,
+	ANDROID_ALARM_TIME_CHANGE_MASK = 1U << 16
+};
+
+/* Disable alarm */
+#define ANDROID_ALARM_CLEAR(type)           _IO('a', 0 | ((type) << 4))
+
+/* Ack last alarm and wait for next */
+#define ANDROID_ALARM_WAIT                  _IO('a', 1)
+
+#define ALARM_IOW(c, type, size)            _IOW('a', (c) | ((type) << 4), size)
+/* Set alarm */
+#define ANDROID_ALARM_SET(type)             ALARM_IOW(2, type, struct timespec)
+#define ANDROID_ALARM_SET_AND_WAIT(type)    ALARM_IOW(3, type, struct timespec)
+#define ANDROID_ALARM_GET_TIME(type)        ALARM_IOW(4, type, struct timespec)
+#define ANDROID_ALARM_SET_RTC               _IOW('a', 5, struct timespec)
+#define ANDROID_ALARM_BASE_CMD(cmd)         (cmd & ~(_IOC(0, 0, 0xf0, 0)))
+#define ANDROID_ALARM_IOCTL_TO_TYPE(cmd)    (_IOC_NR(cmd) >> 4)
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/ashmem.h linux-2.6.29-rc3.owrt.om/include/linux/ashmem.h
--- linux-2.6.29-rc3.owrt/include/linux/ashmem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/ashmem.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+ * include/linux/ashmem.h
+ *
+ * Copyright 2008 Google Inc.
+ * Author: Robert Love
+ *
+ * This file is dual licensed.  It may be redistributed and/or modified
+ * under the terms of the Apache 2.0 License OR version 2 of the GNU
+ * General Public License.
+ */
+
+#ifndef _LINUX_ASHMEM_H
+#define _LINUX_ASHMEM_H
+
+#include <linux/limits.h>
+#include <linux/ioctl.h>
+
+#define ASHMEM_NAME_LEN		256
+
+#define ASHMEM_NAME_DEF		"dev/ashmem"
+
+/* Return values from ASHMEM_PIN: Was the mapping purged while unpinned? */
+#define ASHMEM_NOT_PURGED	0
+#define ASHMEM_WAS_PURGED	1
+
+/* Return values from ASHMEM_GET_PIN_STATUS: Is the mapping pinned? */
+#define ASHMEM_IS_UNPINNED	0
+#define ASHMEM_IS_PINNED	1
+
+struct ashmem_pin {
+	__u32 offset;	/* offset into region, in bytes, page-aligned */
+	__u32 len;	/* length forward from offset, in bytes, page-aligned */
+};
+
+#define __ASHMEMIOC		0x77
+
+#define ASHMEM_SET_NAME		_IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])
+#define ASHMEM_GET_NAME		_IOR(__ASHMEMIOC, 2, char[ASHMEM_NAME_LEN])
+#define ASHMEM_SET_SIZE		_IOW(__ASHMEMIOC, 3, size_t)
+#define ASHMEM_GET_SIZE		_IO(__ASHMEMIOC, 4)
+#define ASHMEM_SET_PROT_MASK	_IOW(__ASHMEMIOC, 5, unsigned long)
+#define ASHMEM_GET_PROT_MASK	_IO(__ASHMEMIOC, 6)
+#define ASHMEM_PIN		_IOW(__ASHMEMIOC, 7, struct ashmem_pin)
+#define ASHMEM_UNPIN		_IOW(__ASHMEMIOC, 8, struct ashmem_pin)
+#define ASHMEM_GET_PIN_STATUS	_IO(__ASHMEMIOC, 9)
+#define ASHMEM_PURGE_ALL_CACHES	_IO(__ASHMEMIOC, 10)
+
+#endif	/* _LINUX_ASHMEM_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/bq27000_battery.h linux-2.6.29-rc3.owrt.om/include/linux/bq27000_battery.h
--- linux-2.6.29-rc3.owrt/include/linux/bq27000_battery.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/bq27000_battery.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef __BQ27000_BATTERY_H__
+#define __BQ27000_BATTERY_H__
+
+void bq27000_charging_state_change(struct platform_device *pdev);
+
+struct bq27000_platform_data {
+	const char 	*name;
+	int		rsense_mohms;
+	int (*hdq_read)(int);
+	int (*hdq_write)(int, u8);
+	int (*hdq_initialized)(void);
+	int (*get_charger_online_status)(void);
+	int (*get_charger_active_status)(void);
+};
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/device.h linux-2.6.29-rc3.owrt.om/include/linux/device.h
--- linux-2.6.29-rc3.owrt/include/linux/device.h	2009-05-10 22:09:07.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/device.h	2009-05-10 22:28:00.000000000 +0200
@@ -48,6 +48,11 @@
 					struct bus_attribute *);
 extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
 
+extern int __must_check bus_create_device_link(struct bus_type *bus,
+					       struct kobject *target,
+					       const char *name);
+extern void bus_remove_device_link(struct bus_type *bus, const char *name);
+
 struct bus_type {
 	const char		*name;
 	struct bus_attribute	*bus_attrs;
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/earlysuspend.h linux-2.6.29-rc3.owrt.om/include/linux/earlysuspend.h
--- linux-2.6.29-rc3.owrt/include/linux/earlysuspend.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/earlysuspend.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,56 @@
+/* include/linux/earlysuspend.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_EARLYSUSPEND_H
+#define _LINUX_EARLYSUSPEND_H
+
+#ifdef CONFIG_ANDROID_HAS_EARLYSUSPEND
+#include <linux/list.h>
+#endif
+
+/* The early_suspend structure defines suspend and resume hooks to be called
+ * when the user visible sleep state of the system changes, and a level to
+ * control the order. They can be used to turn off the screen and input
+ * devices that are not used for wakeup.
+ * Suspend handlers are called in low to high level order, resume handlers are
+ * called in the opposite order. If, when calling register_early_suspend,
+ * the suspend handlers have already been called without a matching call to the
+ * resume handlers, the suspend handler will be called directly from
+ * register_early_suspend. This direct call can violate the normal level order.
+ */
+enum {
+	EARLY_SUSPEND_LEVEL_BLANK_SCREEN = 50,
+	EARLY_SUSPEND_LEVEL_STOP_DRAWING = 100,
+	EARLY_SUSPEND_LEVEL_DISABLE_FB = 150,
+};
+struct early_suspend {
+#ifdef CONFIG_ANDROID_HAS_EARLYSUSPEND
+	struct list_head link;
+	int level;
+	void (*suspend)(struct early_suspend *h);
+	void (*resume)(struct early_suspend *h);
+#endif
+};
+
+#ifdef CONFIG_ANDROID_HAS_EARLYSUSPEND
+void register_early_suspend(struct early_suspend *handler);
+void unregister_early_suspend(struct early_suspend *handler);
+#else
+#define register_early_suspend(handler) do { } while (0)
+#define unregister_early_suspend(handler) do { } while (0)
+#endif
+
+#endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/fb.h linux-2.6.29-rc3.owrt.om/include/linux/fb.h
--- linux-2.6.29-rc3.owrt/include/linux/fb.h	2009-05-10 22:09:07.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/fb.h	2009-05-10 22:28:00.000000000 +0200
@@ -123,6 +123,7 @@
 #define FB_ACCEL_TRIDENT_3DIMAGE 51	/* Trident 3DImage		*/
 #define FB_ACCEL_TRIDENT_BLADE3D 52	/* Trident Blade3D		*/
 #define FB_ACCEL_TRIDENT_BLADEXP 53	/* Trident BladeXP		*/
+#define FB_ACCEL_GLAMO		50	/* SMedia Glamo                 */
 #define FB_ACCEL_NEOMAGIC_NM2070 90	/* NeoMagic NM2070              */
 #define FB_ACCEL_NEOMAGIC_NM2090 91	/* NeoMagic NM2090              */
 #define FB_ACCEL_NEOMAGIC_NM2093 92	/* NeoMagic NM2093              */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/glamofb.h linux-2.6.29-rc3.owrt.om/include/linux/glamofb.h
--- linux-2.6.29-rc3.owrt/include/linux/glamofb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/glamofb.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,50 @@
+#ifndef _LINUX_GLAMOFB_H
+#define _LINUX_GLAMOFB_H
+
+#include <linux/spi/glamo.h>
+
+struct glamofb_val {
+	unsigned int defval;
+	unsigned int min;
+	unsigned int max;
+};
+
+struct glamo_core;
+
+struct glamofb_platform_data {
+	int width, height;
+	int pixclock;
+	int left_margin, right_margin;
+	int upper_margin, lower_margin;
+	int hsync_len, vsync_len;
+	int fb_mem_size;
+
+	struct glamofb_val xres;
+	struct glamofb_val yres;
+	struct glamofb_val bpp;
+
+	struct glamo_spi_info *spi_info;
+	struct glamo_spigpio_info *spigpio_info;
+	struct glamo_core *glamo;
+
+	struct platform_device *mmc_dev;
+
+	/* glamo mmc platform specific info */
+	int		(*glamo_can_set_mci_power)(void);
+	
+	/* glamo-mci asking if it should use the slow clock to card */
+	int		(*glamo_mci_use_slow)(void);
+	int		(*glamo_irq_is_wired)(void);
+	void		(*glamo_external_reset)(int);
+};
+
+int glamofb_cmd_mode(struct glamofb_handle *gfb, int on);
+int glamofb_cmd_write(struct glamofb_handle *gfb, u_int16_t val);
+
+#ifdef CONFIG_MFD_GLAMO
+void glamo_lcm_reset(int level);
+#else
+#define glamo_lcm_reset(...) do {} while (0)
+#endif
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/glamo-gpio.h linux-2.6.29-rc3.owrt.om/include/linux/glamo-gpio.h
--- linux-2.6.29-rc3.owrt/include/linux/glamo-gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/glamo-gpio.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,99 @@
+#ifndef __GLAMO_GPIO_H
+#define __GLAMO_GPIO_H
+
+struct glamo_core;
+
+#define GLAMO_GPIO_BANKA	0x0000
+#define GLAMO_GPIO_BANKB	0x1000
+#define GLAMO_GPIO_BANKC	0x2000
+#define GLAMO_GPIO_BANKD	0x3000
+
+#define GLAMO_GPIONO(bank, pin)	((bank & 0xf000) | ((pin & 0xf) << 8))
+
+#define GLAMO_GPIO_F_IN		0x0010
+#define GLAMO_GPIO_F_OUT	0x0020
+#define GLAMO_GPIO_F_FUNC	0x0030
+
+#define GLAMO_GPIO0		GLAMO_GPIONO(GLAMO_GPIO_BANKA, 0)
+#define GLAMO_GPIO0_INPUT	(GLAMO_GPIO0 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO0_OUTPUT	(GLAMO_GPIO0 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO0_HA20	(GLAMO_GPIO0 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO1		GLAMO_GPIONO(GLAMO_GPIO_BANKA, 1)
+#define GLAMO_GPIO1_INPUT	(GLAMO_GPIO1 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO1_OUTPUT	(GLAMO_GPIO1 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO1_HA21	(GLAMO_GPIO1 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO2		GLAMO_GPIONO(GLAMO_GPIO_BANKA, 2)
+#define GLAMO_GPIO2_INPUT	(GLAMO_GPIO2 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO2_OUTPUT	(GLAMO_GPIO2 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO2_HA22	(GLAMO_GPIO2 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO3		GLAMO_GPIONO(GLAMO_GPIO_BANKA, 3)
+#define GLAMO_GPIO3_INPUT	(GLAMO_GPIO3 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO3_OUTPUT	(GLAMO_GPIO3 | GLAMO_GPIO_F_OUT)
+#define	GLAMO_GPIO3_HA23	(GLAMO_GPIO3 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO4		GLAMO_GPIONO(GLAMO_GPIO_BANKB, 0)
+#define GLAMO_GPIO4_INPUT	(GLAMO_GPIO4 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO4_OUTPUT	(GLAMO_GPIO4 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO4_nLCS0	(GLAMO_GPIO4 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO5		GLAMO_GPIONO(GLAMO_GPIO_BANKB, 1)
+#define GLAMO_GPIO5_INPUT	(GLAMO_GPIO5 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO5_OUTPUT	(GLAMO_GPIO5 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO5_nLCS1	(GLAMO_GPIO5 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO6		GLAMO_GPIONO(GLAMO_GPIO_BANKB, 2)
+#define GLAMO_GPIO6_INPUT	(GLAMO_GPIO6 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO6_OUTPUT	(GLAMO_GPIO6 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO6_LDCLK	(GLAMO_GPIO6 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO7		GLAMO_GPIONO(GLAMO_GPIO_BANKB, 3)
+#define GLAMO_GPIO7_INPUT	(GLAMO_GPIO7 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO7_OUTPUT	(GLAMO_GPIO7 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO7_nLDE	(GLAMO_GPIO7 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO8		GLAMO_GPIONO(GLAMO_GPIO_BANKC, 0)
+#define GLAMO_GPIO8_INPUT	(GLAMO_GPIO8 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO8_OUTPUT	(GLAMO_GPIO8 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO8_LD16	(GLAMO_GPIO8 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO9		GLAMO_GPIONO(GLAMO_GPIO_BANKC, 1)
+#define GLAMO_GPIO9_INPUT	(GLAMO_GPIO9 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO9_OUTPUT	(GLAMO_GPIO9 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO9_LD17	(GLAMO_GPIO9 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO10		GLAMO_GPIONO(GLAMO_GPIO_BANKC, 2)
+#define GLAMO_GPIO10_INPUT	(GLAMO_GPIO10 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO10_OUTPUT	(GLAMO_GPIO10 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO10_LSCK	(GLAMO_GPIO10 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO11		GLAMO_GPIONO(GLAMO_GPIO_BANKC, 3)
+#define GLAMO_GPIO11_INPUT	(GLAMO_GPIO11 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO11_OUTPUT	(GLAMO_GPIO11 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO11_LSDA	(GLAMO_GPIO11 | GLAMO_GPIO_F_FUNC)
+
+#define GLAMO_GPIO12		GLAMO_GPIONO(GLAMO_GPIO_BANKD, 0)
+#define GLAMO_GPIO12_INPUT	(GLAMO_GPIO12 | GLAMO_GPIO_F_IN)
+#define GLAMO_GPIO12_OUTPUT	(GLAMO_GPIO12 | GLAMO_GPIO_F_OUT)
+#define GLAMO_GPIO12_LSA0	(GLAMO_GPIO12 | GLAMO_GPIO_F_FUNC)
+
+
+#define REG_OF_GPIO(gpio)	(((gpio & 0xf000) >> 12)*2 \
+						+ GLAMO_REG_GPIO_GEN1)
+#define NUM_OF_GPIO(gpio)	((gpio & 0x0f00) >> 8)
+#define GPIO_OUT_BIT(gpio)	(1 << (NUM_OF_GPIO(gpio) + 0))
+#define OUTPUT_BIT(gpio)	(1 << (NUM_OF_GPIO(gpio) + 4))
+#define INPUT_BIT(gpio)		(1 << (NUM_OF_GPIO(gpio) + 8))
+#define FUNC_BIT(gpio)		(1 << (NUM_OF_GPIO(gpio) + 12))
+
+void glamo_gpio_setpin(struct glamo_core *glamo, unsigned int pin,
+		       unsigned int value);
+
+int glamo_gpio_getpin(struct glamo_core *glamo, unsigned int pin);
+
+void glamo_gpio_cfgpin(struct glamo_core *glamo, unsigned int pinfunc);
+
+
+#endif /* _GLAMO_GPIO */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/gta01_battery.h linux-2.6.29-rc3.owrt.om/include/linux/gta01_battery.h
--- linux-2.6.29-rc3.owrt/include/linux/gta01_battery.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/gta01_battery.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,10 @@
+#ifndef __GTA01_BATTERY_H__
+#define __GTA01_BATTERY_H__
+
+struct gta01_bat_platform_data {
+	int (*get_charging_status)(void);
+	int (*get_voltage)(void);
+	int (*get_current)(void);
+};
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/gta02_hdq.h linux-2.6.29-rc3.owrt.om/include/linux/gta02_hdq.h
--- linux-2.6.29-rc3.owrt/include/linux/gta02_hdq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/gta02_hdq.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef __GTA02HDQ_H__
+#define __GTA02HDQ_H__
+
+/* platform data */
+
+struct gta02_hdq_platform_data {
+	/*
+	 * give an opportunity to use us as parent for
+	 * devices that depend on us
+	 */
+	void (*attach_child_devices)(struct device *parent_device);
+};
+
+int gta02hdq_read(int address);
+int gta02hdq_write(int address, u8 data);
+int gta02hdq_initialized(void);
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/hdq.h linux-2.6.29-rc3.owrt.om/include/linux/hdq.h
--- linux-2.6.29-rc3.owrt/include/linux/hdq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/hdq.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef __LINUX_HDQ_H__
+#define __LINUX_HDQ_H__
+
+#include <linux/device.h>
+
+#define HDQ_SAMPLE_PERIOD_US	10
+
+/* platform data */
+
+struct hdq_platform_data {
+	/*
+	 * give an opportunity to use us as parent for
+	 * devices that depend on us
+	 */
+	void (*attach_child_devices)(struct device *parent_device);
+	
+	void (*gpio_dir_out)(void);
+	void (*gpio_dir_in)(void);
+	void (*gpio_set)(int);
+	int (*gpio_get)(void);
+
+	int (*enable_fiq)(void);
+	void (*disable_fiq)(void);
+	void (*kick_fiq)(void);
+
+};
+
+int hdq_read(int address);
+int hdq_write(int address, u8 data);
+int hdq_initialized(void);
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/i2c-id.h linux-2.6.29-rc3.owrt.om/include/linux/i2c-id.h
--- linux-2.6.29-rc3.owrt/include/linux/i2c-id.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/i2c-id.h	2009-05-10 22:28:00.000000000 +0200
@@ -73,6 +73,15 @@
 #define I2C_DRIVERID_CS5345	96	/* cs5345 audio processor	*/
 
 #define I2C_DRIVERID_OV7670 1048	/* Omnivision 7670 camera */
+#define I2C_DRIVERID_PCF50606 1049
+#define I2C_DRIVERID_PCF50633 1051
+#define I2C_DRIVERID_PCA9632  1052
+
+#define	I2C_DRIVERID_S5K_3XA	1500	/* Samsung MobileAP I2C adapter */
+#define	I2C_DRIVERID_S5K_53BEA	1501	/* Samsung MobileAP I2C adapter */
+#define	I2C_DRIVERID_S5K_532	1502	/* Samsung MobileAP I2C adapter */
+#define	I2C_DRIVERID_S5K_3BA	1503	/* Samsung MobileAP I2C adapter */
+#define	I2C_DRIVERID_S5K_4XA	1504	/* Samsung MobileAP I2C adapter */
 
 /*
  * ---- Adapter types ----------------------------------------------------
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/jbt6k74.h linux-2.6.29-rc3.owrt.om/include/linux/jbt6k74.h
--- linux-2.6.29-rc3.owrt/include/linux/jbt6k74.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/jbt6k74.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,12 @@
+#ifndef __JBT6K74_H__
+#define __JBT6K74_H__
+
+#include <linux/spi/spi.h>
+
+struct jbt6k74_platform_data {
+	void (*reset)(int devindex, int level);
+	void (*resuming)(int devindex); /* called when LCM is resumed */
+	void (*probe_completed)(struct device *dev);
+};
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/kernel.h linux-2.6.29-rc3.owrt.om/include/linux/kernel.h
--- linux-2.6.29-rc3.owrt/include/linux/kernel.h	2009-05-10 22:09:07.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/kernel.h	2009-05-10 22:28:00.000000000 +0200
@@ -242,6 +242,8 @@
 extern int printk_ratelimit(void);
 extern bool printk_timed_ratelimit(unsigned long *caller_jiffies,
 				   unsigned int interval_msec);
+extern void (*printk_emergency_debug_spew_init)(void);
+extern void (*printk_emergency_debug_spew_send_string)(const char *);
 #else
 static inline int vprintk(const char *s, va_list args)
 	__attribute__ ((format (printf, 1, 0)));
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/kexec.h linux-2.6.29-rc3.owrt.om/include/linux/kexec.h
--- linux-2.6.29-rc3.owrt/include/linux/kexec.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/kexec.h	2009-05-10 22:28:00.000000000 +0200
@@ -1,7 +1,6 @@
 #ifndef LINUX_KEXEC_H
 #define LINUX_KEXEC_H
 
-#ifdef CONFIG_KEXEC
 #include <linux/types.h>
 #include <linux/list.h>
 #include <linux/linkage.h>
@@ -11,6 +10,8 @@
 #include <linux/elf.h>
 #include <asm/kexec.h>
 
+#ifdef CONFIG_KEXEC
+
 /* Verify architecture specific macros are defined */
 
 #ifndef KEXEC_SOURCE_MEMORY_LIMIT
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/l1k002.h linux-2.6.29-rc3.owrt.om/include/linux/l1k002.h
--- linux-2.6.29-rc3.owrt/include/linux/l1k002.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/l1k002.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __LINUX_L1K002_H_
+#define __LINUX_L1K002_H_
+
+struct l1k002_platform_data {
+	void (*pwr_onoff)(int level);
+};
+
+#endif /* __LINUX_L1K002_H_ */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/lis302dl.h linux-2.6.29-rc3.owrt.om/include/linux/lis302dl.h
--- linux-2.6.29-rc3.owrt/include/linux/lis302dl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/lis302dl.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,152 @@
+#ifndef _LINUX_LIS302DL_H
+#define _LINUX_LIS302DL_H
+
+#include <linux/types.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <linux/workqueue.h>
+
+struct lis302dl_info;
+
+struct lis302dl_platform_data {
+	char *name;
+	unsigned long pin_chip_select;
+	unsigned long pin_clk;
+	unsigned long pin_mosi;
+	unsigned long pin_miso;
+	int open_drain;
+	int interrupt;
+	void (*lis302dl_suspend_io)(struct lis302dl_info *, int resuming);
+};
+
+struct lis302dl_info {
+	struct lis302dl_platform_data *pdata;
+	struct device *dev;
+	struct input_dev *input_dev;
+	unsigned int flags;
+	unsigned int threshold;
+	unsigned int duration;
+	u32 overruns;
+	struct {
+		unsigned int threshold; /* mg */
+		unsigned int duration;  /* ms */
+	} wakeup;
+
+	struct spi_device *spi;
+	u_int8_t regs[0x40];
+};
+
+enum lis302dl_reg {
+	LIS302DL_REG_WHO_AM_I		= 0x0f,
+	LIS302DL_REG_CTRL1		= 0x20,
+	LIS302DL_REG_CTRL2		= 0x21,
+	LIS302DL_REG_CTRL3		= 0x22,
+	LIS302DL_REG_HP_FILTER_RESET	= 0x23,
+	LIS302DL_REG_STATUS		= 0x27,
+	LIS302DL_REG_OUT_X		= 0x29,
+	LIS302DL_REG_OUT_Y		= 0x2b,
+	LIS302DL_REG_OUT_Z		= 0x2d,
+	LIS302DL_REG_FF_WU_CFG_1	= 0x30,
+	LIS302DL_REG_FF_WU_SRC_1	= 0x31,
+	LIS302DL_REG_FF_WU_THS_1	= 0x32,
+	LIS302DL_REG_FF_WU_DURATION_1	= 0x33,
+	LIS302DL_REG_FF_WU_CFG_2	= 0x34,
+	LIS302DL_REG_FF_WU_SRC_2	= 0x35,
+	LIS302DL_REG_FF_WU_THS_2	= 0x36,
+	LIS302DL_REG_FF_WU_DURATION_2	= 0x37,
+	LIS302DL_REG_CLICK_CFG		= 0x38,
+	LIS302DL_REG_CLICK_SRC		= 0x39,
+	LIS302DL_REG_CLICK_THSY_X	= 0x3b,
+	LIS302DL_REG_CLICK_THSZ		= 0x3c,
+	LIS302DL_REG_CLICK_TIME_LIMIT	= 0x3d,
+	LIS302DL_REG_CLICK_LATENCY	= 0x3e,
+	LIS302DL_REG_CLICK_WINDOW	= 0x3f,
+};
+
+enum lis302dl_reg_ctrl1 {
+	LIS302DL_CTRL1_Xen		= 0x01,
+	LIS302DL_CTRL1_Yen		= 0x02,
+	LIS302DL_CTRL1_Zen		= 0x04,
+	LIS302DL_CTRL1_STM		= 0x08,
+	LIS302DL_CTRL1_STP		= 0x10,
+	LIS302DL_CTRL1_FS		= 0x20,
+	LIS302DL_CTRL1_PD		= 0x40,
+	LIS302DL_CTRL1_DR		= 0x80,
+};
+
+enum lis302dl_reg_ctrl2 {
+	LIS302DL_CTRL2_HPC1		= 0x01,
+	LIS302DL_CTRL2_HPC2		= 0x02,
+	LIS302DL_CTRL2_HPFF1		= 0x04,
+	LIS302DL_CTRL2_HPFF2		= 0x08,
+	LIS302DL_CTRL2_FDS		= 0x10,
+	LIS302DL_CTRL2_BOOT		= 0x40,
+	LIS302DL_CTRL2_SIM		= 0x80,
+};
+enum lis302dl_reg_ctrl3 {
+	LIS302DL_CTRL3_PP_OD		= 0x40,
+	LIS302DL_CTRL3_IHL		= 0x80,
+};
+
+enum lis302dl_reg_status {
+	LIS302DL_STATUS_XDA		= 0x01,
+	LIS302DL_STATUS_YDA		= 0x02,
+	LIS302DL_STATUS_ZDA		= 0x04,
+	LIS302DL_STATUS_XYZDA		= 0x08,
+	LIS302DL_STATUS_XOR		= 0x10,
+	LIS302DL_STATUS_YOR		= 0x20,
+	LIS302DL_STATUS_ZOR		= 0x40,
+	LIS302DL_STATUS_XYZOR		= 0x80,
+};
+
+/* Wakeup/freefall interrupt defs */
+enum lis302dl_reg_ffwucfg {
+	LIS302DL_FFWUCFG_XLIE		= 0x01,
+	LIS302DL_FFWUCFG_XHIE		= 0x02,
+	LIS302DL_FFWUCFG_YLIE		= 0x04,
+	LIS302DL_FFWUCFG_YHIE		= 0x08,
+	LIS302DL_FFWUCFG_ZLIE		= 0x10,
+	LIS302DL_FFWUCFG_ZHIE		= 0x20,
+	LIS302DL_FFWUCFG_LIR		= 0x40,
+	LIS302DL_FFWUCFG_AOI		= 0x80,
+};
+
+enum lis302dl_reg_ffwuths {
+	LIS302DL_FFWUTHS_DCRM		= 0x80,
+};
+
+enum lis302dl_reg_ffwusrc {
+	LIS302DL_FFWUSRC_XL		= 0x01,
+	LIS302DL_FFWUSRC_XH		= 0x02,
+	LIS302DL_FFWUSRC_YL		= 0x04,
+	LIS302DL_FFWUSRC_YH		= 0x08,
+	LIS302DL_FFWUSRC_ZL		= 0x10,
+	LIS302DL_FFWUSRC_ZH		= 0x20,
+	LIS302DL_FFWUSRC_IA		= 0x40,
+};
+
+enum lis302dl_reg_cloik_src {
+	LIS302DL_CLICKSRC_SINGLE_X	= 0x01,
+	LIS302DL_CLICKSRC_DOUBLE_X	= 0x02,
+	LIS302DL_CLICKSRC_SINGLE_Y	= 0x04,
+	LIS302DL_CLICKSRC_DOUBLE_Y	= 0x08,
+	LIS302DL_CLICKSRC_SINGLE_Z	= 0x10,
+	LIS302DL_CLICKSRC_DOUBLE_Z	= 0x20,
+	LIS302DL_CLICKSRC_IA		= 0x40,
+};
+
+#define LIS302DL_WHO_AM_I_MAGIC		0x3b
+
+#define LIS302DL_F_WUP_FF_1		0x0001	/* wake up from free fall */
+#define LIS302DL_F_WUP_FF_2		0x0002
+#define LIS302DL_F_WUP_FF		0x0003
+#define LIS302DL_F_WUP_CLICK	0x0004
+#define LIS302DL_F_POWER		0x0010
+#define LIS302DL_F_FS			0x0020 	/* ADC full scale */
+#define LIS302DL_F_INPUT_OPEN 	0x0040  /* Set if input device is opened */
+#define LIS302DL_F_IRQ_WAKE 	0x0080  /* IRQ is setup in wake mode */
+#define LIS302DL_F_DR			0x0100 	/* Data rate, 400Hz/100Hz */
+
+
+#endif /* _LINUX_LIS302DL_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/lp5521.h linux-2.6.29-rc3.owrt.om/include/linux/lp5521.h
--- linux-2.6.29-rc3.owrt/include/linux/lp5521.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/lp5521.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,75 @@
+#ifndef _LINUX_LP5521_H_
+#define _LINUX_LP5521_H_
+
+#define LP5521_REG_ENABLE 	0x00
+#define LP5521_REG_OP_MODE 	0x01
+
+#define LP5521_REG_R_PWM 	0x02
+#define LP5521_REG_G_PWM 	0x03
+#define LP5521_REG_B_PWM 	0x04
+
+#define LP5521_REG_R_CUR 	0x05
+#define LP5521_REG_G_CUR	0x06
+#define LP5521_REG_B_CUR	0x07
+
+#define LP5521_REG_CONFIG	0x08
+
+#define LP5521_REG_R_PC		0x09
+#define LP5521_REG_G_PC		0x0a
+#define LP5521_REG_B_PC		0x0b
+
+#define LP5521_REG_STATUS	0x0c
+#define LP5521_REG_RESET	0x0d
+#define LP5521_REG_GPO		0x0e
+
+enum {
+	LP5521_NC,
+	LP5521_CONNECTED,
+};
+
+enum {
+	LP5521_BLUE,
+	LP5521_GREEN,
+	LP5521_RED,
+	LP5521_NUM_CH,
+};
+
+enum {
+	LP5521_MODE_DISABLE,
+	LP5521_MODE_LOAD,
+	LP5521_MODE_RUN,
+	LP5521_MODE_DIRECT,
+};
+
+enum CP_MODE {
+	LP5521_CPM_OFF,
+	LP5521_CPM_BY_PASS,
+	LP5521_CPM_1_5X,
+	LP5521_CPM_AUTO,
+};
+
+enum CLK_SRC {
+	LP5521_EXT_CLK,
+	LP5521_INT_CLK,
+	LP5521_AUTO_CLK,
+};
+
+#define LP5521_FEAT_TRIG	0x00000001
+#define LP5521_FEAT_GPO		0x00000002
+
+
+struct lp5521_platform_data {
+	int channels[LP5521_NUM_CH];
+	/* chip enable */
+	void (*ext_enable)(int level);
+};
+
+struct lp5521 {
+	struct device *dev;
+	struct i2c_client *client;
+	struct mutex lock;
+	int irq;
+
+	struct lp5521_platform_data *pdata;
+};
+#endif /* LINUX_LP5521_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/adc.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/adc.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/adc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/adc.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * adc.h  -- Driver for NXP PCF50606 ADC
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __LINUX_MFD_PCF50606_ADC_H
+#define __LINUX_MFD_PCF50606_ADC_H
+
+#include <linux/mfd/pcf50633/core.h>
+#include <linux/platform_device.h>
+
+/* ADC Registers */
+#define PCF50606_REG_ADCC1 0x2e
+#define PCF50606_REG_ADCC2 0x2f
+#define PCF50606_REG_ADCS1 0x30
+#define PCF50606_REG_ADCS2 0x31
+#define PCF50606_REG_ADCS3 0x32
+
+#define PCF50606_ADCC1_TSCMODACT	 0x01
+#define PCF50606_ADCC1_TSCMODSTB	 0x02
+#define PCF50606_ADCC1_TRATSET		 0x04
+#define PCF50606_ADCC1_NTCSWAPE		 0x08
+#define PCF50606_ADCC1_NTCSWAOFF	 0x10
+#define PCF50606_ADCC1_EXTSYNCBREAK	 0x20
+	/* reserved */
+#define PCF50606_ADCC1_TSCINT		 0x80
+
+#define PCF50606_ADCC2_ADCSTART		 0x01
+	/* see enum pcf50606_adcc2_adcmux */
+#define PCF50606_ADCC2_SYNC_NONE	 0x00
+#define PCF50606_ADCC2_SYNC_TXON	 0x20
+#define PCF50606_ADCC2_SYNC_PWREN1	 0x40
+#define PCF50606_ADCC2_SYNC_PWREN2	 0x60
+#define PCF50606_ADCC2_RES_10BIT	 0x00
+#define PCF50606_ADCC2_RES_8BIT		 0x80
+
+#define PCF50606_ADCC2_ADCMUX_MASK	(0xf << 1)
+
+#define ADCMUX_SHIFT	1
+#define PCF50606_ADCMUX_BATVOLT_RES	 (0x0 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_BATVOLT_SUBTR	 (0x1 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_ADCIN1_RES	 (0x2 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_ADCIN1_SUBTR	 (0x3 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_BATTEMP		 (0x4 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_ADCIN2		 (0x5 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_ADCIN3		 (0x6 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_ADCIN3_RATIO	 (0x7 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_XPOS		 (0x8 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_YPOS		 (0x9 << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_P1		 (0xa << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_P2		 (0xb << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_BATVOLT_ADCIN1	 (0xc << ADCMUX_SHIFT)
+#define PCF50606_ADCMUX_XY_SEQUENCE	 (0xe << ADCMUX_SHIFT)
+#define PCF50606_P1_P2_RESISTANCE	 (0xf << ADCMUX_SHIFT)
+
+#define PCF50606_ADCS2_ADCRDY		 0x80
+
+extern int
+pcf50606_adc_async_read(struct pcf50606 *pcf, int mux,
+		void (*callback)(struct pcf50606 *, void *, int),
+		void *callback_param);
+extern int
+pcf50606_adc_sync_read(struct pcf50606 *pcf, int mux);
+
+#endif /* __LINUX_PCF50606_ADC_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/core.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/core.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/core.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,170 @@
+/*
+ * core.h  -- Core driver for NXP PCF50606
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __LINUX_MFD_PCF50606_CORE_H
+#define __LINUX_MFD_PCF50606_CORE_H
+
+#include <linux/i2c.h>
+#include <linux/workqueue.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/power_supply.h>
+
+struct pcf50606;
+
+#define PCF50606_NUM_REGULATORS	8
+
+struct pcf50606_platform_data {
+	struct regulator_init_data reg_init_data[PCF50606_NUM_REGULATORS];
+
+	char **batteries;
+	int num_batteries;
+
+	/* Callbacks */
+	void (*probe_done)(struct pcf50606 *);
+	void (*mbc_event_callback)(struct pcf50606 *, int);
+	void (*regulator_registered)(struct pcf50606 *, int);
+	void (*force_shutdown)(struct pcf50606 *);
+
+	u8 resumers[3];
+};
+
+struct pcf50606_subdev_pdata {
+	struct pcf50606 *pcf;
+};
+
+struct pcf50606_irq {
+	void (*handler)(int, void *);
+	void *data;
+};
+
+int pcf50606_register_irq(struct pcf50606 *pcf, int irq,
+			void (*handler) (int, void *), void *data);
+int pcf50606_free_irq(struct pcf50606 *pcf, int irq);
+
+int pcf50606_irq_mask(struct pcf50606 *pcf, int irq);
+int pcf50606_irq_unmask(struct pcf50606 *pcf, int irq);
+int pcf50606_irq_mask_get(struct pcf50606 *pcf, int irq);
+
+int pcf50606_read_block(struct pcf50606 *, u8 reg,
+					int nr_regs, u8 *data);
+int pcf50606_write_block(struct pcf50606 *pcf, u8 reg,
+					int nr_regs, u8 *data);
+u8 pcf50606_reg_read(struct pcf50606 *, u8 reg);
+int pcf50606_reg_write(struct pcf50606 *pcf, u8 reg, u8 val);
+
+int pcf50606_reg_set_bit_mask(struct pcf50606 *pcf, u8 reg, u8 mask, u8 val);
+int pcf50606_reg_clear_bits(struct pcf50606 *pcf, u8 reg, u8 bits);
+
+/* Interrupt registers */
+
+#define PCF50606_REG_INT1	0x02
+#define	PCF50606_REG_INT2	0x03
+#define	PCF50606_REG_INT3	0x04
+
+#define PCF50606_REG_INT1M	0x05
+#define	PCF50606_REG_INT2M	0x06
+#define	PCF50606_REG_INT3M	0x07
+
+enum {
+	/* Chip IRQs */
+	PCF50606_IRQ_ONKEYR,
+	PCF50606_IRQ_ONKEYF,
+	PCF50606_IRQ_ONKEY1S,
+	PCF50606_IRQ_EXTONR,
+	PCF50606_IRQ_EXTONF,
+	PCF50606_IRQ_RESERVED_1,
+	PCF50606_IRQ_SECOND,
+	PCF50606_IRQ_ALARM,
+	PCF50606_IRQ_CHGINS,
+	PCF50606_IRQ_CHGRM,
+	PCF50606_IRQ_CHGFOK,
+	PCF50606_IRQ_CHGERR,
+	PCF50606_IRQ_CHGFRDY,
+	PCF50606_IRQ_CHGPROT,
+	PCF50606_IRQ_CHGWD10S,
+	PCF50606_IRQ_CHGWDEXP,
+	PCF50606_IRQ_ADCRDY,
+	PCF50606_IRQ_ACDINS,
+	PCF50606_IRQ_ACDREM,
+	PCF50606_IRQ_TSCPRES,
+	PCF50606_IRQ_RESERVED_2,
+	PCF50606_IRQ_RESERVED_3,
+	PCF50606_IRQ_LOWBAT,
+	PCF50606_IRQ_HIGHTMP,
+
+	/* Always last */
+	PCF50606_NUM_IRQ,
+};
+
+struct pcf50606 {
+	struct device *dev;
+	struct i2c_client *i2c_client;
+
+	struct pcf50606_platform_data *pdata;
+	int irq;
+	struct pcf50606_irq irq_handler[PCF50606_NUM_IRQ];
+	struct work_struct irq_work;
+	struct mutex lock;
+
+	u8 mask_regs[3];
+
+	u8 suspend_irq_masks[3];
+	u8 resume_reason[3];
+	int is_suspended;
+
+	int onkey1s_held;
+
+	struct platform_device *rtc_pdev;
+	struct platform_device *mbc_pdev;
+	struct platform_device *adc_pdev;
+	struct platform_device *input_pdev;
+	struct platform_device *wdt_pdev;
+	struct platform_device *regulator_pdev[PCF50606_NUM_REGULATORS];
+};
+
+enum pcf50606_reg_int1 {
+	PCF50606_INT1_ONKEYR	= 0x01,	/* ONKEY rising edge */
+	PCF50606_INT1_ONKEYF	= 0x02,	/* ONKEY falling edge */
+	PCF50606_INT1_ONKEY1S	= 0x04,	/* OMKEY at least 1sec low */
+	PCF50606_INT1_EXTONR	= 0x08,	/* EXTON rising edge */
+	PCF50606_INT1_EXTONF	= 0x10,	/* EXTON falling edge */
+	PCF50606_INT1_SECOND	= 0x40,	/* RTC periodic second interrupt */
+	PCF50606_INT1_ALARM	= 0x80, /* RTC alarm time is reached */
+};
+
+enum pcf50606_reg_int2 {
+	PCF50606_INT2_CHGINS	= 0x01, /* Charger inserted */
+	PCF50606_INT2_CHGRM	= 0x02, /* Charger removed */
+	PCF50606_INT2_CHGFOK	= 0x04,	/* Fast charging OK */
+	PCF50606_INT2_CHGERR	= 0x08,	/* Error in charging mode */
+	PCF50606_INT2_CHGFRDY	= 0x10,	/* Fast charge completed */
+	PCF50606_INT2_CHGPROT	= 0x20,	/* Charging protection interrupt */
+	PCF50606_INT2_CHGWD10S	= 0x40,	/* Charger watchdig expires in 10s */
+	PCF50606_INT2_CHGWDEXP	= 0x80,	/* Charger watchdog expires */
+};
+
+enum pcf50606_reg_int3 {
+	PCF50606_INT3_ADCRDY	= 0x01,	/* ADC conversion finished */
+	PCF50606_INT3_ACDINS	= 0x02,	/* Accessory inserted */
+	PCF50606_INT3_ACDREM	= 0x04, /* Accessory removed */
+	PCF50606_INT3_TSCPRES	= 0x08,	/* Touch screen pressed */
+	PCF50606_INT3_LOWBAT	= 0x40,	/* Low battery voltage */
+	PCF50606_INT3_HIGHTMP	= 0x80, /* High temperature */
+};
+
+/* Misc regs */
+
+#define PCF50606_REG_OOCC1 	0x08
+#define PCF50606_OOCC1_GOSTDBY	0x01
+#endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/gpo.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/gpo.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/gpo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/gpo.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * gpo.h -- GPO driver for NXP PCF50606
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __LINUX_MFD_PCF50606_GPO_H
+#define __LINUX_MFD_PCF50606_GPO_H
+
+#include <linux/mfd/pcf50633/core.h>
+
+#define PCF50606_REG_GPOC1 0x38
+#define PCF50606_REG_GPOC2 0x39
+#define PCF50606_REG_GPOC3 0x3a
+#define PCF50606_REG_GPOC4 0x3b
+#define PCF50606_REG_GPOC5 0x3c
+
+#define PCF50606_GPO1	PCF50606_REG_GPOC1
+#define PCF50606_GPO2	PCF50606_REG_GPOC1
+#define PCF50606_GPOOD1	PCF50606_REG_GPOC2
+#define PCF50606_GPOOD2	PCF50606_REG_GPOC3
+#define PCF50606_GPOOD3	PCF50606_REG_GPOC4
+#define PCF50606_GPOOD4	PCF50606_REG_GPOC5
+
+#define PCF50606_GPOCFG_GPOSEL_MASK	0x07
+
+void pcf50606_gpo_set_active(struct pcf50606 *pcf, int gpo, int value);
+int pcf50606_gpo_get_active(struct pcf50606 *pcf, int gpo);
+void pcf50606_gpo_set_standby(struct pcf50606 *pcf, int gpo, int value);
+int pcf50606_gpo_get_standby(struct pcf50606 *pcf, int gpo);
+
+void pcf50606_gpo_invert_set(struct pcf50606 *, int gpo, int invert);
+int pcf50606_gpo_invert_get(struct pcf50606 *pcf, int gpo);
+
+#endif /* __LINUX_MFD_PCF50606_GPIO_H */
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/mbc.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/mbc.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/mbc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/mbc.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+ * mbc.h  -- Driver for NXP PCF50606 Main Battery Charger
+ *
+ * (C) 2006-2008 by Openmoko, Inc.
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __LINUX_MFD_PCF50606_MBC_H
+#define __LINUX_MFD_PCF50606_MBC_H
+
+#include <linux/mfd/pcf50606/core.h>
+#include <linux/platform_device.h>
+
+#define PCF50606_REG_OOCS	0x01
+
+/* Charger OK */
+#define PCF50606_OOCS_CHGOK	0x20
+
+#define PCF50606_REG_MBCC1	0x29
+#define PCF50606_REG_MBCC2	0x2a
+#define PCF50606_REG_MBCC3	0x2b
+#define PCF50606_REG_MBCS1	0x2c
+
+#define PCF50606_MBCC1_CHGAPE		0x01
+#define PCF50606_MBCC1_AUTOFST		0x02
+#define PCF50606_MBCC1_CHGMOD_MASK	0x1c
+#define PCF50606_MBCC1_CHGMOD_QUAL	0x00
+#define PCF50606_MBCC1_CHGMOD_PRE	0x04
+#define PCF50606_MBCC1_CHGMOD_TRICKLE	0x08
+#define PCF50606_MBCC1_CHGMOD_FAST_CCCV	0x0c
+#define PCF50606_MBCC1_CHGMOD_FAST_NOCC	0x10
+#define PCF50606_MBCC1_CHGMOD_FAST_NOCV	0x14
+#define PCF50606_MBCC1_CHGMOD_FAST_SW	0x18
+#define PCF50606_MBCC1_CHGMOD_IDLE	0x1c
+#define PCF50606_MBCC1_DETMOD_LOWCHG	0x20
+#define PCF50606_MBCC1_DETMOD_WDRST	0x40
+
+#define PCF50606_MBCC1_CHGMOD_SHIFT	2
+
+/* Charger status */
+#define PCF50606_MBC_CHARGER_ONLINE	0x01
+#define PCF50606_MBC_CHARGER_ACTIVE	0x02
+
+void pcf50606_charge_fast(struct pcf50606 *pcf, int on);
+
+#endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/pmic.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/pmic.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50606/pmic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50606/pmic.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,73 @@
+#ifndef __LINUX_MFD_PCF50606_PMIC_H
+#define __LINUX_MFD_PCF50606_PMIC_H
+
+#define PCF50606_REG_DCDC1	 0x1b
+#define PCF50606_REG_DCDC2	 0x1c
+#define PCF50606_REG_DCDC3	 0x1d
+#define PCF50606_REG_DCDC4	 0x1e
+#define PCF50606_REG_DCDEC1	 0x1f
+#define PCF50606_REG_DCDEC2	 0x20
+#define PCF50606_REG_DCUDC1	 0x21
+#define PCF50606_REG_DCUDC2	 0x22
+#define PCF50606_REG_IOREGC	 0x23
+#define PCF50606_REG_D1REGC1	 0x24
+#define PCF50606_REG_D2REGC1	 0x25
+#define PCF50606_REG_D3REGC1	 0x26
+#define PCF50606_REG_LPREGC1	 0x27
+#define PCF50606_REG_LPREGC2	 0x28
+
+/* used by PSSC, PWROKM, PWROKS, */
+enum pcf50606_regu {
+	PCF50606_REGU_DCD	= 0x01,	/* DCD in phase 2 */
+	PCF50606_REGU_DCDE	= 0x02,	/* DCDE in phase 2 */
+	PCF50606_REGU_DCUD	= 0x04,	/* DCDU in phase 2 */
+	PCF50606_REGU_IO	= 0x08,	/* IO in phase 2 */
+	PCF50606_REGU_D1	= 0x10, /* D1 in phase 2 */
+	PCF50606_REGU_D2	= 0x20,	/* D2 in phase 2 */
+	PCF50606_REGU_D3	= 0x40,	/* D3 in phase 2 */
+	PCF50606_REGU_LP	= 0x80,	/* LP in phase 2 */
+};
+
+enum pcf50606_reg_dcdc4 {
+	PCF50606_DCDC4_MODE_AUTO	= 0x00,
+	PCF50606_DCDC4_MODE_PWM		= 0x01,
+	PCF50606_DCDC4_MODE_PCF		= 0x02,
+	PCF50606_DCDC4_OFF_FLOAT	= 0x00,
+	PCF50606_DCDC4_OFF_BYPASS	= 0x04,
+	PCF50606_DCDC4_OFF_PULLDOWN	= 0x08,
+	PCF50606_DCDC4_CURLIM_500mA	= 0x00,
+	PCF50606_DCDC4_CURLIM_750mA	= 0x10,
+	PCF50606_DCDC4_CURLIM_1000mA	= 0x20,
+	PCF50606_DCDC4_CURLIM_1250mA	= 0x30,
+	PCF50606_DCDC4_TOGGLE		= 0x40,
+	PCF50606_DCDC4_REGSEL_DCDC2	= 0x80,
+};
+
+enum pcf50606_reg_dcdec2 {
+	PCF50606_DCDEC2_MODE_AUTO	= 0x00,
+	PCF50606_DCDEC2_MODE_PWM	= 0x01,
+	PCF50606_DCDEC2_MODE_PCF	= 0x02,
+	PCF50606_DCDEC2_OFF_FLOAT	= 0x00,
+	PCF50606_DCDEC2_OFF_BYPASS	= 0x04,
+};
+
+enum pcf50606_reg_dcudc2 {
+	PCF50606_DCUDC2_MODE_AUTO	= 0x00,
+	PCF50606_DCUDC2_MODE_PWM	= 0x01,
+	PCF50606_DCUDC2_MODE_PCF	= 0x02,
+	PCF50606_DCUDC2_OFF_FLOAT	= 0x00,
+	PCF50606_DCUDC2_OFF_BYPASS	= 0x04,
+};
+
+enum pcf50606_regulator_id {
+	PCF50606_REGULATOR_DCD,
+	PCF50606_REGULATOR_DCDE,
+	PCF50606_REGULATOR_DCUD,
+	PCF50606_REGULATOR_D1REG,
+	PCF50606_REGULATOR_D2REG,
+	PCF50606_REGULATOR_D3REG,
+	PCF50606_REGULATOR_LPREG,
+	PCF50606_REGULATOR_IOREG,
+};
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50633/core.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50633/core.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50633/core.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50633/core.h	2009-05-10 22:28:00.000000000 +0200
@@ -29,6 +29,10 @@
 	char **batteries;
 	int num_batteries;
 
+	int charging_restart_interval;
+
+	int chg_ref_current_ma;
+
 	/* Callbacks */
 	void (*probe_done)(struct pcf50633 *);
 	void (*mbc_event_callback)(struct pcf50633 *, int);
@@ -206,7 +210,8 @@
 };
 
 /* misc. registers */
-#define PCF50633_REG_OOCSHDWN	0x0c
+#define PCF50633_REG_OOCSHDWN		0x0c
+#define PCF50633_OOCSHDWN_GOSTDBY 	0x01
 
 /* LED registers */
 #define PCF50633_REG_LEDOUT 0x28
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50633/mbc.h linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50633/mbc.h
--- linux-2.6.29-rc3.owrt/include/linux/mfd/pcf50633/mbc.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/mfd/pcf50633/mbc.h	2009-05-10 22:28:00.000000000 +0200
@@ -128,7 +128,5 @@
 int pcf50633_mbc_usb_curlim_set(struct pcf50633 *pcf, int ma);
 
 int pcf50633_mbc_get_status(struct pcf50633 *);
-void pcf50633_mbc_set_status(struct pcf50633 *, int what, int status);
-
 #endif
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mmc/core.h linux-2.6.29-rc3.owrt.om/include/linux/mmc/core.h
--- linux-2.6.29-rc3.owrt/include/linux/mmc/core.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/mmc/core.h	2009-05-10 22:28:00.000000000 +0200
@@ -129,6 +129,8 @@
 struct mmc_host;
 struct mmc_card;
 
+extern void mmc_flush_scheduled_work(void);
+
 extern void mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
 extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
 extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mmc/sdio_ids.h linux-2.6.29-rc3.owrt.om/include/linux/mmc/sdio_ids.h
--- linux-2.6.29-rc3.owrt/include/linux/mmc/sdio_ids.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/mmc/sdio_ids.h	2009-05-10 22:28:00.000000000 +0200
@@ -25,5 +25,9 @@
 
 #define SDIO_VENDOR_ID_MARVELL			0x02df
 #define SDIO_DEVICE_ID_MARVELL_LIBERTAS		0x9103
+#define SDIO_DEVICE_ID_MARVELL_88W8688		0x9104
+#define SDIO_VENDOR_ID_ATHEROS			0x0271
+#define SDIO_DEVICE_ID_ATHEROS_AR6001		0x0100
+#define SDIO_DEVICE_ID_ATHEROS_AR6002		0x0200
 
 #endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/mm.h linux-2.6.29-rc3.owrt.om/include/linux/mm.h
--- linux-2.6.29-rc3.owrt/include/linux/mm.h	2009-05-10 22:09:07.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/mm.h	2009-05-10 22:28:00.000000000 +0200
@@ -725,7 +725,7 @@
 }
 #endif
 struct file *shmem_file_setup(char *name, loff_t size, unsigned long flags);
-
+void shmem_set_file(struct vm_area_struct *, struct file *);
 int shmem_zero_setup(struct vm_area_struct *);
 
 #ifndef CONFIG_MMU
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/neo1973_vibrator.h linux-2.6.29-rc3.owrt.om/include/linux/neo1973_vibrator.h
--- linux-2.6.29-rc3.owrt/include/linux/neo1973_vibrator.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/neo1973_vibrator.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,5 @@
+struct neo1973_vib_platform_data {
+	int (* enable_fiq)(void);
+	void (*disable_fiq)(void);
+	void (*kick_fiq)(void);
+};
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/pcap7200.h linux-2.6.29-rc3.owrt.om/include/linux/pcap7200.h
--- linux-2.6.29-rc3.owrt/include/linux/pcap7200.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/pcap7200.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,25 @@
+#ifndef _LINUX_PCPA7200_H
+#define _LINUX_PCPA7200_H
+
+enum op_mode {
+	SLEEP,
+	WAKEUP,
+	SINGLE_TOUCH,
+	MULTI_TOUCH,
+};
+
+enum gesture {
+	ZOOM,
+	FST_ZOOM,
+	SND_ZOOM,
+	ROTATE,
+	FST_SLIDE,
+	SND_SLIDE,
+};
+
+struct pcap7200_platform_data {
+	enum op_mode mode;
+	void (*reset)(void);
+};
+
+#endif 	/* _LINUX_PCPA7200_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/pcf50606.h linux-2.6.29-rc3.owrt.om/include/linux/pcf50606.h
--- linux-2.6.29-rc3.owrt/include/linux/pcf50606.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/pcf50606.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,91 @@
+#ifndef _LINUX_PCF50606_H
+#define _LINUX_PCF50606_H
+
+#include <linux/pcf506xx.h>
+
+
+/* public in-kernel pcf50606 api */
+enum pcf50606_regulator_id {
+	PCF50606_REGULATOR_DCD,
+	PCF50606_REGULATOR_DCDE,
+	PCF50606_REGULATOR_DCUD,
+	PCF50606_REGULATOR_D1REG,
+	PCF50606_REGULATOR_D2REG,
+	PCF50606_REGULATOR_D3REG,
+	PCF50606_REGULATOR_LPREG,
+	PCF50606_REGULATOR_IOREG,
+	__NUM_PCF50606_REGULATORS
+};
+
+struct pcf50606_data;
+
+/* This is an ugly construct on how to access the (currently single/global)
+ * pcf50606 handle from other code in the kernel.  I didn't really come up with
+ * a more decent method of dynamically resolving this */
+extern struct pcf50606_data *pcf50606_global;
+
+extern void
+pcf50606_go_standby(void);
+
+extern void
+pcf50606_gpo0_set(struct pcf50606_data *pcf, int on);
+
+extern int
+pcf50606_gpo0_get(struct pcf50606_data *pcf);
+
+extern int
+pcf50606_voltage_set(struct pcf50606_data *pcf,
+		     enum pcf50606_regulator_id reg,
+		     unsigned int millivolts);
+extern unsigned int
+pcf50606_voltage_get(struct pcf50606_data *pcf,
+		     enum pcf50606_regulator_id reg);
+extern int
+pcf50606_onoff_get(struct pcf50606_data *pcf,
+		   enum pcf50606_regulator_id reg);
+
+extern int
+pcf50606_onoff_set(struct pcf50606_data *pcf,
+		   enum pcf50606_regulator_id reg, int on);
+
+extern void
+pcf50606_charge_fast(struct pcf50606_data *pcf, int on);
+
+
+#define PCF50606_FEAT_EXTON	0x00000001	/* not yet supported */
+#define PCF50606_FEAT_MBC	0x00000002
+#define PCF50606_FEAT_BBC	0x00000004	/* not yet supported */
+#define PCF50606_FEAT_TSC	0x00000008	/* not yet supported */
+#define PCF50606_FEAT_WDT	0x00000010
+#define PCF50606_FEAT_ACD	0x00000020
+#define PCF50606_FEAT_RTC	0x00000040
+#define PCF50606_FEAT_PWM	0x00000080
+#define PCF50606_FEAT_CHGCUR	0x00000100
+#define PCF50606_FEAT_BATVOLT	0x00000200
+#define PCF50606_FEAT_BATTEMP	0x00000400
+#define PCF50606_FEAT_PWM_BL	0x00000800
+
+struct pcf50606_platform_data {
+	/* general */
+	unsigned int used_features;
+	unsigned int onkey_seconds_required;
+
+	/* voltage regulator related */
+	struct pmu_voltage_rail rails[__NUM_PCF50606_REGULATORS];
+	unsigned int used_regulators;
+
+	/* charger related */
+	unsigned int r_fix_batt;
+	unsigned int r_fix_batt_par;
+	unsigned int r_sense_milli;
+
+	/* backlight related */
+	unsigned int init_brightness;
+
+	struct {
+		u_int8_t mbcc3; /* charger voltage / current */
+	} charger;
+	pmu_cb cb;
+};
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/pcf50633.h linux-2.6.29-rc3.owrt.om/include/linux/pcf50633.h
--- linux-2.6.29-rc3.owrt/include/linux/pcf50633.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/pcf50633.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,176 @@
+#ifndef _LINUX_PCF50633_H
+#define _LINUX_PCF50633_H
+
+#include <linux/pcf506xx.h>
+#include <linux/regulator/machine.h>
+
+
+/* public in-kernel pcf50633 api */
+enum pcf50633_regulator_id {
+	PCF50633_REGULATOR_AUTO,
+	PCF50633_REGULATOR_DOWN1,
+	PCF50633_REGULATOR_DOWN2,
+	PCF50633_REGULATOR_MEMLDO,
+	PCF50633_REGULATOR_LDO1,
+	PCF50633_REGULATOR_LDO2,
+	PCF50633_REGULATOR_LDO3,
+	PCF50633_REGULATOR_LDO4,
+	PCF50633_REGULATOR_LDO5,
+	PCF50633_REGULATOR_LDO6,
+	PCF50633_REGULATOR_HCLDO,
+	__NUM_PCF50633_REGULATORS
+};
+
+enum pcf50633_reg_int1 {
+	PCF50633_INT1_ADPINS	= 0x01,	/* Adapter inserted */
+	PCF50633_INT1_ADPREM	= 0x02,	/* Adapter removed */
+	PCF50633_INT1_USBINS	= 0x04,	/* USB inserted */
+	PCF50633_INT1_USBREM	= 0x08,	/* USB removed */
+	/* reserved */
+	PCF50633_INT1_ALARM	= 0x40, /* RTC alarm time is reached */
+	PCF50633_INT1_SECOND	= 0x80,	/* RTC periodic second interrupt */
+};
+
+enum pcf50633_reg_int2 {
+	PCF50633_INT2_ONKEYR	= 0x01, /* ONKEY rising edge */
+	PCF50633_INT2_ONKEYF	= 0x02, /* ONKEY falling edge */
+	PCF50633_INT2_EXTON1R	= 0x04, /* EXTON1 rising edge */
+	PCF50633_INT2_EXTON1F	= 0x08, /* EXTON1 falling edge */
+	PCF50633_INT2_EXTON2R	= 0x10, /* EXTON2 rising edge */
+	PCF50633_INT2_EXTON2F	= 0x20, /* EXTON2 falling edge */
+	PCF50633_INT2_EXTON3R	= 0x40, /* EXTON3 rising edge */
+	PCF50633_INT2_EXTON3F	= 0x80, /* EXTON3 falling edge */
+};
+
+enum pcf50633_reg_int3 {
+	PCF50633_INT3_BATFULL	= 0x01, /* Battery full */
+	PCF50633_INT3_CHGHALT	= 0x02,	/* Charger halt */
+	PCF50633_INT3_THLIMON	= 0x04,
+	PCF50633_INT3_THLIMOFF	= 0x08,
+	PCF50633_INT3_USBLIMON	= 0x10,
+	PCF50633_INT3_USBLIMOFF	= 0x20,
+	PCF50633_INT3_ADCRDY	= 0x40,	/* ADC conversion finished */
+	PCF50633_INT3_ONKEY1S	= 0x80,	/* ONKEY pressed 1 second */
+};
+
+enum pcf50633_reg_int4 {
+	PCF50633_INT4_LOWSYS		= 0x01,
+	PCF50633_INT4_LOWBAT		= 0x02,
+	PCF50633_INT4_HIGHTMP		= 0x04,
+	PCF50633_INT4_AUTOPWRFAIL	= 0x08,
+	PCF50633_INT4_DWN1PWRFAIL	= 0x10,
+	PCF50633_INT4_DWN2PWRFAIL	= 0x20,
+	PCF50633_INT4_LEDPWRFAIL	= 0x40,
+	PCF50633_INT4_LEDOVP		= 0x80,
+};
+
+enum pcf50633_reg_int5 {
+	PCF50633_INT5_LDO1PWRFAIL	= 0x01,
+	PCF50633_INT5_LDO2PWRFAIL	= 0x02,
+	PCF50633_INT5_LDO3PWRFAIL	= 0x04,
+	PCF50633_INT5_LDO4PWRFAIL	= 0x08,
+	PCF50633_INT5_LDO5PWRFAIL	= 0x10,
+	PCF50633_INT5_LDO6PWRFAIL	= 0x20,
+	PCF50633_INT5_HCLDOPWRFAIL	= 0x40,
+	PCF50633_INT5_HCLDOOVL		= 0x80,
+};
+
+struct pcf50633_data;
+extern struct pcf50633_data *pcf50633_global;
+
+extern void
+pcf50633_go_standby(void);
+
+enum pcf50633_gpio {
+	PCF50633_GPIO1 = 1,
+	PCF50633_GPIO2 = 2,
+	PCF50633_GPIO3 = 3,
+	PCF50633_GPO = 4,
+};
+
+extern void
+pcf50633_gpio_set(struct pcf50633_data *pcf, enum pcf50633_gpio gpio, int on);
+
+extern int
+pcf50633_gpio_get(struct pcf50633_data *pcf, enum pcf50633_gpio gpio);
+
+extern int
+pcf50633_voltage_set(struct pcf50633_data *pcf,
+		     enum pcf50633_regulator_id reg,
+		     unsigned int millivolts);
+extern unsigned int
+pcf50633_voltage_get(struct pcf50633_data *pcf,
+		     enum pcf50633_regulator_id reg);
+
+extern int
+pcf50633_onoff_get(struct pcf50633_data *pcf,
+		   enum pcf50633_regulator_id reg);
+
+extern int
+pcf50633_onoff_set(struct pcf50633_data *pcf,
+		   enum pcf50633_regulator_id reg, int on);
+
+extern void
+pcf50633_backlight_resume(struct pcf50633_data *pcf);
+
+extern u_int16_t
+pcf50633_battvolt(struct pcf50633_data *pcf);
+
+extern int
+pcf50633_report_resumers(struct pcf50633_data *pcf, char *buf);
+
+extern int
+pcf50633_notify_usb_current_limit_change(struct pcf50633_data *pcf,
+							       unsigned int ma);
+extern int
+pcf50633_wait_for_ready(struct pcf50633_data *pcf, int timeout_ms,
+								char *name);
+
+/* 0 = initialized and resumed and ready to roll, !=0 = either not
+ * initialized or not resumed yet
+ */
+extern int
+pcf50633_ready(struct pcf50633_data *pcf);
+
+#define PCF50633_FEAT_EXTON	0x00000001	/* not yet supported */
+#define PCF50633_FEAT_MBC	0x00000002
+#define PCF50633_FEAT_BBC	0x00000004	/* not yet supported */
+#define PCF50633_FEAT_RTC	0x00000040
+#define PCF50633_FEAT_CHGCUR	0x00000100
+#define PCF50633_FEAT_BATVOLT	0x00000200
+#define PCF50633_FEAT_BATTEMP	0x00000400
+#define PCF50633_FEAT_PWM_BL	0x00000800
+
+struct pcf50633_platform_data {
+	/* general */
+	unsigned int used_features;
+	unsigned int onkey_seconds_sig_init;
+	unsigned int onkey_seconds_shutdown;
+
+	/* callback to attach platform children (to enforce suspend / resume
+	 * ordering */
+	void (*attach_child_devices)(struct device *parent_device);
+
+	/* voltage regulator related */
+	struct pmu_voltage_rail rails[__NUM_PCF50633_REGULATORS];
+	unsigned int used_regulators;
+
+	/* charger related */
+	unsigned int r_fix_batt;
+	unsigned int r_fix_batt_par;
+	unsigned int r_sense_milli;
+	int flag_use_apm_emulation;
+
+	unsigned char resumers[5];
+
+	struct {
+		u_int8_t mbcc3; /* charger voltage / current */
+	} charger;
+	pmu_cb cb;
+
+	/* post-resume backlight bringup */
+	int defer_resume_backlight;
+	u8 resume_backlight_ramp_speed;
+};
+
+#endif /* _PCF50633_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/pcf506xx.h linux-2.6.29-rc3.owrt.om/include/linux/pcf506xx.h
--- linux-2.6.29-rc3.owrt/include/linux/pcf506xx.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/pcf506xx.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,34 @@
+#ifndef _LINUX_PCF506XX_H
+#define _LINUX_PCF506XX_H
+
+
+#define PMU_VRAIL_F_SUSPEND_ON	0x00000001	/* Remains on during suspend */
+#define PMU_VRAIL_F_UNUSED	0x00000002	/* This rail is not used */
+struct pmu_voltage_rail {
+	char *name;
+	unsigned int flags;
+	struct {
+		unsigned int init;
+		unsigned int max;
+	} voltage;
+};
+
+enum pmu_event {
+	PMU_EVT_NONE,
+	PMU_EVT_INSERT,
+	PMU_EVT_REMOVE,
+#ifdef CONFIG_SENSORS_PCF50633
+	PMU_EVT_USB_INSERT,
+	PMU_EVT_USB_REMOVE,
+#endif
+	PMU_EVT_CHARGER_ACTIVE,
+	PMU_EVT_CHARGER_IDLE,
+	PMU_EVT_CHARGER_CHANGE,
+	__NUM_PMU_EVTS
+};
+
+typedef int (*pmu_cb)(struct device *dev, unsigned int feature,
+		   enum pmu_event event);
+
+
+#endif /* !_LINUX_PCF506XX_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/resume-dependency.h linux-2.6.29-rc3.owrt.om/include/linux/resume-dependency.h
--- linux-2.6.29-rc3.owrt/include/linux/resume-dependency.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/resume-dependency.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,114 @@
+#ifndef __RESUME_DEPENDENCY_H__
+#define __RESUME_DEPENDENCY_H__
+
+/* Resume dependency framework
+ *
+ * (C) 2008 Openmoko, Inc.
+ * Author: Andy Green <andy@openmoko.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; version 2.1.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <linux/list.h>
+
+struct resume_dependency {
+	struct list_head list;
+
+	void (*callback)(void *); /* called with context as arg */
+	void * context;
+	int called_flag; /* set to 1 after called, use for multi dep */
+};
+
+/* if you are a driver accept to have other drivers as dependencies, you need to
+ * instantiate a struct resume_dependency above, then initialize it by invoking
+ * init_resume_dependency_list() on it
+ */
+
+#define init_resume_dependency_list(_head) \
+	printk(KERN_INFO "##### init_resume_dependency_list(head=%p)\n", (_head)); \
+	INIT_LIST_HEAD(&(_head)->list);
+
+
+/* if your resume function depends on something else being resumed first, you
+ * can register the dependency by calling this in your suspend function with
+ * head being the list held by the thing you are dependent on, and dep being
+ * your struct resume_dependency
+ */
+
+#define register_resume_dependency(_head, _dep) { \
+	struct list_head *_pos, *_q; \
+	struct resume_dependency *_d; \
+\
+	printk(KERN_ERR "##### register_resume_dependency(head=%p, dep=%p)\n", (_head), (_dep)); \
+	(_dep)->called_flag = 1; \
+	list_for_each_safe(_pos, _q, &((_head)->list)) { \
+		_d = list_entry(_pos, struct resume_dependency, list); \
+		if (_d == (_dep)) { \
+			list_del(_pos); \
+			printk(KERN_ERR "#####   duplicate dependency removed first\n"); \
+		} \
+	} \
+	list_add(&(_dep)->list, &(_head)->list); \
+}
+
+/* In the resume function that things can be dependent on, at the end you
+ * invoke this macro.  This calls back the dependent resumes now it is safe to
+ * use the resumed thing they were dependent on.
+ */
+
+#define callback_all_resume_dependencies(_head) { \
+	struct list_head *_pos, *_q; \
+	struct resume_dependency *_dep; \
+\
+	printk(KERN_ERR "##### callback_all_resume_dependencies(head=%p)\n", (_head)); \
+	list_for_each_safe(_pos, _q, &((_head)->list)) { \
+		_dep = list_entry(_pos, struct resume_dependency, list); \
+		printk(KERN_ERR "#####   callback list entry (head=%p, dep=%p)\n", (_head), (_dep)); \
+		_dep->called_flag = 1; \
+		printk(KERN_ERR "#####      callback=%p(context=%p))\n", (_dep->callback),(_dep->context)); \
+		(_dep->callback)(_dep->context); \
+		list_del(_pos); \
+	} \
+}
+
+/* When a dependency is added, it is not actually active; the dependent resume
+ * handler will function as normal.  The dependency is activated by the suspend
+ * handler for the driver that will be doing the callbacks.  This ensures that
+ * if the suspend is aborted for any reason (error, driver busy, etc), that all
+ * suspended drivers will resume, even if the driver upon which they are dependent
+ * did not suspend, and hence will not resume, and thus would be unable to perform
+ * the callbacks.
+ */
+
+#define activate_all_resume_dependencies(_head) { \
+	struct list_head *_pos, *_q; \
+	struct resume_dependency *_dep; \
+\
+	printk(KERN_ERR "##### activate_all_resume_dependencies(head=%p)\n", (_head)); \
+	list_for_each_safe(_pos, _q, &((_head)->list)) { \
+		_dep = list_entry(_pos, struct resume_dependency, list); \
+		printk(KERN_ERR "#####   activating callback list entry (head=%p, dep=%p)\n", (_head), (_dep)); \
+		_dep->called_flag = 0; \
+	} \
+}
+
+/* if your resume action is dependent on multiple drivers being resumed already,
+ * register the same callback with each driver you are dependent on, and check
+ * .called_flag for all of the struct resume_dependency.  When they are all 1
+ * you know it is the last callback and you can resume, otherwise just return
+ */
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/rtc/pcf50633.h linux-2.6.29-rc3.owrt.om/include/linux/rtc/pcf50633.h
--- linux-2.6.29-rc3.owrt/include/linux/rtc/pcf50633.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/rtc/pcf50633.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,9 @@
+enum pcf50633_rtc_event {
+        PCF50633_RTC_EVENT_ALARM,
+        PCF50633_RTC_EVENT_SECOND,
+};
+
+extern void pcf50633_rtc_handle_event(struct pcf50633_data *pcf,
+                                        enum pcf50633_rtc_event evt);
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/spi/glamo.h linux-2.6.29-rc3.owrt.om/include/linux/spi/glamo.h
--- linux-2.6.29-rc3.owrt/include/linux/spi/glamo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/spi/glamo.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,27 @@
+#ifndef __GLAMO_SPI_H
+#define __GLAMO_SPI_H
+
+#include <linux/glamo-gpio.h>
+
+struct spi_board_info;
+struct glamofb_handle;
+struct glamo_core;
+
+struct glamo_spi_info {
+	unsigned long 		board_size;
+	struct spi_board_info	*board_info;
+	struct glamofb_handle	*glamofb_handle;
+};
+
+struct glamo_spigpio_info {
+	unsigned int		pin_clk;
+	unsigned int		pin_mosi;
+	unsigned int		pin_miso;
+	unsigned int 		pin_cs;
+	int 			bus_num;
+
+	struct glamo_core	*glamo;
+};
+
+
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/spi/spi_bitbang.h linux-2.6.29-rc3.owrt.om/include/linux/spi/spi_bitbang.h
--- linux-2.6.29-rc3.owrt/include/linux/spi/spi_bitbang.h	2009-05-10 22:09:08.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/spi/spi_bitbang.h	2009-05-10 22:28:00.000000000 +0200
@@ -31,6 +31,9 @@
 	u8			use_dma;
 	u8			flags;		/* extra spi->mode support */
 
+	/* Support for synchronous non blocking transfers */
+	int 			non_blocking_transfer; 
+
 	struct spi_master	*master;
 
 	/* setup_transfer() changes clock and/or wordsize to match settings
@@ -62,6 +65,8 @@
 extern int spi_bitbang_transfer(struct spi_device *spi, struct spi_message *m);
 extern int spi_bitbang_setup_transfer(struct spi_device *spi,
 				      struct spi_transfer *t);
+extern int spi_bitbang_transfer_sync(struct spi_device *spi,
+				      struct spi_message *m);
 
 /* start or stop queue processing */
 extern int spi_bitbang_start(struct spi_bitbang *spi);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/spi/spi.h linux-2.6.29-rc3.owrt.om/include/linux/spi/spi.h
--- linux-2.6.29-rc3.owrt/include/linux/spi/spi.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/spi/spi.h	2009-05-10 22:28:00.000000000 +0200
@@ -264,6 +264,13 @@
 	int			(*transfer)(struct spi_device *spi,
 						struct spi_message *mesg);
 
+	/* 
+	 * Synchronous non blocking transfer function. Should guarantee
+	 * data availability when it returns 
+	 */
+	int			(*transfer_sync)(struct spi_device *spi,
+						struct spi_message *mesg);
+
 	/* called on release() to free memory provided by spi_master */
 	void			(*cleanup)(struct spi_device *spi);
 };
@@ -573,6 +580,29 @@
 	return spi->master->transfer(spi, message);
 }
 
+/**
+ * spi_non_blocking_transfer - Synchronous, non blocking transfer
+ * @spi: device with which data will be exchanged
+ * @message: describes the data transfers with optional completion handlers
+ * Context: any (irqs may be blocked, etc)
+ *
+ * Data is guaranteed to be written or read when this function returns.
+ *
+ * Note : This may not be supported by all spi masters.
+ */
+
+static inline int
+spi_non_blocking_transfer(struct spi_device *spi, struct spi_message *message)
+{
+	if (unlikely(!spi->master->transfer_sync)) {
+		dev_err(&spi->master->dev,
+			       	"non-blocking transfers not supported\n");
+		return -EIO;
+	}
+
+	return spi->master->transfer_sync(spi, message);
+}
+
 /*---------------------------------------------------------------------------*/
 
 /* All these synchronous SPI transfer routines are utilities layered
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/suspend.h linux-2.6.29-rc3.owrt.om/include/linux/suspend.h
--- linux-2.6.29-rc3.owrt/include/linux/suspend.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/suspend.h	2009-05-10 22:28:00.000000000 +0200
@@ -146,6 +146,12 @@
 	struct pbe *next;
 };
 
+/**
+ * global indication we are somewhere between start of suspend and end of
+ * resume, nonzero is true
+ */
+extern int global_inside_suspend;
+
 /* mm/page_alloc.c */
 extern void mark_free_pages(struct zone *zone);
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/vt.h linux-2.6.29-rc3.owrt.om/include/linux/vt.h
--- linux-2.6.29-rc3.owrt/include/linux/vt.h	2009-05-10 22:04:47.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/linux/vt.h	2009-05-10 22:28:00.000000000 +0200
@@ -18,8 +18,19 @@
  * resizing).
  */
 #define MIN_NR_CONSOLES 1       /* must be at least 1 */
+#if (CONFIG_NR_TTY_DEVICES < 4)
+/* Lower Limit */
+#define MAX_NR_CONSOLES	4	/* serial lines start at 64 */
+#define MAX_NR_USER_CONSOLES 4	/* must be root to allocate above this */
+#elif (CONFIG_NR_TTY_DEVICES > 63)
+/* Upper Limit */
 #define MAX_NR_CONSOLES	63	/* serial lines start at 64 */
 #define MAX_NR_USER_CONSOLES 63	/* must be root to allocate above this */
+#else
+/* They chose a sensible number */
+#define MAX_NR_CONSOLES CONFIG_NR_TTY_DEVICES
+#define MAX_NR_USER_CONSOLES CONFIG_NR_TTY_DEVICES
+#endif
 		/* Note: the ioctl VT_GETSTATE does not work for
 		   consoles 16 and higher (since it returns a short) */
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/linux/wakelock.h linux-2.6.29-rc3.owrt.om/include/linux/wakelock.h
--- linux-2.6.29-rc3.owrt/include/linux/wakelock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/include/linux/wakelock.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,91 @@
+/* include/linux/wakelock.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_WAKELOCK_H
+#define _LINUX_WAKELOCK_H
+
+#include <linux/list.h>
+#include <linux/ktime.h>
+
+/* A wake_lock prevents the system from entering suspend or other low power
+ * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
+ * prevents a full system suspend. If the type is WAKE_LOCK_IDLE, low power
+ * states that cause large interrupt latencies or that disable a set of
+ * interrupts will not entered from idle until the wake_locks are released.
+ */
+
+enum {
+	WAKE_LOCK_SUSPEND, /* Prevent suspend */
+	WAKE_LOCK_IDLE,    /* Prevent low power idle */
+	WAKE_LOCK_TYPE_COUNT
+};
+
+struct wake_lock {
+#ifdef CONFIG_ANDROID_HAS_WAKELOCK
+	struct list_head    link;
+	int                 flags;
+	const char         *name;
+	unsigned long       expires;
+#ifdef CONFIG_ANDROID_WAKELOCK_STAT
+	struct {
+		int             count;
+		int             expire_count;
+		int             wakeup_count;
+		ktime_t         total_time;
+		ktime_t         prevent_suspend_time;
+		ktime_t         max_time;
+		ktime_t         last_time;
+	} stat;
+#endif
+#endif
+};
+
+#ifdef CONFIG_ANDROID_HAS_WAKELOCK
+
+void wake_lock_init(struct wake_lock *lock, int type, const char *name);
+void wake_lock_destroy(struct wake_lock *lock);
+void wake_lock(struct wake_lock *lock);
+void wake_lock_timeout(struct wake_lock *lock, long timeout);
+void wake_unlock(struct wake_lock *lock);
+
+/* wake_lock_active returns a non-zero value if the wake_lock is currently
+ * locked. If the wake_lock has a timeout, it does not check the timeout
+ * but if the timeout had aready been checked it will return 0.
+ */
+int wake_lock_active(struct wake_lock *lock);
+
+/* has_wake_lock returns 0 if no wake locks of the specified type are active,
+ * and non-zero if one or more wake locks are held. Specifically it returns
+ * -1 if one or more wake locks with no timeout are active or the
+ * number of jiffies until all active wake locks time out.
+ */
+long has_wake_lock(int type);
+
+#else
+
+static inline void wake_lock_init(struct wake_lock *lock, int type,
+					const char *name) {}
+static inline void wake_lock_destroy(struct wake_lock *lock) {}
+static inline void wake_lock(struct wake_lock *lock) {}
+static inline void wake_lock_timeout(struct wake_lock *lock, long timeout) {}
+static inline void wake_unlock(struct wake_lock *lock) {}
+
+static inline int wake_lock_active(struct wake_lock *lock) { return 0; }
+static inline long has_wake_lock(int type) { return 0; }
+
+#endif
+
+#endif
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/include/sound/soc-dapm.h linux-2.6.29-rc3.owrt.om/include/sound/soc-dapm.h
--- linux-2.6.29-rc3.owrt/include/sound/soc-dapm.h	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/include/sound/soc-dapm.h	2009-05-10 22:28:00.000000000 +0200
@@ -182,6 +182,15 @@
 	.get = snd_soc_dapm_get_value_enum_double, \
 	.put = snd_soc_dapm_put_value_enum_double, \
 	.private_value = (unsigned long)&xenum }
+/* NOTE: Openmoko-specific "DAPM " prefix added to controls for
+ * backwards compatibility.
+ */
+#define SOC_DAPM_PIN_SWITCH(xname) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = "DAPM " xname " Switch", \
+	.info = snd_soc_dapm_info_pin_switch, \
+	.get = snd_soc_dapm_get_pin_switch, \
+	.put = snd_soc_dapm_put_pin_switch, \
+	.private_value = (unsigned long)xname }
 
 /* dapm stream operations */
 #define SND_SOC_DAPM_STREAM_NOP			0x0
@@ -228,6 +237,12 @@
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_dapm_put_value_enum_double(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_dapm_info_pin_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo);
+int snd_soc_dapm_get_pin_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *uncontrol);
+int snd_soc_dapm_put_pin_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *uncontrol);
 int snd_soc_dapm_new_control(struct snd_soc_codec *codec,
 	const struct snd_soc_dapm_widget *widget);
 int snd_soc_dapm_new_controls(struct snd_soc_codec *codec,
@@ -250,12 +265,19 @@
 int snd_soc_dapm_sys_add(struct device *dev);
 
 /* dapm audio pin control and status */
-int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, char *pin);
-int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, char *pin);
-int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, char *pin);
-int snd_soc_dapm_get_pin_status(struct snd_soc_codec *codec, char *pin);
+int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, const char *pin);
+int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, const char *pin);
+int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, const char *pin);
+int snd_soc_dapm_get_pin_status(struct snd_soc_codec *codec, const char *pin);
 int snd_soc_dapm_sync(struct snd_soc_codec *codec);
 
+/* dapm audio endpoint control */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+	char *pin, int status);
+int snd_soc_dapm_get_endpoint(struct snd_soc_codec *codec,
+	char *pin);
+int snd_soc_dapm_sync_endpoints(struct snd_soc_codec *codec);
+
 /* dapm widget types */
 enum snd_soc_dapm_type {
 	snd_soc_dapm_input = 0,		/* input pin */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/init/Kconfig linux-2.6.29-rc3.owrt.om/init/Kconfig
--- linux-2.6.29-rc3.owrt/init/Kconfig	2009-05-10 22:09:09.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/init/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -869,6 +869,15 @@
           by some high performance threaded applications. Disabling
           this option saves about 7k.
 
+config ASHMEM
+	bool "Enable Android's Shared Memory Subsystem"
+	default n
+	depends on SHMEM || TINY_SHMEM
+	help
+	  The ashmem subsystem is a new shared memory allocator, similar to
+	  POSIX SHM but with different behavior and sporting a simpler
+	  file-based API.
+
 config VM_EVENT_COUNTERS
 	default y
 	bool "Enable VM event counters for /proc/vmstat" if EMBEDDED
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/kernel/irq/chip.c linux-2.6.29-rc3.owrt.om/kernel/irq/chip.c
--- linux-2.6.29-rc3.owrt/kernel/irq/chip.c	2009-05-10 22:09:09.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/kernel/irq/chip.c	2009-05-10 22:28:00.000000000 +0200
@@ -383,6 +383,7 @@
 out_unlock:
 	spin_unlock(&desc->lock);
 }
+EXPORT_SYMBOL(handle_level_irq);
 
 /**
  *	handle_fasteoi_irq - irq handler for transparent controllers
@@ -593,6 +594,7 @@
 	}
 	spin_unlock_irqrestore(&desc->lock, flags);
 }
+EXPORT_SYMBOL(__set_irq_handler);
 
 void
 set_irq_chip_and_handler(unsigned int irq, struct irq_chip *chip,
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/kernel/power/main.c linux-2.6.29-rc3.owrt.om/kernel/power/main.c
--- linux-2.6.29-rc3.owrt/kernel/power/main.c	2009-05-10 22:09:09.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/kernel/power/main.c	2009-05-10 22:28:00.000000000 +0200
@@ -131,6 +131,9 @@
 
 #endif /* CONFIG_PM_SLEEP */
 
+int global_inside_suspend;
+EXPORT_SYMBOL(global_inside_suspend);
+
 #ifdef CONFIG_SUSPEND
 
 #ifdef CONFIG_PM_TEST_SUSPEND
@@ -321,6 +324,8 @@
 	if (!suspend_ops)
 		return -ENOSYS;
 
+	global_inside_suspend = 1;
+
 	if (suspend_ops->begin) {
 		error = suspend_ops->begin(state);
 		if (error)
@@ -362,6 +367,8 @@
  Close:
 	if (suspend_ops->end)
 		suspend_ops->end();
+	global_inside_suspend = 0;
+
 	return error;
 
  Recover_platform:
@@ -388,6 +395,9 @@
 
 
 static const char * const pm_states[PM_SUSPEND_MAX] = {
+#ifdef CONFIG_ANDROID_EARLYSUSPEND
+	[PM_SUSPEND_ON]		= "on",
+#endif
 	[PM_SUSPEND_STANDBY]	= "standby",
 	[PM_SUSPEND_MEM]	= "mem",
 };
@@ -424,6 +434,8 @@
 		return -EBUSY;
 
 	printk(KERN_INFO "PM: Syncing filesystems ... ");
+	global_inside_suspend = 1;
+
 	sys_sync();
 	printk("done.\n");
 
@@ -505,7 +517,11 @@
 			   const char *buf, size_t n)
 {
 #ifdef CONFIG_SUSPEND
+#ifdef CONFIG_ANDROID_EARLYSUSPEND
+	suspend_state_t state = PM_SUSPEND_ON;
+#else
 	suspend_state_t state = PM_SUSPEND_STANDBY;
+#endif
 	const char * const *s;
 #endif
 	char *p;
@@ -527,8 +543,15 @@
 			break;
 	}
 	if (state < PM_SUSPEND_MAX && *s)
+#ifdef CONFIG_ANDROID_EARLYSUSPEND
+		if (state == PM_SUSPEND_ON || valid_state(state)) {
+			error = 0;
+			request_suspend_state(state);
+		}
+#else
 		error = enter_state(state);
 #endif
+#endif
 
  Exit:
 	return error ? error : n;
@@ -561,6 +584,12 @@
 power_attr(pm_trace);
 #endif /* CONFIG_PM_TRACE */
 
+#ifdef CONFIG_ANDROID_USER_WAKELOCK
+power_attr(wake_lock);
+power_attr(wake_full_lock);
+power_attr(wake_unlock);
+#endif
+
 static struct attribute * g[] = {
 	&state_attr.attr,
 #ifdef CONFIG_PM_TRACE
@@ -569,6 +598,11 @@
 #if defined(CONFIG_PM_SLEEP) && defined(CONFIG_PM_DEBUG)
 	&pm_test_attr.attr,
 #endif
+#ifdef CONFIG_ANDROID_USER_WAKELOCK
+	&wake_lock_attr.attr,
+	&wake_unlock_attr.attr,
+	&wake_full_lock_attr.attr,
+#endif
 	NULL,
 };
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/kernel/power/power.h linux-2.6.29-rc3.owrt.om/kernel/power/power.h
--- linux-2.6.29-rc3.owrt/kernel/power/power.h	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/kernel/power/power.h	2009-05-10 22:28:00.000000000 +0200
@@ -223,3 +223,32 @@
 {
 }
 #endif
+
+#ifdef CONFIG_ANDROID_WAKELOCK
+/* kernel/power/wakelock.c */
+extern struct workqueue_struct *suspend_work_queue;
+extern struct wake_lock main_wake_lock;
+extern suspend_state_t requested_suspend_state;
+#endif
+
+#ifdef CONFIG_ANDROID_USER_WAKELOCK
+ssize_t wake_lock_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+ssize_t wake_lock_store(struct kobject *kobj, struct kobj_attribute *attr,
+			const char *buf, size_t n);
+ssize_t wake_full_lock_store(struct kobject *kobj, struct kobj_attribute *attr,
+				const char *buf, size_t n);
+
+#define wake_full_lock_show wake_lock_show
+
+ssize_t wake_unlock_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf);
+ssize_t  wake_unlock_store(struct kobject *kobj, struct kobj_attribute *attr,
+			const char *buf, size_t n);
+#endif
+
+#ifdef CONFIG_ANDROID_EARLYSUSPEND
+/* kernel/power/earlysuspend.c */
+void request_suspend_state(suspend_state_t state);
+suspend_state_t get_suspend_state(void);
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/kernel/power/process.c linux-2.6.29-rc3.owrt.om/kernel/power/process.c
--- linux-2.6.29-rc3.owrt/kernel/power/process.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/kernel/power/process.c	2009-05-10 22:28:00.000000000 +0200
@@ -13,6 +13,7 @@
 #include <linux/module.h>
 #include <linux/syscalls.h>
 #include <linux/freezer.h>
+#include <linux/wakelock.h>
 
 /* 
  * Timeout for stopping processes
@@ -36,6 +37,7 @@
 	struct timeval start, end;
 	u64 elapsed_csecs64;
 	unsigned int elapsed_csecs;
+	unsigned int wakeup = 0;
 
 	do_gettimeofday(&start);
 
@@ -62,6 +64,10 @@
 		} while_each_thread(g, p);
 		read_unlock(&tasklist_lock);
 		yield();			/* Yield is okay here */
+		if (todo && has_wake_lock(WAKE_LOCK_SUSPEND)) {
+			wakeup = 1;
+			break;
+		}
 		if (time_after(jiffies, end_time))
 			break;
 	} while (todo);
@@ -77,11 +83,17 @@
 		 * and caller must call thaw_processes() if something fails),
 		 * but it cleans up leftover PF_FREEZE requests.
 		 */
-		printk("\n");
-		printk(KERN_ERR "Freezing of tasks failed after %d.%02d seconds "
+		if (wakeup) {
+			printk("\n");
+			printk(KERN_ERR "Freezing of %s aborted\n",
+				sig_only ? "user space " : "tasks ");
+		} else {
+			printk("\n");
+			printk(KERN_ERR "Freezing of tasks failed after %d.%02d seconds "
 				"(%d tasks refusing to freeze):\n",
 				elapsed_csecs / 100, elapsed_csecs % 100, todo);
-		show_state();
+			show_state();
+		}
 		read_lock(&tasklist_lock);
 		do_each_thread(g, p) {
 			task_lock(p);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/kernel/printk.c linux-2.6.29-rc3.owrt.om/kernel/printk.c
--- linux-2.6.29-rc3.owrt/kernel/printk.c	2009-05-10 22:09:09.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/kernel/printk.c	2009-05-10 22:28:00.000000000 +0200
@@ -32,8 +32,11 @@
 #include <linux/security.h>
 #include <linux/bootmem.h>
 #include <linux/syscalls.h>
+#include <linux/jiffies.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
+#include <asm/plat-s3c24xx/neo1973.h>
 
 /*
  * Architectures can override it:
@@ -67,13 +70,21 @@
 int oops_in_progress;
 EXPORT_SYMBOL(oops_in_progress);
 
+void (*printk_emergency_debug_spew_init)(void) = NULL;
+EXPORT_SYMBOL(printk_emergency_debug_spew_init);
+
+void (*printk_emergency_debug_spew_send_string)(const char *) = NULL;
+EXPORT_SYMBOL(printk_emergency_debug_spew_send_string);
+
 /*
  * console_sem protects the console_drivers list, and also
  * provides serialisation for access to the entire console
  * driver system.
  */
 static DECLARE_MUTEX(console_sem);
+#ifndef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
 static DECLARE_MUTEX(secondary_console_sem);
+#endif
 struct console *console_drivers;
 EXPORT_SYMBOL_GPL(console_drivers);
 
@@ -667,8 +678,39 @@
 	/* Emit the output into the temporary buffer */
 	printed_len += vscnprintf(printk_buf + printed_len,
 				  sizeof(printk_buf) - printed_len, fmt, args);
-
-
+#if defined(CONFIG_MACH_NEO1973_GTA02) && defined(CONFIG_PM)
+	/* if you're debugging resume, the normal methods can change resume
+	 * ordering behaviours because their debugging output is synchronous
+	 * (ie, CONFIG_DEBUG_LL).  If your problem is an OOPS, this code
+	 * will not affect the speed and duration and ordering of resume
+	 * actions, but will give you a chance to read the full undumped
+	 * syslog AND the OOPS data when it happens
+	 *
+	 * if you support it, your debug device init can override the exported
+	 * emergency_debug_spew_init and emergency_debug_spew_send_string to
+	 * usually force polling or bitbanging on your debug console device
+	 */
+	if (oops_in_progress && global_inside_suspend &&
+	    printk_emergency_debug_spew_init &&
+	    printk_emergency_debug_spew_send_string) {
+		unsigned long cur_index;
+		char ch[2];
+
+		if (global_inside_suspend == 1) {
+			(printk_emergency_debug_spew_init)();
+
+			ch[1] = '\0';
+			cur_index = con_start;
+			while (cur_index != log_end) {
+				ch[0] = LOG_BUF(cur_index);
+				(printk_emergency_debug_spew_send_string)(ch);
+				cur_index++;
+			}
+			global_inside_suspend++; /* only once */
+		}
+		(printk_emergency_debug_spew_send_string)(printk_buf);
+	}
+#endif
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
@@ -891,12 +933,18 @@
 	printk("Suspending console(s) (use no_console_suspend to debug)\n");
 	acquire_console_sem();
 	console_suspended = 1;
+#ifdef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
+	up(&console_sem);
+#endif
 }
 
 void resume_console(void)
 {
 	if (!console_suspend_enabled)
 		return;
+#ifdef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
+	down(&console_sem);
+#endif
 	console_suspended = 0;
 	release_console_sem();
 }
@@ -912,11 +960,17 @@
 void acquire_console_sem(void)
 {
 	BUG_ON(in_interrupt());
+#ifndef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
 	if (console_suspended) {
 		down(&secondary_console_sem);
 		return;
 	}
+#endif
 	down(&console_sem);
+#ifdef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
+	if (console_suspended)
+		return;
+#endif
 	console_locked = 1;
 	console_may_schedule = 1;
 }
@@ -926,6 +980,12 @@
 {
 	if (down_trylock(&console_sem))
 		return -1;
+#ifdef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
+	if (console_suspended) {
+		up(&console_sem);
+		return -1;
+	}
+#endif
 	console_locked = 1;
 	console_may_schedule = 0;
 	return 0;
@@ -979,7 +1039,11 @@
 	unsigned wake_klogd = 0;
 
 	if (console_suspended) {
+#ifdef CONFIG_ANDROID_CONSOLE_EARLYSUSPEND
+		up(&console_sem);
+#else
 		up(&secondary_console_sem);
+#endif
 		return;
 	}
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/kernel/timer.c linux-2.6.29-rc3.owrt.om/kernel/timer.c
--- linux-2.6.29-rc3.owrt/kernel/timer.c	2009-05-10 22:05:04.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/kernel/timer.c	2009-05-10 22:28:00.000000000 +0200
@@ -813,7 +813,6 @@
 	 * don't have to detach them individually.
 	 */
 	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
-		BUG_ON(tbase_get_base(timer->base) != base);
 		internal_add_timer(base, timer);
 	}
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/lib/Kconfig.debug linux-2.6.29-rc3.owrt.om/lib/Kconfig.debug
--- linux-2.6.29-rc3.owrt/lib/Kconfig.debug	2009-05-10 22:09:09.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/lib/Kconfig.debug	2009-05-10 22:28:00.000000000 +0200
@@ -847,6 +847,13 @@
 
 	  Say N if you are unsure.
 
+config FIND_IRQ_BLOCKERS
+        bool "IRQ Blocker statistics"
+	depends on ARM
+        ---help---
+          Enables tracking of IRQ dead-time because something has
+          disabled interrupts
+
 config DYNAMIC_PRINTK_DEBUG
 	bool "Enable dynamic printk() call support"
 	default n
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/MAINTAINERS linux-2.6.29-rc3.owrt.om/MAINTAINERS
--- linux-2.6.29-rc3.owrt/MAINTAINERS	2009-05-10 22:09:09.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/MAINTAINERS	2009-05-10 22:28:00.000000000 +0200
@@ -1711,6 +1711,20 @@
 P:	Matthew Wilcox
 M:	matthew@wil.cx
 L:	linux-fsdevel@vger.kernel.org
+
+FIC/OPENMOKO NEO1973 GSM PHONE
+P:	Harald Welte
+M:	laforge@openmoko.org
+L:	openmoko-kernel@lists.openmoko.org
+W:	http://wiki.openmoko.org/wiki/Kernel
+W:	http://wiki.openmoko.org/wiki/Neo1973
+S:	Maintained
+
+FRAMEBUFFER LAYER
+P:	Antonino Daplas
+M:	adaplas@gmail.com
+L:	linux-fbdev-devel@lists.sourceforge.net (moderated for non-subscribers)
+W:	http://linux-fbdev.sourceforge.net/
 S:	Maintained
 
 FILESYSTEMS (VFS and infrastructure)
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/makerecovery linux-2.6.29-rc3.owrt.om/makerecovery
--- linux-2.6.29-rc3.owrt/makerecovery	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/makerecovery	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,17 @@
+#!/bin/sh
+#
+# make 6MB recovery image from two moredrivers type kernels
+# placed at start and at +4MBytes
+
+if [ -z "$1" ] ; then
+ echo "Usage: $0 uImage-moredrivers-..."
+ exit 1
+fi
+cat $1 > recovery-$1
+SIZE=`ls -l $1 | tr -s ' ' ' ' | cut -d' ' -f5`
+SPACE=$(( 4 * 1024 * 1024 - $SIZE ))
+dd if=/dev/zero of=_spacer bs=1 count=$SPACE
+cat _spacer >> recovery-$1
+rm -f _spacer
+cat $1 >> recovery-$1
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/mm/ashmem.c linux-2.6.29-rc3.owrt.om/mm/ashmem.c
--- linux-2.6.29-rc3.owrt/mm/ashmem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/mm/ashmem.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,657 @@
+/* drivers/android/ashmem.c
+**
+** Android / Anonymous Shared Memory Subsystem, ashmem
+**
+** Copyright (C) 2008 Google, Inc.
+**
+** Robert Love <rlove@google.com>
+**
+** This software is licensed under the terms of the GNU General Public
+** License version 2, as published by the Free Software Foundation, and
+** may be copied, distributed, and modified under those terms.
+**
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+*/
+
+#include <linux/module.h>
+#include <linux/file.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/security.h>
+#include <linux/mm.h>
+#include <linux/mman.h>
+#include <linux/uaccess.h>
+#include <linux/personality.h>
+#include <linux/bitops.h>
+#include <linux/mutex.h>
+#include <linux/shmem_fs.h>
+#include <linux/ashmem.h>
+
+/*
+ * ashmem_area - android shared memory area
+ * Lifecycle: From our parent file's open() until its release()
+ * Locking: Protected by `ashmem_mutex'
+ * Big Note: Mappings do NOT pin this structure; it dies on close()
+ */
+struct ashmem_area {
+	char name[ASHMEM_NAME_LEN];	/* optional name for /proc/pid/maps */
+	struct list_head unpinned_list;	/* list of all ashmem areas */
+	struct file *file;		/* the shmem-based backing file */
+	size_t size;			/* size of the mapping, in bytes */
+	unsigned long prot_mask;	/* allowed prot bits, as vm_flags */
+};
+
+/*
+ * ashmem_range - represents an interval of unpinned (evictable) pages
+ * Lifecycle: From unpin to pin
+ * Locking: Protected by `ashmem_mutex'
+ */
+struct ashmem_range {
+	struct list_head lru;		/* entry in LRU list */
+	struct list_head unpinned;	/* entry in its area's unpinned list */
+	struct ashmem_area *asma;	/* associated area */
+	size_t pgstart;			/* starting page, inclusive */
+	size_t pgend;			/* ending page, inclusive */
+	unsigned int purged;		/* ASHMEM_NOT or ASHMEM_WAS_PURGED */
+};
+
+/* LRU list of unpinned pages, protected by ashmem_mutex */
+static LIST_HEAD(ashmem_lru_list);
+
+/* Count of pages on our LRU list, protected by ashmem_mutex */
+static unsigned long lru_count;
+
+/*
+ * ashmem_mutex - protects the list of and each individual ashmem_area
+ *
+ * Lock Ordering: ashmex_mutex -> i_mutex -> i_alloc_sem
+ */
+static DEFINE_MUTEX(ashmem_mutex);
+
+static struct kmem_cache *ashmem_area_cachep __read_mostly;
+static struct kmem_cache *ashmem_range_cachep __read_mostly;
+
+#define range_size(range) \
+  ((range)->pgend - (range)->pgstart + 1)
+
+#define range_on_lru(range) \
+  ((range)->purged == ASHMEM_NOT_PURGED)
+
+#define page_range_subsumes_range(range, start, end) \
+  (((range)->pgstart >= (start)) && ((range)->pgend <= (end)))
+
+#define page_range_subsumed_by_range(range, start, end) \
+  (((range)->pgstart <= (start)) && ((range)->pgend >= (end)))
+
+#define page_in_range(range, page) \
+ (((range)->pgstart <= (page)) && ((range)->pgend >= (page)))
+
+#define page_range_in_range(range, start, end) \
+  (page_in_range(range, start) || page_in_range(range, end) || \
+   page_range_subsumes_range(range, start, end))
+
+#define range_before_page(range, page) \
+  ((range)->pgend < (page))
+
+#define PROT_MASK		(PROT_EXEC | PROT_READ | PROT_WRITE)
+
+static inline void lru_add(struct ashmem_range *range)
+{
+	list_add_tail(&range->lru, &ashmem_lru_list);
+	lru_count += range_size(range);
+}
+
+static inline void lru_del(struct ashmem_range *range)
+{
+	list_del(&range->lru);
+	lru_count -= range_size(range);
+}
+
+/*
+ * range_alloc - allocate and initialize a new ashmem_range structure
+ *
+ * 'asma' - associated ashmem_area
+ * 'prev_range' - the previous ashmem_range in the sorted asma->unpinned list
+ * 'purged' - initial purge value (ASMEM_NOT_PURGED or ASHMEM_WAS_PURGED)
+ * 'start' - starting page, inclusive
+ * 'end' - ending page, inclusive
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int range_alloc(struct ashmem_area *asma,
+		       struct ashmem_range *prev_range, unsigned int purged,
+		       size_t start, size_t end)
+{
+	struct ashmem_range *range;
+
+	range = kmem_cache_zalloc(ashmem_range_cachep, GFP_KERNEL);
+	if (unlikely(!range))
+		return -ENOMEM;
+
+	range->asma = asma;
+	range->pgstart = start;
+	range->pgend = end;
+	range->purged = purged;
+
+	list_add_tail(&range->unpinned, &prev_range->unpinned);
+
+	if (range_on_lru(range))
+		lru_add(range);
+
+	return 0;
+}
+
+static void range_del(struct ashmem_range *range)
+{
+	list_del(&range->unpinned);
+	if (range_on_lru(range))
+		lru_del(range);
+	kmem_cache_free(ashmem_range_cachep, range);
+}
+
+/*
+ * range_shrink - shrinks a range
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static inline void range_shrink(struct ashmem_range *range,
+				size_t start, size_t end)
+{
+	size_t pre = range_size(range);
+
+	range->pgstart = start;
+	range->pgend = end;
+
+	if (range_on_lru(range))
+		lru_count -= pre - range_size(range);
+}
+
+static int ashmem_open(struct inode *inode, struct file *file)
+{
+	struct ashmem_area *asma;
+	int ret;
+
+	ret = nonseekable_open(inode, file);
+	if (unlikely(ret))
+		return ret;
+
+	asma = kmem_cache_zalloc(ashmem_area_cachep, GFP_KERNEL);
+	if (unlikely(!asma))
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&asma->unpinned_list);
+	asma->prot_mask = PROT_MASK;
+	file->private_data = asma;
+
+	return 0;
+}
+
+static int ashmem_release(struct inode *ignored, struct file *file)
+{
+	struct ashmem_area *asma = file->private_data;
+	struct ashmem_range *range, *next;
+
+	mutex_lock(&ashmem_mutex);
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned)
+		range_del(range);
+	mutex_unlock(&ashmem_mutex);
+
+	if (asma->file)
+		fput(asma->file);
+	kmem_cache_free(ashmem_area_cachep, asma);
+
+	return 0;
+}
+
+static int ashmem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct ashmem_area *asma = file->private_data;
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* user needs to SET_SIZE before mapping */
+	if (unlikely(!asma->size)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* requested protection bits must match our allowed protection mask */
+	if (unlikely((vma->vm_flags & ~asma->prot_mask) & PROT_MASK)) {
+		ret = -EPERM;
+		goto out;
+	}
+
+	if (!asma->file) {
+		char *name = ASHMEM_NAME_DEF;
+		struct file *vmfile;
+
+		if (asma->name[0] != '\0')
+			name = asma->name;
+
+		/* ... and allocate the backing shmem file */
+		vmfile = shmem_file_setup(name, asma->size, vma->vm_flags);
+		if (unlikely(IS_ERR(vmfile))) {
+			ret = PTR_ERR(vmfile);
+			goto out;
+		}
+		asma->file = vmfile;
+	}
+	get_file(asma->file);
+
+	shmem_set_file(vma, asma->file);
+	vma->vm_flags |= VM_CAN_NONLINEAR;
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+/*
+ * ashmem_shrink - our cache shrinker, called from mm/vmscan.c :: shrink_slab
+ *
+ * 'nr_to_scan' is the number of objects (pages) to prune, or 0 to query how
+ * many objects (pages) we have in total.
+ *
+ * 'gfp_mask' is the mask of the allocation that got us into this mess.
+ *
+ * Return value is the number of objects (pages) remaining, or -1 if we cannot
+ * proceed without risk of deadlock (due to gfp_mask).
+ *
+ * We approximate LRU via least-recently-unpinned, jettisoning unpinned partial
+ * chunks of ashmem regions LRU-wise one-at-a-time until we hit 'nr_to_scan'
+ * pages freed.
+ */
+static int ashmem_shrink(int nr_to_scan, gfp_t gfp_mask)
+{
+	struct ashmem_range *range, *next;
+
+	/* We might recurse into filesystem code, so bail out if necessary */
+	if (nr_to_scan && !(gfp_mask & __GFP_FS))
+		return -1;
+	if (!nr_to_scan)
+		return lru_count;
+
+	mutex_lock(&ashmem_mutex);
+	list_for_each_entry_safe(range, next, &ashmem_lru_list, lru) {
+		struct inode *inode = range->asma->file->f_dentry->d_inode;
+		loff_t start = range->pgstart * PAGE_SIZE;
+		loff_t end = (range->pgend + 1) * PAGE_SIZE - 1;
+
+		vmtruncate_range(inode, start, end);
+		range->purged = ASHMEM_WAS_PURGED;
+		lru_del(range);
+
+		nr_to_scan -= range_size(range);
+		if (nr_to_scan <= 0)
+			break;
+	}
+	mutex_unlock(&ashmem_mutex);
+
+	return lru_count;
+}
+
+static struct shrinker ashmem_shrinker = {
+	.shrink = ashmem_shrink,
+	.seeks = DEFAULT_SEEKS * 4,
+};
+
+static int set_prot_mask(struct ashmem_area *asma, unsigned long prot)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* the user can only remove, not add, protection bits */
+	if (unlikely((asma->prot_mask & prot) != prot)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* does the application expect PROT_READ to imply PROT_EXEC? */
+	if ((prot & PROT_READ) && (current->personality & READ_IMPLIES_EXEC))
+		prot |= PROT_EXEC;
+
+	asma->prot_mask = prot;
+
+out:
+	mutex_unlock(&ashmem_mutex);
+	return ret;
+}
+
+static int set_name(struct ashmem_area *asma, void __user *name)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+
+	/* cannot change an existing mapping's name */
+	if (unlikely(asma->file)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (unlikely(copy_from_user(asma->name, name, ASHMEM_NAME_LEN)))
+		ret = -EFAULT;
+	asma->name[ASHMEM_NAME_LEN-1] = '\0';
+
+out:
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+static int get_name(struct ashmem_area *asma, void __user *name)
+{
+	int ret = 0;
+
+	mutex_lock(&ashmem_mutex);
+	if (asma->name[0] != '\0') {
+		size_t len;
+
+		/*
+		 * Copying only `len', instead of ASHMEM_NAME_LEN, bytes
+		 * prevents us from revealing one user's stack to another.
+		 */
+		len = strlen(asma->name) + 1;
+		if (unlikely(copy_to_user(name, asma->name, len)))
+			ret = -EFAULT;
+	} else {
+		if (unlikely(copy_to_user(name, ASHMEM_NAME_DEF,
+					  sizeof(ASHMEM_NAME_DEF))))
+			ret = -EFAULT;
+	}
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+/*
+ * ashmem_pin - pin the given ashmem region, returning whether it was
+ * previously purged (ASHMEM_WAS_PURGED) or not (ASHMEM_NOT_PURGED).
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_pin(struct ashmem_area *asma, size_t pgstart, size_t pgend)
+{
+	struct ashmem_range *range, *next;
+	int ret = ASHMEM_NOT_PURGED;
+
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned) {
+		/* moved past last applicable page; we can short circuit */
+		if (range_before_page(range, pgstart))
+			break;
+
+		/*
+		 * The user can ask us to pin pages that span multiple ranges,
+		 * or to pin pages that aren't even unpinned, so this is messy.
+		 *
+		 * Four cases:
+		 * 1. The requested range subsumes an existing range, so we
+		 *    just remove the entire matching range.
+		 * 2. The requested range overlaps the start of an existing
+		 *    range, so we just update that range.
+		 * 3. The requested range overlaps the end of an existing
+		 *    range, so we just update that range.
+		 * 4. The requested range punches a hole in an existing range,
+		 *    so we have to update one side of the range and then
+		 *    create a new range for the other side.
+		 */
+		if (page_range_in_range(range, pgstart, pgend)) {
+			ret |= range->purged;
+
+			/* Case #1: Easy. Just nuke the whole thing. */
+			if (page_range_subsumes_range(range, pgstart, pgend)) {
+				range_del(range);
+				continue;
+			}
+
+			/* Case #2: We overlap from the start, so adjust it */
+			if (range->pgstart >= pgstart) {
+				range_shrink(range, pgend + 1, range->pgend);
+				continue;
+			}
+
+			/* Case #3: We overlap from the rear, so adjust it */
+			if (range->pgend <= pgend) {
+				range_shrink(range, range->pgstart, pgstart-1);
+				continue;
+			}
+
+			/*
+			 * Case #4: We eat a chunk out of the middle. A bit
+			 * more complicated, we allocate a new range for the
+			 * second half and adjust the first chunk's endpoint.
+			 */
+			range_alloc(asma, range, range->purged,
+				    pgend + 1, range->pgend);
+			range_shrink(range, range->pgstart, pgstart - 1);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * ashmem_unpin - unpin the given range of pages. Returns zero on success.
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_unpin(struct ashmem_area *asma, size_t pgstart, size_t pgend)
+{
+	struct ashmem_range *range, *next;
+	unsigned int purged = ASHMEM_NOT_PURGED;
+
+restart:
+	list_for_each_entry_safe(range, next, &asma->unpinned_list, unpinned) {
+		/* short circuit: this is our insertion point */
+		if (range_before_page(range, pgstart))
+			break;
+
+		/*
+		 * The user can ask us to unpin pages that are already entirely
+		 * or partially pinned. We handle those two cases here.
+		 */
+		if (page_range_subsumed_by_range(range, pgstart, pgend))
+			return 0;
+		if (page_range_in_range(range, pgstart, pgend)) {
+			pgstart = min_t(size_t, range->pgstart, pgstart),
+			pgend = max_t(size_t, range->pgend, pgend);
+			purged |= range->purged;
+			range_del(range);
+			goto restart;
+		}
+	}
+
+	return range_alloc(asma, range, purged, pgstart, pgend);
+}
+
+/*
+ * ashmem_get_pin_status - Returns ASHMEM_IS_UNPINNED if _any_ pages in the
+ * given interval are unpinned and ASHMEM_IS_PINNED otherwise.
+ *
+ * Caller must hold ashmem_mutex.
+ */
+static int ashmem_get_pin_status(struct ashmem_area *asma, size_t pgstart,
+				 size_t pgend)
+{
+	struct ashmem_range *range;
+	int ret = ASHMEM_IS_PINNED;
+
+	list_for_each_entry(range, &asma->unpinned_list, unpinned) {
+		if (range_before_page(range, pgstart))
+			break;
+		if (page_range_in_range(range, pgstart, pgend)) {
+			ret = ASHMEM_IS_UNPINNED;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int ashmem_pin_unpin(struct ashmem_area *asma, unsigned long cmd,
+			    void __user *p)
+{
+	struct ashmem_pin pin;
+	size_t pgstart, pgend;
+	int ret = -EINVAL;
+
+	if (unlikely(!asma->file))
+		return -EINVAL;
+
+	if (unlikely(copy_from_user(&pin, p, sizeof(pin))))
+		return -EFAULT;
+
+	/* per custom, you can pass zero for len to mean "everything onward" */
+	if (!pin.len)
+		pin.len = asma->size - pin.offset;
+
+	if (unlikely((pin.offset | pin.len) & ~PAGE_MASK))
+		return -EINVAL;
+
+	if (unlikely(((__u32) -1) - pin.offset < pin.len))
+		return -EINVAL;
+
+	if (unlikely(asma->size < pin.offset + pin.len))
+		return -EINVAL;
+
+	pgstart = pin.offset / PAGE_SIZE;
+	pgend = pgstart + (pin.len / PAGE_SIZE) - 1;
+
+	mutex_lock(&ashmem_mutex);
+
+	switch (cmd) {
+	case ASHMEM_PIN:
+		ret = ashmem_pin(asma, pgstart, pgend);
+		break;
+	case ASHMEM_UNPIN:
+		ret = ashmem_unpin(asma, pgstart, pgend);
+		break;
+	case ASHMEM_GET_PIN_STATUS:
+		ret = ashmem_get_pin_status(asma, pgstart, pgend);
+		break;
+	}
+
+	mutex_unlock(&ashmem_mutex);
+
+	return ret;
+}
+
+static long ashmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct ashmem_area *asma = file->private_data;
+	long ret = -ENOTTY;
+
+	switch (cmd) {
+	case ASHMEM_SET_NAME:
+		ret = set_name(asma, (void __user *) arg);
+		break;
+	case ASHMEM_GET_NAME:
+		ret = get_name(asma, (void __user *) arg);
+		break;
+	case ASHMEM_SET_SIZE:
+		ret = -EINVAL;
+		if (!asma->file && !(arg & ~PAGE_MASK)) {
+			ret = 0;
+			asma->size = (size_t) arg;
+		}
+		break;
+	case ASHMEM_GET_SIZE:
+		ret = asma->size;
+		break;
+	case ASHMEM_SET_PROT_MASK:
+		ret = set_prot_mask(asma, arg);
+		break;
+	case ASHMEM_GET_PROT_MASK:
+		ret = asma->prot_mask;
+		break;
+	case ASHMEM_PIN:
+	case ASHMEM_UNPIN:
+	case ASHMEM_GET_PIN_STATUS:
+		ret = ashmem_pin_unpin(asma, cmd, (void __user *) arg);
+		break;
+	case ASHMEM_PURGE_ALL_CACHES:
+		ret = -EPERM;
+		if (capable(CAP_SYS_ADMIN)) {
+			ret = ashmem_shrink(0, GFP_KERNEL);
+			ashmem_shrink(ret, GFP_KERNEL);
+		}
+		break;
+	}
+
+	return ret;
+}
+
+static struct file_operations ashmem_fops = {
+	.owner = THIS_MODULE,
+	.open = ashmem_open,
+	.release = ashmem_release,
+	.mmap = ashmem_mmap,
+	.unlocked_ioctl = ashmem_ioctl,
+	.compat_ioctl = ashmem_ioctl,
+};
+
+static struct miscdevice ashmem_misc = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ashmem",
+	.fops = &ashmem_fops,
+};
+
+static int __init ashmem_init(void)
+{
+	int ret;
+
+	ashmem_area_cachep = kmem_cache_create("ashmem_area_cache",
+					  sizeof(struct ashmem_area),
+					  0, 0, NULL);
+	if (unlikely(!ashmem_area_cachep)) {
+		printk(KERN_ERR "ashmem: failed to create slab cache\n");
+		return -ENOMEM;
+	}
+
+	ashmem_range_cachep = kmem_cache_create("ashmem_range_cache",
+					  sizeof(struct ashmem_range),
+					  0, 0, NULL);
+	if (unlikely(!ashmem_range_cachep)) {
+		printk(KERN_ERR "ashmem: failed to create slab cache\n");
+		return -ENOMEM;
+	}
+
+	ret = misc_register(&ashmem_misc);
+	if (unlikely(ret)) {
+		printk(KERN_ERR "ashmem: failed to register misc device!\n");
+		return ret;
+	}
+
+	register_shrinker(&ashmem_shrinker);
+
+	printk(KERN_INFO "ashmem: initialized\n");
+
+	return 0;
+}
+
+static void __exit ashmem_exit(void)
+{
+	int ret;
+
+	unregister_shrinker(&ashmem_shrinker);
+
+	ret = misc_deregister(&ashmem_misc);
+	if (unlikely(ret))
+		printk(KERN_ERR "ashmem: failed to unregister misc device!\n");
+
+	kmem_cache_destroy(ashmem_range_cachep);
+	kmem_cache_destroy(ashmem_area_cachep);
+
+	printk(KERN_INFO "ashmem: unloaded\n");
+}
+
+module_init(ashmem_init);
+module_exit(ashmem_exit);
+
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/mm/Makefile linux-2.6.29-rc3.owrt.om/mm/Makefile
--- linux-2.6.29-rc3.owrt/mm/Makefile	2009-05-10 22:04:53.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/mm/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -21,6 +21,8 @@
 obj-$(CONFIG_NUMA) 	+= mempolicy.o
 obj-$(CONFIG_SPARSEMEM)	+= sparse.o
 obj-$(CONFIG_SPARSEMEM_VMEMMAP) += sparse-vmemmap.o
+obj-$(CONFIG_SHMEM) += shmem.o
+obj-$(CONFIG_ASHMEM) += ashmem.o
 obj-$(CONFIG_TMPFS_POSIX_ACL) += shmem_acl.o
 obj-$(CONFIG_SLOB) += slob.o
 obj-$(CONFIG_MMU_NOTIFIER) += mmu_notifier.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/mm/tiny-shmem.c linux-2.6.29-rc3.owrt.om/mm/tiny-shmem.c
--- linux-2.6.29-rc3.owrt/mm/tiny-shmem.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/mm/tiny-shmem.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,148 @@
+/*
+ * tiny-shmem.c: simple shmemfs and tmpfs using ramfs code
+ *
+ * Matt Mackall <mpm@selenic.com> January, 2004
+ * derived from mm/shmem.c and fs/ramfs/inode.c
+ *
+ * This is intended for small system where the benefits of the full
+ * shmem code (swap-backed and resource-limited) are outweighed by
+ * their complexity. On systems without swap this code should be
+ * effectively equivalent, but much lighter weight.
+ */
+
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/vfs.h>
+#include <linux/mount.h>
+#include <linux/file.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/swap.h>
+#include <linux/ramfs.h>
+
+static struct file_system_type tmpfs_fs_type = {
+	.name		= "tmpfs",
+	.get_sb		= ramfs_get_sb,
+	.kill_sb	= kill_litter_super,
+};
+
+static struct vfsmount *shm_mnt;
+
+static int __init init_tmpfs(void)
+{
+	BUG_ON(register_filesystem(&tmpfs_fs_type) != 0);
+
+	shm_mnt = kern_mount(&tmpfs_fs_type);
+	BUG_ON(IS_ERR(shm_mnt));
+
+	return 0;
+}
+module_init(init_tmpfs)
+
+/**
+ * shmem_file_setup - get an unlinked file living in tmpfs
+ * @name: name for dentry (to be seen in /proc/<pid>/maps
+ * @size: size to be set for the file
+ * @flags: vm_flags
+ */
+struct file *shmem_file_setup(char *name, loff_t size, unsigned long flags)
+{
+	int error;
+	struct file *file;
+	struct inode *inode;
+	struct dentry *dentry, *root;
+	struct qstr this;
+
+	if (IS_ERR(shm_mnt))
+		return (void *)shm_mnt;
+
+	error = -ENOMEM;
+	this.name = name;
+	this.len = strlen(name);
+	this.hash = 0; /* will go */
+	root = shm_mnt->mnt_root;
+	dentry = d_alloc(root, &this);
+	if (!dentry)
+		goto put_memory;
+
+	error = -ENFILE;
+	file = get_empty_filp();
+	if (!file)
+		goto put_dentry;
+
+	error = -ENOSPC;
+	inode = ramfs_get_inode(root->d_sb, S_IFREG | S_IRWXUGO, 0);
+	if (!inode)
+		goto close_file;
+
+	d_instantiate(dentry, inode);
+	inode->i_size = size;
+	inode->i_nlink = 0;	/* It is unlinked */
+	init_file(file, shm_mnt, dentry, FMODE_WRITE | FMODE_READ,
+			&ramfs_file_operations);
+
+#ifndef CONFIG_MMU
+	error = ramfs_nommu_expand_for_mapping(inode, size);
+	if (error)
+		goto close_file;
+#endif
+	return file;
+
+close_file:
+	put_filp(file);
+put_dentry:
+	dput(dentry);
+put_memory:
+	return ERR_PTR(error);
+}
+EXPORT_SYMBOL_GPL(shmem_file_setup);
+
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &generic_file_vm_ops;
+}
+
+void shmem_set_file(struct vm_area_struct *vma, struct file *file)
+{
+	if (vma->vm_file)
+		fput(vma->vm_file);
+	vma->vm_file = file;
+	vma->vm_ops = &generic_file_vm_ops;
+}
+
+/**
+ * shmem_zero_setup - setup a shared anonymous mapping
+ * @vma: the vma to be mmapped is prepared by do_mmap_pgoff
+ */
+int shmem_zero_setup(struct vm_area_struct *vma)
+{
+	struct file *file;
+	loff_t size = vma->vm_end - vma->vm_start;
+
+	file = shmem_file_setup("dev/zero", size, vma->vm_flags);
+	if (IS_ERR(file))
+		return PTR_ERR(file);
+
+	shmem_set_file(vma, file);
+
+	return 0;
+}
+
+int shmem_unuse(swp_entry_t entry, struct page *page)
+{
+	return 0;
+}
+
+#ifndef CONFIG_MMU
+unsigned long shmem_get_unmapped_area(struct file *file,
+				      unsigned long addr,
+				      unsigned long len,
+				      unsigned long pgoff,
+				      unsigned long flags)
+{
+	return ramfs_nommu_get_unmapped_area(file, addr, len, pgoff, flags);
+}
+#endif
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/remote_install_sdcard linux-2.6.29-rc3.owrt.om/remote_install_sdcard
--- linux-2.6.29-rc3.owrt/remote_install_sdcard	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/remote_install_sdcard	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+# automatic kernel updater and reboot - Andy Green <andy@openmoko.com>
+
+GTA_DEVICE_IP=192.168.0.202
+
+# you should set up key-based auth on dropbear if you want
+# to play this game.
+#
+# 1) mkdir /home/root/.ssh
+# 2) chown root:root / /home /home/root
+# 3) chmod 700 /home/root /home/root/.ssh
+# 4) copy your id_*.pub into /home/root/.ssh/authorized_keys
+# 5) chmod 600 /home/root/.ssh/*
+
+scp uImage.bin root@$GTA_DEVICE_IP:/boot
+ssh root@$GTA_DEVICE_IP "mount /dev/mmcblk0p1 / -oremount,ro ; reboot -if &"
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/scripts/mkuboot.sh linux-2.6.29-rc3.owrt.om/scripts/mkuboot.sh
--- linux-2.6.29-rc3.owrt/scripts/mkuboot.sh	2009-05-10 22:04:48.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/scripts/mkuboot.sh	2009-05-10 22:28:00.000000000 +0200
@@ -11,7 +11,7 @@
 	if [ -z "${MKIMAGE}" ]; then
 		# Doesn't exist
 		echo '"mkimage" command not found - U-Boot images will not be built' >&2
-		exit 0;
+		exit 1;
 	fi
 fi
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/codecs/wm8731.c linux-2.6.29-rc3.owrt.om/sound/soc/codecs/wm8731.c
--- linux-2.6.29-rc3.owrt/sound/soc/codecs/wm8731.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/codecs/wm8731.c	2009-05-10 22:28:00.000000000 +0200
@@ -73,6 +73,8 @@
 	u16 *cache = codec->reg_cache;
 	if (reg >= WM8731_CACHEREGNUM)
 		return;
+
+	printk(KERN_INFO "%s: reg %d, val %04x\n", __func__, reg, value);
 	cache[reg] = value;
 }
 
@@ -84,6 +86,8 @@
 {
 	u8 data[2];
 
+	printk(KERN_INFO "%s: reg %d val %04x\n", __func__, reg, value);
+
 	/* data is
 	 *   D15..D9 WM8731 register offset
 	 *   D8...D0 register data
@@ -521,7 +525,11 @@
 	if (codec->reg_cache == NULL)
 		return -ENOMEM;
 
-	wm8731_reset(codec);
+	ret = wm8731_reset(codec);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8731: failed to send reset\n");
+		return -EIO;
+	}
 
 	/* register pcms */
 	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/codecs/wm8753.c linux-2.6.29-rc3.owrt.om/sound/soc/codecs/wm8753.c
--- linux-2.6.29-rc3.owrt/sound/soc/codecs/wm8753.c	2009-05-10 22:09:10.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/codecs/wm8753.c	2009-05-10 22:28:00.000000000 +0200
@@ -51,8 +51,6 @@
 
 #include "wm8753.h"
 
-#define WM8753_VERSION "0.16"
-
 static int caps_charge = 2000;
 module_param(caps_charge, int, 0);
 MODULE_PARM_DESC(caps_charge, "WM8753 cap charge time (msecs)");
@@ -60,12 +58,6 @@
 static void wm8753_set_dai_mode(struct snd_soc_codec *codec,
 	unsigned int mode);
 
-/* codec private data */
-struct wm8753_priv {
-	unsigned int sysclk;
-	unsigned int pcmclk;
-};
-
 /*
  * wm8753 register cache
  * We can't read the WM8753 register space when we
@@ -90,6 +82,14 @@
 	0x0000, 0x0000
 };
 
+/* codec private data */
+struct wm8753_priv {
+	unsigned int sysclk;
+	unsigned int pcmclk;
+	struct snd_soc_codec codec;
+	u16 reg_cache[ARRAY_SIZE(wm8753_reg)];
+};
+
 /*
  * read wm8753 register cache
  */
@@ -1451,7 +1451,15 @@
 },
 };
 
-struct snd_soc_dai wm8753_dai[2];
+struct snd_soc_dai wm8753_dai[2] = {
+	{
+		.name = "dummy1"
+	},
+	{
+		.name = "dummy2"
+	},
+};
+
 EXPORT_SYMBOL_GPL(wm8753_dai);
 
 static void wm8753_set_dai_mode(struct snd_soc_codec *codec, unsigned int mode)
@@ -1459,30 +1467,35 @@
 	if (mode < 4) {
 		int playback_active, capture_active, codec_active, pop_wait;
 		void *private_data;
+		struct list_head list;
 
 		playback_active = wm8753_dai[0].playback.active;
 		capture_active = wm8753_dai[0].capture.active;
 		codec_active = wm8753_dai[0].active;
 		private_data = wm8753_dai[0].private_data;
 		pop_wait = wm8753_dai[0].pop_wait;
+		list = wm8753_dai[0].list;
 		wm8753_dai[0] = wm8753_all_dai[mode << 1];
 		wm8753_dai[0].playback.active = playback_active;
 		wm8753_dai[0].capture.active = capture_active;
 		wm8753_dai[0].active = codec_active;
 		wm8753_dai[0].private_data = private_data;
 		wm8753_dai[0].pop_wait = pop_wait;
+		wm8753_dai[0].list = list;
 
 		playback_active = wm8753_dai[1].playback.active;
 		capture_active = wm8753_dai[1].capture.active;
 		codec_active = wm8753_dai[1].active;
 		private_data = wm8753_dai[1].private_data;
 		pop_wait = wm8753_dai[1].pop_wait;
+		list = wm8753_dai[1].list;
 		wm8753_dai[1] = wm8753_all_dai[(mode << 1) + 1];
 		wm8753_dai[1].playback.active = playback_active;
 		wm8753_dai[1].capture.active = capture_active;
 		wm8753_dai[1].active = codec_active;
 		wm8753_dai[1].private_data = private_data;
 		wm8753_dai[1].pop_wait = pop_wait;
+		wm8753_dai[1].list = list;
 	}
 	wm8753_dai[0].codec = codec;
 	wm8753_dai[1].codec = codec;
@@ -1524,6 +1537,11 @@
 	for (i = 0; i < ARRAY_SIZE(wm8753_reg); i++) {
 		if (i + 1 == WM8753_RESET)
 			continue;
+
+		/* No point in writing hardware default values back */
+		if (cache[i] == wm8753_reg[i])
+			continue;
+
 		data[0] = ((i + 1) << 1) | ((cache[i] >> 8) & 0x0001);
 		data[1] = cache[i] & 0x00ff;
 		codec->hw_write(codec->control_data, data, 2);
@@ -1542,44 +1560,133 @@
 	return 0;
 }
 
+static struct snd_soc_codec *wm8753_codec;
+
+static int wm8753_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec;
+	int ret = 0;
+
+	if (!wm8753_codec) {
+		dev_err(&pdev->dev, "WM8753 codec not yet registered\n");
+		return -EINVAL;
+	}
+
+	socdev->codec = wm8753_codec;
+	codec = wm8753_codec;
+
+	wm8753_set_dai_mode(codec, 0);
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8753: failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	wm8753_add_controls(codec);
+	wm8753_add_widgets(codec);
+	ret = snd_soc_init_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "wm8753: failed to register card\n");
+		goto card_err;
+	}
+
+	return 0;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+
+pcm_err:
+	return ret;
+}
+
 /*
- * initialise the WM8753 driver
- * register the mixer and dsp interfaces with the kernel
+ * This function forces any delayed work to be queued and run.
  */
-static int wm8753_init(struct snd_soc_device *socdev)
+static int run_delayed_work(struct delayed_work *dwork)
 {
-	struct snd_soc_codec *codec = socdev->codec;
-	int reg, ret = 0;
+	int ret;
+
+	/* cancel any work waiting to be queued. */
+	ret = cancel_delayed_work(dwork);
+
+	/* if there was any work waiting then we run it now and
+	 * wait for it's completion */
+	if (ret) {
+		schedule_delayed_work(dwork, 0);
+		flush_scheduled_work();
+	}
+	return ret;
+}
+
+/* power down chip */
+static int wm8753_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_wm8753 = {
+	.probe = 	wm8753_probe,
+	.remove = 	wm8753_remove,
+	.suspend = 	wm8753_suspend,
+	.resume =	wm8753_resume,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_wm8753);
+
+static int wm8753_register(struct wm8753_priv *wm8753)
+{
+	int ret, i;
+	struct snd_soc_codec *codec = &wm8753->codec;
+	u16 reg;
+
+	if (wm8753_codec) {
+		dev_err(codec->dev, "Multiple WM8753 devices not supported\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
 
 	codec->name = "WM8753";
 	codec->owner = THIS_MODULE;
 	codec->read = wm8753_read_reg_cache;
 	codec->write = wm8753_write;
+	codec->bias_level = SND_SOC_BIAS_STANDBY;
 	codec->set_bias_level = wm8753_set_bias_level;
 	codec->dai = wm8753_dai;
 	codec->num_dai = 2;
-	codec->reg_cache_size = ARRAY_SIZE(wm8753_reg);
-	codec->reg_cache = kmemdup(wm8753_reg, sizeof(wm8753_reg), GFP_KERNEL);
-
-	if (codec->reg_cache == NULL)
-		return -ENOMEM;
-
-	wm8753_set_dai_mode(codec, 0);
+	codec->reg_cache_size = ARRAY_SIZE(wm8753->reg_cache);
+	codec->reg_cache = &wm8753->reg_cache;
+	codec->private_data = wm8753;
 
-	wm8753_reset(codec);
+	memcpy(codec->reg_cache, wm8753_reg, sizeof(codec->reg_cache));
+	INIT_DELAYED_WORK(&codec->delayed_work, wm8753_work);
 
-	/* register pcms */
-	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	ret = wm8753_reset(codec);
 	if (ret < 0) {
-		printk(KERN_ERR "wm8753: failed to create pcms\n");
-		goto pcm_err;
+		dev_err(codec->dev, "Failed to issue reset\n");
+		goto err;
 	}
 
 	/* charge output caps */
 	wm8753_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
-	codec->bias_level = SND_SOC_BIAS_STANDBY;
 	schedule_delayed_work(&codec->delayed_work,
-		msecs_to_jiffies(caps_charge));
+			      msecs_to_jiffies(caps_charge));
+
+	/* OpenMoko specific bodge for
+	 * http://bugzilla.openmoko.org/cgi-bin/bugzilla/show_bug.cgi?id=1172
+	 */
+	wm8753_write(codec, WM8753_ADCTL2, 0x0000);
 
 	/* set the update bits */
 	reg = wm8753_read_reg_cache(codec, WM8753_LDAC);
@@ -1603,58 +1710,69 @@
 	reg = wm8753_read_reg_cache(codec, WM8753_RINVOL);
 	wm8753_write(codec, WM8753_RINVOL, reg | 0x0100);
 
-	wm8753_add_controls(codec);
-	wm8753_add_widgets(codec);
-	ret = snd_soc_init_card(socdev);
-	if (ret < 0) {
-		printk(KERN_ERR "wm8753: failed to register card\n");
-		goto card_err;
+	wm8753_codec = codec;
+
+	for (i = 0; i < ARRAY_SIZE(wm8753_dai); i++)
+		wm8753_dai[i].dev = codec->dev;
+
+	ret = snd_soc_register_codec(codec);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
+		goto err;
 	}
 
-	return ret;
+	ret = snd_soc_register_dais(&wm8753_dai[0], ARRAY_SIZE(wm8753_dai));
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register DAIs: %d\n", ret);
+		goto err_codec;
+	}
 
-card_err:
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
-pcm_err:
-	kfree(codec->reg_cache);
+	return 0;
+
+err_codec:
+	run_delayed_work(&codec->delayed_work);
+	snd_soc_unregister_codec(codec);
+err:
+	kfree(wm8753);
 	return ret;
 }
 
-/* If the i2c layer weren't so broken, we could pass this kind of data
-   around */
-static struct snd_soc_device *wm8753_socdev;
+static void wm8753_unregister(struct wm8753_priv *wm8753)
+{
+	wm8753_set_bias_level(&wm8753->codec, SND_SOC_BIAS_OFF);
+	run_delayed_work(&wm8753->codec.delayed_work);
+	snd_soc_unregister_dais(&wm8753_dai[0], ARRAY_SIZE(wm8753_dai));
+	snd_soc_unregister_codec(&wm8753->codec);
+	kfree(wm8753);
+	wm8753_codec = NULL;
+}
 
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 
-/*
- * WM8753 2 wire address is determined by GPIO5
- * state during powerup.
- *    low  = 0x1a
- *    high = 0x1b
- */
-
 static int wm8753_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
-	struct snd_soc_device *socdev = wm8753_socdev;
-	struct snd_soc_codec *codec = socdev->codec;
-	int ret;
+	struct snd_soc_codec *codec;
+	struct wm8753_priv *wm8753;
 
-	i2c_set_clientdata(i2c, codec);
+	wm8753 = kzalloc(sizeof(struct wm8753_priv), GFP_KERNEL);
+	if (wm8753 == NULL)
+		return -ENOMEM;
+
+	codec = &wm8753->codec;
+	codec->hw_write = (hw_write_t)i2c_master_send;
 	codec->control_data = i2c;
+	i2c_set_clientdata(i2c, wm8753);
 
-	ret = wm8753_init(socdev);
-	if (ret < 0)
-		pr_err("failed to initialise WM8753\n");
+	codec->dev = &i2c->dev;
 
-	return ret;
+	return wm8753_register(wm8753);
 }
 
 static int wm8753_i2c_remove(struct i2c_client *client)
 {
-	struct snd_soc_codec *codec = i2c_get_clientdata(client);
-	kfree(codec->reg_cache);
+	struct wm8753_priv *wm8753 = i2c_get_clientdata(client);
+	wm8753_unregister(wm8753);
 	return 0;
 }
 
@@ -1666,86 +1784,16 @@
 
 static struct i2c_driver wm8753_i2c_driver = {
 	.driver = {
-		.name = "WM8753 I2C Codec",
+		.name = "wm8753",
 		.owner = THIS_MODULE,
 	},
 	.probe =    wm8753_i2c_probe,
 	.remove =   wm8753_i2c_remove,
 	.id_table = wm8753_i2c_id,
 };
-
-static int wm8753_add_i2c_device(struct platform_device *pdev,
-				 const struct wm8753_setup_data *setup)
-{
-	struct i2c_board_info info;
-	struct i2c_adapter *adapter;
-	struct i2c_client *client;
-	int ret;
-
-	ret = i2c_add_driver(&wm8753_i2c_driver);
-	if (ret != 0) {
-		dev_err(&pdev->dev, "can't add i2c driver\n");
-		return ret;
-	}
-
-	memset(&info, 0, sizeof(struct i2c_board_info));
-	info.addr = setup->i2c_address;
-	strlcpy(info.type, "wm8753", I2C_NAME_SIZE);
-
-	adapter = i2c_get_adapter(setup->i2c_bus);
-	if (!adapter) {
-		dev_err(&pdev->dev, "can't get i2c adapter %d\n",
-			setup->i2c_bus);
-		goto err_driver;
-	}
-
-	client = i2c_new_device(adapter, &info);
-	i2c_put_adapter(adapter);
-	if (!client) {
-		dev_err(&pdev->dev, "can't add i2c device at 0x%x\n",
-			(unsigned int)info.addr);
-		goto err_driver;
-	}
-
-	return 0;
-
-err_driver:
-	i2c_del_driver(&wm8753_i2c_driver);
-	return -ENODEV;
-}
 #endif
 
 #if defined(CONFIG_SPI_MASTER)
-static int __devinit wm8753_spi_probe(struct spi_device *spi)
-{
-	struct snd_soc_device *socdev = wm8753_socdev;
-	struct snd_soc_codec *codec = socdev->codec;
-	int ret;
-
-	codec->control_data = spi;
-
-	ret = wm8753_init(socdev);
-	if (ret < 0)
-		dev_err(&spi->dev, "failed to initialise WM8753\n");
-
-	return ret;
-}
-
-static int __devexit wm8753_spi_remove(struct spi_device *spi)
-{
-	return 0;
-}
-
-static struct spi_driver wm8753_spi_driver = {
-	.driver = {
-		.name	= "wm8753",
-		.bus	= &spi_bus_type,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= wm8753_spi_probe,
-	.remove		= __devexit_p(wm8753_spi_remove),
-};
-
 static int wm8753_spi_write(struct spi_device *spi, const char *data, int len)
 {
 	struct spi_transfer t;
@@ -1769,120 +1817,69 @@
 
 	return len;
 }
-#endif
-
 
-static int wm8753_probe(struct platform_device *pdev)
+static int __devinit wm8753_spi_probe(struct spi_device *spi)
 {
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct wm8753_setup_data *setup;
 	struct snd_soc_codec *codec;
 	struct wm8753_priv *wm8753;
-	int ret = 0;
-
-	pr_info("WM8753 Audio Codec %s", WM8753_VERSION);
-
-	setup = socdev->codec_data;
-	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
-	if (codec == NULL)
-		return -ENOMEM;
 
 	wm8753 = kzalloc(sizeof(struct wm8753_priv), GFP_KERNEL);
-	if (wm8753 == NULL) {
-		kfree(codec);
+	if (wm8753 == NULL)
 		return -ENOMEM;
-	}
 
-	codec->private_data = wm8753;
-	socdev->codec = codec;
-	mutex_init(&codec->mutex);
-	INIT_LIST_HEAD(&codec->dapm_widgets);
-	INIT_LIST_HEAD(&codec->dapm_paths);
-	wm8753_socdev = socdev;
-	INIT_DELAYED_WORK(&codec->delayed_work, wm8753_work);
+	codec = &wm8753->codec;
+	codec->control_data = spi;
+	codec->hw_write = (hw_write_t)wm8753_spi_write;
+	codec->dev = &spi->dev;
 
-#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
-	if (setup->i2c_address) {
-		codec->hw_write = (hw_write_t)i2c_master_send;
-		ret = wm8753_add_i2c_device(pdev, setup);
-	}
-#endif
-#if defined(CONFIG_SPI_MASTER)
-	if (setup->spi) {
-		codec->hw_write = (hw_write_t)wm8753_spi_write;
-		ret = spi_register_driver(&wm8753_spi_driver);
-		if (ret != 0)
-			printk(KERN_ERR "can't add spi driver");
-	}
-#endif
+	spi->dev.driver_data = wm8753;
 
-	if (ret != 0) {
-		kfree(codec->private_data);
-		kfree(codec);
-	}
-	return ret;
+	return wm8753_register(wm8753);
 }
 
-/*
- * This function forces any delayed work to be queued and run.
- */
-static int run_delayed_work(struct delayed_work *dwork)
+static int __devexit wm8753_spi_remove(struct spi_device *spi)
 {
-	int ret;
-
-	/* cancel any work waiting to be queued. */
-	ret = cancel_delayed_work(dwork);
-
-	/* if there was any work waiting then we run it now and
-	 * wait for it's completion */
-	if (ret) {
-		schedule_delayed_work(dwork, 0);
-		flush_scheduled_work();
-	}
-	return ret;
+	struct wm8753_priv *wm8753 = spi->dev.driver_data;
+	wm8753_unregister(wm8753);
+	return 0;
 }
 
-/* power down chip */
-static int wm8753_remove(struct platform_device *pdev)
-{
-	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_codec *codec = socdev->codec;
+static struct spi_driver wm8753_spi_driver = {
+	.driver = {
+		.name	= "wm8753",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe		= wm8753_spi_probe,
+	.remove		= __devexit_p(wm8753_spi_remove),
+};
+#endif
 
-	if (codec->control_data)
-		wm8753_set_bias_level(codec, SND_SOC_BIAS_OFF);
-	run_delayed_work(&codec->delayed_work);
-	snd_soc_free_pcms(socdev);
-	snd_soc_dapm_free(socdev);
+static int __init wm8753_modinit(void)
+{
+	int ret;
 #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
-	i2c_unregister_device(codec->control_data);
-	i2c_del_driver(&wm8753_i2c_driver);
+	ret = i2c_add_driver(&wm8753_i2c_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8753 I2C driver: %d\n", ret);
 #endif
 #if defined(CONFIG_SPI_MASTER)
-	spi_unregister_driver(&wm8753_spi_driver);
+	ret = spi_register_driver(&wm8753_spi_driver);
+	if (ret != 0)
+		pr_err("Failed to register WM8753 SPI driver: %d\n", ret);
 #endif
-	kfree(codec->private_data);
-	kfree(codec);
-
 	return 0;
 }
-
-struct snd_soc_codec_device soc_codec_dev_wm8753 = {
-	.probe = 	wm8753_probe,
-	.remove = 	wm8753_remove,
-	.suspend = 	wm8753_suspend,
-	.resume =	wm8753_resume,
-};
-EXPORT_SYMBOL_GPL(soc_codec_dev_wm8753);
-
-static int __init wm8753_modinit(void)
-{
-	return snd_soc_register_dais(wm8753_dai, ARRAY_SIZE(wm8753_dai));
-}
 module_init(wm8753_modinit);
 
 static void __exit wm8753_exit(void)
 {
-	snd_soc_unregister_dais(wm8753_dai, ARRAY_SIZE(wm8753_dai));
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	i2c_del_driver(&wm8753_i2c_driver);
+#endif
+#if defined(CONFIG_SPI_MASTER)
+	spi_unregister_driver(&wm8753_spi_driver);
+#endif
 }
 module_exit(wm8753_exit);
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/codecs/wm8753.h linux-2.6.29-rc3.owrt.om/sound/soc/codecs/wm8753.h
--- linux-2.6.29-rc3.owrt/sound/soc/codecs/wm8753.h	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/codecs/wm8753.h	2009-05-10 22:28:00.000000000 +0200
@@ -77,12 +77,6 @@
 #define WM8753_BIASCTL		0x3d
 #define WM8753_ADCTL2		0x3f
 
-struct wm8753_setup_data {
-	int spi;
-	int i2c_bus;
-	unsigned short i2c_address;
-};
-
 #define WM8753_PLL1			0
 #define WM8753_PLL2			1
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/jive_wm8750.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/jive_wm8750.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/jive_wm8750.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/jive_wm8750.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,216 @@
+/* sound/soc/s3c24xx/jive_wm8750.c
+ *
+ * Copyright 2007,2008 Simtec Electronics
+ *
+ * Based on sound/soc/pxa/spitz.c
+ *	Copyright 2005 Wolfson Microelectronics PLC.
+ *	Copyright 2005 Openedhand Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+
+#include "s3c24xx-pcm.h"
+#include "s3c2412-i2s.h"
+
+#include "../codecs/wm8750.h"
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	{ "Headphone Jack", NULL, "LOUT1" },
+	{ "Headphone Jack", NULL, "ROUT1" },
+	{ "Internal Speaker", NULL, "LOUT2" },
+	{ "Internal Speaker", NULL, "ROUT2" },
+	{ "LINPUT1", NULL, "Line Input" },
+	{ "RINPUT1", NULL, "Line Input" },
+};
+
+static const struct snd_soc_dapm_widget wm8750_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_SPK("Internal Speaker", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static int jive_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->socdev->codec;
+
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	snd_soc_dapm_enable_pin(codec, "Internal Speaker");
+	snd_soc_dapm_enable_pin(codec, "Line In");
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int jive_hw_params(struct snd_pcm_substream *substream,
+			  struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	struct s3c_i2sv2_rate_calc div;
+	unsigned int clk = 0;
+	int ret = 0;
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+	case 48000:
+	case 96000:
+		clk = 12288000;
+		break;
+	case 11025:
+	case 22050:
+	case 44100:
+		clk = 11289600;
+		break;
+	}
+
+	s3c_i2sv2_calc_rate(&div, NULL, params_rate(params),
+			    s3c2412_get_iisclk());
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8750_SYSCLK, clk,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C2412_DIV_RCLK, div.fs_div);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C2412_DIV_PRESCALER,
+				     div.clk_div - 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static struct snd_soc_ops jive_ops = {
+	.startup	= jive_startup,
+	.hw_params	= jive_hw_params,
+};
+
+static int jive_wm8750_init(struct snd_soc_codec *codec)
+{
+	int err;
+
+	/* These endpoints are not being used. */
+	snd_soc_dapm_disable_pin(codec, "LINPUT2");
+	snd_soc_dapm_disable_pin(codec, "RINPUT2");
+	snd_soc_dapm_disable_pin(codec, "LINPUT3");
+	snd_soc_dapm_disable_pin(codec, "RINPUT3");
+	snd_soc_dapm_disable_pin(codec, "OUT3");
+	snd_soc_dapm_disable_pin(codec, "MONO");
+
+	/* Add jive specific widgets */
+	err = snd_soc_dapm_new_controls(codec, wm8750_dapm_widgets,
+					ARRAY_SIZE(wm8750_dapm_widgets));
+	if (err) {
+		printk(KERN_ERR "%s: failed to add widgets (%d)\n",
+		       __func__, err);
+		return err;
+	}
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static struct snd_soc_dai_link jive_dai = {
+	.name		= "wm8750",
+	.stream_name	= "WM8750",
+	.cpu_dai	= &s3c2412_i2s_dai,
+	.codec_dai	= &wm8750_dai,
+	.init		= jive_wm8750_init,
+	.ops		= &jive_ops,
+};
+
+/* jive audio machine driver */
+static struct snd_soc_machine snd_soc_machine_jive = {
+	.name		= "Jive",
+	.dai_link	= &jive_dai,
+	.num_links	= 1,
+};
+
+/* jive audio private data */
+static struct wm8750_setup_data jive_wm8750_setup = {
+};
+
+/* jive audio subsystem */
+static struct snd_soc_device jive_snd_devdata = {
+	.machine	= &snd_soc_machine_jive,
+	.platform	= &s3c24xx_soc_platform,
+	.codec_dev	= &soc_codec_dev_wm8750_spi,
+	.codec_data	= &jive_wm8750_setup,
+};
+
+static struct platform_device *jive_snd_device;
+
+static int __init jive_init(void)
+{
+	int ret;
+
+	if (!machine_is_jive())
+		return 0;
+
+	printk("JIVE WM8750 Audio support\n");
+
+	jive_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!jive_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(jive_snd_device, &jive_snd_devdata);
+	jive_snd_devdata.dev = &jive_snd_device->dev;
+	ret = platform_device_add(jive_snd_device);
+
+	if (ret)
+		platform_device_put(jive_snd_device);
+
+	return ret;
+}
+
+static void __exit jive_exit(void)
+{
+	platform_device_unregister(jive_snd_device);
+}
+
+module_init(jive_init);
+module_exit(jive_exit);
+
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("ALSA SoC Jive Audio support");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/Kconfig linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/Kconfig
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/Kconfig	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/Kconfig	2009-05-10 22:28:00.000000000 +0200
@@ -1,6 +1,6 @@
 config SND_S3C24XX_SOC
 	tristate "SoC Audio for the Samsung S3C24XX chips"
-	depends on ARCH_S3C2410
+	depends on ARCH_S3C2410 || ARCH_S3C64XX
 	help
 	  Say Y or M if you want to add support for codecs attached to
 	  the S3C24XX AC97, I2S or SSP interface. You will also need
@@ -9,8 +9,16 @@
 config SND_S3C24XX_SOC_I2S
 	tristate
 
+config SND_S3C_I2SV2_SOC
+	tristate
+
 config SND_S3C2412_SOC_I2S
 	tristate
+	select SND_S3C_I2SV2_SOC
+
+config SND_S3C64XX_SOC_I2S
+	tristate
+	select SND_S3C_I2SV2_SOC
 
 config SND_S3C2443_SOC_AC97
 	tristate
@@ -26,6 +34,33 @@
 	  Say Y if you want to add support for SoC audio on smdk2440
 	  with the WM8753.
 
+config SND_S3C24XX_SOC_JIVE_WM8750
+	tristate "SoC I2S Audio support for Jive"
+	depends on SND_S3C24XX_SOC && MACH_JIVE
+	select SND_SOC_WM8750
+	select SND_SOC_WM8750_SPI
+	select SND_S3C2412_SOC_I2S
+	help
+	  Sat Y if you want to add support for SoC audio on the Jive.
+
+config SND_S3C24XX_SOC_NEO1973_GTA02_WM8753
+	tristate "SoC I2S Audio support for NEO1973 GTA02 - WM8753"
+	depends on SND_S3C24XX_SOC && MACH_NEO1973_GTA02
+	select SND_S3C24XX_SOC_I2S
+	select SND_SOC_WM8753
+	help
+	  Say Y if you want to add support for SoC audio on neo1973 gta02
+	  with the WM8753 codec
+
+config SND_S3C24XX_SOC_OM_3D7K_WM8753
+	tristate "SoC I2S Audio support for OM 3D7K - WM8753"
+	depends on SND_S3C24XX_SOC && MACH_OM_3D7K
+	select SND_S3C64XX_SOC_I2S
+	select SND_SOC_WM8753
+	help
+	  Say Y if you want support for SoC audio on Openmoko 3D7K
+	  with the WM8753 codec.
+
 config SND_S3C24XX_SOC_SMDK2443_WM9710
 	tristate "SoC AC97 Audio support for SMDK2443 - WM9710"
 	depends on SND_S3C24XX_SOC && MACH_SMDK2443
@@ -49,3 +84,11 @@
        	depends on SND_S3C24XX_SOC
        	select SND_S3C24XX_SOC_I2S
        	select SND_SOC_UDA134X
+
+config SND_S3C64XX_SOC_SMDK6410_WM8731
+	tristate "SoC I2S Audio support for WM8731 added to an SMDK6410"
+	depends on SND_S3C24XX_SOC
+	select SND_S3C64XX_SOC_I2S
+	select SND_SOC_WM8731
+	help
+	  Support for an WM8731 add-on board on I2S channel 0 on an SMDK6410
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/Makefile linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/Makefile
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/Makefile	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/Makefile	2009-05-10 22:28:00.000000000 +0200
@@ -2,20 +2,32 @@
 snd-soc-s3c24xx-objs := s3c24xx-pcm.o
 snd-soc-s3c24xx-i2s-objs := s3c24xx-i2s.o
 snd-soc-s3c2412-i2s-objs := s3c2412-i2s.o
+snd-soc-s3c64xx-i2s-objs := s3c64xx-i2s.o
 snd-soc-s3c2443-ac97-objs := s3c2443-ac97.o
+snd-soc-s3c-i2s-v2-objs := s3c-i2s-v2.o
 
 obj-$(CONFIG_SND_S3C24XX_SOC) += snd-soc-s3c24xx.o
 obj-$(CONFIG_SND_S3C24XX_SOC_I2S) += snd-soc-s3c24xx-i2s.o
 obj-$(CONFIG_SND_S3C2443_SOC_AC97) += snd-soc-s3c2443-ac97.o
 obj-$(CONFIG_SND_S3C2412_SOC_I2S) += snd-soc-s3c2412-i2s.o
+obj-$(CONFIG_SND_S3C64XX_SOC_I2S) += snd-soc-s3c64xx-i2s.o
+obj-$(CONFIG_SND_S3C_I2SV2_SOC) += snd-soc-s3c-i2s-v2.o
 
 # S3C24XX Machine Support
+snd-soc-jive-wm8750-objs := jive_wm8750.o
 snd-soc-neo1973-wm8753-objs := neo1973_wm8753.o
 snd-soc-smdk2443-wm9710-objs := smdk2443_wm9710.o
 snd-soc-ln2440sbc-alc650-objs := ln2440sbc_alc650.o
 snd-soc-s3c24xx-uda134x-objs := s3c24xx_uda134x.o
+snd-soc-neo1973-gta02-wm8753-objs := neo1973_gta02_wm8753.o
+snd-soc-om-3d7k-wm8753-objs := om_3d7k_wm8753.o
+snd-soc-smdk6410-wm8731-objs := smdk6410-wm8731.o
 
+obj-$(CONFIG_SND_S3C24XX_SOC_JIVE_WM8750) += snd-soc-jive-wm8750.o
 obj-$(CONFIG_SND_S3C24XX_SOC_NEO1973_WM8753) += snd-soc-neo1973-wm8753.o
 obj-$(CONFIG_SND_S3C24XX_SOC_SMDK2443_WM9710) += snd-soc-smdk2443-wm9710.o
 obj-$(CONFIG_SND_S3C24XX_SOC_LN2440SBC_ALC650) += snd-soc-ln2440sbc-alc650.o
 obj-$(CONFIG_SND_S3C24XX_SOC_S3C24XX_UDA134X) += snd-soc-s3c24xx-uda134x.o
+obj-$(CONFIG_SND_S3C24XX_SOC_NEO1973_GTA02_WM8753) += snd-soc-neo1973-gta02-wm8753.o
+obj-$(CONFIG_SND_S3C24XX_SOC_OM_3D7K_WM8753) += snd-soc-om-3d7k-wm8753.o
+obj-$(CONFIG_SND_S3C64XX_SOC_SMDK6410_WM8731) += snd-soc-smdk6410-wm8731.o
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/neo1973_gta02_wm8753.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/neo1973_gta02_wm8753.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/neo1973_gta02_wm8753.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/neo1973_gta02_wm8753.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,481 @@
+/*
+ * neo1973_gta02_wm8753.c  --  SoC audio for Neo1973
+ *
+ * Copyright 2007 Openmoko Inc
+ * Author: Graeme Gregory <graeme@openmoko.org>
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory <linux@wolfsonmicro.com>
+ * Copyright 2009 Wolfson Microelectronics
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+
+#include <plat/regs-iis.h>
+
+#include <mach/regs-clock.h>
+#include <mach/regs-gpio.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <mach/regs-gpioj.h>
+#include <mach/gta02.h>
+#include "../codecs/wm8753.h"
+#include "s3c24xx-pcm.h"
+#include "s3c24xx-i2s.h"
+
+static struct snd_soc_card neo1973_gta02;
+
+static int neo1973_gta02_hifi_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0, bclk = 0;
+	int ret = 0;
+	unsigned long iis_clkrate;
+
+	iis_clkrate = s3c24xx_i2s_get_clockrate();
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+		pll_out = 12288000;
+		break;
+	case 48000:
+		bclk = WM8753_BCLK_DIV_4;
+		pll_out = 12288000;
+		break;
+	case 96000:
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 12288000;
+		break;
+	case 11025:
+		bclk = WM8753_BCLK_DIV_16;
+		pll_out = 11289600;
+		break;
+	case 22050:
+		bclk = WM8753_BCLK_DIV_8;
+		pll_out = 11289600;
+		break;
+	case 44100:
+		bclk = WM8753_BCLK_DIV_4;
+		pll_out = 11289600;
+		break;
+	case 88200:
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 11289600;
+		break;
+	}
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai,
+		SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8753_MCLK, pll_out,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set MCLK division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C24XX_DIV_MCLK,
+		S3C2410_IISMOD_32FS);
+	if (ret < 0)
+		return ret;
+
+	/* set codec BCLK division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(codec_dai,
+					WM8753_BCLKDIV, bclk);
+	if (ret < 0)
+		return ret;
+
+	/* set prescaler division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C24XX_DIV_PRESCALER,
+		S3C24XX_PRESCALE(4, 4));
+	if (ret < 0)
+		return ret;
+
+	/* codec PLL input is PCLK/4 */
+	ret = snd_soc_dai_set_pll(codec_dai, WM8753_PLL1,
+		iis_clkrate / 4, pll_out);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int neo1973_gta02_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return snd_soc_dai_set_pll(codec_dai, WM8753_PLL1, 0, 0);
+}
+
+/*
+ * Neo1973 WM8753 HiFi DAI opserations.
+ */
+static struct snd_soc_ops neo1973_gta02_hifi_ops = {
+	.hw_params = neo1973_gta02_hifi_hw_params,
+	.hw_free = neo1973_gta02_hifi_hw_free,
+};
+
+static int neo1973_gta02_voice_hw_params(
+	struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	unsigned int pcmdiv = 0;
+	int ret = 0;
+	unsigned long iis_clkrate;
+
+	iis_clkrate = s3c24xx_i2s_get_clockrate();
+
+	if (params_rate(params) != 8000)
+		return -EINVAL;
+	if (params_channels(params) != 1)
+		return -EINVAL;
+
+	pcmdiv = WM8753_PCM_DIV_6; /* 2.048 MHz */
+
+	/* todo: gg check mode (DSP_B) against CSR datasheet */
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_DSP_B |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8753_PCMCLK,
+		12288000, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set codec PCM division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(codec_dai, WM8753_PCMDIV,
+					pcmdiv);
+	if (ret < 0)
+		return ret;
+
+	/* configue and enable PLL for 12.288MHz output */
+	ret = snd_soc_dai_set_pll(codec_dai, WM8753_PLL2,
+		iis_clkrate / 4, 12288000);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int neo1973_gta02_voice_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return snd_soc_dai_set_pll(codec_dai, WM8753_PLL2, 0, 0);
+}
+
+static struct snd_soc_ops neo1973_gta02_voice_ops = {
+	.hw_params = neo1973_gta02_voice_hw_params,
+	.hw_free = neo1973_gta02_voice_hw_free,
+};
+
+#define LM4853_AMP 1
+#define LM4853_SPK 2
+
+static u8 lm4853_state;
+
+/* This has no effect, it exists only to maintain compatibility with
+ * existing ALSA state files.
+ */
+static int lm4853_set_state(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int val = ucontrol->value.integer.value[0];
+
+	if (val)
+		lm4853_state |= LM4853_AMP;
+	else
+		lm4853_state &= ~LM4853_AMP;
+
+	return 0;
+}
+
+static int lm4853_get_state(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = lm4853_state & LM4853_AMP;
+
+	return 0;
+}
+
+static int lm4853_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int val = ucontrol->value.integer.value[0];
+
+	if (val) {
+		lm4853_state |= LM4853_SPK;
+		s3c2410_gpio_setpin(GTA02_GPIO_HP_IN, 0);
+	} else {
+		lm4853_state &= ~LM4853_SPK;
+		s3c2410_gpio_setpin(GTA02_GPIO_HP_IN, 1);
+	}
+
+	return 0;
+}
+
+static int lm4853_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = (lm4853_state & LM4853_SPK) >> 1;
+
+	return 0;
+}
+
+static int lm4853_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k,
+			int event)
+{
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		s3c2410_gpio_setpin(GTA02_GPIO_AMP_SHUT, 0);
+
+	if (SND_SOC_DAPM_EVENT_OFF(event))
+		s3c2410_gpio_setpin(GTA02_GPIO_AMP_SHUT, 1);
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget wm8753_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("Stereo Out", lm4853_event),
+	SND_SOC_DAPM_LINE("GSM Line Out", NULL),
+	SND_SOC_DAPM_LINE("GSM Line In", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Handset Mic", NULL),
+	SND_SOC_DAPM_SPK("Handset Spk", NULL),
+};
+
+
+/* example machine audio_mapnections */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	/* Connections to the lm4853 amp */
+	{"Stereo Out", NULL, "LOUT1"},
+	{"Stereo Out", NULL, "ROUT1"},
+
+	/* Connections to the GSM Module */
+	{"GSM Line Out", NULL, "MONO1"},
+	{"GSM Line Out", NULL, "MONO2"},
+	{"RXP", NULL, "GSM Line In"},
+	{"RXN", NULL, "GSM Line In"},
+
+	/* Connections to Headset */
+	{"MIC1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Headset Mic"},
+
+	/* Call Mic */
+	{"MIC2", NULL, "Mic Bias"},
+	{"MIC2N", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Handset Mic"},
+
+	/* Call Speaker */
+	{"Handset Spk", NULL, "LOUT2"},
+	{"Handset Spk", NULL, "ROUT2"},
+
+	/* Connect the ALC pins */
+	{"ACIN", NULL, "ACOP"},
+};
+
+static const struct snd_kcontrol_new wm8753_neo1973_gta02_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Stereo Out"),
+	SOC_DAPM_PIN_SWITCH("GSM Line Out"),
+	SOC_DAPM_PIN_SWITCH("GSM Line In"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+	SOC_DAPM_PIN_SWITCH("Handset Mic"),
+	SOC_DAPM_PIN_SWITCH("Handset Spk"),
+
+	/* This has no effect, it exists only to maintain compatibility with
+	 * existing ALSA state files.
+	 */
+	SOC_SINGLE_EXT("Amp State Switch", 6, 0, 1, 0,
+		lm4853_get_state,
+		lm4853_set_state),
+	SOC_SINGLE_EXT("Amp Spk Switch", 7, 0, 1, 0,
+		lm4853_get_spk,
+		lm4853_set_spk),
+};
+
+/*
+ * This is an example machine initialisation for a wm8753 connected to a
+ * neo1973 GTA02.
+ */
+static int neo1973_gta02_wm8753_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* set up NC codec pins */
+	snd_soc_dapm_nc_pin(codec, "OUT3");
+	snd_soc_dapm_nc_pin(codec, "OUT4");
+	snd_soc_dapm_nc_pin(codec, "LINE1");
+	snd_soc_dapm_nc_pin(codec, "LINE2");
+
+	/* Add neo1973 gta02 specific widgets */
+	snd_soc_dapm_new_controls(codec, wm8753_dapm_widgets,
+				  ARRAY_SIZE(wm8753_dapm_widgets));
+
+	/* add neo1973 gta02 specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8753_neo1973_gta02_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8753_neo1973_gta02_controls[i],
+			codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* set up neo1973 gta02 specific audio path audio_map */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	/* set endpoints to default off mode */
+	snd_soc_dapm_disable_pin(codec, "Stereo Out");
+	snd_soc_dapm_disable_pin(codec, "GSM Line Out");
+	snd_soc_dapm_disable_pin(codec, "GSM Line In");
+	snd_soc_dapm_disable_pin(codec, "Headset Mic");
+	snd_soc_dapm_disable_pin(codec, "Handset Mic");
+	snd_soc_dapm_disable_pin(codec, "Handset Spk");
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+/*
+ * BT Codec DAI
+ */
+static struct snd_soc_dai bt_dai = {
+	.name = "Bluetooth",
+	.id = 0,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = SNDRV_PCM_RATE_8000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = SNDRV_PCM_RATE_8000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,},
+};
+
+static struct snd_soc_dai_link neo1973_gta02_dai[] = {
+{ /* Hifi Playback - for similatious use with voice below */
+	.name = "WM8753",
+	.stream_name = "WM8753 HiFi",
+	.cpu_dai = &s3c24xx_i2s_dai,
+	.codec_dai = &wm8753_dai[WM8753_DAI_HIFI],
+	.init = neo1973_gta02_wm8753_init,
+	.ops = &neo1973_gta02_hifi_ops,
+},
+{ /* Voice via BT */
+	.name = "Bluetooth",
+	.stream_name = "Voice",
+	.cpu_dai = &bt_dai,
+	.codec_dai = &wm8753_dai[WM8753_DAI_VOICE],
+	.ops = &neo1973_gta02_voice_ops,
+},
+};
+
+static struct snd_soc_card neo1973_gta02 = {
+	.name = "neo1973-gta02",
+	.platform = &s3c24xx_soc_platform,
+	.dai_link = neo1973_gta02_dai,
+	.num_links = ARRAY_SIZE(neo1973_gta02_dai),
+};
+
+static struct snd_soc_device neo1973_gta02_snd_devdata = {
+	.card = &neo1973_gta02,
+	.codec_dev = &soc_codec_dev_wm8753,
+};
+
+static struct platform_device *neo1973_gta02_snd_device;
+
+static int __init neo1973_gta02_init(void)
+{
+	int ret;
+
+	if (!machine_is_neo1973_gta02()) {
+		printk(KERN_INFO
+		       "Only GTA02 is supported by this ASoC driver\n");
+		return -ENODEV;
+	}
+
+	/* register bluetooth DAI here */
+	ret = snd_soc_register_dai(&bt_dai);
+	if (ret)
+		return ret;
+
+	neo1973_gta02_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!neo1973_gta02_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(neo1973_gta02_snd_device,
+			&neo1973_gta02_snd_devdata);
+	neo1973_gta02_snd_devdata.dev = &neo1973_gta02_snd_device->dev;
+	ret = platform_device_add(neo1973_gta02_snd_device);
+
+	if (ret) {
+		platform_device_put(neo1973_gta02_snd_device);
+		return ret;
+	}
+
+	/* Initialise GPIOs used by amp */
+	s3c2410_gpio_cfgpin(GTA02_GPIO_HP_IN, S3C2410_GPIO_OUTPUT);
+	s3c2410_gpio_cfgpin(GTA02_GPIO_AMP_SHUT, S3C2410_GPIO_OUTPUT);
+
+	/* Amp off by default */
+	s3c2410_gpio_setpin(GTA02_GPIO_AMP_SHUT, 1);
+
+	/* Speaker off by default */
+	s3c2410_gpio_setpin(GTA02_GPIO_HP_IN, 1);
+
+	return ret;
+}
+module_init(neo1973_gta02_init);
+
+static void __exit neo1973_gta02_exit(void)
+{
+	snd_soc_unregister_dai(&bt_dai);
+	platform_device_unregister(neo1973_gta02_snd_device);
+}
+module_exit(neo1973_gta02_exit);
+
+/* Module information */
+MODULE_AUTHOR("Graeme Gregory, graeme@openmoko.org");
+MODULE_DESCRIPTION("ALSA SoC WM8753 Neo1973 GTA02");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/neo1973_wm8753.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/neo1973_wm8753.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/neo1973_wm8753.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/neo1973_wm8753.c	2009-05-10 22:28:00.000000000 +0200
@@ -29,11 +29,11 @@
 #include <mach/regs-clock.h>
 #include <mach/regs-gpio.h>
 #include <mach/hardware.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 #include <linux/io.h>
 #include <mach/spi-gpio.h>
 
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
 
 #include "../codecs/wm8753.h"
 #include "lm4857.h"
@@ -585,15 +585,9 @@
 	.num_links = ARRAY_SIZE(neo1973_dai),
 };
 
-static struct wm8753_setup_data neo1973_wm8753_setup = {
-	.i2c_bus = 0,
-	.i2c_address = 0x1a,
-};
-
 static struct snd_soc_device neo1973_snd_devdata = {
 	.card = &neo1973,
 	.codec_dev = &soc_codec_dev_wm8753,
-	.codec_data = &neo1973_wm8753_setup,
 };
 
 static int lm4857_i2c_probe(struct i2c_client *client,
@@ -652,13 +646,13 @@
 }
 
 static const struct i2c_device_id lm4857_i2c_id[] = {
-	{ "neo1973_lm4857", 0 },
+	{ "lm4857", 0 },
 	{ }
 };
 
 static struct i2c_driver lm4857_i2c_driver = {
 	.driver = {
-		.name = "LM4857 I2C Amp",
+		.name = "lm4857",
 		.owner = THIS_MODULE,
 	},
 	.suspend =        lm4857_suspend,
@@ -675,7 +669,7 @@
 {
 	int ret;
 
-	DBG("Entered %s\n", __func__);
+	printk(KERN_DEBUG "Entered %s\n", __func__);
 
 	if (!machine_is_neo1973_gta01()) {
 		printk(KERN_INFO
@@ -683,6 +677,11 @@
 		return -ENODEV;
 	}
 
+	/* register bluetooth DAI here */
+	ret = snd_soc_register_dai(&bt_dai);
+	if (ret)
+		return ret;
+
 	neo1973_snd_device = platform_device_alloc("soc-audio", -1);
 	if (!neo1973_snd_device)
 		return -ENOMEM;
@@ -708,6 +707,7 @@
 {
 	DBG("Entered %s\n", __func__);
 
+	snd_soc_unregister_dai(&bt_dai);
 	i2c_del_driver(&lm4857_i2c_driver);
 	platform_device_unregister(neo1973_snd_device);
 }
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/om_3d7k_wm8753.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/om_3d7k_wm8753.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/om_3d7k_wm8753.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/om_3d7k_wm8753.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,600 @@
+/*
+ * om_3d7k_wm8753.c  --  SoC audio for 3D7K
+ *
+ * Based on neo1973_gta02_wm8753
+ *
+ * Copyright 2009 Openmoko Inc
+ * Author: Ben Dooks <ben@simtec.co.uk>
+ * Copyright 2007 Openmoko Inc
+ * Author: Graeme Gregory <graeme@openmoko.org>
+ * Copyright 2007 Wolfson Microelectronics PLC.
+ * Author: Graeme Gregory <linux@wolfsonmicro.com>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <asm/hardware/scoop.h>
+
+#include <plat/regs-s3c2412-iis.h>
+
+#include "../codecs/wm8753.h"
+#include "s3c24xx-pcm.h"
+#include "s3c64xx-i2s.h"
+
+/* define the scenarios */
+#define NEO_AUDIO_OFF			0
+#define NEO_GSM_CALL_AUDIO_HANDSET	1
+#define NEO_GSM_CALL_AUDIO_HEADSET	2
+#define NEO_GSM_CALL_AUDIO_BLUETOOTH	3
+#define NEO_STEREO_TO_SPEAKERS		4
+#define NEO_STEREO_TO_HEADPHONES	5
+#define NEO_CAPTURE_HANDSET		6
+#define NEO_CAPTURE_HEADSET		7
+#define NEO_CAPTURE_BLUETOOTH		8
+#define NEO_STEREO_TO_HANDSET_SPK	9
+
+static struct snd_soc_card om_3d7k;
+
+static int om_3d7k_hifi_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int pll_out = 0, bclk = 0;
+	int ret = 0;
+	unsigned long iis_clkrate;
+
+	iis_clkrate = s3c64xx_i2s_get_clockrate(cpu_dai);
+
+	switch (params_rate(params)) {
+	case 8000:
+	case 16000:
+		pll_out = 12288000;
+		break;
+	case 48000:
+		bclk = WM8753_BCLK_DIV_4;
+		pll_out = 12288000;
+		break;
+	case 96000:
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 12288000;
+		break;
+	case 11025:
+		bclk = WM8753_BCLK_DIV_16;
+		pll_out = 11289600;
+		break;
+	case 22050:
+		bclk = WM8753_BCLK_DIV_8;
+		pll_out = 11289600;
+		break;
+	case 44100:
+		bclk = WM8753_BCLK_DIV_4;
+		pll_out = 11289600;
+		break;
+	case 88200:
+		bclk = WM8753_BCLK_DIV_2;
+		pll_out = 11289600;
+		break;
+	}
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, S3C64XX_CLKSRC_MUX, 0,
+				     SND_SOC_CLOCK_OUT);
+	if (ret < 0)
+		goto err;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai,
+				  SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		goto err;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai,
+				  SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+				  SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		goto err;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8753_MCLK, pll_out,
+				     SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		goto err;
+
+#if 0
+	/* do not think we need to set this if the cpu is not the bitclk
+	 * master */
+	/* set MCLK division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C24XX_DIV_MCLK,
+				     S3C2410_IISMOD_32FS);
+	if (ret < 0)
+		return ret;
+#endif
+
+	/* set codec BCLK division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(codec_dai, WM8753_BCLKDIV, bclk);
+	if (ret < 0)
+		goto err;
+
+	/* set prescaler division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C64XX_DIV_PRESCALER, 2-1);
+	if (ret < 0)
+		goto err;
+
+	/* codec PLL input is ACLK/2 */
+	ret = snd_soc_dai_set_pll(codec_dai, WM8753_PLL1,
+				  iis_clkrate / 2, pll_out);
+	if (ret < 0)
+		goto err;
+
+	return 0;
+
+err:
+	printk(KERN_ERR "%s: failed %d\n", __func__, ret);
+	return ret;
+}
+
+static int om_3d7k_hifi_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return snd_soc_dai_set_pll(codec_dai, WM8753_PLL1, 0, 0);
+}
+
+/*
+ * 3D7K WM8753 HiFi DAI opserations.
+ */
+static struct snd_soc_ops om_3d7k_hifi_ops = {
+	.hw_params	= om_3d7k_hifi_hw_params,
+	.hw_free	= om_3d7k_hifi_hw_free,
+};
+
+static int om_3d7k_voice_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	unsigned int pcmdiv = 0;
+	int ret = 0;
+	unsigned long iis_clkrate;
+
+	iis_clkrate = s3c64xx_i2s_get_clockrate(rtd->dai->cpu_dai);
+
+	if (params_rate(params) != 8000)
+		return -EINVAL;
+	if (params_channels(params) != 1)
+		return -EINVAL;
+
+	pcmdiv = WM8753_PCM_DIV_6; /* 2.048 MHz */
+
+	/* todo: gg check mode (DSP_B) against CSR datasheet */
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, (SND_SOC_DAIFMT_DSP_B |
+					      SND_SOC_DAIFMT_NB_NF |
+					      SND_SOC_DAIFMT_CBS_CFS));
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8753_PCMCLK,
+				     12288000, SND_SOC_CLOCK_IN);
+	if (ret < 0)
+		return ret;
+
+	/* set codec PCM division for sample rate */
+	ret = snd_soc_dai_set_clkdiv(codec_dai, WM8753_PCMDIV, pcmdiv);
+	if (ret < 0)
+		return ret;
+
+	/* configue and enable PLL for 12.288MHz output */
+	ret = snd_soc_dai_set_pll(codec_dai, WM8753_PLL2,
+				  iis_clkrate / 2, 12288000);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int om_3d7k_voice_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+
+	/* disable the PLL */
+	return snd_soc_dai_set_pll(codec_dai, WM8753_PLL2, 0, 0);
+}
+
+static struct snd_soc_ops om_3d7k_voice_ops = {
+	.hw_params	= om_3d7k_voice_hw_params,
+	.hw_free	= om_3d7k_voice_hw_free,
+};
+
+static int om_3d7k_set_stereo_out(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "Stereo Out", val);
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_stereo_out(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "Stereo Out");
+
+	return 0;
+}
+
+
+static int om_3d7k_set_gsm_out(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "GSM Line Out", val);
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_gsm_out(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "GSM Line Out");
+
+	return 0;
+}
+
+static int om_3d7k_set_gsm_in(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "GSM Line In", val);
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_gsm_in(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "GSM Line In");
+
+	return 0;
+}
+
+static int om_3d7k_set_headset_mic(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "Headset Mic", val);
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_headset_mic(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "Headset Mic");
+
+	return 0;
+}
+
+static int om_3d7k_set_handset_mic(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "Handset Mic", val);
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_handset_mic(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "Handset Mic");
+
+	return 0;
+}
+
+static int om_3d7k_set_handset_spk(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "Handset Spk", val);
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_handset_spk(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "Handset Spk");
+
+	return 0;
+}
+
+static int om_3d7k_set_headset_spk(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int val = ucontrol->value.integer.value[0];
+
+	snd_soc_dapm_set_endpoint(codec, "Headset Spk", val);
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+static int om_3d7k_get_headset_spk(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_endpoint(codec, "Headset Spk");
+
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget wm8753_dapm_widgets[] = {
+	SND_SOC_DAPM_LINE("Stereo Out", NULL),
+	SND_SOC_DAPM_LINE("GSM Line Out", NULL),
+	SND_SOC_DAPM_LINE("GSM Line In", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Handset Mic", NULL),
+	SND_SOC_DAPM_SPK("Handset Spk", NULL),
+	SND_SOC_DAPM_SPK("Headset Spk", NULL),
+};
+
+
+/* example machine audio_mapnections */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	{"Stereo Out", NULL, "LOUT2"},
+	{"Stereo Out", NULL, "ROUT2"},
+
+	/* Connections to the GSM Module */
+	{"GSM Line Out", NULL, "MONO1"},
+	{"GSM Line Out", NULL, "MONO2"},
+	{"RXP", NULL, "GSM Line In"},
+	{"RXN", NULL, "GSM Line In"},
+
+	/* Connections to Headset */
+	{"MIC1", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Headset Mic"},
+
+	/* Call Mic */
+	{"MIC2", NULL, "Mic Bias"},
+	{"MIC2N", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Handset Mic"},
+
+	/* Call Speaker */
+	{"Handset Spk", NULL, "OUT3"},
+	{"Handset Spk", NULL, "LOUT1"},
+
+	{"Headset Spk", NULL, "ROUT1"},
+	{"Headset Spk", NULL, "LOUT1"},
+
+	/* Connect the ALC pins */
+	{"ACIN", NULL, "ACOP"},
+};
+
+static const struct snd_kcontrol_new wm8753_om_3d7k_controls[] = {
+	SOC_SINGLE_EXT("DAPM Stereo Out Switch", 0, 0, 1, 0,
+		om_3d7k_get_stereo_out,
+		om_3d7k_set_stereo_out),
+	SOC_SINGLE_EXT("DAPM GSM Line Out Switch", 1, 0, 1, 0,
+		om_3d7k_get_gsm_out,
+		om_3d7k_set_gsm_out),
+	SOC_SINGLE_EXT("DAPM GSM Line In Switch", 2, 0, 1, 0,
+		om_3d7k_get_gsm_in,
+		om_3d7k_set_gsm_in),
+	SOC_SINGLE_EXT("DAPM Headset Mic Switch", 3, 0, 1, 0,
+		om_3d7k_get_headset_mic,
+		om_3d7k_set_headset_mic),
+	SOC_SINGLE_EXT("DAPM Handset Mic Switch", 4, 0, 1, 0,
+		om_3d7k_get_handset_mic,
+		om_3d7k_set_handset_mic),
+	SOC_SINGLE_EXT("DAPM Handset Spk Switch", 5, 0, 1, 0,
+		om_3d7k_get_handset_spk,
+		om_3d7k_set_handset_spk),
+	SOC_SINGLE_EXT("DAPM Headset Spk Switch", 6, 0, 1, 0,
+		om_3d7k_get_headset_spk,
+		om_3d7k_set_headset_spk),
+};
+
+/*
+ * This is an example machine initialisation for a wm8753 connected to a
+ * neo1973 GTA02.
+ */
+static int om_3d7k_wm8753_init(struct snd_soc_codec *codec)
+{
+	int i, err;
+
+	/* set up NC codec pins */
+	snd_soc_dapm_set_endpoint(codec, "OUT4",  0);
+	snd_soc_dapm_set_endpoint(codec, "LINE1", 0);
+	snd_soc_dapm_set_endpoint(codec, "LINE2", 0);
+
+
+	/* Add neo1973 gta02 specific widgets */
+	snd_soc_dapm_new_controls(codec, wm8753_dapm_widgets,
+				  ARRAY_SIZE(wm8753_dapm_widgets));
+
+	/* add neo1973 gta02 specific controls */
+	for (i = 0; i < ARRAY_SIZE(wm8753_om_3d7k_controls); i++) {
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&wm8753_om_3d7k_controls[i],
+			codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	/* set up neo1973 gta02 specific audio path audio_mapnects */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	/* set endpoints to default off mode */
+	snd_soc_dapm_set_endpoint(codec, "Stereo Out",  0);
+	snd_soc_dapm_set_endpoint(codec, "GSM Line Out",0);
+	snd_soc_dapm_set_endpoint(codec, "GSM Line In", 0);
+	snd_soc_dapm_set_endpoint(codec, "Headset Mic", 0);
+	snd_soc_dapm_set_endpoint(codec, "Handset Mic", 0);
+	snd_soc_dapm_set_endpoint(codec, "Handset Spk", 0);
+	snd_soc_dapm_set_endpoint(codec, "Headset Spk", 0);
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+/*
+ * BT Codec DAI
+ */
+static struct snd_soc_dai bt_dai =
+{	.name = "Bluetooth",
+	.id = 0,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = SNDRV_PCM_RATE_8000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 1,
+		.rates = SNDRV_PCM_RATE_8000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+};
+
+static struct snd_soc_dai_link om_3d7k_dai[] = {
+	{ /* Hifi Playback - for similatious use with voice below */
+		.name		= "WM8753",
+		.stream_name	= "WM8753 HiFi",
+		.cpu_dai	= &s3c64xx_i2s_dai,
+		.codec_dai	= &wm8753_dai[WM8753_DAI_HIFI],
+		.init		= om_3d7k_wm8753_init,
+		.ops		= &om_3d7k_hifi_ops,
+	},
+	{ /* Voice via BT */
+		.name		= "Bluetooth",
+		.stream_name	= "Voice",
+		.cpu_dai	= &bt_dai,
+		.codec_dai	= &wm8753_dai[WM8753_DAI_VOICE],
+		.ops		= &om_3d7k_voice_ops,
+	},
+};
+
+static struct snd_soc_card om_3d7k = {
+	.name		= "om-3d7k",
+	.platform	= &s3c24xx_soc_platform,
+	.dai_link	= om_3d7k_dai,
+	.num_links	= ARRAY_SIZE(om_3d7k_dai),
+};
+
+static struct snd_soc_device om_3d7k_snd_devdata = {
+	.card		= &om_3d7k,
+	.codec_dev	= &soc_codec_dev_wm8753,
+};
+
+static struct platform_device *om_3d7k_snd_device;
+
+static int __init om_3d7k_init(void)
+{
+	int ret;
+
+	if (!machine_is_om_3d7k()) {
+		printk(KERN_INFO "Only 3D7K supported by ASoC driver\n");
+		return -ENODEV;
+	}
+
+	/* register bluetooth DAI here */
+	ret = snd_soc_register_dai(&bt_dai);
+	if (ret)
+		return ret;
+
+	om_3d7k_snd_device = platform_device_alloc("soc-audio", 1);
+	if (!om_3d7k_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(om_3d7k_snd_device, &om_3d7k_snd_devdata);
+	om_3d7k_snd_devdata.dev = &om_3d7k_snd_device->dev;
+	ret = platform_device_add(om_3d7k_snd_device);
+
+	if (ret) {
+		platform_device_put(om_3d7k_snd_device);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit om_3d7k_exit(void)
+{
+	platform_device_unregister(om_3d7k_snd_device);
+}
+
+module_init(om_3d7k_init);
+module_exit(om_3d7k_exit);
+
+/* Module information */
+MODULE_AUTHOR("Graeme Gregory, graeme@openmoko.org; Ben Dooks <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("ALSA SoC WM8753 OM 3D7K");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c2412-i2s.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c2412-i2s.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c2412-i2s.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c2412-i2s.c	2009-05-10 22:28:00.000000000 +0200
@@ -22,6 +22,7 @@
 #include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/kernel.h>
+#include <linux/io.h>
 
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -30,20 +31,16 @@
 #include <sound/soc.h>
 #include <mach/hardware.h>
 
-#include <linux/io.h>
-#include <asm/dma.h>
-
-#include <asm/plat-s3c24xx/regs-s3c2412-iis.h>
+#include <plat/regs-s3c2412-iis.h>
 
-#include <mach/regs-gpio.h>
-#include <mach/audio.h>
+#include <plat/regs-gpio.h>
+#include <plat/audio.h>
 #include <mach/dma.h>
 
 #include "s3c24xx-pcm.h"
 #include "s3c2412-i2s.h"
 
 #define S3C2412_I2S_DEBUG 0
-#define S3C2412_I2S_DEBUG_CON 0
 
 #if S3C2412_I2S_DEBUG
 #define DBG(x...) printk(KERN_INFO x)
@@ -73,431 +70,7 @@
 	.dma_size	= 4,
 };
 
-struct s3c2412_i2s_info {
-	struct device	*dev;
-	void __iomem	*regs;
-	struct clk	*iis_clk;
-	struct clk	*iis_pclk;
-	struct clk	*iis_cclk;
-
-	u32		 suspend_iismod;
-	u32		 suspend_iiscon;
-	u32		 suspend_iispsr;
-};
-
-static struct s3c2412_i2s_info s3c2412_i2s;
-
-#define bit_set(v, b) (((v) & (b)) ? 1 : 0)
-
-#if S3C2412_I2S_DEBUG_CON
-static void dbg_showcon(const char *fn, u32 con)
-{
-	printk(KERN_DEBUG "%s: LRI=%d, TXFEMPT=%d, RXFEMPT=%d, TXFFULL=%d, RXFFULL=%d\n", fn,
-	       bit_set(con, S3C2412_IISCON_LRINDEX),
-	       bit_set(con, S3C2412_IISCON_TXFIFO_EMPTY),
-	       bit_set(con, S3C2412_IISCON_RXFIFO_EMPTY),
-	       bit_set(con, S3C2412_IISCON_TXFIFO_FULL),
-	       bit_set(con, S3C2412_IISCON_RXFIFO_FULL));
-
-	printk(KERN_DEBUG "%s: PAUSE: TXDMA=%d, RXDMA=%d, TXCH=%d, RXCH=%d\n",
-	       fn,
-	       bit_set(con, S3C2412_IISCON_TXDMA_PAUSE),
-	       bit_set(con, S3C2412_IISCON_RXDMA_PAUSE),
-	       bit_set(con, S3C2412_IISCON_TXCH_PAUSE),
-	       bit_set(con, S3C2412_IISCON_RXCH_PAUSE));
-	printk(KERN_DEBUG "%s: ACTIVE: TXDMA=%d, RXDMA=%d, IIS=%d\n", fn,
-	       bit_set(con, S3C2412_IISCON_TXDMA_ACTIVE),
-	       bit_set(con, S3C2412_IISCON_RXDMA_ACTIVE),
-	       bit_set(con, S3C2412_IISCON_IIS_ACTIVE));
-}
-#else
-static inline void dbg_showcon(const char *fn, u32 con)
-{
-}
-#endif
-
-/* Turn on or off the transmission path. */
-static void s3c2412_snd_txctrl(int on)
-{
-	struct s3c2412_i2s_info *i2s = &s3c2412_i2s;
-	void __iomem *regs = i2s->regs;
-	u32 fic, con, mod;
-
-	DBG("%s(%d)\n", __func__, on);
-
-	fic = readl(regs + S3C2412_IISFIC);
-	con = readl(regs + S3C2412_IISCON);
-	mod = readl(regs + S3C2412_IISMOD);
-
-	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
-
-	if (on) {
-		con |= S3C2412_IISCON_TXDMA_ACTIVE | S3C2412_IISCON_IIS_ACTIVE;
-		con &= ~S3C2412_IISCON_TXDMA_PAUSE;
-		con &= ~S3C2412_IISCON_TXCH_PAUSE;
-
-		switch (mod & S3C2412_IISMOD_MODE_MASK) {
-		case S3C2412_IISMOD_MODE_TXONLY:
-		case S3C2412_IISMOD_MODE_TXRX:
-			/* do nothing, we are in the right mode */
-			break;
-
-		case S3C2412_IISMOD_MODE_RXONLY:
-			mod &= ~S3C2412_IISMOD_MODE_MASK;
-			mod |= S3C2412_IISMOD_MODE_TXRX;
-			break;
-
-		default:
-			dev_err(i2s->dev, "TXEN: Invalid MODE in IISMOD\n");
-		}
-
-		writel(con, regs + S3C2412_IISCON);
-		writel(mod, regs + S3C2412_IISMOD);
-	} else {
-		/* Note, we do not have any indication that the FIFO problems
-		 * tha the S3C2410/2440 had apply here, so we should be able
-		 * to disable the DMA and TX without resetting the FIFOS.
-		 */
-
-		con |=  S3C2412_IISCON_TXDMA_PAUSE;
-		con |=  S3C2412_IISCON_TXCH_PAUSE;
-		con &= ~S3C2412_IISCON_TXDMA_ACTIVE;
-
-		switch (mod & S3C2412_IISMOD_MODE_MASK) {
-		case S3C2412_IISMOD_MODE_TXRX:
-			mod &= ~S3C2412_IISMOD_MODE_MASK;
-			mod |= S3C2412_IISMOD_MODE_RXONLY;
-			break;
-
-		case S3C2412_IISMOD_MODE_TXONLY:
-			mod &= ~S3C2412_IISMOD_MODE_MASK;
-			con &= ~S3C2412_IISCON_IIS_ACTIVE;
-			break;
-
-		default:
-			dev_err(i2s->dev, "TXDIS: Invalid MODE in IISMOD\n");
-		}
-
-		writel(mod, regs + S3C2412_IISMOD);
-		writel(con, regs + S3C2412_IISCON);
-	}
-
-	fic = readl(regs + S3C2412_IISFIC);
-	dbg_showcon(__func__, con);
-	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
-}
-
-static void s3c2412_snd_rxctrl(int on)
-{
-	struct s3c2412_i2s_info *i2s = &s3c2412_i2s;
-	void __iomem *regs = i2s->regs;
-	u32 fic, con, mod;
-
-	DBG("%s(%d)\n", __func__, on);
-
-	fic = readl(regs + S3C2412_IISFIC);
-	con = readl(regs + S3C2412_IISCON);
-	mod = readl(regs + S3C2412_IISMOD);
-
-	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
-
-	if (on) {
-		con |= S3C2412_IISCON_RXDMA_ACTIVE | S3C2412_IISCON_IIS_ACTIVE;
-		con &= ~S3C2412_IISCON_RXDMA_PAUSE;
-		con &= ~S3C2412_IISCON_RXCH_PAUSE;
-
-		switch (mod & S3C2412_IISMOD_MODE_MASK) {
-		case S3C2412_IISMOD_MODE_TXRX:
-		case S3C2412_IISMOD_MODE_RXONLY:
-			/* do nothing, we are in the right mode */
-			break;
-
-		case S3C2412_IISMOD_MODE_TXONLY:
-			mod &= ~S3C2412_IISMOD_MODE_MASK;
-			mod |= S3C2412_IISMOD_MODE_TXRX;
-			break;
-
-		default:
-			dev_err(i2s->dev, "RXEN: Invalid MODE in IISMOD\n");
-		}
-
-		writel(mod, regs + S3C2412_IISMOD);
-		writel(con, regs + S3C2412_IISCON);
-	} else {
-		/* See txctrl notes on FIFOs. */
-
-		con &= ~S3C2412_IISCON_RXDMA_ACTIVE;
-		con |=  S3C2412_IISCON_RXDMA_PAUSE;
-		con |=  S3C2412_IISCON_RXCH_PAUSE;
-
-		switch (mod & S3C2412_IISMOD_MODE_MASK) {
-		case S3C2412_IISMOD_MODE_RXONLY:
-			con &= ~S3C2412_IISCON_IIS_ACTIVE;
-			mod &= ~S3C2412_IISMOD_MODE_MASK;
-			break;
-
-		case S3C2412_IISMOD_MODE_TXRX:
-			mod &= ~S3C2412_IISMOD_MODE_MASK;
-			mod |= S3C2412_IISMOD_MODE_TXONLY;
-			break;
-
-		default:
-			dev_err(i2s->dev, "RXEN: Invalid MODE in IISMOD\n");
-		}
-
-		writel(con, regs + S3C2412_IISCON);
-		writel(mod, regs + S3C2412_IISMOD);
-	}
-
-	fic = readl(regs + S3C2412_IISFIC);
-	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
-}
-
-
-/*
- * Wait for the LR signal to allow synchronisation to the L/R clock
- * from the codec. May only be needed for slave mode.
- */
-static int s3c2412_snd_lrsync(void)
-{
-	u32 iiscon;
-	unsigned long timeout = jiffies + msecs_to_jiffies(5);
-
-	DBG("Entered %s\n", __func__);
-
-	while (1) {
-		iiscon = readl(s3c2412_i2s.regs + S3C2412_IISCON);
-		if (iiscon & S3C2412_IISCON_LRINDEX)
-			break;
-
-		if (timeout < jiffies) {
-			printk(KERN_ERR "%s: timeout\n", __func__);
-			return -ETIMEDOUT;
-		}
-	}
-
-	return 0;
-}
-
-/*
- * Check whether CPU is the master or slave
- */
-static inline int s3c2412_snd_is_clkmaster(void)
-{
-	u32 iismod = readl(s3c2412_i2s.regs + S3C2412_IISMOD);
-
-	DBG("Entered %s\n", __func__);
-
-	iismod &= S3C2412_IISMOD_MASTER_MASK;
-	return !(iismod == S3C2412_IISMOD_SLAVE);
-}
-
-/*
- * Set S3C2412 I2S DAI format
- */
-static int s3c2412_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
-			       unsigned int fmt)
-{
-	u32 iismod;
-
-
-	DBG("Entered %s\n", __func__);
-
-	iismod = readl(s3c2412_i2s.regs + S3C2412_IISMOD);
-	DBG("hw_params r: IISMOD: %x \n", iismod);
-
-	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
-	case SND_SOC_DAIFMT_CBM_CFM:
-		iismod &= ~S3C2412_IISMOD_MASTER_MASK;
-		iismod |= S3C2412_IISMOD_SLAVE;
-		break;
-	case SND_SOC_DAIFMT_CBS_CFS:
-		iismod &= ~S3C2412_IISMOD_MASTER_MASK;
-		iismod |= S3C2412_IISMOD_MASTER_INTERNAL;
-		break;
-	default:
-		DBG("unknwon master/slave format\n");
-		return -EINVAL;
-	}
-
-	iismod &= ~S3C2412_IISMOD_SDF_MASK;
-
-	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
-	case SND_SOC_DAIFMT_RIGHT_J:
-		iismod |= S3C2412_IISMOD_SDF_MSB;
-		break;
-	case SND_SOC_DAIFMT_LEFT_J:
-		iismod |= S3C2412_IISMOD_SDF_LSB;
-		break;
-	case SND_SOC_DAIFMT_I2S:
-		iismod |= S3C2412_IISMOD_SDF_IIS;
-		break;
-	default:
-		DBG("Unknown data format\n");
-		return -EINVAL;
-	}
-
-	writel(iismod, s3c2412_i2s.regs + S3C2412_IISMOD);
-	DBG("hw_params w: IISMOD: %x \n", iismod);
-	return 0;
-}
-
-static int s3c2412_i2s_hw_params(struct snd_pcm_substream *substream,
-				 struct snd_pcm_hw_params *params,
-				 struct snd_soc_dai *dai)
-{
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	u32 iismod;
-
-	DBG("Entered %s\n", __func__);
-
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		rtd->dai->cpu_dai->dma_data = &s3c2412_i2s_pcm_stereo_out;
-	else
-		rtd->dai->cpu_dai->dma_data = &s3c2412_i2s_pcm_stereo_in;
-
-	/* Working copies of register */
-	iismod = readl(s3c2412_i2s.regs + S3C2412_IISMOD);
-	DBG("%s: r: IISMOD: %x\n", __func__, iismod);
-
-	switch (params_format(params)) {
-	case SNDRV_PCM_FORMAT_S8:
-		iismod |= S3C2412_IISMOD_8BIT;
-		break;
-	case SNDRV_PCM_FORMAT_S16_LE:
-		iismod &= ~S3C2412_IISMOD_8BIT;
-		break;
-	}
-
-	writel(iismod, s3c2412_i2s.regs + S3C2412_IISMOD);
-	DBG("%s: w: IISMOD: %x\n", __func__, iismod);
-	return 0;
-}
-
-static int s3c2412_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
-			       struct snd_soc_dai *dai)
-{
-	int capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
-	unsigned long irqs;
-	int ret = 0;
-
-	DBG("Entered %s\n", __func__);
-
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		/* On start, ensure that the FIFOs are cleared and reset. */
-
-		writel(capture ? S3C2412_IISFIC_RXFLUSH : S3C2412_IISFIC_TXFLUSH,
-		       s3c2412_i2s.regs + S3C2412_IISFIC);
-
-		/* clear again, just in case */
-		writel(0x0, s3c2412_i2s.regs + S3C2412_IISFIC);
-
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (!s3c2412_snd_is_clkmaster()) {
-			ret = s3c2412_snd_lrsync();
-			if (ret)
-				goto exit_err;
-		}
-
-		local_irq_save(irqs);
-
-		if (capture)
-			s3c2412_snd_rxctrl(1);
-		else
-			s3c2412_snd_txctrl(1);
-
-		local_irq_restore(irqs);
-		break;
-
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		local_irq_save(irqs);
-
-		if (capture)
-			s3c2412_snd_rxctrl(0);
-		else
-			s3c2412_snd_txctrl(0);
-
-		local_irq_restore(irqs);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-exit_err:
-	return ret;
-}
-
-/* default table of all avaialable root fs divisors */
-static unsigned int s3c2412_iis_fs[] = { 256, 512, 384, 768, 0 };
-
-int s3c2412_iis_calc_rate(struct s3c2412_rate_calc *info,
-			  unsigned int *fstab,
-			  unsigned int rate, struct clk *clk)
-{
-	unsigned long clkrate = clk_get_rate(clk);
-	unsigned int div;
-	unsigned int fsclk;
-	unsigned int actual;
-	unsigned int fs;
-	unsigned int fsdiv;
-	signed int deviation = 0;
-	unsigned int best_fs = 0;
-	unsigned int best_div = 0;
-	unsigned int best_rate = 0;
-	unsigned int best_deviation = INT_MAX;
-
-
-	if (fstab == NULL)
-		fstab = s3c2412_iis_fs;
-
-	for (fs = 0;; fs++) {
-		fsdiv = s3c2412_iis_fs[fs];
-
-		if (fsdiv == 0)
-			break;
-
-		fsclk = clkrate / fsdiv;
-		div = fsclk / rate;
-
-		if ((fsclk % rate) > (rate / 2))
-			div++;
-
-		if (div <= 1)
-			continue;
-
-		actual = clkrate / (fsdiv * div);
-		deviation = actual - rate;
-
-		printk(KERN_DEBUG "%dfs: div %d => result %d, deviation %d\n",
-		       fsdiv, div, actual, deviation);
-
-		deviation = abs(deviation);
-
-		if (deviation < best_deviation) {
-			best_fs = fsdiv;
-			best_div = div;
-			best_rate = actual;
-			best_deviation = deviation;
-		}
-
-		if (deviation == 0)
-			break;
-	}
-
-	printk(KERN_DEBUG "best: fs=%d, div=%d, rate=%d\n",
-	       best_fs, best_div, best_rate);
-
-	info->fs_div = best_fs;
-	info->clk_div = best_div;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(s3c2412_iis_calc_rate);
+static struct s3c_i2sv2_info s3c2412_i2s;
 
 /*
  * Set S3C2412 Clock source
@@ -512,10 +85,12 @@
 
 	switch (clk_id) {
 	case S3C2412_CLKSRC_PCLK:
+		s3c2412_i2s.master = 1;
 		iismod &= ~S3C2412_IISMOD_MASTER_MASK;
 		iismod |= S3C2412_IISMOD_MASTER_INTERNAL;
 		break;
 	case S3C2412_CLKSRC_I2SCLK:
+		s3c2412_i2s.master = 0;
 		iismod &= ~S3C2412_IISMOD_MASTER_MASK;
 		iismod |= S3C2412_IISMOD_MASTER_EXTERNAL;
 		break;
@@ -527,74 +102,6 @@
 	return 0;
 }
 
-/*
- * Set S3C2412 Clock dividers
- */
-static int s3c2412_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
-				  int div_id, int div)
-{
-	struct s3c2412_i2s_info *i2s = &s3c2412_i2s;
-	u32 reg;
-
-	DBG("%s(%p, %d, %d)\n", __func__, cpu_dai, div_id, div);
-
-	switch (div_id) {
-	case S3C2412_DIV_BCLK:
-		reg = readl(i2s->regs + S3C2412_IISMOD);
-		reg &= ~S3C2412_IISMOD_BCLK_MASK;
-		writel(reg | div, i2s->regs + S3C2412_IISMOD);
-
-		DBG("%s: MOD=%08x\n", __func__, readl(i2s->regs + S3C2412_IISMOD));
-		break;
-
-	case S3C2412_DIV_RCLK:
-		if (div > 3) {
-			/* convert value to bit field */
-
-			switch (div) {
-			case 256:
-				div = S3C2412_IISMOD_RCLK_256FS;
-				break;
-
-			case 384:
-				div = S3C2412_IISMOD_RCLK_384FS;
-				break;
-
-			case 512:
-				div = S3C2412_IISMOD_RCLK_512FS;
-				break;
-
-			case 768:
-				div = S3C2412_IISMOD_RCLK_768FS;
-				break;
-
-			default:
-				return -EINVAL;
-			}
-		}
-
-		reg = readl(s3c2412_i2s.regs + S3C2412_IISMOD);
-		reg &= ~S3C2412_IISMOD_RCLK_MASK;
-		writel(reg | div, i2s->regs + S3C2412_IISMOD);
-		DBG("%s: MOD=%08x\n", __func__, readl(i2s->regs + S3C2412_IISMOD));
-		break;
-
-	case S3C2412_DIV_PRESCALER:
-		if (div >= 0) {
-			writel((div << 8) | S3C2412_IISPSR_PSREN,
-			       i2s->regs + S3C2412_IISPSR);
-		} else {
-			writel(0x0, i2s->regs + S3C2412_IISPSR);
-		}
-		DBG("%s: PSR=%08x\n", __func__, readl(i2s->regs + S3C2412_IISPSR));
-		break;
-
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
 
 struct clk *s3c2412_get_iisclk(void)
 {
@@ -606,20 +113,16 @@
 static int s3c2412_i2s_probe(struct platform_device *pdev,
 			     struct snd_soc_dai *dai)
 {
+	int ret;
+
 	DBG("Entered %s\n", __func__);
 
-	s3c2412_i2s.dev = &pdev->dev;
+	ret = s3c_i2sv2_probe(pdev, dai, &s3c2412_i2s, S3C2410_PA_IIS);
+	if (ret)
+		return ret;
 
-	s3c2412_i2s.regs = ioremap(S3C2410_PA_IIS, 0x100);
-	if (s3c2412_i2s.regs == NULL)
-		return -ENXIO;
-
-	s3c2412_i2s.iis_pclk = clk_get(&pdev->dev, "iis");
-	if (s3c2412_i2s.iis_pclk == NULL) {
-		DBG("failed to get iis_clock\n");
-		iounmap(s3c2412_i2s.regs);
-		return -ENODEV;
-	}
+	s3c2412_i2s.dma_capture = &s3c2412_i2s_pcm_stereo_in;
+	s3c2412_i2s.dma_playback = &s3c2412_i2s_pcm_stereo_out;
 
 	s3c2412_i2s.iis_cclk = clk_get(&pdev->dev, "i2sclk");
 	if (s3c2412_i2s.iis_cclk == NULL) {
@@ -628,12 +131,12 @@
 		return -ENODEV;
 	}
 
-	clk_set_parent(s3c2412_i2s.iis_cclk, clk_get(NULL, "mpll"));
+	/* Set MPLL as the source for IIS CLK */
 
-	clk_enable(s3c2412_i2s.iis_pclk);
+	clk_set_parent(s3c2412_i2s.iis_cclk, clk_get(NULL, "mpll"));
 	clk_enable(s3c2412_i2s.iis_cclk);
 
-	s3c2412_i2s.iis_clk = s3c2412_i2s.iis_pclk;
+	s3c2412_i2s.iis_cclk = s3c2412_i2s.iis_pclk;
 
 	/* Configure the I2S pins in correct mode */
 	s3c2410_gpio_cfgpin(S3C2410_GPE0, S3C2410_GPE0_I2SLRCK);
@@ -642,66 +145,8 @@
 	s3c2410_gpio_cfgpin(S3C2410_GPE3, S3C2410_GPE3_I2SSDI);
 	s3c2410_gpio_cfgpin(S3C2410_GPE4, S3C2410_GPE4_I2SSDO);
 
-	s3c2412_snd_txctrl(0);
-	s3c2412_snd_rxctrl(0);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int s3c2412_i2s_suspend(struct snd_soc_dai *dai)
-{
-	struct s3c2412_i2s_info *i2s = &s3c2412_i2s;
-	u32 iismod;
-
-	if (dai->active) {
-		i2s->suspend_iismod = readl(i2s->regs + S3C2412_IISMOD);
-		i2s->suspend_iiscon = readl(i2s->regs + S3C2412_IISCON);
-		i2s->suspend_iispsr = readl(i2s->regs + S3C2412_IISPSR);
-
-		/* some basic suspend checks */
-
-		iismod = readl(i2s->regs + S3C2412_IISMOD);
-
-		if (iismod & S3C2412_IISCON_RXDMA_ACTIVE)
-			pr_warning("%s: RXDMA active?\n", __func__);
-
-		if (iismod & S3C2412_IISCON_TXDMA_ACTIVE)
-			pr_warning("%s: TXDMA active?\n", __func__);
-
-		if (iismod & S3C2412_IISCON_IIS_ACTIVE)
-			pr_warning("%s: IIS active\n", __func__);
-	}
-
-	return 0;
-}
-
-static int s3c2412_i2s_resume(struct snd_soc_dai *dai)
-{
-	struct s3c2412_i2s_info *i2s = &s3c2412_i2s;
-
-	pr_info("dai_active %d, IISMOD %08x, IISCON %08x\n",
-		dai->active, i2s->suspend_iismod, i2s->suspend_iiscon);
-
-	if (dai->active) {
-		writel(i2s->suspend_iiscon, i2s->regs + S3C2412_IISCON);
-		writel(i2s->suspend_iismod, i2s->regs + S3C2412_IISMOD);
-		writel(i2s->suspend_iispsr, i2s->regs + S3C2412_IISPSR);
-
-		writel(S3C2412_IISFIC_RXFLUSH | S3C2412_IISFIC_TXFLUSH,
-		       i2s->regs + S3C2412_IISFIC);
-
-		ndelay(250);
-		writel(0x0, i2s->regs + S3C2412_IISFIC);
-
-	}
-
 	return 0;
 }
-#else
-#define s3c2412_i2s_suspend NULL
-#define s3c2412_i2s_resume  NULL
-#endif /* CONFIG_PM */
 
 #define S3C2412_I2S_RATES \
 	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
@@ -709,11 +154,9 @@
 	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
 
 struct snd_soc_dai s3c2412_i2s_dai = {
-	.name	= "s3c2412-i2s",
-	.id	= 0,
-	.probe	= s3c2412_i2s_probe,
-	.suspend = s3c2412_i2s_suspend,
-	.resume = s3c2412_i2s_resume,
+	.name		= "s3c2412-i2s",
+	.id		= 0,
+	.probe		= s3c2412_i2s_probe,
 	.playback = {
 		.channels_min	= 2,
 		.channels_max	= 2,
@@ -727,10 +170,6 @@
 		.formats	= SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE,
 	},
 	.ops = {
-		.trigger	= s3c2412_i2s_trigger,
-		.hw_params	= s3c2412_i2s_hw_params,
-		.set_fmt	= s3c2412_i2s_set_fmt,
-		.set_clkdiv	= s3c2412_i2s_set_clkdiv,
 		.set_sysclk	= s3c2412_i2s_set_sysclk,
 	},
 };
@@ -738,7 +177,7 @@
 
 static int __init s3c2412_i2s_init(void)
 {
-	return snd_soc_register_dai(&s3c2412_i2s_dai);
+	return  s3c_i2sv2_register_dai(&s3c2412_i2s_dai);
 }
 module_init(s3c2412_i2s_init);
 
@@ -748,7 +187,6 @@
 }
 module_exit(s3c2412_i2s_exit);
 
-
 /* Module information */
 MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
 MODULE_DESCRIPTION("S3C2412 I2S SoC Interface");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c2412-i2s.h linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c2412-i2s.h
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c2412-i2s.h	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c2412-i2s.h	2009-05-10 22:28:00.000000000 +0200
@@ -15,9 +15,11 @@
 #ifndef __SND_SOC_S3C24XX_S3C2412_I2S_H
 #define __SND_SOC_S3C24XX_S3C2412_I2S_H __FILE__
 
-#define S3C2412_DIV_BCLK	(1)
-#define S3C2412_DIV_RCLK	(2)
-#define S3C2412_DIV_PRESCALER	(3)
+#include "s3c-i2s-v2.h"
+
+#define S3C2412_DIV_BCLK	S3C_I2SV2_DIV_BCLK
+#define S3C2412_DIV_RCLK	S3C_I2SV2_DIV_RCLK
+#define S3C2412_DIV_PRESCALER	S3C_I2SV2_DIV_PRESCALER
 
 #define S3C2412_CLKSRC_PCLK	(0)
 #define S3C2412_CLKSRC_I2SCLK	(1)
@@ -26,13 +28,4 @@
 
 extern struct snd_soc_dai s3c2412_i2s_dai;
 
-struct s3c2412_rate_calc {
-	unsigned int	clk_div;	/* for prescaler */
-	unsigned int	fs_div;		/* for root frame clock */
-};
-
-extern int s3c2412_iis_calc_rate(struct s3c2412_rate_calc *info,
-				 unsigned int *fstab,
-				 unsigned int rate, struct clk *clk);
-
 #endif /* __SND_SOC_S3C24XX_S3C2412_I2S_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c2443-ac97.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c2443-ac97.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c2443-ac97.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c2443-ac97.c	2009-05-10 22:28:00.000000000 +0200
@@ -31,7 +31,7 @@
 #include <plat/regs-ac97.h>
 #include <mach/regs-gpio.h>
 #include <mach/regs-clock.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 #include <asm/dma.h>
 #include <mach/dma.h>
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c24xx-i2s.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c24xx-i2s.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c24xx-i2s.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c24xx-i2s.c	2009-05-10 22:28:00.000000000 +0200
@@ -4,7 +4,7 @@
  * (c) 2006 Wolfson Microelectronics PLC.
  * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
  *
- * (c) 2004-2005 Simtec Electronics
+ * Copyright 2004-2005 Simtec Electronics
  *	http://armlinux.simtec.co.uk/
  *	Ben Dooks <ben@simtec.co.uk>
  *
@@ -30,11 +30,11 @@
 #include <mach/hardware.h>
 #include <mach/regs-gpio.h>
 #include <mach/regs-clock.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 #include <asm/dma.h>
 #include <mach/dma.h>
 
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
 
 #include "s3c24xx-pcm.h"
 #include "s3c24xx-i2s.h"
@@ -175,7 +175,7 @@
 static int s3c24xx_snd_lrsync(void)
 {
 	u32 iiscon;
-	int timeout = 50; /* 5ms */
+	int timeout = 5; /* 500us, 125 should be enough at 8kHz */
 
 	DBG("Entered %s\n", __func__);
 
@@ -291,11 +291,14 @@
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		if (!s3c24xx_snd_is_clkmaster()) {
-			ret = s3c24xx_snd_lrsync();
-			if (ret)
-				goto exit_err;
-		}
+		if (!s3c24xx_snd_is_clkmaster())
+			/* we ignore the return code, if it sync'd then fine,
+			 * if it didn't sync, which happens after resume the
+			 * first time when there was a live stream at suspend,
+			 * just let it timeout, the stream picks up OK after
+			 * that and LRCK is evidently working again.
+			 */
+			s3c24xx_snd_lrsync();
 
 		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 			s3c24xx_snd_rxctrl(1);
@@ -315,7 +318,6 @@
 		break;
 	}
 
-exit_err:
 	return ret;
 }
 
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c24xx-pcm.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c24xx-pcm.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c24xx-pcm.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c24xx-pcm.c	2009-05-10 22:28:00.000000000 +0200
@@ -4,7 +4,7 @@
  * (c) 2006 Wolfson Microelectronics PLC.
  * Graeme Gregory graeme.gregory@wolfsonmicro.com or linux@wolfsonmicro.com
  *
- * (c) 2004-2005 Simtec Electronics
+ * Copyright 2004-2005 Simtec Electronics
  *	http://armlinux.simtec.co.uk/
  *	Ben Dooks <ben@simtec.co.uk>
  *
@@ -29,7 +29,7 @@
 #include <asm/dma.h>
 #include <mach/hardware.h>
 #include <mach/dma.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 
 #include "s3c24xx-pcm.h"
 
@@ -82,11 +82,19 @@
 {
 	struct s3c24xx_runtime_data *prtd = substream->runtime->private_data;
 	dma_addr_t pos = prtd->dma_pos;
+	unsigned int limit;
 	int ret;
 
 	DBG("Entered %s\n", __func__);
 
-	while (prtd->dma_loaded < prtd->dma_limit) {
+	if (s3c_dma_has_circular()) {
+		limit = (prtd->dma_end - prtd->dma_start) / prtd->dma_period;
+	} else
+		limit = prtd->dma_limit;
+
+	DBG("%s: loaded %d, limit %d\n", __func__, prtd->dma_loaded, limit);
+
+	while (prtd->dma_loaded < limit) {
 		unsigned long len = prtd->dma_period;
 
 		DBG("dma_loaded: %d\n", prtd->dma_loaded);
@@ -130,7 +138,7 @@
 		snd_pcm_period_elapsed(substream);
 
 	spin_lock(&prtd->lock);
-	if (prtd->state & ST_RUNNING) {
+	if (prtd->state & ST_RUNNING && !s3c_dma_has_circular()) {
 		prtd->dma_loaded--;
 		s3c24xx_pcm_enqueue(substream);
 	}
@@ -168,9 +176,14 @@
 					  prtd->params->client, NULL);
 
 		if (ret < 0) {
-			DBG(KERN_ERR "failed to get dma channel\n");
+			DBG(KERN_ERR "failed to get dma channel: %d\n", ret);
 			return ret;
 		}
+
+		/* use the circular buffering if we have it available. */
+		if (s3c_dma_has_circular())
+			s3c2410_dma_setflags(prtd->params->channel,
+					     S3C2410_DMAF_CIRCULAR);
 	}
 
 	s3c2410_dma_set_buffdone_fn(prtd->params->channel,
@@ -225,23 +238,16 @@
 	 * sync to pclk, half-word transfers to the IIS-FIFO. */
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		s3c2410_dma_devconfig(prtd->params->channel,
-				S3C2410_DMASRC_MEM, S3C2410_DISRCC_INC |
-				S3C2410_DISRCC_APB, prtd->params->dma_addr);
-
-		s3c2410_dma_config(prtd->params->channel,
-				prtd->params->dma_size,
-				S3C2410_DCON_SYNC_PCLK |
-				S3C2410_DCON_HANDSHAKE);
+				      S3C2410_DMASRC_MEM,
+				      prtd->params->dma_addr);
 	} else {
-		s3c2410_dma_config(prtd->params->channel,
-				prtd->params->dma_size,
-				S3C2410_DCON_HANDSHAKE |
-				S3C2410_DCON_SYNC_PCLK);
-
 		s3c2410_dma_devconfig(prtd->params->channel,
-					S3C2410_DMASRC_HW, 0x3,
-					prtd->params->dma_addr);
+				      S3C2410_DMASRC_HW, 
+				      prtd->params->dma_addr);
 	}
+	
+	s3c2410_dma_config(prtd->params->channel,
+			   prtd->params->dma_size);
 
 	/* flush the DMA channel */
 	s3c2410_dma_ctrl(prtd->params->channel, S3C2410_DMAOP_FLUSH);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c24xx_uda134x.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c24xx_uda134x.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c24xx_uda134x.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c24xx_uda134x.c	2009-05-10 22:28:00.000000000 +0200
@@ -22,7 +22,7 @@
 #include <sound/s3c24xx_uda134x.h>
 #include <sound/uda134x.h>
 
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
 
 #include "s3c24xx-pcm.h"
 #include "s3c24xx-i2s.h"
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c64xx-i2s.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c64xx-i2s.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c64xx-i2s.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c64xx-i2s.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,219 @@
+/* sound/soc/s3c24xx/s3c64xx-i2s.c
+ *
+ * ALSA SoC Audio Layer - S3C64XX I2S driver
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <plat/regs-s3c2412-iis.h>
+#include <plat/gpio-bank-d.h>
+#include <plat/gpio-bank-e.h>
+#include <plat/gpio-cfg.h>
+#include <plat/audio.h>
+
+#include <mach/map.h>
+#include <mach/dma.h>
+
+#include "s3c24xx-pcm.h"
+#include "s3c64xx-i2s.h"
+
+static struct s3c2410_dma_client s3c64xx_dma_client_out = {
+	.name		= "I2S PCM Stereo out"
+};
+
+static struct s3c2410_dma_client s3c64xx_dma_client_in = {
+	.name		= "I2S PCM Stereo in"
+};
+
+static struct s3c24xx_pcm_dma_params s3c64xx_i2s_pcm_stereo_out[2] = {
+	[0] = {
+		.channel	= DMACH_I2S0_OUT,
+		.client		= &s3c64xx_dma_client_out,
+		.dma_addr	= S3C64XX_PA_IIS0 + S3C2412_IISTXD,
+		.dma_size	= 4,
+	},
+	[1] = {
+		.channel	= DMACH_I2S1_OUT,
+		.client		= &s3c64xx_dma_client_out,
+		.dma_addr	= S3C64XX_PA_IIS1 + S3C2412_IISTXD,
+		.dma_size	= 4,
+	},
+};
+
+static struct s3c24xx_pcm_dma_params s3c64xx_i2s_pcm_stereo_in[2] = {
+	[0] = {
+		.channel	= DMACH_I2S0_IN,
+		.client		= &s3c64xx_dma_client_in,
+		.dma_addr	= S3C64XX_PA_IIS0 + S3C2412_IISRXD,
+		.dma_size	= 4,
+	}, 
+	[1] = {
+		.channel	= DMACH_I2S1_IN,
+		.client		= &s3c64xx_dma_client_in,
+		.dma_addr	= S3C64XX_PA_IIS1 + S3C2412_IISRXD,
+		.dma_size	= 4,
+	},
+};
+
+static struct s3c_i2sv2_info s3c64xx_i2s[2];
+
+static inline struct s3c_i2sv2_info *to_info(struct snd_soc_dai *cpu_dai)
+{
+	return cpu_dai->private_data;
+}
+
+static int s3c64xx_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct s3c_i2sv2_info *i2s = to_info(cpu_dai);
+	u32 iismod = readl(i2s->regs + S3C2412_IISMOD);
+
+	switch (clk_id) {
+	case S3C64XX_CLKSRC_PCLK:
+		iismod &= ~S3C64XX_IISMOD_IMS_SYSMUX;
+		break;
+
+	case S3C64XX_CLKSRC_MUX:
+		iismod |= S3C64XX_IISMOD_IMS_SYSMUX;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	writel(iismod, i2s->regs + S3C2412_IISMOD);
+
+	return 0;
+}
+
+unsigned long s3c64xx_i2s_get_clockrate(struct snd_soc_dai *dai)
+{
+	struct s3c_i2sv2_info *i2s = to_info(dai);
+
+	return clk_get_rate(i2s->iis_cclk);
+}
+EXPORT_SYMBOL_GPL(s3c64xx_i2s_get_clockrate);
+
+static int s3c64xx_i2s_probe(struct platform_device *pdev,
+			     struct snd_soc_dai *dai)
+{
+	struct device *dev = &pdev->dev;
+	struct s3c_i2sv2_info *i2s;
+	int ret;
+
+	dev_dbg(dev, "%s: probing dai %d\n", __func__, pdev->id);
+
+	if (pdev->id < 0 || pdev->id > ARRAY_SIZE(s3c64xx_i2s)) {
+		dev_err(dev, "id %d out of range\n", pdev->id);
+		return -EINVAL;
+	}
+
+	i2s = &s3c64xx_i2s[pdev->id];
+
+	ret = s3c_i2sv2_probe(pdev, dai, i2s,
+			      pdev->id ? S3C64XX_PA_IIS1 : S3C64XX_PA_IIS0);
+	if (ret)
+		return ret;
+
+	i2s->dma_capture = &s3c64xx_i2s_pcm_stereo_in[pdev->id];
+	i2s->dma_playback = &s3c64xx_i2s_pcm_stereo_out[pdev->id];
+
+	i2s->iis_cclk = clk_get(dev, "audio-bus");
+	if (IS_ERR(i2s->iis_cclk)) {
+		dev_err(dev, "failed to get audio-bus");
+		iounmap(i2s->regs);
+		return -ENODEV;
+	}
+
+	/* configure GPIO for i2s port */
+	switch (pdev->id) {
+	case 0:
+		s3c_gpio_cfgpin(S3C64XX_GPD(0), S3C64XX_GPD0_I2S0_CLK);
+		s3c_gpio_cfgpin(S3C64XX_GPD(1), S3C64XX_GPD1_I2S0_CDCLK);
+		s3c_gpio_cfgpin(S3C64XX_GPD(2), S3C64XX_GPD2_I2S0_LRCLK);
+		s3c_gpio_cfgpin(S3C64XX_GPD(3), S3C64XX_GPD3_I2S0_DI);
+		s3c_gpio_cfgpin(S3C64XX_GPD(4), S3C64XX_GPD4_I2S0_D0);
+		break;
+	case 1:
+		s3c_gpio_cfgpin(S3C64XX_GPE(0), S3C64XX_GPE0_I2S1_CLK);
+		s3c_gpio_cfgpin(S3C64XX_GPE(1), S3C64XX_GPE1_I2S1_CDCLK);
+		s3c_gpio_cfgpin(S3C64XX_GPE(2), S3C64XX_GPE2_I2S1_LRCLK);
+		s3c_gpio_cfgpin(S3C64XX_GPE(3), S3C64XX_GPE3_I2S1_DI);
+		s3c_gpio_cfgpin(S3C64XX_GPE(4), S3C64XX_GPE4_I2S1_D0);
+	}
+
+	return 0;
+}
+
+
+#define S3C64XX_I2S_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+	SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000)
+
+#define S3C64XX_I2S_FMTS \
+	(SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_LE)
+
+struct snd_soc_dai s3c64xx_i2s_dai = {
+	.name		= "s3c64xx-i2s",
+	.id		= 0,
+	.probe		= s3c64xx_i2s_probe,
+	.playback = {
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= S3C64XX_I2S_RATES,
+		.formats	= S3C64XX_I2S_FMTS,
+	},
+	.capture = {
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= S3C64XX_I2S_RATES,
+		.formats	= S3C64XX_I2S_FMTS,
+	},
+	.ops = {
+		.set_sysclk	= s3c64xx_i2s_set_sysclk,
+	},
+};
+EXPORT_SYMBOL_GPL(s3c64xx_i2s_dai);
+
+static int __init s3c64xx_i2s_init(void)
+{
+	return  s3c_i2sv2_register_dai(&s3c64xx_i2s_dai);
+}
+module_init(s3c64xx_i2s_init);
+
+static void __exit s3c64xx_i2s_exit(void)
+{
+	snd_soc_unregister_dai(&s3c64xx_i2s_dai);
+}
+module_exit(s3c64xx_i2s_exit);
+
+/* Module information */
+MODULE_AUTHOR("Ben Dooks, <ben@simtec.co.uk>");
+MODULE_DESCRIPTION("S3C64XX I2S SoC Interface");
+MODULE_LICENSE("GPL");
+
+
+
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c64xx-i2s.h linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c64xx-i2s.h
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c64xx-i2s.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c64xx-i2s.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,31 @@
+/* sound/soc/s3c24xx/s3c64xx-i2s.h
+ *
+ * ALSA SoC Audio Layer - S3C64XX I2S driver
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __SND_SOC_S3C24XX_S3C64XX_I2S_H
+#define __SND_SOC_S3C24XX_S3C64XX_I2S_H __FILE__
+
+#include "s3c-i2s-v2.h"
+
+#define S3C64XX_DIV_BCLK	S3C_I2SV2_DIV_BCLK
+#define S3C64XX_DIV_RCLK	S3C_I2SV2_DIV_RCLK
+#define S3C64XX_DIV_PRESCALER	S3C_I2SV2_DIV_PRESCALER
+
+#define S3C64XX_CLKSRC_PCLK	(0)
+#define S3C64XX_CLKSRC_MUX	(1)
+
+extern struct snd_soc_dai s3c64xx_i2s_dai;
+
+extern unsigned long s3c64xx_i2s_get_clockrate(struct snd_soc_dai *cpu_dai);
+
+#endif /* __SND_SOC_S3C24XX_S3C64XX_I2S_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c-i2s-v2.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c-i2s-v2.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c-i2s-v2.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c-i2s-v2.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,645 @@
+/* sound/soc/s3c24xx/s3c-i2c-v2.c
+ *
+ * ALSA Soc Audio Layer - I2S core for newer Samsung SoCs.
+ *
+ * Copyright (c) 2006 Wolfson Microelectronics PLC.
+ *	Graeme Gregory graeme.gregory@wolfsonmicro.com
+ *	linux@wolfsonmicro.com
+ *
+ * Copyright (c) 2008, 2007, 2004-2005 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <plat/regs-s3c2412-iis.h>
+
+#include <plat/audio.h>
+#include <mach/dma.h>
+
+#include "s3c-i2s-v2.h"
+
+#define S3C2412_I2S_DEBUG_CON 0
+#define S3C2412_I2S_DEBUG 0
+
+#if S3C2412_I2S_DEBUG
+#define DBG(x...) printk(KERN_INFO x)
+#else
+#define DBG(x...) do { } while (0)
+#endif
+
+static inline struct s3c_i2sv2_info *to_info(struct snd_soc_dai *cpu_dai)
+{
+	return cpu_dai->private_data;
+}
+
+#define bit_set(v, b) (((v) & (b)) ? 1 : 0)
+
+#if S3C2412_I2S_DEBUG_CON
+static void dbg_showcon(const char *fn, u32 con)
+{
+	printk(KERN_DEBUG "%s: LRI=%d, TXFEMPT=%d, RXFEMPT=%d, TXFFULL=%d, RXFFULL=%d\n", fn,
+	       bit_set(con, S3C2412_IISCON_LRINDEX),
+	       bit_set(con, S3C2412_IISCON_TXFIFO_EMPTY),
+	       bit_set(con, S3C2412_IISCON_RXFIFO_EMPTY),
+	       bit_set(con, S3C2412_IISCON_TXFIFO_FULL),
+	       bit_set(con, S3C2412_IISCON_RXFIFO_FULL));
+
+	printk(KERN_DEBUG "%s: PAUSE: TXDMA=%d, RXDMA=%d, TXCH=%d, RXCH=%d\n",
+	       fn,
+	       bit_set(con, S3C2412_IISCON_TXDMA_PAUSE),
+	       bit_set(con, S3C2412_IISCON_RXDMA_PAUSE),
+	       bit_set(con, S3C2412_IISCON_TXCH_PAUSE),
+	       bit_set(con, S3C2412_IISCON_RXCH_PAUSE));
+	printk(KERN_DEBUG "%s: ACTIVE: TXDMA=%d, RXDMA=%d, IIS=%d\n", fn,
+	       bit_set(con, S3C2412_IISCON_TXDMA_ACTIVE),
+	       bit_set(con, S3C2412_IISCON_RXDMA_ACTIVE),
+	       bit_set(con, S3C2412_IISCON_IIS_ACTIVE));
+}
+#else
+static inline void dbg_showcon(const char *fn, u32 con)
+{
+}
+#endif
+
+
+/* Turn on or off the transmission path. */
+void s3c2412_snd_txctrl(struct s3c_i2sv2_info *i2s, int on)
+{
+	void __iomem *regs = i2s->regs;
+	u32 fic, con, mod;
+
+	DBG("%s(%d)\n", __func__, on);
+
+	fic = readl(regs + S3C2412_IISFIC);
+	con = readl(regs + S3C2412_IISCON);
+	mod = readl(regs + S3C2412_IISMOD);
+
+	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
+
+	if (on) {
+		con |= S3C2412_IISCON_TXDMA_ACTIVE | S3C2412_IISCON_IIS_ACTIVE;
+		con &= ~S3C2412_IISCON_TXDMA_PAUSE;
+		con &= ~S3C2412_IISCON_TXCH_PAUSE;
+
+		switch (mod & S3C2412_IISMOD_MODE_MASK) {
+		case S3C2412_IISMOD_MODE_TXONLY:
+		case S3C2412_IISMOD_MODE_TXRX:
+			/* do nothing, we are in the right mode */
+			break;
+
+		case S3C2412_IISMOD_MODE_RXONLY:
+			mod &= ~S3C2412_IISMOD_MODE_MASK;
+			mod |= S3C2412_IISMOD_MODE_TXRX;
+			break;
+
+		default:
+			dev_err(i2s->dev, "TXEN: Invalid MODE in IISMOD\n");
+		}
+
+		writel(con, regs + S3C2412_IISCON);
+		writel(mod, regs + S3C2412_IISMOD);
+	} else {
+		/* Note, we do not have any indication that the FIFO problems
+		 * tha the S3C2410/2440 had apply here, so we should be able
+		 * to disable the DMA and TX without resetting the FIFOS.
+		 */
+
+		con |=  S3C2412_IISCON_TXDMA_PAUSE;
+		con |=  S3C2412_IISCON_TXCH_PAUSE;
+		con &= ~S3C2412_IISCON_TXDMA_ACTIVE;
+
+		switch (mod & S3C2412_IISMOD_MODE_MASK) {
+		case S3C2412_IISMOD_MODE_TXRX:
+			mod &= ~S3C2412_IISMOD_MODE_MASK;
+			mod |= S3C2412_IISMOD_MODE_RXONLY;
+			break;
+
+		case S3C2412_IISMOD_MODE_TXONLY:
+			mod &= ~S3C2412_IISMOD_MODE_MASK;
+			con &= ~S3C2412_IISCON_IIS_ACTIVE;
+			break;
+
+		default:
+			dev_err(i2s->dev, "TXDIS: Invalid MODE in IISMOD\n");
+		}
+
+		writel(mod, regs + S3C2412_IISMOD);
+		writel(con, regs + S3C2412_IISCON);
+	}
+
+	fic = readl(regs + S3C2412_IISFIC);
+	dbg_showcon(__func__, con);
+	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
+}
+EXPORT_SYMBOL_GPL(s3c2412_snd_txctrl);
+
+void s3c2412_snd_rxctrl(struct s3c_i2sv2_info *i2s, int on)
+{
+	void __iomem *regs = i2s->regs;
+	u32 fic, con, mod;
+
+	DBG("%s(%d)\n", __func__, on);
+
+	fic = readl(regs + S3C2412_IISFIC);
+	con = readl(regs + S3C2412_IISCON);
+	mod = readl(regs + S3C2412_IISMOD);
+
+	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
+
+	if (on) {
+		con |= S3C2412_IISCON_RXDMA_ACTIVE | S3C2412_IISCON_IIS_ACTIVE;
+		con &= ~S3C2412_IISCON_RXDMA_PAUSE;
+		con &= ~S3C2412_IISCON_RXCH_PAUSE;
+
+		switch (mod & S3C2412_IISMOD_MODE_MASK) {
+		case S3C2412_IISMOD_MODE_TXRX:
+		case S3C2412_IISMOD_MODE_RXONLY:
+			/* do nothing, we are in the right mode */
+			break;
+
+		case S3C2412_IISMOD_MODE_TXONLY:
+			mod &= ~S3C2412_IISMOD_MODE_MASK;
+			mod |= S3C2412_IISMOD_MODE_TXRX;
+			break;
+
+		default:
+			dev_err(i2s->dev, "RXEN: Invalid MODE in IISMOD\n");
+		}
+
+		writel(mod, regs + S3C2412_IISMOD);
+		writel(con, regs + S3C2412_IISCON);
+	} else {
+		/* See txctrl notes on FIFOs. */
+
+		con &= ~S3C2412_IISCON_RXDMA_ACTIVE;
+		con |=  S3C2412_IISCON_RXDMA_PAUSE;
+		con |=  S3C2412_IISCON_RXCH_PAUSE;
+
+		switch (mod & S3C2412_IISMOD_MODE_MASK) {
+		case S3C2412_IISMOD_MODE_RXONLY:
+			con &= ~S3C2412_IISCON_IIS_ACTIVE;
+			mod &= ~S3C2412_IISMOD_MODE_MASK;
+			break;
+
+		case S3C2412_IISMOD_MODE_TXRX:
+			mod &= ~S3C2412_IISMOD_MODE_MASK;
+			mod |= S3C2412_IISMOD_MODE_TXONLY;
+			break;
+
+		default:
+			dev_err(i2s->dev, "RXEN: Invalid MODE in IISMOD\n");
+		}
+
+		writel(con, regs + S3C2412_IISCON);
+		writel(mod, regs + S3C2412_IISMOD);
+	}
+
+	fic = readl(regs + S3C2412_IISFIC);
+	DBG("%s: IIS: CON=%x MOD=%x FIC=%x\n", __func__, con, mod, fic);
+}
+EXPORT_SYMBOL_GPL(s3c2412_snd_rxctrl);
+
+/*
+ * Wait for the LR signal to allow synchronisation to the L/R clock
+ * from the codec. May only be needed for slave mode.
+ */
+static int s3c2412_snd_lrsync(struct s3c_i2sv2_info *i2s)
+{
+	u32 iiscon;
+	unsigned long timeout = jiffies + msecs_to_jiffies(5);
+
+	DBG("Entered %s\n", __func__);
+
+	while (1) {
+		iiscon = readl(i2s->regs + S3C2412_IISCON);
+		if (iiscon & S3C2412_IISCON_LRINDEX)
+			break;
+
+		if (timeout < jiffies) {
+			printk(KERN_ERR "%s: timeout\n", __func__);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Set S3C2412 I2S DAI format
+ */
+static int s3c2412_i2s_set_fmt(struct snd_soc_dai *cpu_dai,
+			       unsigned int fmt)
+{
+	struct s3c_i2sv2_info *i2s = to_info(cpu_dai);
+	u32 iismod;
+
+	DBG("Entered %s\n", __func__);
+
+	iismod = readl(i2s->regs + S3C2412_IISMOD);
+	DBG("hw_params r: IISMOD: %x \n", iismod);
+
+#if defined(CONFIG_CPU_S3C2412) || defined(CONFIG_CPU_S3C2413)
+#define IISMOD_MASTER_MASK S3C2412_IISMOD_MASTER_MASK
+#define IISMOD_SLAVE S3C2412_IISMOD_SLAVE
+#define IISMOD_MASTER S3C2412_IISMOD_MASTER_INTERNAL
+#endif
+
+#if defined(CONFIG_PLAT_S3C64XX)
+/* From Rev1.1 datasheet, we have two master and two slave modes:
+ * IMS[11:10]:
+ *	00 = master mode, fed from PCLK
+ *	01 = master mode, fed from CLKAUDIO
+ *	10 = slave mode, using PCLK
+ *	11 = slave mode, using I2SCLK
+ */
+#define IISMOD_MASTER_MASK (1 << 11)
+#define IISMOD_SLAVE (1 << 11)
+#define IISMOD_MASTER (0x0)
+#endif
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2s->master = 0;
+		iismod &= ~IISMOD_MASTER_MASK;
+		iismod |= IISMOD_SLAVE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		i2s->master = 1;
+		iismod &= ~IISMOD_MASTER_MASK;
+		iismod |= IISMOD_MASTER;
+		break;
+	default:
+		DBG("unknwon master/slave format\n");
+		return -EINVAL;
+	}
+
+	iismod &= ~S3C2412_IISMOD_SDF_MASK;
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_RIGHT_J:
+		iismod |= S3C2412_IISMOD_SDF_MSB;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iismod |= S3C2412_IISMOD_SDF_LSB;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		iismod |= S3C2412_IISMOD_SDF_IIS;
+		break;
+	default:
+		DBG("Unknown data format\n");
+		return -EINVAL;
+	}
+
+	writel(iismod, i2s->regs + S3C2412_IISMOD);
+	DBG("hw_params w: IISMOD: %x \n", iismod);
+	return 0;
+}
+
+static int s3c2412_i2s_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *socdai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai = rtd->dai;
+	struct s3c_i2sv2_info *i2s = to_info(dai->cpu_dai);
+	u32 iismod;
+
+	DBG("Entered %s\n", __func__);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dai->cpu_dai->dma_data = i2s->dma_playback;
+	else
+		dai->cpu_dai->dma_data = i2s->dma_capture;
+
+	/* Working copies of register */
+	iismod = readl(i2s->regs + S3C2412_IISMOD);
+	DBG("%s: r: IISMOD: %x\n", __func__, iismod);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		iismod |= S3C2412_IISMOD_8BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		iismod &= ~S3C2412_IISMOD_8BIT;
+		break;
+	}
+
+	writel(iismod, i2s->regs + S3C2412_IISMOD);
+	DBG("%s: w: IISMOD: %x\n", __func__, iismod);
+	return 0;
+}
+
+static int s3c2412_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+			       struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct s3c_i2sv2_info *i2s = to_info(rtd->dai->cpu_dai);
+	int capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);
+	unsigned long irqs;
+	int ret = 0;
+
+	DBG("Entered %s\n", __func__);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		/* On start, ensure that the FIFOs are cleared and reset. */
+
+		writel(capture ? S3C2412_IISFIC_RXFLUSH : S3C2412_IISFIC_TXFLUSH,
+		       i2s->regs + S3C2412_IISFIC);
+
+		/* clear again, just in case */
+		writel(0x0, i2s->regs + S3C2412_IISFIC);
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!i2s->master) {
+			ret = s3c2412_snd_lrsync(i2s);
+			if (ret)
+				goto exit_err;
+		}
+
+		local_irq_save(irqs);
+
+		if (capture)
+			s3c2412_snd_rxctrl(i2s, 1);
+		else
+			s3c2412_snd_txctrl(i2s, 1);
+
+		local_irq_restore(irqs);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		local_irq_save(irqs);
+
+		if (capture)
+			s3c2412_snd_rxctrl(i2s, 0);
+		else
+			s3c2412_snd_txctrl(i2s, 0);
+
+		local_irq_restore(irqs);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+exit_err:
+	return ret;
+}
+
+/*
+ * Set S3C2412 Clock dividers
+ */
+static int s3c2412_i2s_set_clkdiv(struct snd_soc_dai *cpu_dai,
+				  int div_id, int div)
+{
+	struct s3c_i2sv2_info *i2s = to_info(cpu_dai);
+	u32 reg;
+
+	DBG("%s(%p, %d, %d)\n", __func__, cpu_dai, div_id, div);
+
+	switch (div_id) {
+	case S3C_I2SV2_DIV_BCLK:
+		reg = readl(i2s->regs + S3C2412_IISMOD);
+		reg &= ~S3C2412_IISMOD_BCLK_MASK;
+		writel(reg | div, i2s->regs + S3C2412_IISMOD);
+
+		DBG("%s: MOD=%08x\n", __func__, readl(i2s->regs + S3C2412_IISMOD));
+		break;
+
+	case S3C_I2SV2_DIV_RCLK:
+		if (div > 3) {
+			/* convert value to bit field */
+
+			switch (div) {
+			case 256:
+				div = S3C2412_IISMOD_RCLK_256FS;
+				break;
+
+			case 384:
+				div = S3C2412_IISMOD_RCLK_384FS;
+				break;
+
+			case 512:
+				div = S3C2412_IISMOD_RCLK_512FS;
+				break;
+
+			case 768:
+				div = S3C2412_IISMOD_RCLK_768FS;
+				break;
+
+			default:
+				return -EINVAL;
+			}
+		}
+
+		reg = readl(i2s->regs + S3C2412_IISMOD);
+		reg &= ~S3C2412_IISMOD_RCLK_MASK;
+		writel(reg | div, i2s->regs + S3C2412_IISMOD);
+		DBG("%s: MOD=%08x\n", __func__, readl(i2s->regs + S3C2412_IISMOD));
+		break;
+
+	case S3C_I2SV2_DIV_PRESCALER:
+		if (div >= 0) {
+			writel((div << 8) | S3C2412_IISPSR_PSREN,
+			       i2s->regs + S3C2412_IISPSR);
+		} else {
+			writel(0x0, i2s->regs + S3C2412_IISPSR);
+		}
+		DBG("%s: PSR=%08x\n", __func__, readl(i2s->regs + S3C2412_IISPSR));
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/* default table of all avaialable root fs divisors */
+static unsigned int iis_fs_tab[] = { 256, 512, 384, 768 };
+
+int s3c2412_iis_calc_rate(struct s3c_i2sv2_rate_calc *info,
+			  unsigned int *fstab,
+			  unsigned int rate, struct clk *clk)
+{
+	unsigned long clkrate = clk_get_rate(clk);
+	unsigned int div;
+	unsigned int fsclk;
+	unsigned int actual;
+	unsigned int fs;
+	unsigned int fsdiv;
+	signed int deviation = 0;
+	unsigned int best_fs = 0;
+	unsigned int best_div = 0;
+	unsigned int best_rate = 0;
+	unsigned int best_deviation = INT_MAX;
+
+	if (fstab == NULL)
+		fstab = iis_fs_tab;
+
+	for (fs = 0; fs < ARRAY_SIZE(iis_fs_tab); fs++) {
+		fsdiv = iis_fs_tab[fs];
+
+		fsclk = clkrate / fsdiv;
+		div = fsclk / rate;
+
+		if ((fsclk % rate) > (rate / 2))
+			div++;
+
+		if (div <= 1)
+			continue;
+
+		actual = clkrate / (fsdiv * div);
+		deviation = actual - rate;
+
+		printk(KERN_DEBUG "%dfs: div %d => result %d, deviation %d\n",
+		       fsdiv, div, actual, deviation);
+
+		deviation = abs(deviation);
+
+		if (deviation < best_deviation) {
+			best_fs = fsdiv;
+			best_div = div;
+			best_rate = actual;
+			best_deviation = deviation;
+		}
+
+		if (deviation == 0)
+			break;
+	}
+
+	printk(KERN_DEBUG "best: fs=%d, div=%d, rate=%d\n",
+	       best_fs, best_div, best_rate);
+
+	info->fs_div = best_fs;
+	info->clk_div = best_div;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s3c2412_iis_calc_rate);
+
+int s3c_i2sv2_probe(struct platform_device *pdev,
+		    struct snd_soc_dai *dai,
+		    struct s3c_i2sv2_info *i2s,
+		    unsigned long base)
+{
+	struct device *dev = &pdev->dev;
+
+	i2s->dev = dev;
+
+	/* record our i2s structure for later use in the callbacks */
+	dai->private_data = i2s;
+
+	i2s->regs = ioremap(base, 0x100);
+	if (i2s->regs == NULL) {
+		dev_err(dev, "cannot ioremap registers\n");
+		return -ENXIO;
+	}
+
+	i2s->iis_pclk = clk_get(dev, "iis");
+	if (i2s->iis_pclk == NULL) {
+		DBG("failed to get iis_clock\n");
+		iounmap(i2s->regs);
+		return -ENOENT;
+	}
+
+	clk_enable(i2s->iis_pclk);
+
+	s3c2412_snd_txctrl(i2s, 0);
+	s3c2412_snd_rxctrl(i2s, 0);
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(s3c_i2sv2_probe);
+
+#ifdef CONFIG_PM
+static int s3c2412_i2s_suspend(struct snd_soc_dai *dai)
+{
+	struct s3c_i2sv2_info *i2s = to_info(dai);
+	u32 iismod;
+
+	if (dai->active) {
+		i2s->suspend_iismod = readl(i2s->regs + S3C2412_IISMOD);
+		i2s->suspend_iiscon = readl(i2s->regs + S3C2412_IISCON);
+		i2s->suspend_iispsr = readl(i2s->regs + S3C2412_IISPSR);
+
+		/* some basic suspend checks */
+
+		iismod = readl(i2s->regs + S3C2412_IISMOD);
+
+		if (iismod & S3C2412_IISCON_RXDMA_ACTIVE)
+			pr_warning("%s: RXDMA active?\n", __func__);
+
+		if (iismod & S3C2412_IISCON_TXDMA_ACTIVE)
+			pr_warning("%s: TXDMA active?\n", __func__);
+
+		if (iismod & S3C2412_IISCON_IIS_ACTIVE)
+			pr_warning("%s: IIS active\n", __func__);
+	}
+
+	return 0;
+}
+
+static int s3c2412_i2s_resume(struct snd_soc_dai *dai)
+{
+	struct s3c_i2sv2_info *i2s = to_info(dai);
+
+	pr_info("dai_active %d, IISMOD %08x, IISCON %08x\n",
+		dai->active, i2s->suspend_iismod, i2s->suspend_iiscon);
+
+	if (dai->active) {
+		writel(i2s->suspend_iiscon, i2s->regs + S3C2412_IISCON);
+		writel(i2s->suspend_iismod, i2s->regs + S3C2412_IISMOD);
+		writel(i2s->suspend_iispsr, i2s->regs + S3C2412_IISPSR);
+
+		writel(S3C2412_IISFIC_RXFLUSH | S3C2412_IISFIC_TXFLUSH,
+		       i2s->regs + S3C2412_IISFIC);
+
+		ndelay(250);
+		writel(0x0, i2s->regs + S3C2412_IISFIC);
+	}
+
+	return 0;
+}
+#else
+#define s3c2412_i2s_suspend NULL
+#define s3c2412_i2s_resume  NULL
+#endif
+
+int s3c_i2sv2_register_dai(struct snd_soc_dai *dai)
+{
+	dai->ops.trigger = s3c2412_i2s_trigger;
+	dai->ops.hw_params = s3c2412_i2s_hw_params;
+	dai->ops.set_fmt = s3c2412_i2s_set_fmt;
+	dai->ops.set_clkdiv = s3c2412_i2s_set_clkdiv;
+
+	dai->suspend = s3c2412_i2s_suspend;
+	dai->resume = s3c2412_i2s_resume;
+
+	return snd_soc_register_dai(dai);
+}
+
+EXPORT_SYMBOL_GPL(s3c_i2sv2_register_dai);
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c-i2s-v2.h linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c-i2s-v2.h
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/s3c-i2s-v2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/s3c-i2s-v2.h	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,90 @@
+/* sound/soc/s3c24xx/s3c-i2s-v2.h
+ *
+ * ALSA Soc Audio Layer - S3C_I2SV2 I2S driver
+ *
+ * Copyright (c) 2007 Simtec Electronics
+ *	http://armlinux.simtec.co.uk/
+ *	Ben Dooks <ben@simtec.co.uk>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+*/
+
+/* This code is the core support for the I2S block found in a number of
+ * Samsung SoC devices which is unofficially named I2S-V2. Currently the
+ * S3C2412 and the S3C64XX series use this block to provide 1 or 2 I2S
+ * channels via configurable GPIO.
+ */
+
+#ifndef __SND_SOC_S3C24XX_S3C_I2SV2_I2S_H
+#define __SND_SOC_S3C24XX_S3C_I2SV2_I2S_H __FILE__
+
+#define S3C_I2SV2_DIV_BCLK	(1)
+#define S3C_I2SV2_DIV_RCLK	(2)
+#define S3C_I2SV2_DIV_PRESCALER	(3)
+
+/**
+ * struct s3c_i2sv2_info - S3C I2S-V2 information
+ * @dev: The parent device passed to use from the probe.
+ * @regs: The pointer to the device registe block.
+ * @master: True if the I2S core is the I2S bit clock master.
+ * @dma_playback: DMA information for playback channel.
+ * @dma_capture: DMA information for capture channel.
+ * @suspend_iismod: PM save for the IISMOD register.
+ * @suspend_iiscon: PM save for the IISCON register.
+ * @suspend_iispsr: PM save for the IISPSR register.
+ *
+ * This is the private codec state for the hardware associated with an
+ * I2S channel such as the register mappings and clock sources.
+ */
+struct s3c_i2sv2_info {
+	struct device	*dev;
+	void __iomem	*regs;
+
+	struct clk	*iis_pclk;
+	struct clk	*iis_cclk;
+	struct clk	*iis_clk;
+
+	unsigned char	 master;
+
+	struct s3c24xx_pcm_dma_params	*dma_playback;
+	struct s3c24xx_pcm_dma_params	*dma_capture;
+
+	u32		 suspend_iismod;
+	u32		 suspend_iiscon;
+	u32		 suspend_iispsr;
+};
+
+struct s3c_i2sv2_rate_calc {
+	unsigned int	clk_div;	/* for prescaler */
+	unsigned int	fs_div;		/* for root frame clock */
+};
+
+extern int s3c_i2sv2_iis_calc_rate(struct s3c_i2sv2_rate_calc *info,
+				   unsigned int *fstab,
+				   unsigned int rate, struct clk *clk);
+
+/**
+ * s3c_i2sv2_probe - probe for i2s device helper
+ * @pdev: The platform device supplied to the original probe.
+ * @dai: The ASoC DAI structure supplied to the original probe.
+ * @i2s: Our local i2s structure to fill in.
+ * @base: The base address for the registers.
+ */
+extern int s3c_i2sv2_probe(struct platform_device *pdev,
+			   struct snd_soc_dai *dai,
+			   struct s3c_i2sv2_info *i2s,
+			   unsigned long base);
+
+/**
+ * s3c_i2sv2_register_dai - register dai with soc core
+ * @dai: The snd_soc_dai structure to register
+ *
+ * Fill in any missing fields and then register the given dai with the
+ * soc core.
+ */
+extern int s3c_i2sv2_register_dai(struct snd_soc_dai *dai);
+
+#endif /* __SND_SOC_S3C24XX_S3C_I2SV2_I2S_H */
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/smdk6410-wm8731.c linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/smdk6410-wm8731.c
--- linux-2.6.29-rc3.owrt/sound/soc/s3c24xx/smdk6410-wm8731.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.29-rc3.owrt.om/sound/soc/s3c24xx/smdk6410-wm8731.c	2009-05-10 22:28:00.000000000 +0200
@@ -0,0 +1,227 @@
+
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+
+#include "../codecs/wm8731.h"
+#include "s3c64xx-i2s.h"
+
+static struct platform_device *socdev;
+
+
+
+static void wm_shutdown(struct snd_pcm_substream *substream)
+{
+	printk(KERN_INFO "%s: substream %p\n", __func__, substream);
+}
+
+static int wm_hw_params(struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	unsigned int fmt;
+	int ret;
+
+	printk(KERN_INFO "%s: (%p,%p)\n", __func__, substream, params);
+	printk(KERN_INFO "%s: dai: cpu %p, codec %p\n", __func__, cpu_dai, codec_dai);
+
+	//fmt = SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS;
+	fmt = SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM;
+	fmt |= SND_SOC_DAIFMT_I2S;
+
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0)
+		return ret;
+
+	if (fmt == (SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM)) {
+		unsigned long iis_clkrate;
+
+		ret = snd_soc_dai_set_sysclk(cpu_dai, S3C64XX_CLKSRC_MUX, 0,
+					     SND_SOC_CLOCK_OUT);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: cpu set_sysclk err\n", __func__);
+			return ret;
+		}
+
+		/* set prescaler division for sample rate */
+		ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C64XX_DIV_PRESCALER, 1);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: codec clkdiv err\n", __func__);
+			return ret;
+		}
+
+		iis_clkrate = s3c64xx_i2s_get_clockrate(cpu_dai) / 2;
+		printk(KERN_INFO "%s: clockrate %ld\n", __func__, iis_clkrate);
+
+		iis_clkrate = 12000000; //tmphack//
+
+		/* set the codec system clock for DAC and ADC */
+		ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK,
+					     iis_clkrate,
+					     SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			printk(KERN_ERR "%s: codec sysclk err\n", __func__);
+			return ret;
+		}
+
+	} else {
+		/* TODO */
+		BUG();
+	}
+
+	return 0;
+}
+
+static int wm_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = snd_pcm_substream_chip(substream);
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	ret = snd_soc_dai_set_sysclk(cpu_dai, S3C64XX_CLKSRC_MUX, 0,
+				     SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: cpu set_sysclk err\n", __func__);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_clkdiv(cpu_dai, S3C64XX_DIV_PRESCALER, 1);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: cpu set_clkdiv err\n", __func__);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK,
+				     12000000, SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: codec sysclk err\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops wm_ops = {
+	.startup	= wm_startup,
+	.hw_params	= wm_hw_params,
+	.shutdown	= wm_shutdown,
+};
+
+static const struct snd_soc_dapm_widget widgets[] = {
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_INPUT("Line In"),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+
+	{"Line Out", NULL, "LOUT" },
+	{"Line Out", NULL, "ROUT" },
+
+	{"LLINEIN", NULL, "Line In" },
+	{"RLINEIN", NULL, "Line In" },
+};
+
+static int wm_init(struct snd_soc_codec *codec)
+{
+	printk(KERN_DEBUG "%s: codec %p\n", __func__, codec);
+
+	snd_soc_dapm_new_controls(codec, widgets, ARRAY_SIZE(widgets));
+	snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+#include "s3c24xx-pcm.h"
+
+static struct snd_soc_dai_link wm_dai_link = {
+	.name		= "WM8731",
+	.stream_name	= "WM8731",
+	.cpu_dai	= &s3c64xx_i2s_dai,
+	.codec_dai	= &wm8731_dai,
+	.init		= wm_init,
+	.ops		= &wm_ops,
+};
+
+static struct snd_soc_card wm_card = {
+	.name		= "SMDK6410-WM8731",
+	.dai_link	= &wm_dai_link,
+	.platform	= &s3c24xx_soc_platform,
+	.num_links	= 1,
+};
+
+struct wm8731_setup_data wm_setup = {
+	.i2c_bus	= 0,
+	.i2c_address	= 0x1a,
+};
+
+static struct snd_soc_device wm_snd_devdata = {
+	.card		= &wm_card,
+	.codec_dev	= &soc_codec_dev_wm8731,
+	.codec_data	= &wm_setup,
+};
+
+static int __init smdk6410_wm8731_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "%s: welcome\n", __func__);
+
+	if (!machine_is_smdk6410()) {
+		printk(KERN_INFO "%s: for SMDK6410s\n", __func__);
+		return -ENOENT;
+	}
+
+	socdev = platform_device_alloc("soc-audio", 0);
+	if (!socdev) {
+		printk(KERN_ERR "%s: no device\n", __func__);
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(socdev, &wm_snd_devdata);
+
+	wm_snd_devdata.dev = &socdev->dev;
+
+	ret = platform_device_add(socdev);
+	if (ret) {
+		printk(KERN_ERR "%s: failed to add\n", __func__);
+		goto err_dev;
+	}
+
+	printk(KERN_INFO "%s: succesfull\n", __func__);
+	return 0;
+
+err_dev:
+	platform_device_put(socdev);
+	return ret;
+}
+
+module_init(smdk6410_wm8731_init);
+MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
+MODULE_LICENSE("GPL");
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/soc-core.c linux-2.6.29-rc3.owrt.om/sound/soc/soc-core.c
--- linux-2.6.29-rc3.owrt/sound/soc/soc-core.c	2009-05-10 22:09:10.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/soc-core.c	2009-05-10 22:28:00.000000000 +0200
@@ -1190,6 +1190,7 @@
 }
 #endif
 
+
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
diff -ruN --exclude='*.orig' --exclude='*.rej' linux-2.6.29-rc3.owrt/sound/soc/soc-dapm.c linux-2.6.29-rc3.owrt.om/sound/soc/soc-dapm.c
--- linux-2.6.29-rc3.owrt/sound/soc/soc-dapm.c	2009-05-10 22:05:01.000000000 +0200
+++ linux-2.6.29-rc3.owrt.om/sound/soc/soc-dapm.c	2009-05-10 22:28:00.000000000 +0200
@@ -332,6 +332,24 @@
 
 			snprintf(path->long_name, name_len, "%s %s",
 				 w->name, w->kcontrols[i].name);
+
+			/*
+			 * This is an ugly Openmoko revert for name
+			 * changes in alsa configuration. This is mergeable
+			 * with the future Linux version.
+			 * We force the truncation again for now because we
+			 * can't cope with mass breakage on alsa state files
+			 * that are spread all over the different distros.
+			 * FIXME: Remember to revert this change.
+			 */
+
+			if (name_len > 32) {
+				printk(KERN_WARNING __FILE__ ":%d mixer name "
+				"'%s' truncated to 31 characters.\n",
+				__LINE__, path->long_name);
+				name_len = 32;
+			}
+
 			path->long_name[name_len - 1] = '\0';
 
 			path->kcontrol = snd_soc_cnew(&w->kcontrols[i], w,
@@ -876,7 +894,7 @@
 }
 
 static int snd_soc_dapm_set_pin(struct snd_soc_codec *codec,
-	char *pin, int status)
+				const char *pin, int status)
 {
 	struct snd_soc_dapm_widget *w;
 
@@ -1396,6 +1414,76 @@
 EXPORT_SYMBOL_GPL(snd_soc_dapm_put_value_enum_double);
 
 /**
+ * snd_soc_dapm_info_pin_switch - Info for a pin switch
+ *
+ * @kcontrol: mixer control
+ * @uinfo: control element information
+ *
+ * Callback to provide information about a pin switch control.
+ */
+int snd_soc_dapm_info_pin_switch(struct snd_kcontrol *kcontrol,
+				 struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_info_pin_switch);
+
+/**
+ * snd_soc_dapm_get_pin_switch - Get information for a pin switch
+ *
+ * @kcontrol: mixer control
+ * @ucontrol: Value
+ */
+int snd_soc_dapm_get_pin_switch(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	const char *pin = (const char *)kcontrol->private_value;
+
+	mutex_lock(&codec->mutex);
+
+	ucontrol->value.integer.value[0] =
+		snd_soc_dapm_get_pin_status(codec, pin);
+
+	mutex_unlock(&codec->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_pin_switch);
+
+/**
+ * snd_soc_dapm_put_pin_switch - Set information for a pin switch
+ *
+ * @kcontrol: mixer control
+ * @ucontrol: Value
+ */
+int snd_soc_dapm_put_pin_switch(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	const char *pin = (const char *)kcontrol->private_value;
+
+	mutex_lock(&codec->mutex);
+
+	if (ucontrol->value.integer.value[0])
+		snd_soc_dapm_enable_pin(codec, pin);
+	else
+		snd_soc_dapm_disable_pin(codec, pin);
+
+	snd_soc_dapm_sync(codec);
+
+	mutex_unlock(&codec->mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_put_pin_switch);
+
+/**
  * snd_soc_dapm_new_control - create new dapm control
  * @codec: audio codec
  * @widget: widget template
@@ -1549,7 +1637,7 @@
  * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
  * do any widget power switching.
  */
-int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, char *pin)
+int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, const char *pin)
 {
 	return snd_soc_dapm_set_pin(codec, pin, 1);
 }
@@ -1564,7 +1652,7 @@
  * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
  * do any widget power switching.
  */
-int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, char *pin)
+int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, const char *pin)
 {
 	return snd_soc_dapm_set_pin(codec, pin, 0);
 }
@@ -1584,7 +1672,7 @@
  * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
  * do any widget power switching.
  */
-int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, char *pin)
+int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, const char *pin)
 {
 	return snd_soc_dapm_set_pin(codec, pin, 0);
 }
@@ -1599,7 +1687,7 @@
  *
  * Returns 1 for connected otherwise 0.
  */
-int snd_soc_dapm_get_pin_status(struct snd_soc_codec *codec, char *pin)
+int snd_soc_dapm_get_pin_status(struct snd_soc_codec *codec, const char *pin)
 {
 	struct snd_soc_dapm_widget *w;
 
@@ -1613,6 +1701,56 @@
 EXPORT_SYMBOL_GPL(snd_soc_dapm_get_pin_status);
 
 /**
+ * snd_soc_dapm_get_endpoint - get audio endpoint status
+ * @codec: audio codec
+ * @endpoint: audio signal endpoint (or start point)
+ *
+ * Get audio endpoint status - connected or disconnected.
+ *
+ * Returns status
+ */
+int snd_soc_dapm_get_endpoint(struct snd_soc_codec *codec,
+	char *endpoint)
+{
+	struct snd_soc_dapm_widget *w;
+
+	list_for_each_entry(w, &codec->dapm_widgets, list) {
+		if (!strcmp(w->name, endpoint)) {
+			return w->connected;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_get_endpoint);
+
+/**
+ * snd_soc_dapm_set_endpoint - set audio endpoint status
+ * @codec: audio codec
+ * @endpoint: audio signal endpoint (or start point)
+ * @status: point status
+ *
+ * Set audio endpoint status - connected or disconnected.
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_set_endpoint(struct snd_soc_codec *codec,
+        char *endpoint, int status)
+{
+        struct snd_soc_dapm_widget *w;
+
+        list_for_each_entry(w, &codec->dapm_widgets, list) {
+               if (!strcmp(w->name, endpoint)) {
+                        w->connected = status;
+                        return 0;
+                }
+        }
+
+        return -ENODEV;
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_set_endpoint);
+
+/**
  * snd_soc_dapm_free - free dapm resources
  * @socdev: SoC device
  *
