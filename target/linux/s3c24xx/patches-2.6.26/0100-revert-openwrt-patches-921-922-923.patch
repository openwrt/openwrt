Index: linux-2.6.26/Documentation/gpiommc.txt
===================================================================
--- linux-2.6.26.orig/Documentation/gpiommc.txt	2008-12-12 21:55:07.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,97 +0,0 @@
-GPIOMMC - Driver for an MMC/SD card on a bitbanging GPIO SPI bus
-================================================================
-
-The gpiommc module hooks up the mmc_spi and spi_gpio modules for running an
-MMC or SD card on GPIO pins.
-
-Two interfaces for registering a new MMC/SD card device are provided:
-A static platform-device based mechanism and a dynamic configfs based interface.
-
-
-Registering devices via platform-device
-=======================================
-
-The platform-device interface is used for registering MMC/SD devices that are
-part of the hardware platform. This is most useful only for embedded machines
-with MMC/SD devices statically connected to the platform GPIO bus.
-
-The data structures are declared in <linux/mmc/gpiommc.h>.
-
-To register a new device, define an instance of struct gpiommc_platform_data.
-This structure holds any information about how the device is hooked up to the
-GPIO pins and what hardware modes the device supports. See the docbook-style
-documentation in the header file for more information on the struct fields.
-
-Then allocate a new instance of a platform device by doing:
-
-	pdev = platform_device_alloc(GPIOMMC_PLATDEV_NAME, gpiommc_next_id());
-
-This will allocate the platform device data structures and hook it up to the
-gpiommc driver.
-Then add the gpiommc_platform_data to the platform device.
-
-	err = platform_device_add_data(pdev, pdata, sizeof(struct gpiommc_platform_data));
-
-You may free the local instance of struct gpiommc_platform_data now. (So the
-struct may be allocated on the stack, too).
-Now simply register the platform device.
-
-	err = platform_device_add(pdev);
-
-Done. The gpiommc probe routine will be invoked now and you should see a kernel
-log message for the added device.
-
-
-Registering devices via configfs
-================================
-
-MMC/SD cards connected via GPIO often are a pretty dynamic thing, as for example
-selfmade hacks for soldering an MMC/SD card to standard GPIO pins on embedded
-hardware are a common situation.
-So we provide a dynamic interface to conveniently handle adding and removing
-devices from userspace, without the need to recompile the kernel.
-
-The "gpiommc" subdirectory at the configfs mountpoint is used for handling
-the dynamic configuration.
-
-To create a new device, it must first be allocated with mkdir.
-The following command will allocate a device named "my_mmc":
-	mkdir /config/gpiommc/my_mmc
-
-There are several configuration files available in the new
-/config/gpiommc/my_mmc/ directory:
-
-gpio_data_in			= The SPI data-IN GPIO pin number.
-gpio_data_out			= The SPI data-OUT GPIO pin number.
-gpio_clock			= The SPI Clock GPIO pin number.
-gpio_chipselect			= The SPI Chipselect GPIO pin number.
-gpio_chipselect_activelow	= Boolean. If 0, Chipselect is active-HIGH.
-				  If 1, Chipselect is active-LOW.
-spi_mode			= The SPI data mode. Can be 0-3.
-spi_delay			= Enable all delays in the lowlevel bitbanging.
-max_bus_speed			= The maximum SPI bus speed. In Hertz.
-
-register			= Not a configuration parameter.
-				  Used to register the configured card
-				  with the kernel.
-
-The device must first get configured and then registered by writing "1" to
-the "register" file.
-The configuration parameters "gpio_data_in", "gpio_data_out", "gpio_clock"
-and "gpio_chipselect" are essential and _must_ be configured before writing
-"1" to the "register" file. The registration will fail, otherwise.
-
-The default values for the other parameters are:
-gpio_chipselect_activelow	= 1		(CS active-LOW)
-spi_mode			= 0		(SPI_MODE_0)
-spi_delay			= 1		(enabled)
-max_bus_speed			= 5000000	(5 Mhz)
-
-Configuration values can not be changed after registration. To unregister
-the device, write a "0" to the "register" file. The configuration can be
-changed again after unregistering.
-
-To completely remove the device, simply rmdir the directory
-(/config/gpiommc/my_mmc in this example).
-There's no need to first unregister the device before removing it. That will
-be done automatically.
Index: linux-2.6.26/drivers/mmc/host/gpiommc.c
===================================================================
--- linux-2.6.26.orig/drivers/mmc/host/gpiommc.c	2008-12-12 21:55:07.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,624 +0,0 @@
-/*
- * Driver an MMC/SD card on a bitbanging GPIO SPI bus.
- * This module hooks up the mmc_spi and spi_gpio modules and also
- * provides a configfs interface.
- *
- * Copyright 2008 Michael Buesch <mb@bu3sch.de>
- *
- * Licensed under the GNU/GPL. See COPYING for details.
- */
-
-#include <linux/platform_device.h>
-#include <linux/list.h>
-#include <linux/mutex.h>
-#include <linux/mmc/gpiommc.h>
-#include <linux/mmc/host.h>
-#include <linux/spi/spi_gpio.h>
-#include <linux/spi/mmc_spi.h>
-#include <linux/configfs.h>
-#include <linux/gpio.h>
-#include <asm/atomic.h>
-
-
-#define PFX				"gpio-mmc: "
-
-
-struct gpiommc_device {
-	struct platform_device *pdev;
-	struct platform_device *spi_pdev;
-	struct spi_board_info boardinfo;
-	struct mmc_spi_platform_data mmc_spi_data;
-};
-
-
-MODULE_DESCRIPTION("GPIO based MMC driver");
-MODULE_AUTHOR("Michael Buesch");
-MODULE_LICENSE("GPL");
-
-
-static int gpiommc_boardinfo_setup(struct spi_board_info *bi,
-				   struct spi_master *master,
-				   void *data)
-{
-	struct gpiommc_device *d = data;
-	struct gpiommc_platform_data *pdata = d->pdev->dev.platform_data;
-
-	/* Bind the SPI master to the MMC-SPI host driver. */
-	strlcpy(bi->modalias, "mmc_spi", sizeof(bi->modalias));
-
-	bi->max_speed_hz = pdata->max_bus_speed;
-	bi->bus_num = master->bus_num;
-	bi->mode = pdata->mode;
-	bi->platform_data = &d->mmc_spi_data;
-
-	return 0;
-}
-
-static int gpiommc_probe(struct platform_device *pdev)
-{
-	struct gpiommc_platform_data *mmc_pdata = pdev->dev.platform_data;
-	struct spi_gpio_platform_data spi_pdata;
-	struct gpiommc_device *d;
-	int err;
-
-	err = -ENXIO;
-	if (!mmc_pdata)
-		goto error;
-
-#ifdef CONFIG_MMC_SPI_MODULE
-	err = request_module("mmc_spi");
-	if (err) {
-		printk(KERN_WARNING PFX
-		       "Failed to request mmc_spi module.\n");
-	}
-#endif /* CONFIG_MMC_SPI_MODULE */
-
-	/* Allocate the GPIO-MMC device */
-	err = -ENOMEM;
-	d = kzalloc(sizeof(*d), GFP_KERNEL);
-	if (!d)
-		goto error;
-	d->pdev = pdev;
-	d->mmc_spi_data.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34;
-
-	/* Create the SPI-GPIO device */
-	d->spi_pdev = platform_device_alloc(SPI_GPIO_PLATDEV_NAME,
-					    spi_gpio_next_id());
-	if (!d->spi_pdev)
-		goto err_free_d;
-
-	memset(&spi_pdata, 0, sizeof(spi_pdata));
-	spi_pdata.pin_clk = mmc_pdata->pins.gpio_clk;
-	spi_pdata.pin_miso = mmc_pdata->pins.gpio_do;
-	spi_pdata.pin_mosi = mmc_pdata->pins.gpio_di;
-	spi_pdata.pin_cs = mmc_pdata->pins.gpio_cs;
-	spi_pdata.cs_activelow = mmc_pdata->pins.cs_activelow;
-	spi_pdata.no_spi_delay = mmc_pdata->no_spi_delay;
-	spi_pdata.boardinfo_setup = gpiommc_boardinfo_setup;
-	spi_pdata.boardinfo_setup_data = d;
-
-	err = platform_device_add_data(d->spi_pdev, &spi_pdata,
-				       sizeof(spi_pdata));
-	if (err)
-		goto err_free_pdev;
-	err = platform_device_add(d->spi_pdev);
-	if (err)
-		goto err_free_pdata;
-	platform_set_drvdata(pdev, d);
-
-	printk(KERN_INFO PFX "MMC-Card \"%s\" "
-	       "attached to GPIO pins di=%u, do=%u, clk=%u, cs=%u\n",
-	       mmc_pdata->name, mmc_pdata->pins.gpio_di,
-	       mmc_pdata->pins.gpio_do,
-	       mmc_pdata->pins.gpio_clk,
-	       mmc_pdata->pins.gpio_cs);
-
-	return 0;
-
-err_free_pdata:
-	kfree(d->spi_pdev->dev.platform_data);
-	d->spi_pdev->dev.platform_data = NULL;
-err_free_pdev:
-	platform_device_put(d->spi_pdev);
-err_free_d:
-	kfree(d);
-error:
-	return err;
-}
-
-static int gpiommc_remove(struct platform_device *pdev)
-{
-	struct gpiommc_device *d = platform_get_drvdata(pdev);
-	struct gpiommc_platform_data *pdata = d->pdev->dev.platform_data;
-
-	platform_device_unregister(d->spi_pdev);
-	printk(KERN_INFO PFX "GPIO based MMC-Card \"%s\" removed\n",
-	       pdata->name);
-	platform_device_put(d->spi_pdev);
-
-	return 0;
-}
-
-#ifdef CONFIG_GPIOMMC_CONFIGFS
-
-/* A device that was created through configfs */
-struct gpiommc_configfs_device {
-	struct config_item item;
-	/* The platform device, after registration. */
-	struct platform_device *pdev;
-	/* The configuration */
-	struct gpiommc_platform_data pdata;
-	/* Mutex to protect this structure */
-	struct mutex mutex;
-};
-
-#define GPIO_INVALID	-1
-
-static inline bool gpiommc_is_registered(struct gpiommc_configfs_device *dev)
-{
-	return (dev->pdev != NULL);
-}
-
-static inline struct gpiommc_configfs_device *ci_to_gpiommc(struct config_item *item)
-{
-	return item ? container_of(item, struct gpiommc_configfs_device, item) : NULL;
-}
-
-static struct configfs_attribute gpiommc_attr_DI = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "gpio_data_in",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_DO = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "gpio_data_out",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_CLK = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "gpio_clock",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_CS = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "gpio_chipselect",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_CS_activelow = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "gpio_chipselect_activelow",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_spimode = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "spi_mode",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_spidelay = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "spi_delay",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_max_bus_speed = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "max_bus_speed",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute gpiommc_attr_register = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "register",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute *gpiommc_config_attrs[] = {
-	&gpiommc_attr_DI,
-	&gpiommc_attr_DO,
-	&gpiommc_attr_CLK,
-	&gpiommc_attr_CS,
-	&gpiommc_attr_CS_activelow,
-	&gpiommc_attr_spimode,
-	&gpiommc_attr_spidelay,
-	&gpiommc_attr_max_bus_speed,
-	&gpiommc_attr_register,
-	NULL,
-};
-
-static ssize_t gpiommc_config_attr_show(struct config_item *item,
-					struct configfs_attribute *attr,
-					char *page)
-{
-	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
-	ssize_t count = 0;
-	unsigned int gpio;
-	int err = 0;
-
-	mutex_lock(&dev->mutex);
-
-	if (attr == &gpiommc_attr_DI) {
-		gpio = dev->pdata.pins.gpio_di;
-		if (gpio == GPIO_INVALID)
-			count = snprintf(page, PAGE_SIZE, "not configured\n");
-		else
-			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_DO) {
-		gpio = dev->pdata.pins.gpio_do;
-		if (gpio == GPIO_INVALID)
-			count = snprintf(page, PAGE_SIZE, "not configured\n");
-		else
-			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_CLK) {
-		gpio = dev->pdata.pins.gpio_clk;
-		if (gpio == GPIO_INVALID)
-			count = snprintf(page, PAGE_SIZE, "not configured\n");
-		else
-			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_CS) {
-		gpio = dev->pdata.pins.gpio_cs;
-		if (gpio == GPIO_INVALID)
-			count = snprintf(page, PAGE_SIZE, "not configured\n");
-		else
-			count = snprintf(page, PAGE_SIZE, "%u\n", gpio);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_CS_activelow) {
-		count = snprintf(page, PAGE_SIZE, "%u\n",
-				 dev->pdata.pins.cs_activelow);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_spimode) {
-		count = snprintf(page, PAGE_SIZE, "%u\n",
-				 dev->pdata.mode);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_spidelay) {
-		count = snprintf(page, PAGE_SIZE, "%u\n",
-				 !dev->pdata.no_spi_delay);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_max_bus_speed) {
-		count = snprintf(page, PAGE_SIZE, "%u\n",
-				 dev->pdata.max_bus_speed);
-		goto out;
-	}
-	if (attr == &gpiommc_attr_register) {
-		count = snprintf(page, PAGE_SIZE, "%u\n",
-				 gpiommc_is_registered(dev));
-		goto out;
-	}
-	WARN_ON(1);
-	err = -ENOSYS;
-out:
-	mutex_unlock(&dev->mutex);
-
-	return err ? err : count;
-}
-
-static int gpiommc_do_register(struct gpiommc_configfs_device *dev,
-			       const char *name)
-{
-	int err;
-
-	if (gpiommc_is_registered(dev))
-		return 0;
-
-	if (!gpio_is_valid(dev->pdata.pins.gpio_di) ||
-	    !gpio_is_valid(dev->pdata.pins.gpio_do) ||
-	    !gpio_is_valid(dev->pdata.pins.gpio_clk) ||
-	    !gpio_is_valid(dev->pdata.pins.gpio_cs)) {
-		printk(KERN_ERR PFX
-		       "configfs: Invalid GPIO pin number(s)\n");
-		return -EINVAL;
-	}
-
-	strlcpy(dev->pdata.name, name,
-		sizeof(dev->pdata.name));
-
-	dev->pdev = platform_device_alloc(GPIOMMC_PLATDEV_NAME,
-					  gpiommc_next_id());
-	if (!dev->pdev)
-		return -ENOMEM;
-	err = platform_device_add_data(dev->pdev, &dev->pdata,
-				       sizeof(dev->pdata));
-	if (err) {
-		platform_device_put(dev->pdev);
-		return err;
-	}
-	err = platform_device_add(dev->pdev);
-	if (err) {
-		platform_device_put(dev->pdev);
-		return err;
-	}
-
-	return 0;
-}
-
-static void gpiommc_do_unregister(struct gpiommc_configfs_device *dev)
-{
-	if (!gpiommc_is_registered(dev))
-		return;
-
-	platform_device_unregister(dev->pdev);
-	dev->pdev = NULL;
-}
-
-static ssize_t gpiommc_config_attr_store(struct config_item *item,
-					 struct configfs_attribute *attr,
-					 const char *page, size_t count)
-{
-	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
-	int err = -EINVAL;
-	unsigned long data;
-
-	mutex_lock(&dev->mutex);
-
-	if (attr == &gpiommc_attr_register) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (data == 1)
-			err = gpiommc_do_register(dev, item->ci_name);
-		if (data == 0) {
-			gpiommc_do_unregister(dev);
-			err = 0;
-		}
-		goto out;
-	}
-
-	if (gpiommc_is_registered(dev)) {
-		/* The rest of the config parameters can only be set
-		 * as long as the device is not registered, yet. */
-		err = -EBUSY;
-		goto out;
-	}
-
-	if (attr == &gpiommc_attr_DI) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (!gpio_is_valid(data))
-			goto out;
-		dev->pdata.pins.gpio_di = data;
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_DO) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (!gpio_is_valid(data))
-			goto out;
-		dev->pdata.pins.gpio_do = data;
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_CLK) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (!gpio_is_valid(data))
-			goto out;
-		dev->pdata.pins.gpio_clk = data;
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_CS) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (!gpio_is_valid(data))
-			goto out;
-		dev->pdata.pins.gpio_cs = data;
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_CS_activelow) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (data != 0 && data != 1)
-			goto out;
-		dev->pdata.pins.cs_activelow = data;
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_spimode) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		switch (data) {
-		case 0:
-			dev->pdata.mode = SPI_MODE_0;
-			break;
-		case 1:
-			dev->pdata.mode = SPI_MODE_1;
-			break;
-		case 2:
-			dev->pdata.mode = SPI_MODE_2;
-			break;
-		case 3:
-			dev->pdata.mode = SPI_MODE_3;
-			break;
-		default:
-			goto out;
-		}
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_spidelay) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (data != 0 && data != 1)
-			goto out;
-		dev->pdata.no_spi_delay = !data;
-		err = 0;
-		goto out;
-	}
-	if (attr == &gpiommc_attr_max_bus_speed) {
-		err = strict_strtoul(page, 10, &data);
-		if (err)
-			goto out;
-		err = -EINVAL;
-		if (data > UINT_MAX)
-			goto out;
-		dev->pdata.max_bus_speed = data;
-		err = 0;
-		goto out;
-	}
-	WARN_ON(1);
-	err = -ENOSYS;
-out:
-	mutex_unlock(&dev->mutex);
-
-	return err ? err : count;
-}
-
-static void gpiommc_config_item_release(struct config_item *item)
-{
-	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
-
-	kfree(dev);
-}
-
-static struct configfs_item_operations gpiommc_config_item_ops = {
-	.release		= gpiommc_config_item_release,
-	.show_attribute		= gpiommc_config_attr_show,
-	.store_attribute	= gpiommc_config_attr_store,
-};
-
-static struct config_item_type gpiommc_dev_ci_type = {
-	.ct_item_ops	= &gpiommc_config_item_ops,
-	.ct_attrs	= gpiommc_config_attrs,
-	.ct_owner	= THIS_MODULE,
-};
-
-static struct config_item *gpiommc_make_item(struct config_group *group,
-					     const char *name)
-{
-	struct gpiommc_configfs_device *dev;
-
-	if (strlen(name) > GPIOMMC_MAX_NAMELEN) {
-		printk(KERN_ERR PFX "configfs: device name too long\n");
-		return NULL;
-	}
-
-	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
-		return NULL;
-
-	mutex_init(&dev->mutex);
-	config_item_init_type_name(&dev->item, name,
-				   &gpiommc_dev_ci_type);
-
-	/* Assign default configuration */
-	dev->pdata.pins.gpio_di = GPIO_INVALID;
-	dev->pdata.pins.gpio_do = GPIO_INVALID;
-	dev->pdata.pins.gpio_clk = GPIO_INVALID;
-	dev->pdata.pins.gpio_cs = GPIO_INVALID;
-	dev->pdata.pins.cs_activelow = 1;
-	dev->pdata.mode = SPI_MODE_0;
-	dev->pdata.no_spi_delay = 0;
-	dev->pdata.max_bus_speed = 5000000; /* 5 MHz */
-
-	return &(dev->item);
-}
-
-static void gpiommc_drop_item(struct config_group *group,
-			      struct config_item *item)
-{
-	struct gpiommc_configfs_device *dev = ci_to_gpiommc(item);
-
-	gpiommc_do_unregister(dev);
-	kfree(dev);
-}
-
-static struct configfs_group_operations gpiommc_ct_group_ops = {
-	.make_item	= gpiommc_make_item,
-	.drop_item	= gpiommc_drop_item,
-};
-
-static struct config_item_type gpiommc_ci_type = {
-	.ct_group_ops	= &gpiommc_ct_group_ops,
-	.ct_owner	= THIS_MODULE,
-};
-
-static struct configfs_subsystem gpiommc_subsys = {
-	.su_group = {
-		.cg_item = {
-			.ci_namebuf = GPIOMMC_PLATDEV_NAME,
-			.ci_type = &gpiommc_ci_type,
-		},
-	},
-	.su_mutex = __MUTEX_INITIALIZER(gpiommc_subsys.su_mutex),
-};
-
-#endif /* CONFIG_GPIOMMC_CONFIGFS */
-
-static struct platform_driver gpiommc_plat_driver = {
-	.probe	= gpiommc_probe,
-	.remove	= gpiommc_remove,
-	.driver	= {
-		.name	= GPIOMMC_PLATDEV_NAME,
-		.owner	= THIS_MODULE,
-	},
-};
-
-int gpiommc_next_id(void)
-{
-	static atomic_t counter = ATOMIC_INIT(-1);
-
-	return atomic_inc_return(&counter);
-}
-EXPORT_SYMBOL(gpiommc_next_id);
-
-static int __init gpiommc_modinit(void)
-{
-	int err;
-
-	err = platform_driver_register(&gpiommc_plat_driver);
-	if (err)
-		return err;
-
-#ifdef CONFIG_GPIOMMC_CONFIGFS
-	config_group_init(&gpiommc_subsys.su_group);
-	err = configfs_register_subsystem(&gpiommc_subsys);
-	if (err) {
-		platform_driver_unregister(&gpiommc_plat_driver);
-		return err;
-	}
-#endif /* CONFIG_GPIOMMC_CONFIGFS */
-
-	return 0;
-}
-module_init(gpiommc_modinit);
-
-static void __exit gpiommc_modexit(void)
-{
-#ifdef CONFIG_GPIOMMC_CONFIGFS
-	configfs_unregister_subsystem(&gpiommc_subsys);
-#endif
-	platform_driver_unregister(&gpiommc_plat_driver);
-}
-module_exit(gpiommc_modexit);
Index: linux-2.6.26/drivers/mmc/host/Kconfig
===================================================================
--- linux-2.6.26.orig/drivers/mmc/host/Kconfig	2008-12-12 21:55:07.000000000 +0100
+++ linux-2.6.26/drivers/mmc/host/Kconfig	2008-12-12 21:55:25.000000000 +0100
@@ -130,27 +130,3 @@ config MMC_SPI
 
 	  If unsure, or if your system has no SPI master driver, say N.
 
-config GPIOMMC
-	tristate "MMC/SD over GPIO-based SPI"
-	depends on MMC && MMC_SPI && SPI_GPIO
-	help
-	  This driver hooks up the mmc_spi and spi_gpio modules so that
-	  MMC/SD cards can be used on a GPIO based bus by bitbanging
-	  the SPI protocol in software.
-
-	  This driver provides a configfs interface to dynamically create
-	  and destroy GPIO-based MMC/SD card devices. It also provides
-	  a platform device interface API.
-	  See Documentation/gpiommc.txt for details.
-
-	  The module will be called gpiommc.
-
-	  If unsure, say N.
-
-config GPIOMMC_CONFIGFS
-	bool
-	depends on GPIOMMC && CONFIGFS_FS
-	default y
-	help
-	  This option automatically enables configfs support for gpiommc
-	  if configfs is available.
Index: linux-2.6.26/drivers/mmc/host/Makefile
===================================================================
--- linux-2.6.26.orig/drivers/mmc/host/Makefile	2008-12-12 21:55:07.000000000 +0100
+++ linux-2.6.26/drivers/mmc/host/Makefile	2008-12-12 21:55:25.000000000 +0100
@@ -17,4 +17,4 @@ obj-$(CONFIG_MMC_OMAP)		+= omap.o
 obj-$(CONFIG_MMC_AT91)		+= at91_mci.o
 obj-$(CONFIG_MMC_TIFM_SD)	+= tifm_sd.o
 obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
-obj-$(CONFIG_GPIOMMC)		+= gpiommc.o
+
Index: linux-2.6.26/drivers/spi/Kconfig
===================================================================
--- linux-2.6.26.orig/drivers/spi/Kconfig	2008-12-12 21:55:07.000000000 +0100
+++ linux-2.6.26/drivers/spi/Kconfig	2008-12-12 21:55:25.000000000 +0100
@@ -100,19 +100,6 @@ config SPI_BUTTERFLY
 	  inexpensive battery powered microcontroller evaluation board.
 	  This same cable can be used to flash new firmware.
 
-config SPI_GPIO
-	tristate "GPIO API based bitbanging SPI controller"
-	depends on SPI_MASTER && GENERIC_GPIO
-	select SPI_BITBANG
-	help
-	  This is a platform driver that can be used for bitbanging
-	  an SPI bus over GPIO pins.
-	  Select this if you have any SPI device that is connected via
-	  GPIO pins.
-	  The module will be called spi_gpio.
-
-	  If unsure, say N.
-
 config SPI_IMX
 	tristate "Freescale iMX SPI controller"
 	depends on SPI_MASTER && ARCH_IMX && EXPERIMENTAL
Index: linux-2.6.26/drivers/spi/Makefile
===================================================================
--- linux-2.6.26.orig/drivers/spi/Makefile	2008-12-12 21:55:07.000000000 +0100
+++ linux-2.6.26/drivers/spi/Makefile	2008-12-12 21:55:25.000000000 +0100
@@ -16,7 +16,6 @@ obj-$(CONFIG_SPI_BFIN)			+= spi_bfin5xx.
 obj-$(CONFIG_SPI_BITBANG)		+= spi_bitbang.o
 obj-$(CONFIG_SPI_AU1550)		+= au1550_spi.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi_butterfly.o
-obj-$(CONFIG_SPI_GPIO)			+= spi_gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi_imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi_lm70llp.o
 obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
Index: linux-2.6.26/drivers/spi/spi_gpio.c
===================================================================
--- linux-2.6.26.orig/drivers/spi/spi_gpio.c	2008-12-12 21:55:07.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,251 +0,0 @@
-/*
- * Bitbanging SPI bus driver using GPIO API
- *
- * Copyright (c) 2008 Piotr Skamruk
- * Copyright (c) 2008 Michael Buesch
- *
- * based on spi_s3c2410_gpio.c
- *   Copyright (c) 2006 Ben Dooks
- *   Copyright (c) 2006 Simtec Electronics
- * and on i2c-gpio.c
- *   Copyright (C) 2007 Atmel Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/spinlock.h>
-#include <linux/workqueue.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/spi_bitbang.h>
-#include <linux/spi/spi_gpio.h>
-#include <linux/gpio.h>
-#include <asm/atomic.h>
-
-
-struct spi_gpio {
-	struct spi_bitbang bitbang;
-	struct spi_gpio_platform_data *info;
-	struct platform_device *pdev;
-	struct spi_board_info bi;
-};
-
-
-static inline struct spi_gpio *spidev_to_sg(struct spi_device *dev)
-{
-	return dev->controller_data;
-}
-
-static inline void setsck(struct spi_device *dev, int val)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-	gpio_set_value(sp->info->pin_clk, val ? 1 : 0);
-}
-
-static inline void setmosi(struct spi_device *dev, int val)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-	gpio_set_value(sp->info->pin_mosi, val ? 1 : 0);
-}
-
-static inline u32 getmiso(struct spi_device *dev)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-	return gpio_get_value(sp->info->pin_miso) ? 1 : 0;
-}
-
-static inline void do_spidelay(struct spi_device *dev, unsigned nsecs)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-
-	if (!sp->info->no_spi_delay)
-		ndelay(nsecs);
-}
-
-#define spidelay(nsecs) do {					\
-	/* Steal the spi_device pointer from our caller.	\
-	 * The bitbang-API should probably get fixed here... */	\
-	do_spidelay(spi, nsecs);				\
-  } while (0)
-
-#define EXPAND_BITBANG_TXRX
-#include <linux/spi/spi_bitbang.h>
-
-static u32 spi_gpio_txrx_mode0(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha0(spi, nsecs, 0, word, bits);
-}
-
-static u32 spi_gpio_txrx_mode1(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha1(spi, nsecs, 0, word, bits);
-}
-
-static u32 spi_gpio_txrx_mode2(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha0(spi, nsecs, 1, word, bits);
-}
-
-static u32 spi_gpio_txrx_mode3(struct spi_device *spi,
-			       unsigned nsecs, u32 word, u8 bits)
-{
-	return bitbang_txrx_be_cpha1(spi, nsecs, 1, word, bits);
-}
-
-static void spi_gpio_chipselect(struct spi_device *dev, int on)
-{
-	struct spi_gpio *sp = spidev_to_sg(dev);
-
-	if (sp->info->cs_activelow)
-		on = !on;
-	gpio_set_value(sp->info->pin_cs, on ? 1 : 0);
-}
-
-static int spi_gpio_probe(struct platform_device *pdev)
-{
-	struct spi_master *master;
-	struct spi_gpio_platform_data *pdata;
-	struct spi_gpio *sp;
-	struct spi_device *spidev;
-	int err;
-
-	pdata = pdev->dev.platform_data;
-	if (!pdata)
-		return -ENXIO;
-
-	err = -ENOMEM;
-	master = spi_alloc_master(&pdev->dev, sizeof(struct spi_gpio));
-	if (!master)
-		goto err_alloc_master;
-
-	sp = spi_master_get_devdata(master);
-	platform_set_drvdata(pdev, sp);
-	sp->info = pdata;
-
-	err = gpio_request(pdata->pin_clk, "spi_clock");
-	if (err)
-		goto err_request_clk;
-	err = gpio_request(pdata->pin_mosi, "spi_mosi");
-	if (err)
-		goto err_request_mosi;
-	err = gpio_request(pdata->pin_miso, "spi_miso");
-	if (err)
-		goto err_request_miso;
-	err = gpio_request(pdata->pin_cs, "spi_cs");
-	if (err)
-		goto err_request_cs;
-
-	sp->bitbang.master = spi_master_get(master);
-	sp->bitbang.master->bus_num = -1;
-	sp->bitbang.master->num_chipselect = 1;
-	sp->bitbang.chipselect = spi_gpio_chipselect;
-	sp->bitbang.txrx_word[SPI_MODE_0] = spi_gpio_txrx_mode0;
-	sp->bitbang.txrx_word[SPI_MODE_1] = spi_gpio_txrx_mode1;
-	sp->bitbang.txrx_word[SPI_MODE_2] = spi_gpio_txrx_mode2;
-	sp->bitbang.txrx_word[SPI_MODE_3] = spi_gpio_txrx_mode3;
-
-	gpio_direction_output(pdata->pin_clk, 0);
-	gpio_direction_output(pdata->pin_mosi, 0);
-	gpio_direction_output(pdata->pin_cs,
-			      pdata->cs_activelow ? 1 : 0);
-	gpio_direction_input(pdata->pin_miso);
-
-	err = spi_bitbang_start(&sp->bitbang);
-	if (err)
-		goto err_no_bitbang;
-	err = pdata->boardinfo_setup(&sp->bi, master,
-				     pdata->boardinfo_setup_data);
-	if (err)
-		goto err_bi_setup;
-	sp->bi.controller_data = sp;
-	spidev = spi_new_device(master, &sp->bi);
-	if (!spidev)
-		goto err_new_dev;
-
-	return 0;
-
-err_new_dev:
-err_bi_setup:
-	spi_bitbang_stop(&sp->bitbang);
-err_no_bitbang:
-	spi_master_put(sp->bitbang.master);
-	gpio_free(pdata->pin_cs);
-err_request_cs:
-	gpio_free(pdata->pin_miso);
-err_request_miso:
-	gpio_free(pdata->pin_mosi);
-err_request_mosi:
-	gpio_free(pdata->pin_clk);
-err_request_clk:
-	kfree(master);
-
-err_alloc_master:
-	return err;
-}
-
-static int __devexit spi_gpio_remove(struct platform_device *pdev)
-{
-	struct spi_gpio *sp;
-	struct spi_gpio_platform_data *pdata;
-
-	pdata = pdev->dev.platform_data;
-	sp = platform_get_drvdata(pdev);
-
-	gpio_free(pdata->pin_clk);
-	gpio_free(pdata->pin_mosi);
-	gpio_free(pdata->pin_miso);
-	gpio_free(pdata->pin_cs);
-	spi_bitbang_stop(&sp->bitbang);
-	spi_master_put(sp->bitbang.master);
-
-	return 0;
-}
-
-static struct platform_driver spi_gpio_driver = {
-	.driver		= {
-		.name	= SPI_GPIO_PLATDEV_NAME,
-		.owner	= THIS_MODULE,
-	},
-	.probe		= spi_gpio_probe,
-	.remove		= __devexit_p(spi_gpio_remove),
-};
-
-int spi_gpio_next_id(void)
-{
-	static atomic_t counter = ATOMIC_INIT(-1);
-
-	return atomic_inc_return(&counter);
-}
-EXPORT_SYMBOL(spi_gpio_next_id);
-
-static int __init spi_gpio_init(void)
-{
-	int err;
-
-	err = platform_driver_register(&spi_gpio_driver);
-	if (err)
-		printk(KERN_ERR "spi-gpio: register failed: %d\n", err);
-
-	return err;
-}
-module_init(spi_gpio_init);
-
-static void __exit spi_gpio_exit(void)
-{
-	platform_driver_unregister(&spi_gpio_driver);
-}
-module_exit(spi_gpio_exit);
-
-MODULE_AUTHOR("Piot Skamruk <piotr.skamruk at gmail.com>");
-MODULE_AUTHOR("Michael Buesch");
-MODULE_DESCRIPTION("Platform independent GPIO bitbanging SPI driver");
-MODULE_LICENSE("GPL v2");
Index: linux-2.6.26/include/linux/mmc/gpiommc.h
===================================================================
--- linux-2.6.26.orig/include/linux/mmc/gpiommc.h	2008-12-12 21:55:07.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,71 +0,0 @@
-/*
- * Device driver for MMC/SD cards driven over a GPIO bus.
- *
- * Copyright (c) 2008 Michael Buesch
- *
- * Licensed under the GNU/GPL version 2.
- */
-#ifndef LINUX_GPIOMMC_H_
-#define LINUX_GPIOMMC_H_
-
-#include <linux/types.h>
-
-
-#define GPIOMMC_MAX_NAMELEN		15
-#define GPIOMMC_MAX_NAMELEN_STR		__stringify(GPIOMMC_MAX_NAMELEN)
-
-/**
- * struct gpiommc_pins - Hardware pin assignments
- *
- * @gpio_di: The GPIO number of the DATA IN pin
- * @gpio_do: The GPIO number of the DATA OUT pin
- * @gpio_clk: The GPIO number of the CLOCK pin
- * @gpio_cs: The GPIO number of the CHIPSELECT pin
- * @cs_activelow: If true, the chip is considered selected if @gpio_cs is low.
- */
-struct gpiommc_pins {
-	unsigned int gpio_di;
-	unsigned int gpio_do;
-	unsigned int gpio_clk;
-	unsigned int gpio_cs;
-	bool cs_activelow;
-};
-
-/**
- * struct gpiommc_platform_data - Platform data for a MMC-over-SPI-GPIO device.
- *
- * @name: The unique name string of the device.
- * @pins: The hardware pin assignments.
- * @mode: The hardware mode. This is either SPI_MODE_0,
- *        SPI_MODE_1, SPI_MODE_2 or SPI_MODE_3. See the SPI documentation.
- * @no_spi_delay: Do not use delays in the lowlevel SPI bitbanging code.
- *                This is not standards compliant, but may be required for some
- *                embedded machines to gain reasonable speed.
- * @max_bus_speed: The maximum speed of the SPI bus, in Hertz.
- */
-struct gpiommc_platform_data {
-	char name[GPIOMMC_MAX_NAMELEN + 1];
-	struct gpiommc_pins pins;
-	u8 mode;
-	bool no_spi_delay;
-	unsigned int max_bus_speed;
-};
-
-/**
- * GPIOMMC_PLATDEV_NAME - The platform device name string.
- *
- * The name string that has to be used for platform_device_alloc
- * when allocating a gpiommc device.
- */
-#define GPIOMMC_PLATDEV_NAME	"gpiommc"
-
-/**
- * gpiommc_next_id - Get another platform device ID number.
- *
- * This returns the next platform device ID number that has to be used
- * for platform_device_alloc. The ID is opaque and should not be used for
- * anything else.
- */
-int gpiommc_next_id(void);
-
-#endif /* LINUX_GPIOMMC_H_ */
Index: linux-2.6.26/include/linux/spi/spi_gpio.h
===================================================================
--- linux-2.6.26.orig/include/linux/spi/spi_gpio.h	2008-12-12 21:55:07.000000000 +0100
+++ /dev/null	1970-01-01 00:00:00.000000000 +0000
@@ -1,73 +0,0 @@
-/*
- * spi_gpio interface to platform code
- *
- * Copyright (c) 2008 Piotr Skamruk
- * Copyright (c) 2008 Michael Buesch
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#ifndef _LINUX_SPI_SPI_GPIO
-#define _LINUX_SPI_SPI_GPIO
-
-#include <linux/types.h>
-#include <linux/spi/spi.h>
-
-
-/**
- * struct spi_gpio_platform_data - Data definitions for a SPI-GPIO device.
- *
- * This structure holds information about a GPIO-based SPI device.
- *
- * @pin_clk: The GPIO pin number of the CLOCK pin.
- *
- * @pin_miso: The GPIO pin number of the MISO pin.
- *
- * @pin_mosi: The GPIO pin number of the MOSI pin.
- *
- * @pin_cs: The GPIO pin number of the CHIPSELECT pin.
- *
- * @cs_activelow: If true, the chip is selected when the CS line is low.
- *
- * @no_spi_delay: If true, no delay is done in the lowlevel bitbanging.
- *                Note that doing no delay is not standards compliant,
- *                but it might be needed to speed up transfers on some
- *                slow embedded machines.
- *
- * @boardinfo_setup: This callback is called after the
- *                   SPI master device was registered, but before the
- *                   device is registered.
- * @boardinfo_setup_data: Data argument passed to boardinfo_setup().
- */
-struct spi_gpio_platform_data {
-	unsigned int pin_clk;
-	unsigned int pin_miso;
-	unsigned int pin_mosi;
-	unsigned int pin_cs;
-	bool cs_activelow;
-	bool no_spi_delay;
-	int (*boardinfo_setup)(struct spi_board_info *bi,
-			       struct spi_master *master,
-			       void *data);
-	void *boardinfo_setup_data;
-};
-
-/**
- * SPI_GPIO_PLATDEV_NAME - The platform device name string.
- *
- * The name string that has to be used for platform_device_alloc
- * when allocating a spi-gpio device.
- */
-#define SPI_GPIO_PLATDEV_NAME	"spi-gpio"
-
-/**
- * spi_gpio_next_id - Get another platform device ID number.
- *
- * This returns the next platform device ID number that has to be used
- * for platform_device_alloc. The ID is opaque and should not be used for
- * anything else.
- */
-int spi_gpio_next_id(void);
-
-#endif /* _LINUX_SPI_SPI_GPIO */
Index: linux-2.6.26/MAINTAINERS
===================================================================
--- linux-2.6.26.orig/MAINTAINERS	2008-12-12 21:55:07.000000000 +0100
+++ linux-2.6.26/MAINTAINERS	2008-12-12 21:55:25.000000000 +0100
@@ -1818,11 +1818,6 @@ L:	gigaset307x-common@lists.sourceforge.
 W:	http://gigaset307x.sourceforge.net/
 S:	Maintained
 
-GPIOMMC DRIVER
-P:	Michael Buesch
-M:	mb@bu3sch.de
-S:	Maintained
-
 HARDWARE MONITORING
 P:	Mark M. Hoffman
 M:	mhoffman@lightlink.com
@@ -3800,11 +3795,6 @@ L:	cbe-oss-dev@ozlabs.org
 W:	http://www.ibm.com/developerworks/power/cell/
 S:	Supported
 
-SPI GPIO MASTER DRIVER
-P:	Michael Buesch
-M:	mb@bu3sch.de
-S:	Maintained
-
 STABLE BRANCH:
 P:	Greg Kroah-Hartman
 M:	greg@kroah.com
