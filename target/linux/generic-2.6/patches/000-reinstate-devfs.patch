diff -urN linux-2.6.19.old/arch/cris/arch-v10/kernel/debugport.c linux-2.6.19.dev/arch/cris/arch-v10/kernel/debugport.c
--- linux-2.6.19.old/arch/cris/arch-v10/kernel/debugport.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/cris/arch-v10/kernel/debugport.c	2006-12-14 03:12:59.000000000 +0100
@@ -540,7 +540,7 @@
 	dummy_driver.init_termios = tty_std_termios;
 	dummy_driver.init_termios.c_cflag =
 		B115200 | CS8 | CREAD | HUPCL | CLOCAL; /* is normally B9600 default... */
-	dummy_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	dummy_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 
 	dummy_driver.open = dummy_open;
 	dummy_driver.close = dummy_close;
diff -urN linux-2.6.19.old/arch/cris/arch-v32/kernel/debugport.c linux-2.6.19.dev/arch/cris/arch-v32/kernel/debugport.c
--- linux-2.6.19.old/arch/cris/arch-v32/kernel/debugport.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/cris/arch-v32/kernel/debugport.c	2006-12-14 03:12:59.000000000 +0100
@@ -352,7 +352,7 @@
 	dummy_driver.init_termios = tty_std_termios;
 	dummy_driver.init_termios.c_cflag =
 		B115200 | CS8 | CREAD | HUPCL | CLOCAL; /* is normally B9600 default... */
-	dummy_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	dummy_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 
 	dummy_driver.open = dummy_open;
 	dummy_driver.close = dummy_close;
diff -urN linux-2.6.19.old/arch/i386/kernel/microcode.c linux-2.6.19.dev/arch/i386/kernel/microcode.c
--- linux-2.6.19.old/arch/i386/kernel/microcode.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/i386/kernel/microcode.c	2006-12-14 03:12:59.000000000 +0100
@@ -460,6 +460,7 @@
 static struct miscdevice microcode_dev = {
 	.minor		= MICROCODE_MINOR,
 	.name		= "microcode",
+	.devfs_name	= "cpu/microcode",
 	.fops		= &microcode_fops,
 };
 
diff -urN linux-2.6.19.old/arch/ppc/4xx_io/serial_sicc.c linux-2.6.19.dev/arch/ppc/4xx_io/serial_sicc.c
--- linux-2.6.19.old/arch/ppc/4xx_io/serial_sicc.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/ppc/4xx_io/serial_sicc.c	2006-12-14 03:12:59.000000000 +0100
@@ -1757,7 +1757,7 @@
     siccnormal_driver->subtype = SERIAL_TYPE_NORMAL;
     siccnormal_driver->init_termios = tty_std_termios;
     siccnormal_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
-    siccnormal_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+    siccnormal_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
     tty_set_operations(siccnormal_driver, &sicc_ops);
 
     if (tty_register_driver(siccnormal_driver))
diff -urN linux-2.6.19.old/arch/sparc64/solaris/socksys.c linux-2.6.19.dev/arch/sparc64/solaris/socksys.c
--- linux-2.6.19.old/arch/sparc64/solaris/socksys.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/sparc64/solaris/socksys.c	2006-12-14 03:12:59.000000000 +0100
@@ -26,6 +26,7 @@
 #include <linux/slab.h>
 #include <linux/syscalls.h>
 #include <linux/in.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include <net/sock.h>
 
@@ -188,6 +189,8 @@
 		return ret;
 	}
 
+	devfs_mk_cdev(MKDEV(30, 0), S_IFCHR|S_IRUSR|S_IWUSR, "socksys");
+
 	file = fcheck(ret);
 	/* N.B. Is this valid? Suppose the f_ops are in a module ... */
 	socksys_file_ops = *file->f_op;
@@ -202,4 +205,5 @@
 {
 	if (unregister_chrdev(30, "socksys"))
 		printk ("Couldn't unregister socksys character device\n");
+	devfs_remove ("socksys");
 }
diff -urN linux-2.6.19.old/arch/um/drivers/line.c linux-2.6.19.dev/arch/um/drivers/line.c
--- linux-2.6.19.old/arch/um/drivers/line.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/um/drivers/line.c	2006-12-14 03:12:59.000000000 +0100
@@ -8,6 +8,7 @@
 #include "linux/list.h"
 #include "linux/kd.h"
 #include "linux/interrupt.h"
+#include "linux/devfs_fs_kernel.h"
 #include "asm/uaccess.h"
 #include "chan_kern.h"
 #include "irq_user.h"
@@ -653,6 +654,7 @@
 
 	driver->driver_name = line_driver->name;
 	driver->name = line_driver->device_name;
+	driver->devfs_name = line_driver->devfs_name;
 	driver->major = line_driver->major;
 	driver->minor_start = line_driver->minor_start;
 	driver->type = line_driver->type;
diff -urN linux-2.6.19.old/arch/um/drivers/ssl.c linux-2.6.19.dev/arch/um/drivers/ssl.c
--- linux-2.6.19.old/arch/um/drivers/ssl.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/um/drivers/ssl.c	2006-12-14 03:12:59.000000000 +0100
@@ -53,6 +53,7 @@
 static struct line_driver driver = {
 	.name 			= "UML serial line",
 	.device_name 		= "ttyS",
+	.devfs_name 		= "tts/",
 	.major 			= TTY_MAJOR,
 	.minor_start 		= 64,
 	.type 		 	= TTY_DRIVER_TYPE_SERIAL,
diff -urN linux-2.6.19.old/arch/um/drivers/stdio_console.c linux-2.6.19.dev/arch/um/drivers/stdio_console.c
--- linux-2.6.19.old/arch/um/drivers/stdio_console.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/um/drivers/stdio_console.c	2006-12-14 03:12:59.000000000 +0100
@@ -59,6 +59,7 @@
 static struct line_driver driver = {
 	.name 			= "UML console",
 	.device_name 		= "tty",
+	.devfs_name 		= "vc/",
 	.major 			= TTY_MAJOR,
 	.minor_start 		= 0,
 	.type 		 	= TTY_DRIVER_TYPE_CONSOLE,
diff -urN linux-2.6.19.old/arch/um/drivers/ubd_kern.c linux-2.6.19.dev/arch/um/drivers/ubd_kern.c
--- linux-2.6.19.old/arch/um/drivers/ubd_kern.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/um/drivers/ubd_kern.c	2006-12-14 03:12:59.000000000 +0100
@@ -24,6 +24,7 @@
 #include "linux/blkdev.h"
 #include "linux/hdreg.h"
 #include "linux/init.h"
+#include "linux/devfs_fs_kernel.h"
 #include "linux/cdrom.h"
 #include "linux/proc_fs.h"
 #include "linux/ctype.h"
@@ -645,10 +646,14 @@
 	disk->first_minor = unit << UBD_SHIFT;
 	disk->fops = &ubd_blops;
 	set_capacity(disk, size / 512);
-	if(major == MAJOR_NR)
+	if(major == MAJOR_NR){
 		sprintf(disk->disk_name, "ubd%c", 'a' + unit);
-	else
+		sprintf(disk->devfs_name, "ubd/disc%d", unit);
+	}
+	else {
 		sprintf(disk->disk_name, "ubd_fake%d", unit);
+		sprintf(disk->devfs_name, "ubd_fake/disc%d", unit);
+	}
 
 	/* sysfs register (not for ide fake devices) */
 	if (major == MAJOR_NR) {
@@ -853,6 +864,7 @@
 {
         int i;
 
+	devfs_mk_dir("ubd");
 	if (register_blkdev(MAJOR_NR, "ubd"))
 		return -1;
 
@@ -866,6 +878,7 @@
 		char name[sizeof("ubd_nnn\0")];
 
 		snprintf(name, sizeof(name), "ubd_%d", fake_major);
+		devfs_mk_dir(name);
 		if (register_blkdev(fake_major, "ubd"))
 			return -1;
 	}
diff -urN linux-2.6.19.old/arch/um/include/line.h linux-2.6.19.dev/arch/um/include/line.h
--- linux-2.6.19.old/arch/um/include/line.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/arch/um/include/line.h	2006-12-14 03:12:59.000000000 +0100
@@ -17,6 +17,7 @@
 struct line_driver {
 	char *name;
 	char *device_name;
+	char *devfs_name;
 	short major;
 	short minor_start;
 	short type;
diff -urN linux-2.6.19.old/Documentation/Changes linux-2.6.19.dev/Documentation/Changes
--- linux-2.6.19.old/Documentation/Changes	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/Documentation/Changes	2006-12-14 03:12:59.000000000 +0100
@@ -180,8 +180,8 @@
 --------------------
 
 A driver has been added to allow updating of Intel IA32 microcode,
-accessible as a normal (misc) character device.  If you are not using
-udev you may need to:
+accessible as both a devfs regular file and as a normal (misc)
+character device.  If you are not using devfs you may need to:
 
 mkdir /dev/cpu
 mknod /dev/cpu/microcode c 10 184
@@ -200,9 +200,7 @@
 udev
 ----
 udev is a userspace application for populating /dev dynamically with
-only entries for devices actually present.  udev replaces the basic
-functionality of devfs, while allowing persistant device naming for
-devices.
+only entries for devices actually present. udev replaces devfs.
 
 FUSE
 ----
@@ -232,13 +230,18 @@
 enable it to operate over diverse media layers.  If you use PPP,
 upgrade pppd to at least 2.4.0.
 
-If you are not using udev, you must have the device file /dev/ppp
+If you are not using devfs, you must have the device file /dev/ppp
 which can be made by:
 
 mknod /dev/ppp c 108 0
 
 as root.
 
+If you use devfsd and build ppp support as modules, you will need
+the following in your /etc/devfsd.conf file:
+
+LOOKUP	PPP	MODLOAD
+
 Isdn4k-utils
 ------------
 
diff -urN linux-2.6.19.old/Documentation/DocBook/kernel-api.tmpl linux-2.6.19.dev/Documentation/DocBook/kernel-api.tmpl
--- linux-2.6.19.old/Documentation/DocBook/kernel-api.tmpl	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/Documentation/DocBook/kernel-api.tmpl	2006-12-14 03:12:59.000000000 +0100
@@ -84,6 +84,9 @@
 !Ekernel/rcupdate.c
      </sect1>
 
+  <chapter id="devfs">
+     <title>The Device File System</title>
+!Efs/devfs/base.c
   </chapter>
 
   <chapter id="adt">
diff -urN linux-2.6.19.old/Documentation/filesystems/devfs/boot-options linux-2.6.19.dev/Documentation/filesystems/devfs/boot-options
--- linux-2.6.19.old/Documentation/filesystems/devfs/boot-options	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/Documentation/filesystems/devfs/boot-options	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,65 @@
+/* -*- auto-fill -*-                                                         */
+
+		Device File System (devfs) Boot Options
+
+		Richard Gooch <rgooch@atnf.csiro.au>
+
+			      18-AUG-2001
+
+
+When CONFIG_DEVFS_DEBUG is enabled, you can pass several boot options
+to the kernel to debug devfs. The boot options are prefixed by
+"devfs=", and are separated by commas. Spaces are not allowed. The
+syntax looks like this:
+
+devfs=<option1>,<option2>,<option3>
+
+and so on. For example, if you wanted to turn on debugging for module
+load requests and device registration, you would do:
+
+devfs=dmod,dreg
+
+You may prefix "no" to any option. This will invert the option.
+
+
+Debugging Options
+=================
+
+These requires CONFIG_DEVFS_DEBUG to be enabled.
+Note that all debugging options have 'd' as the first character. By
+default all options are off. All debugging output is sent to the
+kernel logs. The debugging options do not take effect until the devfs
+version message appears (just prior to the root filesystem being
+mounted).
+
+These are the options:
+
+dmod		print module load requests to <request_module>
+
+dreg		print device register requests to <devfs_register>
+
+dunreg		print device unregister requests to <devfs_unregister>
+
+dchange		print device change requests to <devfs_set_flags>
+
+dilookup	print inode lookup requests
+
+diget		print VFS inode allocations
+
+diunlink	print inode unlinks
+
+dichange	print inode changes
+
+dimknod		print calls to mknod(2)
+
+dall		some debugging turned on
+
+
+Other Options
+=============
+
+These control the default behaviour of devfs. The options are:
+
+mount		mount devfs onto /dev at boot time
+
+only		disable non-devfs device nodes for devfs-capable drivers
diff -urN linux-2.6.19.old/Documentation/filesystems/devfs/ChangeLog linux-2.6.19.dev/Documentation/filesystems/devfs/ChangeLog
--- linux-2.6.19.old/Documentation/filesystems/devfs/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/Documentation/filesystems/devfs/ChangeLog	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,1977 @@
+/* -*- auto-fill -*-                                                         */
+===============================================================================
+Changes for patch v1
+
+- creation of devfs
+
+- modified miscellaneous character devices to support devfs
+===============================================================================
+Changes for patch v2
+
+- bug fix with manual inode creation
+===============================================================================
+Changes for patch v3
+
+- bugfixes
+
+- documentation improvements
+
+- created a couple of scripts (one to save&restore a devfs and the
+  other to set up compatibility symlinks)
+
+- devfs support for SCSI discs. New name format is: sd_hHcCiIlL
+===============================================================================
+Changes for patch v4
+
+- bugfix for the directory reading code
+
+- bugfix for compilation with kerneld
+
+- devfs support for generic hard discs
+
+- rationalisation of the various watchdog drivers
+===============================================================================
+Changes for patch v5
+
+- support for mounting directly from entries in the devfs (it doesn't
+  need to be mounted to do this), including the root filesystem.
+  Mounting of swap partitions also works. Hence, now if you set
+  CONFIG_DEVFS_ONLY to 'Y' then you won't be able to access your discs
+  via ordinary device nodes. Naturally, the default is 'N' so that you
+  can still use your old device nodes.  If you want to mount from devfs
+  entries, make sure you use: append = "root=/dev/sd_..." in your
+  lilo.conf. It seems LILO looks for the device number (major&minor)
+  and writes that into the kernel image :-( 
+
+- support for character memory devices (/dev/null, /dev/zero, /dev/full
+  and so on). Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+===============================================================================
+Changes for patch v6
+
+- support for subdirectories
+
+- support for symbolic links (created by devfs_mk_symlink(), no
+  support yet for creation via symlink(2))
+
+- SCSI disc naming now cast in stone, with the format:
+  /dev/sd/c0b1t2u3	controller=0, bus=1, ID=2, LUN=3, whole disc
+  /dev/sd/c0b1t2u3p4	controller=0, bus=1, ID=2, LUN=3, 4th partition
+
+- loop devices now appear in devfs
+
+- tty devices, console, serial ports, etc. now appear in devfs
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- bugs with mounting devfs-only devices now fixed
+===============================================================================
+Changes for patch v7
+
+- SCSI CD-ROMS, tapes and generic devices now appear in devfs
+===============================================================================
+Changes for patch v8
+
+- bugfix with no-rewind SCSI tapes
+
+- RAMDISCs now appear in devfs
+
+- better cleaning up of devfs entries created by various modules
+
+- interface change to <devfs_register>
+===============================================================================
+Changes for patch v9
+
+- the v8 patch was corrupted somehow, which would affect the patch for
+  linux/fs/filesystems.c
+  I've also fixed the v8 patch file on the WWW
+
+- MetaDevices (/dev/md*) should now appear in devfs
+===============================================================================
+Changes for patch v10
+
+- bugfix in meta device support for devfs
+
+- created this ChangeLog file
+
+- added devfs support to the floppy driver
+
+- added support for creating sockets in a devfs
+===============================================================================
+Changes for patch v11
+
+- added DEVFS_FL_HIDE_UNREG flag
+
+- incorporated better patch for ttyname() in libc 5.4.43 from H.J. Lu.
+
+- interface change to <devfs_mk_symlink>
+
+- support for creating symlinks with symlink(2)
+
+- parallel port printer (/dev/lp*) now appears in devfs
+===============================================================================
+Changes for patch v12
+
+- added inode check to <devfs_fill_file> function
+
+- improved devfs support when mounting from devfs
+
+- added call to <<release>> operation when removing swap areas on
+  devfs devices
+
+- increased NR_SUPER to 128 to support large numbers of devfs mounts
+  (for chroot(2) gaols)
+
+- fixed bug in SCSI disc support: was generating incorrect minors if
+  SCSI ID's did not start at 0 and increase by 1
+
+- support symlink traversal when mounting root
+===============================================================================
+Changes for patch v13
+
+- added devfs support to soundcard driver
+  Thanks to Eric Dumas <dumas@linux.eu.org> and
+  C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- added devfs support to the joystick driver
+
+- loop driver now has it's own subdirectory "/dev/loop/"
+
+- created <devfs_get_flags> and <devfs_set_flags> functions
+
+- fix problem with SCSI disc compatibility names (sd{a,b,c,d,e,f})
+  which assumes ID's start at 0 and increase by 1. Also only create
+  devfs entries for SCSI disc partitions which actually exist
+  Show new names in partition check
+  Thanks to Jakub Jelinek <jj@sunsite.ms.mff.cuni.cz>
+===============================================================================
+Changes for patch v14
+
+- bug fix in floppy driver: would not compile without
+  CONFIG_DEVFS_FS='Y'
+  Thanks to Jurgen Botz <jbotz@nova.botz.org>
+
+- bug fix in loop driver
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- do not create devfs entries for printers not configured
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- do not create devfs entries for serial ports not present
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- ensure <tty_register_devfs> is exported from tty_io.c
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- allow unregistering of devfs symlink entries
+
+- fixed bug in SCSI disc naming introduced in last patch version
+===============================================================================
+Changes for patch v15
+
+- ported to kernel 2.1.81
+===============================================================================
+Changes for patch v16
+
+- created <devfs_set_symlink_destination> function
+
+- moved DEVFS_SUPER_MAGIC into header file
+
+- added DEVFS_FL_HIDE flag
+
+- created <devfs_get_maj_min>
+
+- created <devfs_get_handle_from_inode>
+
+- fixed bugs in searching by major&minor
+
+- changed interface to <devfs_unregister>, <devfs_fill_file> and
+  <devfs_find_handle>
+
+- fixed inode times when symlink created with symlink(2)
+
+- change tty driver to do auto-creation of devfs entries
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- fixed bug in genhd.c: whole disc (non-SCSI) was not registered to
+  devfs
+
+- updated libc 5.4.43 patch for ttyname()
+===============================================================================
+Changes for patch v17
+
+- added CONFIG_DEVFS_TTY_COMPAT
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- bugfix in devfs support for drivers/char/lp.c
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- clean up serial driver so that PCMCIA devices unregister correctly
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- fixed bug in genhd.c: whole disc (non-SCSI) was not registered to
+  devfs [was missing in patch v16]
+
+- updated libc 5.4.43 patch for ttyname() [was missing in patch v16]
+
+- all SCSI devices now registered in /dev/sg
+
+- support removal of devfs entries via unlink(2)
+===============================================================================
+Changes for patch v18
+
+- added floppy/?u720 floppy entry
+
+- fixed kerneld support for entries in devfs subdirectories
+
+- incorporated latest patch for ttyname() in libc 5.4.43 from H.J. Lu.
+===============================================================================
+Changes for patch v19
+
+- bug fix when looking up unregistered entries: kerneld was not called
+
+- fixes for kernel 2.1.86 (now requires 2.1.86)
+===============================================================================
+Changes for patch v20
+
+- only create available floppy entries
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+
+- new IDE naming scheme following SCSI format (i.e. /dev/id/c0b0t0u0p1
+  instead of /dev/hda1)
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+
+- new XT disc naming scheme following SCSI format (i.e. /dev/xd/c0t0p1
+  instead of /dev/xda1)
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+
+- new non-standard CD-ROM names (i.e. /dev/sbp/c#t#)
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+
+- allow symlink traversal when mounting the root filesystem
+
+- Create entries for MD devices at MD init
+  Thanks to Christophe Leroy <christophe.leroy5@capway.com>
+===============================================================================
+Changes for patch v21
+
+- ported to kernel 2.1.91
+===============================================================================
+Changes for patch v22
+
+- SCSI host number patch ("scsihosts=" kernel option)
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+===============================================================================
+Changes for patch v23
+
+- Fixed persistence bug with device numbers for manually created
+  device files
+
+- Fixed problem with recreating symlinks with different content
+
+- Added CONFIG_DEVFS_MOUNT (mount devfs on /dev at boot time)
+===============================================================================
+Changes for patch v24
+
+- Switched from CONFIG_KERNELD to CONFIG_KMOD: module autoloading
+  should now work again
+
+- Hide entries which are manually unlinked
+
+- Always invalidate devfs dentry cache when registering entries
+
+- Support removal of devfs directories via rmdir(2)
+
+- Ensure directories created by <devfs_mk_dir> are visible
+
+- Default no access for "other" for floppy device
+===============================================================================
+Changes for patch v25
+
+- Updates to CREDITS file and minor IDE numbering change
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+
+- Invalidate devfs dentry cache when making directories
+
+- Invalidate devfs dentry cache when removing entries
+
+- More informative message if root FS mount fails when devfs
+  configured
+
+- Fixed persistence bug with fifos
+===============================================================================
+Changes for patch v26
+
+- ported to kernel 2.1.97
+
+- Changed serial directory from "/dev/serial" to "/dev/tts" and
+  "/dev/consoles" to "/dev/vc" to be more friendly to new procps
+===============================================================================
+Changes for patch v27
+
+- Added support for IDE4 and IDE5
+  Thanks to Andrzej Krzysztofowicz <ankry@green.mif.pg.gda.pl>
+
+- Documented "scsihosts=" boot parameter
+
+- Print process command when debugging kerneld/kmod
+
+- Added debugging for register/unregister/change operations
+
+- Added "devfs=" boot options
+
+- Hide unregistered entries by default
+===============================================================================
+Changes for patch v28
+
+- No longer lock/unlock superblock in <devfs_put_super> (cope with
+  recent VFS interface change)
+
+- Do not automatically change ownership/protection of /dev/tty
+
+- Drop negative dentries when they are released
+
+- Manage dcache more efficiently
+===============================================================================
+Changes for patch v29
+
+- Added DEVFS_FL_AUTO_DEVNUM flag
+===============================================================================
+Changes for patch v30
+
+- No longer set unnecessary methods
+
+- Ported to kernel 2.1.99-pre3
+===============================================================================
+Changes for patch v31
+
+- Added PID display to <call_kerneld> debugging message
+
+- Added "diread" and "diwrite" options
+
+- Ported to kernel 2.1.102
+
+- Fixed persistence problem with permissions
+===============================================================================
+Changes for patch v32
+
+- Fixed devfs support in drivers/block/md.c
+===============================================================================
+Changes for patch v33
+
+- Support legacy device nodes
+
+- Fixed bug where recreated inodes were hidden
+
+- New IDE naming scheme: everything is under /dev/ide
+===============================================================================
+Changes for patch v34
+
+- Improved debugging in <get_vfs_inode>
+
+- Prevent duplicate calls to <devfs_mk_dir> in SCSI layer
+
+- No longer free old dentries in <devfs_mk_dir>
+
+- Free all dentries for a given entry when deleting inodes
+===============================================================================
+Changes for patch v35
+
+- Ported to kernel 2.1.105 (sound driver changes)
+===============================================================================
+Changes for patch v36
+
+- Fixed sound driver port
+===============================================================================
+Changes for patch v37
+
+- Minor documentation tweaks
+===============================================================================
+Changes for patch v38
+
+- More documentation tweaks
+
+- Fix for sound driver port
+
+- Removed ttyname-patch (grab libc 5.4.44 instead)
+
+- Ported to kernel 2.1.107-pre2 (loop driver fix)
+===============================================================================
+Changes for patch v39
+
+- Ported to kernel 2.1.107 (hd.c hunk broke due to spelling "fixes"). Sigh
+
+- Removed many #ifdef's, replaced with trickery in include/devfs_fs.h
+===============================================================================
+Changes for patch v40
+
+- Fix for sound driver port
+
+- Limit auto-device numbering to majors 128 to 239
+===============================================================================
+Changes for patch v41
+
+- Fixed inode times persistence problem
+===============================================================================
+Changes for patch v42
+
+- Ported to kernel 2.1.108 (drivers/scsi/hosts.c hunk broke)
+===============================================================================
+Changes for patch v43
+
+- Fixed spelling in <devfs_readlink> debug
+
+- Fixed bug in <devfs_setup> parsing "dilookup"
+
+- More #ifdef's removed
+
+- Supported Sparc keyboard (/dev/kbd)
+
+- Supported DSP56001 digital signal processor (/dev/dsp56k)
+
+- Supported Apple Desktop Bus (/dev/adb)
+
+- Supported Coda network file system (/dev/cfs*)
+===============================================================================
+Changes for patch v44
+
+- Fixed devfs inode leak when manually recreating inodes
+
+- Fixed permission persistence problem when recreating inodes
+===============================================================================
+Changes for patch v45
+
+- Ported to kernel 2.1.110
+===============================================================================
+Changes for patch v46
+
+- Ported to kernel 2.1.112-pre1
+
+- Removed harmless "unused variable" compiler warning
+
+- Fixed modes for manually recreated device nodes
+===============================================================================
+Changes for patch v47
+
+- Added NULL devfs inode warning in <devfs_read_inode>
+
+- Force all inode nlink values to 1
+===============================================================================
+Changes for patch v48
+
+- Added "dimknod" option
+
+- Set inode nlink to 0 when freeing dentries
+
+- Added support for virtual console capture devices (/dev/vcs*)
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Fixed modes for manually recreated symlinks
+===============================================================================
+Changes for patch v49
+
+- Ported to kernel 2.1.113
+===============================================================================
+Changes for patch v50
+
+- Fixed bugs in recreated directories and symlinks
+===============================================================================
+Changes for patch v51
+
+- Improved robustness of rc.devfs script
+  Thanks to Roderich Schupp <rsch@experteam.de>
+
+- Fixed bugs in recreated device nodes
+
+- Fixed bug in currently unused <devfs_get_handle_from_inode>
+
+- Defined new <devfs_handle_t> type
+
+- Improved debugging when getting entries
+
+- Fixed bug where directories could be emptied
+
+- Ported to kernel 2.1.115
+===============================================================================
+Changes for patch v52
+
+- Replaced dummy .epoch inode with .devfsd character device
+
+- Modified rc.devfs to take account of above change
+
+- Removed spurious driver warning messages when CONFIG_DEVFS_FS=n
+
+- Implemented devfsd protocol revision 0
+===============================================================================
+Changes for patch v53
+
+- Ported to kernel 2.1.116 (kmod change broke hunk)
+
+- Updated Documentation/Configure.help
+
+- Test and tty pattern patch for rc.devfs script
+  Thanks to Roderich Schupp <rsch@experteam.de>
+
+- Added soothing message to warning in <devfs_d_iput>
+===============================================================================
+Changes for patch v54
+
+- Ported to kernel 2.1.117
+
+- Fixed default permissions in sound driver
+
+- Added support for frame buffer devices (/dev/fb*)
+===============================================================================
+Changes for patch v55
+
+- Ported to kernel 2.1.119
+
+- Use GCC extensions for structure initialisations
+
+- Implemented async open notification
+
+- Incremented devfsd protocol revision to 1
+===============================================================================
+Changes for patch v56
+
+- Ported to kernel 2.1.120-pre3
+
+- Moved async open notification to end of <devfs_open>
+===============================================================================
+Changes for patch v57
+
+- Ported to kernel 2.1.121
+
+- Prepended "/dev/" to module load request
+
+- Renamed <call_kerneld> to <call_kmod>
+
+- Created sample modules.conf file
+===============================================================================
+Changes for patch v58
+
+- Fixed typo "AYSNC" -> "ASYNC"
+===============================================================================
+Changes for patch v59
+
+- Added open flag for files
+===============================================================================
+Changes for patch v60
+
+- Ported to kernel 2.1.123-pre2
+===============================================================================
+Changes for patch v61
+
+- Set i_blocks=0 and i_blksize=1024 in <devfs_read_inode>
+===============================================================================
+Changes for patch v62
+
+- Ported to kernel 2.1.123
+===============================================================================
+Changes for patch v63
+
+- Ported to kernel 2.1.124-pre2
+===============================================================================
+Changes for patch v64
+
+- Fixed Unix98 pty support
+
+- Increased buffer size in <get_partition_list> to avoid crash and
+  burn
+===============================================================================
+Changes for patch v65
+
+- More Unix98 pty support fixes
+
+- Added test for empty <<name>> in <devfs_find_handle>
+
+- Renamed <generate_path> to <devfs_generate_path> and published
+
+- Created /dev/root symlink
+  Thanks to Roderich Schupp <rsch@ExperTeam.de>
+  with further modifications by me
+===============================================================================
+Changes for patch v66
+
+- Yet more Unix98 pty support fixes (now tested)
+
+- Created <devfs_get_fops>
+
+- Support media change checks when CONFIG_DEVFS_ONLY=y
+
+- Abolished Unix98-style PTY names for old PTY devices
+===============================================================================
+Changes for patch v67
+
+- Added inline declaration for dummy <devfs_generate_path>
+
+- Removed spurious "unable to register... in devfs" messages when
+  CONFIG_DEVFS_FS=n
+
+- Fixed misc. devices when CONFIG_DEVFS_FS=n
+
+- Limit auto-device numbering to majors 144 to 239
+===============================================================================
+Changes for patch v68
+
+- Hide unopened virtual consoles from directory listings
+
+- Added support for video capture devices
+
+- Ported to kernel 2.1.125
+===============================================================================
+Changes for patch v69
+
+- Fix for CONFIG_VT=n
+===============================================================================
+Changes for patch v70
+
+- Added support for non-OSS/Free sound cards
+===============================================================================
+Changes for patch v71
+
+- Ported to kernel 2.1.126-pre2
+===============================================================================
+Changes for patch v72
+
+- #ifdef's for CONFIG_DEVFS_DISABLE_OLD_NAMES removed
+===============================================================================
+Changes for patch v73
+
+- CONFIG_DEVFS_DISABLE_OLD_NAMES replaced with "nocompat" boot option
+
+- CONFIG_DEVFS_BOOT_OPTIONS removed: boot options always available
+===============================================================================
+Changes for patch v74
+
+- Removed CONFIG_DEVFS_MOUNT and "mount" boot option and replaced with
+  "nomount" boot option
+
+- Documentation updates
+
+- Updated sample modules.conf
+===============================================================================
+Changes for patch v75
+
+- Updated sample modules.conf
+
+- Remount devfs after initrd finishes
+
+- Ported to kernel 2.1.127
+
+- Added support for ISDN
+  Thanks to Christophe Leroy <christophe.leroy5@capway.com>
+===============================================================================
+Changes for patch v76
+
+- Updated an email address in ChangeLog
+
+- CONFIG_DEVFS_ONLY replaced with "only" boot option
+===============================================================================
+Changes for patch v77
+
+- Added DEVFS_FL_REMOVABLE flag
+
+- Check for disc change when listing directories with removable media
+  devices
+
+- Use DEVFS_FL_REMOVABLE in sd.c
+
+- Ported to kernel 2.1.128
+===============================================================================
+Changes for patch v78
+
+- Only call <scan_dir_for_removable> on first call to <devfs_readdir>
+
+- Ported to kernel 2.1.129-pre5
+
+- ISDN support improvements
+  Thanks to Christophe Leroy <christophe.leroy5@capway.com>
+===============================================================================
+Changes for patch v79
+
+- Ported to kernel 2.1.130
+
+- Renamed miscdevice "apm" to "apm_bios" to be consistent with
+  devices.txt
+===============================================================================
+Changes for patch v80
+
+- Ported to kernel 2.1.131
+
+- Updated <devfs_rmdir> for VFS change in 2.1.131
+===============================================================================
+Changes for patch v81
+
+- Fixed permissions on /dev/ptmx
+===============================================================================
+Changes for patch v82
+
+- Ported to kernel 2.1.132-pre4
+
+- Changed initial permissions on /dev/pts/*
+
+- Created <devfs_mk_compat>
+
+- Added "symlinks" boot option
+
+- Changed devfs_register_blkdev() back to register_blkdev() for IDE
+
+- Check for partitions on removable media in <devfs_lookup>
+===============================================================================
+Changes for patch v83
+
+- Fixed support for ramdisc when using string-based root FS name
+
+- Ported to kernel 2.2.0-pre1
+===============================================================================
+Changes for patch v84
+
+- Ported to kernel 2.2.0-pre7
+===============================================================================
+Changes for patch v85
+
+- Compile fixes for driver/sound/sound_common.c (non-module) and
+  drivers/isdn/isdn_common.c
+  Thanks to Christophe Leroy <christophe.leroy5@capway.com>
+
+- Added support for registering regular files
+
+- Created <devfs_set_file_size>
+
+- Added /dev/cpu/mtrr as an alternative interface to /proc/mtrr
+
+- Update devfs inodes from entries if not changed through FS
+===============================================================================
+Changes for patch v86
+
+- Ported to kernel 2.2.0-pre9
+===============================================================================
+Changes for patch v87
+
+- Fixed bug when mounting non-devfs devices in a devfs
+===============================================================================
+Changes for patch v88
+
+- Fixed <devfs_fill_file> to only initialise temporary inodes
+
+- Trap for NULL fops in <devfs_register>
+
+- Return -ENODEV in <devfs_fill_file> for non-driver inodes
+
+- Fixed bug when unswapping non-devfs devices in a devfs
+===============================================================================
+Changes for patch v89
+
+- Switched to C data types in include/linux/devfs_fs.h
+
+- Switched from PATH_MAX to DEVFS_PATHLEN
+
+- Updated Documentation/filesystems/devfs/modules.conf to take account
+  of reverse scanning (!) by modprobe
+
+- Ported to kernel 2.2.0
+===============================================================================
+Changes for patch v90
+
+- CONFIG_DEVFS_DISABLE_OLD_TTY_NAMES replaced with "nottycompat" boot
+  option
+
+- CONFIG_DEVFS_TTY_COMPAT removed: existing "symlinks" boot option now
+  controls this. This means you must have libc 5.4.44 or later, or a
+  recent version of libc 6 if you use the "symlinks" option
+===============================================================================
+Changes for patch v91
+
+- Switch from <devfs_mk_symlink> to <devfs_mk_compat> in
+  drivers/char/vc_screen.c to fix problems with Midnight Commander
+===============================================================================
+Changes for patch v92
+
+- Ported to kernel 2.2.2-pre5
+===============================================================================
+Changes for patch v93
+
+- Modified <sd_name> in drivers/scsi/sd.c to cope with devices that
+  don't exist (which happens with new RAID autostart code printk()s)
+===============================================================================
+Changes for patch v94
+
+- Fixed bug in joystick driver: only first joystick was registered
+===============================================================================
+Changes for patch v95
+
+- Fixed another bug in joystick driver
+
+- Fixed <devfsd_read> to not overrun event buffer
+===============================================================================
+Changes for patch v96
+
+- Ported to kernel 2.2.5-2
+
+- Created <devfs_auto_unregister>
+
+- Fixed bugs: compatibility entries were not unregistered for:
+    loop driver
+    floppy driver
+    RAMDISC driver
+    IDE tape driver
+    SCSI CD-ROM driver
+    SCSI HDD driver
+===============================================================================
+Changes for patch v97
+
+- Fixed bugs: compatibility entries were not unregistered for:
+    ALSA sound driver
+    partitions in generic disc driver
+
+- Don't return unregistred entries in <devfs_find_handle>
+
+- Panic in <devfs_unregister> if entry unregistered
+
+- Don't panic in <devfs_auto_unregister> for duplicates
+===============================================================================
+Changes for patch v98
+
+- Don't unregister already unregistered entries in <unregister>
+
+- Register entry in <sd_detect>
+
+- Unregister entry in <sd_detach>
+
+- Changed to <devfs_*register_chrdev> in drivers/char/tty_io.c
+
+- Ported to kernel 2.2.7
+===============================================================================
+Changes for patch v99
+
+- Ported to kernel 2.2.8
+
+- Fixed bug in drivers/scsi/sd.c when >16 SCSI discs
+
+- Disable warning messages when unable to read partition table for
+  removable media
+===============================================================================
+Changes for patch v100
+
+- Ported to kernel 2.3.1-pre5
+
+- Added "oops-on-panic" boot option
+
+- Improved debugging in <devfs_register> and <devfs_unregister>
+
+- Register entry in <sr_detect>
+
+- Unregister entry in <sr_detach>
+
+- Register entry in <sg_detect>
+
+- Unregister entry in <sg_detach>
+
+- Added support for ALSA drivers
+===============================================================================
+Changes for patch v101
+
+- Ported to kernel 2.3.2
+===============================================================================
+Changes for patch v102
+
+- Update serial driver to register PCMCIA entries
+  Thanks to Roch-Alexandre Nomine-Beguin <roch@samarkand.infini.fr>
+
+- Updated an email address in ChangeLog
+
+- Hide virtual console capture entries from directory listings when
+  corresponding console device is not open
+===============================================================================
+Changes for patch v103
+
+- Ported to kernel 2.3.3
+===============================================================================
+Changes for patch v104
+
+- Added documentation for some functions
+
+- Added "doc" target to fs/devfs/Makefile
+
+- Added "v4l" directory for video4linux devices
+
+- Replaced call to <devfs_unregister> in <sd_detach> with call to
+  <devfs_register_partitions>
+
+- Moved registration for sr and sg drivers from detect() to attach()
+  methods
+
+- Register entries in <st_attach> and unregister in <st_detach>
+
+- Work around IDE driver treating CD-ROM as gendisk
+
+- Use <sed> instead of <tr> in rc.devfs
+
+- Updated ToDo list
+
+- Removed "oops-on-panic" boot option: now always Oops
+===============================================================================
+Changes for patch v105
+
+- Unregister SCSI host from <scsi_host_no_list> in <scsi_unregister>
+  Thanks to Zoltán Böszörményi <zboszor@mail.externet.hu>
+
+- Don't save /dev/log in rc.devfs
+
+- Ported to kernel 2.3.4-pre1
+===============================================================================
+Changes for patch v106
+
+- Fixed silly typo in drivers/scsi/st.c
+
+- Improved debugging in <devfs_register>
+===============================================================================
+Changes for patch v107
+
+- Added "diunlink" and "nokmod" boot options
+
+- Removed superfluous warning message in <devfs_d_iput>
+===============================================================================
+Changes for patch v108
+
+- Remove entries when unloading sound module
+===============================================================================
+Changes for patch v109
+
+- Ported to kernel 2.3.6-pre2
+===============================================================================
+Changes for patch v110
+
+- Took account of change to <d_alloc_root>
+===============================================================================
+Changes for patch v111
+
+- Created separate event queue for each mounted devfs
+
+- Removed <devfs_invalidate_dcache>
+
+- Created new ioctl()s for devfsd
+
+- Incremented devfsd protocol revision to 3
+
+- Fixed bug when re-creating directories: contents were lost
+
+- Block access to inodes until devfsd updates permissions
+===============================================================================
+Changes for patch v112
+
+- Modified patch so it applies against 2.3.5 and 2.3.6
+
+- Updated an email address in ChangeLog
+
+- Do not automatically change ownership/protection of /dev/tty<n>
+
+- Updated sample modules.conf
+
+- Switched to sending process uid/gid to devfsd
+
+- Renamed <call_kmod> to <try_modload>
+
+- Added DEVFSD_NOTIFY_LOOKUP event
+
+- Added DEVFSD_NOTIFY_CHANGE event
+
+- Added DEVFSD_NOTIFY_CREATE event
+
+- Incremented devfsd protocol revision to 4
+
+- Moved kernel-specific stuff to include/linux/devfs_fs_kernel.h
+===============================================================================
+Changes for patch v113
+
+- Ported to kernel 2.3.9
+
+- Restricted permissions on some block devices
+===============================================================================
+Changes for patch v114
+
+- Added support for /dev/netlink
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Return EISDIR rather than EINVAL for read(2) on directories
+
+- Ported to kernel 2.3.10
+===============================================================================
+Changes for patch v115
+
+- Added support for all remaining character devices
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Cleaned up netlink support
+===============================================================================
+Changes for patch v116
+
+- Added support for /dev/parport%d
+  Thanks to Tim Waugh <tim@cyberelk.demon.co.uk>
+
+- Fixed parallel port ATAPI tape driver
+
+- Fixed Atari SLM laser printer driver
+===============================================================================
+Changes for patch v117
+
+- Added support for COSA card
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Fixed drivers/char/ppdev.c: missing #include <linux/init.h>
+
+- Fixed drivers/char/ftape/zftape/zftape-init.c
+  Thanks to Vladimir Popov <mashgrad@usa.net>
+===============================================================================
+Changes for patch v118
+
+- Ported to kernel 2.3.15-pre3
+
+- Fixed bug in loop driver
+
+- Unregister /dev/lp%d entries in drivers/char/lp.c
+  Thanks to Maciej W. Rozycki <macro@ds2.pg.gda.pl>
+===============================================================================
+Changes for patch v119
+
+- Ported to kernel 2.3.16
+===============================================================================
+Changes for patch v120
+
+- Fixed bug in drivers/scsi/scsi.c
+
+- Added /dev/ppp
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Ported to kernel 2.3.17
+===============================================================================
+Changes for patch v121
+
+- Fixed bug in drivers/block/loop.c
+
+- Ported to kernel 2.3.18
+===============================================================================
+Changes for patch v122
+
+- Ported to kernel 2.3.19
+===============================================================================
+Changes for patch v123
+
+- Ported to kernel 2.3.20
+===============================================================================
+Changes for patch v124
+
+- Ported to kernel 2.3.21
+===============================================================================
+Changes for patch v125
+
+- Created <devfs_get_info>, <devfs_set_info>,
+  <devfs_get_first_child> and <devfs_get_next_sibling>
+  Added <<dir>> parameter to <devfs_register>, <devfs_mk_compat>,
+  <devfs_mk_dir> and <devfs_find_handle>
+  Work sponsored by SGI
+
+- Fixed apparent bug in COSA driver
+
+- Re-instated "scsihosts=" boot option
+===============================================================================
+Changes for patch v126
+
+- Always create /dev/pts if CONFIG_UNIX98_PTYS=y
+
+- Fixed call to <devfs_mk_dir> in drivers/block/ide-disk.c
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Allow multiple unregistrations
+
+- Created /dev/scsi hierarchy
+  Work sponsored by SGI
+===============================================================================
+Changes for patch v127
+
+Work sponsored by SGI
+
+- No longer disable devpts if devfs enabled (caveat emptor)
+
+- Added flags array to struct gendisk and removed code from
+  drivers/scsi/sd.c
+
+- Created /dev/discs hierarchy
+===============================================================================
+Changes for patch v128
+
+Work sponsored by SGI
+
+- Created /dev/cdroms hierarchy
+===============================================================================
+Changes for patch v129
+
+Work sponsored by SGI
+
+- Removed compatibility entries for sound devices
+
+- Removed compatibility entries for printer devices
+
+- Removed compatibility entries for video4linux devices
+
+- Removed compatibility entries for parallel port devices
+
+- Removed compatibility entries for frame buffer devices
+===============================================================================
+Changes for patch v130
+
+Work sponsored by SGI
+
+- Added major and minor number to devfsd protocol
+
+- Incremented devfsd protocol revision to 5
+
+- Removed compatibility entries for SoundBlaster CD-ROMs
+
+- Removed compatibility entries for netlink devices
+
+- Removed compatibility entries for SCSI generic devices
+
+- Removed compatibility entries for SCSI tape devices
+===============================================================================
+Changes for patch v131
+
+Work sponsored by SGI
+
+- Support info pointer for all devfs entry types
+
+- Added <<info>> parameter to <devfs_mk_dir> and <devfs_mk_symlink>
+
+- Removed /dev/st hierarchy
+
+- Removed /dev/sg hierarchy
+
+- Removed compatibility entries for loop devices
+
+- Removed compatibility entries for IDE tape devices
+
+- Removed compatibility entries for SCSI CD-ROMs
+
+- Removed /dev/sr hierarchy
+===============================================================================
+Changes for patch v132
+
+Work sponsored by SGI
+
+- Removed compatibility entries for floppy devices
+
+- Removed compatibility entries for RAMDISCs
+
+- Removed compatibility entries for meta-devices
+
+- Removed compatibility entries for SCSI discs
+
+- Created <devfs_make_root>
+
+- Removed /dev/sd hierarchy
+
+- Support "../" when searching devfs namespace
+
+- Created /dev/ide/host* hierarchy
+
+- Supported IDE hard discs in /dev/ide/host* hierarchy
+
+- Removed compatibility entries for IDE discs
+
+- Removed /dev/ide/hd hierarchy
+
+- Supported IDE CD-ROMs in /dev/ide/host* hierarchy
+
+- Removed compatibility entries for IDE CD-ROMs
+
+- Removed /dev/ide/cd hierarchy
+===============================================================================
+Changes for patch v133
+
+Work sponsored by SGI
+
+- Created <devfs_get_unregister_slave>
+
+- Fixed bug in fs/partitions/check.c when rescanning
+===============================================================================
+Changes for patch v134
+
+Work sponsored by SGI
+
+- Removed /dev/sd, /dev/sr, /dev/st and /dev/sg directories
+
+- Removed /dev/ide/hd directory
+
+- Exported <devfs_get_parent>
+
+- Created <devfs_register_tape> and /dev/tapes hierarchy
+
+- Removed /dev/ide/mt hierarchy
+
+- Removed /dev/ide/fd hierarchy
+
+- Ported to kernel 2.3.25
+===============================================================================
+Changes for patch v135
+
+Work sponsored by SGI
+
+- Removed compatibility entries for virtual console capture devices
+
+- Removed unused <devfs_set_symlink_destination>
+
+- Removed compatibility entries for serial devices
+
+- Removed compatibility entries for console devices
+
+- Do not hide entries from devfsd or children
+
+- Removed DEVFS_FL_TTY_COMPAT flag
+
+- Removed "nottycompat" boot option
+
+- Removed <devfs_mk_compat>
+===============================================================================
+Changes for patch v136
+
+Work sponsored by SGI
+
+- Moved BSD pty devices to /dev/pty
+
+- Added DEVFS_FL_WAIT flag
+===============================================================================
+Changes for patch v137
+
+Work sponsored by SGI
+
+- Really fixed bug in fs/partitions/check.c when rescanning
+
+- Support new "disc" naming scheme in <get_removable_partition>
+
+- Allow NULL fops in <devfs_register>
+
+- Removed redundant name functions in SCSI disc and IDE drivers
+===============================================================================
+Changes for patch v138
+
+Work sponsored by SGI
+
+- Fixed old bugs in drivers/block/paride/pt.c, drivers/char/tpqic02.c,
+  drivers/net/wan/cosa.c and drivers/scsi/scsi.c
+  Thanks to Sergey Kubushin <ksi@ksi-linux.com>
+
+- Fall back to major table if NULL fops given to <devfs_register>
+===============================================================================
+Changes for patch v139
+
+Work sponsored by SGI
+
+- Corrected and moved <get_blkfops> and <get_chrfops> declarations
+  from arch/alpha/kernel/osf_sys.c to include/linux/fs.h
+
+- Removed name function from struct gendisk
+
+- Updated devfs FAQ
+===============================================================================
+Changes for patch v140
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.27
+===============================================================================
+Changes for patch v141
+
+Work sponsored by SGI
+
+- Bug fix in arch/m68k/atari/joystick.c
+
+- Moved ISDN and capi devices to /dev/isdn
+===============================================================================
+Changes for patch v142
+
+Work sponsored by SGI
+
+- Bug fix in drivers/block/ide-probe.c (patch confusion)
+===============================================================================
+Changes for patch v143
+
+Work sponsored by SGI
+
+- Bug fix in drivers/block/blkpg.c:partition_name()
+===============================================================================
+Changes for patch v144
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.29
+
+- Removed calls to <devfs_register> from cdu31a, cm206, mcd and mcdx
+  CD-ROM drivers: generic driver handles this now
+
+- Moved joystick devices to /dev/joysticks
+===============================================================================
+Changes for patch v145
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.30-pre3
+
+- Register whole-disc entry even for invalid partition tables
+
+- Fixed bug in mounting root FS when initrd enabled
+
+- Fixed device entry leak with IDE CD-ROMs
+
+- Fixed compile problem with drivers/isdn/isdn_common.c
+
+- Moved COSA devices to /dev/cosa
+
+- Support fifos when unregistering
+
+- Created <devfs_register_series> and used in many drivers
+
+- Moved Coda devices to /dev/coda
+
+- Moved parallel port IDE tapes to /dev/pt
+
+- Moved parallel port IDE generic devices to /dev/pg
+===============================================================================
+Changes for patch v146
+
+Work sponsored by SGI
+
+- Removed obsolete DEVFS_FL_COMPAT and DEVFS_FL_TOLERANT flags
+
+- Fixed compile problem with fs/coda/psdev.c
+
+- Reinstate change to <devfs_register_blkdev> in
+  drivers/block/ide-probe.c now that fs/isofs/inode.c is fixed
+
+- Switched to <devfs_register_blkdev> in drivers/block/floppy.c,
+  drivers/scsi/sr.c and drivers/block/md.c
+
+- Moved DAC960 devices to /dev/dac960
+===============================================================================
+Changes for patch v147
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.32-pre4
+===============================================================================
+Changes for patch v148
+
+Work sponsored by SGI
+
+- Removed kmod support: use devfsd instead
+
+- Moved miscellaneous character devices to /dev/misc
+===============================================================================
+Changes for patch v149
+
+Work sponsored by SGI
+
+- Ensure include/linux/joystick.h is OK for user-space
+
+- Improved debugging in <get_vfs_inode>
+
+- Ensure dentries created by devfsd will be cleaned up
+===============================================================================
+Changes for patch v150
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.34
+===============================================================================
+Changes for patch v151
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.35-pre1
+
+- Created <devfs_get_name>
+===============================================================================
+Changes for patch v152
+
+Work sponsored by SGI
+
+- Updated sample modules.conf
+
+- Ported to kernel 2.3.36-pre1
+===============================================================================
+Changes for patch v153
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.42
+
+- Removed <devfs_fill_file>
+===============================================================================
+Changes for patch v154
+
+Work sponsored by SGI
+
+- Took account of device number changes for /dev/fb*
+===============================================================================
+Changes for patch v155
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.43-pre8
+
+- Moved /dev/tty0 to /dev/vc/0
+
+- Moved sequence number formatting from <_tty_make_name> to drivers
+===============================================================================
+Changes for patch v156
+
+Work sponsored by SGI
+
+- Fixed breakage in drivers/scsi/sd.c due to recent SCSI changes
+===============================================================================
+Changes for patch v157
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.45
+===============================================================================
+Changes for patch v158
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.46-pre2
+===============================================================================
+Changes for patch v159
+
+Work sponsored by SGI
+
+- Fixed drivers/block/md.c
+  Thanks to Mike Galbraith <mikeg@weiden.de>
+
+- Documentation fixes
+
+- Moved device registration from <lp_init> to <lp_register>
+  Thanks to Tim Waugh <twaugh@redhat.com>
+===============================================================================
+Changes for patch v160
+
+Work sponsored by SGI
+
+- Fixed drivers/char/joystick/joystick.c
+  Thanks to Vojtech Pavlik <vojtech@suse.cz>
+
+- Documentation updates
+
+- Fixed arch/i386/kernel/mtrr.c if procfs and devfs not enabled
+
+- Fixed drivers/char/stallion.c
+===============================================================================
+Changes for patch v161
+
+Work sponsored by SGI
+
+- Remove /dev/ide when ide-mod is unloaded
+
+- Fixed bug in drivers/block/ide-probe.c when secondary but no primary
+
+- Added DEVFS_FL_NO_PERSISTENCE flag
+
+- Used new DEVFS_FL_NO_PERSISTENCE flag for Unix98 pty slaves
+
+- Removed unnecessary call to <update_devfs_inode_from_entry> in
+  <devfs_readdir>
+
+- Only set auto-ownership for /dev/pty/s*
+===============================================================================
+Changes for patch v162
+
+Work sponsored by SGI
+
+- Set inode->i_size to correct size for symlinks
+  Thanks to Jeremy Fitzhardinge <jeremy@goop.org>
+
+- Only give lookup() method to directories to comply with new VFS
+  assumptions
+
+- Remove unnecessary tests in symlink methods
+
+- Don't kill existing block ops in <devfs_read_inode>
+
+- Restore auto-ownership for /dev/pty/m*
+===============================================================================
+Changes for patch v163
+
+Work sponsored by SGI
+
+- Don't create missing directories in <devfs_find_handle>
+
+- Removed Documentation/filesystems/devfs/mk-devlinks
+
+- Updated Documentation/filesystems/devfs/README
+===============================================================================
+Changes for patch v164
+
+Work sponsored by SGI
+
+- Fixed CONFIG_DEVFS breakage in drivers/char/serial.c introduced in
+  linux-2.3.99-pre6-7
+===============================================================================
+Changes for patch v165
+
+Work sponsored by SGI
+
+- Ported to kernel 2.3.99-pre6
+===============================================================================
+Changes for patch v166
+
+Work sponsored by SGI
+
+- Added CONFIG_DEVFS_MOUNT
+===============================================================================
+Changes for patch v167
+
+Work sponsored by SGI
+
+- Updated Documentation/filesystems/devfs/README
+
+- Updated sample modules.conf
+===============================================================================
+Changes for patch v168
+
+Work sponsored by SGI
+
+- Disabled multi-mount capability (use VFS bindings instead)
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v169
+
+Work sponsored by SGI
+
+- Removed multi-mount code
+
+- Removed compatibility macros: VFS has changed too much
+===============================================================================
+Changes for patch v170
+
+Work sponsored by SGI
+
+- Updated README from master HTML file
+
+- Merged devfs inode into devfs entry
+===============================================================================
+Changes for patch v171
+
+Work sponsored by SGI
+
+- Updated sample modules.conf
+
+- Removed dead code in <devfs_register> which used to call
+  <free_dentries>
+
+- Ported to kernel 2.4.0-test2-pre3
+===============================================================================
+Changes for patch v172
+
+Work sponsored by SGI
+
+- Changed interface to <devfs_register>
+
+- Changed interface to <devfs_register_series>
+===============================================================================
+Changes for patch v173
+
+Work sponsored by SGI
+
+- Simplified interface to <devfs_mk_symlink>
+
+- Simplified interface to <devfs_mk_dir>
+
+- Simplified interface to <devfs_find_handle>
+===============================================================================
+Changes for patch v174
+
+Work sponsored by SGI
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v175
+
+Work sponsored by SGI
+
+- DocBook update for fs/devfs/base.c
+  Thanks to Tim Waugh <twaugh@redhat.com>
+
+- Removed stale fs/tunnel.c (was never used or completed)
+===============================================================================
+Changes for patch v176
+
+Work sponsored by SGI
+
+- Updated ToDo list
+
+- Removed sample modules.conf: now distributed with devfsd
+
+- Updated README from master HTML file
+
+- Ported to kernel 2.4.0-test3-pre4 (which had devfs-patch-v174)
+===============================================================================
+Changes for patch v177
+
+- Updated README from master HTML file
+
+- Documentation cleanups
+
+- Ensure <devfs_generate_path> terminates string for root entry
+  Thanks to Tim Jansen <tim@tjansen.de>
+
+- Exported <devfs_get_name> to modules
+
+- Make <devfs_mk_symlink> send events to devfsd
+
+- Cleaned up option processing in <devfs_setup>
+
+- Fixed bugs in handling symlinks: could leak or cause Oops
+
+- Cleaned up directory handling by separating fops
+  Thanks to Alexander Viro <viro@parcelfarce.linux.theplanet.co.uk>
+===============================================================================
+Changes for patch v178
+
+- Fixed handling of inverted options in <devfs_setup>
+===============================================================================
+Changes for patch v179
+
+- Adjusted <try_modload> to account for <devfs_generate_path> fix
+===============================================================================
+Changes for patch v180
+
+- Fixed !CONFIG_DEVFS_FS stub declaration of <devfs_get_info>
+===============================================================================
+Changes for patch v181
+
+- Answered question posed by Al Viro and removed his comments from <devfs_open>
+
+- Moved setting of registered flag after other fields are changed
+
+- Fixed race between <devfsd_close> and <devfsd_notify_one>
+
+- Global VFS changes added bogus BKL to devfsd_close(): removed
+
+- Widened locking in <devfs_readlink> and <devfs_follow_link>
+
+- Replaced <devfsd_read> stack usage with <devfsd_ioctl> kmalloc
+
+- Simplified locking in <devfsd_ioctl> and fixed memory leak
+===============================================================================
+Changes for patch v182
+
+- Created <devfs_*alloc_major> and <devfs_*alloc_devnum>
+
+- Removed broken devnum allocation and use <devfs_alloc_devnum>
+
+- Fixed old devnum leak by calling new <devfs_dealloc_devnum>
+
+- Created <devfs_*alloc_unique_number>
+
+- Fixed number leak for /dev/cdroms/cdrom%d
+
+- Fixed number leak for /dev/discs/disc%d
+===============================================================================
+Changes for patch v183
+
+- Fixed bug in <devfs_setup> which could hang boot process
+===============================================================================
+Changes for patch v184
+
+- Documentation typo fix for fs/devfs/util.c
+
+- Fixed drivers/char/stallion.c for devfs
+
+- Added DEVFSD_NOTIFY_DELETE event
+
+- Updated README from master HTML file
+
+- Removed #include <asm/segment.h> from fs/devfs/base.c
+===============================================================================
+Changes for patch v185
+
+- Made <block_semaphore> and <char_semaphore> in fs/devfs/util.c
+  private
+
+- Fixed inode table races by removing it and using inode->u.generic_ip
+  instead
+
+- Moved <devfs_read_inode> into <get_vfs_inode>
+
+- Moved <devfs_write_inode> into <devfs_notify_change>
+===============================================================================
+Changes for patch v186
+
+- Fixed race in <devfs_do_symlink> for uni-processor
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v187
+
+- Fixed drivers/char/stallion.c for devfs
+
+- Fixed drivers/char/rocket.c for devfs
+
+- Fixed bug in <devfs_alloc_unique_number>: limited to 128 numbers
+===============================================================================
+Changes for patch v188
+
+- Updated major masks in fs/devfs/util.c up to Linus' "no new majors"
+  proclamation. Block: were 126 now 122 free, char: were 26 now 19 free
+
+- Updated README from master HTML file
+
+- Removed remnant of multi-mount support in <devfs_mknod>
+
+- Removed unused DEVFS_FL_SHOW_UNREG flag
+===============================================================================
+Changes for patch v189
+
+- Removed nlink field from struct devfs_inode
+
+- Removed auto-ownership for /dev/pty/* (BSD ptys) and used
+  DEVFS_FL_CURRENT_OWNER|DEVFS_FL_NO_PERSISTENCE for /dev/pty/s* (just
+  like Unix98 pty slaves) and made /dev/pty/m* rw-rw-rw- access
+===============================================================================
+Changes for patch v190
+
+- Updated README from master HTML file
+
+- Replaced BKL with global rwsem to protect symlink data (quick and
+  dirty hack)
+===============================================================================
+Changes for patch v191
+
+- Replaced global rwsem for symlink with per-link refcount
+===============================================================================
+Changes for patch v192
+
+- Removed unnecessary #ifdef CONFIG_DEVFS_FS from arch/i386/kernel/mtrr.c
+
+- Ported to kernel 2.4.10-pre11
+
+- Set inode->i_mapping->a_ops for block nodes in <get_vfs_inode>
+===============================================================================
+Changes for patch v193
+
+- Went back to global rwsem for symlinks (refcount scheme no good)
+===============================================================================
+Changes for patch v194
+
+- Fixed overrun in <devfs_link> by removing function (not needed)
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v195
+
+- Fixed buffer underrun in <try_modload>
+
+- Moved down_read() from <search_for_entry_in_dir> to <find_entry>
+===============================================================================
+Changes for patch v196
+
+- Fixed race in <devfsd_ioctl> when setting event mask
+  Thanks to Kari Hurtta <hurtta@leija.mh.fmi.fi>
+
+- Avoid deadlock in <devfs_follow_link> by using temporary buffer
+===============================================================================
+Changes for patch v197
+
+- First release of new locking code for devfs core (v1.0)
+
+- Fixed bug in drivers/cdrom/cdrom.c
+===============================================================================
+Changes for patch v198
+
+- Discard temporary buffer, now use "%s" for dentry names
+
+- Don't generate path in <try_modload>: use fake entry instead
+
+- Use "existing" directory in <_devfs_make_parent_for_leaf>
+
+- Use slab cache rather than fixed buffer for devfsd events
+===============================================================================
+Changes for patch v199
+
+- Removed obsolete usage of DEVFS_FL_NO_PERSISTENCE
+
+- Send DEVFSD_NOTIFY_REGISTERED events in <devfs_mk_dir>
+
+- Fixed locking bug in <devfs_d_revalidate_wait> due to typo
+
+- Do not send CREATE, CHANGE, ASYNC_OPEN or DELETE events from devfsd
+  or children
+===============================================================================
+Changes for patch v200
+
+- Ported to kernel 2.5.1-pre2
+===============================================================================
+Changes for patch v201
+
+- Fixed bug in <devfsd_read>: was dereferencing freed pointer
+===============================================================================
+Changes for patch v202
+
+- Fixed bug in <devfsd_close>: was dereferencing freed pointer
+
+- Added process group check for devfsd privileges
+===============================================================================
+Changes for patch v203
+
+- Use SLAB_ATOMIC in <devfsd_notify_de> from <devfs_d_delete>
+===============================================================================
+Changes for patch v204
+
+- Removed long obsolete rc.devfs
+
+- Return old entry in <devfs_mk_dir> for 2.4.x kernels
+
+- Updated README from master HTML file
+
+- Increment refcount on module in <check_disc_changed>
+
+- Created <devfs_get_handle> and exported <devfs_put>
+
+- Increment refcount on module in <devfs_get_ops>
+
+- Created <devfs_put_ops> and used where needed to fix races
+
+- Added clarifying comments in response to preliminary EMC code review
+
+- Added poisoning to <devfs_put>
+
+- Improved debugging messages
+
+- Fixed unregister bugs in drivers/md/lvm-fs.c
+===============================================================================
+Changes for patch v205
+
+- Corrected (made useful) debugging message in <unregister>
+
+- Moved <kmem_cache_create> in <mount_devfs_fs> to <init_devfs_fs>
+
+- Fixed drivers/md/lvm-fs.c to create "lvm" entry
+
+- Added magic number to guard against scribbling drivers
+
+- Only return old entry in <devfs_mk_dir> if a directory
+
+- Defined macros for error and debug messages
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v206
+
+- Added support for multiple Compaq cpqarray controllers
+
+- Fixed (rare, old) race in <devfs_lookup>
+===============================================================================
+Changes for patch v207
+
+- Fixed deadlock bug in <devfs_d_revalidate_wait>
+
+- Tag VFS deletable in <devfs_mk_symlink> if handle ignored
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v208
+
+- Added KERN_* to remaining messages
+
+- Cleaned up declaration of <stat_read>
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v209
+
+- Updated README from master HTML file
+
+- Removed silently introduced calls to lock_kernel() and
+  unlock_kernel() due to recent VFS locking changes. BKL isn't
+  required in devfs 
+
+- Changed <devfs_rmdir> to allow later additions if not yet empty
+
+- Added calls to <devfs_register_partitions> in drivers/block/blkpc.c
+  <add_partition> and <del_partition>
+
+- Fixed bug in <devfs_alloc_unique_number>: was clearing beyond
+  bitfield
+
+- Fixed bitfield data type for <devfs_*alloc_devnum>
+
+- Made major bitfield type and initialiser 64 bit safe
+===============================================================================
+Changes for patch v210
+
+- Updated fs/devfs/util.c to fix shift warning on 64 bit machines
+  Thanks to Anton Blanchard <anton@samba.org>
+
+- Updated README from master HTML file
+===============================================================================
+Changes for patch v211
+
+- Do not put miscellaneous character devices in /dev/misc if they
+  specify their own directory (i.e. contain a '/' character)
+
+- Copied macro for error messages from fs/devfs/base.c to
+  fs/devfs/util.c and made use of this macro
+
+- Removed 2.4.x compatibility code from fs/devfs/base.c
+===============================================================================
+Changes for patch v212
+
+- Added BKL to <devfs_open> because drivers still need it
+===============================================================================
+Changes for patch v213
+
+- Protected <scan_dir_for_removable> and <get_removable_partition>
+  from changing directory contents
+===============================================================================
+Changes for patch v214
+
+- Switched to ISO C structure field initialisers
+
+- Switch to set_current_state() and move before add_wait_queue()
+
+- Updated README from master HTML file
+
+- Fixed devfs entry leak in <devfs_readdir> when *readdir fails
+===============================================================================
+Changes for patch v215
+
+- Created <devfs_find_and_unregister>
+
+- Switched many functions from <devfs_find_handle> to
+  <devfs_find_and_unregister>
+
+- Switched many functions from <devfs_find_handle> to <devfs_get_handle>
+===============================================================================
+Changes for patch v216
+
+- Switched arch/ia64/sn/io/hcl.c from <devfs_find_handle> to
+  <devfs_get_handle>
+
+- Removed deprecated <devfs_find_handle>
+===============================================================================
+Changes for patch v217
+
+- Exported <devfs_find_and_unregister> and <devfs_only> to modules
+
+- Updated README from master HTML file
+
+- Fixed module unload race in <devfs_open>
+===============================================================================
+Changes for patch v218
+
+- Removed DEVFS_FL_AUTO_OWNER flag
+
+- Switched lingering structure field initialiser to ISO C
+
+- Added locking when setting/clearing flags
+
+- Documentation fix in fs/devfs/util.c
diff -urN linux-2.6.19.old/Documentation/filesystems/devfs/README linux-2.6.19.dev/Documentation/filesystems/devfs/README
--- linux-2.6.19.old/Documentation/filesystems/devfs/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/Documentation/filesystems/devfs/README	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,1959 @@
+Devfs (Device File System) FAQ
+
+
+Linux Devfs (Device File System) FAQ
+Richard Gooch
+20-AUG-2002
+
+
+Document languages:
+
+
+
+
+
+
+
+-----------------------------------------------------------------------------
+
+NOTE: the master copy of this document is available online at:
+
+http://www.atnf.csiro.au/~rgooch/linux/docs/devfs.html
+and looks much better than the text version distributed with the
+kernel sources. A mirror site is available at:
+
+http://www.ras.ucalgary.ca/~rgooch/linux/docs/devfs.html
+
+There is also an optional daemon that may be used with devfs. You can
+find out more about it at:
+
+http://www.atnf.csiro.au/~rgooch/linux/
+
+A mailing list is available which you may subscribe to. Send
+email
+to majordomo@oss.sgi.com with the following line in the
+body of the message:
+subscribe devfs
+To unsubscribe, send the message body:
+unsubscribe devfs
+instead. The list is archived at
+
+http://oss.sgi.com/projects/devfs/archive/.
+
+-----------------------------------------------------------------------------
+
+Contents
+
+
+What is it?
+
+Why do it?
+
+Who else does it?
+
+How it works
+
+Operational issues (essential reading)
+
+Instructions for the impatient
+Permissions persistence across reboots
+Dealing with drivers without devfs support
+All the way with Devfs
+Other Issues
+Kernel Naming Scheme
+Devfsd Naming Scheme
+Old Compatibility Names
+SCSI Host Probing Issues
+
+
+
+Device drivers currently ported
+
+Allocation of Device Numbers
+
+Questions and Answers
+
+Making things work
+Alternatives to devfs
+What I don't like about devfs
+How to report bugs
+Strange kernel messages
+Compilation problems with devfsd
+
+
+Other resources
+
+Translations of this document
+
+
+-----------------------------------------------------------------------------
+
+
+What is it?
+
+Devfs is an alternative to "real" character and block special devices
+on your root filesystem. Kernel device drivers can register devices by
+name rather than major and minor numbers. These devices will appear in
+devfs automatically, with whatever default ownership and
+protection the driver specified. A daemon (devfsd) can be used to
+override these defaults. Devfs has been in the kernel since 2.3.46.
+
+NOTE that devfs is entirely optional. If you prefer the old
+disc-based device nodes, then simply leave CONFIG_DEVFS_FS=n (the
+default). In this case, nothing will change.  ALSO NOTE that if you do
+enable devfs, the defaults are such that full compatibility is
+maintained with the old devices names.
+
+There are two aspects to devfs: one is the underlying device
+namespace, which is a namespace just like any mounted filesystem. The
+other aspect is the filesystem code which provides a view of the
+device namespace. The reason I make a distinction is because devfs
+can be mounted many times, with each mount showing the same device
+namespace. Changes made are global to all mounted devfs filesystems.
+Also, because the devfs namespace exists without any devfs mounts, you
+can easily mount the root filesystem by referring to an entry in the
+devfs namespace.
+
+
+The cost of devfs is a small increase in kernel code size and memory
+usage. About 7 pages of code (some of that in __init sections) and 72
+bytes for each entry in the namespace. A modest system has only a
+couple of hundred device entries, so this costs a few more
+pages. Compare this with the suggestion to put /dev on a <a
+href="#why-faq-ramdisc">ramdisc.
+
+On a typical machine, the cost is under 0.2 percent. On a modest
+system with 64 MBytes of RAM, the cost is under 0.1 percent.  The
+accusations of "bloatware" levelled at devfs are not justified.
+
+-----------------------------------------------------------------------------
+
+
+Why do it?
+
+There are several problems that devfs addresses. Some of these
+problems are more serious than others (depending on your point of
+view), and some can be solved without devfs. However, the totality of
+these problems really calls out for devfs.
+
+The choice is a patchwork of inefficient user space solutions, which
+are complex and likely to be fragile, or to use a simple and efficient
+devfs which is robust.
+
+There have been many counter-proposals to devfs, all seeking to
+provide some of the benefits without actually implementing devfs. So
+far there has been an absence of code and no proposed alternative has
+been able to provide all the features that devfs does. Further,
+alternative proposals require far more complexity in user-space (and
+still deliver less functionality than devfs). Some people have the
+mantra of reducing "kernel bloat", but don't consider the effects on
+user-space.
+
+A good solution limits the total complexity of kernel-space and
+user-space.
+
+
+Major&minor allocation
+
+The existing scheme requires the allocation of major and minor device
+numbers for each and every device. This means that a central
+co-ordinating authority is required to issue these device numbers
+(unless you're developing a "private" device driver), in order to
+preserve uniqueness. Devfs shifts the burden to a namespace. This may
+not seem like a huge benefit, but actually it is. Since driver authors
+will naturally choose a device name which reflects the functionality
+of the device, there is far less potential for namespace conflict.
+Solving this requires a kernel change.
+
+/dev management
+
+Because you currently access devices through device nodes, these must
+be created by the system administrator. For standard devices you can
+usually find a MAKEDEV programme which creates all these (hundreds!)
+of nodes. This means that changes in the kernel must be reflected by
+changes in the MAKEDEV programme, or else the system administrator
+creates device nodes by hand.
+
+The basic problem is that there are two separate databases of
+major and minor numbers. One is in the kernel and one is in /dev (or
+in a MAKEDEV programme, if you want to look at it that way). This is
+duplication of information, which is not good practice.
+Solving this requires a kernel change.
+
+/dev growth
+
+A typical /dev has over 1200 nodes! Most of these devices simply don't
+exist because the hardware is not available. A huge /dev increases the
+time to access devices (I'm just referring to the dentry lookup times
+and the time taken to read inodes off disc: the next subsection shows
+some more horrors).
+
+An example of how big /dev can grow is if we consider SCSI devices:
+
+host           6  bits  (say up to 64 hosts on a really big machine)
+channel        4  bits  (say up to 16 SCSI buses per host)
+id             4  bits
+lun            3  bits
+partition      6  bits
+TOTAL          23 bits
+
+
+This requires 8 Mega (1024*1024) inodes if we want to store all
+possible device nodes. Even if we scrap everything but id,partition
+and assume a single host adapter with a single SCSI bus and only one
+logical unit per SCSI target (id), that's still 10 bits or 1024
+inodes. Each VFS inode takes around 256 bytes (kernel 2.1.78), so
+that's 256 kBytes of inode storage on disc (assuming real inodes take
+a similar amount of space as VFS inodes). This is actually not so bad,
+because disc is cheap these days. Embedded systems would care about
+256 kBytes of /dev inodes, but you could argue that embedded systems
+would have hand-tuned /dev directories. I've had to do just that on my
+embedded systems, but I would rather just leave it to devfs.
+
+Another issue is the time taken to lookup an inode when first
+referenced. Not only does this take time in scanning through a list in
+memory, but also the seek times to read the inodes off disc.
+This could be solved in user-space using a clever programme which
+scanned the kernel logs and deleted /dev entries which are not
+available and created them when they were available. This programme
+would need to be run every time a new module was loaded, which would
+slow things down a lot.
+
+There is an existing programme called scsidev which will automatically
+create device nodes for SCSI devices. It can do this by scanning files
+in /proc/scsi. Unfortunately, to extend this idea to other device
+nodes would require significant modifications to existing drivers (so
+they too would provide information in /proc). This is a non-trivial
+change (I should know: devfs has had to do something similar). Once
+you go to this much effort, you may as well use devfs itself (which
+also provides this information).  Furthermore, such a system would
+likely be implemented in an ad-hoc fashion, as different drivers will
+provide their information in different ways.
+
+Devfs is much cleaner, because it (naturally) has a uniform mechanism
+to provide this information: the device nodes themselves!
+
+
+Node to driver file_operations translation
+
+There is an important difference between the way disc-based character
+and block nodes and devfs entries make the connection between an entry
+in /dev and the actual device driver.
+
+With the current 8 bit major and minor numbers the connection between
+disc-based c&b nodes and per-major drivers is done through a
+fixed-length table of 128 entries. The various filesystem types set
+the inode operations for c&b nodes to {chr,blk}dev_inode_operations,
+so when a device is opened a few quick levels of indirection bring us
+to the driver file_operations.
+
+For miscellaneous character devices a second step is required: there
+is a scan for the driver entry with the same minor number as the file
+that was opened, and the appropriate minor open method is called. This
+scanning is done *every time* you open a device node. Potentially, you
+may be searching through dozens of misc. entries before you find your
+open method. While not an enormous performance overhead, this does
+seem pointless.
+
+Linux *must* move beyond the 8 bit major and minor barrier,
+somehow. If we simply increase each to 16 bits, then the indexing
+scheme used for major driver lookup becomes untenable, because the
+major tables (one each for character and block devices) would need to
+be 64 k entries long (512 kBytes on x86, 1 MByte for 64 bit
+systems). So we would have to use a scheme like that used for
+miscellaneous character devices, which means the search time goes up
+linearly with the average number of major device drivers on your
+system. Not all "devices" are hardware, some are higher-level drivers
+like KGI, so you can get more "devices" without adding hardware
+You can improve this by creating an ordered (balanced:-)
+binary tree, in which case your search time becomes log(N).
+Alternatively, you can use hashing to speed up the search.
+But why do that search at all if you don't have to? Once again, it
+seems pointless.
+
+Note that devfs doesn't use the major&minor system. For devfs
+entries, the connection is done when you lookup the /dev entry. When
+devfs_register() is called, an internal table is appended which has
+the entry name and the file_operations. If the dentry cache doesn't
+have the /dev entry already, this internal table is scanned to get the
+file_operations, and an inode is created. If the dentry cache already
+has the entry, there is *no lookup time* (other than the dentry scan
+itself, but we can't avoid that anyway, and besides Linux dentries
+cream other OS's which don't have them:-). Furthermore, the number of
+node entries in a devfs is only the number of available device
+entries, not the number of *conceivable* entries. Even if you remove
+unnecessary entries in a disc-based /dev, the number of conceivable
+entries remains the same: you just limit yourself in order to save
+space.
+
+Devfs provides a fast connection between a VFS node and the device
+driver, in a scalable way.
+
+/dev as a system administration tool
+
+Right now /dev contains a list of conceivable devices, most of which I
+don't have. Devfs only shows those devices available on my
+system. This means that listing /dev is a handy way of checking what
+devices are available.
+
+Major&minor size
+
+Existing major and minor numbers are limited to 8 bits each. This is
+now a limiting factor for some drivers, particularly the SCSI disc
+driver, which consumes a single major number. Only 16 discs are
+supported, and each disc may have only 15 partitions. Maybe this isn't
+a problem for you, but some of us are building huge Linux systems with
+disc arrays. With devfs an arbitrary pointer can be associated with
+each device entry, which can be used to give an effective 32 bit
+device identifier (i.e. that's like having a 32 bit minor
+number). Since this is private to the kernel, there are no C library
+compatibility issues which you would have with increasing major and
+minor number sizes. See the section on "Allocation of Device Numbers"
+for details on maintaining compatibility with userspace.
+
+Solving this requires a kernel change.
+
+Since writing this, the kernel has been modified so that the SCSI disc
+driver has more major numbers allocated to it and now supports up to
+128 discs. Since these major numbers are non-contiguous (a result of
+unplanned expansion), the implementation is a little more cumbersome
+than originally.
+
+Just like the changes to IPv4 to fix impending limitations in the
+address space, people find ways around the limitations. In the long
+run, however, solutions like IPv6 or devfs can't be put off forever.
+
+Read-only root filesystem
+
+Having your device nodes on the root filesystem means that you can't
+operate properly with a read-only root filesystem. This is because you
+want to change ownerships and protections of tty devices. Existing
+practice prevents you using a CD-ROM as your root filesystem for a
+*real* system. Sure, you can boot off a CD-ROM, but you can't change
+tty ownerships, so it's only good for installing.
+
+Also, you can't use a shared NFS root filesystem for a cluster of
+discless Linux machines (having tty ownerships changed on a common
+/dev is not good). Nor can you embed your root filesystem in a
+ROM-FS.
+
+You can get around this by creating a RAMDISC at boot time, making
+an ext2 filesystem in it, mounting it somewhere and copying the
+contents of /dev into it, then unmounting it and mounting it over
+/dev.
+
+A devfs is a cleaner way of solving this.
+
+Non-Unix root filesystem
+
+Non-Unix filesystems (such as NTFS) can't be used for a root
+filesystem because they variously don't support character and block
+special files or symbolic links. You can't have a separate disc-based
+or RAMDISC-based filesystem mounted on /dev because you need device
+nodes before you can mount these. Devfs can be mounted without any
+device nodes. Devlinks won't work because symlinks aren't supported.
+An alternative solution is to use initrd to mount a RAMDISC initial
+root filesystem (which is populated with a minimal set of device
+nodes), and then construct a new /dev in another RAMDISC, and finally
+switch to your non-Unix root filesystem. This requires clever boot
+scripts and a fragile and conceptually complex boot procedure.
+
+Devfs solves this in a robust and conceptually simple way.
+
+PTY security
+
+Current pseudo-tty (pty) devices are owned by root and read-writable
+by everyone. The user of a pty-pair cannot change
+ownership/protections without being suid-root.
+
+This could be solved with a secure user-space daemon which runs as
+root and does the actual creation of pty-pairs. Such a daemon would
+require modification to *every* programme that wants to use this new
+mechanism. It also slows down creation of pty-pairs.
+
+An alternative is to create a new open_pty() syscall which does much
+the same thing as the user-space daemon. Once again, this requires
+modifications to pty-handling programmes.
+
+The devfs solution allows a device driver to "tag" certain device
+files so that when an unopened device is opened, the ownerships are
+changed to the current euid and egid of the opening process, and the
+protections are changed to the default registered by the driver. When
+the device is closed ownership is set back to root and protections are
+set back to read-write for everybody. No programme need be changed.
+The devpts filesystem provides this auto-ownership feature for Unix98
+ptys. It doesn't support old-style pty devices, nor does it have all
+the other features of devfs.
+
+Intelligent device management
+
+Devfs implements a simple yet powerful protocol for communication with
+a device management daemon (devfsd) which runs in user space. It is
+possible to send a message (either synchronously or asynchronously) to
+devfsd on any event, such as registration/unregistration of device
+entries, opening and closing devices, looking up inodes, scanning
+directories and more. This has many possibilities. Some of these are
+already implemented. See:
+
+
+http://www.atnf.csiro.au/~rgooch/linux/
+
+Device entry registration events can be used by devfsd to change
+permissions of newly-created device nodes. This is one mechanism to
+control device permissions.
+
+Device entry registration/unregistration events can be used to run
+programmes or scripts. This can be used to provide automatic mounting
+of filesystems when a new block device media is inserted into the
+drive.
+
+Asynchronous device open and close events can be used to implement
+clever permissions management. For example, the default permissions on
+/dev/dsp do not allow everybody to read from the device. This is
+sensible, as you don't want some remote user recording what you say at
+your console. However, the console user is also prevented from
+recording. This behaviour is not desirable. With asynchronous device
+open and close events, you can have devfsd run a programme or script
+when console devices are opened to change the ownerships for *other*
+device nodes (such as /dev/dsp). On closure, you can run a different
+script to restore permissions. An advantage of this scheme over
+modifying the C library tty handling is that this works even if your
+programme crashes (how many times have you seen the utmp database with
+lingering entries for non-existent logins?).
+
+Synchronous device open events can be used to perform intelligent
+device access protections. Before the device driver open() method is
+called, the daemon must first validate the open attempt, by running an
+external programme or script. This is far more flexible than access
+control lists, as access can be determined on the basis of other
+system conditions instead of just the UID and GID.
+
+Inode lookup events can be used to authenticate module autoload
+requests. Instead of using kmod directly, the event is sent to
+devfsd which can implement an arbitrary authentication before loading
+the module itself.
+
+Inode lookup events can also be used to construct arbitrary
+namespaces, without having to resort to populating devfs with symlinks
+to devices that don't exist.
+
+Speculative Device Scanning
+
+Consider an application (like cdparanoia) that wants to find all
+CD-ROM devices on the system (SCSI, IDE and other types), whether or
+not their respective modules are loaded. The application must
+speculatively open certain device nodes (such as /dev/sr0 for the SCSI
+CD-ROMs) in order to make sure the module is loaded. This requires
+that all Linux distributions follow the standard device naming scheme
+(last time I looked RedHat did things differently). Devfs solves the
+naming problem.
+
+The same application also wants to see which devices are actually
+available on the system. With the existing system it needs to read the
+/dev directory and speculatively open each /dev/sr* device to
+determine if the device exists or not. With a large /dev this is an
+inefficient operation, especially if there are many /dev/sr* nodes. A
+solution like scsidev could reduce the number of /dev/sr* entries (but
+of course that also requires all that inefficient directory scanning).
+
+With devfs, the application can open the /dev/sr directory
+(which triggers the module autoloading if required), and proceed to
+read /dev/sr. Since only the available devices will have
+entries, there are no inefficencies in directory scanning or device
+openings.
+
+-----------------------------------------------------------------------------
+
+Who else does it?
+
+FreeBSD has a devfs implementation. Solaris and AIX each have a
+pseudo-devfs (something akin to scsidev but for all devices, with some
+unspecified kernel support). BeOS, Plan9 and QNX also have it. SGI's
+IRIX 6.4 and above also have a device filesystem.
+
+While we shouldn't just automatically do something because others do
+it, we should not ignore the work of others either. FreeBSD has a lot
+of competent people working on it, so their opinion should not be
+blithely ignored.
+
+-----------------------------------------------------------------------------
+
+
+How it works
+
+Registering device entries
+
+For every entry (device node) in a devfs-based /dev a driver must call
+devfs_register(). This adds the name of the device entry, the
+file_operations structure pointer and a few other things to an
+internal table. Device entries may be added and removed at any
+time. When a device entry is registered, it automagically appears in
+any mounted devfs'.
+
+Inode lookup
+
+When a lookup operation on an entry is performed and if there is no
+driver information for that entry devfs will attempt to call
+devfsd. If still no driver information can be found then a negative
+dentry is yielded and the next stage operation will be called by the
+VFS (such as create() or mknod() inode methods). If driver information
+can be found, an inode is created (if one does not exist already) and
+all is well.
+
+Manually creating device nodes
+
+The mknod() method allows you to create an ordinary named pipe in the
+devfs, or you can create a character or block special inode if one
+does not already exist. You may wish to create a character or block
+special inode so that you can set permissions and ownership. Later, if
+a device driver registers an entry with the same name, the
+permissions, ownership and times are retained. This is how you can set
+the protections on a device even before the driver is loaded. Once you
+create an inode it appears in the directory listing.
+
+Unregistering device entries
+
+A device driver calls devfs_unregister() to unregister an entry.
+
+Chroot() gaols
+
+2.2.x kernels
+
+The semantics of inode creation are different when devfs is mounted
+with the "explicit" option. Now, when a device entry is registered, it
+will not appear until you use mknod() to create the device. It doesn't
+matter if you mknod() before or after the device is registered with
+devfs_register(). The purpose of this behaviour is to support
+chroot(2) gaols, where you want to mount a minimal devfs inside the
+gaol. Only the devices you specifically want to be available (through
+your mknod() setup) will be accessible.
+
+2.4.x kernels
+
+As of kernel 2.3.99, the VFS has had the ability to rebind parts of
+the global filesystem namespace into another part of the namespace.
+This now works even at the leaf-node level, which means that
+individual files and device nodes may be bound into other parts of the
+namespace. This is like making links, but better, because it works
+across filesystems (unlike hard links) and works through chroot()
+gaols (unlike symbolic links).
+
+Because of these improvements to the VFS, the multi-mount capability
+in devfs is no longer needed. The administrator may create a minimal
+device tree inside a chroot(2) gaol by using VFS bindings. As this
+provides most of the features of the devfs multi-mount capability, I
+removed the multi-mount support code (after issuing an RFC). This
+yielded code size reductions and simplifications.
+
+If you want to construct a minimal chroot() gaol, the following
+command should suffice:
+
+mount --bind /dev/null /gaol/dev/null
+
+
+Repeat for other device nodes you want to expose. Simple!
+
+-----------------------------------------------------------------------------
+
+
+Operational issues
+
+
+Instructions for the impatient
+
+Nobody likes reading documentation. People just want to get in there
+and play. So this section tells you quickly the steps you need to take
+to run with devfs mounted over /dev. Skip these steps and you will end
+up with a nearly unbootable system. Subsequent sections describe the
+issues in more detail, and discuss non-essential configuration
+options.
+
+Devfsd
+OK, if you're reading this, I assume you want to play with
+devfs. First you should ensure that /usr/src/linux contains a
+recent kernel source tree. Then you need to compile devfsd, the device
+management daemon, available at
+
+http://www.atnf.csiro.au/~rgooch/linux/.
+Because the kernel has a naming scheme
+which is quite different from the old naming scheme, you need to
+install devfsd so that software and configuration files that use the
+old naming scheme will not break.
+
+Compile and install devfsd. You will be provided with a default
+configuration file /etc/devfsd.conf which will provide
+compatibility symlinks for the old naming scheme. Don't change this
+config file unless you know what you're doing. Even if you think you
+do know what you're doing, don't change it until you've followed all
+the steps below and booted a devfs-enabled system and verified that it
+works.
+
+Now edit your main system boot script so that devfsd is started at the
+very beginning (before any filesystem
+checks). /etc/rc.d/rc.sysinit is often the main boot script
+on systems with SysV-style boot scripts. On systems with BSD-style
+boot scripts it is often /etc/rc. Also check
+/sbin/rc.
+
+NOTE that the line you put into the boot
+script should be exactly:
+
+/sbin/devfsd /dev
+
+DO NOT use some special daemon-launching
+programme, otherwise the boot script may not wait for devfsd to finish
+initialising.
+
+System Libraries
+There may still be some problems because of broken software making
+assumptions about device names. In particular, some software does not
+handle devices which are symbolic links. If you are running a libc 5
+based system, install libc 5.4.44 (if you have libc 5.4.46, go back to
+libc 5.4.44, which is actually correct). If you are running a glibc
+based system, make sure you have glibc 2.1.3 or later.
+
+/etc/securetty
+PAM (Pluggable Authentication Modules) is supposed to be a flexible
+mechanism for providing better user authentication and access to
+services. Unfortunately, it's also fragile, complex and undocumented
+(check out RedHat 6.1, and probably other distributions as well). PAM
+has problems with symbolic links. Append the following lines to your
+/etc/securetty file:
+
+vc/1
+vc/2
+vc/3
+vc/4
+vc/5
+vc/6
+vc/7
+vc/8
+
+This will not weaken security. If you have a version of util-linux
+earlier than 2.10.h, please upgrade to 2.10.h or later. If you
+absolutely cannot upgrade, then also append the following lines to
+your /etc/securetty file:
+
+1
+2
+3
+4
+5
+6
+7
+8
+
+This may potentially weaken security by allowing root logins over the
+network (a password is still required, though). However, since there
+are problems with dealing with symlinks, I'm suspicious of the level
+of security offered in any case.
+
+XFree86
+While not essential, it's probably a good idea to upgrade to XFree86
+4.0, as patches went in to make it more devfs-friendly. If you don't,
+you'll probably need to apply the following patch to
+/etc/security/console.perms so that ordinary users can run
+startx. Note that not all distributions have this file (e.g. Debian),
+so if it's not present, don't worry about it.
+
+--- /etc/security/console.perms.orig    Sat Apr 17 16:26:47 1999 
++++ /etc/security/console.perms Fri Feb 25 23:53:55 2000 
+@@ -14,7 +14,7 @@ 
+ # man 5 console.perms 
+
+ # file classes -- these are regular expressions 
+-<console>=tty[0-9][0-9]* :[0-9]\.[0-9] :[0-9] 
++<console>=tty[0-9][0-9]* vc/[0-9][0-9]* :[0-9]\.[0-9] :[0-9] 
+
+ # device classes -- these are shell-style globs 
+ <floppy>=/dev/fd[0-1]* 
+
+If the patch does not apply, then change the line:
+
+<console>=tty[0-9][0-9]* :[0-9]\.[0-9] :[0-9]
+
+with:
+
+<console>=tty[0-9][0-9]* vc/[0-9][0-9]* :[0-9]\.[0-9] :[0-9]
+
+
+Disable devpts
+I've had a report of devpts mounted on /dev/pts not working
+correctly. Since devfs will also manage /dev/pts, there is no
+need to mount devpts as well. You should either edit your
+/etc/fstab so devpts is not mounted, or disable devpts from
+your kernel configuration.
+
+Unsupported drivers
+Not all drivers have devfs support. If you depend on one of these
+drivers, you will need to create a script or tarfile that you can use
+at boot time to create device nodes as appropriate. There is a
+section which describes this. Another
+section lists the drivers which have
+devfs support.
+
+/dev/mouse
+
+Many disributions configure /dev/mouse to be the mouse device
+for XFree86 and GPM. I actually think this is a bad idea, because it
+adds another level of indirection. When looking at a config file, if
+you see /dev/mouse you're left wondering which mouse
+is being referred to. Hence I recommend putting the actual mouse
+device (for example /dev/psaux) into your
+/etc/X11/XF86Config file (and similarly for the GPM
+configuration file).
+
+Alternatively, use the same technique used for unsupported drivers
+described above.
+
+The Kernel
+Finally, you need to make sure devfs is compiled into your kernel. Set
+CONFIG_EXPERIMENTAL=y, CONFIG_DEVFS_FS=y and CONFIG_DEVFS_MOUNT=y by
+using favourite configuration tool (i.e. make config or
+make xconfig) and then make clean and then recompile your kernel and 
+modules. At boot, devfs will be mounted onto /dev.
+
+If you encounter problems booting (for example if you forgot a
+configuration step), you can pass devfs=nomount at the kernel
+boot command line. This will prevent the kernel from mounting devfs at
+boot time onto /dev.
+
+In general, a kernel built with CONFIG_DEVFS_FS=y but without mounting
+devfs onto /dev is completely safe, and requires no
+configuration changes. One exception to take note of is when
+LABEL= directives are used in /etc/fstab. In this
+case you will be unable to boot properly. This is because the
+mount(8) programme uses /proc/partitions as part of
+the volume label search process, and the device names it finds are not
+available, because setting CONFIG_DEVFS_FS=y changes the names in
+/proc/partitions, irrespective of whether devfs is mounted.
+
+Now you've finished all the steps required. You're now ready to boot
+your shiny new kernel. Enjoy.
+
+Changing the configuration
+
+OK, you've now booted a devfs-enabled system, and everything works.
+Now you may feel like changing the configuration (common targets are
+/etc/fstab and /etc/devfsd.conf). Since you have a
+system that works, if you make any changes and it doesn't work, you
+now know that you only have to restore your configuration files to the
+default and it will work again.
+
+
+Permissions persistence across reboots
+
+If you don't use mknod(2) to create a device file, nor use chmod(2) or
+chown(2) to change the ownerships/permissions, the inode ctime will
+remain at 0 (the epoch, 12 am, 1-JAN-1970, GMT). Anything with a ctime
+later than this has had it's ownership/permissions changed. Hence, a
+simple script or programme may be used to tar up all changed inodes,
+prior to shutdown. Although effective, many consider this approach a
+kludge.
+
+A much better approach is to use devfsd to save and restore
+permissions. It may be configured to record changes in permissions and
+will save them in a database (in fact a directory tree), and restore
+these upon boot. This is an efficient method and results in immediate
+saving of current permissions (unlike the tar approach, which saves
+permissions at some unspecified future time).
+
+The default configuration file supplied with devfsd has config entries
+which you may uncomment to enable persistence management.
+
+If you decide to use the tar approach anyway, be aware that tar will
+first unlink(2) an inode before creating a new device node. The
+unlink(2) has the effect of breaking the connection between a devfs
+entry and the device driver. If you use the "devfs=only" boot option,
+you lose access to the device driver, requiring you to reload the
+module. I consider this a bug in tar (there is no real need to
+unlink(2) the inode first).
+
+Alternatively, you can use devfsd to provide more sophisticated
+management of device permissions. You can use devfsd to store
+permissions for whole groups of devices with a single configuration
+entry, rather than the conventional single entry per device entry.
+
+Permissions database stored in mounted-over /dev
+
+If you wish to save and restore your device permissions into the
+disc-based /dev while still mounting devfs onto /dev
+you may do so. This requires a 2.4.x kernel (in fact, 2.3.99 or
+later), which has the VFS binding facility. You need to do the
+following to set this up:
+
+
+
+make sure the kernel does not mount devfs at boot time
+
+
+make sure you have a correct /dev/console entry in your
+root file-system (where your disc-based /dev lives)
+
+create the /dev-state directory
+
+
+add the following lines near the very beginning of your boot
+scripts:
+
+mount --bind /dev /dev-state
+mount -t devfs none /dev
+devfsd /dev
+
+
+
+
+add the following lines to your /etc/devfsd.conf file:
+
+REGISTER	^pt[sy]		IGNORE
+CREATE		^pt[sy]		IGNORE
+CHANGE		^pt[sy]		IGNORE
+DELETE		^pt[sy]		IGNORE
+REGISTER	.*		COPY	/dev-state/$devname $devpath
+CREATE		.*		COPY	$devpath /dev-state/$devname
+CHANGE		.*		COPY	$devpath /dev-state/$devname
+DELETE		.*		CFUNCTION GLOBAL unlink /dev-state/$devname
+RESTORE		/dev-state
+
+Note that the sample devfsd.conf file contains these lines,
+as well as other sample configurations you may find useful. See the
+devfsd distribution
+
+
+reboot.
+
+
+
+
+Permissions database stored in normal directory
+
+If you are using an older kernel which doesn't support VFS binding,
+then you won't be able to have the permissions database in a
+mounted-over /dev. However, you can still use a regular
+directory to store the database. The sample /etc/devfsd.conf
+file above may still be used. You will need to create the
+/dev-state directory prior to installing devfsd. If you have
+old permissions in /dev, then just copy (or move) the device
+nodes over to the new directory.
+
+Which method is better?
+
+The best method is to have the permissions database stored in the
+mounted-over /dev. This is because you will not need to copy
+device nodes over to /dev-state, and because it allows you to
+switch between devfs and non-devfs kernels, without requiring you to
+copy permissions between /dev-state (for devfs) and
+/dev (for non-devfs).
+
+
+Dealing with drivers without devfs support
+
+Currently, not all device drivers in the kernel have been modified to
+use devfs. Device drivers which do not yet have devfs support will not
+automagically appear in devfs. The simplest way to create device nodes
+for these drivers is to unpack a tarfile containing the required
+device nodes. You can do this in your boot scripts. All your drivers
+will now work as before.
+
+Hopefully for most people devfs will have enough support so that they
+can mount devfs directly over /dev without losing most functionality
+(i.e. losing access to various devices). As of 22-JAN-1998 (devfs
+patch version 10) I am now running this way. All the devices I have
+are available in devfs, so I don't lose anything.
+
+WARNING: if your configuration requires the old-style device names
+(i.e. /dev/hda1 or /dev/sda1), you must install devfsd and configure
+it to maintain compatibility entries. It is almost certain that you
+will require this. Note that the kernel creates a compatibility entry
+for the root device, so you don't need initrd.
+
+Note that you no longer need to mount devpts if you use Unix98 PTYs,
+as devfs can manage /dev/pts itself. This saves you some RAM, as you
+don't need to compile and install devpts. Note that some versions of
+glibc have a bug with Unix98 pty handling on devfs systems. Contact
+the glibc maintainers for a fix. Glibc 2.1.3 has the fix.
+
+Note also that apart from editing /etc/fstab, other things will need
+to be changed if you *don't* install devfsd. Some software (like the X
+server) hard-wire device names in their source. It really is much
+easier to install devfsd so that compatibility entries are created.
+You can then slowly migrate your system to using the new device names
+(for example, by starting with /etc/fstab), and then limiting the
+compatibility entries that devfsd creates.
+
+IF YOU CONFIGURE TO MOUNT DEVFS AT BOOT, MAKE SURE YOU INSTALL DEVFSD
+BEFORE YOU BOOT A DEVFS-ENABLED KERNEL!
+
+Now that devfs has gone into the 2.3.46 kernel, I'm getting a lot of
+reports back. Many of these are because people are trying to run
+without devfsd, and hence some things break. Please just run devfsd if
+things break. I want to concentrate on real bugs rather than
+misconfiguration problems at the moment. If people are willing to fix
+bugs/false assumptions in other code (i.e. glibc, X server) and submit
+that to the respective maintainers, that would be great.
+
+
+All the way with Devfs
+
+The devfs kernel patch creates a rationalised device tree. As stated
+above, if you want to keep using the old /dev naming scheme,
+you just need to configure devfsd appopriately (see the man
+page). People who prefer the old names can ignore this section. For
+those of us who like the rationalised names and an uncluttered
+/dev, read on.
+
+If you don't run devfsd, or don't enable compatibility entry
+management, then you will have to configure your system to use the new
+names. For example, you will then need to edit your
+/etc/fstab to use the new disc naming scheme. If you want to
+be able to boot non-devfs kernels, you will need compatibility
+symlinks in the underlying disc-based /dev pointing back to
+the old-style names for when you boot a kernel without devfs.
+
+You can selectively decide which devices you want compatibility
+entries for. For example, you may only want compatibility entries for
+BSD pseudo-terminal devices (otherwise you'll have to patch you C
+library or use Unix98 ptys instead). It's just a matter of putting in
+the correct regular expression into /dev/devfsd.conf.
+
+There are other choices of naming schemes that you may prefer. For
+example, I don't use the kernel-supplied
+names, because they are too verbose. A common misconception is
+that the kernel-supplied names are meant to be used directly in
+configuration files. This is not the case. They are designed to
+reflect the layout of the devices attached and to provide easy
+classification.
+
+If you like the kernel-supplied names, that's fine. If you don't then
+you should be using devfsd to construct a namespace more to your
+liking. Devfsd has built-in code to construct a
+namespace that is both logical and easy to
+manage. In essence, it creates a convenient abbreviation of the
+kernel-supplied namespace.
+
+You are of course free to build your own namespace. Devfsd has all the
+infrastructure required to make this easy for you. All you need do is
+write a script. You can even write some C code and devfsd can load the
+shared object as a callable extension.
+
+
+Other Issues
+
+The init programme
+Another thing to take note of is whether your init programme
+creates a Unix socket /dev/telinit. Some versions of init
+create /dev/telinit so that the telinit programme can
+communicate with the init process. If you have such a system you need
+to make sure that devfs is mounted over /dev *before* init
+starts. In other words, you can't leave the mounting of devfs to
+/etc/rc, since this is executed after init. Other
+versions of init require a named pipe /dev/initctl
+which must exist *before* init starts. Once again, you need to
+mount devfs and then create the named pipe *before* init
+starts.
+
+The default behaviour now is not to mount devfs onto /dev at
+boot time for 2.3.x and later kernels. You can correct this with the
+"devfs=mount" boot option. This solves any problems with init,
+and also prevents the dreaded:
+
+Cannot open initial console
+
+message. For 2.2.x kernels where you need to apply the devfs patch,
+the default is to mount.
+
+If you have automatic mounting of devfs onto /dev then you
+may need to create /dev/initctl in your boot scripts. The
+following lines should suffice:
+
+mknod /dev/initctl p
+kill -SIGUSR1 1       # tell init that /dev/initctl now exists
+
+Alternatively, if you don't want the kernel to mount devfs onto
+/dev then you could use the following procedure is a
+guideline for how to get around /dev/initctl problems:
+
+# cd /sbin
+# mv init init.real
+# cat > init
+#! /bin/sh
+mount -n -t devfs none /dev
+mknod /dev/initctl p
+exec /sbin/init.real $*
+[control-D]
+# chmod a+x init
+
+Note that newer versions of init create /dev/initctl
+automatically, so you don't have to worry about this.
+
+Module autoloading
+You will need to configure devfsd to enable module
+autoloading. The following lines should be placed in your
+/etc/devfsd.conf file:
+
+LOOKUP	.*		MODLOAD
+
+
+As of devfsd-v1.3.10, a generic /etc/modules.devfs
+configuration file is installed, which is used by the MODLOAD
+action. This should be sufficient for most configurations. If you
+require further configuration, edit your /etc/modules.conf
+file. The way module autoloading work with devfs is:
+
+
+a process attempts to lookup a device node (e.g. /dev/fred)
+
+
+if that device node does not exist, the full pathname is passed to
+devfsd as a string
+
+
+devfsd will pass the string to the modprobe programme (provided the
+configuration line shown above is present), and specifies that
+/etc/modules.devfs is the configuration file
+
+
+/etc/modules.devfs includes /etc/modules.conf to
+access local configurations
+
+modprobe will search it's configuration files, looking for an alias
+that translates the pathname into a module name
+
+
+the translated pathname is then used to load the module.
+
+
+If you wanted a lookup of /dev/fred to load the
+mymod module, you would require the following configuration
+line in /etc/modules.conf:
+
+alias    /dev/fred    mymod
+
+The /etc/modules.devfs configuration file provides many such
+aliases for standard device names. If you look closely at this file,
+you will note that some modules require multiple alias configuration
+lines. This is required to support module autoloading for old and new
+device names.
+
+Mounting root off a devfs device
+If you wish to mount root off a devfs device when you pass the
+"devfs=only" boot option, then you need to pass in the
+"root=<device>" option to the kernel when booting. If you use
+LILO, then you must have this in lilo.conf:
+
+append = "root=<device>"
+
+Surprised? Yep, so was I. It turns out if you have (as most people
+do):
+
+root = <device>
+
+
+then LILO will determine the device number of <device> and will
+write that device number into a special place in the kernel image
+before starting the kernel, and the kernel will use that device number
+to mount the root filesystem. So, using the "append" variety ensures
+that LILO passes the root filesystem device as a string, which devfs
+can then use.
+
+Note that this isn't an issue if you don't pass "devfs=only".
+
+TTY issues
+The ttyname(3) function in some versions of the C library makes
+false assumptions about device entries which are symbolic links.  The
+tty(1) programme is one that depends on this function.  I've
+written a patch to libc 5.4.43 which fixes this. This has been
+included in libc 5.4.44 and a similar fix is in glibc 2.1.3.
+
+
+Kernel Naming Scheme
+
+The kernel provides a default naming scheme. This scheme is designed
+to make it easy to search for specific devices or device types, and to
+view the available devices. Some device types (such as hard discs),
+have a directory of entries, making it easy to see what devices of
+that class are available. Often, the entries are symbolic links into a
+directory tree that reflects the topology of available devices. The
+topological tree is useful for finding how your devices are arranged.
+
+Below is a list of the naming schemes for the most common drivers. A
+list of reserved device names is
+available for reference. Please send email to
+rgooch@atnf.csiro.au to obtain an allocation. Please be
+patient (the maintainer is busy). An alternative name may be allocated
+instead of the requested name, at the discretion of the maintainer.
+
+Disc Devices
+
+All discs, whether SCSI, IDE or whatever, are placed under the
+/dev/discs hierarchy:
+
+	/dev/discs/disc0	first disc
+	/dev/discs/disc1	second disc
+
+
+Each of these entries is a symbolic link to the directory for that
+device. The device directory contains:
+
+	disc	for the whole disc
+	part*	for individual partitions
+
+
+CD-ROM Devices
+
+All CD-ROMs, whether SCSI, IDE or whatever, are placed under the
+/dev/cdroms hierarchy:
+
+	/dev/cdroms/cdrom0	first CD-ROM
+	/dev/cdroms/cdrom1	second CD-ROM
+
+
+Each of these entries is a symbolic link to the real device entry for
+that device.
+
+Tape Devices
+
+All tapes, whether SCSI, IDE or whatever, are placed under the
+/dev/tapes hierarchy:
+
+	/dev/tapes/tape0	first tape
+	/dev/tapes/tape1	second tape
+
+
+Each of these entries is a symbolic link to the directory for that
+device. The device directory contains:
+
+	mt			for mode 0
+	mtl			for mode 1
+	mtm			for mode 2
+	mta			for mode 3
+	mtn			for mode 0, no rewind
+	mtln			for mode 1, no rewind
+	mtmn			for mode 2, no rewind
+	mtan			for mode 3, no rewind
+
+
+SCSI Devices
+
+To uniquely identify any SCSI device requires the following
+information:
+
+  controller	(host adapter)
+  bus		(SCSI channel)
+  target	(SCSI ID)
+  unit		(Logical Unit Number)
+
+
+All SCSI devices are placed under /dev/scsi (assuming devfs
+is mounted on /dev). Hence, a SCSI device with the following
+parameters: c=1,b=2,t=3,u=4 would appear as:
+
+	/dev/scsi/host1/bus2/target3/lun4	device directory
+
+
+Inside this directory, a number of device entries may be created,
+depending on which SCSI device-type drivers were installed.
+
+See the section on the disc naming scheme to see what entries the SCSI
+disc driver creates.
+
+See the section on the tape naming scheme to see what entries the SCSI
+tape driver creates.
+
+The SCSI CD-ROM driver creates:
+
+	cd
+
+
+The SCSI generic driver creates:
+
+	generic
+
+
+IDE Devices
+
+To uniquely identify any IDE device requires the following
+information:
+
+  controller
+  bus		(aka. primary/secondary)
+  target	(aka. master/slave)
+  unit
+
+
+All IDE devices are placed under /dev/ide, and uses a similar
+naming scheme to the SCSI subsystem.
+
+XT Hard Discs
+
+All XT discs are placed under /dev/xd. The first XT disc has
+the directory /dev/xd/disc0.
+
+TTY devices
+
+The tty devices now appear as:
+
+  New name                   Old-name                   Device Type
+  --------                   --------                   -----------
+  /dev/tts/{0,1,...}         /dev/ttyS{0,1,...}         Serial ports
+  /dev/cua/{0,1,...}         /dev/cua{0,1,...}          Call out devices
+  /dev/vc/0                  /dev/tty                   Current virtual console
+  /dev/vc/{1,2,...}          /dev/tty{1...63}           Virtual consoles
+  /dev/vcc/{0,1,...}         /dev/vcs{1...63}           Virtual consoles
+  /dev/pty/m{0,1,...}        /dev/ptyp??                PTY masters
+  /dev/pty/s{0,1,...}        /dev/ttyp??                PTY slaves
+
+
+RAMDISCS
+
+The RAMDISCS are placed in their own directory, and are named thus:
+
+  /dev/rd/{0,1,2,...}
+
+
+Meta Devices
+
+The meta devices are placed in their own directory, and are named
+thus:
+
+  /dev/md/{0,1,2,...}
+
+
+Floppy discs
+
+Floppy discs are placed in the /dev/floppy directory.
+
+Loop devices
+
+Loop devices are placed in the /dev/loop directory.
+
+Sound devices
+
+Sound devices are placed in the /dev/sound directory
+(audio, sequencer, ...).
+
+
+Devfsd Naming Scheme
+
+Devfsd provides a naming scheme which is a convenient abbreviation of
+the kernel-supplied namespace. In some
+cases, the kernel-supplied naming scheme is quite convenient, so
+devfsd does not provide another naming scheme. The convenience names
+that devfsd creates are in fact the same names as the original devfs
+kernel patch created (before Linus mandated the Big Name
+Change). These are referred to as "new compatibility entries".
+
+In order to configure devfsd to create these convenience names, the
+following lines should be placed in your /etc/devfsd.conf:
+
+REGISTER	.*		MKNEWCOMPAT
+UNREGISTER	.*		RMNEWCOMPAT
+
+This will cause devfsd to create (and destroy) symbolic links which
+point to the kernel-supplied names.
+
+SCSI Hard Discs
+
+All SCSI discs are placed under /dev/sd (assuming devfs is
+mounted on /dev). Hence, a SCSI disc with the following
+parameters: c=1,b=2,t=3,u=4 would appear as:
+
+	/dev/sd/c1b2t3u4	for the whole disc
+	/dev/sd/c1b2t3u4p5	for the 5th partition
+	/dev/sd/c1b2t3u4p5s6	for the 6th slice in the 5th partition
+
+
+SCSI Tapes
+
+All SCSI tapes are placed under /dev/st. A similar naming
+scheme is used as for SCSI discs. A SCSI tape with the
+parameters:c=1,b=2,t=3,u=4 would appear as:
+
+	/dev/st/c1b2t3u4m0	for mode 0
+	/dev/st/c1b2t3u4m1	for mode 1
+	/dev/st/c1b2t3u4m2	for mode 2
+	/dev/st/c1b2t3u4m3	for mode 3
+	/dev/st/c1b2t3u4m0n	for mode 0, no rewind
+	/dev/st/c1b2t3u4m1n	for mode 1, no rewind
+	/dev/st/c1b2t3u4m2n	for mode 2, no rewind
+	/dev/st/c1b2t3u4m3n	for mode 3, no rewind
+
+
+SCSI CD-ROMs
+
+All SCSI CD-ROMs are placed under /dev/sr. A similar naming
+scheme is used as for SCSI discs. A SCSI CD-ROM with the
+parameters:c=1,b=2,t=3,u=4 would appear as:
+
+	/dev/sr/c1b2t3u4
+
+
+SCSI Generic Devices
+
+The generic (aka. raw) interface for all SCSI devices are placed under
+/dev/sg. A similar naming scheme is used as for SCSI discs. A
+SCSI generic device with the parameters:c=1,b=2,t=3,u=4 would appear
+as:
+
+	/dev/sg/c1b2t3u4
+
+
+IDE Hard Discs
+
+All IDE discs are placed under /dev/ide/hd, using a similar
+convention to SCSI discs. The following mappings exist between the new
+and the old names:
+
+	/dev/hda	/dev/ide/hd/c0b0t0u0
+	/dev/hdb	/dev/ide/hd/c0b0t1u0
+	/dev/hdc	/dev/ide/hd/c0b1t0u0
+	/dev/hdd	/dev/ide/hd/c0b1t1u0
+
+
+IDE Tapes
+
+A similar naming scheme is used as for IDE discs. The entries will
+appear in the /dev/ide/mt directory.
+
+IDE CD-ROM
+
+A similar naming scheme is used as for IDE discs. The entries will
+appear in the /dev/ide/cd directory.
+
+IDE Floppies
+
+A similar naming scheme is used as for IDE discs. The entries will
+appear in the /dev/ide/fd directory.
+
+XT Hard Discs
+
+All XT discs are placed under /dev/xd. The first XT disc
+would appear as /dev/xd/c0t0.
+
+
+Old Compatibility Names
+
+The old compatibility names are the legacy device names, such as
+/dev/hda, /dev/sda, /dev/rtc and so on.
+Devfsd can be configured to create compatibility symlinks so that you
+may continue to use the old names in your configuration files and so
+that old applications will continue to function correctly.
+
+In order to configure devfsd to create these legacy names, the
+following lines should be placed in your /etc/devfsd.conf:
+
+REGISTER	.*		MKOLDCOMPAT
+UNREGISTER	.*		RMOLDCOMPAT
+
+This will cause devfsd to create (and destroy) symbolic links which
+point to the kernel-supplied names.
+
+
+-----------------------------------------------------------------------------
+
+
+Device drivers currently ported
+
+- All miscellaneous character devices support devfs (this is done
+  transparently through misc_register())
+
+- SCSI discs and generic hard discs
+
+- Character memory devices (null, zero, full and so on)
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- Loop devices (/dev/loop?)
+ 
+- TTY devices (console, serial ports, terminals and pseudo-terminals)
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- SCSI tapes (/dev/scsi and /dev/tapes)
+
+- SCSI CD-ROMs (/dev/scsi and /dev/cdroms)
+
+- SCSI generic devices (/dev/scsi)
+
+- RAMDISCS (/dev/ram?)
+
+- Meta Devices (/dev/md*)
+
+- Floppy discs (/dev/floppy)
+
+- Parallel port printers (/dev/printers)
+
+- Sound devices (/dev/sound)
+  Thanks to Eric Dumas <dumas@linux.eu.org> and
+  C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- Joysticks (/dev/joysticks)
+
+- Sparc keyboard (/dev/kbd)
+
+- DSP56001 digital signal processor (/dev/dsp56k)
+
+- Apple Desktop Bus (/dev/adb)
+
+- Coda network file system (/dev/cfs*)
+
+- Virtual console capture devices (/dev/vcc)
+  Thanks to Dennis Hou <smilax@mindmeld.yi.org>
+
+- Frame buffer devices (/dev/fb)
+
+- Video capture devices (/dev/v4l)
+
+
+-----------------------------------------------------------------------------
+
+
+Allocation of Device Numbers
+
+Devfs allows you to write a driver which doesn't need to allocate a
+device number (major&minor numbers) for the internal operation of the
+kernel. However, there are a number of userspace programmes that use
+the device number as a unique handle for a device. An example is the
+find programme, which uses device numbers to determine whether
+an inode is on a different filesystem than another inode. The device
+number used is the one for the block device which a filesystem is
+using. To preserve compatibility with userspace programmes, block
+devices using devfs need to have unique device numbers allocated to
+them. Furthermore, POSIX specifies device numbers, so some kind of
+device number needs to be presented to userspace.
+
+The simplest option (especially when porting drivers to devfs) is to
+keep using the old major and minor numbers. Devfs will take whatever
+values are given for major&minor and pass them onto userspace.
+
+This device number is a 16 bit number, so this leaves plenty of space
+for large numbers of discs and partitions. This scheme can also be
+used for character devices, in particular the tty devices, which are
+currently limited to 256 pseudo-ttys (this limits the total number of
+simultaneous xterms and remote logins).  Note that the device number
+is limited to the range 36864-61439 (majors 144-239), in order to
+avoid any possible conflicts with existing official allocations.
+
+Please note that using dynamically allocated block device numbers may
+break the NFS daemons (both user and kernel mode), which expect dev_t
+for a given device to be constant over the lifetime of remote mounts.
+
+A final note on this scheme: since it doesn't increase the size of
+device numbers, there are no compatibility issues with userspace.
+
+-----------------------------------------------------------------------------
+
+
+Questions and Answers
+
+
+Making things work
+Alternatives to devfs
+What I don't like about devfs
+How to report bugs
+Strange kernel messages
+Compilation problems with devfsd
+
+
+
+Making things work
+
+Here are some common questions and answers.
+
+
+
+Devfsd doesn't start
+
+Make sure you have compiled and installed devfsd
+Make sure devfsd is being started from your boot
+scripts
+Make sure you have configured your kernel to enable devfs (see
+below)
+Make sure devfs is mounted (see below)
+
+
+Devfsd is not managing all my permissions
+
+Make sure you are capturing the appropriate events. For example,
+device entries created by the kernel generate REGISTER events,
+but those created by devfsd generate CREATE events.
+
+
+Devfsd is not capturing all REGISTER events
+
+See the previous entry: you may need to capture CREATE events.
+
+
+X will not start
+
+Make sure you followed the steps 
+outlined above.
+
+
+Why don't my network devices appear in devfs?
+
+This is not a bug. Network devices have their own, completely separate
+namespace. They are accessed via socket(2) and
+setsockopt(2) calls, and thus require no device nodes. I have
+raised the possibilty of moving network devices into the device
+namespace, but have had no response.
+
+
+How can I test if I have devfs compiled into my kernel?
+
+All filesystems built-in or currently loaded are listed in
+/proc/filesystems. If you see a devfs entry, then
+you know that devfs was compiled into your kernel. If you have
+correctly configured and rebuilt your kernel, then devfs will be
+built-in. If you think you've configured it in, but
+/proc/filesystems doesn't show it, you've made a mistake.
+Common mistakes include:
+
+Using a 2.2.x kernel without applying the devfs patch (if you
+don't know how to patch your kernel, use 2.4.x instead, don't bother
+asking me how to patch)
+Forgetting to set CONFIG_EXPERIMENTAL=y
+Forgetting to set CONFIG_DEVFS_FS=y
+Forgetting to set CONFIG_DEVFS_MOUNT=y (if you want devfs
+to be automatically mounted at boot)
+Editing your .config manually, instead of using make
+config or make xconfig
+Forgetting to run make dep; make clean after changing the
+configuration and before compiling
+Forgetting to compile your kernel and modules
+Forgetting to install your kernel
+Forgetting to install your modules
+
+Please check twice that you've done all these steps before sending in
+a bug report.
+
+
+
+How can I test if devfs is mounted on /dev?
+
+The device filesystem will always create an entry called
+".devfsd", which is used to communicate with the daemon. Even
+if the daemon is not running, this entry will exist. Testing for the
+existence of this entry is the approved method of determining if devfs
+is mounted or not. Note that the type of entry (i.e. regular file,
+character device, named pipe, etc.) may change without notice. Only
+the existence of the entry should be relied upon.
+
+
+When I start devfsd, I see the error:
+Error opening file: ".devfsd"   No such file or directory?
+
+This means that devfs is not mounted. Make sure you have devfs mounted.
+
+
+How do I mount devfs?
+
+First make sure you have devfs compiled into your kernel (see
+above). Then you will either need to:
+
+set CONFIG_DEVFS_MOUNT=y in your kernel config
+pass devfs=mount to your boot loader
+mount devfs manually in your boot scripts with:
+mount -t none devfs /dev
+
+
+
+Mount by volume LABEL=<label> doesn't work with
+devfs
+
+Most probably you are not mounting devfs onto /dev. What
+happens is that if your kernel config has CONFIG_DEVFS_FS=y
+then the contents of /proc/partitions will have the devfs
+names (such as scsi/host0/bus0/target0/lun0/part1). The
+contents of /proc/partitions are used by mount(8) when
+mounting by volume label. If devfs is not mounted on /dev,
+then mount(8) will fail to find devices. The solution is to
+make sure that devfs is mounted on /dev. See above for how to
+do that.
+
+
+I have extra or incorrect entries in /dev
+
+You may have stale entries in your dev-state area. Check for a
+RESTORE configuration line in your devfsd configuration
+(typically /etc/devfsd.conf). If you have this line, check
+the contents of the specified directory for stale entries. Remove
+any entries which are incorrect, then reboot.
+
+
+I get "Unable to open initial console" messages at boot
+
+This usually happens when you don't have devfs automounted onto
+/dev at boot time, and there is no valid
+/dev/console entry on your root file-system. Create a valid
+/dev/console device node.
+
+
+
+
+
+Alternatives to devfs
+
+I've attempted to collate all the anti-devfs proposals and explain
+their limitations. Under construction.
+
+
+Why not just pass device create/remove events to a daemon?
+
+Here the suggestion is to develop an API in the kernel so that devices
+can register create and remove events, and a daemon listens for those
+events. The daemon would then populate/depopulate /dev (which
+resides on disc).
+
+This has several limitations:
+
+
+it only works for modules loaded and unloaded (or devices inserted
+and removed) after the kernel has finished booting. Without a database
+of events, there is no way the daemon could fully populate
+/dev
+
+
+if you add a database to this scheme, the question is then how to
+present that database to user-space. If you make it a list of strings
+with embedded event codes which are passed through a pipe to the
+daemon, then this is only of use to the daemon. I would argue that the
+natural way to present this data is via a filesystem (since many of
+the events will be of a hierarchical nature), such as devfs.
+Presenting the data as a filesystem makes it easy for the user to see
+what is available and also makes it easy to write scripts to scan the
+"database"
+
+
+the tight binding between device nodes and drivers is no longer
+possible (requiring the otherwise perfectly avoidable
+table lookups)
+
+
+you cannot catch inode lookup events on /dev which means
+that module autoloading requires device nodes to be created. This is a
+problem, particularly for drivers where only a few inodes are created
+from a potentially large set
+
+
+this technique can't be used when the root FS is mounted
+read-only
+
+
+
+
+Just implement a better scsidev
+
+This suggestion involves taking the scsidev programme and
+extending it to scan for all devices, not just SCSI devices. The
+scsidev programme works by scanning /proc/scsi
+
+Problems:
+
+
+the kernel does not currently provide a list of all devices
+available. Not all drivers register entries in /proc or
+generate kernel messages
+
+
+there is no uniform mechanism to register devices other than the
+devfs API
+
+
+implementing such an API is then the same as the
+proposal above
+
+
+
+
+Put /dev on a ramdisc
+
+This suggestion involves creating a ramdisc and populating it with
+device nodes and then mounting it over /dev.
+
+Problems:
+
+
+
+this doesn't help when mounting the root filesystem, since you
+still need a device node to do that
+
+
+if you want to use this technique for the root device node as
+well, you need to use initrd. This complicates the booting sequence
+and makes it significantly harder to administer and configure. The
+initrd is essentially opaque, robbing the system administrator of easy
+configuration
+
+
+insufficient information is available to correctly populate the
+ramdisc. So we come back to the
+proposal above to "solve" this
+
+
+a ramdisc-based solution would take more kernel memory, since the
+backing store would be (at best) normal VFS inodes and dentries, which
+take 284 bytes and 112 bytes, respectively, for each entry. Compare
+that to 72 bytes for devfs
+
+
+
+
+Do nothing: there's no problem
+
+Sometimes people can be heard to claim that the existing scheme is
+fine. This is what they're ignoring:
+
+
+device number size (8 bits each for major and minor) is a real
+limitation, and must be fixed somehow. Systems with large numbers of
+SCSI devices, for example, will continue to consume the remaining
+unallocated major numbers. USB will also need to push beyond the 8 bit
+minor limitation
+
+
+simply increasing the device number size is insufficient. Apart
+from causing a lot of pain, it doesn't solve the management issues
+of a /dev with thousands or more device nodes
+
+
+ignoring the problem of a huge /dev will not make it go
+away, and dismisses the legitimacy of a large number of people who
+want a dynamic /dev
+
+
+the standard response then becomes: "write a device management
+daemon", which brings us back to the
+proposal above
+
+
+
+
+What I don't like about devfs
+
+Here are some common complaints about devfs, and some suggestions and
+solutions that may make it more palatable for you. I can't please
+everybody, but I do try :-)
+
+I hate the naming scheme
+
+First, remember that no naming scheme will please everybody. You hate
+the scheme, others love it. Who's to say who's right and who's wrong?
+Ultimately, the person who writes the code gets to choose, and what
+exists now is a combination of the choices made by the
+devfs author and the
+kernel maintainer (Linus).
+
+However, not all is lost. If you want to create your own naming
+scheme, it is a simple matter to write a standalone script, hack
+devfsd, or write a script called by devfsd. You can create whatever
+naming scheme you like.
+
+Further, if you want to remove all traces of the devfs naming scheme
+from /dev, you can mount devfs elsewhere (say
+/devfs) and populate /dev with links into
+/devfs. This population can be automated using devfsd if you
+wish.
+
+You can even use the VFS binding facility to make the links, rather
+than using symbolic links. This way, you don't even have to see the
+"destination" of these symbolic links.
+
+Devfs puts policy into the kernel
+
+There's already policy in the kernel. Device numbers are in fact
+policy (why should the kernel dictate what device numbers I use?).
+Face it, some policy has to be in the kernel. The real difference
+between device names as policy and device numbers as policy is that
+no one will use device numbers directly, because device
+numbers are devoid of meaning to humans and are ugly. At least with
+the devfs device names, (even though you can add your own naming
+scheme) some people will use the devfs-supplied names directly. This
+offends some people :-)
+
+Devfs is bloatware
+
+This is not even remotely true. As shown above,
+both code and data size are quite modest.
+
+
+How to report bugs
+
+If you have (or think you have) a bug with devfs, please follow the
+steps below:
+
+
+
+make sure you have enabled debugging output when configuring your
+kernel. You will need to set (at least) the following config options:
+
+CONFIG_DEVFS_DEBUG=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_SLAB=y
+
+
+
+please make sure you have the latest devfs patches applied. The
+latest kernel version might not have the latest devfs patches applied
+yet (Linus is very busy)
+
+
+save a copy of your complete kernel logs (preferably by
+using the dmesg programme) for later inclusion in your bug
+report. You may need to use the -s switch to increase the
+internal buffer size so you can capture all the boot messages.
+Don't edit or trim the dmesg output
+
+
+
+
+try booting with devfs=dall passed to the kernel boot
+command line (read the documentation on your bootloader on how to do
+this), and save the result to a file. This may be quite verbose, and
+it may overflow the messages buffer, but try to get as much of it as
+you can
+
+
+send a copy of your devfsd configuration file(s)
+
+send the bug report to me first.
+Don't expect that I will see it if you post it to the linux-kernel
+mailing list. Include all the information listed above, plus
+anything else that you think might be relevant. Put the string
+devfs somewhere in the subject line, so my mail filters mark
+it as urgent
+
+
+
+
+Here is a general guide on how to ask questions in a way that greatly
+improves your chances of getting a reply:
+
+http://www.tuxedo.org/~esr/faqs/smart-questions.html. If you have
+a bug to report, you should also read
+
+http://www.chiark.greenend.org.uk/~sgtatham/bugs.html.
+
+
+Strange kernel messages
+
+You may see devfs-related messages in your kernel logs. Below are some
+messages and what they mean (and what you should do about them, if
+anything).
+
+
+
+devfs_register(fred): could not append to parent, err: -17
+
+You need to check what the error code means, but usually 17 means
+EEXIST. This means that a driver attempted to create an entry
+fred in a directory, but there already was an entry with that
+name. This is often caused by flawed boot scripts which untar a bunch
+of inodes into /dev, as a way to restore permissions. This
+message is harmless, as the device nodes will still
+provide access to the driver (unless you use the devfs=only
+boot option, which is only for dedicated souls:-). If you want to get
+rid of these annoying messages, upgrade to devfsd-v1.3.20 and use the
+recommended RESTORE directive to restore permissions.
+
+
+devfs_mk_dir(bill): using old entry in dir: c1808724 ""
+
+This is similar to the message above, except that a driver attempted
+to create a directory named bill, and the parent directory
+has an entry with the same name. In this case, to ensure that drivers
+continue to work properly, the old entry is re-used and given to the
+driver. In 2.5 kernels, the driver is given a NULL entry, and thus,
+under rare circumstances, may not create the require device nodes.
+The solution is the same as above.
+
+
+
+
+
+Compilation problems with devfsd
+
+Usually, you can compile devfsd just by typing in
+make in the source directory, followed by a make
+install (as root). Sometimes, you may have problems, particularly
+on broken configurations.
+
+
+
+error messages relating to DEVFSD_NOTIFY_DELETE
+
+This happened because you have an ancient set of kernel headers
+installed in /usr/include/linux or /usr/src/linux.
+Install kernel 2.4.10 or later. You may need to pass the
+KERNEL_DIR variable to make (if you did not install
+the new kernel sources as /usr/src/linux), or you may copy
+the devfs_fs.h file in the kernel source tree into
+/usr/include/linux.
+
+
+
+
+-----------------------------------------------------------------------------
+
+
+Other resources
+
+
+
+Douglas Gilbert has written a useful document at
+
+http://www.torque.net/sg/devfs_scsi.html which
+explores the SCSI subsystem and how it interacts with devfs
+
+
+Douglas Gilbert has written another useful document at
+
+http://www.torque.net/scsi/SCSI-2.4-HOWTO/ which
+discusses the Linux SCSI subsystem in 2.4.
+
+
+Johannes Erdfelt has started a discussion paper on Linux and
+hot-swap devices, describing what the requirements are for a scalable
+solution and how and why he's used devfs+devfsd. Note that this is an
+early draft only, available in plain text form at:
+
+http://johannes.erdfelt.com/hotswap.txt.
+Johannes has promised a HTML version will follow.
+
+
+I presented an invited 
+paper
+at the
+
+2nd Annual Storage Management Workshop held in Miamia, Florida,
+U.S.A. in October 2000.
+
+
+
+
+-----------------------------------------------------------------------------
+
+
+Translations of this document
+
+This document has been translated into other languages.
+
+
+
+
+The document master (in English) by rgooch@atnf.csiro.au is
+available at
+
+http://www.atnf.csiro.au/~rgooch/linux/docs/devfs.html
+
+
+
+A Korean translation by viatoris@nownuri.net is available at
+
+http://your.destiny.pe.kr/devfs/devfs.html
+
+
+
+
+-----------------------------------------------------------------------------
+Most flags courtesy of ITA's 
+Flags of All Countries
+used with permission. 
diff -urN linux-2.6.19.old/Documentation/filesystems/devfs/ToDo linux-2.6.19.dev/Documentation/filesystems/devfs/ToDo
--- linux-2.6.19.old/Documentation/filesystems/devfs/ToDo	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/Documentation/filesystems/devfs/ToDo	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,40 @@
+		Device File System (devfs) ToDo List
+
+		Richard Gooch <rgooch@atnf.csiro.au>
+
+			      3-JUL-2000
+
+This is a list of things to be done for better devfs support in the
+Linux kernel. If you'd like to contribute to the devfs, please have a
+look at this list for anything that is unallocated. Also, if there are
+items missing (surely), please contact me so I can add them to the
+list (preferably with your name attached to them:-).
+
+
+- >256 ptys
+  Thanks to C. Scott Ananian <cananian@alumni.princeton.edu>
+
+- Amiga floppy driver (drivers/block/amiflop.c)
+
+- Atari floppy driver (drivers/block/ataflop.c)
+
+- SWIM3 (Super Woz Integrated Machine 3) floppy driver (drivers/block/swim3.c)
+
+- Amiga ZorroII ramdisc driver (drivers/block/z2ram.c)
+
+- Parallel port ATAPI CD-ROM (drivers/block/paride/pcd.c)
+
+- Parallel port ATAPI floppy (drivers/block/paride/pf.c)
+
+- AP1000 block driver (drivers/ap1000/ap.c, drivers/ap1000/ddv.c)
+
+- Archimedes floppy (drivers/acorn/block/fd1772.c)
+
+- MFM hard drive (drivers/acorn/block/mfmhd.c)
+
+- I2O block device (drivers/message/i2o/i2o_block.c)
+
+- ST-RAM device (arch/m68k/atari/stram.c)
+
+- Raw devices
+
diff -urN linux-2.6.19.old/Documentation/ioctl-number.txt linux-2.6.19.dev/Documentation/ioctl-number.txt
--- linux-2.6.19.old/Documentation/ioctl-number.txt	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/Documentation/ioctl-number.txt	2006-12-14 03:12:59.000000000 +0100
@@ -119,6 +119,7 @@
 'c'	00-7F	linux/comstats.h	conflict!
 'c'	00-7F	linux/coda.h		conflict!
 'd'	00-FF	linux/char/drm/drm/h	conflict!
+'d'	00-1F	linux/devfs_fs.h	conflict!
 'd'	00-DF	linux/video_decoder.h	conflict!
 'd'	F0-FF	linux/digi1.h
 'e'	all	linux/digi1.h		conflict!
diff -urN linux-2.6.19.old/Documentation/kernel-parameters.txt linux-2.6.19.dev/Documentation/kernel-parameters.txt
--- linux-2.6.19.old/Documentation/kernel-parameters.txt	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/Documentation/kernel-parameters.txt	2006-12-14 03:12:59.000000000 +0100
@@ -35,6 +35,7 @@
 	APM	Advanced Power Management support is enabled.
 	AX25	Appropriate AX.25 support is enabled.
 	CD	Appropriate CD support is enabled.
+	DEVFS	devfs support is enabled.
 	DRM	Direct Rendering Management support is enabled.
 	EDD	BIOS Enhanced Disk Drive Services (EDD) is enabled
 	EFI	EFI Partitioning (GPT) is enabled
@@ -456,6 +457,9 @@
 			Format: <area>[,<node>]
 			See also Documentation/networking/decnet.txt.
 
+	devfs=		[DEVFS]
+			See Documentation/filesystems/devfs/boot-options.
+
 	dhash_entries=	[KNL]
 			Set number of hash buckets for dentry cache.
 
diff -urN linux-2.6.19.old/drivers/block/acsi.c linux-2.6.19.dev/drivers/block/acsi.c
--- linux-2.6.19.old/drivers/block/acsi.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/acsi.c	2006-12-14 03:12:59.000000000 +0100
@@ -1731,10 +1731,13 @@
 		struct gendisk *disk = acsi_gendisk[i];
 		sprintf(disk->disk_name, "ad%c", 'a'+i);
 		aip = &acsi_info[NDevices];
+		sprintf(disk->devfs_name, "ad/target%d/lun%d", aip->target, aip->lun);
 		disk->major = ACSI_MAJOR;
 		disk->first_minor = i << 4;
-		if (acsi_info[i].type != HARDDISK)
+		if (acsi_info[i].type != HARDDISK) {
 			disk->minors = 1;
+			strcat(disk->devfs_name, "/disc");
+		}
 		disk->fops = &acsi_fops;
 		disk->private_data = &acsi_info[i];
 		set_capacity(disk, acsi_info[i].size);
diff -urN linux-2.6.19.old/drivers/block/acsi_slm.c linux-2.6.19.dev/drivers/block/acsi_slm.c
--- linux-2.6.19.old/drivers/block/acsi_slm.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/acsi_slm.c	2006-12-14 03:12:59.000000000 +0100
@@ -65,6 +65,7 @@
 #include <linux/time.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
 
 #include <asm/pgtable.h>
@@ -1004,6 +1005,11 @@
 	BufferP = SLMBuffer;
 	SLMState = IDLE;
 	
+	devfs_mk_dir("slm");
+	for (i = 0; i < MAX_SLM; i++) {
+		devfs_mk_cdev(MKDEV(ACSI_MAJOR, i),
+				S_IFCHR|S_IRUSR|S_IWUSR, "slm/%d", i);
+	}
 	return 0;
 }
 
@@ -1026,6 +1032,10 @@
 
 void cleanup_module(void)
 {
+	int i;
+	for (i = 0; i < MAX_SLM; i++)
+		devfs_remove("slm/%d", i);
+	devfs_remove("slm");
 	if (unregister_chrdev( ACSI_MAJOR, "slm" ) != 0)
 		printk( KERN_ERR "acsi_slm: cleanup_module failed\n");
 	atari_stram_free( SLMBuffer );
diff -urN linux-2.6.19.old/drivers/block/cpqarray.c linux-2.6.19.dev/drivers/block/cpqarray.c
--- linux-2.6.19.old/drivers/block/cpqarray.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/cpqarray.c	2006-12-14 03:12:59.000000000 +0100
@@ -32,6 +32,7 @@
 #include <linux/blkpg.h>
 #include <linux/timer.h>
 #include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/init.h>
 #include <linux/hdreg.h>
 #include <linux/spinlock.h>
@@ -346,6 +347,7 @@
 	for(j = 0; j < NWD; j++) {
 		if (ida_gendisk[i][j]->flags & GENHD_FL_UP)
 			del_gendisk(ida_gendisk[i][j]);
+		devfs_remove("ida/c%dd%d",i,j);
 		put_disk(ida_gendisk[i][j]);
 	}
 	blk_cleanup_queue(hba[i]->queue);
@@ -1808,6 +1810,8 @@
 
 				}
 
+				sprintf(disk->devfs_name, "ida/c%dd%d", ctlr, log_unit);
+
 				info_p->phys_drives =
 				    sense_config_buf->ctlr_phys_drv;
 				info_p->drv_assign_map
@@ -1843,6 +1847,7 @@
 		}
 	}
 
+	devfs_remove("ida");
 	remove_proc_entry("cpqarray", proc_root_driver);
 }
 
diff -urN linux-2.6.19.old/drivers/block/DAC960.c linux-2.6.19.dev/drivers/block/DAC960.c
--- linux-2.6.19.old/drivers/block/DAC960.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/DAC960.c	2006-12-14 03:12:59.000000000 +0100
@@ -2530,6 +2530,7 @@
 	blk_queue_max_sectors(RequestQueue, Controller->MaxBlocksPerCommand);
 	disk->queue = RequestQueue;
 	sprintf(disk->disk_name, "rd/c%dd%d", Controller->ControllerNumber, n);
+	sprintf(disk->devfs_name, "rd/host%d/target%d", Controller->ControllerNumber, n);
 	disk->major = MajorNumber;
 	disk->first_minor = n << DAC960_MaxPartitionsBits;
 	disk->fops = &DAC960_BlockDeviceOperations;
diff -urN linux-2.6.19.old/drivers/block/floppy.c linux-2.6.19.dev/drivers/block/floppy.c
--- linux-2.6.19.old/drivers/block/floppy.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/floppy.c	2006-12-14 03:12:59.000000000 +0100
@@ -177,6 +177,7 @@
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/platform_device.h>
 #include <linux/buffer_head.h>	/* for invalidate_buffers() */
 #include <linux/mutex.h>
@@ -223,6 +224,7 @@
 static unsigned short virtual_dma_port = 0x3f0;
 irqreturn_t floppy_interrupt(int irq, void *dev_id);
 static int set_dor(int fdc, char mask, char data);
+static void register_devfs_entries(int drive) __init;
 
 #define K_64	0x10000		/* 64KB */
 
@@ -3652,6 +3654,7 @@
 				first = 0;
 			}
 			printk("%s fd%d is %s", prepend, drive, name);
+			register_devfs_entries(drive);
 		}
 		*UDP = *params;
 	}
@@ -3921,6 +3924,23 @@
 	.revalidate_disk = floppy_revalidate,
 };
 
+static void __init register_devfs_entries(int drive)
+{
+	int base_minor = (drive < 4) ? drive : (124 + drive);
+
+	if (UDP->cmos < ARRAY_SIZE(default_drive_params)) {
+		int i = 0;
+		do {
+			int minor = base_minor + (table_sup[UDP->cmos][i] << 2);
+
+			devfs_mk_bdev(MKDEV(FLOPPY_MAJOR, minor),
+				      S_IFBLK | S_IRUSR | S_IWUSR | S_IRGRP |
+				      S_IWGRP, "floppy/%d%s", drive,
+				      table[table_sup[UDP->cmos][i]]);
+		} while (table_sup[UDP->cmos][i++]);
+	}
+}
+
 /*
  * Floppy Driver initialization
  * =============================
@@ -4201,9 +4221,11 @@
 		motor_off_timer[dr].function = motor_off_callback;
 	}
 
+	devfs_mk_dir("floppy");
+
 	err = register_blkdev(FLOPPY_MAJOR, "fd");
 	if (err)
-		goto out_put_disk;
+		goto out_devfs_remove;
 
 	floppy_queue = blk_init_queue(do_fd_request, &floppy_lock);
 	if (!floppy_queue) {
@@ -4354,6 +4376,8 @@
 	blk_cleanup_queue(floppy_queue);
 out_unreg_blkdev:
 	unregister_blkdev(FLOPPY_MAJOR, "fd");
+out_devfs_remove:
+	devfs_remove("floppy");
 out_put_disk:
 	while (dr--) {
 		del_timer(&motor_off_timer[dr]);
@@ -4514,6 +4538,19 @@
 
 static char *floppy;
 
+static void unregister_devfs_entries(int drive)
+{
+	int i;
+
+	if (UDP->cmos < ARRAY_SIZE(default_drive_params)) {
+		i = 0;
+		do {
+			devfs_remove("floppy/%d%s", drive,
+				     table[table_sup[UDP->cmos][i]]);
+		} while (table_sup[UDP->cmos][i++]);
+	}
+}
+
 static void __init parse_floppy_cfg_string(char *cfg)
 {
 	char *ptr;
@@ -4550,11 +4587,13 @@
 		if ((allowed_drive_mask & (1 << drive)) &&
 		    fdc_state[FDC(drive)].version != FDC_NONE) {
 			del_gendisk(disks[drive]);
+			unregister_devfs_entries(drive);
 			device_remove_file(&floppy_device[drive].dev, &dev_attr_cmos);
 			platform_device_unregister(&floppy_device[drive]);
 		}
 		put_disk(disks[drive]);
 	}
+	devfs_remove("floppy");
 
 	del_timer_sync(&fd_timeout);
 	del_timer_sync(&fd_timer);
diff -urN linux-2.6.19.old/drivers/block/loop.c linux-2.6.19.dev/drivers/block/loop.c
--- linux-2.6.19.old/drivers/block/loop.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/loop.c	2006-12-14 03:12:59.000000000 +0100
@@ -62,6 +62,7 @@
 #include <linux/blkdev.h>
 #include <linux/blkpg.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
 #include <linux/swap.h>
 #include <linux/slab.h>
@@ -1426,6 +1427,8 @@
 			goto out_mem3;
 	}
 
+	devfs_mk_dir("loop");
+
 	for (i = 0; i < max_loop; i++) {
 		struct loop_device *lo = &loop_dev[i];
 		struct gendisk *disk = disks[i];
@@ -1443,6 +1446,7 @@
 		disk->first_minor = i;
 		disk->fops = &lo_fops;
 		sprintf(disk->disk_name, "loop%d", i);
+		sprintf(disk->devfs_name, "loop/%d", i);
 		disk->private_data = lo;
 		disk->queue = lo->lo_queue;
 	}
@@ -1456,6 +1460,7 @@
 out_mem4:
 	while (i--)
 		blk_cleanup_queue(loop_dev[i].lo_queue);
+	devfs_remove("loop");
 	i = max_loop;
 out_mem3:
 	while (i--)
@@ -1478,6 +1483,7 @@
 		blk_cleanup_queue(loop_dev[i].lo_queue);
 		put_disk(disks[i]);
 	}
+	devfs_remove("loop");
 	if (unregister_blkdev(LOOP_MAJOR, "loop"))
 		printk(KERN_WARNING "loop: cannot unregister blkdev\n");
 
diff -urN linux-2.6.19.old/drivers/block/nbd.c linux-2.6.19.dev/drivers/block/nbd.c
--- linux-2.6.19.old/drivers/block/nbd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/nbd.c	2006-12-14 03:12:59.000000000 +0100
@@ -29,6 +29,8 @@
 #include <linux/kernel.h>
 #include <net/sock.h>
 
+#include <linux/devfs_fs_kernel.h>
+
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/types.h>
@@ -643,6 +645,7 @@
 	printk(KERN_INFO "nbd: registered device at major %d\n", NBD_MAJOR);
 	dprintk(DBG_INIT, "nbd: debugflags=0x%x\n", debugflags);
 
+	devfs_mk_dir("nbd");
 	for (i = 0; i < nbds_max; i++) {
 		struct gendisk *disk = nbd_dev[i].disk;
 		nbd_dev[i].file = NULL;
@@ -660,6 +663,7 @@
 		disk->private_data = &nbd_dev[i];
 		disk->flags |= GENHD_FL_SUPPRESS_PARTITION_INFO;
 		sprintf(disk->disk_name, "nbd%d", i);
+		sprintf(disk->devfs_name, "nbd/%d", i);
 		set_capacity(disk, 0x7ffffc00ULL << 1); /* 2 TB */
 		add_disk(disk);
 	}
@@ -685,6 +689,7 @@
 			put_disk(disk);
 		}
 	}
+	devfs_remove("nbd");
 	unregister_blkdev(NBD_MAJOR, "nbd");
 	printk(KERN_INFO "nbd: unregistered device at major %d\n", NBD_MAJOR);
 }
diff -urN linux-2.6.19.old/drivers/block/paride/pg.c linux-2.6.19.dev/drivers/block/paride/pg.c
--- linux-2.6.19.old/drivers/block/paride/pg.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/paride/pg.c	2006-12-14 03:12:59.000000000 +0100
@@ -156,6 +156,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/mtio.h>
@@ -673,15 +674,25 @@
 		err = PTR_ERR(pg_class);
 		goto out_chrdev;
 	}
+	devfs_mk_dir("pg");
 	for (unit = 0; unit < PG_UNITS; unit++) {
 		struct pg *dev = &devices[unit];
-		if (dev->present)
+		if (dev->present) {
 			class_device_create(pg_class, NULL, MKDEV(major, unit),
 					NULL, "pg%u", unit);
+			err = devfs_mk_cdev(MKDEV(major, unit),
+				      S_IFCHR | S_IRUSR | S_IWUSR, "pg/%u",
+				      unit);
+			if (err) 
+				goto out_class;
+		}
 	}
 	err = 0;
 	goto out;
 
+out_class:
+	class_device_destroy(pg_class, MKDEV(major, unit));
+	class_destroy(pg_class);
 out_chrdev:
 	unregister_chrdev(major, "pg");
 out:
@@ -694,10 +705,13 @@
 
 	for (unit = 0; unit < PG_UNITS; unit++) {
 		struct pg *dev = &devices[unit];
-		if (dev->present)
+		if (dev->present) {
 			class_device_destroy(pg_class, MKDEV(major, unit));
+			devfs_remove("pg/%u", unit);
+		}
 	}
 	class_destroy(pg_class);
+	devfs_remove("pg");
 	unregister_chrdev(major, name);
 
 	for (unit = 0; unit < PG_UNITS; unit++) {
diff -urN linux-2.6.19.old/drivers/block/paride/pt.c linux-2.6.19.dev/drivers/block/paride/pt.c
--- linux-2.6.19.old/drivers/block/paride/pt.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/paride/pt.c	2006-12-14 03:12:59.000000000 +0100
@@ -141,6 +141,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/mtio.h>
@@ -970,15 +971,32 @@
 		goto out_chrdev;
 	}
 
+	devfs_mk_dir("pt");
 	for (unit = 0; unit < PT_UNITS; unit++)
 		if (pt[unit].present) {
 			class_device_create(pt_class, NULL, MKDEV(major, unit),
 					NULL, "pt%d", unit);
+			err = devfs_mk_cdev(MKDEV(major, unit),
+				      S_IFCHR | S_IRUSR | S_IWUSR,
+				      "pt/%d", unit);
+			if (err) {
+				class_device_destroy(pt_class, MKDEV(major, unit));
+				goto out_class;
+			}
 			class_device_create(pt_class, NULL, MKDEV(major, unit + 128),
 					NULL, "pt%dn", unit);
+			err = devfs_mk_cdev(MKDEV(major, unit + 128),
+				      S_IFCHR | S_IRUSR | S_IWUSR,
+				      "pt/%dn", unit);
+			if (err) {
+				class_device_destroy(pt_class, MKDEV(major, unit + 128));
+				goto out_class;
+			}
 		}
 	goto out;
 
+out_class:
+	class_destroy(pt_class);
 out_chrdev:
 	unregister_chrdev(major, "pt");
 out:
@@ -991,9 +1009,12 @@
 	for (unit = 0; unit < PT_UNITS; unit++)
 		if (pt[unit].present) {
 			class_device_destroy(pt_class, MKDEV(major, unit));
+			devfs_remove("pt/%d", unit);
 			class_device_destroy(pt_class, MKDEV(major, unit + 128));
+			devfs_remove("pt/%dn", unit);
 		}
 	class_destroy(pt_class);
+	devfs_remove("pt");
 	unregister_chrdev(major, name);
 	for (unit = 0; unit < PT_UNITS; unit++)
 		if (pt[unit].present)
diff -urN linux-2.6.19.old/drivers/block/pktcdvd.c linux-2.6.19.dev/drivers/block/pktcdvd.c
--- linux-2.6.19.old/drivers/block/pktcdvd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/pktcdvd.c	2006-12-14 03:12:59.000000000 +0100
@@ -2613,6 +2613,7 @@
 static struct miscdevice pkt_misc = {
 	.minor 		= MISC_DYNAMIC_MINOR,
 	.name  		= DRIVER_NAME,
+	.devfs_name 	= "pktcdvd/control",
 	.fops  		= &pkt_ctl_fops
 };
 
diff -urN linux-2.6.19.old/drivers/block/ps2esdi.c linux-2.6.19.dev/drivers/block/ps2esdi.c
--- linux-2.6.19.old/drivers/block/ps2esdi.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/ps2esdi.c	2006-12-14 03:12:59.000000000 +0100
@@ -419,6 +419,7 @@
 		disk->major = PS2ESDI_MAJOR;
 		disk->first_minor = i<<6;
 		sprintf(disk->disk_name, "ed%c", 'a'+i);
+		sprintf(disk->devfs_name, "ed/target%d", i);
 		disk->fops = &ps2esdi_fops;
 		ps2esdi_gendisk[i] = disk;
 	}
diff -urN linux-2.6.19.old/drivers/block/rd.c linux-2.6.19.dev/drivers/block/rd.c
--- linux-2.6.19.old/drivers/block/rd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/rd.c	2006-12-14 03:12:59.000000000 +0100
@@ -49,6 +49,7 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/pagemap.h>
 #include <linux/blkdev.h>
 #include <linux/genhd.h>
@@ -410,6 +411,7 @@
 		put_disk(rd_disks[i]);
 		blk_cleanup_queue(rd_queue[i]);
 	}
+	devfs_remove("rd");
 	unregister_blkdev(RAMDISK_MAJOR, "ramdisk");
 }
 
@@ -445,6 +447,8 @@
 		goto out;
 	}
 
+	devfs_mk_dir("rd");
+
 	for (i = 0; i < CONFIG_BLK_DEV_RAM_COUNT; i++) {
 		struct gendisk *disk = rd_disks[i];
 
@@ -458,6 +462,7 @@
 		disk->queue = rd_queue[i];
 		disk->flags |= GENHD_FL_SUPPRESS_PARTITION_INFO;
 		sprintf(disk->disk_name, "ram%d", i);
+		sprintf(disk->devfs_name, "rd/%d", i);
 		set_capacity(disk, rd_size * 2);
 		add_disk(rd_disks[i]);
 	}
diff -urN linux-2.6.19.old/drivers/block/sx8.c linux-2.6.19.dev/drivers/block/sx8.c
--- linux-2.6.19.old/drivers/block/sx8.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/sx8.c	2006-12-14 03:12:59.000000000 +0100
@@ -18,6 +18,7 @@
 #include <linux/spinlock.h>
 #include <linux/blkdev.h>
 #include <linux/sched.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/interrupt.h>
 #include <linux/compiler.h>
 #include <linux/workqueue.h>
@@ -1509,6 +1510,7 @@
 		port->disk = disk;
 		sprintf(disk->disk_name, DRV_NAME "/%u",
 			(unsigned int) (host->id * CARM_MAX_PORTS) + i);
+		sprintf(disk->devfs_name, DRV_NAME "/%u_%u", host->id, i);
 		disk->major = host->major;
 		disk->first_minor = i * CARM_MINORS_PER_MAJOR;
 		disk->fops = &carm_bd_ops;
@@ -1670,6 +1672,8 @@
 	if (host->flags & FL_DYN_MAJOR)
 		host->major = rc;
 
+	devfs_mk_dir(DRV_NAME);
+
 	rc = carm_init_disks(host);
 	if (rc)
 		goto err_out_blkdev_disks;
@@ -1735,6 +1739,7 @@
 
 	free_irq(pdev->irq, host);
 	carm_free_disks(host);
+	devfs_remove(DRV_NAME);
 	unregister_blkdev(host->major, host->name);
 	if (host->major == 160)
 		clear_bit(0, &carm_major_alloc);
diff -urN linux-2.6.19.old/drivers/block/ub.c linux-2.6.19.dev/drivers/block/ub.c
--- linux-2.6.19.old/drivers/block/ub.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/ub.c	2006-12-14 03:12:59.000000000 +0100
@@ -24,10 +24,12 @@
 #include <linux/usb.h>
 #include <linux/usb_usual.h>
 #include <linux/blkdev.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/timer.h>
 #include <scsi/scsi.h>
 
 #define DRV_NAME "ub"
+#define DEVFS_NAME DRV_NAME
 
 #define UB_MAJOR 180
 
@@ -2301,6 +2303,7 @@
 		goto err_diskalloc;
 
 	sprintf(disk->disk_name, DRV_NAME "%c", lun->id + 'a');
+	sprintf(disk->devfs_name, DEVFS_NAME "/%c", lun->id + 'a');
 	disk->major = UB_MAJOR;
 	disk->first_minor = lun->id * UB_PARTS_PER_LUN;
 	disk->fops = &ub_bd_fops;
@@ -2454,6 +2457,7 @@
 
 	if ((rc = register_blkdev(UB_MAJOR, DRV_NAME)) != 0)
 		goto err_regblkdev;
+	devfs_mk_dir(DEVFS_NAME);
 
 	if ((rc = usb_register(&ub_driver)) != 0)
 		goto err_register;
@@ -2462,6 +2466,7 @@
 	return 0;
 
 err_register:
+	devfs_remove(DEVFS_NAME);
 	unregister_blkdev(UB_MAJOR, DRV_NAME);
 err_regblkdev:
 	return rc;
@@ -2471,6 +2476,7 @@
 {
 	usb_deregister(&ub_driver);
 
+	devfs_remove(DEVFS_NAME);
 	unregister_blkdev(UB_MAJOR, DRV_NAME);
 	usb_usual_clear_present(USB_US_TYPE_UB);
 }
diff -urN linux-2.6.19.old/drivers/block/umem.c linux-2.6.19.dev/drivers/block/umem.c
--- linux-2.6.19.old/drivers/block/umem.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/umem.c	2006-12-14 03:12:59.000000000 +0100
@@ -1192,6 +1192,7 @@
 	for (i = 0; i < num_cards; i++) {
 		struct gendisk *disk = mm_gendisk[i];
 		sprintf(disk->disk_name, "umem%c", 'a'+i);
+		sprintf(disk->devfs_name, "umem/card%d", i);
 		spin_lock_init(&cards[i].lock);
 		disk->major = major_nr;
 		disk->first_minor  = i << MM_SHIFT;
diff -urN linux-2.6.19.old/drivers/block/viodasd.c linux-2.6.19.dev/drivers/block/viodasd.c
--- linux-2.6.19.old/drivers/block/viodasd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/viodasd.c	2006-12-14 03:12:59.000000000 +0100
@@ -59,6 +59,7 @@
  * numbers 0-255 we get a maximum of 32 disks.
  */
 #define VIOD_GENHD_NAME		"iseries/vd"
+#define VIOD_GENHD_DEVFS_NAME	"iseries/disc"
 
 #define VIOD_VERS		"1.64"
 
@@ -522,6 +523,8 @@
 	else
 		snprintf(g->disk_name, sizeof(g->disk_name),
 				VIOD_GENHD_NAME "%c", 'a' + (dev_no % 26));
+	snprintf(g->devfs_name, sizeof(g->devfs_name),
+			"%s%d", VIOD_GENHD_DEVFS_NAME, dev_no);
 	g->fops = &viodasd_fops;
 	g->queue = q;
 	g->private_data = d;
diff -urN linux-2.6.19.old/drivers/block/xd.c linux-2.6.19.dev/drivers/block/xd.c
--- linux-2.6.19.old/drivers/block/xd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/xd.c	2006-12-14 03:12:59.000000000 +0100
@@ -215,6 +215,7 @@
 		disk->major = XT_DISK_MAJOR;
 		disk->first_minor = i<<6;
 		sprintf(disk->disk_name, "xd%c", i+'a');
+		sprintf(disk->devfs_name, "xd/target%d", i);
 		disk->fops = &xd_fops;
 		disk->private_data = p;
 		disk->queue = xd_queue;
diff -urN linux-2.6.19.old/drivers/block/z2ram.c linux-2.6.19.dev/drivers/block/z2ram.c
--- linux-2.6.19.old/drivers/block/z2ram.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/block/z2ram.c	2006-12-14 03:12:59.000000000 +0100
@@ -354,6 +354,7 @@
     z2ram_gendisk->first_minor = 0;
     z2ram_gendisk->fops = &z2_fops;
     sprintf(z2ram_gendisk->disk_name, "z2ram");
+    strcpy(z2ram_gendisk->devfs_name, z2ram_gendisk->disk_name);
 
     z2ram_gendisk->queue = z2_queue;
     add_disk(z2ram_gendisk);
diff -urN linux-2.6.19.old/drivers/cdrom/aztcd.c linux-2.6.19.dev/drivers/cdrom/aztcd.c
--- linux-2.6.19.old/drivers/cdrom/aztcd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/aztcd.c	2006-12-14 03:12:59.000000000 +0100
@@ -1918,6 +1918,7 @@
 	azt_disk->first_minor = 0;
 	azt_disk->fops = &azt_fops;
 	sprintf(azt_disk->disk_name, "aztcd");
+	sprintf(azt_disk->devfs_name, "aztcd");
 	azt_disk->queue = azt_queue;
 	add_disk(azt_disk);
 	azt_invalidate_buffers();
diff -urN linux-2.6.19.old/drivers/cdrom/cdu31a.c linux-2.6.19.dev/drivers/cdrom/cdu31a.c
--- linux-2.6.19.old/drivers/cdrom/cdu31a.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/cdu31a.c	2006-12-14 03:12:59.000000000 +0100
@@ -161,6 +161,7 @@
 #include <linux/hdreg.h>
 #include <linux/genhd.h>
 #include <linux/ioport.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/string.h>
 #include <linux/slab.h>
 #include <linux/init.h>
diff -urN linux-2.6.19.old/drivers/cdrom/cm206.c linux-2.6.19.dev/drivers/cdrom/cm206.c
--- linux-2.6.19.old/drivers/cdrom/cm206.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/cm206.c	2006-12-14 03:12:59.000000000 +0100
@@ -187,6 +187,7 @@
 #include <linux/interrupt.h>
 #include <linux/timer.h>
 #include <linux/cdrom.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/ioport.h>
 #include <linux/mm.h>
 #include <linux/slab.h>
diff -urN linux-2.6.19.old/drivers/cdrom/gscd.c linux-2.6.19.dev/drivers/cdrom/gscd.c
--- linux-2.6.19.old/drivers/cdrom/gscd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/gscd.c	2006-12-14 03:12:59.000000000 +0100
@@ -955,6 +955,7 @@
 	gscd_disk->first_minor = 0;
 	gscd_disk->fops = &gscd_fops;
 	sprintf(gscd_disk->disk_name, "gscd");
+	sprintf(gscd_disk->devfs_name, "gscd");
 
 	if (register_blkdev(MAJOR_NR, "gscd")) {
 		ret = -EIO;
diff -urN linux-2.6.19.old/drivers/cdrom/mcdx.c linux-2.6.19.dev/drivers/cdrom/mcdx.c
--- linux-2.6.19.old/drivers/cdrom/mcdx.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/mcdx.c	2006-12-14 03:12:59.000000000 +0100
@@ -74,6 +74,7 @@
 #include <linux/major.h>
 #define MAJOR_NR MITSUMI_X_CDROM_MAJOR
 #include <linux/blkdev.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include "mcdx.h"
 
diff -urN linux-2.6.19.old/drivers/cdrom/optcd.c linux-2.6.19.dev/drivers/cdrom/optcd.c
--- linux-2.6.19.old/drivers/cdrom/optcd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/optcd.c	2006-12-14 03:12:59.000000000 +0100
@@ -2033,6 +2033,7 @@
 	optcd_disk->first_minor = 0;
 	optcd_disk->fops = &opt_fops;
 	sprintf(optcd_disk->disk_name, "optcd");
+	sprintf(optcd_disk->devfs_name, "optcd");
 
 	if (!request_region(optcd_port, 4, "optcd")) {
 		printk(KERN_ERR "optcd: conflict, I/O port 0x%x already used\n",
diff -urN linux-2.6.19.old/drivers/cdrom/sbpcd.c linux-2.6.19.dev/drivers/cdrom/sbpcd.c
--- linux-2.6.19.old/drivers/cdrom/sbpcd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/sbpcd.c	2006-12-14 03:12:59.000000000 +0100
@@ -371,6 +371,7 @@
 #include <linux/kernel.h>
 #include <linux/cdrom.h>
 #include <linux/ioport.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/major.h>
 #include <linux/string.h>
 #include <linux/vmalloc.h>
@@ -5806,6 +5807,8 @@
 		return -ENOMEM;
 	}
 
+	devfs_mk_dir("sbp");
+
 	for (j=0;j<NR_SBPCD;j++)
 	{
 		struct cdrom_device_info * sbpcd_infop;
@@ -5867,6 +5870,7 @@
 		disk->fops = &sbpcd_bdops;
 		strcpy(disk->disk_name, sbpcd_infop->name);
 		disk->flags = GENHD_FL_CD;
+		sprintf(disk->devfs_name, "sbp/c0t%d", p->drv_id);
 		p->disk = disk;
 		if (register_cdrom(sbpcd_infop))
 		{
@@ -5901,6 +5905,7 @@
 		if (D_S[j].drv_id==-1) continue;
 		del_gendisk(D_S[j].disk);
 		put_disk(D_S[j].disk);
+		devfs_remove("sbp/c0t%d", j);
 		vfree(D_S[j].sbp_buf);
 		if (D_S[j].sbp_audsiz>0)
 			vfree(D_S[j].aud_buf);
@@ -5911,6 +5916,7 @@
 		}
 		vfree(D_S[j].sbpcd_infop);
 	}
+	devfs_remove("sbp");
 	msg(DBG_INF, "%s module released.\n", major_name);
 }
 
diff -urN linux-2.6.19.old/drivers/cdrom/sjcd.c linux-2.6.19.dev/drivers/cdrom/sjcd.c
--- linux-2.6.19.old/drivers/cdrom/sjcd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/sjcd.c	2006-12-14 03:12:59.000000000 +0100
@@ -1695,6 +1695,7 @@
 	sjcd_disk->first_minor = 0,
 	sjcd_disk->fops = &sjcd_fops,
 	sprintf(sjcd_disk->disk_name, "sjcd");
+	sprintf(sjcd_disk->devfs_name, "sjcd");
 
 	if (!request_region(sjcd_base, 4,"sjcd")) {
 		printk
diff -urN linux-2.6.19.old/drivers/cdrom/sonycd535.c linux-2.6.19.dev/drivers/cdrom/sonycd535.c
--- linux-2.6.19.old/drivers/cdrom/sonycd535.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/sonycd535.c	2006-12-14 03:12:59.000000000 +0100
@@ -1589,6 +1589,7 @@
 	cdu_disk->first_minor = 0;
 	cdu_disk->fops = &cdu_fops;
 	sprintf(cdu_disk->disk_name, "cdu");
+	sprintf(cdu_disk->devfs_name, "cdu535");
 
 	if (!request_region(sony535_cd_base_io, 4, CDU535_HANDLE)) {
 		printk(KERN_WARNING"sonycd535: Unable to request region 0x%x\n",
diff -urN linux-2.6.19.old/drivers/cdrom/viocd.c linux-2.6.19.dev/drivers/cdrom/viocd.c
--- linux-2.6.19.old/drivers/cdrom/viocd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/cdrom/viocd.c	2006-12-14 03:12:59.000000000 +0100
@@ -49,6 +49,7 @@
 #include <asm/iseries/vio.h>
 
 #define VIOCD_DEVICE			"iseries/vcd"
+#define VIOCD_DEVICE_DEVFS		"iseries/vcd"
 
 #define VIOCD_VERS "1.06"
 
@@ -687,6 +688,8 @@
 	gendisk->first_minor = deviceno;
 	strncpy(gendisk->disk_name, c->name,
 			sizeof(gendisk->disk_name));
+	snprintf(gendisk->devfs_name, sizeof(gendisk->devfs_name),
+			VIOCD_DEVICE_DEVFS "%d", deviceno);
 	blk_queue_max_hw_segments(q, 1);
 	blk_queue_max_phys_segments(q, 1);
 	blk_queue_max_sectors(q, 4096 / 512);
diff -urN linux-2.6.19.old/drivers/char/cyclades.c linux-2.6.19.dev/drivers/char/cyclades.c
--- linux-2.6.19.old/drivers/char/cyclades.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/cyclades.c	2006-12-14 03:12:59.000000000 +0100
@@ -5227,6 +5227,7 @@
     cy_serial_driver->owner = THIS_MODULE;
     cy_serial_driver->driver_name = "cyclades";
     cy_serial_driver->name = "ttyC";
+    cy_serial_driver->devfs_name = "tts/C";
     cy_serial_driver->major = CYCLADES_MAJOR;
     cy_serial_driver->minor_start = 0;
     cy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/dsp56k.c linux-2.6.19.dev/drivers/char/dsp56k.c
--- linux-2.6.19.old/drivers/char/dsp56k.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/dsp56k.c	2006-12-14 03:12:59.000000000 +0100
@@ -33,6 +33,7 @@
 #include <linux/fs.h>
 #include <linux/mm.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
 #include <linux/device.h>
 
@@ -517,9 +518,17 @@
 	}
 	class_device_create(dsp56k_class, NULL, MKDEV(DSP56K_MAJOR, 0), NULL, "dsp56k");
 
+	err = devfs_mk_cdev(MKDEV(DSP56K_MAJOR, 0),
+		      S_IFCHR | S_IRUSR | S_IWUSR, "dsp56k");
+	if(err)
+		goto out_class;
+
 	printk(banner);
 	goto out;
 
+out_class:
+	class_device_destroy(dsp56k_class, MKDEV(DSP56K_MAJOR, 0));
+	class_destroy(dsp56k_class);
 out_chrdev:
 	unregister_chrdev(DSP56K_MAJOR, "dsp56k");
 out:
@@ -532,6 +541,7 @@
 	class_device_destroy(dsp56k_class, MKDEV(DSP56K_MAJOR, 0));
 	class_destroy(dsp56k_class);
 	unregister_chrdev(DSP56K_MAJOR, "dsp56k");
+	devfs_remove("dsp56k");
 }
 module_exit(dsp56k_cleanup_driver);
 
diff -urN linux-2.6.19.old/drivers/char/dtlk.c linux-2.6.19.dev/drivers/char/dtlk.c
--- linux-2.6.19.old/drivers/char/dtlk.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/dtlk.c	2006-12-14 03:12:59.000000000 +0100
@@ -62,6 +62,7 @@
 #include <linux/init.h>		/* for __init, module_{init,exit} */
 #include <linux/poll.h>		/* for POLLIN, etc. */
 #include <linux/dtlk.h>		/* local header file for DoubleTalk values */
+#include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
 
 #ifdef TRACING
@@ -336,6 +337,9 @@
 	if (dtlk_dev_probe() == 0)
 		printk(", MAJOR %d\n", dtlk_major);
 
+	devfs_mk_cdev(MKDEV(dtlk_major, DTLK_MINOR),
+		       S_IFCHR | S_IRUSR | S_IWUSR, "dtlk");
+
 	init_timer(&dtlk_timer);
 	dtlk_timer.function = dtlk_timer_tick;
 	init_waitqueue_head(&dtlk_process_list);
@@ -353,6 +357,7 @@
 
 	dtlk_write_tts(DTLK_CLEAR);
 	unregister_chrdev(dtlk_major, "dtlk");
+	devfs_remove("dtlk");
 	release_region(dtlk_port_lpc, DTLK_IO_EXTENT);
 }
 
diff -urN linux-2.6.19.old/drivers/char/epca.c linux-2.6.19.dev/drivers/char/epca.c
--- linux-2.6.19.old/drivers/char/epca.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/epca.c	2006-12-14 03:12:59.000000000 +0100
@@ -1227,6 +1227,7 @@
 
 	pc_driver->owner = THIS_MODULE;
 	pc_driver->name = "ttyD"; 
+	pc_driver->devfs_name = "tts/D";
 	pc_driver->major = DIGI_MAJOR; 
 	pc_driver->minor_start = 0;
 	pc_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/esp.c linux-2.6.19.dev/drivers/char/esp.c
--- linux-2.6.19.old/drivers/char/esp.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/esp.c	2006-12-14 03:12:59.000000000 +0100
@@ -2448,6 +2448,7 @@
 	
 	esp_driver->owner = THIS_MODULE;
 	esp_driver->name = "ttyP";
+	esp_driver->devfs_name = "tts/P";
 	esp_driver->major = ESP_IN_MAJOR;
 	esp_driver->minor_start = 0;
 	esp_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/ftape/zftape/zftape-init.c linux-2.6.19.dev/drivers/char/ftape/zftape/zftape-init.c
--- linux-2.6.19.old/drivers/char/ftape/zftape/zftape-init.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/ftape/zftape/zftape-init.c	2006-12-14 03:12:59.000000000 +0100
@@ -32,6 +32,7 @@
 #endif
 #include <linux/fcntl.h>
 #include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include <linux/zftape.h>
 #include <linux/init.h>
@@ -330,11 +331,29 @@
 	zft_class = class_create(THIS_MODULE, "zft");
 	for (i = 0; i < 4; i++) {
 		class_device_create(zft_class, NULL, MKDEV(QIC117_TAPE_MAJOR, i), NULL, "qft%i", i);
+		devfs_mk_cdev(MKDEV(QIC117_TAPE_MAJOR, i),
+				S_IFCHR | S_IRUSR | S_IWUSR,
+				"qft%i", i);
 		class_device_create(zft_class, NULL, MKDEV(QIC117_TAPE_MAJOR, i + 4), NULL, "nqft%i", i);
+		devfs_mk_cdev(MKDEV(QIC117_TAPE_MAJOR, i + 4),
+				S_IFCHR | S_IRUSR | S_IWUSR,
+				"nqft%i", i);
 		class_device_create(zft_class, NULL, MKDEV(QIC117_TAPE_MAJOR, i + 16), NULL, "zqft%i", i);
+		devfs_mk_cdev(MKDEV(QIC117_TAPE_MAJOR, i + 16),
+				S_IFCHR | S_IRUSR | S_IWUSR,
+				"zqft%i", i);
 		class_device_create(zft_class, NULL, MKDEV(QIC117_TAPE_MAJOR, i + 20), NULL, "nzqft%i", i);
+		devfs_mk_cdev(MKDEV(QIC117_TAPE_MAJOR, i + 20),
+				S_IFCHR | S_IRUSR | S_IWUSR,
+				"nzqft%i", i);
 		class_device_create(zft_class, NULL, MKDEV(QIC117_TAPE_MAJOR, i + 32), NULL, "rawqft%i", i);
+		devfs_mk_cdev(MKDEV(QIC117_TAPE_MAJOR, i + 32),
+				S_IFCHR | S_IRUSR | S_IWUSR,
+				"rawqft%i", i);
 		class_device_create(zft_class, NULL, MKDEV(QIC117_TAPE_MAJOR, i + 36), NULL, "nrawrawqft%i", i);
+		devfs_mk_cdev(MKDEV(QIC117_TAPE_MAJOR, i + 36),
+				S_IFCHR | S_IRUSR | S_IWUSR,
+				"nrawqft%i", i);
 	}
 
 #ifdef CONFIG_ZFT_COMPRESSOR
@@ -360,11 +379,17 @@
 		TRACE(ft_t_info, "successful");
 	}
         for (i = 0; i < 4; i++) {
+		devfs_remove("qft%i", i);
 		class_device_destroy(zft_class, MKDEV(QIC117_TAPE_MAJOR, i));
+		devfs_remove("nqft%i", i);
 		class_device_destroy(zft_class, MKDEV(QIC117_TAPE_MAJOR, i + 4));
+		devfs_remove("zqft%i", i);
 		class_device_destroy(zft_class, MKDEV(QIC117_TAPE_MAJOR, i + 16));
+		devfs_remove("nzqft%i", i);
 		class_device_destroy(zft_class, MKDEV(QIC117_TAPE_MAJOR, i + 20));
+		devfs_remove("rawqft%i", i);
 		class_device_destroy(zft_class, MKDEV(QIC117_TAPE_MAJOR, i + 32));
+		devfs_remove("nrawqft%i", i);
 		class_device_destroy(zft_class, MKDEV(QIC117_TAPE_MAJOR, i + 36));
 	}
 	class_destroy(zft_class);
diff -urN linux-2.6.19.old/drivers/char/hvc_console.c linux-2.6.19.dev/drivers/char/hvc_console.c
--- linux-2.6.19.old/drivers/char/hvc_console.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/hvc_console.c	2006-12-14 03:12:59.000000000 +0100
@@ -822,6 +822,7 @@
 		return -ENOMEM;
 
 	drv->owner = THIS_MODULE;
+	drv->devfs_name = "hvc/";
 	drv->driver_name = "hvc";
 	drv->name = "hvc";
 	drv->major = HVC_MAJOR;
diff -urN linux-2.6.19.old/drivers/char/hvcs.c linux-2.6.19.dev/drivers/char/hvcs.c
--- linux-2.6.19.old/drivers/char/hvcs.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/hvcs.c	2006-12-14 03:12:59.000000000 +0100
@@ -1361,6 +1361,7 @@
 
 	hvcs_tty_driver->driver_name = hvcs_driver_name;
 	hvcs_tty_driver->name = hvcs_device_node;
+	hvcs_tty_driver->devfs_name = hvcs_device_node;
 
 	/*
 	 * We'll let the system assign us a major number, indicated by leaving
diff -urN linux-2.6.19.old/drivers/char/hvsi.c linux-2.6.19.dev/drivers/char/hvsi.c
--- linux-2.6.19.old/drivers/char/hvsi.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/hvsi.c	2006-12-14 03:12:59.000000000 +0100
@@ -1152,6 +1152,7 @@
 		return -ENOMEM;
 
 	hvsi_driver->owner = THIS_MODULE;
+	hvsi_driver->devfs_name = "hvsi/";
 	hvsi_driver->driver_name = "hvsi";
 	hvsi_driver->name = "hvsi";
 	hvsi_driver->major = HVSI_MAJOR;
diff -urN linux-2.6.19.old/drivers/char/ip2/ip2main.c linux-2.6.19.dev/drivers/char/ip2/ip2main.c
--- linux-2.6.19.old/drivers/char/ip2/ip2main.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/ip2/ip2main.c	2006-12-14 03:12:59.000000000 +0100
@@ -90,6 +90,7 @@
 #include <linux/module.h>
 #include <linux/signal.h>
 #include <linux/sched.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/timer.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
@@ -412,7 +413,9 @@
 			/* free io addresses and Tibet */
 			release_region( ip2config.addr[i], 8 );
 			class_device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i));
+			devfs_remove("ip2/ipl%d", i);
 			class_device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i + 1));
+			devfs_remove("ip2/stat%d", i);
 		}
 		/* Disable and remove interrupt handler. */
 		if ( (ip2config.irq[i] > 0) && have_requested_irq(ip2config.irq[i]) ) {	
@@ -421,6 +424,7 @@
 		}
 	}
 	class_destroy(ip2_class);
+	devfs_remove("ip2");
 	if ( ( err = tty_unregister_driver ( ip2_tty_driver ) ) ) {
 		printk(KERN_ERR "IP2: failed to unregister tty driver (%d)\n", err);
 	}
@@ -674,6 +678,7 @@
 
 	ip2_tty_driver->owner		    = THIS_MODULE;
 	ip2_tty_driver->name                 = "ttyF";
+	ip2_tty_driver->devfs_name	    = "tts/F";
 	ip2_tty_driver->driver_name          = pcDriver_name;
 	ip2_tty_driver->major                = IP2_TTY_MAJOR;
 	ip2_tty_driver->minor_start          = 0;
@@ -722,9 +727,26 @@
 				class_device_create(ip2_class, NULL,
 						MKDEV(IP2_IPL_MAJOR, 4 * i),
 						NULL, "ipl%d", i);
+				err = devfs_mk_cdev(MKDEV(IP2_IPL_MAJOR, 4 * i),
+						S_IRUSR | S_IWUSR | S_IRGRP | S_IFCHR,
+						"ip2/ipl%d", i);
+				if (err) {
+					class_device_destroy(ip2_class,
+						MKDEV(IP2_IPL_MAJOR, 4 * i));
+					goto out_class;
+				}
+
 				class_device_create(ip2_class, NULL,
 						MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
 						NULL, "stat%d", i);
+				err = devfs_mk_cdev(MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
+						S_IRUSR | S_IWUSR | S_IRGRP | S_IFCHR,
+						"ip2/stat%d", i);
+				if (err) {
+					class_device_destroy(ip2_class,
+						MKDEV(IP2_IPL_MAJOR, 4 * i + 1));
+					goto out_class;
+				}
 
 			    for ( box = 0; box < ABS_MAX_BOXES; ++box )
 			    {
diff -urN linux-2.6.19.old/drivers/char/ipmi/ipmi_devintf.c linux-2.6.19.dev/drivers/char/ipmi/ipmi_devintf.c
--- linux-2.6.19.old/drivers/char/ipmi/ipmi_devintf.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/ipmi/ipmi_devintf.c	2006-12-14 03:12:59.000000000 +0100
@@ -39,6 +39,7 @@
 #include <linux/poll.h>
 #include <linux/spinlock.h>
 #include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/ipmi.h>
 #include <linux/mutex.h>
 #include <linux/init.h>
@@ -832,6 +833,9 @@
 	dev_t dev = MKDEV(ipmi_major, if_num);
 	struct ipmi_reg_list *entry;
 
+	devfs_mk_cdev(dev, S_IFCHR | S_IRUSR | S_IWUSR,
+		      "ipmidev/%d", if_num);
+
 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry) {
 		printk(KERN_ERR "ipmi_devintf: Unable to create the"
@@ -861,6 +865,7 @@
 	}
 	class_device_destroy(ipmi_class, dev);
 	mutex_unlock(&reg_list_mutex);
+	devfs_remove("ipmidev/%d", if_num);
 }
 
 static struct ipmi_smi_watcher smi_watcher =
@@ -896,6 +901,8 @@
 		ipmi_major = rv;
 	}
 
+	devfs_mk_dir(DEVICE_NAME);
+
 	rv = ipmi_smi_watcher_register(&smi_watcher);
 	if (rv) {
 		unregister_chrdev(ipmi_major, DEVICE_NAME);
@@ -920,6 +927,7 @@
 	mutex_unlock(&reg_list_mutex);
 	class_destroy(ipmi_class);
 	ipmi_smi_watcher_unregister(&smi_watcher);
+	devfs_remove(DEVICE_NAME);
 	unregister_chrdev(ipmi_major, DEVICE_NAME);
 }
 module_exit(cleanup_ipmi);
diff -urN linux-2.6.19.old/drivers/char/isicom.c linux-2.6.19.dev/drivers/char/isicom.c
--- linux-2.6.19.old/drivers/char/isicom.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/isicom.c	2006-12-14 03:12:59.000000000 +0100
@@ -1582,6 +1582,7 @@
 
 	isicom_normal->owner			= THIS_MODULE;
 	isicom_normal->name 			= "ttyM";
+	isicom_normal->devfs_name	 	= "isicom/";
 	isicom_normal->major			= ISICOM_NMAJOR;
 	isicom_normal->minor_start		= 0;
 	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/lp.c linux-2.6.19.dev/drivers/char/lp.c
--- linux-2.6.19.old/drivers/char/lp.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/lp.c	2006-12-14 03:12:59.000000000 +0100
@@ -119,6 +119,7 @@
 #include <linux/major.h>
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/slab.h>
 #include <linux/fcntl.h>
 #include <linux/delay.h>
@@ -805,6 +806,8 @@
 
 	class_device_create(lp_class, NULL, MKDEV(LP_MAJOR, nr), NULL,
 				"lp%d", nr);
+	devfs_mk_cdev(MKDEV(LP_MAJOR, nr), S_IFCHR | S_IRUGO | S_IWUGO,
+			"printers/%d", nr);
 
 	printk(KERN_INFO "lp%d: using %s (%s).\n", nr, port->name, 
 	       (port->irq == PARPORT_IRQ_NONE)?"polling":"interrupt-driven");
@@ -903,6 +906,7 @@
 		return -EIO;
 	}
 
+	devfs_mk_dir("printers");
 	lp_class = class_create(THIS_MODULE, "printer");
 	if (IS_ERR(lp_class)) {
 		err = PTR_ERR(lp_class);
@@ -928,6 +932,7 @@
 out_class:
 	class_destroy(lp_class);
 out_reg:
+	devfs_remove("printers");
 	unregister_chrdev(LP_MAJOR, "lp");
 	return err;
 }
@@ -975,8 +980,10 @@
 		if (lp_table[offset].dev == NULL)
 			continue;
 		parport_unregister_device(lp_table[offset].dev);
+		devfs_remove("printers/%d", offset);
 		class_device_destroy(lp_class, MKDEV(LP_MAJOR, offset));
 	}
+	devfs_remove("printers");
 	class_destroy(lp_class);
 }
 
diff -urN linux-2.6.19.old/drivers/char/mem.c linux-2.6.19.dev/drivers/char/mem.c
--- linux-2.6.19.old/drivers/char/mem.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/mem.c	2006-12-14 03:12:59.000000000 +0100
@@ -19,6 +19,7 @@
 #include <linux/tty.h>
 #include <linux/capability.h>
 #include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/ptrace.h>
 #include <linux/device.h>
 #include <linux/highmem.h>
@@ -979,10 +980,13 @@
 		printk("unable to get major %d for memory devs\n", MEM_MAJOR);
 
 	mem_class = class_create(THIS_MODULE, "mem");
-	for (i = 0; i < ARRAY_SIZE(devlist); i++)
+	for (i = 0; i < ARRAY_SIZE(devlist); i++) {
 		class_device_create(mem_class, NULL,
 					MKDEV(MEM_MAJOR, devlist[i].minor),
 					NULL, devlist[i].name);
+		devfs_mk_cdev(MKDEV(MEM_MAJOR, devlist[i].minor),
+				S_IFCHR | devlist[i].mode, devlist[i].name);
+	}
 	
 	return 0;
 }
diff -urN linux-2.6.19.old/drivers/char/misc.c linux-2.6.19.dev/drivers/char/misc.c
--- linux-2.6.19.old/drivers/char/misc.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/misc.c	2006-12-14 03:12:59.000000000 +0100
@@ -43,6 +43,7 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/stat.h>
 #include <linux/init.h>
 #include <linux/device.h>
@@ -226,6 +227,10 @@
 
 	if (misc->minor < DYNAMIC_MINORS)
 		misc_minors[misc->minor >> 3] |= 1 << (misc->minor & 7);
+	if (misc->devfs_name[0] == '\0') {
+		snprintf(misc->devfs_name, sizeof(misc->devfs_name),
+				"misc/%s", misc->name);
+	}
 	dev = MKDEV(MISC_MAJOR, misc->minor);
 
 	misc->class = class_device_create(misc_class, NULL, dev, misc->dev,
@@ -235,6 +240,13 @@
 		goto out;
 	}
 
+	err = devfs_mk_cdev(dev, S_IFCHR|S_IRUSR|S_IWUSR|S_IRGRP, 
+			    misc->devfs_name);
+	if (err) {
+		class_device_destroy(misc_class, dev);
+		goto out;
+	}
+
 	/*
 	 * Add it to the front, so that later devices can "override"
 	 * earlier defaults
@@ -265,6 +277,7 @@
 	down(&misc_sem);
 	list_del(&misc->list);
 	class_device_destroy(misc_class, MKDEV(MISC_MAJOR, misc->minor));
+	devfs_remove(misc->devfs_name);
 	if (i < DYNAMIC_MINORS && i>0) {
 		misc_minors[i>>3] &= ~(1 << (misc->minor & 7));
 	}
diff -urN linux-2.6.19.old/drivers/char/mmtimer.c linux-2.6.19.dev/drivers/char/mmtimer.c
--- linux-2.6.19.old/drivers/char/mmtimer.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/mmtimer.c	2006-12-14 03:12:59.000000000 +0100
@@ -25,6 +25,7 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/mm.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/mmtimer.h>
 #include <linux/miscdevice.h>
 #include <linux/posix-timers.h>
@@ -692,6 +693,7 @@
 		return -1;
 	}
 
+	strcpy(mmtimer_miscdev.devfs_name, MMTIMER_NAME);
 	if (misc_register(&mmtimer_miscdev)) {
 		printk(KERN_ERR "%s: failed to register device\n",
 		       MMTIMER_NAME);
diff -urN linux-2.6.19.old/drivers/char/moxa.c linux-2.6.19.dev/drivers/char/moxa.c
--- linux-2.6.19.old/drivers/char/moxa.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/moxa.c	2006-12-14 03:12:59.000000000 +0100
@@ -346,6 +346,7 @@
 	init_MUTEX(&moxaBuffSem);
 	moxaDriver->owner = THIS_MODULE;
 	moxaDriver->name = "ttyMX";
+	moxaDriver->devfs_name = "tts/a";
 	moxaDriver->major = ttymajor;
 	moxaDriver->minor_start = 0;
 	moxaDriver->type = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/ppdev.c linux-2.6.19.dev/drivers/char/ppdev.c
--- linux-2.6.19.old/drivers/char/ppdev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/ppdev.c	2006-12-14 03:12:59.000000000 +0100
@@ -60,6 +60,7 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/device.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/ioctl.h>
 #include <linux/parport.h>
 #include <linux/ctype.h>
@@ -781,6 +782,11 @@
 		err = PTR_ERR(ppdev_class);
 		goto out_chrdev;
 	}
+	devfs_mk_dir("parports");
+	for (i = 0; i < PARPORT_MAX; i++) {
+		devfs_mk_cdev(MKDEV(PP_MAJOR, i),
+				S_IFCHR | S_IRUGO | S_IWUGO, "parports/%d", i);
+	}
 	if (parport_register_driver(&pp_driver)) {
 		printk (KERN_WARNING CHRDEV ": unable to register with parport\n");
 		goto out_class;
@@ -790,6 +796,9 @@
 	goto out;
 
 out_class:
+	for (i = 0; i < PARPORT_MAX; i++)
+		devfs_remove("parports/%d", i);
+	devfs_remove("parports");
 	class_destroy(ppdev_class);
 out_chrdev:
 	unregister_chrdev(PP_MAJOR, CHRDEV);
@@ -799,8 +808,12 @@
 
 static void __exit ppdev_cleanup (void)
 {
+	int i;
 	/* Clean up all parport stuff */
+	for (i = 0; i < PARPORT_MAX; i++)
+		devfs_remove("parports/%d", i);
 	parport_unregister_driver(&pp_driver);
+	devfs_remove("parports");
 	class_destroy(ppdev_class);
 	unregister_chrdev (PP_MAJOR, CHRDEV);
 }
diff -urN linux-2.6.19.old/drivers/char/pty.c linux-2.6.19.dev/drivers/char/pty.c
--- linux-2.6.19.old/drivers/char/pty.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/pty.c	2006-12-14 03:12:59.000000000 +0100
@@ -23,6 +23,7 @@
 #include <linux/major.h>
 #include <linux/mm.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/sysctl.h>
 
 #include <asm/uaccess.h>
@@ -263,6 +264,7 @@
 	pty_driver->owner = THIS_MODULE;
 	pty_driver->driver_name = "pty_master";
 	pty_driver->name = "pty";
+	pty_driver->devfs_name = "pty/m";
 	pty_driver->major = PTY_MASTER_MAJOR;
 	pty_driver->minor_start = 0;
 	pty_driver->type = TTY_DRIVER_TYPE_PTY;
@@ -280,6 +282,7 @@
 	pty_slave_driver->owner = THIS_MODULE;
 	pty_slave_driver->driver_name = "pty_slave";
 	pty_slave_driver->name = "ttyp";
+	pty_slave_driver->devfs_name = "pty/s";
 	pty_slave_driver->major = PTY_SLAVE_MAJOR;
 	pty_slave_driver->minor_start = 0;
 	pty_slave_driver->type = TTY_DRIVER_TYPE_PTY;
@@ -347,6 +350,7 @@
 
 static void __init unix98_pty_init(void)
 {
+	devfs_mk_dir("pts");
 	ptm_driver = alloc_tty_driver(NR_UNIX98_PTY_MAX);
 	if (!ptm_driver)
 		panic("Couldn't allocate Unix98 ptm driver");
diff -urN linux-2.6.19.old/drivers/char/raw.c linux-2.6.19.dev/drivers/char/raw.c
--- linux-2.6.19.old/drivers/char/raw.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/raw.c	2006-12-14 03:12:59.000000000 +0100
@@ -10,6 +10,7 @@
 
 #include <linux/init.h>
 #include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/major.h>
 #include <linux/blkdev.h>
 #include <linux/module.h>
@@ -285,6 +286,13 @@
 	}
 	class_device_create(raw_class, NULL, MKDEV(RAW_MAJOR, 0), NULL, "rawctl");
 
+	devfs_mk_cdev(MKDEV(RAW_MAJOR, 0),
+		      S_IFCHR | S_IRUGO | S_IWUGO,
+		      "raw/rawctl");
+	for (i = 1; i < MAX_RAW_MINORS; i++)
+		devfs_mk_cdev(MKDEV(RAW_MAJOR, i),
+			      S_IFCHR | S_IRUGO | S_IWUGO,
+			      "raw/raw%d", i);
 	return 0;
 
 error_region:
@@ -295,6 +303,12 @@
 
 static void __exit raw_exit(void)
 {
+	int i;
+
+	for (i = 1; i < MAX_RAW_MINORS; i++)
+		devfs_remove("raw/raw%d", i);
+	devfs_remove("raw/rawctl");
+	devfs_remove("raw");
 	class_device_destroy(raw_class, MKDEV(RAW_MAJOR, 0));
 	class_destroy(raw_class);
 	cdev_del(&raw_cdev);
diff -urN linux-2.6.19.old/drivers/char/riscom8.c linux-2.6.19.dev/drivers/char/riscom8.c
--- linux-2.6.19.old/drivers/char/riscom8.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/riscom8.c	2006-12-14 03:12:59.000000000 +0100
@@ -1613,6 +1613,7 @@
 	memset(IRQ_to_board, 0, sizeof(IRQ_to_board));
 	riscom_driver->owner = THIS_MODULE;
 	riscom_driver->name = "ttyL";
+	riscom_driver->devfs_name = "tts/L";
 	riscom_driver->major = RISCOM8_NORMAL_MAJOR;
 	riscom_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	riscom_driver->subtype = SERIAL_TYPE_NORMAL;
diff -urN linux-2.6.19.old/drivers/char/rocket.c linux-2.6.19.dev/drivers/char/rocket.c
--- linux-2.6.19.old/drivers/char/rocket.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/rocket.c	2006-12-14 03:12:59.000000000 +0100
@@ -2426,7 +2426,8 @@
 	 */
 
 	rocket_driver->owner = THIS_MODULE;
-	rocket_driver->flags = TTY_DRIVER_DYNAMIC_DEV;
+	rocket_driver->flags = TTY_DRIVER_NO_DEVFS;
+	rocket_driver->devfs_name = "tts/R";
 	rocket_driver->name = "ttyR";
 	rocket_driver->driver_name = "Comtrol RocketPort";
 	rocket_driver->major = TTY_ROCKET_MAJOR;
@@ -2437,7 +2438,7 @@
 	rocket_driver->init_termios.c_cflag =
 	    B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 #ifdef ROCKET_SOFT_FLOW
-	rocket_driver->flags |= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	rocket_driver->flags |= TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 #endif
 	tty_set_operations(rocket_driver, &rocket_ops);
 
diff -urN linux-2.6.19.old/drivers/char/serial167.c linux-2.6.19.dev/drivers/char/serial167.c
--- linux-2.6.19.old/drivers/char/serial167.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/serial167.c	2006-12-14 03:12:59.000000000 +0100
@@ -2218,6 +2218,7 @@
     /* Initialize the tty_driver structure */
     
     cy_serial_driver->owner = THIS_MODULE;
+    cy_serial_driver->devfs_name = "tts/";
     cy_serial_driver->name = "ttyS";
     cy_serial_driver->major = TTY_MAJOR;
     cy_serial_driver->minor_start = 64;
diff -urN linux-2.6.19.old/drivers/char/stallion.c linux-2.6.19.dev/drivers/char/stallion.c
--- linux-2.6.19.old/drivers/char/stallion.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/stallion.c	2006-12-14 03:12:59.000000000 +0100
@@ -39,6 +39,7 @@
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/device.h>
 #include <linux/delay.h>
 
@@ -753,15 +754,21 @@
 	if (i) {
 		printk("STALLION: failed to un-register tty driver, "
 			"errno=%d\n", -i);
+		restore_flags(flags);
 		return;
 	}
-	for (i = 0; i < 4; i++)
+	for (i = 0; i < 4; i++) {
+		devfs_remove("staliomem/%d", i);
 		class_device_destroy(stallion_class, MKDEV(STL_SIOMEMMAJOR, i));
+	}
+	devfs_remove("staliomem");
 	if ((i = unregister_chrdev(STL_SIOMEMMAJOR, "staliomem")))
 		printk("STALLION: failed to un-register serial memory device, "
 			"errno=%d\n", -i);
 	class_destroy(stallion_class);
 
+	kfree(stl_tmpwritebuf);
+
 	for (i = 0; (i < stl_nrbrds); i++) {
 		if ((brdp = stl_brds[i]) == (stlbrd_t *) NULL)
 			continue;
@@ -3033,21 +3040,35 @@
 		return -1;
 
 /*
+ *	Allocate a temporary write buffer.
+ */
+	stl_tmpwritebuf = kmalloc(STL_TXBUFSIZE, GFP_KERNEL);
+	if (!stl_tmpwritebuf)
+		printk("STALLION: failed to allocate memory (size=%d)\n",
+			STL_TXBUFSIZE);
+
+/*
  *	Set up a character driver for per board stuff. This is mainly used
  *	to do stats ioctls on the ports.
  */
 	if (register_chrdev(STL_SIOMEMMAJOR, "staliomem", &stl_fsiomem))
 		printk("STALLION: failed to register serial board device\n");
+	devfs_mk_dir("staliomem");
 
 	stallion_class = class_create(THIS_MODULE, "staliomem");
-	for (i = 0; i < 4; i++)
+	for (i = 0; i < 4; i++) {
+		devfs_mk_cdev(MKDEV(STL_SIOMEMMAJOR, i),
+				S_IFCHR|S_IRUSR|S_IWUSR,
+				"staliomem/%d", i);
 		class_device_create(stallion_class, NULL,
 				    MKDEV(STL_SIOMEMMAJOR, i), NULL,
 				    "staliomem%d", i);
+	}
 
 	stl_serial->owner = THIS_MODULE;
 	stl_serial->driver_name = stl_drvname;
 	stl_serial->name = "ttyE";
+	stl_serial->devfs_name = "tts/E";
 	stl_serial->major = STL_SERIALMAJOR;
 	stl_serial->minor_start = 0;
 	stl_serial->type = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/tipar.c linux-2.6.19.dev/drivers/char/tipar.c
--- linux-2.6.19.old/drivers/char/tipar.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/tipar.c	2006-12-14 03:12:59.000000000 +0100
@@ -55,6 +55,7 @@
 #include <linux/ioport.h>
 #include <asm/io.h>
 #include <linux/bitops.h>
+#include <linux/devfs_fs_kernel.h>	/* DevFs support */
 #include <linux/parport.h>		/* Our code depend on parport */
 #include <linux/device.h>
 
@@ -443,6 +444,12 @@
 
 	class_device_create(tipar_class, NULL, MKDEV(TIPAR_MAJOR,
 			TIPAR_MINOR + nr), NULL, "par%d", nr);
+	/* Use devfs, tree: /dev/ticables/par/[0..2] */
+	err = devfs_mk_cdev(MKDEV(TIPAR_MAJOR, TIPAR_MINOR + nr),
+			S_IFCHR | S_IRUGO | S_IWUGO,
+			"ticables/par/%d", nr);
+	if (err)
+		goto out_class;
 
 	/* Display informations */
 	pr_info("tipar%d: using %s (%s)\n", nr, port->name, (port->irq ==
@@ -497,6 +504,9 @@
 		goto out;
 	}
 
+	/* Use devfs with tree: /dev/ticables/par/[0..2] */
+	devfs_mk_dir("ticables/par");
+
 	tipar_class = class_create(THIS_MODULE, "ticables");
 	if (IS_ERR(tipar_class)) {
 		err = PTR_ERR(tipar_class);
@@ -515,6 +525,7 @@
 	class_destroy(tipar_class);
 
 out_chrdev:
+	devfs_remove("ticables/par");
 	unregister_chrdev(TIPAR_MAJOR, "tipar");
 out:
 	return err;	
@@ -535,8 +546,10 @@
 			continue;
 		parport_unregister_device(table[i].dev);
 		class_device_destroy(tipar_class, MKDEV(TIPAR_MAJOR, i));
+		devfs_remove("ticables/par/%d", i);
 	}
 	class_destroy(tipar_class);
+	devfs_remove("ticables/par");
 
 	pr_info("tipar: module unloaded\n");
 }
diff -urN linux-2.6.19.old/drivers/char/tty_io.c linux-2.6.19.dev/drivers/char/tty_io.c
--- linux-2.6.19.old/drivers/char/tty_io.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/tty_io.c	2006-12-14 03:12:59.000000000 +0100
@@ -101,6 +101,7 @@
 #include <linux/kbd_kern.h>
 #include <linux/vt_kern.h>
 #include <linux/selection.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include <linux/kmod.h>
 
@@ -3634,6 +3635,9 @@
 		return ERR_PTR(-EINVAL);
 	}
 
+	devfs_mk_cdev(dev, S_IFCHR | S_IRUSR | S_IWUSR,
+			"%s%d", driver->devfs_name, index + driver->name_base);
+
 	if (driver->type == TTY_DRIVER_TYPE_PTY)
 		pty_line_name(driver, index, name);
 	else
@@ -3655,6 +3659,7 @@
 
 void tty_unregister_device(struct tty_driver *driver, unsigned index)
 {
+	devfs_remove("%s%d", driver->devfs_name, index + driver->name_base);
 	class_device_destroy(tty_class, MKDEV(driver->major, driver->minor_start) + index);
 }
 
@@ -3776,7 +3781,7 @@
 	
 	list_add(&driver->tty_drivers, &tty_drivers);
 	
-	if ( !(driver->flags & TTY_DRIVER_DYNAMIC_DEV) ) {
+	if ( !(driver->flags & TTY_DRIVER_NO_DEVFS) ) {
 		for(i = 0; i < driver->num; i++)
 		    tty_register_device(driver, i, NULL);
 	}
@@ -3819,7 +3824,7 @@
 			driver->termios_locked[i] = NULL;
 			kfree(tp);
 		}
-		if (!(driver->flags & TTY_DRIVER_DYNAMIC_DEV))
+		if (!(driver->flags & TTY_DRIVER_NO_DEVFS))
 			tty_unregister_device(driver, i);
 	}
 	p = driver->ttys;
@@ -3895,12 +3900,14 @@
 	if (cdev_add(&tty_cdev, MKDEV(TTYAUX_MAJOR, 0), 1) ||
 	    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 0), 1, "/dev/tty") < 0)
 		panic("Couldn't register /dev/tty driver\n");
+	devfs_mk_cdev(MKDEV(TTYAUX_MAJOR, 0), S_IFCHR|S_IRUGO|S_IWUGO, "tty");
 	class_device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 0), NULL, "tty");
 
 	cdev_init(&console_cdev, &console_fops);
 	if (cdev_add(&console_cdev, MKDEV(TTYAUX_MAJOR, 1), 1) ||
 	    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 1), 1, "/dev/console") < 0)
 		panic("Couldn't register /dev/console driver\n");
+	devfs_mk_cdev(MKDEV(TTYAUX_MAJOR, 1), S_IFCHR|S_IRUSR|S_IWUSR, "console");
 	class_device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 1), NULL, "console");
 
 #ifdef CONFIG_UNIX98_PTYS
@@ -3908,6 +3915,7 @@
 	if (cdev_add(&ptmx_cdev, MKDEV(TTYAUX_MAJOR, 2), 1) ||
 	    register_chrdev_region(MKDEV(TTYAUX_MAJOR, 2), 1, "/dev/ptmx") < 0)
 		panic("Couldn't register /dev/ptmx driver\n");
+	devfs_mk_cdev(MKDEV(TTYAUX_MAJOR, 2), S_IFCHR|S_IRUGO|S_IWUGO, "ptmx");
 	class_device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 2), NULL, "ptmx");
 #endif
 
@@ -3916,6 +3924,7 @@
 	if (cdev_add(&vc0_cdev, MKDEV(TTY_MAJOR, 0), 1) ||
 	    register_chrdev_region(MKDEV(TTY_MAJOR, 0), 1, "/dev/vc/0") < 0)
 		panic("Couldn't register /dev/tty0 driver\n");
+	devfs_mk_cdev(MKDEV(TTY_MAJOR, 0), S_IFCHR|S_IRUSR|S_IWUSR, "vc/0");
 	class_device_create(tty_class, NULL, MKDEV(TTY_MAJOR, 0), NULL, "tty0");
 
 	vty_init();
diff -urN linux-2.6.19.old/drivers/char/vc_screen.c linux-2.6.19.dev/drivers/char/vc_screen.c
--- linux-2.6.19.old/drivers/char/vc_screen.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/vc_screen.c	2006-12-14 03:12:59.000000000 +0100
@@ -25,6 +25,7 @@
 #include <linux/major.h>
 #include <linux/errno.h>
 #include <linux/tty.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/mm.h>
@@ -476,6 +477,12 @@
 
 void vcs_make_sysfs(struct tty_struct *tty)
 {
+	devfs_mk_cdev(MKDEV(VCS_MAJOR, tty->index + 1),
+			S_IFCHR|S_IRUSR|S_IWUSR,
+			"vcc/%u", tty->index + 1);
+	devfs_mk_cdev(MKDEV(VCS_MAJOR, tty->index + 129),
+			S_IFCHR|S_IRUSR|S_IWUSR,
+			"vcc/a%u", tty->index + 1);
 	class_device_create(vc_class, NULL, MKDEV(VCS_MAJOR, tty->index + 1),
 			NULL, "vcs%u", tty->index + 1);
 	class_device_create(vc_class, NULL, MKDEV(VCS_MAJOR, tty->index + 129),
@@ -484,6 +491,8 @@
 
 void vcs_remove_sysfs(struct tty_struct *tty)
 {
+	devfs_remove("vcc/%u", tty->index + 1);
+	devfs_remove("vcc/a%u", tty->index + 1);
 	class_device_destroy(vc_class, MKDEV(VCS_MAJOR, tty->index + 1));
 	class_device_destroy(vc_class, MKDEV(VCS_MAJOR, tty->index + 129));
 }
@@ -494,6 +503,8 @@
 		panic("unable to get major %d for vcs device", VCS_MAJOR);
 	vc_class = class_create(THIS_MODULE, "vc");
 
+	devfs_mk_cdev(MKDEV(VCS_MAJOR, 0), S_IFCHR|S_IRUSR|S_IWUSR, "vcc/0");
+	devfs_mk_cdev(MKDEV(VCS_MAJOR, 128), S_IFCHR|S_IRUSR|S_IWUSR, "vcc/a0");
 	class_device_create(vc_class, NULL, MKDEV(VCS_MAJOR, 0), NULL, "vcs");
 	class_device_create(vc_class, NULL, MKDEV(VCS_MAJOR, 128), NULL, "vcsa");
 	return 0;
diff -urN linux-2.6.19.old/drivers/char/viocons.c linux-2.6.19.dev/drivers/char/viocons.c
--- linux-2.6.19.old/drivers/char/viocons.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/viocons.c	2006-12-14 03:12:59.000000000 +0100
@@ -1121,6 +1121,7 @@
 	viotty_driver = alloc_tty_driver(VTTY_PORTS);
 	viotty_driver->owner = THIS_MODULE;
 	viotty_driver->driver_name = "vioconsole";
+	viotty_driver->devfs_name = "vcs/";
 	viotty_driver->name = "tty";
 	viotty_driver->name_base = 1;
 	viotty_driver->major = TTY_MAJOR;
diff -urN linux-2.6.19.old/drivers/char/viotape.c linux-2.6.19.dev/drivers/char/viotape.c
--- linux-2.6.19.old/drivers/char/viotape.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/viotape.c	2006-12-14 03:12:59.000000000 +0100
@@ -42,6 +42,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/fs.h>
 #include <linux/cdev.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/major.h>
 #include <linux/completion.h>
 #include <linux/proc_fs.h>
@@ -942,6 +943,7 @@
 {
 	int i = vdev->unit_address;
 	int j;
+	char tapename[16];
 
 	if (i >= viotape_numdev)
 		return -ENODEV;
@@ -955,6 +957,12 @@
 			"iseries!vt%d", i);
 	class_device_create(tape_class, NULL, MKDEV(VIOTAPE_MAJOR, i | 0x80),
 			NULL, "iseries!nvt%d", i);
+	devfs_mk_cdev(MKDEV(VIOTAPE_MAJOR, i), S_IFCHR | S_IRUSR | S_IWUSR,
+			"iseries/vt%d", i);
+	devfs_mk_cdev(MKDEV(VIOTAPE_MAJOR, i | 0x80),
+			S_IFCHR | S_IRUSR | S_IWUSR, "iseries/nvt%d", i);
+  	sprintf(tapename, "iseries/vt%d", i);
+	state[i].dev_handle = devfs_register_tape(tapename);
 	printk(VIOTAPE_KERN_INFO "tape iseries/vt%d is iSeries "
 			"resource %10.10s type %4.4s, model %3.3s\n",
 			i, viotape_unitinfo[i].rsrcname,
@@ -966,6 +974,9 @@
 {
 	int i = vdev->unit_address;
 
+	devfs_remove("iseries/nvt%d", i);
+	devfs_remove("iseries/vt%d", i);
+	devfs_unregister_tape(state[i].dev_handle);
 	class_device_destroy(tape_class, MKDEV(VIOTAPE_MAJOR, i | 0x80));
 	class_device_destroy(tape_class, MKDEV(VIOTAPE_MAJOR, i));
 	return 0;
diff -urN linux-2.6.19.old/drivers/char/vme_scc.c linux-2.6.19.dev/drivers/char/vme_scc.c
--- linux-2.6.19.old/drivers/char/vme_scc.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/vme_scc.c	2006-12-14 03:12:59.000000000 +0100
@@ -146,6 +146,7 @@
 	scc_driver->owner = THIS_MODULE;
 	scc_driver->driver_name = "scc";
 	scc_driver->name = "ttyS";
+	scc_driver->devfs_name = "tts/";
 	scc_driver->major = TTY_MAJOR;
 	scc_driver->minor_start = SCC_MINOR_BASE;
 	scc_driver->type = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/drivers/char/vt.c linux-2.6.19.dev/drivers/char/vt.c
--- linux-2.6.19.old/drivers/char/vt.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/char/vt.c	2006-12-14 03:12:59.000000000 +0100
@@ -86,6 +86,7 @@
 #include <linux/mm.h>
 #include <linux/console.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/vt_kern.h>
 #include <linux/selection.h>
 #include <linux/tiocl.h>
@@ -2691,6 +2692,7 @@
 	if (!console_driver)
 		panic("Couldn't allocate console driver\n");
 	console_driver->owner = THIS_MODULE;
+	console_driver->devfs_name = "vc/";
 	console_driver->name = "tty";
 	console_driver->name_base = 1;
 	console_driver->major = TTY_MAJOR;
diff -urN linux-2.6.19.old/drivers/ide/ide.c linux-2.6.19.dev/drivers/ide/ide.c
--- linux-2.6.19.old/drivers/ide/ide.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ide/ide.c	2006-12-14 03:12:59.000000000 +0100
@@ -146,6 +146,7 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/ide.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/completion.h>
 #include <linux/reboot.h>
 #include <linux/cdrom.h>
@@ -591,8 +592,13 @@
 		goto abort;
 	for (unit = 0; unit < MAX_DRIVES; ++unit) {
 		drive = &hwif->drives[unit];
-		if (!drive->present)
+		if (!drive->present) {
+			if (drive->devfs_name[0] != '\0') {
+				devfs_remove(drive->devfs_name);
+				drive->devfs_name[0] = '\0';
+			}
 			continue;
+		}
 		spin_unlock_irq(&ide_lock);
 		device_unregister(&drive->gendev);
 		wait_for_completion(&drive->gendev_rel_comp);
@@ -2005,6 +2011,7 @@
 	int ret;
 
 	printk(KERN_INFO "Uniform Multi-Platform E-IDE driver " REVISION "\n");
+	devfs_mk_dir("ide");
 	system_bus_speed = ide_system_bus_speed();
 
 	ret = bus_register(&ide_bus_type);
@@ -2086,6 +2093,7 @@
 #ifdef CONFIG_PROC_FS
 	proc_ide_destroy();
 #endif
+	devfs_remove("ide");
 
 	bus_unregister(&ide_bus_type);
 }
diff -urN linux-2.6.19.old/drivers/ide/ide-cd.c linux-2.6.19.dev/drivers/ide/ide-cd.c
--- linux-2.6.19.old/drivers/ide/ide-cd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ide/ide-cd.c	2006-12-14 03:12:59.000000000 +0100
@@ -3528,6 +3528,8 @@
 	drive->driver_data = info;
 
 	g->minors = 1;
+	snprintf(g->devfs_name, sizeof(g->devfs_name),
+			"%s/cd", drive->devfs_name);
 	g->driverfs_dev = &drive->gendev;
 	g->flags = GENHD_FL_CD | GENHD_FL_REMOVABLE;
 	if (ide_cdrom_setup(drive)) {
diff -urN linux-2.6.19.old/drivers/ide/ide-disk.c linux-2.6.19.dev/drivers/ide/ide-disk.c
--- linux-2.6.19.old/drivers/ide/ide-disk.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ide/ide-disk.c	2006-12-14 03:12:59.000000000 +0100
@@ -1018,6 +1018,7 @@
 	struct gendisk *g = idkp->disk;
 
 	drive->driver_data = NULL;
+	drive->devfs_name[0] = '\0';
 	g->private_data = NULL;
 	put_disk(g);
 	kfree(idkp);
@@ -1221,6 +1222,7 @@
 		drive->attach = 1;
 
 	g->minors = 1 << PARTN_BITS;
+	strcpy(g->devfs_name, drive->devfs_name);
 	g->driverfs_dev = &drive->gendev;
 	g->flags = drive->removable ? GENHD_FL_REMOVABLE : 0;
 	set_capacity(g, idedisk_capacity(drive));
diff -urN linux-2.6.19.old/drivers/ide/ide-floppy.c linux-2.6.19.dev/drivers/ide/ide-floppy.c
--- linux-2.6.19.old/drivers/ide/ide-floppy.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ide/ide-floppy.c	2006-12-14 03:12:59.000000000 +0100
@@ -2174,6 +2174,7 @@
 
 	g->minors = 1 << PARTN_BITS;
 	g->driverfs_dev = &drive->gendev;
+	strcpy(g->devfs_name, drive->devfs_name);
 	g->flags = drive->removable ? GENHD_FL_REMOVABLE : 0;
 	g->fops = &idefloppy_ops;
 	drive->attach = 1;
diff -urN linux-2.6.19.old/drivers/ide/ide-probe.c linux-2.6.19.dev/drivers/ide/ide-probe.c
--- linux-2.6.19.old/drivers/ide/ide-probe.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ide/ide-probe.c	2006-12-14 03:12:59.000000000 +0100
@@ -46,6 +46,7 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/ide.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/spinlock.h>
 #include <linux/kmod.h>
 #include <linux/pci.h>
@@ -1288,6 +1289,10 @@
 	ide_drive_t *drive = container_of(dev, ide_drive_t, gendev);
 
 	spin_lock_irq(&ide_lock);
+	if (drive->devfs_name[0] != '\0') {
+		devfs_remove(drive->devfs_name);
+		drive->devfs_name[0] = '\0';
+	}
 	ide_remove_drive_from_hwgroup(drive);
 	kfree(drive->id);
 	drive->id = NULL;
@@ -1321,6 +1326,12 @@
 		drive->gendev.bus = &ide_bus_type;
 		drive->gendev.driver_data = drive;
 		drive->gendev.release = drive_release_dev;
+		if (drive->present) {
+			sprintf(drive->devfs_name, "ide/host%d/bus%d/target%d/lun%d",
+				(hwif->channel && hwif->mate) ?
+				hwif->mate->index : hwif->index,
+				hwif->channel, unit, drive->lun);
+		}
 	}
 	blk_register_region(MKDEV(hwif->major, 0), MAX_DRIVES << PARTN_BITS,
 			THIS_MODULE, ata_probe, ata_lock, hwif);
diff -urN linux-2.6.19.old/drivers/ide/ide-tape.c linux-2.6.19.dev/drivers/ide/ide-tape.c
--- linux-2.6.19.old/drivers/ide/ide-tape.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ide/ide-tape.c	2006-12-14 03:12:59.000000000 +0100
@@ -434,6 +434,7 @@
 #include <linux/interrupt.h>
 #include <linux/jiffies.h>
 #include <linux/major.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/errno.h>
 #include <linux/genhd.h>
 #include <linux/slab.h>
@@ -4724,6 +4725,9 @@
 			MKDEV(IDETAPE_MAJOR, tape->minor));
 	class_device_destroy(idetape_sysfs_class,
 			MKDEV(IDETAPE_MAJOR, tape->minor + 128));
+	devfs_remove("%s/mt", drive->devfs_name);
+	devfs_remove("%s/mtn", drive->devfs_name);
+	devfs_unregister_tape(g->number);
 	idetape_devs[tape->minor] = NULL;
 	g->private_data = NULL;
 	put_disk(g);
@@ -4897,6 +4901,14 @@
 	class_device_create(idetape_sysfs_class, NULL,
 			MKDEV(IDETAPE_MAJOR, minor + 128), &drive->gendev, "n%s", tape->name);
 
+	devfs_mk_cdev(MKDEV(HWIF(drive)->major, minor),
+			S_IFCHR | S_IRUGO | S_IWUGO,
+			"%s/mt", drive->devfs_name);
+	devfs_mk_cdev(MKDEV(HWIF(drive)->major, minor + 128),
+			S_IFCHR | S_IRUGO | S_IWUGO,
+			"%s/mtn", drive->devfs_name);
+
+	g->number = devfs_register_tape(drive->devfs_name);
 	g->fops = &idetape_block_ops;
 	ide_register_region(g);
 
diff -urN linux-2.6.19.old/drivers/ieee1394/dv1394.c linux-2.6.19.dev/drivers/ieee1394/dv1394.c
--- linux-2.6.19.old/drivers/ieee1394/dv1394.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ieee1394/dv1394.c	2006-12-14 03:12:59.000000000 +0100
@@ -2263,14 +2263,37 @@
 	list_add_tail(&video->list, &dv1394_cards);
 	spin_unlock_irqrestore(&dv1394_cards_lock, flags);
 
+	if (devfs_mk_cdev(MKDEV(IEEE1394_MAJOR,
+				IEEE1394_MINOR_BLOCK_DV1394*16 + video->id),
+			S_IFCHR|S_IRUGO|S_IWUGO,
+			 "ieee1394/dv/host%d/%s/%s",
+			 (video->id>>2),
+			 (video->pal_or_ntsc == DV1394_NTSC ? "NTSC" : "PAL"),
+			 (video->mode == MODE_RECEIVE ? "in" : "out")) < 0)
+			goto err_free;
+
 	debug_printk("dv1394: dv1394_init() OK on ID %d\n", video->id);
+
 	return 0;
+
+ err_free:
+	kfree(video);
+ err:
+	return -1;
 }
 
 static void dv1394_un_init(struct video_card *video)
 {
+	char buf[32];
+
 	/* obviously nobody has the driver open at this point */
 	do_dv1394_shutdown(video, 1);
+	snprintf(buf, sizeof(buf), "dv/host%d/%s/%s", (video->id >> 2),
+		(video->pal_or_ntsc == DV1394_NTSC ? "NTSC" : "PAL"),
+		(video->mode == MODE_RECEIVE ? "in" : "out")
+		);
+
+	devfs_remove("ieee1394/%s", buf);
 	kfree(video);
 }
 
@@ -2307,6 +2330,9 @@
 
 	class_device_destroy(hpsb_protocol_class,
 		MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_DV1394 * 16 + (id<<2)));
+	devfs_remove("ieee1394/dv/host%d/NTSC", id);
+	devfs_remove("ieee1394/dv/host%d/PAL", id);
+	devfs_remove("ieee1394/dv/host%d", id);
 }
 
 static void dv1394_add_host (struct hpsb_host *host)
@@ -2323,6 +2349,9 @@
 	class_device_create(hpsb_protocol_class, NULL, MKDEV(
 		IEEE1394_MAJOR,	IEEE1394_MINOR_BLOCK_DV1394 * 16 + (id<<2)), 
 		NULL, "dv1394-%d", id);
+	devfs_mk_dir("ieee1394/dv/host%d", id);
+	devfs_mk_dir("ieee1394/dv/host%d/NTSC", id);
+	devfs_mk_dir("ieee1394/dv/host%d/PAL", id);
 
 	dv1394_init(ohci, DV1394_NTSC, MODE_RECEIVE);
 	dv1394_init(ohci, DV1394_NTSC, MODE_TRANSMIT);
@@ -2579,8 +2608,10 @@
 static void __exit dv1394_exit_module(void)
 {
 	hpsb_unregister_protocol(&dv1394_driver);
+
 	hpsb_unregister_highlevel(&dv1394_highlevel);
 	cdev_del(&dv1394_cdev);
+	devfs_remove("ieee1394/dv");
 }
 
 static int __init dv1394_init_module(void)
@@ -2596,12 +2627,15 @@
 		return ret;
 	}
 
+	devfs_mk_dir("ieee1394/dv");
+
 	hpsb_register_highlevel(&dv1394_highlevel);
 
 	ret = hpsb_register_protocol(&dv1394_driver);
 	if (ret) {
 		printk(KERN_ERR "dv1394: failed to register protocol\n");
 		hpsb_unregister_highlevel(&dv1394_highlevel);
+		devfs_remove("ieee1394/dv");
 		cdev_del(&dv1394_cdev);
 		return ret;
 	}
diff -urN linux-2.6.19.old/drivers/ieee1394/ieee1394_core.c linux-2.6.19.dev/drivers/ieee1394/ieee1394_core.c
--- linux-2.6.19.old/drivers/ieee1394/ieee1394_core.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ieee1394/ieee1394_core.c	2006-12-14 03:12:59.000000000 +0100
@@ -1072,10 +1072,17 @@
 		goto exit_release_kernel_thread;
 	}
 
+	/* actually this is a non-fatal error */
+	ret = devfs_mk_dir("ieee1394");
+	if (ret < 0) {
+		HPSB_ERR("unable to make devfs dir for device major %d!\n", IEEE1394_MAJOR);
+		goto release_chrdev;
+	}
+
 	ret = bus_register(&ieee1394_bus_type);
 	if (ret < 0) {
 		HPSB_INFO("bus register failed");
-		goto release_chrdev;
+		goto release_devfs;
 	}
 
 	for (i = 0; fw_bus_attrs[i]; i++) {
@@ -1086,7 +1093,7 @@
 						fw_bus_attrs[i--]);
 			}
 			bus_unregister(&ieee1394_bus_type);
-			goto release_chrdev;
+			goto release_devfs;
 		}
 	}
 
@@ -1139,6 +1146,8 @@
 	for (i = 0; fw_bus_attrs[i]; i++)
 		bus_remove_file(&ieee1394_bus_type, fw_bus_attrs[i]);
 	bus_unregister(&ieee1394_bus_type);
+release_devfs:
+	devfs_remove("ieee1394");
 release_chrdev:
 	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
 exit_release_kernel_thread:
@@ -1168,6 +1177,7 @@
 	hpsb_cleanup_config_roms();
 
 	unregister_chrdev_region(IEEE1394_CORE_DEV, 256);
+	devfs_remove("ieee1394");
 }
 
 fs_initcall(ieee1394_init); /* same as ohci1394 */
diff -urN linux-2.6.19.old/drivers/ieee1394/ieee1394_core.h linux-2.6.19.dev/drivers/ieee1394/ieee1394_core.h
--- linux-2.6.19.old/drivers/ieee1394/ieee1394_core.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ieee1394/ieee1394_core.h	2006-12-14 03:12:59.000000000 +0100
@@ -6,6 +6,7 @@
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/types.h>
+#include <linux/devfs_fs_kernel.h>
 #include <asm/atomic.h>
 
 #include "hosts.h"
diff -urN linux-2.6.19.old/drivers/ieee1394/raw1394.c linux-2.6.19.dev/drivers/ieee1394/raw1394.c
--- linux-2.6.19.old/drivers/ieee1394/raw1394.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ieee1394/raw1394.c	2006-12-14 03:12:59.000000000 +0100
@@ -41,6 +41,7 @@
 #include <linux/cdev.h>
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/compat.h>
 
 #include "csr1212.h"
@@ -3017,6 +3018,9 @@
 		goto out_unreg;
 	}
 
+	devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, IEEE1394_MINOR_BLOCK_RAW1394 * 16),
+		      S_IFCHR | S_IRUSR | S_IWUSR, RAW1394_DEVICE_NAME);
+
 	cdev_init(&raw1394_cdev, &raw1394_fops);
 	raw1394_cdev.owner = THIS_MODULE;
 	kobject_set_name(&raw1394_cdev.kobj, RAW1394_DEVICE_NAME);
@@ -3038,6 +3042,7 @@
 	goto out;
 
       out_dev:
+	devfs_remove(RAW1394_DEVICE_NAME);
 	class_device_destroy(hpsb_protocol_class,
 			     MKDEV(IEEE1394_MAJOR,
 				   IEEE1394_MINOR_BLOCK_RAW1394 * 16));
@@ -3053,6 +3058,7 @@
 			     MKDEV(IEEE1394_MAJOR,
 				   IEEE1394_MINOR_BLOCK_RAW1394 * 16));
 	cdev_del(&raw1394_cdev);
+	devfs_remove(RAW1394_DEVICE_NAME);
 	hpsb_unregister_highlevel(&raw1394_highlevel);
 	hpsb_unregister_protocol(&raw1394_driver);
 }
diff -urN linux-2.6.19.old/drivers/ieee1394/video1394.c linux-2.6.19.dev/drivers/ieee1394/video1394.c
--- linux-2.6.19.old/drivers/ieee1394/video1394.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/ieee1394/video1394.c	2006-12-14 03:12:59.000000000 +0100
@@ -41,6 +41,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/delay.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/bitops.h>
 #include <linux/types.h>
 #include <linux/vmalloc.h>
@@ -1356,6 +1357,9 @@
 	class_device_create(hpsb_protocol_class, NULL, MKDEV(
 		IEEE1394_MAJOR,	minor), 
 		NULL, "%s-%d", VIDEO1394_DRIVER_NAME, ohci->host->id);
+	devfs_mk_cdev(MKDEV(IEEE1394_MAJOR, minor),
+		       S_IFCHR | S_IRUSR | S_IWUSR,
+		       "%s/%d", VIDEO1394_DRIVER_NAME, ohci->host->id);
 }
 
 
@@ -1363,9 +1367,12 @@
 {
 	struct ti_ohci *ohci = hpsb_get_hostinfo(&video1394_highlevel, host);
 
-	if (ohci)
+	if (ohci) {
 		class_device_destroy(hpsb_protocol_class, MKDEV(IEEE1394_MAJOR,
 			IEEE1394_MINOR_BLOCK_VIDEO1394 * 16 + ohci->host->id));
+		devfs_remove("%s/%d", VIDEO1394_DRIVER_NAME, ohci->host->id);
+	}
+	
 	return;
 }
 
@@ -1506,8 +1513,12 @@
 static void __exit video1394_exit_module (void)
 {
 	hpsb_unregister_protocol(&video1394_driver);
+
 	hpsb_unregister_highlevel(&video1394_highlevel);
+
+	devfs_remove(VIDEO1394_DRIVER_NAME);
 	cdev_del(&video1394_cdev);
+
 	PRINT_G(KERN_INFO, "Removed " VIDEO1394_DRIVER_NAME " module");
 }
 
@@ -1524,12 +1535,15 @@
 		return ret;
         }
 
+	devfs_mk_dir(VIDEO1394_DRIVER_NAME);
+
 	hpsb_register_highlevel(&video1394_highlevel);
 
 	ret = hpsb_register_protocol(&video1394_driver);
 	if (ret) {
 		PRINT_G(KERN_ERR, "video1394: failed to register protocol");
 		hpsb_unregister_highlevel(&video1394_highlevel);
+		devfs_remove(VIDEO1394_DRIVER_NAME);
 		cdev_del(&video1394_cdev);
 		return ret;
 	}
diff -urN linux-2.6.19.old/drivers/input/serio/serio_raw.c linux-2.6.19.dev/drivers/input/serio/serio_raw.c
--- linux-2.6.19.old/drivers/input/serio/serio_raw.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/input/serio/serio_raw.c	2006-12-14 03:12:59.000000000 +0100
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/miscdevice.h>
 #include <linux/wait.h>
 #include <linux/mutex.h>
diff -urN linux-2.6.19.old/drivers/isdn/capi/capi.c linux-2.6.19.dev/drivers/isdn/capi/capi.c
--- linux-2.6.19.old/drivers/isdn/capi/capi.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/capi/capi.c	2006-12-14 03:12:59.000000000 +0100
@@ -38,6 +38,7 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/moduleparam.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/isdn/capiutil.h>
 #include <linux/isdn/capicmd.h>
 #if defined(CONFIG_ISDN_CAPI_CAPIFS) || defined(CONFIG_ISDN_CAPI_CAPIFS_MODULE)
@@ -1335,6 +1336,7 @@
 
 	drv->owner = THIS_MODULE;
 	drv->driver_name = "capi_nc";
+	drv->devfs_name = "capi/";
 	drv->name = "capi";
 	drv->major = capi_ttymajor;
 	drv->minor_start = 0;
@@ -1513,6 +1515,8 @@
 	}
 
 	class_device_create(capi_class, NULL, MKDEV(capi_major, 0), NULL, "capi");
+	devfs_mk_cdev(MKDEV(capi_major, 0), S_IFCHR | S_IRUSR | S_IWUSR,
+			"isdn/capi20");
 
 #ifdef CONFIG_ISDN_CAPI_MIDDLEWARE
 	if (capinc_tty_init() < 0) {
@@ -1547,6 +1551,7 @@
 	class_device_destroy(capi_class, MKDEV(capi_major, 0));
 	class_destroy(capi_class);
 	unregister_chrdev(capi_major, "capi20");
+	devfs_remove("isdn/capi20");
 
 #ifdef CONFIG_ISDN_CAPI_MIDDLEWARE
 	capinc_tty_exit();
diff -urN linux-2.6.19.old/drivers/isdn/gigaset/bas-gigaset.c linux-2.6.19.dev/drivers/isdn/gigaset/bas-gigaset.c
--- linux-2.6.19.old/drivers/isdn/gigaset/bas-gigaset.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/gigaset/bas-gigaset.c	2006-12-14 03:12:59.000000000 +0100
@@ -41,6 +41,7 @@
 #define GIGASET_MINORS     1
 #define GIGASET_MINOR      16
 #define GIGASET_MODULENAME "bas_gigaset"
+#define GIGASET_DEVFSNAME  "gig/bas/"
 #define GIGASET_DEVNAME    "ttyGB"
 
 /* length limit according to Siemens 3070usb-protokoll.doc ch. 2.1 */
@@ -2348,7 +2349,8 @@
 	/* allocate memory for our driver state and intialize it */
 	if ((driver = gigaset_initdriver(GIGASET_MINOR, GIGASET_MINORS,
 				       GIGASET_MODULENAME, GIGASET_DEVNAME,
-				       &gigops, THIS_MODULE)) == NULL)
+				       GIGASET_DEVFSNAME, &gigops,
+				       THIS_MODULE)) == NULL)
 		goto error;
 
 	/* allocate memory for our device state and intialize it */
diff -urN linux-2.6.19.old/drivers/isdn/gigaset/common.c linux-2.6.19.dev/drivers/isdn/gigaset/common.c
--- linux-2.6.19.old/drivers/isdn/gigaset/common.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/gigaset/common.c	2006-12-14 03:12:59.000000000 +0100
@@ -1092,12 +1092,14 @@
  *	minors		Number of minors this driver can handle
  *	procname	Name of the driver
  *	devname		Name of the device files (prefix without minor number)
+ *	devfsname	Devfs name of the device files without %d
  * return value:
  *	Pointer to the gigaset_driver structure on success, NULL on failure.
  */
 struct gigaset_driver *gigaset_initdriver(unsigned minor, unsigned minors,
 					  const char *procname,
 					  const char *devname,
+					  const char *devfsname,
 					  const struct gigaset_ops *ops,
 					  struct module *owner)
 {
@@ -1137,7 +1139,7 @@
 		drv->cs[i].minor_index = i;
 	}
 
-	gigaset_if_initdriver(drv, procname, devname);
+	gigaset_if_initdriver(drv, procname, devname, devfsname);
 
 	spin_lock_irqsave(&driver_lock, flags);
 	list_add(&drv->list, &drivers);
diff -urN linux-2.6.19.old/drivers/isdn/gigaset/gigaset.h linux-2.6.19.dev/drivers/isdn/gigaset/gigaset.h
--- linux-2.6.19.old/drivers/isdn/gigaset/gigaset.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/gigaset/gigaset.h	2006-12-14 03:12:59.000000000 +0100
@@ -768,6 +768,7 @@
 struct gigaset_driver *gigaset_initdriver(unsigned minor, unsigned minors,
 					  const char *procname,
 					  const char *devname,
+					  const char *devfsname,
 					  const struct gigaset_ops *ops,
 					  struct module *owner);
 
@@ -890,7 +891,7 @@
 
 /* initialize interface */
 void gigaset_if_initdriver(struct gigaset_driver *drv, const char *procname,
-			   const char *devname);
+			   const char *devname, const char *devfsname);
 /* release interface */
 void gigaset_if_freedriver(struct gigaset_driver *drv);
 /* add minor */
diff -urN linux-2.6.19.old/drivers/isdn/gigaset/interface.c linux-2.6.19.dev/drivers/isdn/gigaset/interface.c
--- linux-2.6.19.old/drivers/isdn/gigaset/interface.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/gigaset/interface.c	2006-12-14 03:12:59.000000000 +0100
@@ -673,9 +673,10 @@
  *	drv		Driver
  *	procname	Name of the driver (e.g. for /proc/tty/drivers)
  *	devname		Name of the device files (prefix without minor number)
+ *	devfsname	Devfs name of the device files without %d
  */
 void gigaset_if_initdriver(struct gigaset_driver *drv, const char *procname,
-			   const char *devname)
+			   const char *devname, const char *devfsname)
 {
 	unsigned minors = drv->minors;
 	int ret;
@@ -691,7 +692,7 @@
 	tty->major =		GIG_MAJOR,
 	tty->type =		TTY_DRIVER_TYPE_SERIAL,
 	tty->subtype =		SERIAL_TYPE_NORMAL,
-	tty->flags =		TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	tty->flags =		TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
 
 	tty->driver_name =	procname;
 	tty->name =		devname;
@@ -699,6 +700,7 @@
 	tty->num =		drv->minors;
 
 	tty->owner =		THIS_MODULE;
+	tty->devfs_name =	devfsname;
 
 	tty->init_termios          = tty_std_termios; //FIXME
 	tty->init_termios.c_cflag  = B9600 | CS8 | CREAD | HUPCL | CLOCAL; //FIXME
diff -urN linux-2.6.19.old/drivers/isdn/gigaset/usb-gigaset.c linux-2.6.19.dev/drivers/isdn/gigaset/usb-gigaset.c
--- linux-2.6.19.old/drivers/isdn/gigaset/usb-gigaset.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/gigaset/usb-gigaset.c	2006-12-14 03:12:59.000000000 +0100
@@ -41,6 +41,7 @@
 #define GIGASET_MINORS     1
 #define GIGASET_MINOR      8
 #define GIGASET_MODULENAME "usb_gigaset"
+#define GIGASET_DEVFSNAME  "gig/usb/"
 #define GIGASET_DEVNAME    "ttyGU"
 
 #define IF_WRITEBUF 2000 //FIXME  // WAKEUP_CHARS: 256
@@ -895,7 +896,8 @@
 	/* allocate memory for our driver state and intialize it */
 	if ((driver = gigaset_initdriver(GIGASET_MINOR, GIGASET_MINORS,
 				       GIGASET_MODULENAME, GIGASET_DEVNAME,
-				       &ops, THIS_MODULE)) == NULL)
+				       GIGASET_DEVFSNAME, &ops,
+				       THIS_MODULE)) == NULL)
 		goto error;
 
 	/* allocate memory for our device state and intialize it */
diff -urN linux-2.6.19.old/drivers/isdn/hardware/eicon/divamnt.c linux-2.6.19.dev/drivers/isdn/hardware/eicon/divamnt.c
--- linux-2.6.19.old/drivers/isdn/hardware/eicon/divamnt.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/hardware/eicon/divamnt.c	2006-12-14 03:12:59.000000000 +0100
@@ -10,12 +10,14 @@
  * of the GNU General Public License, incorporated herein by reference.
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
 #include <linux/poll.h>
+#include <linux/devfs_fs_kernel.h>
 #include <asm/uaccess.h>
 
 #include "platform.h"
@@ -176,6 +178,7 @@
 
 static void divas_maint_unregister_chrdev(void)
 {
+	devfs_remove(DEVNAME);
 	unregister_chrdev(major, DEVNAME);
 }
 
@@ -187,6 +190,7 @@
 		       DRIVERLNAME);
 		return (0);
 	}
+	devfs_mk_cdev(MKDEV(major, 0), S_IFCHR|S_IRUSR|S_IWUSR, DEVNAME);
 
 	return (1);
 }
diff -urN linux-2.6.19.old/drivers/isdn/hardware/eicon/divasi.c linux-2.6.19.dev/drivers/isdn/hardware/eicon/divasi.c
--- linux-2.6.19.old/drivers/isdn/hardware/eicon/divasi.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/hardware/eicon/divasi.c	2006-12-14 03:12:59.000000000 +0100
@@ -18,6 +18,7 @@
 #include <linux/poll.h>
 #include <linux/proc_fs.h>
 #include <linux/skbuff.h>
+#include <linux/devfs_fs_kernel.h>
 #include <asm/uaccess.h>
 
 #include "platform.h"
@@ -143,6 +144,7 @@
 
 static void divas_idi_unregister_chrdev(void)
 {
+	devfs_remove(DEVNAME);
 	unregister_chrdev(major, DEVNAME);
 }
 
@@ -154,6 +156,7 @@
 		       DRIVERLNAME);
 		return (0);
 	}
+	devfs_mk_cdev(MKDEV(major, 0), S_IFCHR|S_IRUSR|S_IWUSR, DEVNAME);
 
 	return (1);
 }
diff -urN linux-2.6.19.old/drivers/isdn/hardware/eicon/divasmain.c linux-2.6.19.dev/drivers/isdn/hardware/eicon/divasmain.c
--- linux-2.6.19.old/drivers/isdn/hardware/eicon/divasmain.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/hardware/eicon/divasmain.c	2006-12-14 03:12:59.000000000 +0100
@@ -9,10 +9,12 @@
  * of the GNU General Public License, incorporated herein by reference.
  */
 
+#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/devfs_fs_kernel.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <linux/ioport.h>
@@ -675,6 +677,7 @@
 
 static void divas_unregister_chrdev(void)
 {
+	devfs_remove(DEVNAME);
 	unregister_chrdev(major, DEVNAME);
 }
 
@@ -686,6 +689,7 @@
 		       DRIVERLNAME);
 		return (0);
 	}
+	devfs_mk_cdev(MKDEV(major, 0), S_IFCHR|S_IRUSR|S_IWUSR, DEVNAME);
 
 	return (1);
 }
diff -urN linux-2.6.19.old/drivers/isdn/i4l/isdn_tty.c linux-2.6.19.dev/drivers/isdn/i4l/isdn_tty.c
--- linux-2.6.19.old/drivers/isdn/i4l/isdn_tty.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/isdn/i4l/isdn_tty.c	2006-12-14 03:12:59.000000000 +0100
@@ -1889,13 +1889,14 @@
 	if (!m->tty_modem)
 		return -ENOMEM;
 	m->tty_modem->name = "ttyI";
+	m->tty_modem->devfs_name = "isdn/ttyI";
 	m->tty_modem->major = ISDN_TTY_MAJOR;
 	m->tty_modem->minor_start = 0;
 	m->tty_modem->type = TTY_DRIVER_TYPE_SERIAL;
 	m->tty_modem->subtype = SERIAL_TYPE_NORMAL;
 	m->tty_modem->init_termios = tty_std_termios;
 	m->tty_modem->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
-	m->tty_modem->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	m->tty_modem->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	m->tty_modem->driver_name = "isdn_tty";
 	tty_set_operations(m->tty_modem, &modem_ops);
 	retval = tty_register_driver(m->tty_modem);
diff -urN linux-2.6.19.old/drivers/macintosh/adb.c linux-2.6.19.dev/drivers/macintosh/adb.c
--- linux-2.6.19.old/drivers/macintosh/adb.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/macintosh/adb.c	2006-12-14 03:12:59.000000000 +0100
@@ -35,6 +35,7 @@
 #include <linux/spinlock.h>
 #include <linux/completion.h>
 #include <linux/device.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
@@ -902,6 +903,8 @@
 		return;
 	}
 
+	devfs_mk_cdev(MKDEV(ADB_MAJOR, 0), S_IFCHR | S_IRUSR | S_IWUSR, "adb");
+
 	adb_dev_class = class_create(THIS_MODULE, "adb");
 	if (IS_ERR(adb_dev_class))
 		return;
diff -urN linux-2.6.19.old/drivers/md/dm-ioctl.c linux-2.6.19.dev/drivers/md/dm-ioctl.c
--- linux-2.6.19.old/drivers/md/dm-ioctl.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/md/dm-ioctl.c	2006-12-14 03:12:59.000000000 +0100
@@ -13,6 +13,7 @@
 #include <linux/init.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/dm-ioctl.h>
 #include <linux/hdreg.h>
 
@@ -67,12 +68,14 @@
 {
 	init_buckets(_name_buckets);
 	init_buckets(_uuid_buckets);
+	devfs_mk_dir(DM_DIR);
 	return 0;
 }
 
 static void dm_hash_exit(void)
 {
 	dm_hash_remove_all(0);
+	devfs_remove(DM_DIR);
 }
 
 /*-----------------------------------------------------------------
@@ -169,6 +172,25 @@
 }
 
 /*
+ * devfs stuff.
+ */
+static int register_with_devfs(struct hash_cell *hc)
+{
+	struct gendisk *disk = dm_disk(hc->md);
+
+	devfs_mk_bdev(MKDEV(disk->major, disk->first_minor),
+		      S_IFBLK | S_IRUSR | S_IWUSR | S_IRGRP,
+		      DM_DIR "/%s", hc->name);
+	return 0;
+}
+
+static int unregister_with_devfs(struct hash_cell *hc)
+{
+	devfs_remove(DM_DIR"/%s", hc->name);
+	return 0;
+}
+
+/*
  * The kdev_t and uuid of a device can never change once it is
  * initially inserted.
  */
@@ -204,6 +226,7 @@
 		}
 		list_add(&cell->uuid_list, _uuid_buckets + hash_str(uuid));
 	}
+	register_with_devfs(cell);
 	dm_get(md);
 	dm_set_mdptr(md, cell);
 	up_write(&_hash_lock);
@@ -223,6 +246,7 @@
 	/* remove from the dev hash */
 	list_del(&hc->uuid_list);
 	list_del(&hc->name_list);
+	unregister_with_devfs(hc);
 	dm_set_mdptr(hc->md, NULL);
 
 	table = dm_get_table(hc->md);
@@ -318,11 +342,16 @@
 	/*
 	 * rename and move the name cell.
 	 */
+	unregister_with_devfs(hc);
+
 	list_del(&hc->name_list);
 	old_name = hc->name;
 	hc->name = new_name;
 	list_add(&hc->name_list, _name_buckets + hash_str(new_name));
 
+	/* rename the device node in devfs */
+	register_with_devfs(hc);
+
 	/*
 	 * Wake up any dm event waiters.
 	 */
@@ -1477,6 +1506,7 @@
 static struct miscdevice _dm_misc = {
 	.minor 		= MISC_DYNAMIC_MINOR,
 	.name  		= DM_NAME,
+	.devfs_name 	= "mapper/control",
 	.fops  		= &_ctl_fops
 };
 
diff -urN linux-2.6.19.old/drivers/md/md.c linux-2.6.19.dev/drivers/md/md.c
--- linux-2.6.19.old/drivers/md/md.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/md/md.c	2006-12-14 03:12:59.000000000 +0100
@@ -38,6 +38,7 @@
 #include <linux/raid/md.h>
 #include <linux/raid/bitmap.h>
 #include <linux/sysctl.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/buffer_head.h> /* for invalidate_bdev */
 #include <linux/suspend.h>
 #include <linux/poll.h>
@@ -2969,10 +2970,13 @@
 	}
 	disk->major = MAJOR(dev);
 	disk->first_minor = unit << shift;
-	if (partitioned)
+	if (partitioned) {
 		sprintf(disk->disk_name, "md_d%d", unit);
-	else
+		sprintf(disk->devfs_name, "md/d%d", unit);
+	} else {
 		sprintf(disk->disk_name, "md%d", unit);
+		sprintf(disk->devfs_name, "md/%d", unit);
+	}
 	disk->fops = &md_fops;
 	disk->private_data = mddev;
 	disk->queue = mddev->queue;
@@ -5539,11 +5543,23 @@
 		unregister_blkdev(MAJOR_NR, "md");
 		return -1;
 	}
+	devfs_mk_dir("md");
 	blk_register_region(MKDEV(MAJOR_NR, 0), 1UL<<MINORBITS, THIS_MODULE,
 			    md_probe, NULL, NULL);
 	blk_register_region(MKDEV(mdp_major, 0), 1UL<<MINORBITS, THIS_MODULE,
 			    md_probe, NULL, NULL);
 
+	for (minor=0; minor < MAX_MD_DEVS; ++minor)
+		devfs_mk_bdev(MKDEV(MAJOR_NR, minor),
+				S_IFBLK|S_IRUSR|S_IWUSR,
+				"md/%d", minor);
+
+	for (minor=0; minor < MAX_MD_DEVS; ++minor)
+		devfs_mk_bdev(MKDEV(mdp_major, minor<<MdpMinorShift),
+			      S_IFBLK|S_IRUSR|S_IWUSR,
+			      "md/mdp%d", minor);
+
+
 	register_reboot_notifier(&md_notifier);
 	raid_table_header = register_sysctl_table(raid_root_table, 1);
 
@@ -5599,9 +5615,16 @@
 {
 	mddev_t *mddev;
 	struct list_head *tmp;
+	int i;
 
 	blk_unregister_region(MKDEV(MAJOR_NR,0), 1U << MINORBITS);
 	blk_unregister_region(MKDEV(mdp_major,0), 1U << MINORBITS);
+	for (i=0; i < MAX_MD_DEVS; i++)
+		devfs_remove("md/%d", i);
+	for (i=0; i < MAX_MD_DEVS; i++)
+		devfs_remove("md/d%d", i);
+
+	devfs_remove("md");
 
 	unregister_blkdev(MAJOR_NR,"md");
 	unregister_blkdev(mdp_major, "mdp");
diff -urN linux-2.6.19.old/drivers/media/dvb/dvb-core/dvbdev.c linux-2.6.19.dev/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.19.old/drivers/media/dvb/dvb-core/dvbdev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/dvb/dvb-core/dvbdev.c	2006-12-14 03:12:59.000000000 +0100
@@ -231,6 +231,10 @@
 
 	mutex_unlock(&dvbdev_register_lock);
 
+	devfs_mk_cdev(MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
+			S_IFCHR | S_IRUSR | S_IWUSR,
+			"dvb/adapter%d/%s%d", adap->num, dnames[type], id);
+
 	class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
 			    adap->device, "dvb%d.%s%d", adap->num, dnames[type], id);
 
@@ -248,6 +252,9 @@
 	if (!dvbdev)
 		return;
 
+	devfs_remove("dvb/adapter%d/%s%d", dvbdev->adapter->num,
+			dnames[dvbdev->type], dvbdev->id);
+
 	class_device_destroy(dvb_class, MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
 					dvbdev->type, dvbdev->id)));
 
@@ -295,6 +302,7 @@
 
 	printk ("DVB: registering new adapter (%s).\n", name);
 
+	devfs_mk_dir("dvb/adapter%d", num);
 	adap->num = num;
 	adap->name = name;
 	adap->module = module;
@@ -311,6 +319,8 @@
 
 int dvb_unregister_adapter(struct dvb_adapter *adap)
 {
+	devfs_remove("dvb/adapter%d", adap->num);
+
 	if (mutex_lock_interruptible(&dvbdev_register_lock))
 		return -ERESTARTSYS;
 	list_del (&adap->list_head);
@@ -400,6 +410,8 @@
 		goto error;
 	}
 
+	devfs_mk_dir("dvb");
+
 	dvb_class = class_create(THIS_MODULE, "dvb");
 	if (IS_ERR(dvb_class)) {
 		retval = PTR_ERR(dvb_class);
@@ -416,6 +428,7 @@
 
 static void __exit exit_dvbdev(void)
 {
+	devfs_remove("dvb");
 	class_destroy(dvb_class);
 	cdev_del(&dvb_device_cdev);
 	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
diff -urN linux-2.6.19.old/drivers/media/dvb/dvb-core/dvbdev.h linux-2.6.19.dev/drivers/media/dvb/dvb-core/dvbdev.h
--- linux-2.6.19.old/drivers/media/dvb/dvb-core/dvbdev.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/dvb/dvb-core/dvbdev.h	2006-12-14 03:12:59.000000000 +0100
@@ -27,6 +27,7 @@
 #include <linux/poll.h>
 #include <linux/fs.h>
 #include <linux/list.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
 
 #define DVB_MAJOR 212
diff -urN linux-2.6.19.old/drivers/media/dvb/ttpci/av7110.h linux-2.6.19.dev/drivers/media/dvb/ttpci/av7110.h
--- linux-2.6.19.old/drivers/media/dvb/ttpci/av7110.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/dvb/ttpci/av7110.h	2006-12-14 03:12:59.000000000 +0100
@@ -6,6 +6,10 @@
 #include <linux/netdevice.h>
 #include <linux/i2c.h>
 
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
+
 #include <linux/dvb/video.h>
 #include <linux/dvb/audio.h>
 #include <linux/dvb/dmx.h>
diff -urN linux-2.6.19.old/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c linux-2.6.19.dev/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c
--- linux-2.6.19.old/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/dvb/ttusb-budget/dvb-ttusb-budget.c	2006-12-14 03:12:59.000000000 +0100
@@ -126,6 +126,10 @@
 
 	int revision;
 
+#if 0
+	devfs_handle_t stc_devfs_handle;
+#endif
+
 	struct dvb_frontend* fe;
 };
 
@@ -1741,6 +1745,13 @@
 		return -ENODEV;
 	}
 
+#if 0
+	ttusb->stc_devfs_handle =
+	    devfs_register(ttusb->adapter->devfs_handle, TTUSB_BUDGET_NAME,
+			   DEVFS_FL_DEFAULT, 0, 192,
+			   S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP
+			   | S_IROTH | S_IWOTH, &stc_fops, ttusb);
+#endif
 	usb_set_intfdata(intf, (void *) ttusb);
 
 	frontend_init(ttusb);
diff -urN linux-2.6.19.old/drivers/media/radio/miropcm20-rds.c linux-2.6.19.dev/drivers/media/radio/miropcm20-rds.c
--- linux-2.6.19.old/drivers/media/radio/miropcm20-rds.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/radio/miropcm20-rds.c	2006-12-14 03:12:59.000000000 +0100
@@ -115,6 +115,7 @@
 static struct miscdevice rds_miscdev = {
 	.minor		= MISC_DYNAMIC_MINOR,
 	.name		= "radiotext",
+	.devfs_name	= "v4l/rds/radiotext",
 	.fops		= &rds_fops,
 };
 
diff -urN linux-2.6.19.old/drivers/media/video/arv.c linux-2.6.19.dev/drivers/media/video/arv.c
--- linux-2.6.19.old/drivers/media/video/arv.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/video/arv.c	2006-12-14 03:12:59.000000000 +0100
@@ -19,6 +19,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
diff -urN linux-2.6.19.old/drivers/media/video/videodev.c linux-2.6.19.dev/drivers/media/video/videodev.c
--- linux-2.6.19.old/drivers/media/video/videodev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/media/video/videodev.c	2006-12-14 03:12:59.000000000 +0100
@@ -38,6 +38,7 @@
 #include <linux/init.h>
 #include <linux/kmod.h>
 #include <linux/slab.h>
+#include <linux/devfs_fs_kernel.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 
@@ -1593,6 +1594,10 @@
 	video_device[i]=vfd;
 	vfd->minor=i;
 	mutex_unlock(&videodev_lock);
+
+	sprintf(vfd->devfs_name, "v4l/%s%d", name_base, i - base);
+	devfs_mk_cdev(MKDEV(VIDEO_MAJOR, vfd->minor),
+			S_IFCHR | S_IRUSR | S_IWUSR, vfd->devfs_name);
 	mutex_init(&vfd->lock);
 
 	/* sysfs class */
@@ -1602,6 +1607,7 @@
 	vfd->class_dev.class       = &video_class;
 	vfd->class_dev.devt        = MKDEV(VIDEO_MAJOR, vfd->minor);
 	sprintf(vfd->class_dev.class_id, "%s%d", name_base, i - base);
+	strlcpy(vfd->class_dev.class_id, vfd->devfs_name + 4, BUS_ID_SIZE);
 	ret = class_device_register(&vfd->class_dev);
 	if (ret < 0) {
 		printk(KERN_ERR "%s: class_device_register failed\n",
@@ -1648,6 +1654,7 @@
 	if(video_device[vfd->minor]!=vfd)
 		panic("videodev: bad unregister");
 
+	devfs_remove(vfd->devfs_name);
 	video_device[vfd->minor]=NULL;
 	class_device_unregister(&vfd->class_dev);
 	mutex_unlock(&videodev_lock);
diff -urN linux-2.6.19.old/drivers/message/i2o/i2o_block.c linux-2.6.19.dev/drivers/message/i2o/i2o_block.c
--- linux-2.6.19.old/drivers/message/i2o/i2o_block.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/message/i2o/i2o_block.c	2006-12-14 03:12:59.000000000 +0100
@@ -1090,6 +1090,7 @@
 	gd = i2o_blk_dev->gd;
 	gd->first_minor = unit << 4;
 	sprintf(gd->disk_name, "i2o/hd%c", 'a' + unit);
+	sprintf(gd->devfs_name, "i2o/hd%c", 'a' + unit);
 	gd->driverfs_dev = &i2o_dev->device;
 
 	/* setup request queue */
diff -urN linux-2.6.19.old/drivers/mmc/mmc_block.c linux-2.6.19.dev/drivers/mmc/mmc_block.c
--- linux-2.6.19.old/drivers/mmc/mmc_block.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/mmc/mmc_block.c	2006-12-14 03:12:59.000000000 +0100
@@ -27,6 +27,7 @@
 #include <linux/hdreg.h>
 #include <linux/kdev_t.h>
 #include <linux/blkdev.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/mutex.h>
 #include <linux/scatterlist.h>
 
@@ -472,6 +473,7 @@
 	 */
 
 	sprintf(md->disk->disk_name, "mmcblk%d", devidx);
+	sprintf(md->disk->devfs_name, "mmc/blk%d", devidx);
 
 	blk_queue_hardsect_size(md->queue.queue, 1 << md->block_bits);
 
@@ -617,6 +619,7 @@
 	if (major == 0)
 		major = res;
 
+	devfs_mk_dir("mmc");
 	return mmc_register_driver(&mmc_driver);
 
  out:
@@ -626,6 +629,7 @@
 static void __exit mmc_blk_exit(void)
 {
 	mmc_unregister_driver(&mmc_driver);
+	devfs_remove("mmc");
 	unregister_blkdev(major, "mmc");
 }
 
diff -urN linux-2.6.19.old/drivers/mtd/mtd_blkdevs.c linux-2.6.19.dev/drivers/mtd/mtd_blkdevs.c
--- linux-2.6.19.old/drivers/mtd/mtd_blkdevs.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/mtd/mtd_blkdevs.c	2006-12-14 03:12:59.000000000 +0100
@@ -21,6 +21,9 @@
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <asm/uaccess.h>
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#endif
 
 static LIST_HEAD(blktrans_majors);
 
@@ -295,6 +298,11 @@
 		snprintf(gd->disk_name, sizeof(gd->disk_name),
 			 "%s%d", tr->name, new->devnum);
 
+#ifdef CONFIG_DEVFS_FS
+		snprintf(gd->devfs_name, sizeof(gd->devfs_name),
+			 "%s/%c", tr->name, (tr->part_bits?'a':'0') + new->devnum);
+#endif
+
 	/* 2.5 has capacity in units of 512 bytes while still
 	   having BLOCK_SIZE_BITS set to 10. Just to keep us amused. */
 	set_capacity(gd, (new->size * new->blksize) >> 9);
@@ -411,6 +419,10 @@
 		return ret;
 	}
 
+#ifdef CONFIG_DEVFS_FS
+	devfs_mk_dir(tr->name);
+#endif
+
 	INIT_LIST_HEAD(&tr->devs);
 	list_add(&tr->list, &blktrans_majors);
 
@@ -443,6 +455,10 @@
 		tr->remove_dev(dev);
 	}
 
+#ifdef CONFIG_DEVFS_FS
+	devfs_remove(tr->name);
+#endif
+
 	blk_cleanup_queue(tr->blkcore_priv->rq);
 	unregister_blkdev(tr->major, tr->name);
 
diff -urN linux-2.6.19.old/drivers/mtd/mtdchar.c linux-2.6.19.dev/drivers/mtd/mtdchar.c
--- linux-2.6.19.old/drivers/mtd/mtdchar.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/mtd/mtdchar.c	2006-12-14 03:12:59.000000000 +0100
@@ -18,19 +18,33 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_DEVFS_FS
+#include <linux/devfs_fs_kernel.h>
+#else
+#include <linux/device.h>
+
 static struct class *mtd_class;
+#endif
 
 static void mtd_notify_add(struct mtd_info* mtd)
 {
 	if (!mtd)
 		return;
 
+#ifdef CONFIG_DEVFS_FS
+	devfs_mk_cdev(MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
+			S_IFCHR | S_IRUGO | S_IWUGO, "mtd/%d", mtd->index);
+
+	devfs_mk_cdev(MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
+			S_IFCHR | S_IRUGO, "mtd/%dro", mtd->index);
+#else
 	class_device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd->index*2),
 			    NULL, "mtd%d", mtd->index);
 
 	class_device_create(mtd_class, NULL,
 			    MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1),
 			    NULL, "mtd%dro", mtd->index);
+#endif
 }
 
 static void mtd_notify_remove(struct mtd_info* mtd)
@@ -38,8 +52,13 @@
 	if (!mtd)
 		return;
 
+#ifdef CONFIG_DEVFS_FS
+	devfs_remove("mtd/%d", mtd->index);
+	devfs_remove("mtd/%dro", mtd->index);
+#else
 	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2));
 	class_device_destroy(mtd_class, MKDEV(MTD_CHAR_MAJOR, mtd->index*2+1));
+#endif
 }
 
 static struct mtd_notifier notifier = {
@@ -47,6 +66,22 @@
 	.remove	= mtd_notify_remove,
 };
 
+#ifdef CONFIG_DEVFS_FS
+	static inline void mtdchar_devfs_init(void)
+	{
+		devfs_mk_dir("mtd");
+		register_mtd_user(&notifier);
+	}
+	static inline void mtdchar_devfs_exit(void)
+	{
+		unregister_mtd_user(&notifier);
+		devfs_remove("mtd");
+	}
+	#else /* !DEVFS */
+	#define mtdchar_devfs_init() do { } while(0)
+	#define mtdchar_devfs_exit() do { } while(0)
+#endif
+
 /*
  * Data structure to hold the pointer to the mtd device as well
  * as mode information ofr various use cases.
@@ -778,6 +813,9 @@
 		return -EAGAIN;
 	}
 
+#ifdef CONFIG_DEVFS_FS
+	mtdchar_devfs_init();
+#else
 	mtd_class = class_create(THIS_MODULE, "mtd");
 
 	if (IS_ERR(mtd_class)) {
@@ -787,13 +825,19 @@
 	}
 
 	register_mtd_user(&notifier);
+#endif
 	return 0;
 }
 
 static void __exit cleanup_mtdchar(void)
 {
+
+#ifdef CONFIG_DEVFS_FS
+	mtdchar_devfs_exit();
+#else
 	unregister_mtd_user(&notifier);
 	class_destroy(mtd_class);
+#endif
 	unregister_chrdev(MTD_CHAR_MAJOR, "mtd");
 }
 
diff -urN linux-2.6.19.old/drivers/net/ppp_generic.c linux-2.6.19.dev/drivers/net/ppp_generic.c
--- linux-2.6.19.old/drivers/net/ppp_generic.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/net/ppp_generic.c	2006-12-14 03:12:59.000000000 +0100
@@ -27,6 +27,7 @@
 #include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/list.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/netdevice.h>
 #include <linux/poll.h>
 #include <linux/ppp_defs.h>
@@ -861,6 +862,10 @@
 			goto out_chrdev;
 		}
 		class_device_create(ppp_class, NULL, MKDEV(PPP_MAJOR, 0), NULL, "ppp");
+		err = devfs_mk_cdev(MKDEV(PPP_MAJOR, 0),
+				S_IFCHR|S_IRUSR|S_IWUSR, "ppp");
+		if (err)
+			goto out_chrdev;
 	}
 
 out:
@@ -2675,6 +2680,7 @@
 	cardmap_destroy(&all_ppp_units);
 	if (unregister_chrdev(PPP_MAJOR, "ppp") != 0)
 		printk(KERN_ERR "PPP: failed to unregister PPP device\n");
+	devfs_remove("ppp");
 	class_device_destroy(ppp_class, MKDEV(PPP_MAJOR, 0));
 	class_destroy(ppp_class);
 }
diff -urN linux-2.6.19.old/drivers/net/tun.c linux-2.6.19.dev/drivers/net/tun.c
--- linux-2.6.19.old/drivers/net/tun.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/net/tun.c	2006-12-14 03:12:59.000000000 +0100
@@ -762,6 +762,7 @@
 	.minor = TUN_MINOR,
 	.name = "tun",
 	.fops = &tun_fops,
+	.devfs_name = "net/tun",
 };
 
 /* ethtool interface */
diff -urN linux-2.6.19.old/drivers/net/wan/cosa.c linux-2.6.19.dev/drivers/net/wan/cosa.c
--- linux-2.6.19.old/drivers/net/wan/cosa.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/net/wan/cosa.c	2006-12-14 03:12:59.000000000 +0100
@@ -84,6 +84,7 @@
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/errno.h>
@@ -391,6 +392,7 @@
 		err = -ENODEV;
 		goto out;
 	}
+	devfs_mk_dir("cosa");
 	cosa_class = class_create(THIS_MODULE, "cosa");
 	if (IS_ERR(cosa_class)) {
 		err = PTR_ERR(cosa_class);
@@ -399,6 +401,13 @@
 	for (i=0; i<nr_cards; i++) {
 		class_device_create(cosa_class, NULL, MKDEV(cosa_major, i),
 				NULL, "cosa%d", i);
+		err = devfs_mk_cdev(MKDEV(cosa_major, i),
+				S_IFCHR|S_IRUSR|S_IWUSR,
+				"cosa/%d", i);
+		if (err) {
+			class_device_destroy(cosa_class, MKDEV(cosa_major, i));
+			goto out_chrdev;		
+		}
 	}
 	err = 0;
 	goto out;
@@ -416,9 +425,12 @@
 	int i;
 	printk(KERN_INFO "Unloading the cosa module\n");
 
-	for (i=0; i<nr_cards; i++)
+	for (i=0; i<nr_cards; i++) {
 		class_device_destroy(cosa_class, MKDEV(cosa_major, i));
+		devfs_remove("cosa/%d", i);
+	}
 	class_destroy(cosa_class);
+	devfs_remove("cosa");
 	for (cosa=cosa_cards; nr_cards--; cosa++) {
 		/* Clean up the per-channel data */
 		for (i=0; i<cosa->nchannels; i++) {
diff -urN linux-2.6.19.old/drivers/s390/block/dasd.c linux-2.6.19.dev/drivers/s390/block/dasd.c
--- linux-2.6.19.old/drivers/s390/block/dasd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/s390/block/dasd.c	2006-12-14 03:12:59.000000000 +0100
@@ -1903,6 +1903,7 @@
 	}
 	dasd_gendisk_exit();
 	dasd_devmap_exit();
+	devfs_remove("dasd");
 	if (dasd_debug_area != NULL) {
 		debug_unregister(dasd_debug_area);
 		dasd_debug_area = NULL;
@@ -2176,6 +2177,9 @@
 
 	dasd_diag_discipline_pointer = NULL;
 
+	rc = devfs_mk_dir("dasd");
+	if (rc)
+		goto failed;
 	rc = dasd_devmap_init();
 	if (rc)
 		goto failed;
diff -urN linux-2.6.19.old/drivers/s390/block/dasd_genhd.c linux-2.6.19.dev/drivers/s390/block/dasd_genhd.c
--- linux-2.6.19.old/drivers/s390/block/dasd_genhd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/s390/block/dasd_genhd.c	2006-12-14 03:12:59.000000000 +0100
@@ -67,6 +67,8 @@
 	}
 	len += sprintf(gdp->disk_name + len, "%c", 'a'+(device->devindex%26));
 
+ 	sprintf(gdp->devfs_name, "dasd/%s", device->cdev->dev.bus_id);
+
 	if (device->features & DASD_FEATURE_READONLY)
 		set_disk_ro(gdp, 1);
 	gdp->private_data = device;
diff -urN linux-2.6.19.old/drivers/s390/block/dasd_int.h linux-2.6.19.dev/drivers/s390/block/dasd_int.h
--- linux-2.6.19.old/drivers/s390/block/dasd_int.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/s390/block/dasd_int.h	2006-12-14 03:12:59.000000000 +0100
@@ -54,6 +54,7 @@
 #include <linux/module.h>
 #include <linux/wait.h>
 #include <linux/blkdev.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/genhd.h>
 #include <linux/hdreg.h>
 #include <linux/interrupt.h>
diff -urN linux-2.6.19.old/drivers/s390/block/xpram.c linux-2.6.19.dev/drivers/s390/block/xpram.c
--- linux-2.6.19.old/drivers/s390/block/xpram.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/s390/block/xpram.c	2006-12-14 03:12:59.000000000 +0100
@@ -36,6 +36,7 @@
 #include <linux/hdreg.h>  /* HDIO_GETGEO */
 #include <linux/sysdev.h>
 #include <linux/bio.h>
+#include <linux/devfs_fs_kernel.h>
 #include <asm/uaccess.h>
 
 #define XPRAM_NAME	"xpram"
@@ -363,6 +364,8 @@
 	if (rc < 0)
 		goto out;
 
+	devfs_mk_dir("slram");
+
 	/*
 	 * Assign the other needed values: make request function, sizes and
 	 * hardsect size. All the minor devices feature the same value.
@@ -391,12 +394,14 @@
 		disk->private_data = &xpram_devices[i];
 		disk->queue = xpram_queue;
 		sprintf(disk->disk_name, "slram%d", i);
+		sprintf(disk->devfs_name, "slram/%d", i);
 		set_capacity(disk, xpram_sizes[i] << 1);
 		add_disk(disk);
 	}
 
 	return 0;
 out_unreg:
+	devfs_remove("slram");
 	unregister_blkdev(XPRAM_MAJOR, XPRAM_NAME);
 out:
 	while (i--)
@@ -415,7 +420,10 @@
 		put_disk(xpram_disks[i]);
 	}
 	unregister_blkdev(XPRAM_MAJOR, XPRAM_NAME);
+	devfs_remove("slram");
 	blk_cleanup_queue(xpram_queue);
+	sysdev_unregister(&xpram_sys_device);
+	sysdev_class_unregister(&xpram_sysclass);
 }
 
 static int __init xpram_init(void)
diff -urN linux-2.6.19.old/drivers/s390/char/monreader.c linux-2.6.19.dev/drivers/s390/char/monreader.c
--- linux-2.6.19.old/drivers/s390/char/monreader.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/s390/char/monreader.c	2006-12-14 03:12:59.000000000 +0100
@@ -586,6 +586,7 @@
 
 static struct miscdevice mon_dev = {
 	.name       = "monreader",
+	.devfs_name = "monreader",
 	.fops       = &mon_fops,
 	.minor      = MISC_DYNAMIC_MINOR,
 };
diff -urN linux-2.6.19.old/drivers/s390/char/tty3270.c linux-2.6.19.dev/drivers/s390/char/tty3270.c
--- linux-2.6.19.old/drivers/s390/char/tty3270.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/s390/char/tty3270.c	2006-12-14 03:12:59.000000000 +0100
@@ -1783,6 +1783,7 @@
 	 * proc_entry, set_termios, flush_buffer, set_ldisc, write_proc
 	 */
 	driver->owner = THIS_MODULE;
+	driver->devfs_name = "ttyTUB/";
 	driver->driver_name = "ttyTUB";
 	driver->name = "ttyTUB";
 	driver->major = IBM_TTY3270_MAJOR;
@@ -1790,7 +1791,7 @@
 	driver->type = TTY_DRIVER_TYPE_SYSTEM;
 	driver->subtype = SYSTEM_TYPE_TTY;
 	driver->init_termios = tty_std_termios;
-	driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_DYNAMIC_DEV;
+	driver->flags = TTY_DRIVER_RESET_TERMIOS | TTY_DRIVER_NO_DEVFS;
 	tty_set_operations(driver, &tty3270_ops);
 	ret = tty_register_driver(driver);
 	if (ret) {
diff -urN linux-2.6.19.old/drivers/sbus/char/bpp.c linux-2.6.19.dev/drivers/sbus/char/bpp.c
--- linux-2.6.19.old/drivers/sbus/char/bpp.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/sbus/char/bpp.c	2006-12-14 03:12:59.000000000 +0100
@@ -20,6 +20,7 @@
 #include <linux/timer.h>
 #include <linux/ioport.h>
 #include <linux/major.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -1030,6 +1031,11 @@
 		instances[idx].opened = 0;
 		probeLptPort(idx);
 	}
+	devfs_mk_dir("bpp");
+	for (idx = 0; idx < BPP_NO; idx++) {
+		devfs_mk_cdev(MKDEV(BPP_MAJOR, idx),
+				S_IFCHR | S_IRUSR | S_IWUSR, "bpp/%d", idx);
+	}
 
 	return 0;
 }
@@ -1038,6 +1044,9 @@
 {
 	unsigned idx;
 
+	for (idx = 0; idx < BPP_NO; idx++)
+		devfs_remove("bpp/%d", idx);
+	devfs_remove("bpp");
 	unregister_chrdev(BPP_MAJOR, dev_name);
 
 	for (idx = 0;  idx < BPP_NO; idx++) {
diff -urN linux-2.6.19.old/drivers/sbus/char/vfc_dev.c linux-2.6.19.dev/drivers/sbus/char/vfc_dev.c
--- linux-2.6.19.old/drivers/sbus/char/vfc_dev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/sbus/char/vfc_dev.c	2006-12-14 03:12:59.000000000 +0100
@@ -164,6 +164,10 @@
 		return -EINVAL;
 	if (init_vfc_hw(dev))
 		return -EIO;
+
+	devfs_mk_cdev(MKDEV(VFC_MAJOR, instance),
+			S_IFCHR | S_IRUSR | S_IWUSR,
+			"vfc/%d", instance);
 	return 0;
 }
 
@@ -673,6 +677,7 @@
 		kfree(vfc_dev_lst);
 		return -EIO;
 	}
+	devfs_mk_dir("vfc");
 	instance = 0;
 	for_all_sbusdev(sdev, sbus) {
 		if (strcmp(sdev->prom_name, "vfc") == 0) {
@@ -712,6 +717,7 @@
 {
 	if(dev == NULL)
 		return;
+	devfs_remove("vfc/%d", dev->instance);
 	sbus_iounmap(dev->regs, sizeof(struct vfc_regs));
 	kfree(dev);
 }
@@ -725,6 +731,7 @@
 	for (devp = vfc_dev_lst; *devp; devp++)
 		deinit_vfc_device(*devp);
 
+	devfs_remove("vfc");
 	kfree(vfc_dev_lst);
 	return;
 }
diff -urN linux-2.6.19.old/drivers/sbus/char/vfc.h linux-2.6.19.dev/drivers/sbus/char/vfc.h
--- linux-2.6.19.old/drivers/sbus/char/vfc.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/sbus/char/vfc.h	2006-12-14 03:12:59.000000000 +0100
@@ -1,6 +1,8 @@
 #ifndef _LINUX_VFC_H_
 #define _LINUX_VFC_H_
 
+#include <linux/devfs_fs_kernel.h>
+
 /*
  * The control register for the vfc is at offset 0x4000
  * The first field ram bank is located at offset 0x5000
diff -urN linux-2.6.19.old/drivers/scsi/osst.c linux-2.6.19.dev/drivers/scsi/osst.c
--- linux-2.6.19.old/drivers/scsi/osst.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/osst.c	2006-12-14 03:12:59.000000000 +0100
@@ -48,6 +48,7 @@
 #include <linux/vmalloc.h>
 #include <linux/blkdev.h>
 #include <linux/moduleparam.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/delay.h>
 #include <linux/jiffies.h>
 #include <asm/uaccess.h>
@@ -5859,6 +5860,18 @@
 		STps->drv_block = (-1);
 		STps->drv_file = (-1);
 	}
+	for (mode = 0; mode < ST_NBR_MODES; ++mode) {
+		/*  Rewind entry  */
+		devfs_mk_cdev(MKDEV(OSST_MAJOR, dev_num + (mode << 5)),
+				S_IFCHR | S_IRUGO | S_IWUGO,
+				"%s/ot%s", SDp->devfs_name, osst_formats[mode]);
+
+		/*  No-rewind entry  */
+		devfs_mk_cdev(MKDEV(OSST_MAJOR, dev_num + (mode << 5) + 128),
+				S_IFCHR | S_IRUGO | S_IWUGO,
+				"%s/ot%sn", SDp->devfs_name, osst_formats[mode]);
+	}
+	drive->number = devfs_register_tape(SDp->devfs_name);
 
 	tpnt->current_mode = 0;
 	tpnt->modes[0].defined = 1;
@@ -5914,6 +5927,11 @@
 			osst_sysfs_destroy(MKDEV(OSST_MAJOR, i));
 			osst_sysfs_destroy(MKDEV(OSST_MAJOR, i+128));
 			tpnt->device = NULL;
+			for (mode = 0; mode < ST_NBR_MODES; ++mode) {
+				devfs_remove("%s/ot%s", SDp->devfs_name, osst_formats[mode]);
+				devfs_remove("%s/ot%sn", SDp->devfs_name, osst_formats[mode]);
+			}
+			devfs_unregister_tape(tpnt->drive->number);
 			put_disk(tpnt->drive);
 			os_scsi_tapes[i] = NULL;
 			osst_nr_dev--;
diff -urN linux-2.6.19.old/drivers/scsi/scsi.c linux-2.6.19.dev/drivers/scsi/scsi.c
--- linux-2.6.19.old/drivers/scsi/scsi.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/scsi.c	2006-12-14 03:12:59.000000000 +0100
@@ -48,6 +48,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/completion.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/unistd.h>
 #include <linux/spinlock.h>
 #include <linux/kmod.h>
@@ -1119,6 +1120,7 @@
 
 	scsi_netlink_init();
 
+	devfs_mk_dir("scsi");
 	printk(KERN_NOTICE "SCSI subsystem initialized\n");
 	return 0;
 
@@ -1144,6 +1146,7 @@
 	scsi_exit_sysctl();
 	scsi_exit_hosts();
 	scsi_exit_devinfo();
+	devfs_remove("scsi");
 	scsi_exit_procfs();
 	scsi_exit_queue();
 }
diff -urN linux-2.6.19.old/drivers/scsi/scsi_scan.c linux-2.6.19.dev/drivers/scsi/scsi_scan.c
--- linux-2.6.19.old/drivers/scsi/scsi_scan.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/scsi_scan.c	2006-12-14 03:12:59.000000000 +0100
@@ -719,8 +719,12 @@
 			sdev->inq_periph_qual, inq_result[2] & 0x07,
 			(inq_result[3] & 0x0f) == 1 ? " CCS" : "");
 
+	sprintf(sdev->devfs_name, "scsi/host%d/bus%d/target%d/lun%d",
+				sdev->host->host_no, sdev->channel,
+				sdev->id, sdev->lun);
+
 	/*
-	 * End sysfs code.
+	 * End driverfs/devfs code.
 	 */
 
 	if ((sdev->scsi_level >= SCSI_2) && (inq_result[7] & 2) &&
diff -urN linux-2.6.19.old/drivers/scsi/sd.c linux-2.6.19.dev/drivers/scsi/sd.c
--- linux-2.6.19.old/drivers/scsi/sd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/sd.c	2006-12-14 03:12:59.000000000 +0100
@@ -1687,6 +1687,8 @@
 			'a' + m1, 'a' + m2, 'a' + m3);
 	}
 
+	strcpy(gd->devfs_name, sdp->devfs_name);
+
 	gd->private_data = &sdkp->driver;
 	gd->queue = sdkp->device->request_queue;
 
diff -urN linux-2.6.19.old/drivers/scsi/sg.c linux-2.6.19.dev/drivers/scsi/sg.c
--- linux-2.6.19.old/drivers/scsi/sg.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/sg.c	2006-12-14 03:12:59.000000000 +0100
@@ -43,6 +43,7 @@
 #include <linux/poll.h>
 #include <linux/smp_lock.h>
 #include <linux/moduleparam.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/cdev.h>
 #include <linux/seq_file.h>
 #include <linux/blkdev.h>
@@ -1530,6 +1531,7 @@
 		class_device_destroy(sg_sysfs_class, MKDEV(SCSI_GENERIC_MAJOR, k));
 		cdev_del(sdp->cdev);
 		sdp->cdev = NULL;
+		devfs_remove("%s/generic", scsidp->devfs_name);
 		put_disk(sdp->disk);
 		sdp->disk = NULL;
 		if (NULL == sdp->headfp)
diff -urN linux-2.6.19.old/drivers/scsi/sr.c linux-2.6.19.dev/drivers/scsi/sr.c
--- linux-2.6.19.old/drivers/scsi/sr.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/sr.c	2006-12-14 03:12:59.000000000 +0100
@@ -591,6 +591,8 @@
 	get_capabilities(cd);
 	sr_vendor_init(cd);
 
+	snprintf(disk->devfs_name, sizeof(disk->devfs_name),
+			"%s/cd", sdev->devfs_name);
 	disk->driverfs_dev = &sdev->sdev_gendev;
 	set_capacity(disk, cd->capacity);
 	disk->private_data = &cd->driver;
diff -urN linux-2.6.19.old/drivers/scsi/st.c linux-2.6.19.dev/drivers/scsi/st.c
--- linux-2.6.19.old/drivers/scsi/st.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/scsi/st.c	2006-12-14 03:12:59.000000000 +0100
@@ -35,6 +35,7 @@
 #include <linux/spinlock.h>
 #include <linux/blkdev.h>
 #include <linux/moduleparam.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/cdev.h>
 #include <linux/delay.h>
 #include <linux/mutex.h>
@@ -4056,6 +4057,21 @@
 			goto out_free_tape;
 	}
 
+	for (mode = 0; mode < ST_NBR_MODES; ++mode) {
+		/* Make sure that the minor numbers corresponding to the four
+		   first modes always get the same names */
+		i = mode << (4 - ST_NBR_MODE_BITS);
+		/*  Rewind entry  */
+		devfs_mk_cdev(MKDEV(SCSI_TAPE_MAJOR, TAPE_MINOR(dev_num, mode, 0)),
+			      S_IFCHR | S_IRUGO | S_IWUGO,
+			      "%s/mt%s", SDp->devfs_name, st_formats[i]);
+		/*  No-rewind entry  */
+		devfs_mk_cdev(MKDEV(SCSI_TAPE_MAJOR, TAPE_MINOR(dev_num, mode, 1)),
+			      S_IFCHR | S_IRUGO | S_IWUGO,
+			      "%s/mt%sn", SDp->devfs_name, st_formats[i]);
+	}
+	disk->number = devfs_register_tape(SDp->devfs_name);
+
 	sdev_printk(KERN_WARNING, SDp,
 		    "Attached scsi tape %s\n", tape_name(tpnt));
 	printk(KERN_WARNING "%s: try direct i/o: %s (alignment %d B)\n",
@@ -4109,9 +4125,13 @@
 			scsi_tapes[i] = NULL;
 			st_nr_dev--;
 			write_unlock(&st_dev_arr_lock);
+			devfs_unregister_tape(tpnt->disk->number);
 			sysfs_remove_link(&tpnt->device->sdev_gendev.kobj,
 					  "tape");
 			for (mode = 0; mode < ST_NBR_MODES; ++mode) {
+				j = mode << (4 - ST_NBR_MODE_BITS);
+				devfs_remove("%s/mt%s", SDp->devfs_name, st_formats[j]);
+				devfs_remove("%s/mt%sn", SDp->devfs_name, st_formats[j]);
 				for (j=0; j < 2; j++) {
 					class_device_destroy(st_sysfs_class,
 							     MKDEV(SCSI_TAPE_MAJOR,
diff -urN linux-2.6.19.old/drivers/serial/21285.c linux-2.6.19.dev/drivers/serial/21285.c
--- linux-2.6.19.old/drivers/serial/21285.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/21285.c	2006-12-14 03:12:59.000000000 +0100
@@ -478,6 +478,7 @@
 	.owner			= THIS_MODULE,
 	.driver_name		= "ttyFB",
 	.dev_name		= "ttyFB",
+	.devfs_name             = "ttyFB",
 	.major			= SERIAL_21285_MAJOR,
 	.minor			= SERIAL_21285_MINOR,
 	.nr			= 1,
diff -urN linux-2.6.19.old/drivers/serial/8250.c linux-2.6.19.dev/drivers/serial/8250.c
--- linux-2.6.19.old/drivers/serial/8250.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/8250.c	2006-12-14 03:12:59.000000000 +0100
@@ -2381,6 +2381,7 @@
 static struct uart_driver serial8250_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "serial",
+	.devfs_name		= "tts/",
 	.dev_name		= "ttyS",
 	.major			= TTY_MAJOR,
 	.minor			= 64,
diff -urN linux-2.6.19.old/drivers/serial/atmel_serial.c linux-2.6.19.dev/drivers/serial/atmel_serial.c
--- linux-2.6.19.old/drivers/serial/atmel_serial.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/atmel_serial.c	2006-12-14 03:12:59.000000000 +0100
@@ -875,6 +875,7 @@
 	.owner			= THIS_MODULE,
 	.driver_name		= "atmel_serial",
 	.dev_name		= ATMEL_DEVICENAME,
+	.devfs_name		= ATMEL_DEVICENAME,
 	.major			= SERIAL_ATMEL_MAJOR,
 	.minor			= MINOR_START,
 	.nr			= ATMEL_MAX_UART,
diff -urN linux-2.6.19.old/drivers/serial/crisv10.c linux-2.6.19.dev/drivers/serial/crisv10.c
--- linux-2.6.19.old/drivers/serial/crisv10.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/crisv10.c	2006-12-14 03:12:59.000000000 +0100
@@ -4877,7 +4877,7 @@
 	driver->init_termios = tty_std_termios;
 	driver->init_termios.c_cflag =
 		B115200 | CS8 | CREAD | HUPCL | CLOCAL; /* is normally B9600 default... */
-	driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	driver->termios = serial_termios;
 	driver->termios_locked = serial_termios_locked;
 
diff -urN linux-2.6.19.old/drivers/serial/dz.c linux-2.6.19.dev/drivers/serial/dz.c
--- linux-2.6.19.old/drivers/serial/dz.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/dz.c	2006-12-14 03:12:59.000000000 +0100
@@ -767,7 +767,11 @@
 static struct uart_driver dz_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "serial",
+#ifdef CONFIG_DEVFS
+	.dev_name		= "tts/%d",
+#else
 	.dev_name		= "ttyS%d",
+#endif
 	.major			= TTY_MAJOR,
 	.minor			= 64,
 	.nr			= DZ_NB_PORT,
diff -urN linux-2.6.19.old/drivers/serial/imx.c linux-2.6.19.dev/drivers/serial/imx.c
--- linux-2.6.19.old/drivers/serial/imx.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/imx.c	2006-12-14 03:12:59.000000000 +0100
@@ -887,6 +887,7 @@
 	.owner          = THIS_MODULE,
 	.driver_name    = DRIVER_NAME,
 	.dev_name       = "ttySMX",
+	.devfs_name	= "ttsmx/",
 	.major          = SERIAL_IMX_MAJOR,
 	.minor          = MINOR_START,
 	.nr             = ARRAY_SIZE(imx_ports),
diff -urN linux-2.6.19.old/drivers/serial/ip22zilog.c linux-2.6.19.dev/drivers/serial/ip22zilog.c
--- linux-2.6.19.old/drivers/serial/ip22zilog.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/ip22zilog.c	2006-12-14 03:12:59.000000000 +0100
@@ -1082,6 +1082,7 @@
 static struct uart_driver ip22zilog_reg = {
 	.owner		= THIS_MODULE,
 	.driver_name	= "serial",
+	.devfs_name	= "tts/",
 	.dev_name	= "ttyS",
 	.major		= TTY_MAJOR,
 	.minor		= 64,
diff -urN linux-2.6.19.old/drivers/serial/m32r_sio.c linux-2.6.19.dev/drivers/serial/m32r_sio.c
--- linux-2.6.19.old/drivers/serial/m32r_sio.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/m32r_sio.c	2006-12-14 03:12:59.000000000 +0100
@@ -1127,6 +1127,7 @@
 static struct uart_driver m32r_sio_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "sio",
+	.devfs_name		= "tts/",
 	.dev_name		= "ttyS",
 	.major			= TTY_MAJOR,
 	.minor			= 64,
diff -urN linux-2.6.19.old/drivers/serial/mcfserial.c linux-2.6.19.dev/drivers/serial/mcfserial.c
--- linux-2.6.19.old/drivers/serial/mcfserial.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/mcfserial.c	2006-12-14 03:12:59.000000000 +0100
@@ -1713,6 +1713,7 @@
 	/* Initialize the tty_driver structure */
 	mcfrs_serial_driver->owner = THIS_MODULE;
 	mcfrs_serial_driver->name = "ttyS";
+	mcfrs_serial_driver->devfs_name = "ttys/";
 	mcfrs_serial_driver->driver_name = "serial";
 	mcfrs_serial_driver->major = TTY_MAJOR;
 	mcfrs_serial_driver->minor_start = 64;
diff -urN linux-2.6.19.old/drivers/serial/mpc52xx_uart.c linux-2.6.19.dev/drivers/serial/mpc52xx_uart.c
--- linux-2.6.19.old/drivers/serial/mpc52xx_uart.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/mpc52xx_uart.c	2006-12-14 03:12:59.000000000 +0100
@@ -693,6 +693,7 @@
 	.owner		= THIS_MODULE,
 	.driver_name	= "mpc52xx_psc_uart",
 	.dev_name	= "ttyPSC",
+	.devfs_name	= "ttyPSC",
 	.major		= SERIAL_PSC_MAJOR,
 	.minor		= SERIAL_PSC_MINOR,
 	.nr		= MPC52xx_PSC_MAXNUM,
diff -urN linux-2.6.19.old/drivers/serial/mpsc.c linux-2.6.19.dev/drivers/serial/mpsc.c
--- linux-2.6.19.old/drivers/serial/mpsc.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/mpsc.c	2006-12-14 03:12:59.000000000 +0100
@@ -314,6 +314,7 @@
 #define MPSC_MAJOR		204
 #define MPSC_MINOR_START	44
 #define	MPSC_DRIVER_NAME	"MPSC"
+#define	MPSC_DEVFS_NAME		"ttymm/"
 #define	MPSC_DEV_NAME		"ttyMM"
 #define	MPSC_VERSION		"1.00"
 
@@ -1861,6 +1862,7 @@
 static struct uart_driver mpsc_reg = {
 	.owner       = THIS_MODULE,
 	.driver_name = MPSC_DRIVER_NAME,
+	.devfs_name  = MPSC_DEVFS_NAME,
 	.dev_name    = MPSC_DEV_NAME,
 	.major       = MPSC_MAJOR,
 	.minor       = MPSC_MINOR_START,
diff -urN linux-2.6.19.old/drivers/serial/pmac_zilog.c linux-2.6.19.dev/drivers/serial/pmac_zilog.c
--- linux-2.6.19.old/drivers/serial/pmac_zilog.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/pmac_zilog.c	2006-12-14 03:12:59.000000000 +0100
@@ -100,6 +100,7 @@
 static struct uart_driver pmz_uart_reg = {
 	.owner		=	THIS_MODULE,
 	.driver_name	=	"ttyS",
+	.devfs_name	=	"tts/",
 	.dev_name	=	"ttyS",
 	.major		=	TTY_MAJOR,
 };
diff -urN linux-2.6.19.old/drivers/serial/pxa.c linux-2.6.19.dev/drivers/serial/pxa.c
--- linux-2.6.19.old/drivers/serial/pxa.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/pxa.c	2006-12-14 03:12:59.000000000 +0100
@@ -777,6 +777,7 @@
 static struct uart_driver serial_pxa_reg = {
 	.owner		= THIS_MODULE,
 	.driver_name	= "PXA serial",
+	.devfs_name	= "tts/",
 	.dev_name	= "ttyS",
 	.major		= TTY_MAJOR,
 	.minor		= 64,
diff -urN linux-2.6.19.old/drivers/serial/s3c2410.c linux-2.6.19.dev/drivers/serial/s3c2410.c
--- linux-2.6.19.old/drivers/serial/s3c2410.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/s3c2410.c	2006-12-14 03:12:59.000000000 +0100
@@ -148,6 +148,7 @@
 /* UART name and device definitions */
 
 #define S3C24XX_SERIAL_NAME	"ttySAC"
+#define S3C24XX_SERIAL_DEVFS    "tts/"
 #define S3C24XX_SERIAL_MAJOR	204
 #define S3C24XX_SERIAL_MINOR	64
 
@@ -950,6 +951,7 @@
 	.nr		= 3,
 	.cons		= S3C24XX_SERIAL_CONSOLE,
 	.driver_name	= S3C24XX_SERIAL_NAME,
+	.devfs_name	= S3C24XX_SERIAL_DEVFS,
 	.major		= S3C24XX_SERIAL_MAJOR,
 	.minor		= S3C24XX_SERIAL_MINOR,
 };
diff -urN linux-2.6.19.old/drivers/serial/sa1100.c linux-2.6.19.dev/drivers/serial/sa1100.c
--- linux-2.6.19.old/drivers/serial/sa1100.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/sa1100.c	2006-12-14 03:12:59.000000000 +0100
@@ -815,6 +815,7 @@
 	.owner			= THIS_MODULE,
 	.driver_name		= "ttySA",
 	.dev_name		= "ttySA",
+	.devfs_name		= "ttySA",
 	.major			= SERIAL_SA1100_MAJOR,
 	.minor			= MINOR_START,
 	.nr			= NR_PORTS,
diff -urN linux-2.6.19.old/drivers/serial/serial_core.c linux-2.6.19.dev/drivers/serial/serial_core.c
--- linux-2.6.19.old/drivers/serial/serial_core.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/serial_core.c	2006-12-14 03:12:59.000000000 +0100
@@ -2182,6 +2182,7 @@
 
 	normal->owner		= drv->owner;
 	normal->driver_name	= drv->driver_name;
+	normal->devfs_name	= drv->devfs_name;
 	normal->name		= drv->dev_name;
 	normal->major		= drv->major;
 	normal->minor_start	= drv->minor;
@@ -2189,7 +2190,7 @@
 	normal->subtype		= SERIAL_TYPE_NORMAL;
 	normal->init_termios	= tty_std_termios;
 	normal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
-	normal->flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	normal->flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	normal->driver_state    = drv;
 	tty_set_operations(normal, &uart_ops);
 
diff -urN linux-2.6.19.old/drivers/serial/serial_txx9.c linux-2.6.19.dev/drivers/serial/serial_txx9.c
--- linux-2.6.19.old/drivers/serial/serial_txx9.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/serial_txx9.c	2006-12-14 03:12:59.000000000 +0100
@@ -68,10 +68,12 @@
 #if !defined(CONFIG_SERIAL_TXX9_STDSERIAL)
 /* "ttyS" is used for standard serial driver */
 #define TXX9_TTY_NAME "ttyTX"
+#define TXX9_TTY_DEVFS_NAME "tttx/"
 #define TXX9_TTY_MINOR_START	(64 + 64)	/* ttyTX0(128), ttyTX1(129) */
 #else
 /* acts like standard serial driver */
 #define TXX9_TTY_NAME "ttyS"
+#define TXX9_TTY_DEVFS_NAME "tts/"
 #define TXX9_TTY_MINOR_START	64
 #endif
 #define TXX9_TTY_MAJOR	TTY_MAJOR
@@ -968,6 +970,7 @@
 static struct uart_driver serial_txx9_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "serial_txx9",
+	.devfs_name		= TXX9_TTY_DEVFS_NAME,
 	.dev_name		= TXX9_TTY_NAME,
 	.major			= TXX9_TTY_MAJOR,
 	.minor			= TXX9_TTY_MINOR_START,
diff -urN linux-2.6.19.old/drivers/serial/sh-sci.c linux-2.6.19.dev/drivers/serial/sh-sci.c
--- linux-2.6.19.old/drivers/serial/sh-sci.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/sh-sci.c	2006-12-14 03:12:59.000000000 +0100
@@ -1320,6 +1320,9 @@
 static struct uart_driver sci_uart_driver = {
 	.owner		= THIS_MODULE,
 	.driver_name	= "sci",
+#ifdef CONFIG_DEVFS_FS
+	.devfs_name	= "ttsc/",
+#endif
 	.dev_name	= "ttySC",
 	.major		= SCI_MAJOR,
 	.minor		= SCI_MINOR_START,
diff -urN linux-2.6.19.old/drivers/serial/sunhv.c linux-2.6.19.dev/drivers/serial/sunhv.c
--- linux-2.6.19.old/drivers/serial/sunhv.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/sunhv.c	2006-12-14 03:12:59.000000000 +0100
@@ -353,6 +353,7 @@
 static struct uart_driver sunhv_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "serial",
+	.devfs_name		= "tts/",
 	.dev_name		= "ttyS",
 	.major			= TTY_MAJOR,
 };
diff -urN linux-2.6.19.old/drivers/serial/sunsab.c linux-2.6.19.dev/drivers/serial/sunsab.c
--- linux-2.6.19.old/drivers/serial/sunsab.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/sunsab.c	2006-12-14 03:12:59.000000000 +0100
@@ -849,6 +849,7 @@
 static struct uart_driver sunsab_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "serial",
+	.devfs_name		= "tts/",
 	.dev_name		= "ttyS",
 	.major			= TTY_MAJOR,
 };
diff -urN linux-2.6.19.old/drivers/serial/sunsu.c linux-2.6.19.dev/drivers/serial/sunsu.c
--- linux-2.6.19.old/drivers/serial/sunsu.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/sunsu.c	2006-12-14 03:12:59.000000000 +0100
@@ -1175,6 +1175,7 @@
 static struct uart_driver sunsu_reg = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "serial",
+	.devfs_name		= "tts/",
 	.dev_name		= "ttyS",
 	.major			= TTY_MAJOR,
 };
diff -urN linux-2.6.19.old/drivers/serial/sunzilog.c linux-2.6.19.dev/drivers/serial/sunzilog.c
--- linux-2.6.19.old/drivers/serial/sunzilog.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/sunzilog.c	2006-12-14 03:12:59.000000000 +0100
@@ -1006,6 +1006,7 @@
 static struct uart_driver sunzilog_reg = {
 	.owner		=	THIS_MODULE,
 	.driver_name	=	"ttyS",
+	.devfs_name	=	"tts/",
 	.dev_name	=	"ttyS",
 	.major		=	TTY_MAJOR,
 };
diff -urN linux-2.6.19.old/drivers/serial/v850e_uart.c linux-2.6.19.dev/drivers/serial/v850e_uart.c
--- linux-2.6.19.old/drivers/serial/v850e_uart.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/v850e_uart.c	2006-12-14 03:12:59.000000000 +0100
@@ -468,6 +468,7 @@
 static struct uart_driver v850e_uart_driver = {
 	.owner			= THIS_MODULE,
 	.driver_name		= "v850e_uart",
+	.devfs_name		= "tts/",
 	.dev_name		= "ttyS",
 	.major			= TTY_MAJOR,
 	.minor			= V850E_UART_MINOR_BASE,
diff -urN linux-2.6.19.old/drivers/serial/vr41xx_siu.c linux-2.6.19.dev/drivers/serial/vr41xx_siu.c
--- linux-2.6.19.old/drivers/serial/vr41xx_siu.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/serial/vr41xx_siu.c	2006-12-14 03:12:59.000000000 +0100
@@ -910,6 +910,7 @@
 	.owner		= THIS_MODULE,
 	.driver_name	= "SIU",
 	.dev_name	= "ttyVR",
+	.devfs_name	= "ttvr/",
 	.major		= SIU_MAJOR,
 	.minor		= SIU_MINOR_BASE,
 	.cons		= SERIAL_VR41XX_CONSOLE,
diff -urN linux-2.6.19.old/drivers/tc/zs.c linux-2.6.19.dev/drivers/tc/zs.c
--- linux-2.6.19.old/drivers/tc/zs.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/tc/zs.c	2006-12-14 03:12:59.000000000 +0100
@@ -1744,6 +1744,7 @@
 	/* Not all of this is exactly right for us. */
 
 	serial_driver->owner = THIS_MODULE;
+	serial_driver->devfs_name = "tts/";
 	serial_driver->name = "ttyS";
 	serial_driver->major = TTY_MAJOR;
 	serial_driver->minor_start = 64;
@@ -1752,7 +1753,7 @@
 	serial_driver->init_termios = tty_std_termios;
 	serial_driver->init_termios.c_cflag =
 		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
-	serial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	serial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	tty_set_operations(serial_driver, &serial_ops);
 
 	if (tty_register_driver(serial_driver))
diff -urN linux-2.6.19.old/drivers/telephony/phonedev.c linux-2.6.19.dev/drivers/telephony/phonedev.c
--- linux-2.6.19.old/drivers/telephony/phonedev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/telephony/phonedev.c	2006-12-14 03:12:59.000000000 +0100
@@ -28,6 +28,7 @@
 
 #include <linux/kmod.h>
 #include <linux/sem.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/mutex.h>
 
 #define PHONE_NUM_DEVICES	256
@@ -105,6 +106,8 @@
 		if (phone_device[i] == NULL) {
 			phone_device[i] = p;
 			p->minor = i;
+			devfs_mk_cdev(MKDEV(PHONE_MAJOR,i),
+				S_IFCHR|S_IRUSR|S_IWUSR, "phone/%d", i);
 			mutex_unlock(&phone_lock);
 			return 0;
 		}
@@ -122,6 +125,7 @@
 	mutex_lock(&phone_lock);
 	if (phone_device[pfd->minor] != pfd)
 		panic("phone: bad unregister");
+	devfs_remove("phone/%d", pfd->minor);
 	phone_device[pfd->minor] = NULL;
 	mutex_unlock(&phone_lock);
 }
diff -urN linux-2.6.19.old/drivers/usb/class/cdc-acm.c linux-2.6.19.dev/drivers/usb/class/cdc-acm.c
--- linux-2.6.19.old/drivers/usb/class/cdc-acm.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/usb/class/cdc-acm.c	2006-12-14 03:12:59.000000000 +0100
@@ -1151,11 +1151,12 @@
 	acm_tty_driver->owner = THIS_MODULE,
 	acm_tty_driver->driver_name = "acm",
 	acm_tty_driver->name = "ttyACM",
+	acm_tty_driver->devfs_name = "usb/acm/",
 	acm_tty_driver->major = ACM_TTY_MAJOR,
 	acm_tty_driver->minor_start = 0,
 	acm_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,
 	acm_tty_driver->subtype = SERIAL_TYPE_NORMAL,
-	acm_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	acm_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS,
 	acm_tty_driver->init_termios = tty_std_termios;
 	acm_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	tty_set_operations(acm_tty_driver, &acm_ops);
diff -urN linux-2.6.19.old/drivers/usb/gadget/serial.c linux-2.6.19.dev/drivers/usb/gadget/serial.c
--- linux-2.6.19.old/drivers/usb/gadget/serial.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/usb/gadget/serial.c	2006-12-14 03:12:59.000000000 +0100
@@ -587,11 +587,12 @@
 	gs_tty_driver->owner = THIS_MODULE;
 	gs_tty_driver->driver_name = GS_SHORT_NAME;
 	gs_tty_driver->name = "ttygs";
+	gs_tty_driver->devfs_name = "usb/ttygs/";
 	gs_tty_driver->major = GS_MAJOR;
 	gs_tty_driver->minor_start = GS_MINOR_START;
 	gs_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	gs_tty_driver->subtype = SERIAL_TYPE_NORMAL;
-	gs_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	gs_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	gs_tty_driver->init_termios = tty_std_termios;
 	gs_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	tty_set_operations(gs_tty_driver, &gs_tty_ops);
diff -urN linux-2.6.19.old/drivers/usb/serial/usb-serial.c linux-2.6.19.dev/drivers/usb/serial/usb-serial.c
--- linux-2.6.19.old/drivers/usb/serial/usb-serial.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/usb/serial/usb-serial.c	2006-12-14 03:12:59.000000000 +0100
@@ -1055,12 +1055,13 @@
 
 	usb_serial_tty_driver->owner = THIS_MODULE;
 	usb_serial_tty_driver->driver_name = "usbserial";
+	usb_serial_tty_driver->devfs_name = "usb/tts/";
 	usb_serial_tty_driver->name = 	"ttyUSB";
 	usb_serial_tty_driver->major = SERIAL_TTY_MAJOR;
 	usb_serial_tty_driver->minor_start = 0;
 	usb_serial_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;
 	usb_serial_tty_driver->subtype = SERIAL_TYPE_NORMAL;
-	usb_serial_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	usb_serial_tty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	usb_serial_tty_driver->init_termios = tty_std_termios;
 	usb_serial_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	tty_set_operations(usb_serial_tty_driver, &serial_ops);
diff -urN linux-2.6.19.old/drivers/video/fbmem.c linux-2.6.19.dev/drivers/video/fbmem.c
--- linux-2.6.19.old/drivers/video/fbmem.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/drivers/video/fbmem.c	2006-12-14 03:12:59.000000000 +0100
@@ -31,6 +31,7 @@
 #ifdef CONFIG_KMOD
 #include <linux/kmod.h>
 #endif
+#include <linux/devfs_fs_kernel.h>
 #include <linux/err.h>
 #include <linux/device.h>
 #include <linux/efi.h>
@@ -1324,6 +1325,8 @@
 	fb_add_videomode(&mode, &fb_info->modelist);
 	registered_fb[i] = fb_info;
 
+	devfs_mk_cdev(MKDEV(FB_MAJOR, i),
+			S_IFCHR | S_IRUGO | S_IWUGO, "fb/%d", i);
 	event.info = fb_info;
 	fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &event);
 	return 0;
@@ -1349,6 +1352,7 @@
 	i = fb_info->node;
 	if (!registered_fb[i])
 		return -EINVAL;
+	devfs_remove("fb/%d", i);
 
 	if (fb_info->pixmap.addr &&
 	    (fb_info->pixmap.flags & FB_PIXMAP_DEFAULT))
@@ -1400,6 +1404,7 @@
 {
 	create_proc_read_entry("fb", 0, NULL, fbmem_read_proc, NULL);
 
+	devfs_mk_dir("fb");
 	if (register_chrdev(FB_MAJOR,"fb",&fb_fops))
 		printk("unable to get major %d for fb devs\n", FB_MAJOR);
 
diff -urN linux-2.6.19.old/fs/block_dev.c linux-2.6.19.dev/fs/block_dev.c
--- linux-2.6.19.old/fs/block_dev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/block_dev.c	2006-12-14 03:12:59.000000000 +0100
@@ -11,6 +11,7 @@
 #include <linux/slab.h>
 #include <linux/kmod.h>
 #include <linux/major.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
 #include <linux/highmem.h>
 #include <linux/blkdev.h>
diff -urN linux-2.6.19.old/fs/char_dev.c linux-2.6.19.dev/fs/char_dev.c
--- linux-2.6.19.old/fs/char_dev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/char_dev.c	2006-12-14 03:12:59.000000000 +0100
@@ -13,6 +13,7 @@
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/smp_lock.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/seq_file.h>
 
 #include <linux/kobject.h>
diff -urN linux-2.6.19.old/fs/coda/psdev.c linux-2.6.19.dev/fs/coda/psdev.c
--- linux-2.6.19.old/fs/coda/psdev.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/coda/psdev.c	2006-12-14 03:12:59.000000000 +0100
@@ -28,6 +28,7 @@
 #include <linux/delay.h>
 #include <linux/skbuff.h>
 #include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/vmalloc.h>
 #include <linux/fs.h>
 #include <linux/file.h>
@@ -364,12 +365,22 @@
 		err = PTR_ERR(coda_psdev_class);
 		goto out_chrdev;
 	}		
-	for (i = 0; i < MAX_CODADEVS; i++)
+	devfs_mk_dir ("coda");
+	for (i = 0; i < MAX_CODADEVS; i++) {
 		class_device_create(coda_psdev_class, NULL,
 				MKDEV(CODA_PSDEV_MAJOR,i), NULL, "cfs%d", i);
+		err = devfs_mk_cdev(MKDEV(CODA_PSDEV_MAJOR, i),
+				S_IFCHR|S_IRUSR|S_IWUSR, "coda/%d", i);
+		if (err)
+			goto out_class;
+	}
 	coda_sysctl_init();
 	goto out;
 
+out_class:
+	for (i = 0; i < MAX_CODADEVS; i++) 
+		class_device_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));
+	class_destroy(coda_psdev_class);
 out_chrdev:
 	unregister_chrdev(CODA_PSDEV_MAJOR, "coda");
 out:
@@ -408,9 +419,12 @@
 	}
 	return 0;
 out:
-	for (i = 0; i < MAX_CODADEVS; i++)
+	for (i = 0; i < MAX_CODADEVS; i++) {
 		class_device_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));
+		devfs_remove("coda/%d", i);
+	}
 	class_destroy(coda_psdev_class);
+	devfs_remove("coda");
 	unregister_chrdev(CODA_PSDEV_MAJOR, "coda");
 	coda_sysctl_clean();
 out1:
@@ -427,9 +441,12 @@
         if ( err != 0 ) {
                 printk("coda: failed to unregister filesystem\n");
         }
-	for (i = 0; i < MAX_CODADEVS; i++)
+	for (i = 0; i < MAX_CODADEVS; i++) {
 		class_device_destroy(coda_psdev_class, MKDEV(CODA_PSDEV_MAJOR, i));
+		devfs_remove("coda/%d", i);
+	}
 	class_destroy(coda_psdev_class);
+	devfs_remove("coda");
 	unregister_chrdev(CODA_PSDEV_MAJOR, "coda");
 	coda_sysctl_clean();
 	coda_destroy_inodecache();
diff -urN linux-2.6.19.old/fs/compat_ioctl.c linux-2.6.19.dev/fs/compat_ioctl.c
--- linux-2.6.19.old/fs/compat_ioctl.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/compat_ioctl.c	2006-12-14 03:12:59.000000000 +0100
@@ -42,6 +42,7 @@
 #include <linux/cdrom.h>
 #include <linux/auto_fs.h>
 #include <linux/auto_fs4.h>
+#include <linux/devfs_fs.h>
 #include <linux/tty.h>
 #include <linux/vt_kern.h>
 #include <linux/fb.h>
diff -urN linux-2.6.19.old/fs/devfs/base.c linux-2.6.19.dev/fs/devfs/base.c
--- linux-2.6.19.old/fs/devfs/base.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/fs/devfs/base.c	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,2835 @@
+/*  devfs (Device FileSystem) driver.
+
+    Copyright (C) 1998-2002  Richard Gooch
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au
+    The postal address is:
+      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.
+
+    ChangeLog
+
+    19980110   Richard Gooch <rgooch@atnf.csiro.au>
+               Original version.
+  v0.1
+    19980111   Richard Gooch <rgooch@atnf.csiro.au>
+               Created per-fs inode table rather than using inode->u.generic_ip
+  v0.2
+    19980111   Richard Gooch <rgooch@atnf.csiro.au>
+               Created .epoch inode which has a ctime of 0.
+	       Fixed loss of named pipes when dentries lost.
+	       Fixed loss of inode data when devfs_register() follows mknod().
+  v0.3
+    19980111   Richard Gooch <rgooch@atnf.csiro.au>
+               Fix for when compiling with CONFIG_KERNELD.
+    19980112   Richard Gooch <rgooch@atnf.csiro.au>
+               Fix for readdir() which sometimes didn't show entries.
+	       Added <<tolerant>> option to <devfs_register>.
+  v0.4
+    19980113   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <devfs_fill_file> function.
+  v0.5
+    19980115   Richard Gooch <rgooch@atnf.csiro.au>
+               Added subdirectory support. Major restructuring.
+    19980116   Richard Gooch <rgooch@atnf.csiro.au>
+               Fixed <find_by_dev> to not search major=0,minor=0.
+	       Added symlink support.
+  v0.6
+    19980120   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <devfs_mk_dir> function and support directory unregister
+    19980120   Richard Gooch <rgooch@atnf.csiro.au>
+               Auto-ownership uses real uid/gid rather than effective uid/gid.
+  v0.7
+    19980121   Richard Gooch <rgooch@atnf.csiro.au>
+               Supported creation of sockets.
+  v0.8
+    19980122   Richard Gooch <rgooch@atnf.csiro.au>
+               Added DEVFS_FL_HIDE_UNREG flag.
+	       Interface change to <devfs_mk_symlink>.
+               Created <devfs_symlink> to support symlink(2).
+  v0.9
+    19980123   Richard Gooch <rgooch@atnf.csiro.au>
+               Added check to <devfs_fill_file> to check inode is in devfs.
+	       Added optional traversal of symlinks.
+  v0.10
+    19980124   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <devfs_get_flags> and <devfs_set_flags>.
+  v0.11
+    19980125   C. Scott Ananian <cananian@alumni.princeton.edu>
+               Created <devfs_find_handle>.
+    19980125   Richard Gooch <rgooch@atnf.csiro.au>
+               Allow removal of symlinks.
+  v0.12
+    19980125   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <devfs_set_symlink_destination>.
+    19980126   Richard Gooch <rgooch@atnf.csiro.au>
+               Moved DEVFS_SUPER_MAGIC into header file.
+	       Added DEVFS_FL_HIDE flag.
+	       Created <devfs_get_maj_min>.
+	       Created <devfs_get_handle_from_inode>.
+	       Fixed minor bug in <find_by_dev>.
+    19980127   Richard Gooch <rgooch@atnf.csiro.au>
+	       Changed interface to <find_by_dev>, <find_entry>,
+	       <devfs_unregister>, <devfs_fill_file> and <devfs_find_handle>.
+	       Fixed inode times when symlink created with symlink(2).
+  v0.13
+    19980129   C. Scott Ananian <cananian@alumni.princeton.edu>
+               Exported <devfs_set_symlink_destination>, <devfs_get_maj_min>
+	       and <devfs_get_handle_from_inode>.
+    19980129   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_unlink> to support unlink(2).
+  v0.14
+    19980129   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed kerneld support for entries in devfs subdirectories.
+    19980130   Richard Gooch <rgooch@atnf.csiro.au>
+	       Bugfixes in <call_kerneld>.
+  v0.15
+    19980207   Richard Gooch <rgooch@atnf.csiro.au>
+	       Call kerneld when looking up unregistered entries.
+  v0.16
+    19980326   Richard Gooch <rgooch@atnf.csiro.au>
+	       Modified interface to <devfs_find_handle> for symlink traversal.
+  v0.17
+    19980331   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed persistence bug with device numbers for manually created
+	       device files.
+	       Fixed problem with recreating symlinks with different content.
+  v0.18
+    19980401   Richard Gooch <rgooch@atnf.csiro.au>
+	       Changed to CONFIG_KMOD.
+	       Hide entries which are manually unlinked.
+	       Always invalidate devfs dentry cache when registering entries.
+	       Created <devfs_rmdir> to support rmdir(2).
+	       Ensure directories created by <devfs_mk_dir> are visible.
+  v0.19
+    19980402   Richard Gooch <rgooch@atnf.csiro.au>
+	       Invalidate devfs dentry cache when making directories.
+	       Invalidate devfs dentry cache when removing entries.
+	       Fixed persistence bug with fifos.
+  v0.20
+    19980421   Richard Gooch <rgooch@atnf.csiro.au>
+	       Print process command when debugging kerneld/kmod.
+	       Added debugging for register/unregister/change operations.
+    19980422   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added "devfs=" boot options.
+  v0.21
+    19980426   Richard Gooch <rgooch@atnf.csiro.au>
+	       No longer lock/unlock superblock in <devfs_put_super>.
+	       Drop negative dentries when they are released.
+	       Manage dcache more efficiently.
+  v0.22
+    19980427   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added DEVFS_FL_AUTO_DEVNUM flag.
+  v0.23
+    19980430   Richard Gooch <rgooch@atnf.csiro.au>
+	       No longer set unnecessary methods.
+  v0.24
+    19980504   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added PID display to <call_kerneld> debugging message.
+	       Added "after" debugging message to <call_kerneld>.
+    19980519   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added "diread" and "diwrite" boot options.
+    19980520   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed persistence problem with permissions.
+  v0.25
+    19980602   Richard Gooch <rgooch@atnf.csiro.au>
+	       Support legacy device nodes.
+	       Fixed bug where recreated inodes were hidden.
+  v0.26
+    19980602   Richard Gooch <rgooch@atnf.csiro.au>
+	       Improved debugging in <get_vfs_inode>.
+    19980607   Richard Gooch <rgooch@atnf.csiro.au>
+	       No longer free old dentries in <devfs_mk_dir>.
+	       Free all dentries for a given entry when deleting inodes.
+  v0.27
+    19980627   Richard Gooch <rgooch@atnf.csiro.au>
+	       Limit auto-device numbering to majors 128 to 239.
+  v0.28
+    19980629   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed inode times persistence problem.
+  v0.29
+    19980704   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed spelling in <devfs_readlink> debug.
+	       Fixed bug in <devfs_setup> parsing "dilookup".
+  v0.30
+    19980705   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed devfs inode leak when manually recreating inodes.
+	       Fixed permission persistence problem when recreating inodes.
+  v0.31
+    19980727   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed harmless "unused variable" compiler warning.
+	       Fixed modes for manually recreated device nodes.
+  v0.32
+    19980728   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added NULL devfs inode warning in <devfs_read_inode>.
+	       Force all inode nlink values to 1.
+  v0.33
+    19980730   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added "dimknod" boot option.
+	       Set inode nlink to 0 when freeing dentries.
+	       Fixed modes for manually recreated symlinks.
+  v0.34
+    19980802   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bugs in recreated directories and symlinks.
+  v0.35
+    19980806   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bugs in recreated device nodes.
+    19980807   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bug in currently unused <devfs_get_handle_from_inode>.
+	       Defined new <devfs_handle_t> type.
+	       Improved debugging when getting entries.
+	       Fixed bug where directories could be emptied.
+  v0.36
+    19980809   Richard Gooch <rgooch@atnf.csiro.au>
+	       Replaced dummy .epoch inode with .devfsd character device.
+    19980810   Richard Gooch <rgooch@atnf.csiro.au>
+	       Implemented devfsd protocol revision 0.
+  v0.37
+    19980819   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added soothing message to warning in <devfs_d_iput>.
+  v0.38
+    19980829   Richard Gooch <rgooch@atnf.csiro.au>
+	       Use GCC extensions for structure initialisations.
+	       Implemented async open notification.
+	       Incremented devfsd protocol revision to 1.
+  v0.39
+    19980908   Richard Gooch <rgooch@atnf.csiro.au>
+	       Moved async open notification to end of <devfs_open>.
+  v0.40
+    19980910   Richard Gooch <rgooch@atnf.csiro.au>
+	       Prepended "/dev/" to module load request.
+	       Renamed <call_kerneld> to <call_kmod>.
+  v0.41
+    19980910   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed typo "AYSNC" -> "ASYNC".
+  v0.42
+    19980910   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added open flag for files.
+  v0.43
+    19980927   Richard Gooch <rgooch@atnf.csiro.au>
+	       Set i_blocks=0 and i_blksize=1024 in <devfs_read_inode>.
+  v0.44
+    19981005   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added test for empty <<name>> in <devfs_find_handle>.
+	       Renamed <generate_path> to <devfs_generate_path> and published.
+  v0.45
+    19981006   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_get_fops>.
+  v0.46
+    19981007   Richard Gooch <rgooch@atnf.csiro.au>
+	       Limit auto-device numbering to majors 144 to 239.
+  v0.47
+    19981010   Richard Gooch <rgooch@atnf.csiro.au>
+	       Updated <devfs_follow_link> for VFS change in 2.1.125.
+  v0.48
+    19981022   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created DEVFS_ FL_COMPAT flag.
+  v0.49
+    19981023   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created "nocompat" boot option.
+  v0.50
+    19981025   Richard Gooch <rgooch@atnf.csiro.au>
+	       Replaced "mount" boot option with "nomount".
+  v0.51
+    19981110   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created "only" boot option.
+  v0.52
+    19981112   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added DEVFS_FL_REMOVABLE flag.
+  v0.53
+    19981114   Richard Gooch <rgooch@atnf.csiro.au>
+	       Only call <scan_dir_for_removable> on first call to
+	       <devfs_readdir>.
+  v0.54
+    19981205   Richard Gooch <rgooch@atnf.csiro.au>
+	       Updated <devfs_rmdir> for VFS change in 2.1.131.
+  v0.55
+    19981218   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_mk_compat>.
+    19981220   Richard Gooch <rgooch@atnf.csiro.au>
+	       Check for partitions on removable media in <devfs_lookup>.
+  v0.56
+    19990118   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added support for registering regular files.
+	       Created <devfs_set_file_size>.
+	       Update devfs inodes from entries if not changed through FS.
+  v0.57
+    19990124   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed <devfs_fill_file> to only initialise temporary inodes.
+	       Trap for NULL fops in <devfs_register>.
+	       Return -ENODEV in <devfs_fill_file> for non-driver inodes.
+  v0.58
+    19990126   Richard Gooch <rgooch@atnf.csiro.au>
+	       Switched from PATH_MAX to DEVFS_PATHLEN.
+  v0.59
+    19990127   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created "nottycompat" boot option.
+  v0.60
+    19990318   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed <devfsd_read> to not overrun event buffer.
+  v0.61
+    19990329   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_auto_unregister>.
+  v0.62
+    19990330   Richard Gooch <rgooch@atnf.csiro.au>
+	       Don't return unregistred entries in <devfs_find_handle>.
+	       Panic in <devfs_unregister> if entry unregistered.
+    19990401   Richard Gooch <rgooch@atnf.csiro.au>
+	       Don't panic in <devfs_auto_unregister> for duplicates.
+  v0.63
+    19990402   Richard Gooch <rgooch@atnf.csiro.au>
+	       Don't unregister already unregistered entries in <unregister>.
+  v0.64
+    19990510   Richard Gooch <rgooch@atnf.csiro.au>
+	       Disable warning messages when unable to read partition table for
+	       removable media.
+  v0.65
+    19990512   Richard Gooch <rgooch@atnf.csiro.au>
+	       Updated <devfs_lookup> for VFS change in 2.3.1-pre1.
+	       Created "oops-on-panic" boot option.
+	       Improved debugging in <devfs_register> and <devfs_unregister>.
+  v0.66
+    19990519   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added documentation for some functions.
+    19990525   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed "oops-on-panic" boot option: now always Oops.
+  v0.67
+    19990531   Richard Gooch <rgooch@atnf.csiro.au>
+	       Improved debugging in <devfs_register>.
+  v0.68
+    19990604   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added "diunlink" and "nokmod" boot options.
+	       Removed superfluous warning message in <devfs_d_iput>.
+  v0.69
+    19990611   Richard Gooch <rgooch@atnf.csiro.au>
+	       Took account of change to <d_alloc_root>.
+  v0.70
+    19990614   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created separate event queue for each mounted devfs.
+	       Removed <devfs_invalidate_dcache>.
+	       Created new ioctl()s.
+	       Incremented devfsd protocol revision to 3.
+	       Fixed bug when re-creating directories: contents were lost.
+	       Block access to inodes until devfsd updates permissions.
+    19990615   Richard Gooch <rgooch@atnf.csiro.au>
+	       Support 2.2.x kernels.
+  v0.71
+    19990623   Richard Gooch <rgooch@atnf.csiro.au>
+	       Switched to sending process uid/gid to devfsd.
+	       Renamed <call_kmod> to <try_modload>.
+	       Added DEVFSD_NOTIFY_LOOKUP event.
+    19990624   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added DEVFSD_NOTIFY_CHANGE event.
+	       Incremented devfsd protocol revision to 4.
+  v0.72
+    19990713   Richard Gooch <rgooch@atnf.csiro.au>
+	       Return EISDIR rather than EINVAL for read(2) on directories.
+  v0.73
+    19990809   Richard Gooch <rgooch@atnf.csiro.au>
+	       Changed <devfs_setup> to new __init scheme.
+  v0.74
+    19990901   Richard Gooch <rgooch@atnf.csiro.au>
+	       Changed remaining function declarations to new __init scheme.
+  v0.75
+    19991013   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_get_info>, <devfs_set_info>,
+	       <devfs_get_first_child> and <devfs_get_next_sibling>.
+	       Added <<dir>> parameter to <devfs_register>, <devfs_mk_compat>,
+	       <devfs_mk_dir> and <devfs_find_handle>.
+	       Work sponsored by SGI.
+  v0.76
+    19991017   Richard Gooch <rgooch@atnf.csiro.au>
+	       Allow multiple unregistrations.
+	       Work sponsored by SGI.
+  v0.77
+    19991026   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added major and minor number to devfsd protocol.
+	       Incremented devfsd protocol revision to 5.
+	       Work sponsored by SGI.
+  v0.78
+    19991030   Richard Gooch <rgooch@atnf.csiro.au>
+	       Support info pointer for all devfs entry types.
+	       Added <<info>> parameter to <devfs_mk_dir> and
+	       <devfs_mk_symlink>.
+	       Work sponsored by SGI.
+  v0.79
+    19991031   Richard Gooch <rgooch@atnf.csiro.au>
+	       Support "../" when searching devfs namespace.
+	       Work sponsored by SGI.
+  v0.80
+    19991101   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_get_unregister_slave>.
+	       Work sponsored by SGI.
+  v0.81
+    19991103   Richard Gooch <rgooch@atnf.csiro.au>
+	       Exported <devfs_get_parent>.
+	       Work sponsored by SGI.
+  v0.82
+    19991104   Richard Gooch <rgooch@atnf.csiro.au>
+               Removed unused <devfs_set_symlink_destination>.
+    19991105   Richard Gooch <rgooch@atnf.csiro.au>
+               Do not hide entries from devfsd or children.
+	       Removed DEVFS_ FL_TTY_COMPAT flag.
+	       Removed "nottycompat" boot option.
+	       Removed <devfs_mk_compat>.
+	       Work sponsored by SGI.
+  v0.83
+    19991107   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added DEVFS_FL_WAIT flag.
+	       Work sponsored by SGI.
+  v0.84
+    19991107   Richard Gooch <rgooch@atnf.csiro.au>
+	       Support new "disc" naming scheme in <get_removable_partition>.
+	       Allow NULL fops in <devfs_register>.
+	       Work sponsored by SGI.
+  v0.85
+    19991110   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fall back to major table if NULL fops given to <devfs_register>.
+	       Work sponsored by SGI.
+  v0.86
+    19991204   Richard Gooch <rgooch@atnf.csiro.au>
+	       Support fifos when unregistering.
+	       Work sponsored by SGI.
+  v0.87
+    19991209   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed obsolete DEVFS_ FL_COMPAT and DEVFS_ FL_TOLERANT flags.
+	       Work sponsored by SGI.
+  v0.88
+    19991214   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed kmod support.
+	       Work sponsored by SGI.
+  v0.89
+    19991216   Richard Gooch <rgooch@atnf.csiro.au>
+	       Improved debugging in <get_vfs_inode>.
+	       Ensure dentries created by devfsd will be cleaned up.
+	       Work sponsored by SGI.
+  v0.90
+    19991223   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_get_name>.
+	       Work sponsored by SGI.
+  v0.91
+    20000203   Richard Gooch <rgooch@atnf.csiro.au>
+	       Ported to kernel 2.3.42.
+	       Removed <devfs_fill_file>.
+	       Work sponsored by SGI.
+  v0.92
+    20000306   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added DEVFS_ FL_NO_PERSISTENCE flag.
+	       Removed unnecessary call to <update_devfs_inode_from_entry> in
+	       <devfs_readdir>.
+	       Work sponsored by SGI.
+  v0.93
+    20000413   Richard Gooch <rgooch@atnf.csiro.au>
+	       Set inode->i_size to correct size for symlinks.
+    20000414   Richard Gooch <rgooch@atnf.csiro.au>
+	       Only give lookup() method to directories to comply with new VFS
+	       assumptions.
+	       Work sponsored by SGI.
+    20000415   Richard Gooch <rgooch@atnf.csiro.au>
+	       Remove unnecessary tests in symlink methods.
+	       Don't kill existing block ops in <devfs_read_inode>.
+	       Work sponsored by SGI.
+  v0.94
+    20000424   Richard Gooch <rgooch@atnf.csiro.au>
+	       Don't create missing directories in <devfs_find_handle>.
+	       Work sponsored by SGI.
+  v0.95
+    20000430   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added CONFIG_DEVFS_MOUNT.
+	       Work sponsored by SGI.
+  v0.96
+    20000608   Richard Gooch <rgooch@atnf.csiro.au>
+	       Disabled multi-mount capability (use VFS bindings instead).
+	       Work sponsored by SGI.
+  v0.97
+    20000610   Richard Gooch <rgooch@atnf.csiro.au>
+	       Switched to FS_SINGLE to disable multi-mounts.
+    20000612   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed module support.
+	       Removed multi-mount code.
+	       Removed compatibility macros: VFS has changed too much.
+	       Work sponsored by SGI.
+  v0.98
+    20000614   Richard Gooch <rgooch@atnf.csiro.au>
+	       Merged devfs inode into devfs entry.
+	       Work sponsored by SGI.
+  v0.99
+    20000619   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed dead code in <devfs_register> which used to call
+	       <free_dentries>.
+	       Work sponsored by SGI.
+  v0.100
+    20000621   Richard Gooch <rgooch@atnf.csiro.au>
+	       Changed interface to <devfs_register>.
+	       Work sponsored by SGI.
+  v0.101
+    20000622   Richard Gooch <rgooch@atnf.csiro.au>
+	       Simplified interface to <devfs_mk_symlink> and <devfs_mk_dir>.
+	       Simplified interface to <devfs_find_handle>.
+	       Work sponsored by SGI.
+  v0.102
+    20010519   Richard Gooch <rgooch@atnf.csiro.au>
+	       Ensure <devfs_generate_path> terminates string for root entry.
+	       Exported <devfs_get_name> to modules.
+    20010520   Richard Gooch <rgooch@atnf.csiro.au>
+	       Make <devfs_mk_symlink> send events to devfsd.
+	       Cleaned up option processing in <devfs_setup>.
+    20010521   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bugs in handling symlinks: could leak or cause Oops.
+    20010522   Richard Gooch <rgooch@atnf.csiro.au>
+	       Cleaned up directory handling by separating fops.
+  v0.103
+    20010601   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed handling of inverted options in <devfs_setup>.
+  v0.104
+    20010604   Richard Gooch <rgooch@atnf.csiro.au>
+	       Adjusted <try_modload> to account for <devfs_generate_path> fix.
+  v0.105
+    20010617   Richard Gooch <rgooch@atnf.csiro.au>
+	       Answered question posed by Al Viro and removed his comments.
+	       Moved setting of registered flag after other fields are changed.
+	       Fixed race between <devfsd_close> and <devfsd_notify_one>.
+	       Global VFS changes added bogus BKL to <devfsd_close>: removed.
+	       Widened locking in <devfs_readlink> and <devfs_follow_link>.
+	       Replaced <devfsd_read> stack usage with <devfsd_ioctl> kmalloc.
+	       Simplified locking in <devfsd_ioctl> and fixed memory leak.
+  v0.106
+    20010709   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed broken devnum allocation and use <devfs_alloc_devnum>.
+	       Fixed old devnum leak by calling new <devfs_dealloc_devnum>.
+  v0.107
+    20010712   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bug in <devfs_setup> which could hang boot process.
+  v0.108
+    20010730   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added DEVFSD_NOTIFY_DELETE event.
+    20010801   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed #include <asm/segment.h>.
+  v0.109
+    20010807   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed inode table races by removing it and using
+	       inode->u.generic_ip instead.
+	       Moved <devfs_read_inode> into <get_vfs_inode>.
+	       Moved <devfs_write_inode> into <devfs_notify_change>.
+  v0.110
+    20010808   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed race in <devfs_do_symlink> for uni-processor.
+  v0.111
+    20010818   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed remnant of multi-mount support in <devfs_mknod>.
+               Removed unused DEVFS_FL_SHOW_UNREG flag.
+  v0.112
+    20010820   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed nlink field from struct devfs_inode.
+  v0.113
+    20010823   Richard Gooch <rgooch@atnf.csiro.au>
+	       Replaced BKL with global rwsem to protect symlink data (quick
+	       and dirty hack).
+  v0.114
+    20010827   Richard Gooch <rgooch@atnf.csiro.au>
+	       Replaced global rwsem for symlink with per-link refcount.
+  v0.115
+    20010919   Richard Gooch <rgooch@atnf.csiro.au>
+	       Set inode->i_mapping->a_ops for block nodes in <get_vfs_inode>.
+  v0.116
+    20011008   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed overrun in <devfs_link> by removing function (not needed).
+    20011009   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed buffer underrun in <try_modload>.
+    20011029   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed race in <devfsd_ioctl> when setting event mask.
+    20011114   Richard Gooch <rgooch@atnf.csiro.au>
+	       First release of new locking code.
+  v1.0
+    20011117   Richard Gooch <rgooch@atnf.csiro.au>
+	       Discard temporary buffer, now use "%s" for dentry names.
+    20011118   Richard Gooch <rgooch@atnf.csiro.au>
+	       Don't generate path in <try_modload>: use fake entry instead.
+	       Use "existing" directory in <_devfs_make_parent_for_leaf>.
+    20011122   Richard Gooch <rgooch@atnf.csiro.au>
+	       Use slab cache rather than fixed buffer for devfsd events.
+  v1.1
+    20011125   Richard Gooch <rgooch@atnf.csiro.au>
+	       Send DEVFSD_NOTIFY_REGISTERED events in <devfs_mk_dir>.
+    20011127   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed locking bug in <devfs_d_revalidate_wait> due to typo.
+	       Do not send CREATE, CHANGE, ASYNC_OPEN or DELETE events from
+	       devfsd or children.
+  v1.2
+    20011202   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bug in <devfsd_read>: was dereferencing freed pointer.
+  v1.3
+    20011203   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed bug in <devfsd_close>: was dereferencing freed pointer.
+	       Added process group check for devfsd privileges.
+  v1.4
+    20011204   Richard Gooch <rgooch@atnf.csiro.au>
+	       Use SLAB_ATOMIC in <devfsd_notify_de> from <devfs_d_delete>.
+  v1.5
+    20011211   Richard Gooch <rgooch@atnf.csiro.au>
+	       Return old entry in <devfs_mk_dir> for 2.4.x kernels.
+    20011212   Richard Gooch <rgooch@atnf.csiro.au>
+	       Increment refcount on module in <check_disc_changed>.
+    20011215   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_get_handle> and exported <devfs_put>.
+	       Increment refcount on module in <devfs_get_ops>.
+	       Created <devfs_put_ops>.
+  v1.6
+    20011216   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added poisoning to <devfs_put>.
+	       Improved debugging messages.
+  v1.7
+    20011221   Richard Gooch <rgooch@atnf.csiro.au>
+	       Corrected (made useful) debugging message in <unregister>.
+	       Moved <kmem_cache_create> in <mount_devfs_fs> to <init_devfs_fs>
+    20011224   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added magic number to guard against scribbling drivers.
+    20011226   Richard Gooch <rgooch@atnf.csiro.au>
+	       Only return old entry in <devfs_mk_dir> if a directory.
+	       Defined macros for error and debug messages.
+  v1.8
+    20020113   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed (rare, old) race in <devfs_lookup>.
+  v1.9
+    20020120   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed deadlock bug in <devfs_d_revalidate_wait>.
+	       Tag VFS deletable in <devfs_mk_symlink> if handle ignored.
+  v1.10
+    20020129   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added KERN_* to remaining messages.
+	       Cleaned up declaration of <stat_read>.
+  v1.11
+    20020219   Richard Gooch <rgooch@atnf.csiro.au>
+	       Changed <devfs_rmdir> to allow later additions if not yet empty.
+  v1.12
+    20020406   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed silently introduced calls to lock_kernel() and
+	       unlock_kernel() due to recent VFS locking changes. BKL isn't
+	       required in devfs.
+  v1.13
+    20020428   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed 2.4.x compatibility code.
+  v1.14
+    20020510   Richard Gooch <rgooch@atnf.csiro.au>
+	       Added BKL to <devfs_open> because drivers still need it.
+  v1.15
+    20020512   Richard Gooch <rgooch@atnf.csiro.au>
+	       Protected <scan_dir_for_removable> and <get_removable_partition>
+	       from changing directory contents.
+  v1.16
+    20020514   Richard Gooch <rgooch@atnf.csiro.au>
+	       Minor cleanup of <scan_dir_for_removable>.
+  v1.17
+    20020721   Richard Gooch <rgooch@atnf.csiro.au>
+	       Switched to ISO C structure field initialisers.
+	       Switch to set_current_state() and move before add_wait_queue().
+    20020722   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed devfs entry leak in <devfs_readdir> when *readdir fails.
+  v1.18
+    20020725   Richard Gooch <rgooch@atnf.csiro.au>
+	       Created <devfs_find_and_unregister>.
+  v1.19
+    20020728   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed deprecated <devfs_find_handle>.
+  v1.20
+    20020820   Richard Gooch <rgooch@atnf.csiro.au>
+	       Fixed module unload race in <devfs_open>.
+  v1.21
+    20021013   Richard Gooch <rgooch@atnf.csiro.au>
+	       Removed DEVFS_ FL_AUTO_OWNER.
+	       Switched lingering structure field initialiser to ISO C.
+	       Added locking when updating FCB flags.
+  v1.22
+*/
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/time.h>
+#include <linux/tty.h>
+#include <linux/timer.h>
+#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/devfs_fs.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/smp_lock.h>
+#include <linux/smp.h>
+#include <linux/rwsem.h>
+#include <linux/sched.h>
+#include <linux/namei.h>
+#include <linux/bitops.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/atomic.h>
+
+#define DEVFS_VERSION            "2004-01-31"
+
+#define DEVFS_NAME "devfs"
+
+#define FIRST_INODE 1
+
+#define STRING_LENGTH 256
+#define FAKE_BLOCK_SIZE 1024
+#define POISON_PTR ( *(void **) poison_array )
+#define MAGIC_VALUE 0x327db823
+
+#ifndef TRUE
+#  define TRUE 1
+#  define FALSE 0
+#endif
+
+#define MODE_DIR (S_IFDIR | S_IWUSR | S_IRUGO | S_IXUGO)
+
+#define DEBUG_NONE         0x0000000
+#define DEBUG_MODULE_LOAD  0x0000001
+#define DEBUG_REGISTER     0x0000002
+#define DEBUG_UNREGISTER   0x0000004
+#define DEBUG_FREE         0x0000008
+#define DEBUG_SET_FLAGS    0x0000010
+#define DEBUG_S_READ       0x0000100	/*  Break  */
+#define DEBUG_I_LOOKUP     0x0001000	/*  Break  */
+#define DEBUG_I_CREATE     0x0002000
+#define DEBUG_I_GET        0x0004000
+#define DEBUG_I_CHANGE     0x0008000
+#define DEBUG_I_UNLINK     0x0010000
+#define DEBUG_I_RLINK      0x0020000
+#define DEBUG_I_FLINK      0x0040000
+#define DEBUG_I_MKNOD      0x0080000
+#define DEBUG_F_READDIR    0x0100000	/*  Break  */
+#define DEBUG_D_DELETE     0x1000000	/*  Break  */
+#define DEBUG_D_RELEASE    0x2000000
+#define DEBUG_D_IPUT       0x4000000
+#define DEBUG_ALL          0xfffffff
+#define DEBUG_DISABLED     DEBUG_NONE
+
+#define OPTION_NONE             0x00
+#define OPTION_MOUNT            0x01
+
+#define PRINTK(format, args...) \
+   {printk (KERN_ERR "%s" format, __FUNCTION__ , ## args);}
+
+#define OOPS(format, args...) \
+   {printk (KERN_CRIT "%s" format, __FUNCTION__ , ## args); \
+    printk ("Forcing Oops\n"); \
+    BUG();}
+
+#ifdef CONFIG_DEVFS_DEBUG
+#  define VERIFY_ENTRY(de) \
+   {if ((de) && (de)->magic_number != MAGIC_VALUE) \
+        OOPS ("(%p): bad magic value: %x\n", (de), (de)->magic_number);}
+#  define WRITE_ENTRY_MAGIC(de,magic) (de)->magic_number = (magic)
+#  define DPRINTK(flag, format, args...) \
+   {if (devfs_debug & flag) \
+	printk (KERN_INFO "%s" format, __FUNCTION__ , ## args);}
+#else
+#  define VERIFY_ENTRY(de)
+#  define WRITE_ENTRY_MAGIC(de,magic)
+#  define DPRINTK(flag, format, args...)
+#endif
+
+typedef struct devfs_entry *devfs_handle_t;
+
+struct directory_type {
+	rwlock_t lock;		/*  Lock for searching(R)/updating(W)   */
+	struct devfs_entry *first;
+	struct devfs_entry *last;
+	unsigned char no_more_additions:1;
+};
+
+struct symlink_type {
+	unsigned int length;	/*  Not including the NULL-termimator       */
+	char *linkname;		/*  This is NULL-terminated                 */
+};
+
+struct devfs_inode {		/*  This structure is for "persistent" inode storage  */
+	struct dentry *dentry;
+	struct timespec atime;
+	struct timespec mtime;
+	struct timespec ctime;
+	unsigned int ino;	/*  Inode number as seen in the VFS         */
+	uid_t uid;
+	gid_t gid;
+};
+
+struct devfs_entry {
+#ifdef CONFIG_DEVFS_DEBUG
+	unsigned int magic_number;
+#endif
+	void *info;
+	atomic_t refcount;	/*  When this drops to zero, it's unused    */
+	union {
+		struct directory_type dir;
+		dev_t dev;
+		struct symlink_type symlink;
+		const char *name;	/*  Only used for (mode == 0)               */
+	} u;
+	struct devfs_entry *prev;	/*  Previous entry in the parent directory  */
+	struct devfs_entry *next;	/*  Next entry in the parent directory      */
+	struct devfs_entry *parent;	/*  The parent directory                    */
+	struct devfs_inode inode;
+	umode_t mode;
+	unsigned short namelen;	/*  I think 64k+ filenames are a way off... */
+	unsigned char vfs:1;	/*  Whether the VFS may delete the entry   */
+	char name[1];		/*  This is just a dummy: the allocated array
+				   is bigger. This is NULL-terminated      */
+};
+
+/*  The root of the device tree  */
+static struct devfs_entry *root_entry;
+
+struct devfsd_buf_entry {
+	struct devfs_entry *de;	/*  The name is generated with this         */
+	unsigned short type;	/*  The type of event                       */
+	umode_t mode;
+	uid_t uid;
+	gid_t gid;
+	struct devfsd_buf_entry *next;
+};
+
+struct fs_info {		/*  This structure is for the mounted devfs  */
+	struct super_block *sb;
+	spinlock_t devfsd_buffer_lock;	/*  Lock when inserting/deleting events  */
+	struct devfsd_buf_entry *devfsd_first_event;
+	struct devfsd_buf_entry *devfsd_last_event;
+	volatile int devfsd_sleeping;
+	volatile struct task_struct *devfsd_task;
+	volatile pid_t devfsd_pgrp;
+	volatile struct file *devfsd_file;
+	struct devfsd_notify_struct *devfsd_info;
+	volatile unsigned long devfsd_event_mask;
+	atomic_t devfsd_overrun_count;
+	wait_queue_head_t devfsd_wait_queue;	/*  Wake devfsd on input       */
+	wait_queue_head_t revalidate_wait_queue;	/*  Wake when devfsd sleeps    */
+};
+
+static struct fs_info fs_info = {.devfsd_buffer_lock = SPIN_LOCK_UNLOCKED };
+static kmem_cache_t *devfsd_buf_cache;
+#ifdef CONFIG_DEVFS_DEBUG
+static unsigned int devfs_debug_init __initdata = DEBUG_NONE;
+static unsigned int devfs_debug = DEBUG_NONE;
+static DEFINE_SPINLOCK(stat_lock);
+static unsigned int stat_num_entries;
+static unsigned int stat_num_bytes;
+#endif
+static unsigned char poison_array[8] =
+    { 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a };
+
+#ifdef CONFIG_DEVFS_MOUNT
+static unsigned int boot_options = OPTION_MOUNT;
+#else
+static unsigned int boot_options = OPTION_NONE;
+#endif
+
+/*  Forward function declarations  */
+static devfs_handle_t _devfs_walk_path(struct devfs_entry *dir,
+				       const char *name, int namelen,
+				       int traverse_symlink);
+static ssize_t devfsd_read(struct file *file, char __user *buf, size_t len,
+			   loff_t * ppos);
+static int devfsd_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg);
+static int devfsd_close(struct inode *inode, struct file *file);
+#ifdef CONFIG_DEVFS_DEBUG
+static ssize_t stat_read(struct file *file, char __user *buf, size_t len,
+			 loff_t * ppos);
+static const struct file_operations stat_fops = {
+	.open = nonseekable_open,
+	.read = stat_read,
+};
+#endif
+
+/*  Devfs daemon file operations  */
+static const struct file_operations devfsd_fops = {
+	.open = nonseekable_open,
+	.read = devfsd_read,
+	.ioctl = devfsd_ioctl,
+	.release = devfsd_close,
+};
+
+/*  Support functions follow  */
+
+/**
+ *	devfs_get - Get a reference to a devfs entry.
+ *	@de:  The devfs entry.
+ */
+
+static struct devfs_entry *devfs_get(struct devfs_entry *de)
+{
+	VERIFY_ENTRY(de);
+	if (de)
+		atomic_inc(&de->refcount);
+	return de;
+}				/*  End Function devfs_get  */
+
+/**
+ *	devfs_put - Put (release) a reference to a devfs entry.
+ *	@de:  The handle to the devfs entry.
+ */
+
+static void devfs_put(devfs_handle_t de)
+{
+	if (!de)
+		return;
+	VERIFY_ENTRY(de);
+	if (de->info == POISON_PTR)
+		OOPS("(%p): poisoned pointer\n", de);
+	if (!atomic_dec_and_test(&de->refcount))
+		return;
+	if (de == root_entry)
+		OOPS("(%p): root entry being freed\n", de);
+	DPRINTK(DEBUG_FREE, "(%s): de: %p, parent: %p \"%s\"\n",
+		de->name, de, de->parent,
+		de->parent ? de->parent->name : "no parent");
+	if (S_ISLNK(de->mode))
+		kfree(de->u.symlink.linkname);
+	WRITE_ENTRY_MAGIC(de, 0);
+#ifdef CONFIG_DEVFS_DEBUG
+	spin_lock(&stat_lock);
+	--stat_num_entries;
+	stat_num_bytes -= sizeof *de + de->namelen;
+	if (S_ISLNK(de->mode))
+		stat_num_bytes -= de->u.symlink.length + 1;
+	spin_unlock(&stat_lock);
+#endif
+	de->info = POISON_PTR;
+	kfree(de);
+}				/*  End Function devfs_put  */
+
+/**
+ *	_devfs_search_dir - Search for a devfs entry in a directory.
+ *	@dir:  The directory to search.
+ *	@name:  The name of the entry to search for.
+ *	@namelen:  The number of characters in @name.
+ *
+ *  Search for a devfs entry in a directory and returns a pointer to the entry
+ *   on success, else %NULL. The directory must be locked already.
+ *   An implicit devfs_get() is performed on the returned entry.
+ */
+
+static struct devfs_entry *_devfs_search_dir(struct devfs_entry *dir,
+					     const char *name,
+					     unsigned int namelen)
+{
+	struct devfs_entry *curr;
+
+	if (!S_ISDIR(dir->mode)) {
+		PRINTK("(%s): not a directory\n", dir->name);
+		return NULL;
+	}
+	for (curr = dir->u.dir.first; curr != NULL; curr = curr->next) {
+		if (curr->namelen != namelen)
+			continue;
+		if (memcmp(curr->name, name, namelen) == 0)
+			break;
+		/*  Not found: try the next one  */
+	}
+	return devfs_get(curr);
+}				/*  End Function _devfs_search_dir  */
+
+/**
+ *	_devfs_alloc_entry - Allocate a devfs entry.
+ *	@name:     the name of the entry
+ *	@namelen:  the number of characters in @name
+ *      @mode:     the mode for the entry
+ *
+ *  Allocate a devfs entry and returns a pointer to the entry on success, else
+ *   %NULL.
+ */
+
+static struct devfs_entry *_devfs_alloc_entry(const char *name,
+					      unsigned int namelen,
+					      umode_t mode)
+{
+	struct devfs_entry *new;
+	static unsigned long inode_counter = FIRST_INODE;
+	static DEFINE_SPINLOCK(counter_lock);
+
+	if (name && (namelen < 1))
+		namelen = strlen(name);
+	if ((new = kmalloc(sizeof *new + namelen, GFP_KERNEL)) == NULL)
+		return NULL;
+	memset(new, 0, sizeof *new + namelen);	/*  Will set '\0' on name  */
+	new->mode = mode;
+	if (S_ISDIR(mode))
+		rwlock_init(&new->u.dir.lock);
+	atomic_set(&new->refcount, 1);
+	spin_lock(&counter_lock);
+	new->inode.ino = inode_counter++;
+	spin_unlock(&counter_lock);
+	if (name)
+		memcpy(new->name, name, namelen);
+	new->namelen = namelen;
+	WRITE_ENTRY_MAGIC(new, MAGIC_VALUE);
+#ifdef CONFIG_DEVFS_DEBUG
+	spin_lock(&stat_lock);
+	++stat_num_entries;
+	stat_num_bytes += sizeof *new + namelen;
+	spin_unlock(&stat_lock);
+#endif
+	return new;
+}				/*  End Function _devfs_alloc_entry  */
+
+/**
+ *	_devfs_append_entry - Append a devfs entry to a directory's child list.
+ *	@dir:  The directory to add to.
+ *	@de:  The devfs entry to append.
+ *	@old_de: If an existing entry exists, it will be written here. This may
+ *		 be %NULL. An implicit devfs_get() is performed on this entry.
+ *
+ *  Append a devfs entry to a directory's list of children, checking first to
+ *   see if an entry of the same name exists. The directory will be locked.
+ *   The value 0 is returned on success, else a negative error code.
+ *   On failure, an implicit devfs_put() is performed on %de.
+ */
+
+static int _devfs_append_entry(devfs_handle_t dir, devfs_handle_t de,
+			       devfs_handle_t * old_de)
+{
+	int retval;
+
+	if (old_de)
+		*old_de = NULL;
+	if (!S_ISDIR(dir->mode)) {
+		PRINTK("(%s): dir: \"%s\" is not a directory\n", de->name,
+		       dir->name);
+		devfs_put(de);
+		return -ENOTDIR;
+	}
+	write_lock(&dir->u.dir.lock);
+	if (dir->u.dir.no_more_additions)
+		retval = -ENOENT;
+	else {
+		struct devfs_entry *old;
+
+		old = _devfs_search_dir(dir, de->name, de->namelen);
+		if (old_de)
+			*old_de = old;
+		else
+			devfs_put(old);
+		if (old == NULL) {
+			de->parent = dir;
+			de->prev = dir->u.dir.last;
+			/*  Append to the directory's list of children  */
+			if (dir->u.dir.first == NULL)
+				dir->u.dir.first = de;
+			else
+				dir->u.dir.last->next = de;
+			dir->u.dir.last = de;
+			retval = 0;
+		} else
+			retval = -EEXIST;
+	}
+	write_unlock(&dir->u.dir.lock);
+	if (retval)
+		devfs_put(de);
+	return retval;
+}				/*  End Function _devfs_append_entry  */
+
+/**
+ *	_devfs_get_root_entry - Get the root devfs entry.
+ *
+ *	Returns the root devfs entry on success, else %NULL.
+ *
+ *	TODO it must be called asynchronously due to the fact
+ *	that devfs is initialized relatively late. Proper way
+ *	is to remove module_init from init_devfs_fs and manually
+ *	call it early enough during system init
+ */
+
+static struct devfs_entry *_devfs_get_root_entry(void)
+{
+	struct devfs_entry *new;
+	static DEFINE_SPINLOCK(root_lock);
+
+	if (root_entry)
+		return root_entry;
+
+	new = _devfs_alloc_entry(NULL, 0, MODE_DIR);
+	if (new == NULL)
+		return NULL;
+
+	spin_lock(&root_lock);
+	if (root_entry) {
+		spin_unlock(&root_lock);
+		devfs_put(new);
+		return root_entry;
+	}
+	root_entry = new;
+	spin_unlock(&root_lock);
+
+	return root_entry;
+}				/*  End Function _devfs_get_root_entry  */
+
+/**
+ *	_devfs_descend - Descend down a tree using the next component name.
+ *	@dir:  The directory to search.
+ *	@name:  The component name to search for.
+ *	@namelen:  The length of %name.
+ *	@next_pos:  The position of the next '/' or '\0' is written here.
+ *
+ *  Descend into a directory, searching for a component. This function forms
+ *   the core of a tree-walking algorithm. The directory will be locked.
+ *   The devfs entry corresponding to the component is returned. If there is
+ *   no matching entry, %NULL is returned.
+ *   An implicit devfs_get() is performed on the returned entry.
+ */
+
+static struct devfs_entry *_devfs_descend(struct devfs_entry *dir,
+					  const char *name, int namelen,
+					  int *next_pos)
+{
+	const char *stop, *ptr;
+	struct devfs_entry *entry;
+
+	if ((namelen >= 3) && (strncmp(name, "../", 3) == 0)) {	/*  Special-case going to parent directory  */
+		*next_pos = 3;
+		return devfs_get(dir->parent);
+	}
+	stop = name + namelen;
+	/*  Search for a possible '/'  */
+	for (ptr = name; (ptr < stop) && (*ptr != '/'); ++ptr) ;
+	*next_pos = ptr - name;
+	read_lock(&dir->u.dir.lock);
+	entry = _devfs_search_dir(dir, name, *next_pos);
+	read_unlock(&dir->u.dir.lock);
+	return entry;
+}				/*  End Function _devfs_descend  */
+
+static devfs_handle_t _devfs_make_parent_for_leaf(struct devfs_entry *dir,
+						  const char *name,
+						  int namelen, int *leaf_pos)
+{
+	int next_pos = 0;
+
+	if (dir == NULL)
+		dir = _devfs_get_root_entry();
+	if (dir == NULL)
+		return NULL;
+	devfs_get(dir);
+	/*  Search for possible trailing component and ignore it  */
+	for (--namelen; (namelen > 0) && (name[namelen] != '/'); --namelen) ;
+	*leaf_pos = (name[namelen] == '/') ? (namelen + 1) : 0;
+	for (; namelen > 0; name += next_pos, namelen -= next_pos) {
+		struct devfs_entry *de, *old = NULL;
+
+		if ((de =
+		     _devfs_descend(dir, name, namelen, &next_pos)) == NULL) {
+			de = _devfs_alloc_entry(name, next_pos, MODE_DIR);
+			devfs_get(de);
+			if (!de || _devfs_append_entry(dir, de, &old)) {
+				devfs_put(de);
+				if (!old || !S_ISDIR(old->mode)) {
+					devfs_put(old);
+					devfs_put(dir);
+					return NULL;
+				}
+				de = old;	/*  Use the existing directory  */
+			}
+		}
+		if (de == dir->parent) {
+			devfs_put(dir);
+			devfs_put(de);
+			return NULL;
+		}
+		devfs_put(dir);
+		dir = de;
+		if (name[next_pos] == '/')
+			++next_pos;
+	}
+	return dir;
+}				/*  End Function _devfs_make_parent_for_leaf  */
+
+static devfs_handle_t _devfs_prepare_leaf(devfs_handle_t * dir,
+					  const char *name, umode_t mode)
+{
+	int namelen, leaf_pos;
+	struct devfs_entry *de;
+
+	namelen = strlen(name);
+	if ((*dir = _devfs_make_parent_for_leaf(*dir, name, namelen,
+						&leaf_pos)) == NULL) {
+		PRINTK("(%s): could not create parent path\n", name);
+		return NULL;
+	}
+	if ((de = _devfs_alloc_entry(name + leaf_pos, namelen - leaf_pos, mode))
+	    == NULL) {
+		PRINTK("(%s): could not allocate entry\n", name);
+		devfs_put(*dir);
+		return NULL;
+	}
+	return de;
+}				/*  End Function _devfs_prepare_leaf  */
+
+static devfs_handle_t _devfs_walk_path(struct devfs_entry *dir,
+				       const char *name, int namelen,
+				       int traverse_symlink)
+{
+	int next_pos = 0;
+
+	if (dir == NULL)
+		dir = _devfs_get_root_entry();
+	if (dir == NULL)
+		return NULL;
+	devfs_get(dir);
+	for (; namelen > 0; name += next_pos, namelen -= next_pos) {
+		struct devfs_entry *de, *link;
+
+		if (!S_ISDIR(dir->mode)) {
+			devfs_put(dir);
+			return NULL;
+		}
+
+		if ((de =
+		     _devfs_descend(dir, name, namelen, &next_pos)) == NULL) {
+			devfs_put(dir);
+			return NULL;
+		}
+		if (S_ISLNK(de->mode) && traverse_symlink) {	/*  Need to follow the link: this is a stack chomper  */
+			/* FIXME what if it puts outside of mounted tree? */
+			link = _devfs_walk_path(dir, de->u.symlink.linkname,
+						de->u.symlink.length, TRUE);
+			devfs_put(de);
+			if (!link) {
+				devfs_put(dir);
+				return NULL;
+			}
+			de = link;
+		}
+		devfs_put(dir);
+		dir = de;
+		if (name[next_pos] == '/')
+			++next_pos;
+	}
+	return dir;
+}				/*  End Function _devfs_walk_path  */
+
+/**
+ *	_devfs_find_entry - Find a devfs entry.
+ *	@dir: The handle to the parent devfs directory entry. If this is %NULL the
+ *		name is relative to the root of the devfs.
+ *	@name: The name of the entry. This may be %NULL.
+ *	@traverse_symlink: If %TRUE then symbolic links are traversed.
+ *
+ *	Returns the devfs_entry pointer on success, else %NULL. An implicit
+ *	devfs_get() is performed.
+ */
+
+static struct devfs_entry *_devfs_find_entry(devfs_handle_t dir,
+					     const char *name,
+					     int traverse_symlink)
+{
+	unsigned int namelen = strlen(name);
+
+	if (name[0] == '/') {
+		/*  Skip leading pathname component  */
+		if (namelen < 2) {
+			PRINTK("(%s): too short\n", name);
+			return NULL;
+		}
+		for (++name, --namelen; (*name != '/') && (namelen > 0);
+		     ++name, --namelen) ;
+		if (namelen < 2) {
+			PRINTK("(%s): too short\n", name);
+			return NULL;
+		}
+		++name;
+		--namelen;
+	}
+	return _devfs_walk_path(dir, name, namelen, traverse_symlink);
+}				/*  End Function _devfs_find_entry  */
+
+static struct devfs_entry *get_devfs_entry_from_vfs_inode(struct inode *inode)
+{
+	if (inode == NULL)
+		return NULL;
+	VERIFY_ENTRY((struct devfs_entry *)inode->u.generic_ip);
+	return inode->i_private;
+}				/*  End Function get_devfs_entry_from_vfs_inode  */
+
+/**
+ *	free_dentry - Free the dentry for a device entry and invalidate inode.
+ *	@de: The entry.
+ *
+ *	This must only be called after the entry has been unhooked from its
+ *	 parent directory.
+ */
+
+static void free_dentry(struct devfs_entry *de)
+{
+	struct dentry *dentry = de->inode.dentry;
+
+	if (!dentry)
+		return;
+	spin_lock(&dcache_lock);
+	dget_locked(dentry);
+	spin_unlock(&dcache_lock);
+	/*  Forcefully remove the inode  */
+	if (dentry->d_inode != NULL)
+		dentry->d_inode->i_nlink = 0;
+	d_drop(dentry);
+	dput(dentry);
+}				/*  End Function free_dentry  */
+
+/**
+ *	is_devfsd_or_child - Test if the current process is devfsd or one of its children.
+ *	@fs_info: The filesystem information.
+ *
+ *	Returns %TRUE if devfsd or child, else %FALSE.
+ */
+
+static int is_devfsd_or_child(struct fs_info *fs_info)
+{
+	struct task_struct *p = current;
+
+	if (p == fs_info->devfsd_task)
+		return (TRUE);
+	if (process_group(p) == fs_info->devfsd_pgrp)
+		return (TRUE);
+	read_lock(&tasklist_lock);
+	for (; p != &init_task; p = p->real_parent) {
+		if (p == fs_info->devfsd_task) {
+			read_unlock(&tasklist_lock);
+			return (TRUE);
+		}
+	}
+	read_unlock(&tasklist_lock);
+	return (FALSE);
+}				/*  End Function is_devfsd_or_child  */
+
+/**
+ *	devfsd_queue_empty - Test if devfsd has work pending in its event queue.
+ *	@fs_info: The filesystem information.
+ *
+ *	Returns %TRUE if the queue is empty, else %FALSE.
+ */
+
+static inline int devfsd_queue_empty(struct fs_info *fs_info)
+{
+	return (fs_info->devfsd_last_event) ? FALSE : TRUE;
+}				/*  End Function devfsd_queue_empty  */
+
+/**
+ *	wait_for_devfsd_finished - Wait for devfsd to finish processing its event queue.
+ *	@fs_info: The filesystem information.
+ *
+ *	Returns %TRUE if no more waiting will be required, else %FALSE.
+ */
+
+static int wait_for_devfsd_finished(struct fs_info *fs_info)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	if (fs_info->devfsd_task == NULL)
+		return (TRUE);
+	if (devfsd_queue_empty(fs_info) && fs_info->devfsd_sleeping)
+		return TRUE;
+	if (is_devfsd_or_child(fs_info))
+		return (FALSE);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&fs_info->revalidate_wait_queue, &wait);
+	if (!devfsd_queue_empty(fs_info) || !fs_info->devfsd_sleeping)
+		if (fs_info->devfsd_task)
+			schedule();
+	remove_wait_queue(&fs_info->revalidate_wait_queue, &wait);
+	__set_current_state(TASK_RUNNING);
+	return (TRUE);
+}				/*  End Function wait_for_devfsd_finished  */
+
+/**
+ *	devfsd_notify_de - Notify the devfsd daemon of a change.
+ *	@de: The devfs entry that has changed. This and all parent entries will
+ *            have their reference counts incremented if the event was queued.
+ *	@type: The type of change.
+ *	@mode: The mode of the entry.
+ *	@uid: The user ID.
+ *	@gid: The group ID.
+ *	@fs_info: The filesystem info.
+ *
+ *	Returns %TRUE if an event was queued and devfsd woken up, else %FALSE.
+ */
+
+static int devfsd_notify_de(struct devfs_entry *de,
+			    unsigned short type, umode_t mode,
+			    uid_t uid, gid_t gid, struct fs_info *fs_info)
+{
+	struct devfsd_buf_entry *entry;
+	struct devfs_entry *curr;
+
+	if (!(fs_info->devfsd_event_mask & (1 << type)))
+		return (FALSE);
+	if ((entry = kmem_cache_alloc(devfsd_buf_cache, SLAB_KERNEL)) == NULL) {
+		atomic_inc(&fs_info->devfsd_overrun_count);
+		return (FALSE);
+	}
+	for (curr = de; curr != NULL; curr = curr->parent)
+		devfs_get(curr);
+	entry->de = de;
+	entry->type = type;
+	entry->mode = mode;
+	entry->uid = uid;
+	entry->gid = gid;
+	entry->next = NULL;
+	spin_lock(&fs_info->devfsd_buffer_lock);
+	if (!fs_info->devfsd_first_event)
+		fs_info->devfsd_first_event = entry;
+	if (fs_info->devfsd_last_event)
+		fs_info->devfsd_last_event->next = entry;
+	fs_info->devfsd_last_event = entry;
+	spin_unlock(&fs_info->devfsd_buffer_lock);
+	wake_up_interruptible(&fs_info->devfsd_wait_queue);
+	return (TRUE);
+}				/*  End Function devfsd_notify_de  */
+
+/**
+ *	devfsd_notify - Notify the devfsd daemon of a change.
+ *	@de: The devfs entry that has changed.
+ *	@type: The type of change event.
+ *	@wait: If TRUE, the function waits for the daemon to finish processing
+ *		the event.
+ */
+
+static void devfsd_notify(struct devfs_entry *de, unsigned short type)
+{
+	devfsd_notify_de(de, type, de->mode, current->euid,
+			 current->egid, &fs_info);
+}
+
+static int devfs_mk_dev(dev_t dev, umode_t mode, const char *fmt, va_list args)
+{
+	struct devfs_entry *dir = NULL, *de;
+	char buf[64];
+	int error, n;
+
+	n = vsnprintf(buf, sizeof(buf), fmt, args);
+	if (n >= sizeof(buf) || !buf[0]) {
+		printk(KERN_WARNING "%s: invalid format string %s\n",
+		       __FUNCTION__, fmt);
+		return -EINVAL;
+	}
+
+	de = _devfs_prepare_leaf(&dir, buf, mode);
+	if (!de) {
+		printk(KERN_WARNING "%s: could not prepare leaf for %s\n",
+		       __FUNCTION__, buf);
+		return -ENOMEM;	/* could be more accurate... */
+	}
+
+	de->u.dev = dev;
+
+	error = _devfs_append_entry(dir, de, NULL);
+	if (error) {
+		printk(KERN_WARNING "%s: could not append to parent for %s\n",
+		       __FUNCTION__, buf);
+		goto out;
+	}
+
+	devfsd_notify(de, DEVFSD_NOTIFY_REGISTERED);
+      out:
+	devfs_put(dir);
+	return error;
+}
+
+int devfs_mk_bdev(dev_t dev, umode_t mode, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!S_ISBLK(mode)) {
+		printk(KERN_WARNING "%s: invalide mode (%u) for %s\n",
+		       __FUNCTION__, mode, fmt);
+		return -EINVAL;
+	}
+
+	va_start(args, fmt);
+	return devfs_mk_dev(dev, mode, fmt, args);
+}
+
+EXPORT_SYMBOL(devfs_mk_bdev);
+
+int devfs_mk_cdev(dev_t dev, umode_t mode, const char *fmt, ...)
+{
+	va_list args;
+
+	if (!S_ISCHR(mode)) {
+		printk(KERN_WARNING "%s: invalide mode (%u) for %s\n",
+		       __FUNCTION__, mode, fmt);
+		return -EINVAL;
+	}
+
+	va_start(args, fmt);
+	return devfs_mk_dev(dev, mode, fmt, args);
+}
+
+EXPORT_SYMBOL(devfs_mk_cdev);
+
+/**
+ *	_devfs_unhook - Unhook a device entry from its parents list
+ *	@de: The entry to unhook.
+ *
+ *	Returns %TRUE if the entry was unhooked, else %FALSE if it was
+ *		previously unhooked.
+ *	The caller must have a write lock on the parent directory.
+ */
+
+static int _devfs_unhook(struct devfs_entry *de)
+{
+	struct devfs_entry *parent;
+
+	if (!de || (de->prev == de))
+		return FALSE;
+	parent = de->parent;
+	if (de->prev == NULL)
+		parent->u.dir.first = de->next;
+	else
+		de->prev->next = de->next;
+	if (de->next == NULL)
+		parent->u.dir.last = de->prev;
+	else
+		de->next->prev = de->prev;
+	de->prev = de;		/*  Indicate we're unhooked                      */
+	de->next = NULL;	/*  Force early termination for <devfs_readdir>  */
+	return TRUE;
+}				/*  End Function _devfs_unhook  */
+
+/**
+ *	_devfs_unregister - Unregister a device entry from its parent.
+ *	@dir: The parent directory.
+ *	@de: The entry to unregister.
+ *
+ *	The caller must have a write lock on the parent directory, which is
+ *	unlocked by this function.
+ */
+
+static void _devfs_unregister(struct devfs_entry *dir, struct devfs_entry *de)
+{
+	int unhooked = _devfs_unhook(de);
+
+	write_unlock(&dir->u.dir.lock);
+	if (!unhooked)
+		return;
+	devfs_get(dir);
+	devfsd_notify(de, DEVFSD_NOTIFY_UNREGISTERED);
+	free_dentry(de);
+	devfs_put(dir);
+	if (!S_ISDIR(de->mode))
+		return;
+	while (TRUE) {		/*  Recursively unregister: this is a stack chomper  */
+		struct devfs_entry *child;
+
+		write_lock(&de->u.dir.lock);
+		de->u.dir.no_more_additions = TRUE;
+		child = de->u.dir.first;
+		VERIFY_ENTRY(child);
+		_devfs_unregister(de, child);
+		if (!child)
+			break;
+		DPRINTK(DEBUG_UNREGISTER, "(%s): child: %p  refcount: %d\n",
+			child->name, child, atomic_read(&child->refcount));
+		devfs_put(child);
+	}
+}				/*  End Function _devfs_unregister  */
+
+static int devfs_do_symlink(devfs_handle_t dir, const char *name,
+			    const char *link, devfs_handle_t * handle)
+{
+	int err;
+	unsigned int linklength;
+	char *newlink;
+	struct devfs_entry *de;
+
+	if (handle != NULL)
+		*handle = NULL;
+	if (name == NULL) {
+		PRINTK("(): NULL name pointer\n");
+		return -EINVAL;
+	}
+	if (link == NULL) {
+		PRINTK("(%s): NULL link pointer\n", name);
+		return -EINVAL;
+	}
+	linklength = strlen(link);
+	if ((newlink = kmalloc(linklength + 1, GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+	memcpy(newlink, link, linklength);
+	newlink[linklength] = '\0';
+	if ((de = _devfs_prepare_leaf(&dir, name, S_IFLNK | S_IRUGO | S_IXUGO))
+	    == NULL) {
+		PRINTK("(%s): could not prepare leaf\n", name);
+		kfree(newlink);
+		return -ENOTDIR;
+	}
+	de->info = NULL;
+	de->u.symlink.linkname = newlink;
+	de->u.symlink.length = linklength;
+	if ((err = _devfs_append_entry(dir, de, NULL)) != 0) {
+		PRINTK("(%s): could not append to parent, err: %d\n", name,
+		       err);
+		devfs_put(dir);
+		return err;
+	}
+	devfs_put(dir);
+#ifdef CONFIG_DEVFS_DEBUG
+	spin_lock(&stat_lock);
+	stat_num_bytes += linklength + 1;
+	spin_unlock(&stat_lock);
+#endif
+	if (handle != NULL)
+		*handle = de;
+	return 0;
+}				/*  End Function devfs_do_symlink  */
+
+/**
+ *	devfs_mk_symlink Create a symbolic link in the devfs namespace.
+ *	@from: The name of the entry.
+ *	@to: Name of the destination
+ *
+ *	Returns 0 on success, else a negative error code is returned.
+ */
+
+int devfs_mk_symlink(const char *from, const char *to)
+{
+	devfs_handle_t de;
+	int err;
+
+	err = devfs_do_symlink(NULL, from, to, &de);
+	if (!err) {
+		de->vfs = TRUE;
+		devfsd_notify(de, DEVFSD_NOTIFY_REGISTERED);
+	}
+
+	return err;
+}
+
+/**
+ *	devfs_mk_dir - Create a directory in the devfs namespace.
+ *		new name is relative to the root of the devfs.
+ *	@fmt: The name of the entry.
+ *
+ *	Use of this function is optional. The devfs_register() function
+ *	will automatically create intermediate directories as needed. This function
+ *	is provided for efficiency reasons, as it provides a handle to a directory.
+ *	On failure %NULL is returned.
+ */
+
+int devfs_mk_dir(const char *fmt, ...)
+{
+	struct devfs_entry *dir = NULL, *de = NULL, *old;
+	char buf[64];
+	va_list args;
+	int error, n;
+
+	va_start(args, fmt);
+	n = vsnprintf(buf, 64, fmt, args);
+	if (n >= 64 || !buf[0]) {
+		printk(KERN_WARNING "%s: invalid argument.", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	de = _devfs_prepare_leaf(&dir, buf, MODE_DIR);
+	if (!de) {
+		PRINTK("(%s): could not prepare leaf\n", buf);
+		return -EINVAL;
+	}
+
+	error = _devfs_append_entry(dir, de, &old);
+	if (error == -EEXIST && S_ISDIR(old->mode)) {
+		/*
+		 * devfs_mk_dir() of an already-existing directory will
+		 * return success.
+		 */
+		error = 0;
+		goto out_put;
+	} else if (error) {
+		PRINTK("(%s): could not append to dir: %p \"%s\"\n",
+		       buf, dir, dir->name);
+		devfs_put(old);
+		goto out_put;
+	}
+
+	devfsd_notify(de, DEVFSD_NOTIFY_REGISTERED);
+
+      out_put:
+	devfs_put(dir);
+	return error;
+}
+
+void devfs_remove(const char *fmt, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, fmt);
+	n = vsnprintf(buf, sizeof(buf), fmt, args);
+	if (n < sizeof(buf) && buf[0]) {
+		devfs_handle_t de = _devfs_find_entry(NULL, buf, 0);
+
+		if (!de) {
+			printk(KERN_ERR "%s: %s not found, cannot remove\n",
+			       __FUNCTION__, buf);
+			dump_stack();
+			return;
+		}
+
+		write_lock(&de->parent->u.dir.lock);
+		_devfs_unregister(de->parent, de);
+		devfs_put(de);
+		devfs_put(de);
+	}
+}
+
+/**
+ *	devfs_generate_path - Generate a pathname for an entry, relative to the devfs root.
+ *	@de: The devfs entry.
+ *	@path: The buffer to write the pathname to. The pathname and '\0'
+ *		terminator will be written at the end of the buffer.
+ *	@buflen: The length of the buffer.
+ *
+ *	Returns the offset in the buffer where the pathname starts on success,
+ *	else a negative error code.
+ */
+
+static int devfs_generate_path(devfs_handle_t de, char *path, int buflen)
+{
+	int pos;
+#define NAMEOF(de) ( (de)->mode ? (de)->name : (de)->u.name )
+
+	if (de == NULL)
+		return -EINVAL;
+	VERIFY_ENTRY(de);
+	if (de->namelen >= buflen)
+		return -ENAMETOOLONG;	/*  Must be first       */
+	path[buflen - 1] = '\0';
+	if (de->parent == NULL)
+		return buflen - 1;	/*  Don't prepend root  */
+	pos = buflen - de->namelen - 1;
+	memcpy(path + pos, NAMEOF(de), de->namelen);
+	for (de = de->parent; de->parent != NULL; de = de->parent) {
+		if (pos - de->namelen - 1 < 0)
+			return -ENAMETOOLONG;
+		path[--pos] = '/';
+		pos -= de->namelen;
+		memcpy(path + pos, NAMEOF(de), de->namelen);
+	}
+	return pos;
+}				/*  End Function devfs_generate_path  */
+
+/**
+ *	devfs_setup - Process kernel boot options.
+ *	@str: The boot options after the "devfs=".
+ */
+
+static int __init devfs_setup(char *str)
+{
+	static struct {
+		char *name;
+		unsigned int mask;
+		unsigned int *opt;
+	} devfs_options_tab[] __initdata = {
+#ifdef CONFIG_DEVFS_DEBUG
+		{
+		"dall", DEBUG_ALL, &devfs_debug_init}, {
+		"dmod", DEBUG_MODULE_LOAD, &devfs_debug_init}, {
+		"dreg", DEBUG_REGISTER, &devfs_debug_init}, {
+		"dunreg", DEBUG_UNREGISTER, &devfs_debug_init}, {
+		"dfree", DEBUG_FREE, &devfs_debug_init}, {
+		"diget", DEBUG_I_GET, &devfs_debug_init}, {
+		"dchange", DEBUG_SET_FLAGS, &devfs_debug_init}, {
+		"dsread", DEBUG_S_READ, &devfs_debug_init}, {
+		"dichange", DEBUG_I_CHANGE, &devfs_debug_init}, {
+		"dimknod", DEBUG_I_MKNOD, &devfs_debug_init}, {
+		"dilookup", DEBUG_I_LOOKUP, &devfs_debug_init}, {
+		"diunlink", DEBUG_I_UNLINK, &devfs_debug_init},
+#endif				/*  CONFIG_DEVFS_DEBUG  */
+		{
+		"mount", OPTION_MOUNT, &boot_options}, {
+		NULL, 0, NULL}
+	};
+
+	while ((*str != '\0') && !isspace(*str)) {
+		int i, found = 0, invert = 0;
+
+		if (strncmp(str, "no", 2) == 0) {
+			invert = 1;
+			str += 2;
+		}
+		for (i = 0; devfs_options_tab[i].name != NULL; i++) {
+			int len = strlen(devfs_options_tab[i].name);
+
+			if (strncmp(str, devfs_options_tab[i].name, len) == 0) {
+				if (invert)
+					*devfs_options_tab[i].opt &=
+					    ~devfs_options_tab[i].mask;
+				else
+					*devfs_options_tab[i].opt |=
+					    devfs_options_tab[i].mask;
+				str += len;
+				found = 1;
+				break;
+			}
+		}
+		if (!found)
+			return 0;	/*  No match         */
+		if (*str != ',')
+			return 0;	/*  No more options  */
+		++str;
+	}
+	return 1;
+}				/*  End Function devfs_setup  */
+
+__setup("devfs=", devfs_setup);
+
+EXPORT_SYMBOL(devfs_mk_dir);
+EXPORT_SYMBOL(devfs_remove);
+
+/**
+ *	try_modload - Notify devfsd of an inode lookup by a non-devfsd process.
+ *	@parent: The parent devfs entry.
+ *	@fs_info: The filesystem info.
+ *	@name: The device name.
+ *	@namelen: The number of characters in @name.
+ *	@buf: A working area that will be used. This must not go out of scope
+ *            until devfsd is idle again.
+ *
+ *	Returns 0 on success (event was queued), else a negative error code.
+ */
+
+static int try_modload(struct devfs_entry *parent, struct fs_info *fs_info,
+		       const char *name, unsigned namelen,
+		       struct devfs_entry *buf)
+{
+	if (!(fs_info->devfsd_event_mask & (1 << DEVFSD_NOTIFY_LOOKUP)))
+		return -ENOENT;
+	if (is_devfsd_or_child(fs_info))
+		return -ENOENT;
+	memset(buf, 0, sizeof *buf);
+	atomic_set(&buf->refcount, 1);
+	buf->parent = parent;
+	buf->namelen = namelen;
+	buf->u.name = name;
+	WRITE_ENTRY_MAGIC(buf, MAGIC_VALUE);
+	if (!devfsd_notify_de(buf, DEVFSD_NOTIFY_LOOKUP, 0,
+			      current->euid, current->egid, fs_info))
+		return -ENOENT;
+	/*  Possible success: event has been queued  */
+	return 0;
+}				/*  End Function try_modload  */
+
+/*  Superblock operations follow  */
+
+static struct inode_operations devfs_iops;
+static struct inode_operations devfs_dir_iops;
+static const struct file_operations devfs_fops;
+static const struct file_operations devfs_dir_fops;
+static struct inode_operations devfs_symlink_iops;
+
+static int devfs_notify_change(struct dentry *dentry, struct iattr *iattr)
+{
+	int retval;
+	struct devfs_entry *de;
+	struct inode *inode = dentry->d_inode;
+	struct fs_info *fs_info = inode->i_sb->s_fs_info;
+
+	de = get_devfs_entry_from_vfs_inode(inode);
+	if (de == NULL)
+		return -ENODEV;
+	retval = inode_change_ok(inode, iattr);
+	if (retval != 0)
+		return retval;
+	retval = inode_setattr(inode, iattr);
+	if (retval != 0)
+		return retval;
+	DPRINTK(DEBUG_I_CHANGE, "(%d): VFS inode: %p  devfs_entry: %p\n",
+		(int)inode->i_ino, inode, de);
+	DPRINTK(DEBUG_I_CHANGE, "():   mode: 0%o  uid: %d  gid: %d\n",
+		(int)inode->i_mode, (int)inode->i_uid, (int)inode->i_gid);
+	/*  Inode is not on hash chains, thus must save permissions here rather
+	   than in a write_inode() method  */
+	de->mode = inode->i_mode;
+	de->inode.uid = inode->i_uid;
+	de->inode.gid = inode->i_gid;
+	de->inode.atime = inode->i_atime;
+	de->inode.mtime = inode->i_mtime;
+	de->inode.ctime = inode->i_ctime;
+	if ((iattr->ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID)) &&
+	    !is_devfsd_or_child(fs_info))
+		devfsd_notify_de(de, DEVFSD_NOTIFY_CHANGE, inode->i_mode,
+				 inode->i_uid, inode->i_gid, fs_info);
+	return 0;
+}				/*  End Function devfs_notify_change  */
+
+static struct super_operations devfs_sops = {
+	.drop_inode = generic_delete_inode,
+	.statfs = simple_statfs,
+};
+
+/**
+ *	_devfs_get_vfs_inode - Get a VFS inode.
+ *	@sb: The super block.
+ *	@de: The devfs inode.
+ *	@dentry: The dentry to register with the devfs inode.
+ *
+ *	Returns the inode on success, else %NULL. An implicit devfs_get() is
+ *       performed if the inode is created.
+ */
+
+static struct inode *_devfs_get_vfs_inode(struct super_block *sb,
+					  struct devfs_entry *de,
+					  struct dentry *dentry)
+{
+	struct inode *inode;
+
+	if (de->prev == de)
+		return NULL;	/*  Quick check to see if unhooked  */
+	if ((inode = new_inode(sb)) == NULL) {
+		PRINTK("(%s): new_inode() failed, de: %p\n", de->name, de);
+		return NULL;
+	}
+	if (de->parent) {
+		read_lock(&de->parent->u.dir.lock);
+		if (de->prev != de)
+			de->inode.dentry = dentry;	/*      Not unhooked  */
+		read_unlock(&de->parent->u.dir.lock);
+	} else
+		de->inode.dentry = dentry;	/*  Root: no locking needed  */
+	if (de->inode.dentry != dentry) {	/*  Must have been unhooked  */
+		iput(inode);
+		return NULL;
+	}
+	/* FIXME where is devfs_put? */
+	inode->i_private = devfs_get(de);
+	inode->i_ino = de->inode.ino;
+	DPRINTK(DEBUG_I_GET, "(%d): VFS inode: %p  devfs_entry: %p\n",
+		(int)inode->i_ino, inode, de);
+	inode->i_blocks = 0;
+	inode->i_op = &devfs_iops;
+	inode->i_mode = de->mode;
+	if (S_ISDIR(de->mode)) {
+		inode->i_op = &devfs_dir_iops;
+		inode->i_fop = &devfs_dir_fops;
+	} else if (S_ISLNK(de->mode)) {
+		inode->i_op = &devfs_symlink_iops;
+		inode->i_size = de->u.symlink.length;
+	} else if (S_ISCHR(de->mode) || S_ISBLK(de->mode)) {
+		init_special_inode(inode, de->mode, de->u.dev);
+	} else if (S_ISFIFO(de->mode) || S_ISSOCK(de->mode)) {
+		init_special_inode(inode, de->mode, 0);
+	} else {
+		PRINTK("(%s): unknown mode %o de: %p\n",
+		       de->name, de->mode, de);
+		iput(inode);
+		devfs_put(de);
+		return NULL;
+	}
+
+	inode->i_uid = de->inode.uid;
+	inode->i_gid = de->inode.gid;
+	inode->i_atime = de->inode.atime;
+	inode->i_mtime = de->inode.mtime;
+	inode->i_ctime = de->inode.ctime;
+	DPRINTK(DEBUG_I_GET, "():   mode: 0%o  uid: %d  gid: %d\n",
+		(int)inode->i_mode, (int)inode->i_uid, (int)inode->i_gid);
+	return inode;
+}				/*  End Function _devfs_get_vfs_inode  */
+
+/*  File operations for device entries follow  */
+
+static int devfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err, count;
+	int stored = 0;
+	struct fs_info *fs_info;
+	struct devfs_entry *parent, *de, *next = NULL;
+	struct inode *inode = file->f_dentry->d_inode;
+
+	fs_info = inode->i_sb->s_fs_info;
+	parent = get_devfs_entry_from_vfs_inode(file->f_dentry->d_inode);
+	if ((long)file->f_pos < 0)
+		return -EINVAL;
+	DPRINTK(DEBUG_F_READDIR, "(%s): fs_info: %p  pos: %ld\n",
+		parent->name, fs_info, (long)file->f_pos);
+	switch ((long)file->f_pos) {
+	case 0:
+		err = (*filldir) (dirent, "..", 2, file->f_pos,
+				  parent_ino(file->f_dentry), DT_DIR);
+		if (err == -EINVAL)
+			break;
+		if (err < 0)
+			return err;
+		file->f_pos++;
+		++stored;
+		/*  Fall through  */
+	case 1:
+		err =
+		    (*filldir) (dirent, ".", 1, file->f_pos, inode->i_ino,
+				DT_DIR);
+		if (err == -EINVAL)
+			break;
+		if (err < 0)
+			return err;
+		file->f_pos++;
+		++stored;
+		/*  Fall through  */
+	default:
+		/*  Skip entries  */
+		count = file->f_pos - 2;
+		read_lock(&parent->u.dir.lock);
+		for (de = parent->u.dir.first; de && (count > 0); de = de->next)
+			--count;
+		devfs_get(de);
+		read_unlock(&parent->u.dir.lock);
+		/*  Now add all remaining entries  */
+		while (de) {
+			err = (*filldir) (dirent, de->name, de->namelen,
+					  file->f_pos, de->inode.ino,
+					  de->mode >> 12);
+			if (err < 0)
+				devfs_put(de);
+			else {
+				file->f_pos++;
+				++stored;
+			}
+			if (err == -EINVAL)
+				break;
+			if (err < 0)
+				return err;
+			read_lock(&parent->u.dir.lock);
+			next = devfs_get(de->next);
+			read_unlock(&parent->u.dir.lock);
+			devfs_put(de);
+			de = next;
+		}
+		break;
+	}
+	return stored;
+}				/*  End Function devfs_readdir  */
+
+/* Open devfs specific special files */
+static int devfs_open(struct inode *inode, struct file *file)
+{
+	int err;
+	int minor = MINOR(inode->i_rdev);
+	struct file_operations *old_fops, *new_fops;
+
+	switch (minor) {
+	case 0:		/* /dev/.devfsd */
+		new_fops = fops_get(&devfsd_fops);
+		break;
+#ifdef CONFIG_DEVFS_DEBUG
+	case 1:		/* /dev/.stat */
+		new_fops = fops_get(&stat_fops);
+		break;
+#endif
+	default:
+		return -ENODEV;
+	}
+
+	if (new_fops == NULL)
+		return -ENODEV;
+	old_fops = file->f_op;
+	file->f_op = new_fops;
+	err = new_fops->open ? new_fops->open(inode, file) : 0;
+	if (err) {
+		file->f_op = old_fops;
+		fops_put(new_fops);
+	} else
+		fops_put(old_fops);
+	return err;
+}				/*  End Function devfs_open  */
+
+static const struct file_operations devfs_fops = {
+	.open = devfs_open,
+};
+
+static const struct file_operations devfs_dir_fops = {
+	.read = generic_read_dir,
+	.readdir = devfs_readdir,
+};
+
+/*  Dentry operations for device entries follow  */
+
+/**
+ *	devfs_d_release - Callback for when a dentry is freed.
+ *	@dentry: The dentry.
+ */
+
+static void devfs_d_release(struct dentry *dentry)
+{
+	DPRINTK(DEBUG_D_RELEASE, "(%p): inode: %p\n", dentry, dentry->d_inode);
+}				/*  End Function devfs_d_release  */
+
+/**
+ *	devfs_d_iput - Callback for when a dentry loses its inode.
+ *	@dentry: The dentry.
+ *	@inode:	The inode.
+ */
+
+static void devfs_d_iput(struct dentry *dentry, struct inode *inode)
+{
+	struct devfs_entry *de;
+
+	de = get_devfs_entry_from_vfs_inode(inode);
+	DPRINTK(DEBUG_D_IPUT,
+		"(%s): dentry: %p inode: %p de: %p de->dentry: %p\n", de->name,
+		dentry, inode, de, de->inode.dentry);
+	if (de->inode.dentry && (de->inode.dentry != dentry))
+		OOPS("(%s): de: %p dentry: %p de->dentry: %p\n",
+		     de->name, de, dentry, de->inode.dentry);
+	de->inode.dentry = NULL;
+	iput(inode);
+	devfs_put(de);
+}				/*  End Function devfs_d_iput  */
+
+static int devfs_d_delete(struct dentry *dentry);
+
+static struct dentry_operations devfs_dops = {
+	.d_delete = devfs_d_delete,
+	.d_release = devfs_d_release,
+	.d_iput = devfs_d_iput,
+};
+
+static int devfs_d_revalidate_wait(struct dentry *dentry, struct nameidata *);
+
+static struct dentry_operations devfs_wait_dops = {
+	.d_delete = devfs_d_delete,
+	.d_release = devfs_d_release,
+	.d_iput = devfs_d_iput,
+	.d_revalidate = devfs_d_revalidate_wait,
+};
+
+/**
+ *	devfs_d_delete - Callback for when all files for a dentry are closed.
+ *	@dentry: The dentry.
+ */
+
+static int devfs_d_delete(struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+
+	if (dentry->d_op == &devfs_wait_dops)
+		dentry->d_op = &devfs_dops;
+	/*  Unhash dentry if negative (has no inode)  */
+	if (inode == NULL) {
+		DPRINTK(DEBUG_D_DELETE, "(%p): dropping negative dentry\n",
+			dentry);
+		return 1;
+	}
+	return 0;
+}				/*  End Function devfs_d_delete  */
+
+struct devfs_lookup_struct {
+	devfs_handle_t de;
+	wait_queue_head_t wait_queue;
+};
+
+/* XXX: this doesn't handle the case where we got a negative dentry
+        but a devfs entry has been registered in the meanwhile */
+static int devfs_d_revalidate_wait(struct dentry *dentry, struct nameidata *nd)
+{
+	struct inode *dir = dentry->d_parent->d_inode;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+	devfs_handle_t parent = get_devfs_entry_from_vfs_inode(dir);
+	struct devfs_lookup_struct *lookup_info = dentry->d_fsdata;
+	DECLARE_WAITQUEUE(wait, current);
+	int need_lock;
+
+	/*
+	 * FIXME HACK
+	 *
+	 * make sure that
+	 *   d_instantiate always runs under lock
+	 *   we release i_mutex lock before going to sleep
+	 *
+	 * unfortunately sometimes d_revalidate is called with
+	 * and sometimes without i_mutex lock held. The following checks
+	 * attempt to deduce when we need to add (and drop resp.) lock
+	 * here. This relies on current (2.6.2) calling coventions:
+	 *
+	 *   lookup_hash is always run under i_mutex and is passing NULL
+	 *   as nd
+	 *
+	 *   open(...,O_CREATE,...) calls _lookup_hash under i_mutex
+	 *   and sets flags to LOOKUP_OPEN|LOOKUP_CREATE
+	 *
+	 *   all other invocations of ->d_revalidate seem to happen
+	 *   outside of i_mutex
+	 */
+	need_lock = nd &&
+	    (!(nd->flags & LOOKUP_CREATE) || (nd->flags & LOOKUP_PARENT));
+
+	if (need_lock)
+		mutex_lock(&dir->i_mutex);
+
+	if (is_devfsd_or_child(fs_info)) {
+		devfs_handle_t de = lookup_info->de;
+		struct inode *inode;
+
+		DPRINTK(DEBUG_I_LOOKUP,
+			"(%s): dentry: %p inode: %p de: %p by: \"%s\"\n",
+			dentry->d_name.name, dentry, dentry->d_inode, de,
+			current->comm);
+		if (dentry->d_inode)
+			goto out;
+		if (de == NULL) {
+			read_lock(&parent->u.dir.lock);
+			de = _devfs_search_dir(parent, dentry->d_name.name,
+					       dentry->d_name.len);
+			read_unlock(&parent->u.dir.lock);
+			if (de == NULL)
+				goto out;
+			lookup_info->de = de;
+		}
+		/*  Create an inode, now that the driver information is available  */
+		inode = _devfs_get_vfs_inode(dir->i_sb, de, dentry);
+		if (!inode)
+			goto out;
+		DPRINTK(DEBUG_I_LOOKUP,
+			"(%s): new VFS inode(%u): %p de: %p by: \"%s\"\n",
+			de->name, de->inode.ino, inode, de, current->comm);
+		d_instantiate(dentry, inode);
+		goto out;
+	}
+	if (lookup_info == NULL)
+		goto out;	/*  Early termination  */
+	read_lock(&parent->u.dir.lock);
+	if (dentry->d_fsdata) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&lookup_info->wait_queue, &wait);
+		read_unlock(&parent->u.dir.lock);
+		/* at this point it is always (hopefully) locked */
+		mutex_unlock(&dir->i_mutex);
+		schedule();
+		mutex_lock(&dir->i_mutex);
+		/*
+		 * This does not need nor should remove wait from wait_queue.
+		 * Wait queue head is never reused - nothing is ever added to it
+		 * after all waiters have been waked up and head itself disappears
+		 * very soon after it. Moreover it is local variable on stack that
+		 * is likely to have already disappeared so any reference to it
+		 * at this point is buggy.
+		 */
+
+	} else
+		read_unlock(&parent->u.dir.lock);
+
+      out:
+	if (need_lock)
+		mutex_unlock(&dir->i_mutex);
+	return 1;
+}				/*  End Function devfs_d_revalidate_wait  */
+
+/*  Inode operations for device entries follow  */
+
+static struct dentry *devfs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *nd)
+{
+	struct devfs_entry tmp;	/*  Must stay in scope until devfsd idle again  */
+	struct devfs_lookup_struct lookup_info;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+	struct devfs_entry *parent, *de;
+	struct inode *inode;
+	struct dentry *retval = NULL;
+
+	/*  Set up the dentry operations before anything else, to ensure cleaning
+	   up on any error  */
+	dentry->d_op = &devfs_dops;
+	/*  First try to get the devfs entry for this directory  */
+	parent = get_devfs_entry_from_vfs_inode(dir);
+	DPRINTK(DEBUG_I_LOOKUP, "(%s): dentry: %p parent: %p by: \"%s\"\n",
+		dentry->d_name.name, dentry, parent, current->comm);
+	if (parent == NULL)
+		return ERR_PTR(-ENOENT);
+	read_lock(&parent->u.dir.lock);
+	de = _devfs_search_dir(parent, dentry->d_name.name, dentry->d_name.len);
+	read_unlock(&parent->u.dir.lock);
+	lookup_info.de = de;
+	init_waitqueue_head(&lookup_info.wait_queue);
+	dentry->d_fsdata = &lookup_info;
+	if (de == NULL) {	/*  Try with devfsd. For any kind of failure, leave a negative dentry
+				   so someone else can deal with it (in the case where the sysadmin
+				   does a mknod()). It's important to do this before hashing the
+				   dentry, so that the devfsd queue is filled before revalidates
+				   can start  */
+		if (try_modload(parent, fs_info, dentry->d_name.name, dentry->d_name.len, &tmp) < 0) {	/*  Lookup event was not queued to devfsd  */
+			d_add(dentry, NULL);
+			return NULL;
+		}
+	}
+	dentry->d_op = &devfs_wait_dops;
+	d_add(dentry, NULL);	/*  Open the floodgates  */
+	/*  Unlock directory semaphore, which will release any waiters. They
+	   will get the hashed dentry, and may be forced to wait for
+	   revalidation  */
+	mutex_unlock(&dir->i_mutex);
+	wait_for_devfsd_finished(fs_info);	/*  If I'm not devfsd, must wait  */
+	mutex_lock(&dir->i_mutex);	/*  Grab it again because them's the rules  */
+	de = lookup_info.de;
+	/*  If someone else has been so kind as to make the inode, we go home
+	   early  */
+	if (dentry->d_inode)
+		goto out;
+	if (de == NULL) {
+		read_lock(&parent->u.dir.lock);
+		de = _devfs_search_dir(parent, dentry->d_name.name,
+				       dentry->d_name.len);
+		read_unlock(&parent->u.dir.lock);
+		if (de == NULL)
+			goto out;
+		/*  OK, there's an entry now, but no VFS inode yet  */
+	}
+	/*  Create an inode, now that the driver information is available  */
+	inode = _devfs_get_vfs_inode(dir->i_sb, de, dentry);
+	if (!inode) {
+		retval = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	DPRINTK(DEBUG_I_LOOKUP,
+		"(%s): new VFS inode(%u): %p de: %p by: \"%s\"\n", de->name,
+		de->inode.ino, inode, de, current->comm);
+	d_instantiate(dentry, inode);
+      out:
+	write_lock(&parent->u.dir.lock);
+	dentry->d_op = &devfs_dops;
+	dentry->d_fsdata = NULL;
+	wake_up(&lookup_info.wait_queue);
+	write_unlock(&parent->u.dir.lock);
+	devfs_put(de);
+	return retval;
+}				/*  End Function devfs_lookup  */
+
+static int devfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int unhooked;
+	struct devfs_entry *de;
+	struct inode *inode = dentry->d_inode;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+
+	de = get_devfs_entry_from_vfs_inode(inode);
+	DPRINTK(DEBUG_I_UNLINK, "(%s): de: %p\n", dentry->d_name.name, de);
+	if (de == NULL)
+		return -ENOENT;
+	if (!de->vfs)
+		return -EPERM;
+	write_lock(&de->parent->u.dir.lock);
+	unhooked = _devfs_unhook(de);
+	write_unlock(&de->parent->u.dir.lock);
+	if (!unhooked)
+		return -ENOENT;
+	if (!is_devfsd_or_child(fs_info))
+		devfsd_notify_de(de, DEVFSD_NOTIFY_DELETE, inode->i_mode,
+				 inode->i_uid, inode->i_gid, fs_info);
+	free_dentry(de);
+	devfs_put(de);
+	return 0;
+}				/*  End Function devfs_unlink  */
+
+static int devfs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	int err;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+	struct devfs_entry *parent, *de;
+	struct inode *inode;
+
+	/*  First try to get the devfs entry for this directory  */
+	parent = get_devfs_entry_from_vfs_inode(dir);
+	if (parent == NULL)
+		return -ENOENT;
+	err = devfs_do_symlink(parent, dentry->d_name.name, symname, &de);
+	DPRINTK(DEBUG_DISABLED, "(%s): errcode from <devfs_do_symlink>: %d\n",
+		dentry->d_name.name, err);
+	if (err < 0)
+		return err;
+	de->vfs = TRUE;
+	de->inode.uid = current->euid;
+	de->inode.gid = current->egid;
+	de->inode.atime = CURRENT_TIME;
+	de->inode.mtime = CURRENT_TIME;
+	de->inode.ctime = CURRENT_TIME;
+	if ((inode = _devfs_get_vfs_inode(dir->i_sb, de, dentry)) == NULL)
+		return -ENOMEM;
+	DPRINTK(DEBUG_DISABLED, "(%s): new VFS inode(%u): %p  dentry: %p\n",
+		dentry->d_name.name, de->inode.ino, inode, dentry);
+	d_instantiate(dentry, inode);
+	if (!is_devfsd_or_child(fs_info))
+		devfsd_notify_de(de, DEVFSD_NOTIFY_CREATE, inode->i_mode,
+				 inode->i_uid, inode->i_gid, fs_info);
+	return 0;
+}				/*  End Function devfs_symlink  */
+
+static int devfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int err;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+	struct devfs_entry *parent, *de;
+	struct inode *inode;
+
+	mode = (mode & ~S_IFMT) | S_IFDIR;	/*  VFS doesn't pass S_IFMT part  */
+	parent = get_devfs_entry_from_vfs_inode(dir);
+	if (parent == NULL)
+		return -ENOENT;
+	de = _devfs_alloc_entry(dentry->d_name.name, dentry->d_name.len, mode);
+	if (!de)
+		return -ENOMEM;
+	de->vfs = TRUE;
+	if ((err = _devfs_append_entry(parent, de, NULL)) != 0)
+		return err;
+	de->inode.uid = current->euid;
+	de->inode.gid = current->egid;
+	de->inode.atime = CURRENT_TIME;
+	de->inode.mtime = CURRENT_TIME;
+	de->inode.ctime = CURRENT_TIME;
+	if ((inode = _devfs_get_vfs_inode(dir->i_sb, de, dentry)) == NULL)
+		return -ENOMEM;
+	DPRINTK(DEBUG_DISABLED, "(%s): new VFS inode(%u): %p  dentry: %p\n",
+		dentry->d_name.name, de->inode.ino, inode, dentry);
+	d_instantiate(dentry, inode);
+	if (!is_devfsd_or_child(fs_info))
+		devfsd_notify_de(de, DEVFSD_NOTIFY_CREATE, inode->i_mode,
+				 inode->i_uid, inode->i_gid, fs_info);
+	return 0;
+}				/*  End Function devfs_mkdir  */
+
+static int devfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct devfs_entry *de;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+	struct inode *inode = dentry->d_inode;
+
+	if (dir->i_sb->s_fs_info != inode->i_sb->s_fs_info)
+		return -EINVAL;
+	de = get_devfs_entry_from_vfs_inode(inode);
+	if (de == NULL)
+		return -ENOENT;
+	if (!S_ISDIR(de->mode))
+		return -ENOTDIR;
+	if (!de->vfs)
+		return -EPERM;
+	/*  First ensure the directory is empty and will stay that way  */
+	write_lock(&de->u.dir.lock);
+	if (de->u.dir.first)
+		err = -ENOTEMPTY;
+	else
+		de->u.dir.no_more_additions = TRUE;
+	write_unlock(&de->u.dir.lock);
+	if (err)
+		return err;
+	/*  Now unhook the directory from its parent  */
+	write_lock(&de->parent->u.dir.lock);
+	if (!_devfs_unhook(de))
+		err = -ENOENT;
+	write_unlock(&de->parent->u.dir.lock);
+	if (err)
+		return err;
+	if (!is_devfsd_or_child(fs_info))
+		devfsd_notify_de(de, DEVFSD_NOTIFY_DELETE, inode->i_mode,
+				 inode->i_uid, inode->i_gid, fs_info);
+	free_dentry(de);
+	devfs_put(de);
+	return 0;
+}				/*  End Function devfs_rmdir  */
+
+static int devfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+{
+	int err;
+	struct fs_info *fs_info = dir->i_sb->s_fs_info;
+	struct devfs_entry *parent, *de;
+	struct inode *inode;
+
+	DPRINTK(DEBUG_I_MKNOD, "(%s): mode: 0%o  dev: %u:%u\n",
+		dentry->d_name.name, mode, MAJOR(rdev), MINOR(rdev));
+	parent = get_devfs_entry_from_vfs_inode(dir);
+	if (parent == NULL)
+		return -ENOENT;
+	de = _devfs_alloc_entry(dentry->d_name.name, dentry->d_name.len, mode);
+	if (!de)
+		return -ENOMEM;
+	de->vfs = TRUE;
+	if (S_ISCHR(mode) || S_ISBLK(mode))
+		de->u.dev = rdev;
+	if ((err = _devfs_append_entry(parent, de, NULL)) != 0)
+		return err;
+	de->inode.uid = current->euid;
+	de->inode.gid = current->egid;
+	de->inode.atime = CURRENT_TIME;
+	de->inode.mtime = CURRENT_TIME;
+	de->inode.ctime = CURRENT_TIME;
+	if ((inode = _devfs_get_vfs_inode(dir->i_sb, de, dentry)) == NULL)
+		return -ENOMEM;
+	DPRINTK(DEBUG_I_MKNOD, ":   new VFS inode(%u): %p  dentry: %p\n",
+		de->inode.ino, inode, dentry);
+	d_instantiate(dentry, inode);
+	if (!is_devfsd_or_child(fs_info))
+		devfsd_notify_de(de, DEVFSD_NOTIFY_CREATE, inode->i_mode,
+				 inode->i_uid, inode->i_gid, fs_info);
+	return 0;
+}				/*  End Function devfs_mknod  */
+
+static void *devfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	struct devfs_entry *p = get_devfs_entry_from_vfs_inode(dentry->d_inode);
+	nd_set_link(nd, p ? p->u.symlink.linkname : ERR_PTR(-ENODEV));
+	return NULL;
+}				/*  End Function devfs_follow_link  */
+
+static struct inode_operations devfs_iops = {
+	.setattr = devfs_notify_change,
+};
+
+static struct inode_operations devfs_dir_iops = {
+	.lookup = devfs_lookup,
+	.unlink = devfs_unlink,
+	.symlink = devfs_symlink,
+	.mkdir = devfs_mkdir,
+	.rmdir = devfs_rmdir,
+	.mknod = devfs_mknod,
+	.setattr = devfs_notify_change,
+};
+
+static struct inode_operations devfs_symlink_iops = {
+	.readlink = generic_readlink,
+	.follow_link = devfs_follow_link,
+	.setattr = devfs_notify_change,
+};
+
+static int devfs_fill_super(struct super_block *sb, void *data, int silent)
+{
+	struct inode *root_inode = NULL;
+
+	if (_devfs_get_root_entry() == NULL)
+		goto out_no_root;
+	atomic_set(&fs_info.devfsd_overrun_count, 0);
+	init_waitqueue_head(&fs_info.devfsd_wait_queue);
+	init_waitqueue_head(&fs_info.revalidate_wait_queue);
+	fs_info.sb = sb;
+	sb->s_fs_info = &fs_info;
+	sb->s_blocksize = 1024;
+	sb->s_blocksize_bits = 10;
+	sb->s_magic = DEVFS_SUPER_MAGIC;
+	sb->s_op = &devfs_sops;
+	sb->s_time_gran = 1;
+	if ((root_inode = _devfs_get_vfs_inode(sb, root_entry, NULL)) == NULL)
+		goto out_no_root;
+	sb->s_root = d_alloc_root(root_inode);
+	if (!sb->s_root)
+		goto out_no_root;
+	DPRINTK(DEBUG_S_READ, "(): made devfs ptr: %p\n", sb->s_fs_info);
+	return 0;
+
+      out_no_root:
+	PRINTK("(): get root inode failed\n");
+	if (root_inode)
+		iput(root_inode);
+	return -EINVAL;
+}				/*  End Function devfs_fill_super  */
+
+static int devfs_get_sb(struct file_system_type *fs_type,
+					int flags, const char *dev_name,
+					void *data, struct vfsmount *mnt)
+{
+	return get_sb_single(fs_type, flags, data, devfs_fill_super, mnt);
+}
+
+static struct file_system_type devfs_fs_type = {
+	.name = DEVFS_NAME,
+	.get_sb = devfs_get_sb,
+	.kill_sb = kill_anon_super,
+};
+
+/*  File operations for devfsd follow  */
+
+static ssize_t devfsd_read(struct file *file, char __user *buf, size_t len,
+			   loff_t * ppos)
+{
+	int done = FALSE;
+	int ival;
+	loff_t pos, devname_offset, tlen, rpos;
+	devfs_handle_t de;
+	struct devfsd_buf_entry *entry;
+	struct fs_info *fs_info = file->f_dentry->d_inode->i_sb->s_fs_info;
+	struct devfsd_notify_struct *info = fs_info->devfsd_info;
+	DECLARE_WAITQUEUE(wait, current);
+
+	/*  Verify the task has grabbed the queue  */
+	if (fs_info->devfsd_task != current)
+		return -EPERM;
+	info->major = 0;
+	info->minor = 0;
+	/*  Block for a new entry  */
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&fs_info->devfsd_wait_queue, &wait);
+	while (devfsd_queue_empty(fs_info)) {
+		fs_info->devfsd_sleeping = TRUE;
+		wake_up(&fs_info->revalidate_wait_queue);
+		schedule();
+		fs_info->devfsd_sleeping = FALSE;
+		if (signal_pending(current)) {
+			remove_wait_queue(&fs_info->devfsd_wait_queue, &wait);
+			__set_current_state(TASK_RUNNING);
+			return -EINTR;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+	remove_wait_queue(&fs_info->devfsd_wait_queue, &wait);
+	__set_current_state(TASK_RUNNING);
+	/*  Now play with the data  */
+	ival = atomic_read(&fs_info->devfsd_overrun_count);
+	info->overrun_count = ival;
+	entry = fs_info->devfsd_first_event;
+	info->type = entry->type;
+	info->mode = entry->mode;
+	info->uid = entry->uid;
+	info->gid = entry->gid;
+	de = entry->de;
+	if (S_ISCHR(de->mode) || S_ISBLK(de->mode)) {
+		info->major = MAJOR(de->u.dev);
+		info->minor = MINOR(de->u.dev);
+	}
+	pos = devfs_generate_path(de, info->devname, DEVFS_PATHLEN);
+	if (pos < 0)
+		return pos;
+	info->namelen = DEVFS_PATHLEN - pos - 1;
+	if (info->mode == 0)
+		info->mode = de->mode;
+	devname_offset = info->devname - (char *)info;
+	rpos = *ppos;
+	if (rpos < devname_offset) {
+		/*  Copy parts of the header  */
+		tlen = devname_offset - rpos;
+		if (tlen > len)
+			tlen = len;
+		if (copy_to_user(buf, (char *)info + rpos, tlen)) {
+			return -EFAULT;
+		}
+		rpos += tlen;
+		buf += tlen;
+		len -= tlen;
+	}
+	if ((rpos >= devname_offset) && (len > 0)) {
+		/*  Copy the name  */
+		tlen = info->namelen + 1;
+		if (tlen > len)
+			tlen = len;
+		else
+			done = TRUE;
+		if (copy_to_user
+		    (buf, info->devname + pos + rpos - devname_offset, tlen)) {
+			return -EFAULT;
+		}
+		rpos += tlen;
+	}
+	tlen = rpos - *ppos;
+	if (done) {
+		devfs_handle_t parent;
+
+		spin_lock(&fs_info->devfsd_buffer_lock);
+		fs_info->devfsd_first_event = entry->next;
+		if (entry->next == NULL)
+			fs_info->devfsd_last_event = NULL;
+		spin_unlock(&fs_info->devfsd_buffer_lock);
+		for (; de != NULL; de = parent) {
+			parent = de->parent;
+			devfs_put(de);
+		}
+		kmem_cache_free(devfsd_buf_cache, entry);
+		if (ival > 0)
+			atomic_sub(ival, &fs_info->devfsd_overrun_count);
+		*ppos = 0;
+	} else
+		*ppos = rpos;
+	return tlen;
+}				/*  End Function devfsd_read  */
+
+static int devfsd_ioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int ival;
+	struct fs_info *fs_info = inode->i_sb->s_fs_info;
+
+	switch (cmd) {
+	case DEVFSDIOC_GET_PROTO_REV:
+		ival = DEVFSD_PROTOCOL_REVISION_KERNEL;
+		if (copy_to_user((void __user *)arg, &ival, sizeof ival))
+			return -EFAULT;
+		break;
+	case DEVFSDIOC_SET_EVENT_MASK:
+		/*  Ensure only one reader has access to the queue. This scheme will
+		   work even if the global kernel lock were to be removed, because it
+		   doesn't matter who gets in first, as long as only one gets it  */
+		if (fs_info->devfsd_task == NULL) {
+			static DEFINE_SPINLOCK(lock);
+
+			if (!spin_trylock(&lock))
+				return -EBUSY;
+			if (fs_info->devfsd_task != NULL) {	/*  We lost the race...  */
+				spin_unlock(&lock);
+				return -EBUSY;
+			}
+			fs_info->devfsd_task = current;
+			spin_unlock(&lock);
+			fs_info->devfsd_pgrp =
+			    (process_group(current) ==
+			     current->pid) ? process_group(current) : 0;
+			fs_info->devfsd_file = file;
+			fs_info->devfsd_info =
+			    kmalloc(sizeof *fs_info->devfsd_info, GFP_KERNEL);
+			if (!fs_info->devfsd_info) {
+				devfsd_close(inode, file);
+				return -ENOMEM;
+			}
+		} else if (fs_info->devfsd_task != current)
+			return -EBUSY;
+		fs_info->devfsd_event_mask = arg;	/*  Let the masses come forth  */
+		break;
+	case DEVFSDIOC_RELEASE_EVENT_QUEUE:
+		if (fs_info->devfsd_file != file)
+			return -EPERM;
+		return devfsd_close(inode, file);
+		/*break; */
+#ifdef CONFIG_DEVFS_DEBUG
+	case DEVFSDIOC_SET_DEBUG_MASK:
+		if (copy_from_user(&ival, (void __user *)arg, sizeof ival))
+			return -EFAULT;
+		devfs_debug = ival;
+		break;
+#endif
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}				/*  End Function devfsd_ioctl  */
+
+static int devfsd_close(struct inode *inode, struct file *file)
+{
+	struct devfsd_buf_entry *entry, *next;
+	struct fs_info *fs_info = inode->i_sb->s_fs_info;
+
+	if (fs_info->devfsd_file != file)
+		return 0;
+	fs_info->devfsd_event_mask = 0;
+	fs_info->devfsd_file = NULL;
+	spin_lock(&fs_info->devfsd_buffer_lock);
+	entry = fs_info->devfsd_first_event;
+	fs_info->devfsd_first_event = NULL;
+	fs_info->devfsd_last_event = NULL;
+	kfree(fs_info->devfsd_info);
+	fs_info->devfsd_info = NULL;
+	spin_unlock(&fs_info->devfsd_buffer_lock);
+	fs_info->devfsd_pgrp = 0;
+	fs_info->devfsd_task = NULL;
+	wake_up(&fs_info->revalidate_wait_queue);
+	for (; entry; entry = next) {
+		next = entry->next;
+		kmem_cache_free(devfsd_buf_cache, entry);
+	}
+	return 0;
+}				/*  End Function devfsd_close  */
+
+#ifdef CONFIG_DEVFS_DEBUG
+static ssize_t stat_read(struct file *file, char __user *buf, size_t len,
+			 loff_t * ppos)
+{
+	ssize_t num;
+	char txt[80];
+
+	num = sprintf(txt, "Number of entries: %u  number of bytes: %u\n",
+		      stat_num_entries, stat_num_bytes) + 1;
+	if (*ppos >= num)
+		return 0;
+	if (*ppos + len > num)
+		len = num - *ppos;
+	if (copy_to_user(buf, txt + *ppos, len))
+		return -EFAULT;
+	*ppos += len;
+	return len;
+}				/*  End Function stat_read  */
+#endif
+
+static int __init init_devfs_fs(void)
+{
+	int err;
+	int major;
+	struct devfs_entry *devfsd;
+#ifdef CONFIG_DEVFS_DEBUG
+	struct devfs_entry *stat;
+#endif
+
+	if (_devfs_get_root_entry() == NULL)
+		return -ENOMEM;
+
+	printk(KERN_INFO "%s: %s Richard Gooch (rgooch@atnf.csiro.au)\n",
+	       DEVFS_NAME, DEVFS_VERSION);
+	devfsd_buf_cache = kmem_cache_create("devfsd_event",
+					     sizeof(struct devfsd_buf_entry),
+					     0, 0, NULL, NULL);
+	if (!devfsd_buf_cache)
+		OOPS("(): unable to allocate event slab\n");
+#ifdef CONFIG_DEVFS_DEBUG
+	devfs_debug = devfs_debug_init;
+	printk(KERN_INFO "%s: devfs_debug: 0x%0x\n", DEVFS_NAME, devfs_debug);
+#endif
+	printk(KERN_INFO "%s: boot_options: 0x%0x\n", DEVFS_NAME, boot_options);
+
+	/* register special device for devfsd communication */
+	major = register_chrdev(0, "devfs", &devfs_fops);
+	if (major < 0)
+		return major;
+
+	/*  And create the entry for ".devfsd"  */
+	devfsd = _devfs_alloc_entry(".devfsd", 0, S_IFCHR | S_IRUSR | S_IWUSR);
+	if (devfsd == NULL)
+		return -ENOMEM;
+	devfsd->u.dev = MKDEV(major, 0);
+	_devfs_append_entry(root_entry, devfsd, NULL);
+
+#ifdef CONFIG_DEVFS_DEBUG
+	stat = _devfs_alloc_entry(".stat", 0, S_IFCHR | S_IRUGO);
+	if (stat == NULL)
+		return -ENOMEM;
+	stat->u.dev = MKDEV(major, 1);
+	_devfs_append_entry(root_entry, stat, NULL);
+#endif
+
+	err = register_filesystem(&devfs_fs_type);
+	return err;
+}				/*  End Function init_devfs_fs  */
+
+void __init mount_devfs_fs(void)
+{
+	int err;
+
+	if (!(boot_options & OPTION_MOUNT))
+		return;
+	err = do_mount("none", "/dev", "devfs", 0, NULL);
+	if (err == 0)
+		printk(KERN_INFO "Mounted devfs on /dev\n");
+	else
+		PRINTK("(): unable to mount devfs, err: %d\n", err);
+}				/*  End Function mount_devfs_fs  */
+
+module_init(init_devfs_fs)
diff -urN linux-2.6.19.old/fs/devfs/Makefile linux-2.6.19.dev/fs/devfs/Makefile
--- linux-2.6.19.old/fs/devfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/fs/devfs/Makefile	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,8 @@
+#
+# Makefile for the linux devfs-filesystem routines.
+#
+
+obj-$(CONFIG_DEVFS_FS) += devfs.o
+
+devfs-objs := base.o util.o
+
diff -urN linux-2.6.19.old/fs/devfs/util.c linux-2.6.19.dev/fs/devfs/util.c
--- linux-2.6.19.old/fs/devfs/util.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/fs/devfs/util.c	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,97 @@
+/*  devfs (Device FileSystem) utilities.
+
+    Copyright (C) 1999-2002  Richard Gooch
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au
+    The postal address is:
+      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.
+
+    ChangeLog
+
+    19991031   Richard Gooch <rgooch@atnf.csiro.au>
+               Created.
+    19991103   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <_devfs_convert_name> and supported SCSI and IDE CD-ROMs
+    20000203   Richard Gooch <rgooch@atnf.csiro.au>
+               Changed operations pointer type to void *.
+    20000621   Richard Gooch <rgooch@atnf.csiro.au>
+               Changed interface to <devfs_register_series>.
+    20000622   Richard Gooch <rgooch@atnf.csiro.au>
+               Took account of interface change to <devfs_mk_symlink>.
+               Took account of interface change to <devfs_mk_dir>.
+    20010519   Richard Gooch <rgooch@atnf.csiro.au>
+               Documentation cleanup.
+    20010709   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <devfs_*alloc_major> and <devfs_*alloc_devnum>.
+    20010710   Richard Gooch <rgooch@atnf.csiro.au>
+               Created <devfs_*alloc_unique_number>.
+    20010730   Richard Gooch <rgooch@atnf.csiro.au>
+               Documentation typo fix.
+    20010806   Richard Gooch <rgooch@atnf.csiro.au>
+               Made <block_semaphore> and <char_semaphore> private.
+    20010813   Richard Gooch <rgooch@atnf.csiro.au>
+               Fixed bug in <devfs_alloc_unique_number>: limited to 128 numbers
+    20010818   Richard Gooch <rgooch@atnf.csiro.au>
+               Updated major masks up to Linus' "no new majors" proclamation.
+	       Block: were 126 now 122 free, char: were 26 now 19 free.
+    20020324   Richard Gooch <rgooch@atnf.csiro.au>
+               Fixed bug in <devfs_alloc_unique_number>: was clearing beyond
+	       bitfield.
+    20020326   Richard Gooch <rgooch@atnf.csiro.au>
+               Fixed bitfield data type for <devfs_*alloc_devnum>.
+               Made major bitfield type and initialiser 64 bit safe.
+    20020413   Richard Gooch <rgooch@atnf.csiro.au>
+               Fixed shift warning on 64 bit machines.
+    20020428   Richard Gooch <rgooch@atnf.csiro.au>
+               Copied and used macro for error messages from fs/devfs/base.c 
+    20021013   Richard Gooch <rgooch@atnf.csiro.au>
+               Documentation fix.
+    20030101   Adam J. Richter <adam@yggdrasil.com>
+               Eliminate DEVFS_SPECIAL_{CHR,BLK}.  Use mode_t instead.
+    20030106   Christoph Hellwig <hch@infradead.org>
+               Rewrite devfs_{,de}alloc_devnum to look like C code.
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/bitops.h>
+
+int devfs_register_tape(const char *name)
+{
+	char tname[32], dest[64];
+	static unsigned int tape_counter;
+	unsigned int n = tape_counter++;
+
+	sprintf(dest, "../%s", name);
+	sprintf(tname, "tapes/tape%u", n);
+	devfs_mk_symlink(tname, dest);
+
+	return n;
+}
+
+EXPORT_SYMBOL(devfs_register_tape);
+
+void devfs_unregister_tape(int num)
+{
+	if (num >= 0)
+		devfs_remove("tapes/tape%u", num);
+}
+
+EXPORT_SYMBOL(devfs_unregister_tape);
diff -urN linux-2.6.19.old/fs/Kconfig linux-2.6.19.dev/fs/Kconfig
--- linux-2.6.19.old/fs/Kconfig	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/Kconfig	2006-12-14 03:12:59.000000000 +0100
@@ -957,6 +957,56 @@
 	  building a kernel for install/rescue disks or your system is very
 	  limited in memory.
 
+config DEVFS_FS
+	bool "/dev file system support (OBSOLETE)"
+	depends on EXPERIMENTAL
+	help
+	  This is support for devfs, a virtual file system (like /proc) which
+	  provides the file system interface to device drivers, normally found
+	  in /dev. Devfs does not depend on major and minor number
+	  allocations. Device drivers register entries in /dev which then
+	  appear automatically, which means that the system administrator does
+	  not have to create character and block special device files in the
+	  /dev directory using the mknod command (or MAKEDEV script) anymore.
+
+	  This is work in progress. If you want to use this, you *must* read
+	  the material in <file:Documentation/filesystems/devfs/>, especially
+	  the file README there.
+
+	  Note that devfs no longer manages /dev/pts!  If you are using UNIX98
+	  ptys, you will also need to mount the /dev/pts filesystem (devpts).
+
+	  Note that devfs has been obsoleted by udev,
+	  <http://www.kernel.org/pub/linux/utils/kernel/hotplug/>.
+	  It has been stripped down to a bare minimum and is only provided for
+	  legacy installations that use its naming scheme which is
+	  unfortunately different from the names normal Linux installations
+	  use.
+
+	  If unsure, say N.
+
+config DEVFS_MOUNT
+	bool "Automatically mount at boot"
+	depends on DEVFS_FS
+	help
+	  This option appears if you have CONFIG_DEVFS_FS enabled. Setting
+	  this to 'Y' will make the kernel automatically mount devfs onto /dev
+	  when the system is booted, before the init thread is started.
+	  You can override this with the "devfs=nomount" boot option.
+
+	  If unsure, say N.
+
+config DEVFS_DEBUG
+	bool "Debug devfs"
+	depends on DEVFS_FS
+	help
+	  If you say Y here, then the /dev file system code will generate
+	  debugging messages. See the file
+	  <file:Documentation/filesystems/devfs/boot-options> for more
+	  details.
+
+	  If unsure, say N.
+
 config SYSFS
 	bool "sysfs file system support" if EMBEDDED
 	default y
diff -urN linux-2.6.19.old/fs/Makefile linux-2.6.19.dev/fs/Makefile
--- linux-2.6.19.old/fs/Makefile	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/Makefile	2006-12-14 03:12:59.000000000 +0100
@@ -76,6 +76,7 @@
 obj-$(CONFIG_VFAT_FS)		+= vfat/
 obj-$(CONFIG_BFS_FS)		+= bfs/
 obj-$(CONFIG_ISO9660_FS)	+= isofs/
+obj-$(CONFIG_DEVFS_FS)		+= devfs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
 obj-$(CONFIG_HFS_FS)		+= hfs/
 obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
diff -urN linux-2.6.19.old/fs/partitions/check.c linux-2.6.19.dev/fs/partitions/check.c
--- linux-2.6.19.old/fs/partitions/check.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/partitions/check.c	2006-12-14 03:12:59.000000000 +0100
@@ -18,8 +18,10 @@
 #include <linux/fs.h>
 #include <linux/kmod.h>
 #include <linux/ctype.h>
+#include <linux/devfs_fs_kernel.h>
 
 #include "check.h"
+#include "devfs.h"
 
 #include "acorn.h"
 #include "amiga.h"
@@ -159,11 +161,18 @@
 	if (!state)
 		return NULL;
 
-	disk_name(hd, 0, state->name);
-	printk(KERN_INFO " %s:", state->name);
-	if (isdigit(state->name[strlen(state->name)-1]))
+#ifdef CONFIG_DEVFS_FS
+	if (hd->devfs_name[0] != '\0') {
+		printk(KERN_INFO " /dev/%s:", hd->devfs_name);
 		sprintf(state->name, "p");
-
+	}
+#endif
+	else {
+		disk_name(hd, 0, state->name);
+		printk(KERN_INFO " %s:", state->name);
+		if (isdigit(state->name[strlen(state->name)-1]))
+			sprintf(state->name, "p");
+	}
 	state->limit = hd->minors;
 	i = res = 0;
 	while (!res && check_part[i]) {
@@ -319,7 +328,7 @@
 	p->nr_sects = 0;
 	p->ios[0] = p->ios[1] = 0;
 	p->sectors[0] = p->sectors[1] = 0;
-	sysfs_remove_link(&p->kobj, "subsystem");
+	devfs_remove("%s/part%d", disk->devfs_name, part);
 	if (p->holder_dir)
 		kobject_unregister(p->holder_dir);
 	kobject_uevent(&p->kobj, KOBJ_REMOVE);
@@ -339,7 +348,10 @@
 	p->start_sect = start;
 	p->nr_sects = len;
 	p->partno = part;
-	p->policy = disk->policy;
+
+	devfs_mk_bdev(MKDEV(disk->major, disk->first_minor + part),
+			S_IFBLK|S_IRUSR|S_IWUSR,
+			"%s/part%d", disk->devfs_name, part);
 
 	if (isdigit(disk->kobj.name[strlen(disk->kobj.name)-1]))
 		snprintf(p->kobj.name,KOBJ_NAME_LEN,"%sp%d",disk->kobj.name,part);
@@ -444,8 +456,14 @@
  	disk_sysfs_add_subdirs(disk);
 
 	/* No minors to use for partitions */
-	if (disk->minors == 1)
+	if (disk->minors == 1) {
+		if (disk->devfs_name[0] != '\0')
+			devfs_add_disk(disk);
 		goto exit;
+	}
+
+	/* always add handle for the whole disk */
+	devfs_add_partitioned(disk);
 
 	/* No such device (e.g., media were just removed) */
 	if (!get_capacity(disk))
@@ -553,6 +571,8 @@
 	disk_stat_set_all(disk, 0);
 	disk->stamp = 0;
 
+	devfs_remove_disk(disk);
+
 	kobject_uevent(&disk->kobj, KOBJ_REMOVE);
 	if (disk->holder_dir)
 		kobject_unregister(disk->holder_dir);
diff -urN linux-2.6.19.old/fs/partitions/devfs.c linux-2.6.19.dev/fs/partitions/devfs.c
--- linux-2.6.19.old/fs/partitions/devfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/fs/partitions/devfs.c	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+ * This tries to keep block devices away from devfs as much as possible.
+ */
+#include <linux/fs.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/genhd.h>
+#include <linux/bitops.h>
+#include <linux/mutex.h>
+
+
+struct unique_numspace {
+	u32		  num_free;          /*  Num free in bits       */
+	u32		  length;            /*  Array length in bytes  */
+	unsigned long	  *bits;
+	struct semaphore  mutex;
+};
+
+static DEFINE_MUTEX(numspace_mutex);
+
+static int expand_numspace(struct unique_numspace *s)
+{
+	u32 length;
+	void *bits;
+
+	if (s->length < 16)
+		length = 16;
+	else
+		length = s->length << 1;
+
+	bits = vmalloc(length);
+	if (!bits)
+		return -ENOMEM;
+	if (s->bits) {
+		memcpy(bits, s->bits, s->length);
+		vfree(s->bits);
+	}
+		
+	s->num_free = (length - s->length) << 3;
+	s->bits = bits;
+	memset(bits + s->length, 0, length - s->length);
+	s->length = length;
+
+	return 0;
+}
+
+static int alloc_unique_number(struct unique_numspace *s)
+{
+	int rval = 0;
+
+	mutex_lock(&numspace_mutex);
+	if (s->num_free < 1)
+		rval = expand_numspace(s);
+	if (!rval) {
+		rval = find_first_zero_bit(s->bits, s->length << 3);
+		--s->num_free;
+		__set_bit(rval, s->bits);
+	}
+	mutex_unlock(&numspace_mutex);
+
+	return rval;
+}
+
+static void dealloc_unique_number(struct unique_numspace *s, int number)
+{
+	int old_val;
+
+	if (number >= 0) {
+		mutex_lock(&numspace_mutex);
+		old_val = __test_and_clear_bit(number, s->bits);
+		if (old_val)
+			++s->num_free;
+		mutex_unlock(&numspace_mutex);
+	}
+}
+
+static struct unique_numspace disc_numspace;
+static struct unique_numspace cdrom_numspace;
+
+void devfs_add_partitioned(struct gendisk *disk)
+{
+	char dirname[64], symlink[16];
+
+	devfs_mk_dir(disk->devfs_name);
+	devfs_mk_bdev(MKDEV(disk->major, disk->first_minor),
+			S_IFBLK|S_IRUSR|S_IWUSR,
+			"%s/disc", disk->devfs_name);
+
+	disk->number = alloc_unique_number(&disc_numspace);
+
+	sprintf(symlink, "discs/disc%d", disk->number);
+	sprintf(dirname, "../%s", disk->devfs_name);
+	devfs_mk_symlink(symlink, dirname);
+
+}
+
+void devfs_add_disk(struct gendisk *disk)
+{
+	devfs_mk_bdev(MKDEV(disk->major, disk->first_minor),
+			(disk->flags & GENHD_FL_CD) ?
+				S_IFBLK|S_IRUGO|S_IWUGO :
+				S_IFBLK|S_IRUSR|S_IWUSR,
+			"%s", disk->devfs_name);
+
+	if (disk->flags & GENHD_FL_CD) {
+		char dirname[64], symlink[16];
+
+		disk->number = alloc_unique_number(&cdrom_numspace);
+
+		sprintf(symlink, "cdroms/cdrom%d", disk->number);
+		sprintf(dirname, "../%s", disk->devfs_name);
+		devfs_mk_symlink(symlink, dirname);
+	}
+}
+
+void devfs_remove_disk(struct gendisk *disk)
+{
+	if (disk->minors != 1) {
+		devfs_remove("discs/disc%d", disk->number);
+		dealloc_unique_number(&disc_numspace, disk->number);
+		devfs_remove("%s/disc", disk->devfs_name);
+	}
+	if (disk->flags & GENHD_FL_CD) {
+		devfs_remove("cdroms/cdrom%d", disk->number);
+		dealloc_unique_number(&cdrom_numspace, disk->number);
+	}
+	devfs_remove(disk->devfs_name);
+}
+
+
diff -urN linux-2.6.19.old/fs/partitions/devfs.h linux-2.6.19.dev/fs/partitions/devfs.h
--- linux-2.6.19.old/fs/partitions/devfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/fs/partitions/devfs.h	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,10 @@
+
+#ifdef CONFIG_DEVFS_FS
+void devfs_add_disk(struct gendisk *dev);
+void devfs_add_partitioned(struct gendisk *dev);
+void devfs_remove_disk(struct gendisk *dev);
+#else
+# define devfs_add_disk(disk)			do { } while (0)
+# define devfs_add_partitioned(disk)		do { } while (0)
+# define devfs_remove_disk(disk)		do { } while (0)
+#endif
diff -urN linux-2.6.19.old/fs/partitions/Makefile linux-2.6.19.dev/fs/partitions/Makefile
--- linux-2.6.19.old/fs/partitions/Makefile	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/fs/partitions/Makefile	2006-12-14 03:12:59.000000000 +0100
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_BLOCK) := check.o
 
+obj-$(CONFIG_DEVFS_FS) += devfs.o
 obj-$(CONFIG_ACORN_PARTITION) += acorn.o
 obj-$(CONFIG_AMIGA_PARTITION) += amiga.o
 obj-$(CONFIG_ATARI_PARTITION) += atari.o
diff -urN linux-2.6.19.old/include/asm-ppc/ocp.h linux-2.6.19.dev/include/asm-ppc/ocp.h
--- linux-2.6.19.old/include/asm-ppc/ocp.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/asm-ppc/ocp.h	2006-12-14 03:12:59.000000000 +0100
@@ -26,6 +26,7 @@
 
 #include <linux/init.h>
 #include <linux/list.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/device.h>
 
 #include <asm/mmu.h>
diff -urN linux-2.6.19.old/include/linux/compat_ioctl.h linux-2.6.19.dev/include/linux/compat_ioctl.h
--- linux-2.6.19.old/include/linux/compat_ioctl.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/compat_ioctl.h	2006-12-14 03:12:59.000000000 +0100
@@ -571,6 +571,11 @@
 COMPATIBLE_IOCTL(AUTOFS_IOC_ASKREGHOST)
 COMPATIBLE_IOCTL(AUTOFS_IOC_TOGGLEREGHOST)
 COMPATIBLE_IOCTL(AUTOFS_IOC_ASKUMOUNT)
+/* DEVFS */
+COMPATIBLE_IOCTL(DEVFSDIOC_GET_PROTO_REV)
+COMPATIBLE_IOCTL(DEVFSDIOC_SET_EVENT_MASK)
+COMPATIBLE_IOCTL(DEVFSDIOC_RELEASE_EVENT_QUEUE)
+COMPATIBLE_IOCTL(DEVFSDIOC_SET_DEBUG_MASK)
 /* Raw devices */
 COMPATIBLE_IOCTL(RAW_SETBIND)
 COMPATIBLE_IOCTL(RAW_GETBIND)
diff -urN linux-2.6.19.old/include/linux/devfs_fs.h linux-2.6.19.dev/include/linux/devfs_fs.h
--- linux-2.6.19.old/include/linux/devfs_fs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/include/linux/devfs_fs.h	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,41 @@
+#ifndef _LINUX_DEVFS_FS_H
+#define _LINUX_DEVFS_FS_H
+
+#include <linux/ioctl.h>
+
+#define DEVFSD_PROTOCOL_REVISION_KERNEL  5
+
+#define	DEVFSD_IOCTL_BASE	'd'
+
+/*  These are the various ioctls  */
+#define DEVFSDIOC_GET_PROTO_REV         _IOR(DEVFSD_IOCTL_BASE, 0, int)
+#define DEVFSDIOC_SET_EVENT_MASK        _IOW(DEVFSD_IOCTL_BASE, 2, int)
+#define DEVFSDIOC_RELEASE_EVENT_QUEUE   _IOW(DEVFSD_IOCTL_BASE, 3, int)
+#define DEVFSDIOC_SET_DEBUG_MASK        _IOW(DEVFSD_IOCTL_BASE, 4, int)
+
+#define DEVFSD_NOTIFY_REGISTERED    0
+#define DEVFSD_NOTIFY_UNREGISTERED  1
+#define DEVFSD_NOTIFY_ASYNC_OPEN    2
+#define DEVFSD_NOTIFY_CLOSE         3
+#define DEVFSD_NOTIFY_LOOKUP        4
+#define DEVFSD_NOTIFY_CHANGE        5
+#define DEVFSD_NOTIFY_CREATE        6
+#define DEVFSD_NOTIFY_DELETE        7
+
+#define DEVFS_PATHLEN               1024	/*  Never change this otherwise the
+						   binary interface will change   */
+
+struct devfsd_notify_struct {	/*  Use native C types to ensure same types in kernel and user space     */
+	unsigned int type;	/*  DEVFSD_NOTIFY_* value                   */
+	unsigned int mode;	/*  Mode of the inode or device entry       */
+	unsigned int major;	/*  Major number of device entry            */
+	unsigned int minor;	/*  Minor number of device entry            */
+	unsigned int uid;	/*  Uid of process, inode or device entry   */
+	unsigned int gid;	/*  Gid of process, inode or device entry   */
+	unsigned int overrun_count;	/*  Number of lost events                   */
+	unsigned int namelen;	/*  Number of characters not including '\0' */
+	/*  The device name MUST come last                                       */
+	char devname[DEVFS_PATHLEN];	/*  This will be '\0' terminated            */
+};
+
+#endif				/*  _LINUX_DEVFS_FS_H  */
diff -urN linux-2.6.19.old/include/linux/devfs_fs_kernel.h linux-2.6.19.dev/include/linux/devfs_fs_kernel.h
--- linux-2.6.19.old/include/linux/devfs_fs_kernel.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/include/linux/devfs_fs_kernel.h	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,58 @@
+#ifndef _LINUX_DEVFS_FS_KERNEL_H
+#define _LINUX_DEVFS_FS_KERNEL_H
+
+#include <linux/fs.h>
+#include <linux/autoconf.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#include <asm/semaphore.h>
+
+#define DEVFS_SUPER_MAGIC                0x1373
+
+#ifdef CONFIG_DEVFS_FS
+extern int devfs_mk_bdev(dev_t dev, umode_t mode, const char *fmt, ...)
+    __attribute__ ((format(printf, 3, 4)));
+extern int devfs_mk_cdev(dev_t dev, umode_t mode, const char *fmt, ...)
+    __attribute__ ((format(printf, 3, 4)));
+extern int devfs_mk_symlink(const char *name, const char *link);
+extern int devfs_mk_dir(const char *fmt, ...)
+    __attribute__ ((format(printf, 1, 2)));
+extern void devfs_remove(const char *fmt, ...)
+    __attribute__ ((format(printf, 1, 2)));
+extern int devfs_register_tape(const char *name);
+extern void devfs_unregister_tape(int num);
+extern void mount_devfs_fs(void);
+#else				/*  CONFIG_DEVFS_FS  */
+static inline int devfs_mk_bdev(dev_t dev, umode_t mode, const char *fmt, ...)
+{
+	return 0;
+}
+static inline int devfs_mk_cdev(dev_t dev, umode_t mode, const char *fmt, ...)
+{
+	return 0;
+}
+static inline int devfs_mk_symlink(const char *name, const char *link)
+{
+	return 0;
+}
+static inline int devfs_mk_dir(const char *fmt, ...)
+{
+	return 0;
+}
+static inline void devfs_remove(const char *fmt, ...)
+{
+}
+static inline int devfs_register_tape(const char *name)
+{
+	return -1;
+}
+static inline void devfs_unregister_tape(int num)
+{
+}
+static inline void mount_devfs_fs(void)
+{
+	return;
+}
+#endif				/*  CONFIG_DEVFS_FS  */
+#endif				/*  _LINUX_DEVFS_FS_KERNEL_H  */
diff -urN linux-2.6.19.old/include/linux/fb.h linux-2.6.19.dev/include/linux/fb.h
--- linux-2.6.19.old/include/linux/fb.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/fb.h	2006-12-14 03:12:59.000000000 +0100
@@ -379,6 +379,7 @@
 #include <linux/init.h>
 #include <linux/device.h>
 #include <linux/workqueue.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/notifier.h>
 #include <linux/list.h>
 #include <linux/backlight.h>
diff -urN linux-2.6.19.old/include/linux/genhd.h linux-2.6.19.dev/include/linux/genhd.h
--- linux-2.6.19.old/include/linux/genhd.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/genhd.h	2006-12-14 03:12:59.000000000 +0100
@@ -114,6 +114,8 @@
 	sector_t capacity;
 
 	int flags;
+	char devfs_name[64];		/* devfs crap */
+	int number;			/* more of the same */
 	struct device *driverfs_dev;
 	struct kobject kobj;
 	struct kobject *holder_dir;
diff -urN linux-2.6.19.old/include/linux/ide.h linux-2.6.19.dev/include/linux/ide.h
--- linux-2.6.19.old/include/linux/ide.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/ide.h	2006-12-14 03:12:59.000000000 +0100
@@ -553,6 +553,7 @@
 	struct hd_driveid	*id;	/* drive model identification info */
 	struct proc_dir_entry *proc;	/* /proc/ide/ directory entry */
 	struct ide_settings_s *settings;/* /proc/ide/ drive settings */
+	char		devfs_name[64];	/* devfs crap */
 
 	struct hwif_s		*hwif;	/* actually (ide_hwif_t *) */
 
diff -urN linux-2.6.19.old/include/linux/miscdevice.h linux-2.6.19.dev/include/linux/miscdevice.h
--- linux-2.6.19.old/include/linux/miscdevice.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/miscdevice.h	2006-12-14 03:12:59.000000000 +0100
@@ -40,6 +40,7 @@
 	struct list_head list;
 	struct device *dev;
 	struct class_device *class;
+	char devfs_name[64];
 };
 
 extern int misc_register(struct miscdevice * misc);
diff -urN linux-2.6.19.old/include/linux/serial_core.h linux-2.6.19.dev/include/linux/serial_core.h
--- linux-2.6.19.old/include/linux/serial_core.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/serial_core.h	2006-12-14 03:12:59.000000000 +0100
@@ -339,6 +339,7 @@
 	struct module		*owner;
 	const char		*driver_name;
 	const char		*dev_name;
+	const char		*devfs_name;
 	int			 major;
 	int			 minor;
 	int			 nr;
diff -urN linux-2.6.19.old/include/linux/tty_driver.h linux-2.6.19.dev/include/linux/tty_driver.h
--- linux-2.6.19.old/include/linux/tty_driver.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/linux/tty_driver.h	2006-12-14 03:12:59.000000000 +0100
@@ -157,6 +157,7 @@
 	struct cdev cdev;
 	struct module	*owner;
 	const char	*driver_name;
+	const char	*devfs_name;
 	const char	*name;
 	int	name_base;	/* offset of printed name */
 	int	major;		/* major device number */
@@ -251,6 +252,8 @@
  *	called.  This is to be used by drivers that have tty devices
  *	that can appear and disappear while the main tty driver is
  *	registered with the tty core.
+ * TTY_DRIVER_NO_DEVFS --- if set, do not create devfs entries. This
+ *	is only used by tty_register_driver().
  *
  * TTY_DRIVER_DEVPTS_MEM -- don't use the standard arrays, instead
  *	use dynamic memory keyed through the devpts filesystem.  This
@@ -260,6 +263,7 @@
 #define TTY_DRIVER_RESET_TERMIOS	0x0002
 #define TTY_DRIVER_REAL_RAW		0x0004
 #define TTY_DRIVER_DYNAMIC_DEV		0x0008
+#define TTY_DRIVER_NO_DEVFS		0x0008
 #define TTY_DRIVER_DEVPTS_MEM		0x0010
 
 /* tty driver types */
diff -urN linux-2.6.19.old/include/media/v4l2-dev.h linux-2.6.19.dev/include/media/v4l2-dev.h
--- linux-2.6.19.old/include/media/v4l2-dev.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/media/v4l2-dev.h	2006-12-14 03:12:59.000000000 +0100
@@ -315,6 +315,7 @@
 	/* for videodev.c intenal usage -- please don't touch */
 	int users;                     /* video_exclusive_{open|close} ... */
 	struct mutex lock;             /* ... helper function uses these   */
+	char devfs_name[64];           /* devfs */
 	struct class_device class_dev; /* sysfs */
 };
 
diff -urN linux-2.6.19.old/include/scsi/scsi_device.h linux-2.6.19.dev/include/scsi/scsi_device.h
--- linux-2.6.19.old/include/scsi/scsi_device.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/scsi/scsi_device.h	2006-12-14 03:12:59.000000000 +0100
@@ -74,6 +74,7 @@
 	unsigned sector_size;	/* size in bytes */
 
 	void *hostdata;		/* available to low-level driver */
+	char devfs_name[256];	/* devfs junk */
 	char type;
 	char scsi_level;
 	char inq_periph_qual;	/* PQ from INQUIRY data */	
diff -urN linux-2.6.19.old/include/sound/core.h linux-2.6.19.dev/include/sound/core.h
--- linux-2.6.19.old/include/sound/core.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/include/sound/core.h	2006-12-14 03:12:59.000000000 +0100
@@ -188,6 +188,8 @@
 	const struct file_operations *f_ops;	/* file operations */
 	void *private_data;		/* private data for f_ops->open */
 	struct class_device *class_dev;	/* class device for sysfs */
+	char name[0];			/* device name for devfs (keep
+					   at the end of structure) */
 };
 
 /* sound.c */
diff -urN linux-2.6.19.old/init/do_mounts.c linux-2.6.19.dev/init/do_mounts.c
--- linux-2.6.19.old/init/do_mounts.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/init/do_mounts.c	2006-12-14 03:12:59.000000000 +0100
@@ -335,7 +335,7 @@
 {
 	void *data = nfs_root_data();
 
-	create_dev("/dev/root", ROOT_DEV);
+	create_dev("/dev/root", ROOT_DEV, root_device_name);
 	if (data &&
 	    do_mount_root("/dev/root", "nfs", root_mountflags, data) == 0)
 		return 1;
@@ -397,7 +397,7 @@
 	}
 #endif
 #ifdef CONFIG_BLOCK
-	create_dev("/dev/root", ROOT_DEV);
+	create_dev("/dev/root", ROOT_DEV, root_device_name);
 	mount_block_root("/dev/root", root_mountflags);
 #endif
 }
@@ -409,6 +409,8 @@
 {
 	int is_floppy;
 
+	mount_devfs();
+
 	if (root_delay) {
 		printk(KERN_INFO "Waiting %dsec before mounting root device...\n",
 		       root_delay);
@@ -442,8 +444,10 @@
 
 	mount_root();
 out:
+	umount_devfs("/dev");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
 	security_sb_post_mountroot();
+	mount_devfs_fs ();
 }
 
diff -urN linux-2.6.19.old/init/do_mounts_devfs.c linux-2.6.19.dev/init/do_mounts_devfs.c
--- linux-2.6.19.old/init/do_mounts_devfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.19.dev/init/do_mounts_devfs.c	2006-12-14 03:12:59.000000000 +0100
@@ -0,0 +1,137 @@
+
+#include <linux/kernel.h>
+#include <linux/dirent.h>
+#include <linux/string.h>
+
+#include "do_mounts.h"
+
+void __init mount_devfs(void)
+{
+	sys_mount("devfs", "/dev", "devfs", 0, NULL);
+}
+
+void __init umount_devfs(char *path)
+{
+	sys_umount(path, 0);
+}
+
+/*
+ * If the dir will fit in *buf, return its length.  If it won't fit, return
+ * zero.  Return -ve on error.
+ */
+static int __init do_read_dir(int fd, void *buf, int len)
+{
+	long bytes, n;
+	char *p = buf;
+	sys_lseek(fd, 0, 0);
+
+	for (bytes = 0; bytes < len; bytes += n) {
+		n = sys_getdents64(fd, (struct linux_dirent64 *)(p + bytes),
+					len - bytes);
+		if (n < 0)
+			return n;
+		if (n == 0)
+			return bytes;
+	}
+	return 0;
+}
+
+/*
+ * Try to read all of a directory.  Returns the contents at *p, which
+ * is kmalloced memory.  Returns the number of bytes read at *len.  Returns
+ * NULL on error.
+ */
+static void * __init read_dir(char *path, int *len)
+{
+	int size;
+	int fd = sys_open(path, 0, 0);
+
+	*len = 0;
+	if (fd < 0)
+		return NULL;
+
+	for (size = 1 << 9; size <= (PAGE_SIZE << MAX_ORDER); size <<= 1) {
+		void *p = kmalloc(size, GFP_KERNEL);
+		int n;
+		if (!p)
+			break;
+		n = do_read_dir(fd, p, size);
+		if (n > 0) {
+			sys_close(fd);
+			*len = n;
+			return p;
+		}
+		kfree(p);
+		if (n == -EINVAL)
+			continue;	/* Try a larger buffer */
+		if (n < 0)
+			break;
+	}
+	sys_close(fd);
+	return NULL;
+}
+
+/*
+ * recursively scan <path>, looking for a device node of type <dev>
+ */
+static int __init find_in_devfs(char *path, unsigned dev)
+{
+	char *end = path + strlen(path);
+	int rest = path + 64 - end;
+	int size;
+	char *p = read_dir(path, &size);
+	char *s;
+
+	if (!p)
+		return -1;
+	for (s = p; s < p + size; s += ((struct linux_dirent64 *)s)->d_reclen) {
+		struct linux_dirent64 *d = (struct linux_dirent64 *)s;
+		if (strlen(d->d_name) + 2 > rest)
+			continue;
+		switch (d->d_type) {
+			case DT_BLK:
+				sprintf(end, "/%s", d->d_name);
+				if (bstat(path) != dev)
+					break;
+				kfree(p);
+				return 0;
+			case DT_DIR:
+				if (strcmp(d->d_name, ".") == 0)
+					break;
+				if (strcmp(d->d_name, "..") == 0)
+					break;
+				sprintf(end, "/%s", d->d_name);
+				if (find_in_devfs(path, dev) < 0)
+					break;
+				kfree(p);
+				return 0;
+		}
+	}
+	kfree(p);
+	return -1;
+}
+
+/*
+ * create a device node called <name> which points to
+ * <devfs_name> if possible, otherwise find a device node
+ * which matches <dev> and make <name> a symlink pointing to it.
+ */
+int __init create_dev(char *name, dev_t dev, char *devfs_name)
+{
+	char path[64];
+
+	sys_unlink(name);
+	if (devfs_name && devfs_name[0]) {
+		if (strncmp(devfs_name, "/dev/", 5) == 0)
+			devfs_name += 5;
+		sprintf(path, "/dev/%s", devfs_name);
+		if (sys_access(path, 0) == 0)
+			return sys_symlink(devfs_name, name);
+	}
+	if (!dev)
+		return -1;
+	strcpy(path, "/dev");
+	if (find_in_devfs(path, new_encode_dev(dev)) < 0)
+		return -1;
+	return sys_symlink(path + 5, name);
+}
diff -urN linux-2.6.19.old/init/do_mounts.h linux-2.6.19.dev/init/do_mounts.h
--- linux-2.6.19.old/init/do_mounts.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/init/do_mounts.h	2006-12-14 03:12:59.000000000 +0100
@@ -6,6 +6,7 @@
 #include <linux/mount.h>
 #include <linux/major.h>
 #include <linux/root_dev.h>
+#include <linux/devfs_fs_kernel.h>
 
 void  change_floppy(char *fmt, ...);
 void  mount_block_root(char *name, int flags);
@@ -13,12 +14,25 @@
 extern int root_mountflags;
 extern char *root_device_name;
 
-static inline int create_dev(char *name, dev_t dev)
+#ifdef CONFIG_DEVFS_FS
+
+void mount_devfs(void);
+void umount_devfs(char *path);
+int  create_dev(char *name, dev_t dev, char *devfs_name);
+
+#else
+
+static inline void mount_devfs(void) {}
+static inline void umount_devfs(const char *path) {}
+
+static inline int create_dev(char *name, dev_t dev, char *devfs_name)
 {
 	sys_unlink(name);
 	return sys_mknod(name, S_IFBLK|0600, new_encode_dev(dev));
 }
 
+#endif
+
 #if BITS_PER_LONG == 32
 static inline u32 bstat(char *name)
 {
diff -urN linux-2.6.19.old/init/do_mounts_initrd.c linux-2.6.19.dev/init/do_mounts_initrd.c
--- linux-2.6.19.old/init/do_mounts_initrd.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/init/do_mounts_initrd.c	2006-12-14 03:12:59.000000000 +0100
@@ -43,7 +43,7 @@
 	int pid;
 
 	real_root_dev = new_encode_dev(ROOT_DEV);
-	create_dev("/dev/root.old", Root_RAM0);
+	create_dev("/dev/root.old", Root_RAM0, NULL);
 	/* mount initrd on rootfs' /root */
 	mount_block_root("/dev/root.old", root_mountflags & ~MS_RDONLY);
 	sys_mkdir("/old", 0700);
@@ -53,6 +53,7 @@
 	sys_chdir("/root");
 	sys_mount(".", "/", NULL, MS_MOVE, NULL);
 	sys_chroot(".");
+	mount_devfs_fs ();
 
 	current->flags |= PF_NOFREEZE;
 	pid = kernel_thread(do_linuxrc, "/linuxrc", SIGCHLD);
@@ -69,6 +70,7 @@
 	sys_chroot(".");
 	sys_close(old_fd);
 	sys_close(root_fd);
+	umount_devfs("/old/dev");
 
 	if (new_decode_dev(real_root_dev) == Root_RAM0) {
 		sys_chdir("/old");
@@ -104,7 +106,7 @@
 int __init initrd_load(void)
 {
 	if (mount_initrd) {
-		create_dev("/dev/ram", Root_RAM0);
+		create_dev("/dev/ram", Root_RAM0, NULL);
 		/*
 		 * Load the initrd data into /dev/ram0. Execute it as initrd
 		 * unless /dev/ram0 is supposed to be our actual root device,
diff -urN linux-2.6.19.old/init/do_mounts_md.c linux-2.6.19.dev/init/do_mounts_md.c
--- linux-2.6.19.old/init/do_mounts_md.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/init/do_mounts_md.c	2006-12-14 03:12:59.000000000 +0100
@@ -121,18 +121,19 @@
 		int err = 0;
 		char *devname;
 		mdu_disk_info_t dinfo;
-		char name[16];
+		char name[16], devfs_name[16];
 
 		minor = md_setup_args[ent].minor;
 		partitioned = md_setup_args[ent].partitioned;
 		devname = md_setup_args[ent].device_names;
 
 		sprintf(name, "/dev/md%s%d", partitioned?"_d":"", minor);
+		sprintf(devfs_name, "/dev/md/%s%d", partitioned?"d":"", minor);
 		if (partitioned)
 			dev = MKDEV(mdp_major, minor << MdpMinorShift);
 		else
 			dev = MKDEV(MD_MAJOR, minor);
-		create_dev(name, dev);
+		create_dev(name, dev, devfs_name);
 		for (i = 0; i < MD_SB_DISKS && devname != 0; i++) {
 			char *p;
 			char comp_name[64];
@@ -267,7 +268,7 @@
 
 void __init md_run_setup(void)
 {
-	create_dev("/dev/md0", MKDEV(MD_MAJOR, 0));
+	create_dev("/dev/md0", MKDEV(MD_MAJOR, 0), "md/0");
 	if (raid_noautodetect)
 		printk(KERN_INFO "md: Skipping autodetection of RAID arrays. (raid=noautodetect)\n");
 	else {
diff -urN linux-2.6.19.old/init/main.c linux-2.6.19.dev/init/main.c
--- linux-2.6.19.old/init/main.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/init/main.c	2006-12-14 03:12:59.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/kernel.h>
 #include <linux/syscalls.h>
 #include <linux/string.h>
diff -urN linux-2.6.19.old/init/Makefile linux-2.6.19.dev/init/Makefile
--- linux-2.6.19.old/init/Makefile	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/init/Makefile	2006-12-14 03:12:59.000000000 +0100
@@ -6,6 +6,7 @@
 obj-$(CONFIG_GENERIC_CALIBRATE_DELAY) += calibrate.o
 
 mounts-y			:= do_mounts.o
+mounts-$(CONFIG_DEVFS_FS)	+= do_mounts_devfs.o
 mounts-$(CONFIG_BLK_DEV_RAM)	+= do_mounts_rd.o
 mounts-$(CONFIG_BLK_DEV_INITRD)	+= do_mounts_initrd.o
 mounts-$(CONFIG_BLK_DEV_MD)	+= do_mounts_md.o
diff -urN linux-2.6.19.old/mm/shmem.c linux-2.6.19.dev/mm/shmem.c
--- linux-2.6.19.old/mm/shmem.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/mm/shmem.c	2006-12-14 03:12:59.000000000 +0100
@@ -25,6 +25,7 @@
 
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/fs.h>
 #include <linux/xattr.h>
 #include <linux/generic_acl.h>
@@ -2427,6 +2428,9 @@
 		goto out2;
 	}
 
+#ifdef CONFIG_TMPFS
+	devfs_mk_dir("shm");
+#endif
 	shm_mnt = vfs_kern_mount(&tmpfs_fs_type, MS_NOUSER,
 				tmpfs_fs_type.name, NULL);
 	if (IS_ERR(shm_mnt)) {
diff -urN linux-2.6.19.old/mm/tiny-shmem.c linux-2.6.19.dev/mm/tiny-shmem.c
--- linux-2.6.19.old/mm/tiny-shmem.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/mm/tiny-shmem.c	2006-12-14 03:12:59.000000000 +0100
@@ -12,6 +12,7 @@
 
 #include <linux/fs.h>
 #include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/vfs.h>
 #include <linux/mount.h>
 #include <linux/file.h>
@@ -32,6 +33,9 @@
 {
 	BUG_ON(register_filesystem(&tmpfs_fs_type) != 0);
 
+#ifdef CONFIG_TMPFS
+	devfs_mk_dir("shm");
+#endif
 	shm_mnt = kern_mount(&tmpfs_fs_type);
 	BUG_ON(IS_ERR(shm_mnt));
 
diff -urN linux-2.6.19.old/net/bluetooth/rfcomm/tty.c linux-2.6.19.dev/net/bluetooth/rfcomm/tty.c
--- linux-2.6.19.old/net/bluetooth/rfcomm/tty.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/net/bluetooth/rfcomm/tty.c	2006-12-14 03:12:59.000000000 +0100
@@ -1039,12 +1039,13 @@
 
 	rfcomm_tty_driver->owner	= THIS_MODULE;
 	rfcomm_tty_driver->driver_name	= "rfcomm";
+	rfcomm_tty_driver->devfs_name	= "bluetooth/rfcomm/";
 	rfcomm_tty_driver->name		= "rfcomm";
 	rfcomm_tty_driver->major	= RFCOMM_TTY_MAJOR;
 	rfcomm_tty_driver->minor_start	= RFCOMM_TTY_MINOR;
 	rfcomm_tty_driver->type		= TTY_DRIVER_TYPE_SERIAL;
 	rfcomm_tty_driver->subtype	= SERIAL_TYPE_NORMAL;
-	rfcomm_tty_driver->flags	= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	rfcomm_tty_driver->flags	= TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
 	rfcomm_tty_driver->init_termios	= tty_std_termios;
 	rfcomm_tty_driver->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	tty_set_operations(rfcomm_tty_driver, &rfcomm_ops);
diff -urN linux-2.6.19.old/net/irda/ircomm/ircomm_tty.c linux-2.6.19.dev/net/irda/ircomm/ircomm_tty.c
--- linux-2.6.19.old/net/irda/ircomm/ircomm_tty.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/net/irda/ircomm/ircomm_tty.c	2006-12-14 03:12:59.000000000 +0100
@@ -123,6 +123,7 @@
 	driver->owner		= THIS_MODULE;
 	driver->driver_name     = "ircomm";
 	driver->name            = "ircomm";
+	driver->devfs_name      = "ircomm";
 	driver->major           = IRCOMM_TTY_MAJOR;
 	driver->minor_start     = IRCOMM_TTY_MINOR;
 	driver->type            = TTY_DRIVER_TYPE_SERIAL;
diff -urN linux-2.6.19.old/net/irda/irnet/irnet.h linux-2.6.19.dev/net/irda/irnet/irnet.h
--- linux-2.6.19.old/net/irda/irnet/irnet.h	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/net/irda/irnet/irnet.h	2006-12-14 03:12:59.000000000 +0100
@@ -244,6 +244,7 @@
 #include <linux/skbuff.h>
 #include <linux/tty.h>
 #include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/netdevice.h>
 #include <linux/miscdevice.h>
 #include <linux/poll.h>
diff -urN linux-2.6.19.old/sound/core/info.c linux-2.6.19.dev/sound/core/info.c
--- linux-2.6.19.old/sound/core/info.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/sound/core/info.c	2006-12-14 03:12:59.000000000 +0100
@@ -29,6 +29,7 @@
 #include <sound/info.h>
 #include <sound/version.h>
 #include <linux/proc_fs.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/mutex.h>
 #include <stdarg.h>
 
diff -urN linux-2.6.19.old/sound/core/sound.c linux-2.6.19.dev/sound/core/sound.c
--- linux-2.6.19.old/sound/core/sound.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/sound/core/sound.c	2006-12-14 03:12:59.000000000 +0100
@@ -32,6 +32,7 @@
 #include <sound/control.h>
 #include <sound/initval.h>
 #include <linux/kmod.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/mutex.h>
 
 #define SNDRV_OS_MINORS 256
@@ -41,6 +42,7 @@
 EXPORT_SYMBOL(snd_major);
 
 static int cards_limit = 1;
+static int device_mode = S_IFCHR | S_IRUGO | S_IWUGO;
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture driver for soundcards.");
@@ -49,6 +51,10 @@
 MODULE_PARM_DESC(major, "Major # for sound driver.");
 module_param(cards_limit, int, 0444);
 MODULE_PARM_DESC(cards_limit, "Count of auto-loadable soundcards.");
+#ifdef CONFIG_DEVFS_FS
+module_param(device_mode, int, 0444);
+MODULE_PARM_DESC(device_mode, "Device file permission mask for devfs.");
+#endif
 MODULE_ALIAS_CHARDEV_MAJOR(CONFIG_SND_MAJOR);
 
 /* this one holds the actual max. card number currently available.
@@ -244,7 +250,7 @@
 	struct device *device = NULL;
 
 	snd_assert(name, return -EINVAL);
-	preg = kmalloc(sizeof *preg, GFP_KERNEL);
+	preg = kmalloc((sizeof *preg) + strlen(name) + 1, GFP_KERNEL);
 	if (preg == NULL)
 		return -ENOMEM;
 	preg->type = type;
@@ -252,6 +258,7 @@
 	preg->device = dev;
 	preg->f_ops = f_ops;
 	preg->private_data = private_data;
+	strcpy(preg->name, name); /* for devfs */
 	mutex_lock(&sound_mutex);
 #ifdef CONFIG_SND_DYNAMIC_MINORS
 	minor = snd_find_free_minor();
@@ -266,6 +273,8 @@
 		return minor;
 	}
 	snd_minors[minor] = preg;
+	if (type != SNDRV_DEVICE_TYPE_CONTROL || preg->card >= cards_limit)
+		devfs_mk_cdev(MKDEV(major, minor), S_IFCHR | device_mode, "snd/%s", name);
 	if (card)
 		device = card->dev;
 	preg->class_dev = class_device_create(sound_class, NULL,
@@ -320,6 +329,9 @@
 		return -EINVAL;
 	}
 
+	if (snd_minors[minor]->type != SNDRV_DEVICE_TYPE_CONTROL ||
+	    snd_minors[minor]->card >= cards_limit)	/* created in sound.c */
+		devfs_remove("snd/%s", snd_minors[minor]->name);
 	class_device_destroy(sound_class, MKDEV(major, minor));
 
 	kfree(snd_minors[minor]);
@@ -430,17 +442,24 @@
 
 static int __init alsa_sound_init(void)
 {
+	short controlnum;
+
 	snd_major = major;
 	snd_ecards_limit = cards_limit;
+	devfs_mk_dir("snd");
 	if (register_chrdev(major, "alsa", &snd_fops)) {
 		snd_printk(KERN_ERR "unable to register native major device number %d\n", major);
+		devfs_remove("snd");
 		return -EIO;
 	}
 	if (snd_info_init() < 0) {
 		unregister_chrdev(major, "alsa");
+		devfs_remove("snd");
 		return -ENOMEM;
 	}
 	snd_info_minor_register();
+	for (controlnum = 0; controlnum < cards_limit; controlnum++)
+		devfs_mk_cdev(MKDEV(major, controlnum<<5), S_IFCHR | device_mode, "snd/controlC%d", controlnum);
 #ifndef MODULE
 	printk(KERN_INFO "Advanced Linux Sound Architecture Driver Version " CONFIG_SND_VERSION CONFIG_SND_DATE ".\n");
 #endif
@@ -449,10 +468,16 @@
 
 static void __exit alsa_sound_exit(void)
 {
+	short controlnum;
+
+	for (controlnum = 0; controlnum < cards_limit; controlnum++)
+		devfs_remove("snd/controlC%d", controlnum);
+
 	snd_info_minor_unregister();
 	snd_info_done();
 	if (unregister_chrdev(major, "alsa") != 0)
 		snd_printk(KERN_ERR "unable to unregister major device number %d\n", major);
+	devfs_remove("snd");
 }
 
 module_init(alsa_sound_init)
diff -urN linux-2.6.19.old/sound/oss/soundcard.c linux-2.6.19.dev/sound/oss/soundcard.c
--- linux-2.6.19.old/sound/oss/soundcard.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/sound/oss/soundcard.c	2006-12-14 03:12:59.000000000 +0100
@@ -37,6 +37,7 @@
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <linux/ioport.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/major.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
@@ -557,6 +558,9 @@
 	sound_dmap_flag = (dmabuf > 0 ? 1 : 0);
 
 	for (i = 0; i < sizeof (dev_list) / sizeof *dev_list; i++) {
+		devfs_mk_cdev(MKDEV(SOUND_MAJOR, dev_list[i].minor),
+				S_IFCHR | dev_list[i].mode,
+				"sound/%s", dev_list[i].name);
 		class_device_create(sound_class, NULL,
 				    MKDEV(SOUND_MAJOR, dev_list[i].minor),
 				    NULL, "%s", dev_list[i].name);
@@ -564,10 +568,15 @@
 		if (!dev_list[i].num)
 			continue;
 
-		for (j = 1; j < *dev_list[i].num; j++)
+		for (j = 1; j < *dev_list[i].num; j++) {
+			devfs_mk_cdev(MKDEV(SOUND_MAJOR,
+						dev_list[i].minor + (j*0x10)),
+					S_IFCHR | dev_list[i].mode,
+					"sound/%s%d", dev_list[i].name, j);
 			class_device_create(sound_class, NULL,
 					    MKDEV(SOUND_MAJOR, dev_list[i].minor + (j*0x10)),
 					    NULL, "%s%d", dev_list[i].name, j);
+		}
 	}
 
 	if (sound_nblocks >= 1024)
@@ -581,11 +590,14 @@
 	int i, j;
 
 	for (i = 0; i < sizeof (dev_list) / sizeof *dev_list; i++) {
+		devfs_remove("sound/%s", dev_list[i].name);
 		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, dev_list[i].minor));
 		if (!dev_list[i].num)
 			continue;
-		for (j = 1; j < *dev_list[i].num; j++)
+		for (j = 1; j < *dev_list[i].num; j++) {
+			devfs_remove("sound/%s%d", dev_list[i].name, j);
 			class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, dev_list[i].minor + (j*0x10)));
+		}
 	}
 	
 	unregister_sound_special(1);
diff -urN linux-2.6.19.old/sound/sound_core.c linux-2.6.19.dev/sound/sound_core.c
--- linux-2.6.19.old/sound/sound_core.c	2006-11-29 22:57:37.000000000 +0100
+++ linux-2.6.19.dev/sound/sound_core.c	2006-12-14 03:12:59.000000000 +0100
@@ -43,6 +43,7 @@
 #include <linux/sound.h>
 #include <linux/major.h>
 #include <linux/kmod.h>
+#include <linux/devfs_fs_kernel.h>
 #include <linux/device.h>
 
 #define SOUND_STEP 16
@@ -170,6 +171,8 @@
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
 
+	devfs_mk_cdev(MKDEV(SOUND_MAJOR, s->unit_minor),
+			S_IFCHR | mode, s->name);
 	class_device_create(sound_class, NULL, MKDEV(SOUND_MAJOR, s->unit_minor),
 			    dev, s->name+6);
 	return r;
@@ -193,6 +196,7 @@
 	p = __sound_remove_unit(list, unit);
 	spin_unlock(&sound_loader_lock);
 	if (p) {
+		devfs_remove(p->name);
 		class_device_destroy(sound_class, MKDEV(SOUND_MAJOR, p->unit_minor));
 		kfree(p);
 	}
@@ -527,6 +531,7 @@
 	/* We have nothing to really do here - we know the lists must be
 	   empty */
 	unregister_chrdev(SOUND_MAJOR, "sound");
+	devfs_remove("sound");
 	class_destroy(sound_class);
 }
 
@@ -536,6 +541,7 @@
 		printk(KERN_ERR "soundcore: sound device already in use.\n");
 		return -EBUSY;
 	}
+	devfs_mk_dir ("sound");
 	sound_class = class_create(THIS_MODULE, "sound");
 	if (IS_ERR(sound_class))
 		return PTR_ERR(sound_class);
