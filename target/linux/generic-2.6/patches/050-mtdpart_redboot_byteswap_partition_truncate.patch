--- linux-2.6.18/drivers/mtd/redboot.c.orig	2006-10-23 11:41:56.000000000 -0400
+++ linux-2.6.18/drivers/mtd/redboot.c	2006-10-23 11:42:09.000000000 -0400
@@ -92,22 +92,47 @@
 			 * swab32(erasesize) then we know we are looking at
 			 * a byte swapped FIS directory - swap all the entries!
 			 * (NOTE: this is 'size' not 'data_length'; size is
-			 * the full size of the entry.)
+			 * the full size of the entry.) 
+			 *
+			 * Handle cases where the FIS directory is less than
+			 * a full erase block (like combine FIS directory
+			 * and RedBoot config).
+			 *
+			 * IMHO the best solution would be to compute the
+			 * flash address of the RedBoot FIS directory and
+			 * compare that with the entry in the FIS directory
+			 * entry swabbed.  However, I haven't yet figured out
+			 * how to compute that.
 			 */
-			if (swab32(buf[i].size) == master->erasesize) {
+
+			unsigned long erasesize_mask = master->erasesize -1;
+			unsigned long eraseaddr_mask = 0xFFFFFFFF ^ erasesize_mask;
+			
+			if (((swab32(buf[i].size)+erasesize_mask) 
+				& eraseaddr_mask) == master->erasesize) {
 				int j;
-				for (j = 0; j < numslots && buf[j].name[0] != 0xff; ++j) {
+
+				/* N.B. The full table being processed so adjust size now */
+				numslots = swab32(buf[i].size) / sizeof (struct fis_image_desc);
+				for (j = 0; j < numslots; ++j) {
 					/* The unsigned long fields were written with the
 					 * wrong byte sex, name and pad have no byte sex.
-					 */
-					swab32s(&buf[j].flash_base);
-					swab32s(&buf[j].mem_base);
-					swab32s(&buf[j].size);
-					swab32s(&buf[j].entry_point);
-					swab32s(&buf[j].data_length);
-					swab32s(&buf[j].desc_cksum);
-					swab32s(&buf[j].file_cksum);
+					 *
+					 * Only process non-deleted entries. Don't exit early.
+					 */
+					if (buf[j].name[0] != 0xff) {
+						swab32s(&buf[j].flash_base);
+						swab32s(&buf[j].mem_base);
+						swab32s(&buf[j].size);
+						swab32s(&buf[j].entry_point);
+						swab32s(&buf[j].data_length);
+						swab32s(&buf[j].desc_cksum);
+						swab32s(&buf[j].file_cksum);
+					}
 				}
+			} else {
+				/* Update numslots based on actual FIS directory size */
+				numslots = buf[i].size / sizeof (struct fis_image_desc);
 			}
 			break;
 		}
