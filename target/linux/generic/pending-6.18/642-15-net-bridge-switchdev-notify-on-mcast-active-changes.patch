From aa8714d0a53220d6120fb2685d88f541eb52af06 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Linus=20L=C3=BCssing?= <linus.luessing@c0d3.blue>
Date: Mon, 14 Apr 2025 00:03:10 +0200
Subject: [PATCH 15/16] net: bridge: switchdev: notify on mcast active changes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Let the bridge notify switchdev if the multicast
active state toggles. So that switch drivers can act on it
accordingly, especially to avoid packetloss.

Signed-off-by: Linus LÃ¼ssing <linus.luessing@c0d3.blue>
---
 Documentation/networking/switchdev.rst |  8 +--
 include/net/switchdev.h                | 10 +++
 net/bridge/br_multicast.c              | 91 ++++++++++++++++++++------
 3 files changed, 85 insertions(+), 24 deletions(-)

--- a/Documentation/networking/switchdev.rst
+++ b/Documentation/networking/switchdev.rst
@@ -558,7 +558,7 @@ Because IGMP snooping can be turned on/o
 must be able to reconfigure the underlying hardware on the fly to honor the
 toggling of that option and behave appropriately.
 
-A switchdev driver can also refuse to support dynamic toggling of the multicast
-snooping knob at runtime and require the destruction of the bridge device(s)
-and creation of a new bridge device(s) with a different multicast snooping
-value.
+A switchdev driver must also be able to react to vanishing or appearing
+IGMP/MLD queriers. If no querier is present then, even if IGMP/MLD snooping
+is enabled, the switch must treat this as if IGMP/MLD snooping were disabled.
+The SWITCHDEV_ATTR_ID_BRIDGE_MC_ACTIVE notification allows to track this.
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@ -27,6 +27,7 @@ enum switchdev_attr_id {
 	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING,
 	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL,
 	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED,
+	SWITCHDEV_ATTR_ID_BRIDGE_MC_ACTIVE,
 	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER,
 	SWITCHDEV_ATTR_ID_BRIDGE_MST,
 	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE,
@@ -43,6 +44,14 @@ struct switchdev_brport_flags {
 	unsigned long mask;
 };
 
+struct switchdev_mc_active {
+	short vid;
+	u8 ip4:1,
+	   ip6:1,
+	   ip4_changed:1,
+	   ip6_changed:1;
+};
+
 struct switchdev_vlan_msti {
 	u16 vid;
 	u16 msti;
@@ -64,6 +73,7 @@ struct switchdev_attr {
 		u16 vlan_protocol;			/* BRIDGE_VLAN_PROTOCOL */
 		bool mst;				/* BRIDGE_MST */
 		bool mc_disabled;			/* MC_DISABLED */
+		struct switchdev_mc_active mc_active;	/* MC_ACTIVE */
 		u8 mrp_port_role;			/* MRP_PORT_ROLE */
 		struct switchdev_vlan_msti vlan_msti;	/* VLAN_MSTI */
 	} u;
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -1135,23 +1135,47 @@ static void br_ip6_multicast_update_acti
 #endif
 }
 
-static void br_multicast_notify_active(struct net_bridge_mcast *brmctx,
-				       bool ip4_active_old, bool ip6_active_old)
+static int br_multicast_notify_active(struct net_bridge_mcast *brmctx,
+				      bool ip4_active_old, bool ip6_active_old,
+				      struct netlink_ext_ack *extack)
 {
 	int ip4_active = READ_ONCE(brmctx->ip4_active);
 	int ip6_active = READ_ONCE(brmctx->ip6_active);
+	int err;
 
-	if (ip4_active == ip4_active_old &&
-	    ip6_active == ip6_active_old)
-		return;
+	struct switchdev_attr attr = {
+		.orig_dev = brmctx->br->dev,
+		.id = SWITCHDEV_ATTR_ID_BRIDGE_MC_ACTIVE,
+		.flags = SWITCHDEV_F_DEFER,
+		.u.mc_active = {
+			.vid = brmctx->vlan ? brmctx->vlan->vid : -1,
+			.ip4 = ip4_active,
+			.ip6 = ip6_active,
+			.ip4_changed = ip4_active != ip4_active_old,
+			.ip6_changed = ip6_active != ip6_active_old,
+		},
+	};
+
+	if (!attr.u.mc_active.ip4_changed &&
+	    !attr.u.mc_active.ip6_changed)
+		return 0;
+
+	err = switchdev_port_attr_set(brmctx->br->dev, &attr, extack);
+	if (err && err != -EOPNOTSUPP) {
+		br_err(brmctx->br, "failed to notify mc_active change, err: %i\n", err);
+		return err;
+	}
 
 	br_info(brmctx->br, "mc_active changed: v4: %i->%i, v6: %i->%i\n",
 		ip4_active_old, ip4_active, ip6_active_old, ip6_active);
+
+	return 0;
 }
 
 /**
  * br_multicast_update_active() - update mcast active state
  * @brmctx: the bridge multicast context to check
+ * @extack: netlink extended ACK structure
  *
  * This (potentially) updates the IPv4/IPv6 multicast active state. And by
  * that enables or disables snooping of multicast payload traffic in fast
@@ -1168,12 +1192,18 @@ static void br_multicast_notify_active(s
  *
  * This function should be called by anything that changes one of the
  * above prerequisites.
+ *
+ * Any multicast active state toggling is further notified to switchdev.
+ *
+ * Return: 0 on success, a negative value otherwise.
  */
-static void br_multicast_update_active(struct net_bridge_mcast *brmctx)
+static int br_multicast_update_active(struct net_bridge_mcast *brmctx,
+				      struct netlink_ext_ack *extack)
 {
 	bool ip4_active_old = READ_ONCE(brmctx->ip4_active);
 	bool ip6_active_old = READ_ONCE(brmctx->ip6_active);
 	bool force_inactive = false;
+	int err;
 
 	lockdep_assert_held_once(&brmctx->br->multicast_lock);
 
@@ -1206,7 +1236,15 @@ static void br_multicast_update_active(s
 	br_ip4_multicast_update_active(brmctx, force_inactive);
 	br_ip6_multicast_update_active(brmctx, force_inactive);
 
-	br_multicast_notify_active(brmctx, ip4_active_old, ip6_active_old);
+	err = br_multicast_notify_active(brmctx, ip4_active_old, ip6_active_old, extack);
+	if (err) {
+		/* notification failed (out-of-memory?), rollback */
+		WRITE_ONCE(brmctx->ip4_active, ip4_active_old);
+		WRITE_ONCE(brmctx->ip6_active, ip6_active_old);
+		return err;
+	}
+
+	return 0;
 }
 
 #if IS_ENABLED(CONFIG_IPV6)
@@ -1287,12 +1325,12 @@ static struct sk_buff *br_ip6_multicast_
 			       &ip6h->daddr, 0, &ip6h->saddr)) {
 		kfree_skb(skb);
 		br_opt_toggle(brmctx->br, BROPT_HAS_IPV6_ADDR, false);
-		br_multicast_update_active(brmctx);
+		br_multicast_update_active(brmctx, NULL);
 		return NULL;
 	}
 
 	br_opt_toggle(brmctx->br, BROPT_HAS_IPV6_ADDR, true);
-	br_multicast_update_active(brmctx);
+	br_multicast_update_active(brmctx, NULL);
 	ipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);
 
 	hopopt = (u8 *)(ip6h + 1);
@@ -1433,13 +1471,24 @@ static void br_multicast_assert_inactive
 	br_ip6_multicast_assert_inactive(brmctx);
 }
 
-static void br_multicast_toggle_enabled(struct net_bridge *br, bool on)
+static int br_multicast_toggle_enabled(struct net_bridge *br, bool on,
+				       struct netlink_ext_ack *extack)
 {
+	int old = br_opt_get(br, BROPT_MULTICAST_ENABLED);
+	int err;
+
 	br_opt_toggle(br, BROPT_MULTICAST_ENABLED, on);
-	br_multicast_update_active(&br->multicast_ctx);
+
+	err = br_multicast_update_active(&br->multicast_ctx, extack);
+	if (err) {
+		br_opt_toggle(br, BROPT_MULTICAST_ENABLED, old);
+		return err;
+	}
 
 	if (!on)
 		br_multicast_assert_inactive(&br->multicast_ctx);
+
+	return 0;
 }
 
 struct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,
@@ -1455,7 +1504,7 @@ struct net_bridge_mdb_entry *br_multicas
 	if (atomic_read(&br->mdb_hash_tbl.nelems) >= br->hash_max) {
 		trace_br_mdb_full(br->dev, group);
 		br_mc_disabled_update(br->dev, false, NULL);
-		br_multicast_toggle_enabled(br, false);
+		br_multicast_toggle_enabled(br, false, NULL);
 		return ERR_PTR(-E2BIG);
 	}
 
@@ -1919,7 +1968,7 @@ out:
 	/* another IGMP/MLD querier disappeared, set multicast state to inactive
 	 * if our own querier is disabled, too
 	 */
-	br_multicast_update_active(brmctx);
+	br_multicast_update_active(brmctx, NULL);
 }
 
 static void br_ip4_multicast_querier_expired(struct timer_list *t)
@@ -1968,7 +2017,7 @@ static void br_ip4_multicast_query_delay
 		/* an own or other IGMP querier appeared some seconds ago and all
 		 * reports should have arrived by now, maybe set multicast state to active
 		 */
-		br_multicast_update_active(brmctx);
+		br_multicast_update_active(brmctx, NULL);
 	spin_unlock(&brmctx->br->multicast_lock);
 }
 
@@ -1983,7 +2032,7 @@ static void br_ip6_multicast_query_delay
 		/* an own or other MLD querier appeared some seconds ago and all
 		 * reports should have arrived, maybe set multicast state to active
 		 */
-		br_multicast_update_active(brmctx);
+		br_multicast_update_active(brmctx, NULL);
 	spin_unlock(&brmctx->br->multicast_lock);
 }
 #endif
@@ -4488,7 +4537,7 @@ static void __br_multicast_open(struct n
 #endif
 
 	/* bridge interface is up, maybe set multicast state to active */
-	br_multicast_update_active(brmctx);
+	br_multicast_update_active(brmctx, NULL);
 }
 
 void br_multicast_open(struct net_bridge *br)
@@ -4531,7 +4580,7 @@ static void __br_multicast_stop(struct n
 #endif
 
 	/* bridge interface is down, set multicast state to inactive */
-	br_multicast_update_active(brmctx);
+	br_multicast_update_active(brmctx, NULL);
 	br_multicast_assert_inactive(brmctx);
 }
 
@@ -4582,7 +4631,7 @@ void br_multicast_toggle_one_vlan(struct
 
 		spin_lock_bh(&br->multicast_lock);
 		vlan->priv_flags ^= BR_VLFLAG_MCAST_ENABLED;
-		br_multicast_update_active(&vlan->br_mcast_ctx);
+		br_multicast_update_active(&vlan->br_mcast_ctx, NULL);
 
 		if (on)
 			__br_multicast_open(&vlan->br_mcast_ctx);
@@ -4926,7 +4975,9 @@ int br_multicast_toggle(struct net_bridg
 	if (err)
 		goto unlock;
 
-	br_multicast_toggle_enabled(br, !!val);
+	err = br_multicast_toggle_enabled(br, !!val, extack);
+	if (err)
+		goto unlock;
 
 	if (!br_opt_get(br, BROPT_MULTICAST_ENABLED)) {
 		change_snoopers = true;
@@ -5018,7 +5069,7 @@ int br_multicast_set_querier(struct net_
 #endif
 
 unlock:
-	br_multicast_update_active(brmctx);
+	br_multicast_update_active(brmctx, NULL);
 	spin_unlock_bh(&brmctx->br->multicast_lock);
 
 	return 0;
