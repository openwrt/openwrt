From: Schneider Azima <Schneider-Azima12@protonmail.com>
Date: Wed, 20 Aug 2025 23:39:31 -0700
Subject: [PATCH] net: dsa: realtek: rtl8365mb: add SGMII and HSGMII mode support

This adds support for SGMII and HSGMII on RTL8367S switches.
HSGMII is configured using the 2500BASEX mode.
This is baed on the rtl8367c driver found in OpenWrt.

For (H)SGMII mode we have to load a firmware into some memory which gets
executed on the integrated 8051. The firmware binary was added as a
array into the driver with a GPL license notice on top.

This was tested on RTL8367S (ver=0x00a0, opt=0x0001).

Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
Signed-off-by: Schneider Azima <Schneider-Azima12@protonmail.com>
---
 drivers/net/dsa/realtek/rtl8365mb.c | 502 +++++++++++++++++++++++++++-
 1 file changed, 496 insertions(+), 6 deletions(-)

--- a/drivers/net/dsa/realtek/rtl8365mb.c
+++ b/drivers/net/dsa/realtek/rtl8365mb.c
@@ -124,11 +124,14 @@
 
 #define RTL8365MB_CHIP_VER_REG		0x1301
 
+#define RTL8365MB_MAGIC_OPT_REG		0x13C0
+#define RTL8365MB_CHIP_OPTION_REG	0x13C1
 #define RTL8365MB_MAGIC_REG		0x13C2
 #define   RTL8365MB_MAGIC_VALUE		0x0249
 
 /* Chip reset register */
 #define RTL8365MB_CHIP_RESET_REG	0x1322
+#define RTL8365MB_CHIP_RESET_DW8051	0x0010
 #define RTL8365MB_CHIP_RESET_SW_MASK	0x0002
 #define RTL8365MB_CHIP_RESET_HW_MASK	0x0001
 
@@ -276,6 +279,29 @@
 		 (_extint) == 1 ? RTL8367D_DIGITAL_INTERFACE_FORCE_REG1_EN : \
 		 0x0)
 
+#define	RTL8365MB_SDS_MISC			0x1d11
+#define  RTL8365MB_CFG_SGMII_RXFC		0x4000
+#define  RTL8365MB_CFG_SGMII_TXFC		0x2000
+#define  RTL8365MB_INB_ARB			0x1000
+#define  RTL8365MB_CFG_MAC8_SEL_HSGMII		0x0800
+#define  RTL8365MB_CFG_SGMII_FDUP		0x0400
+#define  RTL8365MB_CFG_SGMII_LINK		0x0200
+#define  RTL8365MB_CFG_SGMII_SPD		0x0180
+#define  RTL8365MB_CFG_MAC8_SEL_SGMII		0x0040
+#define  RTL8365MB_CFG_INB_SEL			0x0038
+#define  RTL8365MB_CFG_SDS_MODE_18C		0x0007
+
+#define RTL8365MB_SDS_INDACS_CMD		0x6600
+#define RTL8365MB_SDS_INDACS_ADR		0x6601
+#define RTL8365MB_SDS_INDACS_DATA		0x6602
+
+#define RTL8365MB_MISC_CFG0			0x130c
+#define  RTL8365MB_MISC_CFG0_DW8051_EN		0x0020
+
+#define RTL8365MB_DW8051_RDY			0x1336
+#define  RTL8365MB_DW8051_RDY_IROM_MSB		0x0004
+#define  RTL8365MB_DW8051_RDY_ACS_IROM_EN	0x0002
+
 /* CPU port mask register - controls which ports are treated as CPU ports */
 #define RTL8365MB_CPU_PORT_MASK_REG	0x1219
 #define   RTL8365MB_CPU_PORT_MASK_MASK	0x07FF
@@ -295,6 +321,8 @@
 #define   RTL8365MB_CFG0_MAX_LEN_MASK	0x3FFF
 #define RTL8365MB_CFG0_MAX_LEN_MAX	0x3FFF
 
+#define RTL8365MB_BYPASS_LINE_RATE		0x03f7
+
 /* Port learning limit registers */
 #define RTL8365MB_LUT_PORT_LEARN_LIMIT_BASE		0x0A20
 #define RTL8365MB_LUT_PORT_LEARN_LIMIT_REG(_physport) \
@@ -604,6 +632,160 @@ struct rtl8365mb_jam_tbl_entry {
 	u16 val;
 };
 
+/*
+ * The firmware binary was added as an array into the rtl8367c driver
+ * with a GPL license notice on top.
+ */
+static const u8 rtl8365mb_sgmii_init[1183] = {
+0x02,0x03,0x81,0xE4,0xF5,0xA8,0xD2,0xAF,
+0x22,0x00,0x00,0x02,0x04,0x0D,0xC5,0xF0,
+0xF8,0xA3,0xE0,0x28,0xF0,0xC5,0xF0,0xF8,
+0xE5,0x82,0x15,0x82,0x70,0x02,0x15,0x83,
+0xE0,0x38,0xF0,0x22,0x75,0xF0,0x08,0x75,
+0x82,0x00,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xCD,0x33,0xCD,0xCC,0x33,0xCC,0xC5,0x82,
+0x33,0xC5,0x82,0x9B,0xED,0x9A,0xEC,0x99,
+0xE5,0x82,0x98,0x40,0x0C,0xF5,0x82,0xEE,
+0x9B,0xFE,0xED,0x9A,0xFD,0xEC,0x99,0xFC,
+0x0F,0xD5,0xF0,0xD6,0xE4,0xCE,0xFB,0xE4,
+0xCD,0xFA,0xE4,0xCC,0xF9,0xA8,0x82,0x22,
+0xB8,0x00,0xC1,0xB9,0x00,0x59,0xBA,0x00,
+0x2D,0xEC,0x8B,0xF0,0x84,0xCF,0xCE,0xCD,
+0xFC,0xE5,0xF0,0xCB,0xF9,0x78,0x18,0xEF,
+0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,0xFD,
+0xEC,0x33,0xFC,0xEB,0x33,0xFB,0x10,0xD7,
+0x03,0x99,0x40,0x04,0xEB,0x99,0xFB,0x0F,
+0xD8,0xE5,0xE4,0xF9,0xFA,0x22,0x78,0x18,
+0xEF,0x2F,0xFF,0xEE,0x33,0xFE,0xED,0x33,
+0xFD,0xEC,0x33,0xFC,0xC9,0x33,0xC9,0x10,
+0xD7,0x05,0x9B,0xE9,0x9A,0x40,0x07,0xEC,
+0x9B,0xFC,0xE9,0x9A,0xF9,0x0F,0xD8,0xE0,
+0xE4,0xC9,0xFA,0xE4,0xCC,0xFB,0x22,0x75,
+0xF0,0x10,0xEF,0x2F,0xFF,0xEE,0x33,0xFE,
+0xED,0x33,0xFD,0xCC,0x33,0xCC,0xC8,0x33,
+0xC8,0x10,0xD7,0x07,0x9B,0xEC,0x9A,0xE8,
+0x99,0x40,0x0A,0xED,0x9B,0xFD,0xEC,0x9A,
+0xFC,0xE8,0x99,0xF8,0x0F,0xD5,0xF0,0xDA,
+0xE4,0xCD,0xFB,0xE4,0xCC,0xFA,0xE4,0xC8,
+0xF9,0x22,0xEB,0x9F,0xF5,0xF0,0xEA,0x9E,
+0x42,0xF0,0xE9,0x9D,0x42,0xF0,0xE8,0x9C,
+0x45,0xF0,0x22,0xE0,0xFC,0xA3,0xE0,0xFD,
+0xA3,0xE0,0xFE,0xA3,0xE0,0xFF,0x22,0xE0,
+0xF8,0xA3,0xE0,0xF9,0xA3,0xE0,0xFA,0xA3,
+0xE0,0xFB,0x22,0xEC,0xF0,0xA3,0xED,0xF0,
+0xA3,0xEE,0xF0,0xA3,0xEF,0xF0,0x22,0xE4,
+0x90,0x06,0x2C,0xF0,0xFD,0x7C,0x01,0x7F,
+0x3F,0x7E,0x1D,0x12,0x04,0x6B,0x7D,0x40,
+0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,0x04,
+0x6B,0xE4,0xFF,0xFE,0xFD,0x80,0x25,0xE4,
+0x7F,0xFF,0x7E,0xFF,0xFD,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,0xF2,
+0x50,0x1B,0x90,0x06,0x24,0x12,0x01,0x03,
+0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,0xE4,
+0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,0x24,
+0x12,0x01,0x1B,0x80,0xD2,0xE4,0xF5,0xA8,
+0xD2,0xAF,0x7D,0x1F,0xFC,0x7F,0x49,0x7E,
+0x13,0x12,0x04,0x6B,0x12,0x04,0x92,0x7D,
+0x41,0x7C,0x00,0x7F,0x36,0x7E,0x13,0x12,
+0x04,0x6B,0xE4,0xFF,0xFE,0xFD,0x80,0x25,
+0xE4,0x7F,0x20,0x7E,0x4E,0xFD,0xFC,0x90,
+0x06,0x24,0x12,0x01,0x0F,0xC3,0x12,0x00,
+0xF2,0x50,0x1B,0x90,0x06,0x24,0x12,0x01,
+0x03,0xEF,0x24,0x01,0xFF,0xE4,0x3E,0xFE,
+0xE4,0x3D,0xFD,0xE4,0x3C,0xFC,0x90,0x06,
+0x24,0x12,0x01,0x1B,0x80,0xD2,0xC2,0x00,
+0xC2,0x01,0xD2,0xA9,0xD2,0x8C,0x7F,0x01,
+0x7E,0x62,0x12,0x04,0x47,0xEF,0x30,0xE2,
+0x07,0xE4,0x90,0x06,0x2C,0xF0,0x80,0xEE,
+0x90,0x06,0x2C,0xE0,0x70,0x12,0x12,0x02,
+0xDB,0x90,0x06,0x2C,0x74,0x01,0xF0,0xE4,
+0x90,0x06,0x2F,0xF0,0xA3,0xF0,0x80,0xD6,
+0xC3,0x90,0x06,0x30,0xE0,0x94,0x62,0x90,
+0x06,0x2F,0xE0,0x94,0x00,0x40,0xC7,0xE4,
+0xF0,0xA3,0xF0,0x12,0x02,0xDB,0x90,0x06,
+0x2C,0x74,0x01,0xF0,0x80,0xB8,0x75,0x0F,
+0x80,0x75,0x0E,0x7E,0x75,0x0D,0xAA,0x75,
+0x0C,0x83,0xE4,0xF5,0x10,0x7F,0x36,0x7E,
+0x13,0x12,0x04,0x47,0xEE,0xC4,0xF8,0x54,
+0xF0,0xC8,0xEF,0xC4,0x54,0x0F,0x48,0x54,
+0x07,0xFB,0x7A,0x00,0xEA,0x70,0x4A,0xEB,
+0x14,0x60,0x1C,0x14,0x60,0x27,0x24,0xFE,
+0x60,0x31,0x14,0x60,0x3C,0x24,0x05,0x70,
+0x38,0x75,0x0B,0x00,0x75,0x0A,0xC2,0x75,
+0x09,0xEB,0x75,0x08,0x0B,0x80,0x36,0x75,
+0x0B,0x40,0x75,0x0A,0x59,0x75,0x09,0x73,
+0x75,0x08,0x07,0x80,0x28,0x75,0x0B,0x00,
+0x75,0x0A,0xE1,0x75,0x09,0xF5,0x75,0x08,
+0x05,0x80,0x1A,0x75,0x0B,0xA0,0x75,0x0A,
+0xAC,0x75,0x09,0xB9,0x75,0x08,0x03,0x80,
+0x0C,0x75,0x0B,0x00,0x75,0x0A,0x62,0x75,
+0x09,0x3D,0x75,0x08,0x01,0x75,0x89,0x11,
+0xE4,0x7B,0x60,0x7A,0x09,0xF9,0xF8,0xAF,
+0x0B,0xAE,0x0A,0xAD,0x09,0xAC,0x08,0x12,
+0x00,0x60,0xAA,0x06,0xAB,0x07,0xC3,0xE4,
+0x9B,0xFB,0xE4,0x9A,0xFA,0x78,0x17,0xF6,
+0xAF,0x03,0xEF,0x08,0xF6,0x18,0xE6,0xF5,
+0x8C,0x08,0xE6,0xF5,0x8A,0x74,0x0D,0x2B,
+0xFB,0xE4,0x3A,0x18,0xF6,0xAF,0x03,0xEF,
+0x08,0xF6,0x75,0x88,0x10,0x53,0x8E,0xC7,
+0xD2,0xA9,0x22,0x7D,0x02,0x7C,0x00,0x7F,
+0x4A,0x7E,0x13,0x12,0x04,0x6B,0x7D,0x46,
+0x7C,0x71,0x7F,0x02,0x7E,0x66,0x12,0x04,
+0x6B,0x7D,0x03,0x7C,0x00,0x7F,0x01,0x7E,
+0x66,0x12,0x04,0x6B,0x7D,0xC0,0x7C,0x00,
+0x7F,0x00,0x7E,0x66,0x12,0x04,0x6B,0xE4,
+0xFF,0xFE,0x0F,0xBF,0x00,0x01,0x0E,0xEF,
+0x64,0x64,0x4E,0x70,0xF5,0x7D,0x04,0x7C,
+0x00,0x7F,0x02,0x7E,0x66,0x12,0x04,0x6B,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x04,0x6B,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x04,0x6B,0xE4,0xFD,
+0xFC,0x7F,0x02,0x7E,0x66,0x12,0x04,0x6B,
+0x7D,0x00,0x7C,0x04,0x7F,0x01,0x7E,0x66,
+0x12,0x04,0x6B,0x7D,0xC0,0x7C,0x00,0x7F,
+0x00,0x7E,0x66,0x12,0x04,0x6B,0xE4,0xFD,
+0xFC,0x7F,0x4A,0x7E,0x13,0x12,0x04,0x6B,
+0x7D,0x06,0x7C,0x71,0x7F,0x02,0x7E,0x66,
+0x12,0x04,0x6B,0x7D,0x03,0x7C,0x00,0x7F,
+0x01,0x7E,0x66,0x12,0x04,0x6B,0x7D,0xC0,
+0x7C,0x00,0x7F,0x00,0x7E,0x66,0x02,0x04,
+0x6B,0x78,0x7F,0xE4,0xF6,0xD8,0xFD,0x75,
+0x81,0x3C,0x02,0x03,0xC8,0x02,0x01,0x27,
+0xE4,0x93,0xA3,0xF8,0xE4,0x93,0xA3,0x40,
+0x03,0xF6,0x80,0x01,0xF2,0x08,0xDF,0xF4,
+0x80,0x29,0xE4,0x93,0xA3,0xF8,0x54,0x07,
+0x24,0x0C,0xC8,0xC3,0x33,0xC4,0x54,0x0F,
+0x44,0x20,0xC8,0x83,0x40,0x04,0xF4,0x56,
+0x80,0x01,0x46,0xF6,0xDF,0xE4,0x80,0x0B,
+0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,
+0x90,0x04,0x87,0xE4,0x7E,0x01,0x93,0x60,
+0xBC,0xA3,0xFF,0x54,0x3F,0x30,0xE5,0x09,
+0x54,0x1F,0xFE,0xE4,0x93,0xA3,0x60,0x01,
+0x0E,0xCF,0x54,0xC0,0x25,0xE0,0x60,0xA8,
+0x40,0xB8,0xE4,0x93,0xA3,0xFA,0xE4,0x93,
+0xA3,0xF8,0xE4,0x93,0xA3,0xC8,0xC5,0x82,
+0xC8,0xCA,0xC5,0x83,0xCA,0xF0,0xA3,0xC8,
+0xC5,0x82,0xC8,0xCA,0xC5,0x83,0xCA,0xDF,
+0xE9,0xDE,0xE7,0x80,0xBE,0xC0,0xE0,0xC0,
+0xF0,0xC0,0x83,0xC0,0x82,0xC0,0xD0,0x75,
+0xD0,0x00,0xC0,0x00,0x78,0x17,0xE6,0xF5,
+0x8C,0x78,0x18,0xE6,0xF5,0x8A,0x90,0x06,
+0x2D,0xE4,0x75,0xF0,0x01,0x12,0x00,0x0E,
+0x90,0x06,0x2F,0xE4,0x75,0xF0,0x01,0x12,
+0x00,0x0E,0xD0,0x00,0xD0,0xD0,0xD0,0x82,
+0xD0,0x83,0xD0,0xF0,0xD0,0xE0,0x32,0xC2,
+0xAF,0xAD,0x07,0xAC,0x06,0x8C,0xA2,0x8D,
+0xA3,0x75,0xA0,0x01,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xAE,
+0xA1,0xBE,0x00,0xF0,0xAE,0xA6,0xAF,0xA7,
+0xD2,0xAF,0x22,0xC2,0xAF,0xAB,0x07,0xAA,
+0x06,0x8A,0xA2,0x8B,0xA3,0x8C,0xA4,0x8D,
+0xA5,0x75,0xA0,0x03,0x00,0x00,0x00,0xAA,
+0xA1,0xBA,0x00,0xF8,0xD2,0xAF,0x22,0x42,
+0x06,0x2F,0x00,0x00,0x42,0x06,0x2D,0x00,
+0x00,0x00,0x12,0x04,0x9B,0x12,0x02,0x16,
+0x02,0x00,0x03,0xE4,0xF5,0x8E,0x22,};
+
 /* Lifted from the vendor driver sources */
 static const struct rtl8365mb_jam_tbl_entry rtl8365mb_init_jam_8365mb_vc[] = {
 	{ 0x13EB, 0x15BB }, { 0x1303, 0x06D6 }, { 0x1304, 0x0700 },
@@ -621,6 +803,39 @@ static const struct rtl8365mb_jam_tbl_en
 	{ 0x1D32, 0x0002 },
 };
 
+struct rtl8365mb_sds_init {
+	unsigned int data;
+	unsigned int addr;
+};
+
+static const struct rtl8365mb_sds_init redData[] = {
+	{0x04D7, 0x0480}, {0xF994, 0x0481}, {0x21A2, 0x0482}, {0x6960, 0x0483},
+	{0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E}
+};
+
+static const struct rtl8365mb_sds_init redDataSB[] = {
+	{0x04D7, 0x0480}, {0xF994, 0x0481}, {0x31A2, 0x0482}, {0x6960, 0x0483},
+	{0x9728, 0x0484}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x83F2, 0x002E}
+};
+
+static const struct rtl8365mb_sds_init redData1_5_6[] = {
+	{0x82F1, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503},
+	{0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001},
+	{0x83F2, 0x002E}
+};
+
+static const struct rtl8365mb_sds_init redData8_9[] = {
+	{0x82F1, 0x0500}, {0xF995, 0x0501}, {0x31A2, 0x0502}, {0x796C, 0x0503},
+	{0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001},
+	{0x83F2, 0x002E}
+};
+
+static const struct rtl8365mb_sds_init redDataHB[] = {
+	{0x82F0, 0x0500}, {0xF195, 0x0501}, {0x31A2, 0x0502}, {0x7960, 0x0503},
+	{0x9728, 0x0504}, {0x9D85, 0x0423}, {0xD810, 0x0424}, {0x0F80, 0x0001},
+	{0x83F2, 0x002E}
+};
+
 enum rtl8365mb_phy_interface_mode {
 	RTL8365MB_PHY_INTERFACE_MODE_INVAL = 0,
 	RTL8365MB_PHY_INTERFACE_MODE_INTERNAL = BIT(0),
@@ -1572,6 +1787,243 @@ rtl8365mb_get_tag_protocol(struct dsa_sw
 	return DSA_TAG_PROTO_RTL8_4;
 }
 
+static int rtl8365mb_sds_indacs_write(struct realtek_priv *priv, unsigned int addr,
+				      unsigned int data)
+{
+	int ret;
+
+	ret = regmap_write(priv->map, RTL8365MB_SDS_INDACS_DATA, data);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->map, RTL8365MB_SDS_INDACS_ADR, addr);
+	if (ret)
+		return ret;
+
+	return regmap_write(priv->map, RTL8365MB_SDS_INDACS_CMD, 0x00C0);
+}
+
+static int rtl8365mb_sds_indacs_read(struct realtek_priv *priv, unsigned int addr,
+				     unsigned int *data)
+{
+	int ret;
+
+	ret = regmap_write(priv->map, RTL8365MB_SDS_INDACS_ADR, addr);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->map, RTL8365MB_SDS_INDACS_CMD, 0x00C0);
+	if (ret)
+		return ret;
+
+	return regmap_write(priv->map, RTL8365MB_SDS_INDACS_DATA, *data);
+}
+
+static int rtl8365mb_ext_init_sgmii_fw(struct realtek_priv *priv)
+{
+	int ret;
+	int i;
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_CHIP_RESET_REG,
+				 RTL8365MB_CHIP_RESET_DW8051,
+				 FIELD_PREP(RTL8365MB_CHIP_RESET_DW8051, 1));
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_MISC_CFG0,
+				 RTL8365MB_MISC_CFG0_DW8051_EN,
+				 FIELD_PREP(RTL8365MB_MISC_CFG0_DW8051_EN, 1));
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_DW8051_RDY,
+				 RTL8365MB_DW8051_RDY_ACS_IROM_EN,
+				 FIELD_PREP(RTL8365MB_DW8051_RDY_ACS_IROM_EN, 1));
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_DW8051_RDY,
+				 RTL8365MB_DW8051_RDY_IROM_MSB,
+				 FIELD_PREP(RTL8365MB_DW8051_RDY_IROM_MSB, 0));
+	if (ret)
+		return ret;
+
+	for (i = 0; i < sizeof(rtl8365mb_sgmii_init); i++) {
+		ret = regmap_write(priv->map, 0xE000 + i, rtl8365mb_sgmii_init[i]);
+		if (ret)
+			return ret;
+	}
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_DW8051_RDY,
+				 RTL8365MB_DW8051_RDY_IROM_MSB,
+				 FIELD_PREP(RTL8365MB_DW8051_RDY_IROM_MSB, 0));
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_DW8051_RDY,
+				 RTL8365MB_DW8051_RDY_ACS_IROM_EN,
+				 FIELD_PREP(RTL8365MB_DW8051_RDY_ACS_IROM_EN, 0));
+	if (ret)
+		return ret;
+
+	ret = regmap_update_bits(priv->map, RTL8365MB_CHIP_RESET_REG,
+				 RTL8365MB_CHIP_RESET_DW8051,
+				 FIELD_PREP(RTL8365MB_CHIP_RESET_DW8051, 0));
+
+	return ret;
+}
+
+static int rtl8365mb_get_chip_option(struct regmap *map, u32 *id)
+{
+	int ret;
+
+	ret = regmap_write(map, RTL8365MB_MAGIC_OPT_REG, RTL8365MB_MAGIC_VALUE);
+	if (ret)
+		return ret;
+
+	ret = regmap_read(map, RTL8365MB_CHIP_OPTION_REG, id);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(map, RTL8365MB_MAGIC_OPT_REG, 0);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int rtl8365mb_ext_init_sgmii(struct realtek_priv *priv, int port, phy_interface_t interface)
+{
+	struct rtl8365mb *mb;
+	int interface_mode;
+	int sds_mode;
+	const struct rtl8365mb_sds_init *sds_init;
+	const struct rtl8365mb_extint *extint;
+	size_t sds_init_len;
+	int ext_int;
+	int ret;
+	int i;
+	int val;
+	int mask;
+	u32 chip_option;
+
+	mb = priv->chip_data;
+
+	extint = rtl8365mb_get_port_extint(priv, port);
+	if (extint->id != 1)
+		return -EINVAL;
+
+	ret = rtl8365mb_get_chip_option(priv->map, &chip_option);
+	if (ret)
+		return ret;
+
+	if (interface == PHY_INTERFACE_MODE_SGMII) {
+		sds_mode = FIELD_PREP(RTL8365MB_CFG_MAC8_SEL_SGMII, 1);
+		interface_mode = RTL8365MB_EXT_PORT_MODE_SGMII;
+
+		if (chip_option == 0) {
+			sds_init = redData;
+			sds_init_len = ARRAY_SIZE(redData);
+		} else {
+			sds_init = redDataSB;
+			sds_init_len = ARRAY_SIZE(redDataSB);
+		}
+	} else if (interface == PHY_INTERFACE_MODE_2500BASEX) {
+		sds_mode = FIELD_PREP(RTL8365MB_CFG_MAC8_SEL_HSGMII, 1);
+		interface_mode = RTL8365MB_EXT_PORT_MODE_HSGMII;
+
+		if (chip_option == 0) {
+			switch (mb->chip_info->chip_ver & 0x00F0) {
+			case 0x0010:
+			case 0x0050:
+			case 0x0060:
+				sds_init = redData1_5_6;
+				sds_init_len = ARRAY_SIZE(redData1_5_6);
+				break;
+			case 0x0080:
+			case 0x0090:
+				sds_init = redData8_9;
+				sds_init_len = ARRAY_SIZE(redData8_9);
+				break;
+			default:
+				return -EINVAL;
+			}
+		} else {
+			sds_init = redDataHB;
+			sds_init_len = ARRAY_SIZE(redDataHB);
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	for (i = 0; i < sds_init_len; i++) {
+		ret = rtl8365mb_sds_indacs_write(priv, sds_init[i].addr, sds_init[i].data);
+		if (ret)
+			return ret;
+	}
+
+	mask = RTL8365MB_CFG_MAC8_SEL_SGMII | RTL8365MB_CFG_MAC8_SEL_HSGMII;
+	ret = regmap_update_bits(priv->map,
+				 RTL8365MB_SDS_MISC,
+				 mask,
+				 sds_mode);
+	if (ret)
+		return ret;
+
+	mask = RTL8365MB_DIGITAL_INTERFACE_SELECT_MODE_MASK(ext_int);
+	val = interface_mode << RTL8365MB_DIGITAL_INTERFACE_SELECT_MODE_OFFSET(ext_int);
+	ret = regmap_update_bits(priv->map,
+				 RTL8365MB_DIGITAL_INTERFACE_SELECT_REG(ext_int),
+				 mask,
+				 val);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->map, RTL8365MB_BYPASS_LINE_RATE, 0x0);
+	if (ret)
+		return ret;
+
+	/* Serdes not reset */
+	ret = rtl8365mb_sds_indacs_write(priv, 0x0003, 0x7106);
+	if (ret)
+		return ret;
+
+	return rtl8365mb_ext_init_sgmii_fw(priv);
+}
+
+static int rtl8365mb_ext_sgmii_nway(struct realtek_priv *priv, bool state)
+{
+	u32 running;
+	u32 regValue;
+	int ret;
+
+	ret = regmap_read(priv->map, RTL8365MB_MISC_CFG0, &running);
+	if (running & RTL8365MB_MISC_CFG0_DW8051_EN) {
+		ret = regmap_update_bits(priv->map, RTL8365MB_MISC_CFG0,
+					 RTL8365MB_MISC_CFG0_DW8051_EN,
+					 FIELD_PREP(RTL8365MB_MISC_CFG0_DW8051_EN, 0));
+		if (ret)
+			return ret;
+	}
+
+	ret = rtl8365mb_sds_indacs_read(priv, 0x0002, &regValue);
+	if (ret)
+		return ret;
+
+	if (state)
+		regValue |= 0x0200;
+	else
+		regValue &= ~0x0200;
+	regValue |= 0x0100;
+
+	ret = rtl8365mb_sds_indacs_write(priv, 0x0002, regValue);
+	if (ret)
+		return ret;
+	return regmap_update_bits(priv->map, RTL8365MB_MISC_CFG0,
+				  RTL8365MB_MISC_CFG0_DW8051_EN,
+				  FIELD_PREP(RTL8365MB_MISC_CFG0_DW8051_EN, 1));
+}
+
 static int rtl8365mb_ext_config_rgmii(struct realtek_priv *priv, int port,
 				      phy_interface_t interface)
 {
@@ -1673,6 +2125,7 @@ static int rtl8365mb_ext_config_rgmii(st
 }
 
 static int rtl8365mb_ext_config_forcemode(struct realtek_priv *priv, int port,
+					  phy_interface_t interface,
 					  bool link, int speed, int duplex,
 					  bool tx_pause, bool rx_pause)
 {
@@ -1696,8 +2149,8 @@ static int rtl8365mb_ext_config_forcemod
 		r_rx_pause = rx_pause ? 1 : 0;
 		r_tx_pause = tx_pause ? 1 : 0;
 
-		if (!mb->family_c && (speed == SPEED_2500)) {
-			r_speed = RTL8367D_PORT_SPEED_2500M;
+		if (speed == SPEED_2500) {
+			r_speed = mb->family_c ? RTL8365MB_PORT_SPEED_1000M : RTL8367D_PORT_SPEED_2500M;
 		} else if (speed == SPEED_1000) {
 			r_speed = RTL8365MB_PORT_SPEED_1000M;
 		} else if (speed == SPEED_100) {
@@ -1728,6 +2181,25 @@ static int rtl8365mb_ext_config_forcemod
 		r_duplex = 0;
 	}
 
+	if (interface == PHY_INTERFACE_MODE_SGMII ||
+	    interface == PHY_INTERFACE_MODE_2500BASEX) {
+		val = FIELD_PREP(RTL8365MB_CFG_SGMII_FDUP, r_duplex) |
+		      FIELD_PREP(RTL8365MB_CFG_SGMII_SPD, r_speed) |
+		      FIELD_PREP(RTL8365MB_CFG_SGMII_LINK, r_link) |
+		      FIELD_PREP(RTL8365MB_CFG_SGMII_TXFC, r_tx_pause) |
+		      FIELD_PREP(RTL8365MB_CFG_SGMII_RXFC, r_rx_pause);
+		ret = regmap_update_bits(priv->map,
+					 RTL8365MB_SDS_MISC,
+					 RTL8365MB_CFG_SGMII_FDUP |
+					 RTL8365MB_CFG_SGMII_SPD |
+					 RTL8365MB_CFG_SGMII_LINK |
+					 RTL8365MB_CFG_SGMII_TXFC |
+					 RTL8365MB_CFG_SGMII_RXFC,
+					 val);
+		if (ret)
+			return ret;
+	}
+
 	val = FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_TXPAUSE_MASK,
 			 r_tx_pause) |
 	      FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_RXPAUSE_MASK,
@@ -1790,6 +2262,14 @@ static void rtl8365mb_phylink_get_caps(s
 
 	if (extint->supported_interfaces & RTL8365MB_PHY_INTERFACE_MODE_RGMII)
 		phy_interface_set_rgmii(config->supported_interfaces);
+
+	if (extint->supported_interfaces & RTL8365MB_PHY_INTERFACE_MODE_SGMII)
+		__set_bit(PHY_INTERFACE_MODE_SGMII, config->supported_interfaces);
+
+	if (extint->supported_interfaces & RTL8365MB_PHY_INTERFACE_MODE_HSGMII) {
+		__set_bit(PHY_INTERFACE_MODE_2500BASEX, config->supported_interfaces);
+		config->mac_capabilities |= MAC_2500FD;
+	}
 }
 
 static void rtl8365mb_phylink_mac_config(struct phylink_config *config,
@@ -1815,6 +2295,10 @@ static void rtl8365mb_phylink_mac_config
 				"failed to configure RGMII mode on port %d: %d\n",
 				port, ret);
 		return;
+	} else if (state->interface == PHY_INTERFACE_MODE_SGMII ||
+		   state->interface == PHY_INTERFACE_MODE_2500BASEX) {
+		rtl8365mb_ext_init_sgmii(priv, port, state->interface);
+		rtl8365mb_ext_sgmii_nway(priv, false);
 	}
 
 	/* TODO: Implement MII and RMII modes, which the RTL8365MB-VC also
@@ -1836,8 +2320,11 @@ static void rtl8365mb_phylink_mac_link_d
 	p = &mb->ports[port];
 	cancel_delayed_work_sync(&p->mib_work);
 
-	if (phy_interface_mode_is_rgmii(interface)) {
-		ret = rtl8365mb_ext_config_forcemode(priv, port, false, 0, 0,
+	if (phy_interface_mode_is_rgmii(interface) ||
+	    interface == PHY_INTERFACE_MODE_SGMII ||
+	    interface == PHY_INTERFACE_MODE_2500BASEX) {
+		ret = rtl8365mb_ext_config_forcemode(priv, port, interface,
+						     false, 0, 0,
 						     false, false);
 		if (ret)
 			dev_err(priv->dev,
@@ -1865,8 +2352,11 @@ static void rtl8365mb_phylink_mac_link_u
 	p = &mb->ports[port];
 	schedule_delayed_work(&p->mib_work, 0);
 
-	if (phy_interface_mode_is_rgmii(interface)) {
-		ret = rtl8365mb_ext_config_forcemode(priv, port, true, speed,
+	if (phy_interface_mode_is_rgmii(interface) ||
+	    interface == PHY_INTERFACE_MODE_SGMII ||
+	    interface == PHY_INTERFACE_MODE_2500BASEX) {
+		ret = rtl8365mb_ext_config_forcemode(priv, port, interface,
+						     true, speed,
 						     duplex, tx_pause,
 						     rx_pause);
 		if (ret)
