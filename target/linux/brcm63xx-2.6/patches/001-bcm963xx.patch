diff -urN linux.old/arch/mips/bcm963xx/bcm63xx_led.c linux.dev/arch/mips/bcm963xx/bcm63xx_led.c
--- linux.old/arch/mips/bcm963xx/bcm63xx_led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/bcm63xx_led.c	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,582 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***************************************************************************
+ * File Name  : bcm63xx_led.c
+ *
+ * Description: 
+ *
+ *    This file contains bcm963xx board led control API functions. 
+ *
+ *    To use it, do the following
+ *
+ *    1). define in the board.c the following led mappping (this is for 6345GW board):
+ *        const LED_MAP_PAIR cLedMapping45GW[] =
+ *        {   // led name     Initial state       physical pin (ledMask)
+ *            {kLedUsb,       kLedStateOff,       GPIO_LED_PIN_7}, 
+ *            {kLedAdsl,      kLedStateOff,       GPIO_LED_PIN_8},
+ *            {kLedPPP,       kLedStateOff,       GPIO_LED_PIN_9},    // PPP and WanData share PIN_9
+ *            {kLedWanData,   kLedStateOff,       GPIO_LED_PIN_9},
+ *            {kLedWireless,  kLedStateOff,       GPIO_LED_PIN_10},
+ *            {kLedEnd,       kLedStateOff,       0              } // NOTE: kLedEnd has to be at the end.
+ *
+ *    2). };To initialize led API and initial state of the leds, call the following function with the mapping 
+ *        pointer from the above struct
+ *
+ *        boardLedInit((PLED_MAP_PAIR) &cLedMapping45R);
+ *
+ *    3). Sample call for kernel mode:
+ *
+ *        kerSysLedCtrl(kLedAdsl, kLedStateBlinkOnce);        // kLedxxx defines in board.h
+ *
+ *    4). Sample call for user mode
+ *
+ *        sysLedCtrl(kLedAdsl, kLedStateBlinkOnce);           // kLedxxx defines in board_api.h
+ *
+ *
+ * Created on :  10/28/2002  seanl
+ *
+ ***************************************************************************/
+
+/* Includes. */
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <asm/uaccess.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+
+#define k100ms              (HZ / 10)     // ~100 ms
+#define kFastBlinkCount     0             // ~100ms
+#define kSlowBlinkCount     5             // ~600ms
+
+#define MAX_VIRT_LEDS       12
+
+// uncomment // for debug led
+//#define DEBUG_LED
+
+// global variables:
+struct timer_list gLedTimer;
+int gTimerOn = FALSE;
+int gLedCount = 0;
+
+typedef struct ledinfo
+{
+    unsigned short ledMask;         // mask for led: ie. giop 10 = 0x0400
+    unsigned short ledActiveLow;    // GPIO bit reset to turn on LED
+    unsigned short ledMaskFail;     // mask for led: ie. giop 10 = 0x0400
+    unsigned short ledActiveLowFail;// GPIO bit reset to turn on LED
+    BOARD_LED_STATE ledState;       // current led state
+    BOARD_LED_STATE savedLedState;  // used in blink once for restore to the orignal ledState
+    int blinkCountDown;             // if == 0, do blink (toggle).  Is assgined value and dec by 1 at each timer.
+} LED_INFO, *PLED_INFO;
+
+static PLED_INFO gLed = NULL;
+static PLED_INFO gpVirtLeds[MAX_VIRT_LEDS];
+static HANDLE_LED_FUNC gLedHwFunc[MAX_VIRT_LEDS];
+static HANDLE_LED_FUNC gLedHwFailFunc[MAX_VIRT_LEDS];
+
+#if 0 /* BROKEN */
+#if defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+static int gLedOffInBridgeMode = 1;
+#elif defined(CONFIG_BCM96345)
+static int gLedOffInBridgeMode = 0;
+#endif
+#endif
+
+void ledTimerExpire(void);
+int initLedInfo( PLED_MAP_PAIR pCurMap, PLED_INFO pCurLed );
+
+//**************************************************************************************
+// LED operations
+//**************************************************************************************
+
+// turn led on and set the ledState
+void ledOn(PLED_INFO pLed)
+{
+    if( pLed->ledMask )
+    {
+        GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLow )
+            GPIO->GPIOio  &= ~pLed->ledMask;    // turn on the led
+        else
+            GPIO->GPIOio  |= pLed->ledMask;     // turn on the led
+        pLed->ledState = pLed->savedLedState = kLedStateOn;
+    }
+}
+
+
+// turn led off and set the ledState
+void ledOff(PLED_INFO pLed)
+{
+    if( pLed->ledMask )
+    {
+        GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLow )
+            GPIO->GPIOio  |= pLed->ledMask;     // turn off the led
+        else
+            GPIO->GPIOio  &= ~pLed->ledMask;    // turn off the led
+        pLed->ledState = pLed->savedLedState = kLedStateOff;
+    }
+}
+
+// turn led on and set the ledState
+void ledOnFail(PLED_INFO pLed)
+{
+    if( pLed->ledMaskFail )
+    {
+        GPIO->GPIODir |= pLed->ledMaskFail;     // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLowFail )
+            GPIO->GPIOio  &= ~pLed->ledMaskFail;// turn on the led
+        else
+            GPIO->GPIOio  |= pLed->ledMaskFail; // turn on the led
+        pLed->ledState = pLed->savedLedState = kLedStateFail;
+    }
+}
+
+
+// turn led off and set the ledState
+void ledOffFail(PLED_INFO pLed)
+{
+    if( pLed->ledMaskFail )
+    {
+        GPIO->GPIODir |= pLed->ledMaskFail;     // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLowFail )
+            GPIO->GPIOio  |= pLed->ledMaskFail; // turn off the led
+        else
+            GPIO->GPIOio  &= ~pLed->ledMaskFail;// turn off the led
+        pLed->ledState = pLed->savedLedState = kLedStateOff;
+    }
+}
+
+
+// toggle the led and return the current ledState
+BOARD_LED_STATE ledToggle(PLED_INFO pLed)
+{
+    GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+    if (GPIO->GPIOio & pLed->ledMask)
+    {
+        GPIO->GPIOio &= ~(pLed->ledMask);
+        return( (pLed->ledActiveLow) ? kLedStateOn : kLedStateOff );
+    }
+    else
+    {
+        GPIO->GPIOio |= pLed->ledMask;
+        return( (pLed->ledActiveLow) ? kLedStateOff : kLedStateOn );
+    }
+}   
+
+
+// led timer.  Will return if timer is already on
+void ledTimerStart(void)
+{
+    if (gTimerOn)
+        return;
+
+#if defined(DEBUG_LED)
+    printk("led: add_timer\n");
+#endif
+
+    init_timer(&gLedTimer);
+    gLedTimer.function = (void*)ledTimerExpire;
+    gLedTimer.expires = jiffies + k100ms;        // timer expires in ~100ms
+    add_timer (&gLedTimer);
+    gTimerOn = TRUE;
+} 
+
+
+// led timer expire kicks in about ~100ms and perform the led operation according to the ledState and
+// restart the timer according to ledState
+void ledTimerExpire(void)
+{
+    int i;
+    PLED_INFO pCurLed;
+
+    gTimerOn = FALSE;
+
+    for (i = 0, pCurLed = gLed; i < gLedCount; i++, pCurLed++)
+    {
+#if defined(DEBUG_LED)
+        printk("led[%d]: Mask=0x%04x, State = %d, blcd=%d\n", i, pCurLed->ledMask, pCurLed->ledState, pCurLed->blinkCountDown);
+#endif
+        switch (pCurLed->ledState)
+        {
+            case kLedStateOn:
+            case kLedStateOff:
+            case kLedStateFail:
+                pCurLed->blinkCountDown = 0;            // reset the blink count down
+                break;
+
+            case kLedStateBlinkOnce:
+                ledToggle(pCurLed);
+                pCurLed->blinkCountDown = 0;                      // reset to 0
+                pCurLed->ledState = pCurLed->savedLedState;
+                if (pCurLed->ledState == kLedStateSlowBlinkContinues || 
+                    pCurLed->ledState == kLedStateFastBlinkContinues)
+                    ledTimerStart();                  // start timer if in blinkContinues stats
+                break;
+
+            case kLedStateSlowBlinkContinues:
+                if (pCurLed->blinkCountDown-- == 0)
+                {
+                    pCurLed->blinkCountDown = kSlowBlinkCount;
+                    ledToggle(pCurLed);
+                }
+                ledTimerStart();
+                break;
+
+            case kLedStateFastBlinkContinues:
+                if (pCurLed->blinkCountDown-- == 0)
+                {
+                    pCurLed->blinkCountDown = kFastBlinkCount;
+                    ledToggle(pCurLed);
+                }
+                ledTimerStart();
+                break;
+
+            default:
+                printk("Invalid state = %d\n", pCurLed->ledState);
+        }
+    }
+}
+
+// initialize the gLedCount and allocate and fill gLed struct
+void __init boardLedInit(PLED_MAP_PAIR cLedMapping)
+{
+    PLED_MAP_PAIR p1, p2;
+    PLED_INFO pCurLed;
+    int needTimer = FALSE;
+    int alreadyUsed = 0;
+
+#if defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+    /* Set blink rate for BCM6348/BCM6338 hardware LEDs. */
+    GPIO->LEDCtrl &= ~LED_INTERVAL_SET_MASK;
+    GPIO->LEDCtrl |= LED_INTERVAL_SET_80MS;
+#endif
+
+    memset( gpVirtLeds, 0x00, sizeof(gpVirtLeds) );
+    memset( gLedHwFunc, 0x00, sizeof(gLedHwFunc) );
+    memset( gLedHwFailFunc, 0x00, sizeof(gLedHwFailFunc) );
+
+    gLedCount = 0;
+
+    // Check for multiple LED names and multiple LED GPIO pins that share the
+    // same physical board LED.
+    for( p1 = cLedMapping; p1->ledName != kLedEnd; p1++ )
+    {
+        alreadyUsed = 0;
+        for( p2 = cLedMapping; p2 != p1; p2++ )
+        {
+            if( (p1->ledMask && p1->ledMask == p2->ledMask) ||
+                (p1->ledMaskFail && p1->ledMaskFail == p2->ledMaskFail) )
+            {
+                alreadyUsed = 1;
+                break;
+            }
+        }
+
+        if( alreadyUsed == 0  )
+            gLedCount++;
+    }
+
+    gLed = (PLED_INFO) kmalloc((gLedCount * sizeof(LED_INFO)), GFP_KERNEL);
+    if( gLed == NULL )
+    {
+        printk( "LED memory allocation error.\n" );
+        return;
+    }
+
+    memset( gLed, 0x00, gLedCount * sizeof(LED_INFO) );
+
+    // initial the gLed with unique ledMask and initial state. If more than 1 ledNames share the physical led 
+    // (ledMask) the first defined led's ledInitState will be used.
+    pCurLed = gLed;
+    for( p1 = cLedMapping; p1->ledName != kLedEnd; p1++ )
+    {
+        if( (int) p1->ledName > MAX_VIRT_LEDS )
+            continue;
+
+        alreadyUsed = 0;
+        for( p2 = cLedMapping; p2 != p1; p2++ )
+        {
+            if( (p1->ledMask && p1->ledMask == p2->ledMask) ||
+                (p1->ledMaskFail && p1->ledMaskFail == p2->ledMaskFail) )
+            {
+                alreadyUsed = 1;
+                break;
+            }
+        }
+
+        if( alreadyUsed == 0 )
+        {
+            // Initialize the board LED for the first time.
+            needTimer = initLedInfo( p1, pCurLed );
+            gpVirtLeds[(int) p1->ledName] = pCurLed;
+            pCurLed++;
+        }
+        else
+        {
+            PLED_INFO pLed;
+            for( pLed = gLed; pLed != pCurLed; pLed++ )
+            {
+                // Find the LED_INFO structure that has already been initialized.
+                if((pLed->ledMask && pLed->ledMask == p1->ledMask) ||
+                   (pLed->ledMaskFail && pLed->ledMaskFail==p1->ledMaskFail))
+                {
+                    // The board LED has already been initialized but possibly
+                    // not completely initialized.
+                    if( p1->ledMask )
+                    {
+                        pLed->ledMask = p1->ledMask;
+                        pLed->ledActiveLow = p1->ledActiveLow;
+                    }
+                    if( p1->ledMaskFail )
+                    {
+                        pLed->ledMaskFail = p1->ledMaskFail;
+                        pLed->ledActiveLowFail = p1->ledActiveLowFail;
+                    }
+                    gpVirtLeds[(int) p1->ledName] = pLed;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (needTimer)
+        ledTimerStart();
+
+#if defined(DEBUG_LED)
+    int i;
+    for (i=0; i < gLedCount; i++)
+        printk("initLed: led[%d]: mask=0x%04x, state=%d\n", i,(gLed+i)->ledMask, (gLed+i)->ledState);
+#endif
+
+}
+
+// Initialize a structure that contains information about a physical board LED
+// control.  The board LED may contain more than one GPIO pin to control a
+// normal condition (green) or a failure condition (red).
+int initLedInfo( PLED_MAP_PAIR pCurMap, PLED_INFO pCurLed )
+{
+    int needTimer = FALSE;
+    pCurLed->ledState = pCurLed->savedLedState = pCurMap->ledInitState;
+    pCurLed->ledMask = pCurMap->ledMask;
+    pCurLed->ledActiveLow = pCurMap->ledActiveLow;
+    pCurLed->ledMaskFail = pCurMap->ledMaskFail;
+    pCurLed->ledActiveLowFail = pCurMap->ledActiveLowFail;
+
+    switch (pCurLed->ledState)
+    {
+        case kLedStateOn:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOn(pCurLed);
+            break;
+        case kLedStateOff:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOff(pCurLed);
+            break;
+        case kLedStateFail:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOnFail(pCurLed);
+            break;
+        case kLedStateBlinkOnce:
+            pCurLed->blinkCountDown = 1;
+            needTimer = TRUE;
+            break;
+        case kLedStateSlowBlinkContinues:
+            pCurLed->blinkCountDown = kSlowBlinkCount;
+            needTimer = TRUE;
+            break;
+        case kLedStateFastBlinkContinues:
+            pCurLed->blinkCountDown = kFastBlinkCount;
+            needTimer = TRUE;
+            break;
+        default:
+            printk("Invalid state = %d\n", pCurLed->ledState);
+    }
+
+    return( needTimer );
+}
+
+#if 0 /* BROKEN */
+// Determines if there is at least one interface in bridge mode.  Bridge mode
+// is determined by the cfm convention of naming bridge interfaces nas17
+// through nas24.
+static int isBridgedProtocol(void)
+{
+    extern int dev_get(const char *name);
+    const int firstBridgeId = 17;
+    const int lastBridgeId = 24;
+    int i;
+    int ret = FALSE;
+    char name[16];
+
+    for( i = firstBridgeId; i <= lastBridgeId; i++ )
+    {
+        sprintf( name, "nas%d", i );
+
+        if( dev_get(name) )
+        {
+            ret = TRUE;
+            break;
+        }
+    }
+
+    return(ret);
+}
+#endif
+
+// led ctrl.  Maps the ledName to the corresponding ledInfoPtr and perform the led operation
+void boardLedCtrl(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState)
+{
+    PLED_INFO ledInfoPtr;
+
+    // do the mapping from virtual to physical led
+    if( (int) ledName < MAX_VIRT_LEDS )
+        ledInfoPtr = gpVirtLeds[(int) ledName];
+    else
+        ledInfoPtr = NULL;
+
+    if (ledInfoPtr == NULL)
+        return;
+
+    if( ledState != kLedStateFail && gLedHwFunc[(int) ledName] )
+    {
+        (*gLedHwFunc[(int) ledName]) (ledName, ledState);
+        ledOffFail(ledInfoPtr);
+        return;
+    }
+    else
+        if( ledState == kLedStateFail && gLedHwFailFunc[(int) ledName] )
+        {
+            (*gLedHwFailFunc[(int) ledName]) (ledName, ledState);
+            ledOff(ledInfoPtr);
+            return;
+        }
+
+#if 0 /* BROKEN */
+    // Do not blink the WAN Data LED if at least one interface is in bridge mode.
+    if(gLedOffInBridgeMode == 1 && (ledName == kLedWanData || ledName == kLedPPP))
+    {
+        static int BridgedProtocol = -1;
+
+        if( BridgedProtocol == -1 )
+            BridgedProtocol = isBridgedProtocol();
+
+        if( BridgedProtocol == TRUE )
+            return;
+    }
+#endif
+
+    // If the state is kLedStateFail and there is not a failure LED defined
+    // in the board parameters, change the state to kLedStateFastBlinkContinues.
+    if( ledState == kLedStateFail && ledInfoPtr->ledMaskFail == 0 )
+        ledState = kLedStateFastBlinkContinues;
+
+    switch (ledState)
+    {
+        case kLedStateOn:
+            // First, turn off the complimentary (failure) LED GPIO.
+            if( ledInfoPtr->ledMaskFail )
+                ledOffFail(ledInfoPtr);
+            else
+                if( gLedHwFailFunc[(int) ledName] )
+                    (*gLedHwFailFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn on the specified LED GPIO.
+            ledOn(ledInfoPtr);
+            break;
+
+        case kLedStateOff: 
+            // First, turn off the complimentary (failure) LED GPIO.
+            if( ledInfoPtr->ledMaskFail )
+                ledOffFail(ledInfoPtr);
+            else
+                if( gLedHwFailFunc[(int) ledName] )
+                    (*gLedHwFailFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn off the specified LED GPIO.
+            ledOff(ledInfoPtr);
+            break;
+
+        case kLedStateFail:
+            // First, turn off the complimentary (normal) LED GPIO.
+            if( ledInfoPtr->ledMask )
+                ledOff(ledInfoPtr);
+            else
+                if( gLedHwFunc[(int) ledName] )
+                    (*gLedHwFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn on (red) the specified LED GPIO.
+            ledOnFail(ledInfoPtr);
+            break;
+
+        case kLedStateBlinkOnce:
+            // skip blinkOnce if it is already in Slow/Fast blink continues state
+            if (ledInfoPtr->savedLedState == kLedStateSlowBlinkContinues ||
+                ledInfoPtr->savedLedState == kLedStateFastBlinkContinues)
+                ;
+            else
+            {
+                if (ledInfoPtr->blinkCountDown == 0)  // skip the call if it is 1
+                {
+                    ledToggle(ledInfoPtr);
+                    ledInfoPtr->blinkCountDown = 1;  // it will be reset to 0 when timer expires
+                    ledInfoPtr->ledState = kLedStateBlinkOnce;
+                    ledTimerStart();
+                }
+            }
+            break;
+
+        case kLedStateSlowBlinkContinues:
+            ledInfoPtr->blinkCountDown = kSlowBlinkCount;
+            ledInfoPtr->ledState = kLedStateSlowBlinkContinues;
+            ledInfoPtr->savedLedState = kLedStateSlowBlinkContinues;
+            ledTimerStart();
+            break;
+
+        case kLedStateFastBlinkContinues:
+            ledInfoPtr->blinkCountDown = kFastBlinkCount;
+            ledInfoPtr->ledState = kLedStateFastBlinkContinues;
+            ledInfoPtr->savedLedState = kLedStateFastBlinkContinues;
+            ledTimerStart();
+            break;
+
+        default:
+            printk("Invalid led state\n");
+    }
+}
+
+// This function is called for an LED that is controlled by hardware.
+void kerSysLedRegisterHwHandler( BOARD_LED_NAME ledName,
+    HANDLE_LED_FUNC ledHwFunc, int ledFailType )
+{
+    if( (int) ledName < MAX_VIRT_LEDS )
+    {
+        if( ledFailType == 1 )
+            gLedHwFailFunc[(int) ledName] = ledHwFunc;
+        else
+            gLedHwFunc[(int) ledName] = ledHwFunc;
+    }
+}
+
diff -urN linux.old/arch/mips/bcm963xx/board.c linux.dev/arch/mips/bcm963xx/board.c
--- linux.old/arch/mips/bcm963xx/board.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/board.c	2006-08-27 21:02:04.000000000 +0200
@@ -0,0 +1,559 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+/* Includes. */
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/if.h>
+#include <linux/spinlock.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#include <bcmTag.h>
+#include "boardparms.h"
+#include "bcm_intr.h"
+#include "board.h"
+#include "bcm_map_part.h"
+
+static DEFINE_SPINLOCK(board_lock);
+
+/* Typedefs. */
+#if defined (NON_CONSECUTIVE_MAC)
+// used to be the last octet. Now changed to the first 5 bits of the the forth octet
+// to reduced the duplicated MAC addresses.
+#define CHANGED_OCTET   3
+#define SHIFT_BITS      3
+#else
+#define CHANGED_OCTET   1
+#define SHIFT_BITS      0
+#endif
+
+typedef struct
+{
+    unsigned long ulId;
+    char chInUse;
+    char chReserved[3];
+} MAC_ADDR_INFO, *PMAC_ADDR_INFO;
+
+typedef struct
+{
+    unsigned long ulSdramSize;
+    unsigned long ulPsiSize;
+    unsigned long ulNumMacAddrs;
+    unsigned long ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    MAC_ADDR_INFO MacAddrs[1];
+} NVRAM_INFO, *PNVRAM_INFO;
+
+typedef struct
+{
+    unsigned long eventmask;    
+} BOARD_IOC, *PBOARD_IOC;
+
+
+/*Dyinggasp callback*/
+typedef void (*cb_dgasp_t)(void *arg);
+typedef struct _CB_DGASP__LIST
+{
+    struct list_head list;
+    char name[IFNAMSIZ];
+    cb_dgasp_t cb_dgasp_fn;
+    void *context;
+}CB_DGASP_LIST , *PCB_DGASP_LIST;
+
+
+static LED_MAP_PAIR LedMapping[] =
+{   // led name     Initial state       physical pin (ledMask)
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0}, 
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0}, 
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},     
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0} // NOTE: kLedEnd has to be at the end.
+};
+
+/* Externs. */
+extern struct file fastcall *fget_light(unsigned int fd, int *fput_needed);
+extern unsigned int nr_free_pages (void);
+extern const char *get_system_type(void);
+extern void kerSysFlashInit(void);
+extern unsigned long get_nvram_start_addr(void);
+extern unsigned long get_scratch_pad_start_addr(void);
+extern unsigned long getMemorySize(void);
+extern void __init boardLedInit(PLED_MAP_PAIR);
+extern void boardLedCtrl(BOARD_LED_NAME, BOARD_LED_STATE);
+extern void kerSysLedRegisterHandler( BOARD_LED_NAME ledName,
+    HANDLE_LED_FUNC ledHwFunc, int ledFailType );
+
+/* Prototypes. */
+void __init InitNvramInfo( void );
+
+/* DyingGasp function prototype */
+static void __init kerSysDyingGaspMapIntr(void);
+static irqreturn_t kerSysDyingGaspIsr(int irq, void * dev_id);
+static void __init kerSysInitDyingGaspHandler( void );
+static void __exit kerSysDeinitDyingGaspHandler( void );
+/* -DyingGasp function prototype - */
+
+static PNVRAM_INFO g_pNvramInfo = NULL;
+static int g_ledInitialized = 0;
+static CB_DGASP_LIST *g_cb_dgasp_list_head = NULL;
+
+static int g_wakeup_monitor = 0;
+static struct file *g_monitor_file = NULL;
+static struct task_struct *g_monitor_task = NULL;
+static unsigned int (*g_orig_fop_poll)
+    (struct file *, struct poll_table_struct *) = NULL;
+
+void kerSysMipsSoftReset(void)
+{
+    if (PERF->RevID == 0x634800A1) {
+        typedef void (*FNPTR) (void);
+        FNPTR bootaddr = (FNPTR) FLASH_BASE;
+        int i;
+
+        /* Disable interrupts. */
+        //cli();
+	spin_lock_irq(&board_lock);
+	
+        /* Reset all blocks. */
+        PERF->BlockSoftReset &= ~BSR_ALL_BLOCKS;
+        for( i = 0; i < 1000000; i++ )
+            ;
+        PERF->BlockSoftReset |= BSR_ALL_BLOCKS;
+        /* Jump to the power on address. */
+        (*bootaddr) ();
+    }
+    else
+        PERF->pll_control |= SOFT_RESET;    // soft reset mips
+}
+
+
+int kerSysGetMacAddress( unsigned char *pucaMacAddr, unsigned long ulId )
+{
+    int nRet = 0;
+    PMAC_ADDR_INFO pMai = NULL;
+    PMAC_ADDR_INFO pMaiFreeNoId = NULL;
+    PMAC_ADDR_INFO pMaiFreeId = NULL;
+    unsigned long i = 0, ulIdxNoId = 0, ulIdxId = 0, shiftedIdx = 0;
+
+    /* CMO -- Fix le problème avec les adresses mac que l'on n'arrive pas
+     *  * à relire plusieurs fois */
+    /* inv_xde */
+#if 0
+    if (boot_loader_type == BOOT_CFE)
+      memcpy( pucaMacAddr, g_pNvramInfo->ucaBaseMacAddr,
+              NVRAM_MAC_ADDRESS_LEN );
+    else {
+#endif
+      pucaMacAddr[0] = 0x00;
+      pucaMacAddr[1] = 0x07;
+      pucaMacAddr[2] = 0x3A;
+      pucaMacAddr[3] = 0xFF;
+      pucaMacAddr[4] = 0xFF;
+      pucaMacAddr[5] = 0xFF;
+#if 0
+    }
+#endif
+
+    return nRet;
+} /* kerSysGetMacAddr */
+
+int kerSysReleaseMacAddress( unsigned char *pucaMacAddr )
+{
+    int nRet = -EINVAL;
+    unsigned long ulIdx = 0;
+    int idx = (pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] -
+        g_pNvramInfo->ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET]);
+
+    // if overflow 255 (negitive), add 256 to have the correct index
+    if (idx < 0)
+        idx += 256;
+    ulIdx = (unsigned long) (idx >> SHIFT_BITS);
+
+    if( ulIdx < g_pNvramInfo->ulNumMacAddrs )
+    {
+        PMAC_ADDR_INFO pMai = &g_pNvramInfo->MacAddrs[ulIdx];
+        if( pMai->chInUse == 1 )
+        {
+            pMai->chInUse = 0;
+            nRet = 0;
+        }
+    }
+
+    return( nRet );
+} /* kerSysReleaseMacAddr */
+
+int kerSysGetSdramSize( void )
+{
+  if (boot_loader_type == BOOT_CFE) {
+    return( (int) g_pNvramInfo->ulSdramSize );
+  }
+  else {
+    printk("kerSysGetSdramSize : 0x%08X\n", (int)getMemorySize() + 0x00040000);
+    return((int)getMemorySize() + 0x00040000);
+  }
+} /* kerSysGetSdramSize */
+
+
+void kerSysLedCtrl(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState)
+{
+    if (g_ledInitialized)
+      boardLedCtrl(ledName, ledState);
+}
+
+unsigned int kerSysMonitorPollHook( struct file *f, struct poll_table_struct *t)
+{
+    int mask = (*g_orig_fop_poll) (f, t);
+
+    if( g_wakeup_monitor == 1 && g_monitor_file == f )
+    {
+        /* If g_wakeup_monitor is non-0, the user mode application needs to
+         * return from a blocking select function.  Return POLLPRI which will
+         * cause the select to return with the exception descriptor set.
+         */
+        mask |= POLLPRI;
+        g_wakeup_monitor = 0;
+    }
+
+    return( mask );
+}
+
+/* Put the user mode application that monitors link state on a run queue. */
+void kerSysWakeupMonitorTask( void )
+{
+    g_wakeup_monitor = 1;
+    if( g_monitor_task )
+        wake_up_process( g_monitor_task );
+}
+
+//<<JUNHON, 2004/09/15, get reset button status , tim hou , 05/04/12
+int kerSysGetResetHold(void)
+{
+	unsigned short gpio;
+
+	if( BpGetPressAndHoldResetGpio( &gpio ) == BP_SUCCESS )
+	{
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+
+    if( (gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+	//printk("gpio=%04x,gpio_mask=%04x,gpio_reg=%04x\n",gpio,gpio_mask,*gpio_reg);
+	if(*gpio_reg & gpio_mask)  //press down
+		return RESET_BUTTON_UP;
+	}
+	return RESET_BUTTON_PRESSDOWN;
+}
+//<<JUNHON, 2004/09/15
+
+/***************************************************************************
+ * Dying gasp ISR and functions.
+ ***************************************************************************/
+#define KERSYS_DBG	printk
+
+#if defined(CONFIG_BCM96345)
+#define	CYCLE_PER_US	70
+#elif defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+/* The BCM6348 cycles per microsecond is really variable since the BCM6348
+ * MIPS speed can vary depending on the PLL settings.  However, an appoximate
+ * value of 120 will still work OK for the test being done.
+ */
+#define	CYCLE_PER_US	120
+#endif
+#define	DG_GLITCH_TO	(100*CYCLE_PER_US)
+ 
+static void __init kerSysDyingGaspMapIntr()
+{
+    unsigned long ulIntr;
+    	
+#if defined(CONFIG_BCM96348) || defined(_BCM96348_) || defined(CONFIG_BCM96338) || defined(_BCM96338_)
+    if( BpGetAdslDyingGaspExtIntr( &ulIntr ) == BP_SUCCESS ) {
+		BcmHalMapInterrupt((FN_HANDLER)kerSysDyingGaspIsr, 0, INTERRUPT_ID_DG);
+		BcmHalInterruptEnable( INTERRUPT_ID_DG );
+    }
+#elif defined(CONFIG_BCM96345) || defined(_BCM96345_)
+    if( BpGetAdslDyingGaspExtIntr( &ulIntr ) == BP_SUCCESS ) {
+        ulIntr += INTERRUPT_ID_EXTERNAL_0;
+        BcmHalMapInterrupt((FN_HANDLER)kerSysDyingGaspIsr, 0, ulIntr);
+        BcmHalInterruptEnable( ulIntr );
+    }
+#endif
+
+} 
+
+void kerSysSetWdTimer(ulong timeUs)
+{
+	TIMER->WatchDogDefCount = timeUs * (FPERIPH/1000000);
+	TIMER->WatchDogCtl = 0xFF00;
+	TIMER->WatchDogCtl = 0x00FF;
+}
+
+ulong kerSysGetCycleCount(void)
+{
+    ulong cnt; 
+#ifdef _WIN32_WCE
+    cnt = 0;
+#else
+    __asm volatile("mfc0 %0, $9":"=d"(cnt));
+#endif
+    return(cnt); 
+}
+
+static Bool kerSysDyingGaspCheckPowerLoss(void)
+{
+    ulong clk0;
+    ulong ulIntr;
+
+    ulIntr = 0;
+    clk0 = kerSysGetCycleCount();
+
+    UART->Data = 'D';
+    UART->Data = '%';
+    UART->Data = 'G';
+
+#if defined(CONFIG_BCM96345)
+    BpGetAdslDyingGaspExtIntr( &ulIntr );
+
+    do {
+        ulong clk1;
+        
+        clk1 = kerSysGetCycleCount();		/* time cleared */
+	/* wait a little to get new reading */
+        while ((kerSysGetCycleCount()-clk1) < CYCLE_PER_US*2)
+            ;
+    } while ((0 == (PERF->ExtIrqCfg & (1 << (ulIntr + EI_STATUS_SHFT)))) && ((kerSysGetCycleCount() - clk0) < DG_GLITCH_TO));
+
+    if (PERF->ExtIrqCfg & (1 << (ulIntr + EI_STATUS_SHFT))) {	/* power glitch */
+        BcmHalInterruptEnable( ulIntr + INTERRUPT_ID_EXTERNAL_0);
+        KERSYS_DBG(" - Power glitch detected. Duration: %ld us\n", (kerSysGetCycleCount() - clk0)/CYCLE_PER_US);
+        return 0;
+    }
+#elif (defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)) && !defined(VXWORKS)
+    do {
+        ulong clk1;
+        
+        clk1 = kerSysGetCycleCount();		/* time cleared */
+	/* wait a little to get new reading */
+        while ((kerSysGetCycleCount()-clk1) < CYCLE_PER_US*2)
+            ;
+     } while ((PERF->IrqStatus & (1 << (INTERRUPT_ID_DG - INTERNAL_ISR_TABLE_OFFSET))) && ((kerSysGetCycleCount() - clk0) < DG_GLITCH_TO));
+
+    if (!(PERF->IrqStatus & (1 << (INTERRUPT_ID_DG - INTERNAL_ISR_TABLE_OFFSET)))) {
+        BcmHalInterruptEnable( INTERRUPT_ID_DG );
+        KERSYS_DBG(" - Power glitch detected. Duration: %ld us\n", (kerSysGetCycleCount() - clk0)/CYCLE_PER_US);
+        return 0;
+    }
+#endif
+    return 1;
+}
+
+static void kerSysDyingGaspShutdown( void )
+{
+    kerSysSetWdTimer(1000000);
+#if defined(CONFIG_BCM96345)
+    PERF->blkEnables &= ~(EMAC_CLK_EN | USB_CLK_EN | CPU_CLK_EN);
+#elif defined(CONFIG_BCM96348)
+    PERF->blkEnables &= ~(EMAC_CLK_EN | USBS_CLK_EN | USBH_CLK_EN | SAR_CLK_EN);
+#endif
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+static irqreturn_t kerSysDyingGaspIsr(int irq, void * dev_id)
+#else
+static unsigned int kerSysDyingGaspIsr(void)
+#endif
+{	
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp, *dsl = NULL;	
+
+    if (kerSysDyingGaspCheckPowerLoss()) {        
+
+        /* first to turn off everything other than dsl */        
+        list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+            tmp = list_entry(pos, CB_DGASP_LIST, list);
+    	    if(strncmp(tmp->name, "dsl", 3)) {
+    	        (tmp->cb_dgasp_fn)(tmp->context); 
+    	    }else {
+    		dsl = tmp;    		    	
+    	    }       
+        }  
+        
+        /* now send dgasp */
+        if(dsl)
+            (dsl->cb_dgasp_fn)(dsl->context); 
+
+        /* reset and shutdown system */
+        kerSysDyingGaspShutdown();
+    }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+return( IRQ_HANDLED );
+#else
+    return( 1 );
+#endif
+}
+
+static void __init kerSysInitDyingGaspHandler( void )
+{
+    CB_DGASP_LIST *new_node;
+
+    if( g_cb_dgasp_list_head != NULL) {
+        printk("Error: kerSysInitDyingGaspHandler: list head is not null\n");
+        return;	
+    }
+    new_node= (CB_DGASP_LIST *)kmalloc(sizeof(CB_DGASP_LIST), GFP_KERNEL);
+    memset(new_node, 0x00, sizeof(CB_DGASP_LIST));
+    INIT_LIST_HEAD(&new_node->list);    
+    g_cb_dgasp_list_head = new_node; 
+		
+} /* kerSysInitDyingGaspHandler */
+
+static void __exit kerSysDeinitDyingGaspHandler( void )
+{
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp; 
+     	
+    if(g_cb_dgasp_list_head == NULL)
+        return;
+        
+    list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+    	tmp = list_entry(pos, CB_DGASP_LIST, list);
+        list_del(pos);
+	kfree(tmp);
+    }       
+
+    kfree(g_cb_dgasp_list_head);	
+    g_cb_dgasp_list_head = NULL;
+    
+} /* kerSysDeinitDyingGaspHandler */
+
+void kerSysRegisterDyingGaspHandler(char *devname, void *cbfn, void *context)
+{
+    CB_DGASP_LIST *new_node;
+
+    if( g_cb_dgasp_list_head == NULL) {
+        printk("Error: kerSysRegisterDyingGaspHandler: list head is null\n");	
+        return;    
+    }
+    
+    if( devname == NULL || cbfn == NULL ) {
+        printk("Error: kerSysRegisterDyingGaspHandler: register info not enough (%s,%x,%x)\n", devname, (unsigned int)cbfn, (unsigned int)context);	    	
+        return;
+    }
+       
+    new_node= (CB_DGASP_LIST *)kmalloc(sizeof(CB_DGASP_LIST), GFP_KERNEL);
+    memset(new_node, 0x00, sizeof(CB_DGASP_LIST));    
+    INIT_LIST_HEAD(&new_node->list);
+    strncpy(new_node->name, devname, IFNAMSIZ);
+    new_node->cb_dgasp_fn = (cb_dgasp_t)cbfn;
+    new_node->context = context;
+    list_add(&new_node->list, &g_cb_dgasp_list_head->list);
+    
+    printk("dgasp: kerSysRegisterDyingGaspHandler: %s registered \n", devname);
+        	
+} /* kerSysRegisterDyingGaspHandler */
+
+void kerSysDeregisterDyingGaspHandler(char *devname)
+{
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp;    
+    
+    if(g_cb_dgasp_list_head == NULL) {
+        printk("Error: kerSysDeregisterDyingGaspHandler: list head is null\n");
+        return;	
+    }
+
+    if(devname == NULL) {
+        printk("Error: kerSysDeregisterDyingGaspHandler: devname is null\n");
+        return;	
+    }
+    
+    printk("kerSysDeregisterDyingGaspHandler: %s is deregistering\n", devname);
+
+    list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+    	tmp = list_entry(pos, CB_DGASP_LIST, list);
+    	if(!strcmp(tmp->name, devname)) {
+            list_del(pos);
+	    kfree(tmp);
+	    printk("kerSysDeregisterDyingGaspHandler: %s is deregistered\n", devname);
+	    return;
+	}
+    }	
+    printk("kerSysDeregisterDyingGaspHandler: %s not (de)registered\n", devname);
+	
+} /* kerSysDeregisterDyingGaspHandler */
+
+//EXPORT_SYMBOL(kerSysNvRamGet);
+EXPORT_SYMBOL(kerSysGetMacAddress);
+EXPORT_SYMBOL(kerSysReleaseMacAddress);
+EXPORT_SYMBOL(kerSysGetSdramSize);
+EXPORT_SYMBOL(kerSysLedCtrl);
+EXPORT_SYMBOL(kerSysGetResetHold);
+EXPORT_SYMBOL(kerSysLedRegisterHwHandler);
+EXPORT_SYMBOL(BpGetBoardIds);
+EXPORT_SYMBOL(BpGetSdramSize);
+EXPORT_SYMBOL(BpGetPsiSize);
+EXPORT_SYMBOL(BpGetEthernetMacInfo);
+EXPORT_SYMBOL(BpGetRj11InnerOuterPairGpios);
+EXPORT_SYMBOL(BpGetPressAndHoldResetGpio);
+EXPORT_SYMBOL(BpGetVoipResetGpio);
+EXPORT_SYMBOL(BpGetVoipIntrGpio);
+EXPORT_SYMBOL(BpGetPcmciaResetGpio);
+EXPORT_SYMBOL(BpGetRtsCtsUartGpios);
+EXPORT_SYMBOL(BpGetAdslLedGpio);
+EXPORT_SYMBOL(BpGetAdslFailLedGpio);
+EXPORT_SYMBOL(BpGetWirelessLedGpio);
+EXPORT_SYMBOL(BpGetUsbLedGpio);
+EXPORT_SYMBOL(BpGetHpnaLedGpio);
+EXPORT_SYMBOL(BpGetWanDataLedGpio);
+EXPORT_SYMBOL(BpGetPppLedGpio);
+EXPORT_SYMBOL(BpGetPppFailLedGpio);
+EXPORT_SYMBOL(BpGetVoipLedGpio);
+EXPORT_SYMBOL(BpGetWirelessExtIntr);
+EXPORT_SYMBOL(BpGetAdslDyingGaspExtIntr);
+EXPORT_SYMBOL(BpGetVoipExtIntr);
+EXPORT_SYMBOL(BpGetHpnaExtIntr);
+EXPORT_SYMBOL(BpGetHpnaChipSelect);
+EXPORT_SYMBOL(BpGetVoipChipSelect);
+EXPORT_SYMBOL(BpGetWirelessSesBtnGpio);
+EXPORT_SYMBOL(BpGetWirelessSesExtIntr);
+EXPORT_SYMBOL(BpGetWirelessSesLedGpio);
+EXPORT_SYMBOL(kerSysRegisterDyingGaspHandler);
+EXPORT_SYMBOL(kerSysDeregisterDyingGaspHandler);
+EXPORT_SYMBOL(kerSysGetCycleCount);
+EXPORT_SYMBOL(kerSysSetWdTimer);
+EXPORT_SYMBOL(kerSysWakeupMonitorTask);
+
diff -urN linux.old/arch/mips/bcm963xx/boardparms.c linux.dev/arch/mips/bcm963xx/boardparms.c
--- linux.old/arch/mips/bcm963xx/boardparms.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/boardparms.c	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,2391 @@
+/*
+<:copyright-gpl 
+
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+
+:>
+*/
+/**************************************************************************
+ * File Name  : boardparms.c
+ *
+ * Description: This file contains the implementation for the BCM63xx board
+ *              parameter access functions.
+ * 
+ * Updates    : 07/14/2003  Created.
+ ***************************************************************************/
+
+/* Includes. */
+#include "boardparms.h"
+
+/* Defines. */
+
+/* Default psi size in K bytes */
+#define BP_PSI_DEFAULT_SIZE                     24   
+
+/* Typedefs */
+typedef struct boardparameters
+{
+    char szBoardId[BP_BOARD_ID_LEN];        /* board id string */
+    ETHERNET_MAC_INFO EnetMacInfos[BP_MAX_ENET_MACS];
+    VOIP_DSP_INFO VoIPDspInfo[BP_MAX_VOIP_DSP];
+    unsigned short usSdramSize;             /* SDRAM size and type */
+    unsigned short usPsiSize;               /* persistent storage in K bytes */
+    unsigned short usGpioRj11InnerPair;     /* GPIO pin or not defined */
+    unsigned short usGpioRj11OuterPair;     /* GPIO pin or not defined */
+    unsigned short usGpioPressAndHoldReset; /* GPIO pin or not defined */
+    unsigned short usGpioPcmciaReset;       /* GPIO pin or not defined */
+    unsigned short usGpioUartRts;           /* GPIO pin or not defined */
+    unsigned short usGpioUartCts;           /* GPIO pin or not defined */
+    unsigned short usGpioLedAdsl;           /* GPIO pin or not defined */
+    unsigned short usGpioLedAdslFail;       /* GPIO pin or not defined */
+    unsigned short usGpioLedWireless;       /* GPIO pin or not defined */
+    unsigned short usGpioLedUsb;            /* GPIO pin or not defined */
+    unsigned short usGpioLedHpna;           /* GPIO pin or not defined */
+    unsigned short usGpioLedWanData;        /* GPIO pin or not defined */
+    unsigned short usGpioLedPpp;            /* GPIO pin or not defined */
+    unsigned short usGpioLedPppFail;        /* GPIO pin or not defined */
+    unsigned short usGpioLedBlPowerOn;      /* GPIO pin or not defined */
+    unsigned short usGpioLedBlAlarm;        /* GPIO pin or not defined */
+    unsigned short usGpioLedBlResetCfg;     /* GPIO pin or not defined */
+    unsigned short usGpioLedBlStop;         /* GPIO pin or not defined */
+    unsigned short usExtIntrWireless;       /* ext intr or not defined */
+    unsigned short usExtIntrAdslDyingGasp;  /* ext intr or not defined */
+    unsigned short usExtIntrHpna;           /* ext intr or not defined */
+    unsigned short usCsHpna;                /* chip select not defined */
+    unsigned short usAntInUseWireless;	    /* antenna in use or not defined */
+    unsigned short usGpioSesBtnWireless;    /* GPIO pin or not defined */
+    unsigned short usExtIntrSesBtnWireless; /* ext intr or not defined */        
+    unsigned short usGpioLedSesWireless;    /* GPIO pin or not defined */        
+} BOARD_PARAMETERS, *PBOARD_PARAMETERS;
+
+/* Variables */
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+static BOARD_PARAMETERS g_bcm96338sv =
+{
+    "96338SV",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_1_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_NOT_DEFINED,                         /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_NOT_DEFINED,                         /* usGpioLedBlResetCfg */
+    BP_NOT_DEFINED,                         /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */     
+};
+static BOARD_PARAMETERS g_bcm96338l2m8m =
+{
+    "96338L-2M-8M",                         /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */    
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */         
+};
+static PBOARD_PARAMETERS g_BoardParms[] =
+    {&g_bcm96338sv, &g_bcm96338l2m8m, 0};
+#endif
+
+#if defined(_BCM96345_) || defined(CONFIG_BCM96345)
+static BOARD_PARAMETERS g_bcm96345r =
+{
+    "96345R",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_GPIO_11_AH,                          /* usGpioRj11InnerPair */
+    BP_GPIO_12_AH,                          /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_GPIO_9_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_9_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96345gw2 =
+{
+    /* A hardware jumper determines whether GPIO 13 is used for Press and Hold
+     * Reset or RTS.
+     */
+    "96345GW2",                             /* szBoardId */
+    {{BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_GPIO_0_AH,                         /* usGpioPhySpiSck */
+      BP_GPIO_4_AH,                         /* usGpioPhySpiSs */
+      BP_GPIO_12_AH,                        /* usGpioPhySpiMosi */
+      BP_GPIO_11_AH,                        /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_GPIO,                  /* usConfigType */
+      BP_ENET_REVERSE_MII},                 /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_1,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_15_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_1_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_GPIO_2_AH,                           /* usGpioPcmciaReset */
+    BP_GPIO_13_AH,                          /* usGpioUartRts */
+    BP_GPIO_9_AH,                           /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_GPIO_7_AH,                           /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_7_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_EXT_INTR_2,                          /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96345gw =
+{
+    "96345GW",                              /* szBoardId */
+    {{BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_ENET_NO_REVERSE_MII},              /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_1,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_15_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_1_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_GPIO_11_AH,                          /* usGpioRj11InnerPair */
+    BP_GPIO_1_AH,                           /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_GPIO_2_AH,                           /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_GPIO_10_AH,                          /* usGpioLedWireless */
+    BP_GPIO_7_AH,                           /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_9_AH,                           /* usGpioLedBlAlarm */
+    BP_GPIO_10_AH,                          /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_EXT_INTR_2,                          /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_EXT_INTR_3,                          /* usExtIntrHpna */
+    BP_CS_1,                                /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96335r =
+{
+    "96335R",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_14_AH,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_9_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_9_AH,                           /* usGpioLedWanData */
+    BP_GPIO_8_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_8_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_9_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96345r0 =
+{
+    "96345R0",                              /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_9_AH,                           /* usGpioLedWanData */
+    BP_GPIO_9_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_9_AH,                           /* usGpioLedBlAlarm */
+    BP_GPIO_8_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */     
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96345rs =
+{
+    "96345RS",                              /* szBoardId */
+    {{BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_ENET_NO_REVERSE_MII},              /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_GPIO_11_AH,                          /* usGpioRj11InnerPair */
+    BP_GPIO_12_AH,                          /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_GPIO_9_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_9_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static PBOARD_PARAMETERS g_BoardParms[] =
+    {&g_bcm96345r, &g_bcm96345gw2, &g_bcm96345gw, &g_bcm96335r, &g_bcm96345r0,
+     &g_bcm96345rs, 0};
+#endif
+
+#if defined(_BCM96348_) || defined(CONFIG_BCM96348)
+
+static BOARD_PARAMETERS g_bcm96348r =
+{
+    "96348R",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_7_AH,                           /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96348lv =
+{
+    "96348LV",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_PHY,                 /* ucPhyType */
+      0x02,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_GPIO_5_AL,                         /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED}},                     /* usReverseMii */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_7_AH,                           /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96348gw =
+{
+    "96348GW",                              /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x03,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_0,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_34_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED, /* BP_GPIO_35_AH, */    /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED, /* BP_EXT_INTR_3, */    /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED  /* BP_GPIO_0_AL   */    /* usGpioLedSesWireless */
+};
+
+
+static BOARD_PARAMETERS g_bcm96348gw_10 =
+{
+    "96348GW-10",                           /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x03,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_34_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96348gw_11 =
+{
+    "96348GW-11",                           /* szBoardId */
+    {{BP_ENET_NO_PHY},                      /* ucPhyType */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96348sv =
+{
+    "96348SV",                              /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_PHY,                 /* ucPhyType */
+      0x1f,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED}},                     /* usReverseMii */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_32MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_NOT_DEFINED,                         /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_NOT_DEFINED,                         /* usGpioLedBlResetCfg */
+    BP_NOT_DEFINED,                         /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+
+static BOARD_PARAMETERS g_bcm96348gw_dualDsp =
+{
+    "96348GW-DualDSP",                      /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x03,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_UNEQUIPPED,                        /* usGpioVoipReset */
+      BP_GPIO_34_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_DSP,                          /* ucDspType */
+      0x01,                                 /* ucDspAddress */
+      BP_EXT_INTR_3,                        /* usExtIntrVoip */
+      BP_UNEQUIPPED ,                       /* usGpioVoipReset */
+      BP_GPIO_35_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_3}},                            /* usCsVoip */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+
+static BOARD_PARAMETERS g_bcmCustom_01 =
+{
+     "BCMCUST_01",                          /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY,                       /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_GPIO_36_AH,                        /* usGpioVoipReset */
+      BP_GPIO_34_AL,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static PBOARD_PARAMETERS g_BoardParms[] =
+    {&g_bcm96348r, &g_bcm96348lv, &g_bcm96348gw, &g_bcm96348gw_10,
+     &g_bcm96348gw_11, &g_bcm96348sv, &g_bcm96348gw_dualDsp,
+     &g_bcmCustom_01, 0};
+#endif
+
+static PBOARD_PARAMETERS g_pCurrentBp = 0;
+
+/**************************************************************************
+ * Name       : bpstrcmp
+ *
+ * Description: String compare for this file so it does not depend on an OS.
+ *              (Linux kernel and CFE share this source file.)
+ *
+ * Parameters : [IN] dest - destination string
+ *              [IN] src - source string
+ *
+ * Returns    : -1 - dest < src, 1 - dest > src, 0 dest == src
+ ***************************************************************************/
+static int bpstrcmp(const char *dest,const char *src);
+static int bpstrcmp(const char *dest,const char *src)
+{
+    while (*src && *dest)
+    {
+        if (*dest < *src) return -1;
+        if (*dest > *src) return 1;
+        dest++;
+        src++;
+    }
+
+    if (*dest && !*src) return 1;
+    if (!*dest && *src) return -1;
+    return 0;
+} /* bpstrcmp */
+
+/**************************************************************************
+ * Name       : BpGetVoipDspConfig
+ *
+ * Description: Gets the DSP configuration from the board parameter
+ *              structure for a given DSP index.
+ *
+ * Parameters : [IN] dspNum - DSP index (number)
+ *
+ * Returns    : Pointer to DSP configuration block if found/valid, NULL
+ *              otherwise.
+ ***************************************************************************/
+VOIP_DSP_INFO *BpGetVoipDspConfig( unsigned char dspNum );
+VOIP_DSP_INFO *BpGetVoipDspConfig( unsigned char dspNum )
+{
+    VOIP_DSP_INFO *pDspConfig = 0;
+    int i;
+
+    if( g_pCurrentBp )
+    {
+        for( i = 0 ; i < BP_MAX_VOIP_DSP ; i++ )
+        {
+            if( g_pCurrentBp->VoIPDspInfo[i].ucDspType != BP_VOIP_NO_DSP &&
+                g_pCurrentBp->VoIPDspInfo[i].ucDspAddress == dspNum )
+            {
+                pDspConfig = &g_pCurrentBp->VoIPDspInfo[i];
+                break;
+            }
+        }
+    }
+
+    return pDspConfig;
+}
+
+
+/**************************************************************************
+ * Name       : BpSetBoardId
+ *
+ * Description: This function find the BOARD_PARAMETERS structure for the
+ *              specified board id string and assigns it to a global, static
+ *              variable.
+ *
+ * Parameters : [IN] pszBoardId - Board id string that is saved into NVRAM.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_FOUND - Error, board id input string does not
+ *                  have a board parameters configuration record.
+ ***************************************************************************/
+int BpSetBoardId( char *pszBoardId )
+{
+    int nRet = BP_BOARD_ID_NOT_FOUND;
+    PBOARD_PARAMETERS *ppBp;
+
+    for( ppBp = g_BoardParms; *ppBp; ppBp++ )
+    {
+        if( !bpstrcmp((*ppBp)->szBoardId, pszBoardId) )
+        {
+            g_pCurrentBp = *ppBp;
+            nRet = BP_SUCCESS;
+            break;
+        }
+    }
+
+    return( nRet );
+} /* BpSetBoardId */
+
+/**************************************************************************
+ * Name       : BpGetBoardIds
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pszBoardIds - Address of a buffer that the board id
+ *                  strings are returned in.  Each id starts at BP_BOARD_ID_LEN
+ *                  boundary.
+ *              [IN] nBoardIdsSize - Number of BP_BOARD_ID_LEN elements that
+ *                  were allocated in pszBoardIds.
+ *
+ * Returns    : Number of board id strings returned.
+ ***************************************************************************/
+int BpGetBoardIds( char *pszBoardIds, int nBoardIdsSize )
+{
+    PBOARD_PARAMETERS *ppBp;
+    int i;
+    char *src;
+    char *dest;
+
+    for( i = 0, ppBp = g_BoardParms; *ppBp && nBoardIdsSize;
+        i++, ppBp++, nBoardIdsSize--, pszBoardIds += BP_BOARD_ID_LEN )
+    {
+        dest = pszBoardIds;
+        src = (*ppBp)->szBoardId;
+        while( *src )
+            *dest++ = *src++;
+        *dest = '\0';
+    }
+
+    return( i );
+} /* BpGetBoardIds */
+
+/**************************************************************************
+ * Name       : BpGetEthernetMacInfo
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pEnetInfos - Address of an array of ETHERNET_MAC_INFO
+ *                  buffers.
+ *              [IN] nNumEnetInfos - Number of ETHERNET_MAC_INFO elements that
+ *                  are pointed to by pEnetInfos.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetEthernetMacInfo( PETHERNET_MAC_INFO pEnetInfos, int nNumEnetInfos )
+{
+    int i, nRet;
+
+    if( g_pCurrentBp )
+    {
+        for( i = 0; i < nNumEnetInfos; i++, pEnetInfos++ )
+        {
+            if( i < BP_MAX_ENET_MACS )
+            {
+                unsigned char *src = (unsigned char *)
+                    &g_pCurrentBp->EnetMacInfos[i];
+                unsigned char *dest = (unsigned char *) pEnetInfos;
+                int len = sizeof(ETHERNET_MAC_INFO);
+                while( len-- )
+                    *dest++ = *src++;
+            }
+            else
+                pEnetInfos->ucPhyType = BP_ENET_NO_PHY;
+        }
+
+        nRet = BP_SUCCESS;
+    }
+    else
+    {
+        for( i = 0; i < nNumEnetInfos; i++, pEnetInfos++ )
+            pEnetInfos->ucPhyType = BP_ENET_NO_PHY;
+
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetEthernetMacInfo */
+
+/**************************************************************************
+ * Name       : BpGetSdramSize
+ *
+ * Description: This function returns a constant that describees the board's
+ *              SDRAM type and size.
+ *
+ * Parameters : [OUT] pulSdramSize - Address of short word that the SDRAM size
+ *                  is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetSdramSize( unsigned long *pulSdramSize )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulSdramSize = g_pCurrentBp->usSdramSize;
+        nRet = BP_SUCCESS;
+    }
+    else
+    {
+        *pulSdramSize = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetSdramSize */
+
+/**************************************************************************
+ * Name       : BpGetPsiSize
+ *
+ * Description: This function returns the persistent storage size in K bytes.
+ *
+ * Parameters : [OUT] pulPsiSize - Address of short word that the persistent
+ *                  storage size is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetPsiSize( unsigned long *pulPsiSize )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulPsiSize = g_pCurrentBp->usPsiSize;
+        nRet = BP_SUCCESS;
+    }
+    else
+    {
+        *pulPsiSize = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPsiSize */
+
+/**************************************************************************
+ * Name       : BpGetRj11InnerOuterPairGpios
+ *
+ * Description: This function returns the GPIO pin assignments for changing
+ *              between the RJ11 inner pair and RJ11 outer pair.
+ *
+ * Parameters : [OUT] pusInner - Address of short word that the RJ11 inner pair
+ *                  GPIO pin is returned in.
+ *              [OUT] pusOuter - Address of short word that the RJ11 outer pair
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRj11InnerOuterPairGpios( unsigned short *pusInner,
+    unsigned short *pusOuter )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusInner = g_pCurrentBp->usGpioRj11InnerPair;
+        *pusOuter = g_pCurrentBp->usGpioRj11OuterPair;
+
+        if( g_pCurrentBp->usGpioRj11InnerPair != BP_NOT_DEFINED &&
+            g_pCurrentBp->usGpioRj11OuterPair != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusInner = *pusOuter = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetRj11InnerOuterPairGpios */
+
+/**************************************************************************
+ * Name       : BpGetPressAndHoldResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the press
+ *              and hold reset button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the press and hold
+ *                  reset button GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPressAndHoldResetGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioPressAndHoldReset;
+
+        if( g_pCurrentBp->usGpioPressAndHoldReset != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPressAndHoldResetGpio */
+
+/**************************************************************************
+ * Name       : BpGetVoipResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP reset
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipResetGpio( unsigned char dspNum, unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pusValue = pDspInfo->usGpioVoipReset;
+
+           if( *pusValue != BP_NOT_DEFINED ||
+               *pusValue == BP_UNEQUIPPED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pusValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipResetGpio */
+
+/**************************************************************************
+ * Name       : BpGetVoipIntrGpio
+ *
+ * Description: This function returns the GPIO pin assignment for VoIP interrupt.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP interrupt
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipIntrGpio( unsigned char dspNum, unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pusValue = pDspInfo->usGpioVoipIntr;
+
+           if( *pusValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pusValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipIntrGpio */
+
+/**************************************************************************
+ * Name       : BpGetPcmciaResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PCMCIA
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PCMCIA reset
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPcmciaResetGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioPcmciaReset;
+
+        if( g_pCurrentBp->usGpioPcmciaReset != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPcmciaResetGpio */
+
+/**************************************************************************
+ * Name       : BpGetUartRtsCtsGpios
+ *
+ * Description: This function returns the GPIO pin assignments for RTS and CTS
+ *              UART signals.
+ *
+ * Parameters : [OUT] pusRts - Address of short word that the UART RTS GPIO
+ *                  pin is returned in.
+ *              [OUT] pusCts - Address of short word that the UART CTS GPIO
+ *                  pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, board id input string does not
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRtsCtsUartGpios( unsigned short *pusRts, unsigned short *pusCts )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusRts = g_pCurrentBp->usGpioUartRts;
+        *pusCts = g_pCurrentBp->usGpioUartCts;
+
+        if( g_pCurrentBp->usGpioUartRts != BP_NOT_DEFINED &&
+            g_pCurrentBp->usGpioUartCts != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusRts = *pusCts = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetUartRtsCtsGpios */
+
+/**************************************************************************
+ * Name       : BpGetAdslLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedAdsl;
+
+        if( g_pCurrentBp->usGpioLedAdsl != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetAdslLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetAdslFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED that is used when there is a DSL connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslFailLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedAdslFail;
+
+        if( g_pCurrentBp->usGpioLedAdslFail != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetAdslFailLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedWireless;
+
+        if( g_pCurrentBp->usGpioLedWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetWirelessLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessAntInUse
+ *
+ * Description: This function returns the antennas in use for wireless
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Antenna
+ *                  is in use.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessAntInUse( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usAntInUseWireless;
+
+        if( g_pCurrentBp->usAntInUseWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );	
+} /* BpGetWirelessAntInUse */
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesBtnGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesBtnGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioSesBtnWireless;
+
+        if( g_pCurrentBp->usGpioSesBtnWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );	
+} /* BpGetWirelessSesBtnGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesExtIntr
+ *
+ * Description: This function returns the external interrupt number for the 
+ *              Wireless Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  external interrup is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesExtIntr( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usExtIntrSesBtnWireless;
+
+        if( g_pCurrentBp->usExtIntrSesBtnWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );	
+		
+} /* BpGetWirelessSesExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Led.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  Led GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedSesWireless;
+
+        if( g_pCurrentBp->usGpioLedSesWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+	
+} /* BpGetWirelessSesLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetUsbLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the USB
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the USB LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetUsbLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedUsb;
+
+        if( g_pCurrentBp->usGpioLedUsb != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetUsbLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetHpnaLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the HPNA
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the HPNA LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedHpna;
+
+        if( g_pCurrentBp->usGpioLedHpna != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetHpnaLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWanDataLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the WAN Data
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the WAN Data LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWanDataLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedWanData;
+
+        if( g_pCurrentBp->usGpioLedWanData != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetWanDataLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetPppLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedPpp;
+
+        if( g_pCurrentBp->usGpioLedPpp != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPppLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetPppFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED that is used when there is a PPP connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppFailLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedPppFail;
+
+        if( g_pCurrentBp->usGpioLedPppFail != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPppFailLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderPowerOnLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the power
+ *              on LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderPowerOnLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlPowerOn;
+
+        if( g_pCurrentBp->usGpioLedBlPowerOn != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderPowerOn */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderAlarmLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the alarm
+ *              LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderAlarmLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlAlarm;
+
+        if( g_pCurrentBp->usGpioLedBlAlarm != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderAlarmLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderResetCfgLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the reset
+ *              configuration LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the reset
+ *                  configuration LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderResetCfgLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlResetCfg;
+
+        if( g_pCurrentBp->usGpioLedBlResetCfg != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderResetCfgLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderStopLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the break
+ *              into bootloader LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the break into
+ *                  bootloader LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderStopLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlStop;
+
+        if( g_pCurrentBp->usGpioLedBlStop != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderStopLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetVoipLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ *
+ * Note       : The VoIP structure would allow for having one LED per DSP
+ *              however, the board initialization function assumes only one
+ *              LED per functionality (ie one LED for VoIP).  Therefore in
+ *              order to keep this tidy and simple we do not make usage of the
+ *              one-LED-per-DSP function.  Instead, we assume that the LED for
+ *              VoIP is unique and associated with DSP 0 (always present on
+ *              any VoIP platform).  If changing this to a LED-per-DSP function
+ *              then one need to update the board initialization driver in
+ *              bcmdrivers\opensource\char\board\bcm963xx\impl1
+ ***************************************************************************/
+int BpGetVoipLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( 0 );
+
+        if( pDspInfo )
+        {
+           *pusValue = pDspInfo->usGpioLedVoip;
+
+           if( *pusValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pusValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessExtIntr
+ *
+ * Description: This function returns the Wireless external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the wireless
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessExtIntr( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usExtIntrWireless;
+
+        if( g_pCurrentBp->usExtIntrWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetWirelessExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetAdslDyingGaspExtIntr
+ *
+ * Description: This function returns the ADSL Dying Gasp external interrupt
+ *              number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the ADSL Dying Gasp
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslDyingGaspExtIntr( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usExtIntrAdslDyingGasp;
+
+        if( g_pCurrentBp->usExtIntrAdslDyingGasp != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetAdslDyingGaspExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetVoipExtIntr
+ *
+ * Description: This function returns the VOIP external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  external interrupt number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipExtIntr( unsigned char dspNum, unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pulValue = pDspInfo->usExtIntrVoip;
+
+           if( *pulValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pulValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetHpnaExtIntr
+ *
+ * Description: This function returns the HPNA external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaExtIntr( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usExtIntrHpna;
+
+        if( g_pCurrentBp->usExtIntrHpna != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetHpnaExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetHpnaChipSelect
+ *
+ * Description: This function returns the HPNA chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  chip select number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaChipSelect( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usCsHpna;
+
+        if( g_pCurrentBp->usCsHpna != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetHpnaChipSelect */
+
+/**************************************************************************
+ * Name       : BpGetVoipChipSelect
+ *
+ * Description: This function returns the VOIP chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  chip select number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipChipSelect( unsigned char dspNum, unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pulValue = pDspInfo->usCsVoip;
+
+           if( *pulValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pulValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipChipSelect */
+
diff -urN linux.old/arch/mips/bcm963xx/boardparms.h linux.dev/arch/mips/bcm963xx/boardparms.h
--- linux.old/arch/mips/bcm963xx/boardparms.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/boardparms.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,758 @@
+/*
+<:copyright-gpl 
+
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+
+:>
+*/
+/**************************************************************************
+ * File Name  : boardparms.h
+ *
+ * Description: This file contains definitions and function prototypes for
+ *              the BCM63xx board parameter access functions.
+ * 
+ * Updates    : 07/14/2003  Created.
+ ***************************************************************************/
+
+#if !defined(_BOARDPARMS_H)
+#define _BOARDPARMS_H
+
+/* Return codes. */
+#define BP_SUCCESS                              0
+#define BP_BOARD_ID_NOT_FOUND                   1
+#define BP_VALUE_NOT_DEFINED                    2
+#define BP_BOARD_ID_NOT_SET                     3
+
+/* Values for BpGetSdramSize. */
+#define BP_MEMORY_8MB_1_CHIP                    0
+#define BP_MEMORY_16MB_1_CHIP                   1
+#define BP_MEMORY_32MB_1_CHIP                   2
+#define BP_MEMORY_64MB_2_CHIP                   3
+#define BP_MEMORY_32MB_2_CHIP                   4
+#define BP_MEMORY_16MB_2_CHIP                   5
+
+/* Values for EthernetMacInfo PhyType. */
+#define BP_ENET_NO_PHY                          0
+#define BP_ENET_INTERNAL_PHY                    1
+#define BP_ENET_EXTERNAL_PHY                    2
+#define BP_ENET_EXTERNAL_SWITCH                 3
+
+/* Values for EthernetMacInfo Configuration type. */
+#define BP_ENET_CONFIG_MDIO                     0       /* Internal PHY, External PHY, Switch+(no GPIO, no SPI, no MDIO Pseudo phy */
+#define BP_ENET_CONFIG_GPIO                     1       /* Bcm96345GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_MDIO_PSEUDO_PHY          2       /* Bcm96348GW board + Bcm5325E */
+#define BP_ENET_CONFIG_SPI_SSB_0                3       /* Bcm96348GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_SPI_SSB_1                4       /* Bcm96348GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_SPI_SSB_2                5       /* Bcm96348GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_SPI_SSB_3                6       /* Bcm96348GW board + Bcm5325M/E */
+
+/* Values for EthernetMacInfo Reverse MII. */
+#define BP_ENET_NO_REVERSE_MII                  0
+#define BP_ENET_REVERSE_MII                     1
+
+/* Values for VoIPDSPInfo DSPType. */
+#define BP_VOIP_NO_DSP                          0
+#define BP_VOIP_DSP                             1
+
+
+/* Values for GPIO pin assignments (AH = Active High, AL = Active Low). */
+#define BP_ACTIVE_MASK                          0x8000
+#define BP_ACTIVE_HIGH                          0x0000
+#define BP_ACTIVE_LOW                           0x8000
+#define BP_GPIO_0_AH                            (0  | BP_ACTIVE_HIGH)
+#define BP_GPIO_0_AL                            (0  | BP_ACTIVE_LOW)
+#define BP_GPIO_1_AH                            (1  | BP_ACTIVE_HIGH)
+#define BP_GPIO_1_AL                            (1  | BP_ACTIVE_LOW)
+#define BP_GPIO_2_AH                            (2  | BP_ACTIVE_HIGH)
+#define BP_GPIO_2_AL                            (2  | BP_ACTIVE_LOW)
+#define BP_GPIO_3_AH                            (3  | BP_ACTIVE_HIGH)
+#define BP_GPIO_3_AL                            (3  | BP_ACTIVE_LOW)
+#define BP_GPIO_4_AH                            (4  | BP_ACTIVE_HIGH)
+#define BP_GPIO_4_AL                            (4  | BP_ACTIVE_LOW)
+#define BP_GPIO_5_AH                            (5  | BP_ACTIVE_HIGH)
+#define BP_GPIO_5_AL                            (5  | BP_ACTIVE_LOW)
+#define BP_GPIO_6_AH                            (6  | BP_ACTIVE_HIGH)
+#define BP_GPIO_6_AL                            (6  | BP_ACTIVE_LOW)
+#define BP_GPIO_7_AH                            (7  | BP_ACTIVE_HIGH)
+#define BP_GPIO_7_AL                            (7  | BP_ACTIVE_LOW)
+#define BP_GPIO_8_AH                            (8  | BP_ACTIVE_HIGH)
+#define BP_GPIO_8_AL                            (8  | BP_ACTIVE_LOW)
+#define BP_GPIO_9_AH                            (9  | BP_ACTIVE_HIGH)
+#define BP_GPIO_9_AL                            (9  | BP_ACTIVE_LOW)
+#define BP_GPIO_10_AH                           (10 | BP_ACTIVE_HIGH)
+#define BP_GPIO_10_AL                           (10 | BP_ACTIVE_LOW)
+#define BP_GPIO_11_AH                           (11 | BP_ACTIVE_HIGH)
+#define BP_GPIO_11_AL                           (11 | BP_ACTIVE_LOW)
+#define BP_GPIO_12_AH                           (12 | BP_ACTIVE_HIGH)
+#define BP_GPIO_12_AL                           (12 | BP_ACTIVE_LOW)
+#define BP_GPIO_13_AH                           (13 | BP_ACTIVE_HIGH)
+#define BP_GPIO_13_AL                           (13 | BP_ACTIVE_LOW)
+#define BP_GPIO_14_AH                           (14 | BP_ACTIVE_HIGH)
+#define BP_GPIO_14_AL                           (14 | BP_ACTIVE_LOW)
+#define BP_GPIO_15_AH                           (15 | BP_ACTIVE_HIGH)
+#define BP_GPIO_15_AL                           (15 | BP_ACTIVE_LOW)
+#define BP_GPIO_16_AH                           (16 | BP_ACTIVE_HIGH)
+#define BP_GPIO_16_AL                           (16 | BP_ACTIVE_LOW)
+#define BP_GPIO_17_AH                           (17 | BP_ACTIVE_HIGH)
+#define BP_GPIO_17_AL                           (17 | BP_ACTIVE_LOW)
+#define BP_GPIO_18_AH                           (18 | BP_ACTIVE_HIGH)
+#define BP_GPIO_18_AL                           (18 | BP_ACTIVE_LOW)
+#define BP_GPIO_19_AH                           (19 | BP_ACTIVE_HIGH)
+#define BP_GPIO_19_AL                           (19 | BP_ACTIVE_LOW)
+#define BP_GPIO_20_AH                           (20 | BP_ACTIVE_HIGH)
+#define BP_GPIO_20_AL                           (20 | BP_ACTIVE_LOW)
+#define BP_GPIO_21_AH                           (21 | BP_ACTIVE_HIGH)
+#define BP_GPIO_21_AL                           (21 | BP_ACTIVE_LOW)
+#define BP_GPIO_22_AH                           (22 | BP_ACTIVE_HIGH)
+#define BP_GPIO_22_AL                           (22 | BP_ACTIVE_LOW)
+#define BP_GPIO_23_AH                           (23 | BP_ACTIVE_HIGH)
+#define BP_GPIO_23_AL                           (23 | BP_ACTIVE_LOW)
+#define BP_GPIO_24_AH                           (24 | BP_ACTIVE_HIGH)
+#define BP_GPIO_24_AL                           (24 | BP_ACTIVE_LOW)
+#define BP_GPIO_25_AH                           (25 | BP_ACTIVE_HIGH)
+#define BP_GPIO_25_AL                           (25 | BP_ACTIVE_LOW)
+#define BP_GPIO_26_AH                           (26 | BP_ACTIVE_HIGH)
+#define BP_GPIO_26_AL                           (26 | BP_ACTIVE_LOW)
+#define BP_GPIO_27_AH                           (27 | BP_ACTIVE_HIGH)
+#define BP_GPIO_27_AL                           (27 | BP_ACTIVE_LOW)
+#define BP_GPIO_28_AH                           (28 | BP_ACTIVE_HIGH)
+#define BP_GPIO_28_AL                           (28 | BP_ACTIVE_LOW)
+#define BP_GPIO_29_AH                           (29 | BP_ACTIVE_HIGH)
+#define BP_GPIO_29_AL                           (29 | BP_ACTIVE_LOW)
+#define BP_GPIO_30_AH                           (30 | BP_ACTIVE_HIGH)
+#define BP_GPIO_30_AL                           (30 | BP_ACTIVE_LOW)
+#define BP_GPIO_31_AH                           (31 | BP_ACTIVE_HIGH)
+#define BP_GPIO_31_AL                           (31 | BP_ACTIVE_LOW)
+#define BP_GPIO_32_AH                           (32 | BP_ACTIVE_HIGH)
+#define BP_GPIO_32_AL                           (32 | BP_ACTIVE_LOW)
+#define BP_GPIO_33_AH                           (33 | BP_ACTIVE_HIGH)
+#define BP_GPIO_33_AL                           (33 | BP_ACTIVE_LOW)
+#define BP_GPIO_34_AH                           (34 | BP_ACTIVE_HIGH)
+#define BP_GPIO_34_AL                           (34 | BP_ACTIVE_LOW)
+#define BP_GPIO_35_AH                           (35 | BP_ACTIVE_HIGH)
+#define BP_GPIO_35_AL                           (35 | BP_ACTIVE_LOW)
+#define BP_GPIO_36_AH                           (36 | BP_ACTIVE_HIGH)
+#define BP_GPIO_36_AL                           (36 | BP_ACTIVE_LOW)
+
+/* Values for external interrupt assignments. */
+#define BP_EXT_INTR_0                           0
+#define BP_EXT_INTR_1                           1
+#define BP_EXT_INTR_2                           2
+#define BP_EXT_INTR_3                           3
+
+/* Values for chip select assignments. */
+#define BP_CS_0                                 0
+#define BP_CS_1                                 1
+#define BP_CS_2                                 2
+#define BP_CS_3                                 3
+
+/* Value for GPIO and external interrupt fields that are not used. */
+#define BP_NOT_DEFINED                          0xffff
+#define BP_HW_DEFINED                           0xfff0
+#define BP_UNEQUIPPED                           0xfff1
+
+/* Maximum size of the board id string. */
+#define BP_BOARD_ID_LEN                         16
+
+/* Maximum number of Ethernet MACs. */
+#define BP_MAX_ENET_MACS                        2
+
+/* Maximum number of VoIP DSPs. */
+#define BP_MAX_VOIP_DSP                         2
+
+/* Wireless Antenna Settings. */
+#define BP_WLAN_ANT_MAIN                        0
+#define BP_WLAN_ANT_AUX                         1
+#define BP_WLAN_ANT_BOTH                        3
+
+#if !defined(__ASSEMBLER__)
+
+/* Information about an Ethernet MAC.  If ucPhyType is BP_ENET_NO_PHY,
+ * then the other fields are not valid.
+ */
+typedef struct EthernetMacInfo
+{
+    unsigned char ucPhyType;                    /* BP_ENET_xxx             */
+    unsigned char ucPhyAddress;                 /* 0 to 31                 */
+    unsigned short usGpioPhySpiSck;             /* GPIO pin or not defined */
+    unsigned short usGpioPhySpiSs;              /* GPIO pin or not defined */
+    unsigned short usGpioPhySpiMosi;            /* GPIO pin or not defined */
+    unsigned short usGpioPhySpiMiso;            /* GPIO pin or not defined */
+    unsigned short usGpioPhyReset;              /* GPIO pin or not defined (96348LV) */
+    unsigned short numSwitchPorts;              /* Number of PHY ports */
+    unsigned short usConfigType;                /* Configuration type */
+    unsigned short usReverseMii;                /* Reverse MII */
+} ETHERNET_MAC_INFO, *PETHERNET_MAC_INFO;
+
+
+/* Information about VoIP DSPs.  If ucDspType is BP_VOIP_NO_DSP,
+ * then the other fields are not valid.
+ */
+typedef struct VoIPDspInfo
+{
+    unsigned char  ucDspType;
+    unsigned char  ucDspAddress;
+    unsigned short usExtIntrVoip;
+    unsigned short usGpioVoipReset;
+    unsigned short usGpioVoipIntr;
+    unsigned short usGpioLedVoip;
+    unsigned short usCsVoip;
+
+} VOIP_DSP_INFO;
+
+
+/**************************************************************************
+ * Name       : BpSetBoardId
+ *
+ * Description: This function find the BOARD_PARAMETERS structure for the
+ *              specified board id string and assigns it to a global, static
+ *              variable.
+ *
+ * Parameters : [IN] pszBoardId - Board id string that is saved into NVRAM.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_FOUND - Error, board id input string does not
+ *                  have a board parameters configuration record.
+ ***************************************************************************/
+int BpSetBoardId( char *pszBoardId );
+
+/**************************************************************************
+ * Name       : BpGetBoardIds
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pszBoardIds - Address of a buffer that the board id
+ *                  strings are returned in.  Each id starts at BP_BOARD_ID_LEN
+ *                  boundary.
+ *              [IN] nBoardIdsSize - Number of BP_BOARD_ID_LEN elements that
+ *                  were allocated in pszBoardIds.
+ *
+ * Returns    : Number of board id strings returned.
+ ***************************************************************************/
+int BpGetBoardIds( char *pszBoardIds, int nBoardIdsSize );
+
+/**************************************************************************
+ * Name       : BpGetEthernetMacInfo
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pEnetInfos - Address of an array of ETHERNET_MAC_INFO
+ *                  buffers.
+ *              [IN] nNumEnetInfos - Number of ETHERNET_MAC_INFO elements that
+ *                  are pointed to by pEnetInfos.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetEthernetMacInfo( PETHERNET_MAC_INFO pEnetInfos, int nNumEnetInfos );
+
+/**************************************************************************
+ * Name       : BpGetSdramSize
+ *
+ * Description: This function returns a constant that describees the board's
+ *              SDRAM type and size.
+ *
+ * Parameters : [OUT] pulSdramSize - Address of short word that the SDRAM size
+ *                  is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetSdramSize( unsigned long *pulSdramSize );
+
+/**************************************************************************
+ * Name       : BpGetPsiSize
+ *
+ * Description: This function returns the persistent storage size in K bytes.
+ *
+ * Parameters : [OUT] pulPsiSize - Address of short word that the persistent
+ *                  storage size is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetPsiSize( unsigned long *pulPsiSize );
+
+/**************************************************************************
+ * Name       : BpGetRj11InnerOuterPairGpios
+ *
+ * Description: This function returns the GPIO pin assignments for changing
+ *              between the RJ11 inner pair and RJ11 outer pair.
+ *
+ * Parameters : [OUT] pusInner - Address of short word that the RJ11 inner pair
+ *                  GPIO pin is returned in.
+ *              [OUT] pusOuter - Address of short word that the RJ11 outer pair
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRj11InnerOuterPairGpios( unsigned short *pusInner,
+    unsigned short *pusOuter );
+
+/**************************************************************************
+ * Name       : BpGetPressAndHoldResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the press
+ *              and hold reset button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the press and hold
+ *                  reset button GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPressAndHoldResetGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP reset
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipResetGpio( unsigned char dspNum, unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipIntrGpio
+ *
+ * Description: This function returns the GPIO pin assignment for VoIP interrupt.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP interrupt
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipIntrGpio( unsigned char dspNum, unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetPcmciaResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PCMCIA
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PCMCIA reset
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPcmciaResetGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetUartRtsCtsGpios
+ *
+ * Description: This function returns the GPIO pin assignments for RTS and CTS
+ *              UART signals.
+ *
+ * Parameters : [OUT] pusRts - Address of short word that the UART RTS GPIO
+ *                  pin is returned in.
+ *              [OUT] pusCts - Address of short word that the UART CTS GPIO
+ *                  pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRtsCtsUartGpios( unsigned short *pusRts, unsigned short *pusCts );
+
+/**************************************************************************
+ * Name       : BpGetAdslLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetAdslFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED that is used when there is a DSL connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslFailLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessAntInUse
+ *
+ * Description: This function returns the antennas in use for wireless
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Antenna
+ *                  is in use.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessAntInUse( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesBtnGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  Button GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesBtnGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesExtIntr
+ *
+ * Description: This function returns the external interrupt number for the 
+ *              Wireless Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  external interrup is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesExtIntr( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Led.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  Led GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetUsbLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the USB
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the USB LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetUsbLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetHpnaLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the HPNA
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the HPNA LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWanDataLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the WAN Data
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the WAN Data LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWanDataLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetPppLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetPppFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED that is used when there is a PPP connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppFailLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderPowerOnLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the power
+ *              on LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderPowerOnLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderAlarmLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the alarm
+ *              LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderAlarmLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderResetCfgLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the reset
+ *              configuration LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the reset
+ *                  configuration LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderResetCfgLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderStopLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the break
+ *              into bootloader LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the break into
+ *                  bootloader LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderStopLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessExtIntr
+ *
+ * Description: This function returns the Wireless external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the wireless
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessExtIntr( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetAdslDyingGaspExtIntr
+ *
+ * Description: This function returns the ADSL Dying Gasp external interrupt
+ *              number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the ADSL Dying Gasp
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslDyingGaspExtIntr( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipExtIntr
+ *
+ * Description: This function returns the VOIP external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  external interrupt number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipExtIntr( unsigned char dspNum, unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetHpnaExtIntr
+ *
+ * Description: This function returns the HPNA external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaExtIntr( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetHpnaChipSelect
+ *
+ * Description: This function returns the HPNA chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  chip select number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaChipSelect( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipChipSelect
+ *
+ * Description: This function returns the VOIP chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  chip select number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipChipSelect( unsigned char dspNum, unsigned long *pulValue );
+
+#endif /* __ASSEMBLER__ */
+
+#endif /* _BOARDPARMS_H */
+
diff -urN linux.old/arch/mips/bcm963xx/include/6338_intr.h linux.dev/arch/mips/bcm963xx/include/6338_intr.h
--- linux.old/arch/mips/bcm963xx/include/6338_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/6338_intr.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6338_INTR_H
+#define __6338_INTR_H
+
+/*=====================================================================*/
+/* BCM6338 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6338 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+#define INTERRUPT_ID_TIMER               (INTERNAL_ISR_TABLE_OFFSET + 0)
+#define INTERRUPT_ID_SPI                 (INTERNAL_ISR_TABLE_OFFSET + 1)
+#define INTERRUPT_ID_UART                (INTERNAL_ISR_TABLE_OFFSET + 2)
+#define INTERRUPT_ID_DG                  (INTERNAL_ISR_TABLE_OFFSET + 4)
+#define INTERRUPT_ID_ADSL                (INTERNAL_ISR_TABLE_OFFSET + 5)
+#define INTERRUPT_ID_ATM                 (INTERNAL_ISR_TABLE_OFFSET + 6)
+#define INTERRUPT_ID_USBS                (INTERNAL_ISR_TABLE_OFFSET + 7)
+#define INTERRUPT_ID_EMAC1               (INTERNAL_ISR_TABLE_OFFSET + 8)
+#define INTERRUPT_ID_EPHY                (INTERNAL_ISR_TABLE_OFFSET + 9)
+#define INTERRUPT_ID_SDRAM               (INTERNAL_ISR_TABLE_OFFSET + 10)
+#define INTERRUPT_ID_USB_CNTL_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 11)
+#define INTERRUPT_ID_USB_CNTL_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 12)
+#define INTERRUPT_ID_USB_BULK_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 13)
+#define INTERRUPT_ID_USB_BULK_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 14)
+#define INTERRUPT_ID_EMAC1_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 15)
+#define INTERRUPT_ID_EMAC1_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 16)
+#define INTERRUPT_ID_SDIO                (INTERNAL_ISR_TABLE_OFFSET + 17)
+
+#endif  /* __BCM6338_H */
+
diff -urN linux.old/arch/mips/bcm963xx/include/6338_map_part.h linux.dev/arch/mips/bcm963xx/include/6338_map_part.h
--- linux.old/arch/mips/bcm963xx/include/6338_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/6338_map_part.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,334 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6338_MAP_H
+#define __BCM6338_MAP_H
+
+#include "bcmtypes.h"
+
+#define PERF_BASE           0xfffe0000
+#define TIMR_BASE           0xfffe0200 
+#define UART_BASE           0xfffe0300
+#define GPIO_BASE           0xfffe0400
+#define SPI_BASE            0xfffe0c00
+
+typedef struct PerfControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define EMAC_CLK_EN     0x0010
+#define USBS_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+
+#define SPI_CLK_EN      0x0200
+
+  uint32        pll_control;
+#define SOFT_RESET 0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint32        unused0;
+  uint32        GPIODir;      /* bits 7:0 */
+  uint32        unused1;
+  uint32        GPIOio;       /* bits 7:0 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        vRegConfig;
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+/*
+** Spi Controller
+*/
+
+typedef struct SpiControl {
+  uint16        spiCmd;                 /* (0x0): SPI command */
+#define SPI_CMD_START_IMMEDIATE         3
+
+#define SPI_CMD_COMMAND_SHIFT           0
+#define SPI_CMD_DEVICE_ID_SHIFT         4
+#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT  8
+
+  byte          spiIntStatus;           /* (0x2): SPI interrupt status */
+  byte          spiMaskIntStatus;       /* (0x3): SPI masked interrupt status */
+
+  byte          spiIntMask;             /* (0x4): SPI interrupt mask */
+#define SPI_INTR_CMD_DONE               0x01
+#define SPI_INTR_CLEAR_ALL              0x1f
+
+  byte          spiStatus;              /* (0x5): SPI status */
+
+  byte          spiClkCfg;              /* (0x6): SPI clock configuration */
+
+  byte          spiFillByte;            /* (0x7): SPI fill byte */
+
+  byte          unused0; 
+  byte          spiMsgTail;             /* (0x9): msgtail */
+  byte          unused1; 
+  byte          spiRxTail;              /* (0xB): rxtail */
+
+  uint32        unused2[13];            /* (0x0c - 0x3c) reserved */
+
+  byte          spiMsgCtl;              /* (0x40) control byte */
+#define HALF_DUPLEX_W                   1
+#define HALF_DUPLEX_R                   2
+#define SPI_MSG_TYPE_SHIFT              6
+#define SPI_BYTE_CNT_SHIFT              0
+  byte          spiMsgData[63];         /* (0x41 - 0x7f) msg data */
+  byte          spiRxDataFifo[64];      /* (0x80 - 0xbf) rx data */
+  byte          unused3[64];            /* (0xc0 - 0xff) reserved */
+} SpiControl;
+
+#define SPI ((volatile SpiControl * const) SPI_BASE)
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[1];                  /* size chip select configuration */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+
+#endif
+
diff -urN linux.old/arch/mips/bcm963xx/include/6345_intr.h linux.dev/arch/mips/bcm963xx/include/6345_intr.h
--- linux.old/arch/mips/bcm963xx/include/6345_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/6345_intr.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6345_INTR_H
+#define __6345_INTR_H
+
+
+/*=====================================================================*/
+/* BCM6345 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6345 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+#define DMA_ISR_TABLE_OFFSET            (INTERNAL_ISR_TABLE_OFFSET + 13)
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+/* Internal peripheral interrupt IDs */
+#define INTERRUPT_ID_TIMER              (INTERNAL_ISR_TABLE_OFFSET +  0)
+#define INTERRUPT_ID_UART               (INTERNAL_ISR_TABLE_OFFSET +  2)
+#define INTERRUPT_ID_ADSL               (INTERNAL_ISR_TABLE_OFFSET +  3)
+#define INTERRUPT_ID_ATM                (INTERNAL_ISR_TABLE_OFFSET +  4)
+#define INTERRUPT_ID_USB                (INTERNAL_ISR_TABLE_OFFSET +  5)
+#define INTERRUPT_ID_EMAC               (INTERNAL_ISR_TABLE_OFFSET +  8)
+#define INTERRUPT_ID_EPHY               (INTERNAL_ISR_TABLE_OFFSET +  12)
+
+/* DMA channel interrupt IDs */        
+#define INTERRUPT_ID_EMAC_RX_CHAN       (DMA_ISR_TABLE_OFFSET + EMAC_RX_CHAN)
+#define INTERRUPT_ID_EMAC_TX_CHAN       (DMA_ISR_TABLE_OFFSET + EMAC_TX_CHAN)
+#define INTERRUPT_ID_EBI_RX_CHAN        (DMA_ISR_TABLE_OFFSET + EBI_RX_CHAN)
+#define INTERRUPT_ID_EBI_TX_CHAN        (DMA_ISR_TABLE_OFFSET + EBI_TX_CHAN)
+#define INTERRUPT_ID_RESERVED_RX_CHAN   (DMA_ISR_TABLE_OFFSET + RESERVED_RX_CHAN)
+#define INTERRUPT_ID_RESERVED_TX_CHAN   (DMA_ISR_TABLE_OFFSET + RESERVED_TX_CHAN)
+#define INTERRUPT_ID_USB_BULK_RX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_BULK_RX_CHAN)
+#define INTERRUPT_ID_USB_BULK_TX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_BULK_TX_CHAN)
+#define INTERRUPT_ID_USB_CNTL_RX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_CNTL_RX_CHAN)
+#define INTERRUPT_ID_USB_CNTL_TX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_CNTL_TX_CHAN)
+#define INTERRUPT_ID_USB_ISO_RX_CHAN    (DMA_ISR_TABLE_OFFSET + USB_ISO_RX_CHAN)
+#define INTERRUPT_ID_USB_ISO_TX_CHAN    (DMA_ISR_TABLE_OFFSET + USB_ISO_TX_CHAN)
+
+
+#endif  /* __BCM6345_H */
+
diff -urN linux.old/arch/mips/bcm963xx/include/6345_map_part.h linux.dev/arch/mips/bcm963xx/include/6345_map_part.h
--- linux.old/arch/mips/bcm963xx/include/6345_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/6345_map_part.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6345_MAP_H
+#define __BCM6345_MAP_H
+
+
+#include "bcmtypes.h"
+#include "6345_intr.h"
+
+typedef struct IntControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define USB_CLK_EN      0x0100
+#define EMAC_CLK_EN     0x0080
+#define UART_CLK_EN     0x0008
+#define CPU_CLK_EN      0x0001
+
+  uint32        pll_control;
+#define SOFT_RESET	0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  4
+#define EI_CLEAR_SHFT   8
+#define EI_MASK_SHFT    12
+#define EI_INSENS_SHFT  16
+#define EI_LEVEL_SHFT   20
+} IntControl;
+
+#define INTC_BASE     0xfffe0000
+#define PERF ((volatile IntControl * const) INTC_BASE)
+
+#define TIMR_BASE     0xfffe0200    
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+  byte          config;
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define XMITBREAK       0x40
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  uint32        baudword;
+
+  byte          txf_levl;
+  byte          rxf_levl;
+  byte          fifocfg;
+  byte          prog_out;
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;
+  byte          DeltaIPConfig_Mask;
+  byte          DeltaIP_SyncIP;
+  uint16        intMask;
+  uint16        intStatus;
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOEMT       0x0020
+#define RXOVFERR        0x0080
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART_BASE     0xfffe0300
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint16        unused0;
+  byte          unused1;
+  byte          TBusSel;
+
+  uint16        unused2;
+  uint16        GPIODir;
+  byte          unused3;
+  byte          Leds;
+  uint16        GPIOio;
+
+  uint32        UartCtl;
+} GpioControl;
+
+#define GPIO_BASE     0xfffe0400
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+
+#endif
+
diff -urN linux.old/arch/mips/bcm963xx/include/6348_intr.h linux.dev/arch/mips/bcm963xx/include/6348_intr.h
--- linux.old/arch/mips/bcm963xx/include/6348_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/6348_intr.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,74 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6348_INTR_H
+#define __6348_INTR_H
+
+
+/*=====================================================================*/
+/* BCM6348 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6348 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+#define INTERRUPT_ID_TIMER               (INTERNAL_ISR_TABLE_OFFSET + 0)
+#define INTERRUPT_ID_SPI                 (INTERNAL_ISR_TABLE_OFFSET + 1)
+#define INTERRUPT_ID_UART                (INTERNAL_ISR_TABLE_OFFSET + 2)
+#define INTERRUPT_ID_ADSL                (INTERNAL_ISR_TABLE_OFFSET + 4)
+#define INTERRUPT_ID_ATM                 (INTERNAL_ISR_TABLE_OFFSET + 5)
+#define INTERRUPT_ID_USBS                (INTERNAL_ISR_TABLE_OFFSET + 6)
+#define INTERRUPT_ID_EMAC2               (INTERNAL_ISR_TABLE_OFFSET + 7)
+#define INTERRUPT_ID_EMAC1               (INTERNAL_ISR_TABLE_OFFSET + 8)
+#define INTERRUPT_ID_EPHY                (INTERNAL_ISR_TABLE_OFFSET + 9)
+#define INTERRUPT_ID_M2M                 (INTERNAL_ISR_TABLE_OFFSET + 10)
+#define INTERRUPT_ID_ACLC                (INTERNAL_ISR_TABLE_OFFSET + 11)
+#define INTERRUPT_ID_USBH                (INTERNAL_ISR_TABLE_OFFSET + 12)
+#define INTERRUPT_ID_SDRAM               (INTERNAL_ISR_TABLE_OFFSET + 13)
+#define INTERRUPT_ID_USB_CNTL_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 14)
+#define INTERRUPT_ID_USB_CNTL_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 15)
+#define INTERRUPT_ID_USB_BULK_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 16)
+#define INTERRUPT_ID_USB_BULK_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 17)
+#define INTERRUPT_ID_USB_ISO_RX_DMA      (INTERNAL_ISR_TABLE_OFFSET + 18)
+#define INTERRUPT_ID_USB_ISO_TX_DMA      (INTERNAL_ISR_TABLE_OFFSET + 19)
+#define INTERRUPT_ID_EMAC1_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 20)
+#define INTERRUPT_ID_EMAC1_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 21)
+#define INTERRUPT_ID_EMAC2_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 22)
+#define INTERRUPT_ID_EMAC2_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 23)
+#define INTERRUPT_ID_MPI                 (INTERNAL_ISR_TABLE_OFFSET + 24)
+#define INTERRUPT_ID_DG                  (INTERNAL_ISR_TABLE_OFFSET + 25)
+
+
+#endif  /* __BCM6348_H */
+
diff -urN linux.old/arch/mips/bcm963xx/include/6348_map_part.h linux.dev/arch/mips/bcm963xx/include/6348_map_part.h
--- linux.old/arch/mips/bcm963xx/include/6348_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/6348_map_part.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,500 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6348_MAP_H
+#define __BCM6348_MAP_H
+
+#include "bcmtypes.h"
+
+#define PERF_BASE           0xfffe0000
+#define TIMR_BASE           0xfffe0200    
+#define UART_BASE           0xfffe0300
+#define GPIO_BASE           0xfffe0400
+#define MPI_BASE            0xfffe2000    /* MPI control registers */
+#define USB_HOST_BASE       0xfffe1b00    /* USB host registers */
+#define USB_HOST_NON_OHCI   0xfffe1c00    /* USB host non-OHCI registers */
+
+typedef struct PerfControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define EMAC_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+#define USBS_CLK_EN     0x0040
+#define USBH_CLK_EN     0x0100
+
+  uint32        pll_control;
+#define SOFT_RESET 0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+  uint32        unused2[2];     /* (2c) */
+  uint32        PllStrap;       /* (34) */
+#define PLL_N1_SHFT         20
+#define PLL_N1_MASK         (7<<PLL_N1_SHFT)
+#define PLL_N2_SHFT         15
+#define PLL_N2_MASK         (0x1f<<PLL_N2_SHFT)
+#define PLL_M1_REF_SHFT     12
+#define PLL_M1_REF_MASK     (7<<PLL_M1_REF_SHFT)
+#define PLL_M2_REF_SHFT     9
+#define PLL_M2_REF_MASK     (7<<PLL_M2_REF_SHFT)
+#define PLL_M1_CPU_SHFT     6
+#define PLL_M1_CPU_MASK     (7<<PLL_M1_CPU_SHFT)
+#define PLL_M1_BUS_SHFT     3
+#define PLL_M1_BUS_MASK     (7<<PLL_M1_BUS_SHFT)
+#define PLL_M2_BUS_SHFT     0
+#define PLL_M2_BUS_MASK     (7<<PLL_M2_BUS_SHFT)
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint32        GPIODir_high; /* bits 36:32 */
+  uint32        GPIODir;      /* bits 31:00 */
+  uint32        GPIOio_high;  /* bits 36:32 */
+  uint32        GPIOio;       /* bits 31:00 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        GPIOMode;
+#define         GROUP4_DIAG             0x00090000
+#define         GROUP4_UTOPIA           0x00080000
+#define         GROUP4_LEGACY_LED       0x00030000
+#define         GROUP4_MII_SNOOP        0x00020000
+#define         GROUP4_EXT_EPHY         0x00010000
+#define         GROUP3_DIAG             0x00009000
+#define         GROUP3_UTOPIA           0x00008000
+#define         GROUP3_EXT_MII          0x00007000
+#define         GROUP2_DIAG             0x00000900
+#define         GROUP2_PCI              0x00000500
+#define         GROUP1_DIAG             0x00000090
+#define         GROUP1_UTOPIA           0x00000080
+#define         GROUP1_SPI_UART         0x00000060
+#define         GROUP1_SPI_MASTER       0x00000060
+#define         GROUP1_MII_PCCARD       0x00000040
+#define         GROUP1_MII_SNOOP        0x00000020
+#define         GROUP1_EXT_EPHY         0x00000010
+#define         GROUP0_DIAG             0x00000009
+#define         GROUP0_EXT_MII          0x00000007
+
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_TOTAL_BITS_MASK        0x3f
+#define GPIO_NUM_MAX_BITS_MASK          0x1f
+#define GPIO_NUM_TO_MASK(X)             ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) < 32) ? (1 << ((X) & GPIO_NUM_MAX_BITS_MASK)) : (0) )
+
+/* Number to mask conversion macro used for GPIODir_high and GPIOio_high */
+#define GPIO_NUM_MAX_BITS_MASK_HIGH     0x07
+#define GPIO_NUM_TO_MASK_HIGH(X)        ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) >= 32) ? (1 << ((X-32) & GPIO_NUM_MAX_BITS_MASK_HIGH)) : (0) )
+
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[7];                  /* size chip select configuration */
+#define EBI_CS0_BASE            0
+#define EBI_CS1_BASE            1
+#define EBI_CS2_BASE            2
+#define EBI_CS3_BASE            3
+#define PCMCIA_COMMON_BASE      4
+#define PCMCIA_ATTRIBUTE_BASE   5
+#define PCMCIA_IO_BASE          6
+  uint32        unused0[2];             /* reserved */
+  uint32        ebi_control;            /* ebi control */
+  uint32        unused1[4];             /* reserved */
+#define EBI_ACCESS_TIMEOUT      0x000007FF
+  uint32        pcmcia_cntl1;           /* pcmcia control 1 */
+#define PCCARD_CARD_RESET       0x00040000
+#define CARDBUS_ENABLE          0x00008000
+#define PCMCIA_ENABLE           0x00004000
+#define PCMCIA_GPIO_ENABLE      0x00002000
+#define CARDBUS_IDSEL           0x00001F00
+#define VS2_OEN                 0x00000080
+#define VS1_OEN                 0x00000040
+#define VS2_OUT                 0x00000020
+#define VS1_OUT                 0x00000010
+#define VS2_IN                  0x00000008
+#define VS1_IN                  0x00000004
+#define CD2_IN                  0x00000002
+#define CD1_IN                  0x00000001
+#define VS_MASK                 0x0000000C
+#define CD_MASK                 0x00000003
+  uint32        unused2;                /* reserved */
+  uint32        pcmcia_cntl2;           /* pcmcia control 2 */
+#define PCMCIA_BYTESWAP_DIS     0x00000002
+#define PCMCIA_HALFWORD_EN      0x00000001
+#define RW_ACTIVE_CNT_BIT       2
+#define INACTIVE_CNT_BIT        8
+#define CE_SETUP_CNT_BIT        16
+#define CE_HOLD_CNT_BIT         24
+  uint32        unused3[40];            /* reserved */
+
+  uint32        sp0range;               /* PCI to internal system bus address space */
+  uint32        sp0remap;
+  uint32        sp0cfg;
+  uint32        sp1range;
+  uint32        sp1remap;
+  uint32        sp1cfg;
+
+  uint32        EndianCfg;
+
+  uint32        l2pcfgctl;              /* internal system bus to PCI IO/Cfg control */
+#define DIR_CFG_SEL             0x80000000 /* change from PCI I/O access to PCI config access */
+#define DIR_CFG_USEREG          0x40000000 /* use this register info for PCI configuration access */
+#define DEVICE_NUMBER           0x00007C00 /* device number for the PCI configuration access */
+#define FUNC_NUMBER             0x00000300 /* function number for the PCI configuration access */
+#define REG_NUMBER              0x000000FC /* register number for the PCI configuration access */
+#define CONFIG_TYPE             0x00000003 /* configuration type for the PCI configuration access */
+
+  uint32        l2pmrange1;             /* internal system bus to PCI memory space */
+#define PCI_SIZE_64K            0xFFFF0000
+#define PCI_SIZE_128K           0xFFFE0000
+#define PCI_SIZE_256K           0xFFFC0000
+#define PCI_SIZE_512K           0xFFF80000
+#define PCI_SIZE_1M             0xFFF00000
+#define PCI_SIZE_2M             0xFFE00000
+#define PCI_SIZE_4M             0xFFC00000
+#define PCI_SIZE_8M             0xFF800000
+#define PCI_SIZE_16M            0xFF000000
+#define PCI_SIZE_32M            0xFE000000
+  uint32        l2pmbase1;              /* kseg0 or kseg1 address & 0x1FFFFFFF */
+  uint32        l2pmremap1;
+#define CARDBUS_MEM             0x00000004
+#define MEM_WINDOW_EN           0x00000001
+  uint32        l2pmrange2;
+  uint32        l2pmbase2;
+  uint32        l2pmremap2;
+  uint32        l2piorange;             /* internal system bus to PCI I/O space */
+  uint32        l2piobase;
+  uint32        l2pioremap;
+
+  uint32        pcimodesel;
+#define PCI2_INT_BUS_RD_PREFECH 0x000000F0
+#define PCI_BAR2_NOSWAP         0x00000002 /* BAR at offset 0x20 */
+#define PCI_BAR1_NOSWAP         0x00000001 /* BAR at affset 0x1c */
+
+  uint32        pciintstat;             /* PCI interrupt mask/status */
+#define MAILBOX1_SENT           0x08
+#define MAILBOX0_SENT           0x04
+#define MAILBOX1_MSG_RCV        0x02
+#define MAILBOX0_MSG_RCV        0x01
+  uint32        locbuscntrl;            /* internal system bus control */
+#define DIR_U2P_NOSWAP          0x00000002
+#define EN_PCI_GPIO             0x00000001
+  uint32        locintstat;             /* internal system bus interrupt mask/status */
+#define CSERR                   0x0200
+#define SERR                    0x0100
+#define EXT_PCI_INT             0x0080
+#define DIR_FAILED              0x0040
+#define DIR_COMPLETE            0x0020
+#define PCI_CFG                 0x0010
+  uint32        unused5[7];
+
+  uint32        mailbox0;
+  uint32        mailbox1;
+
+  uint32        pcicfgcntrl;            /* internal system bus PCI configuration control */
+#define PCI_CFG_REG_WRITE_EN    0x00000080
+#define PCI_CFG_ADDR            0x0000003C
+  uint32        pcicfgdata;             /* internal system bus PCI configuration data */
+
+  uint32        locch2ctl;              /* PCI to interrnal system bus DMA (downstream) local control */
+#define MPI_DMA_HALT            0x00000008  /* idle after finish current memory burst */
+#define MPI_DMA_PKT_HALT        0x00000004  /* idle after an EOP flag is detected */
+#define MPI_DMA_STALL           0x00000002  /* idle after an EOP flag is detected */
+#define MPI_DMA_ENABLE          0x00000001  /* set to enable channel */
+  uint32        locch2intStat;
+#define MPI_DMA_NO_DESC         0x00000004  /* no valid descriptors */
+#define MPI_DMA_DONE            0x00000002  /* packet xfer complete */
+#define MPI_DMA_BUFF_DONE       0x00000001  /* buffer done */
+  uint32        locch2intMask;
+  uint32        unused6;
+  uint32        locch2descaddr;
+  uint32        locch2status1;
+#define LOCAL_DESC_STATE        0xE0000000
+#define PCI_DESC_STATE          0x1C000000
+#define BYTE_DONE               0x03FFC000
+#define RING_ADDR               0x00003FFF
+  uint32        locch2status2;
+#define BUFPTR_OFFSET           0x1FFF0000
+#define PCI_MASTER_STATE        0x000000C0
+#define LOC_MASTER_STATE        0x00000038
+#define CONTROL_STATE           0x00000007
+  uint32        unused7;
+
+  uint32        locch1Ctl;              /*internal system bus to PCI DMA (upstream) local control */
+#define DMA_U2P_LE              0x00000200  /* local bus is little endian */
+#define DMA_U2P_NOSWAP          0x00000100  /* lccal bus is little endian but no data swapped */
+  uint32        locch1intstat;
+  uint32        locch1intmask;
+  uint32        unused8;
+  uint32        locch1descaddr;
+  uint32        locch1status1;
+  uint32        locch1status2;
+  uint32        unused9;
+
+  uint32        pcich1ctl;              /* internal system bus to PCI DMA PCI control */
+  uint32        pcich1intstat;
+  uint32        pcich1intmask;
+  uint32        pcich1descaddr;
+  uint32        pcich1status1;
+  uint32        pcich1status2;
+
+  uint32        pcich2Ctl;              /* PCI to internal system bus DMA PCI control */
+  uint32        pcich2intstat;
+  uint32        pcich2intmask;
+  uint32        pcich2descaddr;
+  uint32        pcich2status1;
+  uint32        pcich2status2;
+
+  uint32        perm_id;                /* permanent device and vendor id */
+  uint32        perm_rev;               /* permanent revision id */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+/* PCI configuration address space start offset 0x40 */
+#define BRCM_PCI_CONFIG_TIMER               0x40
+#define BRCM_PCI_CONFIG_TIMER_RETRY_MASK	0x0000FF00
+#define BRCM_PCI_CONFIG_TIMER_TRDY_MASK		0x000000FF
+
+/* USB host non-Open HCI register, USB_HOST_NON_OHCI, bit definitions. */
+#define NON_OHCI_ENABLE_PORT1   0x00000001 /* Use USB port 1 for host, not dev */
+#define NON_OHCI_BYTE_SWAP      0x00000008 /* Swap USB host registers */
+
+#define USBH_NON_OHCI ((volatile unsigned long * const) USB_HOST_NON_OHCI)
+
+#endif
+
diff -urN linux.old/arch/mips/bcm963xx/include/bcm_intr.h linux.dev/arch/mips/bcm963xx/include/bcm_intr.h
--- linux.old/arch/mips/bcm963xx/include/bcm_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/bcm_intr.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM_INTR_H
+#define __BCM_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#if defined(CONFIG_BCM96338)
+#include <6338_intr.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_intr.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_intr.h>
+#endif
+
+/* defines */
+struct pt_regs;
+typedef int (*FN_HANDLER) (int, void *);
+
+/* prototypes */
+extern void enable_brcm_irq(unsigned int irq);
+extern void disable_brcm_irq(unsigned int irq);
+extern int request_external_irq(unsigned int irq,
+    FN_HANDLER handler, unsigned long irqflags, 
+    const char * devname, void *dev_id);
+extern unsigned int BcmHalMapInterrupt(FN_HANDLER isr, unsigned int param,
+    unsigned int interruptId);
+extern void dump_intr_regs(void);
+
+/* compatibility definitions */
+#define BcmHalInterruptEnable(irq)      enable_brcm_irq( irq )
+#define BcmHalInterruptDisable(irq)     disable_brcm_irq( irq )
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif
diff -urN linux.old/arch/mips/bcm963xx/include/bcm_map_part.h linux.dev/arch/mips/bcm963xx/include/bcm_map_part.h
--- linux.old/arch/mips/bcm963xx/include/bcm_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/bcm_map_part.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM_MAP_PART_H
+#define __BCM_MAP_PART_H
+
+#if defined(CONFIG_BCM96338)
+#include <6338_map_part.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_map_part.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_map_part.h>
+#endif
+
+#endif
+
diff -urN linux.old/arch/mips/bcm963xx/include/bcmpci.h linux.dev/arch/mips/bcm963xx/include/bcmpci.h
--- linux.old/arch/mips/bcm963xx/include/bcmpci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/bcmpci.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,87 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+//
+// bcmpci.h - bcm96348 PCI, Cardbus, and PCMCIA definition
+//
+#ifndef BCMPCI_H
+#define BCMPCI_H
+
+/* Memory window in internal system bus address space */ 
+#define BCM_PCI_MEM_BASE        0x08000000
+/* IO window in internal system bus address space */ 
+#define BCM_PCI_IO_BASE         0x0C000000
+
+#define BCM_PCI_ADDR_MASK       0x1fffffff
+
+/* Memory window size (range) */
+#define BCM_PCI_MEM_SIZE_16MB   0x01000000
+/* IO window size (range) */
+#define BCM_PCI_IO_SIZE_64KB    0x00010000
+
+/* PCI Configuration and I/O space acesss */
+#define BCM_PCI_CFG(d, f, o)    ( (d << 11) | (f << 8) | (o/4 << 2) )
+
+/* fake USB PCI slot */
+#define USB_HOST_SLOT           9
+#define USB_BAR0_MEM_SIZE       0x0800
+
+#define BCM_HOST_MEM_SPACE1     0x10000000
+#define BCM_HOST_MEM_SPACE2     0x00000000
+
+/* 
+ * EBI bus clock is 33MHz and share with PCI bus
+ * each clock cycle is 30ns.
+ */
+/* attribute memory access wait cnt for 4306 */
+#define PCMCIA_ATTR_CE_HOLD     3  // data hold time 70ns
+#define PCMCIA_ATTR_CE_SETUP    3  // data setup time 50ns
+#define PCMCIA_ATTR_INACTIVE    6  // time between read/write cycles 180ns. For the total cycle time 600ns (cnt1+cnt2+cnt3+cnt4)
+#define PCMCIA_ATTR_ACTIVE      10 // OE/WE pulse width 300ns
+
+/* common memory access wait cnt for 4306 */
+#define PCMCIA_MEM_CE_HOLD      1  // data hold time 30ns
+#define PCMCIA_MEM_CE_SETUP     1  // data setup time 30ns
+#define PCMCIA_MEM_INACTIVE     2  // time between read/write cycles 40ns. For the total cycle time 250ns (cnt1+cnt2+cnt3+cnt4)
+#define PCMCIA_MEM_ACTIVE       5  // OE/WE pulse width 150ns
+
+#define PCCARD_VCC_MASK     0x00070000  // Mask Reset also
+#define PCCARD_VCC_33V      0x00010000
+#define PCCARD_VCC_50V      0x00020000
+
+typedef enum {
+    MPI_CARDTYPE_NONE,      // No Card in slot
+    MPI_CARDTYPE_PCMCIA,    // 16-bit PCMCIA card in slot    
+    MPI_CARDTYPE_CARDBUS,   // 32-bit CardBus card in slot
+}   CardType;
+
+#define CARDBUS_SLOT        0    // Slot 0 is default for CardBus
+
+#define pcmciaAttrOffset    0x00200000
+#define pcmciaMemOffset     0x00000000
+// Needs to be right above PCI I/O space. Give 0x8000 (32K) to PCMCIA. 
+#define pcmciaIoOffset      (BCM_PCI_IO_BASE + 0x80000)
+// Base Address is that mapped into the MPI ChipSelect registers. 
+// UBUS bridge MemoryWindow 0 outputs a 0x00 for the base.
+#define pcmciaBase          0xbf000000
+#define pcmciaAttr          (pcmciaAttrOffset | pcmciaBase)
+#define pcmciaMem           (pcmciaMemOffset  | pcmciaBase)
+#define pcmciaIo            (pcmciaIoOffset   | pcmciaBase)
+
+#endif
diff -urN linux.old/arch/mips/bcm963xx/include/bcmTag.h linux.dev/arch/mips/bcm963xx/include/bcmTag.h
--- linux.old/arch/mips/bcm963xx/include/bcmTag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/bcmTag.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,153 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+//**************************************************************************************
+// File Name  : bcmTag.h
+//
+// Description: add tag with validation system to the firmware image file to be uploaded
+//              via http
+//
+// Created    : 02/28/2002  seanl
+//**************************************************************************************
+
+#ifndef _BCMTAG_H_
+#define _BCMTAG_H_
+
+
+#define BCM_SIG_1   "Broadcom Corporation"
+#define BCM_SIG_2   "ver. 2.0"          // was "firmware version 2.0" now it is split 6 char out for chip id.
+
+#define BCM_TAG_VER         "6"
+#define BCM_TAG_VER_LAST    "26"
+
+// file tag (head) structure all is in clear text except validationTokens (crc, md5, sha1, etc). Total: 128 unsigned chars
+#define TAG_LEN         256
+#define TAG_VER_LEN     4
+#define SIG_LEN         20
+#define SIG_LEN_2       14   // Original second SIG = 20 is now devided into 14 for SIG_LEN_2 and 6 for CHIP_ID
+#define CHIP_ID_LEN		6	
+#define IMAGE_LEN       10
+#define ADDRESS_LEN     12
+#define FLAG_LEN        2
+#define TOKEN_LEN       20
+#define BOARD_ID_LEN    16
+#define RESERVED_LEN    (TAG_LEN - TAG_VER_LEN - SIG_LEN - SIG_LEN_2 - CHIP_ID_LEN - BOARD_ID_LEN - \
+                        (4*IMAGE_LEN) - (3*ADDRESS_LEN) - (3*FLAG_LEN) - (2*TOKEN_LEN))
+
+
+// TAG for downloadable image (kernel plus file system)
+typedef struct _FILE_TAG
+{
+    unsigned char tagVersion[TAG_VER_LEN];       // tag version.  Will be 2 here.
+    unsigned char signiture_1[SIG_LEN];          // text line for company info
+    unsigned char signiture_2[SIG_LEN_2];        // additional info (can be version number)
+    unsigned char chipId[CHIP_ID_LEN];			 // chip id 
+    unsigned char boardId[BOARD_ID_LEN];         // board id
+    unsigned char bigEndian[FLAG_LEN];           // if = 1 - big, = 0 - little endia of the host
+    unsigned char totalImageLen[IMAGE_LEN];      // the sum of all the following length
+    unsigned char cfeAddress[ADDRESS_LEN];       // if non zero, cfe starting address
+    unsigned char cfeLen[IMAGE_LEN];             // if non zero, cfe size in clear ASCII text.
+    unsigned char rootfsAddress[ADDRESS_LEN];    // if non zero, filesystem starting address
+    unsigned char rootfsLen[IMAGE_LEN];          // if non zero, filesystem size in clear ASCII text.
+    unsigned char kernelAddress[ADDRESS_LEN];    // if non zero, kernel starting address
+    unsigned char kernelLen[IMAGE_LEN];          // if non zero, kernel size in clear ASCII text.
+    unsigned char dualImage[FLAG_LEN];           // if 1, dual image
+    unsigned char inactiveLen[FLAG_LEN];         // if 1, the image is INACTIVE; if 0, active 
+    unsigned char reserved[RESERVED_LEN];        // reserved for later use
+    unsigned char imageValidationToken[TOKEN_LEN];// image validation token - can be crc, md5, sha;  for
+                                                 // now will be 4 unsigned char crc
+    unsigned char tagValidationToken[TOKEN_LEN]; // validation token for tag(from signiture_1 to end of // mageValidationToken)
+} FILE_TAG, *PFILE_TAG;
+
+#define CRC32_INIT_VALUE 0xffffffff /* Initial CRC32 checksum value */
+#define CRC_LEN 4
+
+// only included if for bcmTag.exe program
+#ifdef BCMTAG_EXE_USE
+
+static unsigned long Crc32_table[256] = {
+    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
+    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
+    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
+    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
+    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
+    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
+    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
+    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
+    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
+    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
+    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
+    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
+    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
+    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
+    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
+    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
+    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
+    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
+    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
+    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
+    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
+    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
+    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
+    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
+    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
+    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
+    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
+    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
+    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
+    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
+    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
+    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
+    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
+    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
+    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
+    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
+    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
+    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
+    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
+    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
+    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
+    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
+    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
+    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
+    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
+    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
+    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
+    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
+    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
+    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
+    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
+    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
+    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
+    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
+    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
+};
+#endif // BCMTAG_USE
+
+
+#endif // _BCMTAG_H_
+
diff -urN linux.old/arch/mips/bcm963xx/include/bcmtypes.h linux.dev/arch/mips/bcm963xx/include/bcmtypes.h
--- linux.old/arch/mips/bcm963xx/include/bcmtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/bcmtypes.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+//
+// bcmtypes.h - misc useful typedefs
+//
+#ifndef BCMTYPES_H
+#define BCMTYPES_H
+
+// These are also defined in typedefs.h in the application area, so I need to
+// protect against re-definition.
+
+#ifndef _TYPEDEFS_H_
+typedef unsigned char   uint8;
+typedef unsigned short  uint16;
+typedef unsigned long   uint32;
+typedef signed char     int8;
+typedef signed short    int16;
+typedef signed long     int32;
+#if !defined(__cplusplus)
+typedef	int	bool;
+#endif
+#endif
+
+typedef unsigned char   byte;
+// typedef unsigned long   sem_t;
+
+typedef unsigned long   HANDLE,*PULONG,DWORD,*PDWORD;
+typedef signed long     LONG,*PLONG;
+
+typedef unsigned int    *PUINT;
+typedef signed int      INT;
+
+typedef unsigned short  *PUSHORT;
+typedef signed short    SHORT,*PSHORT;
+typedef unsigned short  WORD,*PWORD;
+
+typedef unsigned char   *PUCHAR;
+typedef signed char     *PCHAR;
+
+typedef void            *PVOID;
+
+typedef unsigned char   BOOLEAN, *PBOOL, *PBOOLEAN;
+
+typedef unsigned char   BYTE,*PBYTE;
+
+//#ifndef __GNUC__
+//The following has been defined in Vxworks internally: vxTypesOld.h
+//redefine under vxworks will cause error
+typedef signed int      *PINT;
+
+typedef signed char     INT8;
+typedef signed short    INT16;
+typedef signed long     INT32;
+
+typedef unsigned char   UINT8;
+typedef unsigned short  UINT16;
+typedef unsigned long   UINT32;
+
+typedef unsigned char   UCHAR;
+typedef unsigned short  USHORT;
+typedef unsigned int    UINT;
+typedef unsigned long   ULONG;
+
+typedef void            VOID;
+typedef unsigned char   BOOL;
+
+//#endif  /* __GNUC__ */
+
+
+// These are also defined in typedefs.h in the application area, so I need to
+// protect against re-definition.
+#ifndef TYPEDEFS_H
+
+// Maximum and minimum values for a signed 16 bit integer.
+#define MAX_INT16 32767
+#define MIN_INT16 -32768
+
+// Useful for true/false return values.  This uses the
+// Taligent notation (k for constant).
+typedef enum
+{
+    kFalse = 0,
+    kTrue = 1
+} Bool;
+
+#endif
+
+/* macros to protect against unaligned accesses */
+
+#if 0
+/* first arg is an address, second is a value */
+#define PUT16( a, d ) { 		\
+  *((byte *)a) = (byte)((d)>>8); 	\
+  *(((byte *)a)+1) = (byte)(d); 	\
+}
+
+#define PUT32( a, d ) { 		\
+  *((byte *)a) = (byte)((d)>>24); 	\
+  *(((byte *)a)+1) = (byte)((d)>>16); 	\
+  *(((byte *)a)+2) = (byte)((d)>>8); 	\
+  *(((byte *)a)+3) = (byte)(d); 	\
+}
+
+/* first arg is an address, returns a value */
+#define GET16( a ) ( 			\
+  (*((byte *)a) << 8) |			\
+  (*(((byte *)a)+1))	 		\
+)
+
+#define GET32( a ) ( 			\
+  (*((byte *)a) << 24)     |		\
+  (*(((byte *)a)+1) << 16) | 		\
+  (*(((byte *)a)+2) << 8)  | 		\
+  (*(((byte *)a)+3))	 		\
+)
+#endif
+
+#ifndef YES
+#define YES 1
+#endif
+
+#ifndef NO
+#define NO  0
+#endif
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+#define READ32(addr)        (*(volatile UINT32 *)((ULONG)&addr))
+#define READ16(addr)        (*(volatile UINT16 *)((ULONG)&addr))
+#define READ8(addr)         (*(volatile UINT8  *)((ULONG)&addr))
+
+#endif
diff -urN linux.old/arch/mips/bcm963xx/include/board.h linux.dev/arch/mips/bcm963xx/include/board.h
--- linux.old/arch/mips/bcm963xx/include/board.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/include/board.h	2006-08-25 01:52:34.000000000 +0200
@@ -0,0 +1,373 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  board.h                                                  */
+/*   DATE:    97/02/18                                                 */
+/*   PURPOSE: Board specific information.  This module should include  */
+/*            all base device addresses and board specific macros.     */
+/*                                                                     */
+/***********************************************************************/
+#ifndef _BOARD_H
+#define _BOARD_H
+
+/*****************************************************************************/
+/*                    Misc board definitions                                 */
+/*****************************************************************************/
+
+#define	DYING_GASP_API
+
+/*****************************************************************************/
+/*                    Physical Memory Map                                    */
+/*****************************************************************************/
+
+#define PHYS_DRAM_BASE           0x00000000     /* Dynamic RAM Base */
+#define PHYS_FLASH_BASE          0x1FC00000     /* Flash Memory         */
+
+/*****************************************************************************/
+/* Note that the addresses above are physical addresses and that programs    */
+/* have to use converted addresses defined below:                            */
+/*****************************************************************************/
+#define DRAM_BASE           (0x80000000 | PHYS_DRAM_BASE)   /* cached DRAM */
+#define DRAM_BASE_NOCACHE   (0xA0000000 | PHYS_DRAM_BASE)   /* uncached DRAM */
+#define FLASH_BASE          (0xA0000000 | PHYS_FLASH_BASE)  /* uncached Flash  */
+
+/*****************************************************************************/
+/*  Select the PLL value to get the desired CPU clock frequency.             */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+#define FPERIPH            50000000
+
+#define ONEK                            1024
+#define BLK64K                          (64*ONEK)
+#define FLASH45_BLKS_BOOT_ROM           1
+#define FLASH45_LENGTH_BOOT_ROM         (FLASH45_BLKS_BOOT_ROM * BLK64K)
+#define FLASH_RESERVED_AT_END           (64*ONEK) /*reserved for PSI, scratch pad*/
+    
+/*****************************************************************************/
+/* Note that the addresses above are physical addresses and that programs    */
+/* have to use converted addresses defined below:                            */
+/*****************************************************************************/
+#define DRAM_BASE           (0x80000000 | PHYS_DRAM_BASE)   /* cached DRAM */
+#define DRAM_BASE_NOCACHE   (0xA0000000 | PHYS_DRAM_BASE)   /* uncached DRAM */
+#define FLASH_BASE          (0xA0000000 | PHYS_FLASH_BASE)  /* uncached Flash  */
+
+/*****************************************************************************/
+/*  Select the PLL value to get the desired CPU clock frequency.             */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+#define FPERIPH            50000000
+    
+#define SDRAM_TYPE_ADDRESS_OFFSET   16
+#define NVRAM_DATA_OFFSET           0x0580
+#define NVRAM_DATA_ID               0x0f1e2d3c
+#define BOARD_SDRAM_TYPE            *(unsigned long *) \
+                                    (FLASH_BASE + SDRAM_TYPE_ADDRESS_OFFSET)
+
+#define ONEK                1024
+#define BLK64K              (64*ONEK)
+
+// nvram and psi flash definitions for 45
+#define FLASH45_LENGTH_NVRAM            ONEK            // 1k nvram 
+#define NVRAM_PSI_DEFAULT               24              // default psi in K byes
+
+/*****************************************************************************/
+/*       NVRAM Offset and definition                                         */
+/*****************************************************************************/
+
+#define NVRAM_VERSION_NUMBER            2
+#define NVRAM_VERSION_NUMBER_ADDRESS    0
+
+#define NVRAM_BOOTLINE_LEN              256
+#define NVRAM_BOARD_ID_STRING_LEN       16
+#define NVRAM_MAC_ADDRESS_LEN           6
+#define NVRAM_MAC_COUNT_MAX             32
+
+/*****************************************************************************/
+/*       Misc Offsets                                                        */
+/*****************************************************************************/
+
+#define CFE_VERSION_OFFSET           0x0570
+#define CFE_VERSION_MARK_SIZE        5
+#define CFE_VERSION_SIZE             5
+
+typedef struct
+{
+    unsigned long ulVersion;
+    char szBootline[NVRAM_BOOTLINE_LEN];
+    char szBoardId[NVRAM_BOARD_ID_STRING_LEN];
+    unsigned long ulReserved1[2];
+    unsigned long ulNumMacAddrs;
+    unsigned char ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    char chReserved[2];
+    unsigned long ulCheckSum;
+} NVRAM_DATA, *PNVRAM_DATA;
+
+
+/*****************************************************************************/
+/*          board ioctl calls for flash, led and some other utilities        */
+/*****************************************************************************/
+
+
+/* Defines. for board driver */
+#define BOARD_IOCTL_MAGIC       'B'
+#define BOARD_DRV_MAJOR          206
+
+#define MAC_ADDRESS_ANY         (unsigned long) -1
+
+#define BOARD_IOCTL_FLASH_INIT \
+    _IOWR(BOARD_IOCTL_MAGIC, 0, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_FLASH_WRITE \
+    _IOWR(BOARD_IOCTL_MAGIC, 1, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_FLASH_READ \
+    _IOWR(BOARD_IOCTL_MAGIC, 2, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_NR_PAGES \
+    _IOWR(BOARD_IOCTL_MAGIC, 3, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_DUMP_ADDR \
+    _IOWR(BOARD_IOCTL_MAGIC, 4, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_MEMORY \
+    _IOWR(BOARD_IOCTL_MAGIC, 5, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_MIPS_SOFT_RESET \
+    _IOWR(BOARD_IOCTL_MAGIC, 6, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_LED_CTRL \
+    _IOWR(BOARD_IOCTL_MAGIC, 7, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_ID \
+    _IOWR(BOARD_IOCTL_MAGIC, 8, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 9, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_RELEASE_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 10, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_PSI_SIZE \
+    _IOWR(BOARD_IOCTL_MAGIC, 11, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_SDRAM_SIZE \
+    _IOWR(BOARD_IOCTL_MAGIC, 12, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_MONITOR_FD \
+    _IOWR(BOARD_IOCTL_MAGIC, 13, BOARD_IOCTL_PARMS)
+    
+#define BOARD_IOCTL_WAKEUP_MONITOR_TASK \
+    _IOWR(BOARD_IOCTL_MAGIC, 14, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_BOOTLINE \
+    _IOWR(BOARD_IOCTL_MAGIC, 15, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_BOOTLINE \
+    _IOWR(BOARD_IOCTL_MAGIC, 16, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_BASE_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 17, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_CHIP_ID \
+    _IOWR(BOARD_IOCTL_MAGIC, 18, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_NUM_ENET \
+    _IOWR(BOARD_IOCTL_MAGIC, 19, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_CFE_VER \
+    _IOWR(BOARD_IOCTL_MAGIC, 20, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_ENET_CFG \
+    _IOWR(BOARD_IOCTL_MAGIC, 21, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_WLAN_ANT_INUSE \
+    _IOWR(BOARD_IOCTL_MAGIC, 22, BOARD_IOCTL_PARMS)
+    
+#define BOARD_IOCTL_SET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 23, BOARD_IOCTL_PARMS)        
+
+#define BOARD_IOCTL_GET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 24, BOARD_IOCTL_PARMS)        
+
+#define BOARD_IOCTL_UNSET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 25, BOARD_IOCTL_PARMS) 
+
+#define BOARD_IOCTL_SET_SES_LED \
+    _IOWR(BOARD_IOCTL_MAGIC, 26, BOARD_IOCTL_PARMS)
+
+//<<JUNHON, 2004/09/15, get reset button status , tim hou , 05/04/12
+#define RESET_BUTTON_UP           1
+#define RESET_BUTTON_PRESSDOWN    0
+#define BOARD_IOCTL_GET_RESETHOLD \
+    _IOWR(BOARD_IOCTL_MAGIC, 27, BOARD_IOCTL_PARMS)
+//>>JUNHON, 2004/09/15    
+    
+// for the action in BOARD_IOCTL_PARMS for flash operation
+typedef enum 
+{
+    PERSISTENT,
+    NVRAM,
+    BCM_IMAGE_CFE,
+    BCM_IMAGE_FS,
+    BCM_IMAGE_KERNEL,
+    BCM_IMAGE_WHOLE,
+    SCRATCH_PAD,
+    FLASH_SIZE,
+} BOARD_IOCTL_ACTION;
+    
+    
+typedef struct boardIoctParms
+{
+    char *string;
+    char *buf;
+    int strLen;
+    int offset;
+    BOARD_IOCTL_ACTION  action;        /* flash read/write: nvram, persistent, bcm image */
+    int result;
+} BOARD_IOCTL_PARMS;
+
+
+// LED defines 
+typedef enum
+{   
+    kLedAdsl,
+    kLedWireless,
+    kLedUsb,
+    kLedHpna,
+    kLedWanData,
+    kLedPPP,
+    kLedVoip,
+    kLedSes,
+    kLedLan,
+    kLedSelfTest,
+    kLedEnd,                // NOTE: Insert the new led name before this one.  Alway stay at the end.
+} BOARD_LED_NAME;
+
+typedef enum
+{
+    kLedStateOff,                        /* turn led off */
+    kLedStateOn,                         /* turn led on */
+    kLedStateFail,                       /* turn led on red */
+    kLedStateBlinkOnce,                  /* blink once, ~100ms and ignore the same call during the 100ms period */
+    kLedStateSlowBlinkContinues,         /* slow blink continues at ~600ms interval */
+    kLedStateFastBlinkContinues,         /* fast blink continues at ~200ms interval */
+} BOARD_LED_STATE;
+
+
+// virtual and physical map pair defined in board.c
+typedef struct ledmappair
+{
+    BOARD_LED_NAME ledName;         // virtual led name
+    BOARD_LED_STATE ledInitState;   // initial led state when the board boots.
+    unsigned short ledMask;         // physical GPIO pin mask
+    unsigned short ledActiveLow;    // reset bit to turn on LED
+    unsigned short ledMaskFail;     // physical GPIO pin mask for state failure
+    unsigned short ledActiveLowFail;// reset bit to turn on LED
+} LED_MAP_PAIR, *PLED_MAP_PAIR;
+
+typedef void (*HANDLE_LED_FUNC)(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState);
+
+/* Flash storage address information that is determined by the flash driver. */
+typedef struct flashaddrinfo
+{
+    int flash_persistent_start_blk;
+    int flash_persistent_number_blk;
+    int flash_persistent_length;
+    unsigned long flash_persistent_blk_offset;
+    int flash_scratch_pad_start_blk;         // start before psi (SP_BUF_LEN)
+    int flash_scratch_pad_number_blk;
+    int flash_scratch_pad_length;
+    unsigned long flash_scratch_pad_blk_offset;
+    int flash_nvram_start_blk;
+    int flash_nvram_number_blk;
+    int flash_nvram_length;
+    unsigned long flash_nvram_blk_offset;
+} FLASH_ADDR_INFO, *PFLASH_ADDR_INFO;
+
+// scratch pad defines
+/* SP - Persisten Scratch Pad format:
+       sp header        : 32 bytes
+       tokenId-1        : 8 bytes
+       tokenId-1 len    : 4 bytes
+       tokenId-1 data    
+       ....
+       tokenId-n        : 8 bytes
+       tokenId-n len    : 4 bytes
+       tokenId-n data    
+*/
+
+#define MAGIC_NUM_LEN       8
+#define MAGIC_NUMBER        "gOGoBrCm"
+#define TOKEN_NAME_LEN      16
+#define SP_VERSION          1
+#define SP_MAX_LEN          8 * 1024            // 8k buf before psi
+#define SP_RESERVERD        16
+
+typedef struct _SP_HEADER
+{
+    char SPMagicNum[MAGIC_NUM_LEN];             // 8 bytes of magic number
+    int SPVersion;                              // version number
+    int SPUsedLen;                              // used sp len   
+    char SPReserved[SP_RESERVERD];              // reservied, total 32 bytes
+} SP_HEADER, *PSP_HEADER;
+
+typedef struct _TOKEN_DEF
+{
+    char tokenName[TOKEN_NAME_LEN];
+    int tokenLen;
+} SP_TOKEN, *PSP_TOKEN;
+
+
+/*****************************************************************************/
+/*          Function Prototypes                                              */
+/*****************************************************************************/
+#if !defined(__ASM_ASM_H)
+void dumpaddr( unsigned char *pAddr, int nLen );
+
+int kerSysNvRamGet(char *string, int strLen, int offset);
+int kerSysNvRamSet(char *string, int strLen, int offset);
+int kerSysPersistentGet(char *string, int strLen, int offset);
+int kerSysPersistentSet(char *string, int strLen, int offset);
+int kerSysScratchPadGet(char *tokName, char *tokBuf, int tokLen);
+int kerSysScratchPadSet(char *tokName, char *tokBuf, int tokLen);
+int kerSysBcmImageSet( int flash_start_addr, char *string, int size);
+int kerSysGetMacAddress( unsigned char *pucaAddr, unsigned long ulId );
+int kerSysReleaseMacAddress( unsigned char *pucaAddr );
+int kerSysGetSdramSize( void );
+void kerSysGetBootline(char *string, int strLen);
+void kerSysSetBootline(char *string, int strLen);
+void kerSysMipsSoftReset(void);
+void kerSysLedCtrl(BOARD_LED_NAME, BOARD_LED_STATE);
+void kerSysLedRegisterHwHandler( BOARD_LED_NAME, HANDLE_LED_FUNC, int );
+int kerSysFlashSizeGet(void);
+void kerSysRegisterDyingGaspHandler(char *devname, void *cbfn, void *context);
+void kerSysDeregisterDyingGaspHandler(char *devname);    
+void kerSysWakeupMonitorTask( void );
+#endif
+
+#define BOOT_CFE     0
+#define BOOT_REDBOOT 1
+
+extern int boot_loader_type;
+
+#endif /* _BOARD_H */
+
diff -urN linux.old/arch/mips/bcm963xx/int-handler.S linux.dev/arch/mips/bcm963xx/int-handler.S
--- linux.old/arch/mips/bcm963xx/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/int-handler.S	2006-08-25 02:13:33.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * Generic interrupt handler for Broadcom MIPS boards
+ */
+
+#include <linux/autoconf.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware
+ *             4        Hardware
+ *             5        Hardware
+ *             6        Hardware
+ *             7        R4k timer
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(brcmIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	noreorder
+	.set	at
+
+	jal		plat_irq_dispatch
+	move	a0, sp
+
+	j	ret_from_irq
+	nop
+		
+	END(brcmIRQ)
diff -urN linux.old/arch/mips/bcm963xx/irq.c linux.dev/arch/mips/bcm963xx/irq.c
--- linux.old/arch/mips/bcm963xx/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/irq.c	2006-08-25 03:54:34.000000000 +0200
@@ -0,0 +1,256 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * Interrupt control functions for Broadcom 963xx MIPS boards
+ */
+
+#include <asm/atomic.h>
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/signal.h>
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+static void irq_dispatch_int(struct pt_regs *regs)
+{
+	unsigned int pendingIrqs;
+	static unsigned int irqBit;
+	static unsigned int isrNumber = 31;
+
+	pendingIrqs = PERF->IrqStatus & PERF->IrqMask;
+	if (!pendingIrqs) {
+		return;
+	}
+
+	while (1) {
+	irqBit <<= 1;
+	isrNumber++;
+	if (isrNumber == 32) {
+		isrNumber = 0;
+		irqBit = 0x1;
+	}
+	if (pendingIrqs & irqBit) {
+			PERF->IrqMask &= ~irqBit; // mask
+			do_IRQ(isrNumber + INTERNAL_ISR_TABLE_OFFSET);
+		break;
+	}
+	}
+}
+
+static void irq_dispatch_ext(uint32 irq)
+{
+	if (!(PERF->ExtIrqCfg & (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT)))) {
+	printk("**** Ext IRQ mask. Should not dispatch ****\n");
+	}
+	/* disable and clear interrupt in the controller */
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_CLEAR_SHFT));
+	PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));
+	do_IRQ(irq);
+}
+
+
+extern void brcm_timer_interrupt(struct pt_regs *regs);
+
+asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
+{
+	u32 cause;
+	while((cause = (read_c0_cause()& CAUSEF_IP))) {
+		if (cause & CAUSEF_IP7)
+			brcm_timer_interrupt(regs);
+		else if (cause & CAUSEF_IP2)
+			irq_dispatch_int(regs);
+		else if (cause & CAUSEF_IP3)
+			irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_0);
+		else if (cause & CAUSEF_IP4)
+			irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_1);
+		else if (cause & CAUSEF_IP5)
+			irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_2);
+		else if (cause & CAUSEF_IP6)
+			irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_3);
+		local_irq_disable();
+	}
+}
+
+
+void enable_brcm_irq(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if( irq >= INTERNAL_ISR_TABLE_OFFSET ) {
+	PERF->IrqMask |= (1 << (irq - INTERNAL_ISR_TABLE_OFFSET));
+	}
+	else if (irq >= INTERRUPT_ID_EXTERNAL_0 && irq <= INTERRUPT_ID_EXTERNAL_3) {
+	/* enable and clear interrupt in the controller */
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_CLEAR_SHFT));
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));
+	}
+	local_irq_restore(flags);
+}
+
+void disable_brcm_irq(unsigned int irq)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if( irq >= INTERNAL_ISR_TABLE_OFFSET ) {
+	PERF->IrqMask &= ~(1 << (irq - INTERNAL_ISR_TABLE_OFFSET));
+	}
+	else if (irq >= INTERRUPT_ID_EXTERNAL_0 && irq <= INTERRUPT_ID_EXTERNAL_3) {
+	/* disable interrupt in the controller */
+	PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));
+	}
+	local_irq_restore(flags);
+}
+
+void ack_brcm_irq(unsigned int irq)
+{
+	/* Already done in brcm_irq_dispatch */
+}
+
+unsigned int startup_brcm_irq(unsigned int irq)
+{
+	enable_brcm_irq(irq);
+
+	return 0; /* never anything pending */
+}
+
+unsigned int startup_brcm_none(unsigned int irq)
+{
+	return 0;
+}
+
+void end_brcm_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_brcm_irq(irq);
+}
+
+void end_brcm_none(unsigned int irq)
+{
+}
+
+static struct hw_interrupt_type brcm_irq_type = {
+	.typename	= "MIPS",
+	.startup	= startup_brcm_irq,
+	.shutdown	= disable_brcm_irq,
+	.enable	= enable_brcm_irq,
+	.disable	= disable_brcm_irq,
+	.ack	= ack_brcm_irq,
+	.end	= end_brcm_irq,
+	.set_affinity = NULL
+};
+
+static struct hw_interrupt_type brcm_irq_no_end_type = {
+	.typename	= "MIPS",
+	.startup	= startup_brcm_none,
+	.shutdown	= disable_brcm_irq,
+	.enable	= enable_brcm_irq,
+	.disable	= disable_brcm_irq,
+	.ack	= ack_brcm_irq,
+	.end	= end_brcm_none,
+	.set_affinity = NULL
+};
+
+void __init arch_init_irq(void)
+{
+	int i;
+
+	clear_c0_status(ST0_BEV);
+	change_c0_status(ST0_IM, (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4));
+
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = 0;
+		irq_desc[i].depth = 1;
+		irq_desc[i].handler = &brcm_irq_type;
+	}
+}
+
+int request_external_irq(unsigned int irq, 
+	FN_HANDLER handler,
+		unsigned long irqflags, 
+		const char * devname,
+		void *dev_id)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_CLEAR_SHFT));      // Clear
+	PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));      // Mask
+	PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_INSENS_SHFT));    // Edge insesnsitive
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_LEVEL_SHFT));      // Level triggered
+	PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_SENSE_SHFT));     // Low level
+
+	local_irq_restore(flags);
+
+	return( request_irq(irq, handler, irqflags, devname, dev_id) );
+}
+
+/* VxWorks compatibility function(s). */
+
+unsigned int BcmHalMapInterrupt(FN_HANDLER pfunc, unsigned int param,
+	unsigned int interruptId)
+{
+	int nRet = -1;
+	char *devname;
+
+	devname = kmalloc(16, GFP_KERNEL);
+	if (devname)
+		sprintf( devname, "brcm_%d", interruptId );
+
+	/* Set the IRQ description to not automatically enable the interrupt at
+	 * the end of an ISR.  The driver that handles the interrupt must
+	 * explicitly call BcmHalInterruptEnable or enable_brcm_irq.  This behavior
+	 * is consistent with interrupt handling on VxWorks.
+	 */
+	irq_desc[interruptId].handler = &brcm_irq_no_end_type;
+
+	if( interruptId >= INTERNAL_ISR_TABLE_OFFSET )
+	{
+		nRet = request_irq( interruptId, pfunc, SA_SAMPLE_RANDOM | SA_INTERRUPT,
+			devname, (void *) param );
+	}
+	else if (interruptId >= INTERRUPT_ID_EXTERNAL_0 && interruptId <= INTERRUPT_ID_EXTERNAL_3)
+	{
+		nRet = request_external_irq( interruptId, pfunc, SA_SAMPLE_RANDOM | SA_INTERRUPT,
+			devname, (void *) param );
+	}
+
+	return( nRet );
+}
+
+
+EXPORT_SYMBOL(enable_brcm_irq);
+EXPORT_SYMBOL(disable_brcm_irq);
+EXPORT_SYMBOL(request_external_irq);
+EXPORT_SYMBOL(BcmHalMapInterrupt);
+
diff -urN linux.old/arch/mips/bcm963xx/Kconfig linux.dev/arch/mips/bcm963xx/Kconfig
--- linux.old/arch/mips/bcm963xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/Kconfig	2006-08-25 01:22:39.000000000 +0200
@@ -0,0 +1,138 @@
+# Kernel and Driver configuration for Broadcom Commengine ADSL board
+choice
+	prompt "Broadcom Commengine ADSL board"
+	depends on BCM963XX
+	default BCM96345
+	help
+	  Select different Broadcom ADSL board
+
+config BCM96338
+	bool "96338 ADSL board"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+
+config BCM96345
+	bool "96345 ADSL board"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+
+config BCM96348
+	bool "96348 ADSL board"
+	select DMA_NONCOHERENT
+	select HW_HAS_PCI
+
+endchoice
+
+config BCM_BOARD
+	bool "Support for Broadcom Board"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SERIAL
+	bool "Support for Serial Port"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENET
+	tristate "Support for Ethernet"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_USB
+	tristate "Support for USB"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_WLAN
+	tristate "Support for Wireless"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_PCI
+	bool "Support for PCI"
+	depends on BCM96338 || BCM96345 || BCM96348
+	select PCI
+
+config BCM_ATMAPI
+	tristate "Support for ATM"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ATMTEST
+	tristate "Support for ATM Diagnostic"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ADSL
+	tristate "Support for ADSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENDPOINT
+	tristate "Support for VOICE"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_PROCFS
+	tristate "Support for PROCFS"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_VDSL
+	tristate "Support for VDSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SECURITY
+	tristate "Support for SECURITY"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_HPNA
+	tristate "Support for HPNA"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_BOARD_IMPL
+	int "Implementation index for ADSL Board"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SERIAL_IMPL
+	int "Implementation index for Serial"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENET_IMPL
+	int "Implementation index for Ethernet"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_USB_IMPL
+	int "Implementation index for USB"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_WLAN_IMPL
+	int "Implementation index for WIRELESS"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ATMAPI_IMPL
+	int "Implementation index for ATM"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ATMTEST_IMPL
+	int "Implementation index for ATM Diagnostic"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_BLAA_IMPL
+	int "Implementation index for BLAA"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ADSL_IMPL
+	int "Implementation index for ADSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENDPOINT_IMPL
+	int "Implementation index for VOICE"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_PROCFS_IMPL
+	int "Implementation index for PROCFS"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_VDSL_IMPL
+	int "Implementation index for VDSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SECURITY_IMPL
+	int "Implementation index for SECURITY"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_HPNA_IMPL
+	int "Implementation index for HPNA"
+	depends on BCM96338 || BCM96345 || BCM96348
+
diff -urN linux.old/arch/mips/bcm963xx/Makefile linux.dev/arch/mips/bcm963xx/Makefile
--- linux.old/arch/mips/bcm963xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/Makefile	2006-08-25 02:04:27.000000000 +0200
@@ -0,0 +1,23 @@
+#
+# Makefile for generic Broadcom MIPS boards
+#
+# Copyright (C) 2004 Broadcom Corporation
+#
+obj-y           := irq.o prom.o setup.o time.o ser_init.o bcm63xx_led.o  board.o  boardparms.o int-handler.o
+
+SRCBASE         := $(TOPDIR)
+EXTRA_CFLAGS    += -I$(SRCBASE)/include
+#EXTRA_CFLAGS    += -I$(INC_ADSLDRV_PATH) -DDBG
+EXTRA_CFLAGS    += -I$(INC_ADSLDRV_PATH) 
+
+
+ifeq "$(ADSL)" "ANNEX_B"
+EXTRA_CFLAGS += -DADSL_ANNEXB
+endif
+ifeq "$(ADSL)" "SADSL"
+EXTRA_CFLAGS += -DADSL_SADSL
+endif
+ifeq "$(ADSL)" "ANNEX_C"
+EXTRA_CFLAGS += -DADSL_ANNEXC
+endif
+
diff -urN linux-2.6.17/arch/mips/bcm963xx/prom.c linux-2.6.17-brcm63xx/arch/mips/bcm963xx/prom.c
--- linux-2.6.17/arch/mips/bcm963xx/prom.c      1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-brcm63xx/arch/mips/bcm963xx/prom.c     2006-08-29 07:10:10.000000000 +0200
@@ -0,0 +1,143 @@
+/*
+<:copyright-gpl
+ Copyright 2004 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+/*
+ * prom.c: PROM library initialization code.
+ *
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <linux/blkdev.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#include "boardparms.h"
+#include "softdsl/AdslCoreDefs.h"
+
+
+//char arcs_cmdline[CL_SIZE] __initdata = {0};
+/* inv_xde */
+int boot_loader_type;
+int prom_argc;
+char **prom_argv, **prom_envp;
+
+extern int  do_syslog(int, char *, int);
+extern void serial_init(void);
+extern void __init InitNvramInfo( void );
+extern void kerSysFlashInit( void );
+extern unsigned long get_nvram_start_addr(void);
+void __init create_root_nfs_cmdline( char *cmdline );
+
+#define MACH_BCM                    MACH_BCM96348
+
+const char *get_system_type(void)
+{
+    /*PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+
+    return( pNvramData->szBoardId );*/
+    return "brcm63xx";
+}
+
+unsigned long getMemorySize(void)
+{
+    unsigned long ulSdramType = BOARD_SDRAM_TYPE;
+
+    unsigned long ulSdramSize;
+
+    switch( ulSdramType )
+    {
+    case BP_MEMORY_16MB_1_CHIP:
+    case BP_MEMORY_16MB_2_CHIP:
+        ulSdramSize = 16 * 1024 * 1024;
+        break;
+    case BP_MEMORY_32MB_1_CHIP:
+    case BP_MEMORY_32MB_2_CHIP:
+        ulSdramSize = 32 * 1024 * 1024;
+        break;
+    case BP_MEMORY_64MB_2_CHIP:
+        ulSdramSize = 64 * 1024 * 1024;
+        break;
+    default:
+        ulSdramSize = 8 * 1024 * 1024;
+        break;
+    }
+    if (boot_loader_type == BOOT_CFE)
+      return ulSdramSize;
+    else
+      // assume that there is one contiguous memory map
+      return boot_mem_map.map[0].size;
+}
+
+/* --------------------------------------------------------------------------
+    Name: prom_init
+ -------------------------------------------------------------------------- */
+void __init prom_init(void)
+{
+    extern ulong r4k_interval;
+
+    serial_init();
+
+    prom_argc = fw_arg0;
+    prom_argv = (char **) fw_arg1;
+    prom_envp = (char **) fw_arg2;
+
+    if ((prom_argv > 0x80000000) && (prom_argv < 0x82000000)) {
+      strncpy(arcs_cmdline, prom_argv[1], CL_SIZE);
+    }
+
+    if (strncmp(arcs_cmdline, "boot_loader=RedBoot", 19) != 0) {
+      boot_loader_type =  BOOT_CFE;
+    }
+    else {
+      boot_loader_type = BOOT_REDBOOT;
+    }
+
+    do_syslog(8, NULL, 8);
+
+    printk( "%s prom init\n", get_system_type() );
+
+    PERF->IrqMask = 0;
+
+    arcs_cmdline[0] = '\0';
+
+       if (boot_loader_type == BOOT_CFE)
+      add_memory_region(0, (getMemorySize() - ADSL_SDRAM_IMAGE_SIZE), BOOT_MEM_RAM);
+    else
+       add_memory_region(0, (0x01000000 - ADSL_SDRAM_IMAGE_SIZE), BOOT_MEM_RAM);
+
+    mips_machgroup = MACH_GROUP_BRCM;
+    mips_machtype = MACH_BCM;
+
+       BpSetBoardId("96348GW-10");
+}
+
+/* --------------------------------------------------------------------------
+    Name: prom_free_prom_memory
+Abstract:
+ -------------------------------------------------------------------------- */
+void __init prom_free_prom_memory(void)
+{
+
+}
+
diff -urN linux.old/arch/mips/bcm963xx/ser_init.c linux.dev/arch/mips/bcm963xx/ser_init.c
--- linux.old/arch/mips/bcm963xx/ser_init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/ser_init.c	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,180 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ *  Broadcom bcm63xx serial port initialization, also prepare for printk
+ *  by registering with console_init
+ *   
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/console.h>
+#include <linux/sched.h>
+
+#include <asm/addrspace.h>
+#include <asm/irq.h>
+#include <asm/reboot.h>
+#include <asm/gdb-stub.h>
+#include <asm/mc146818rtc.h> 
+
+#include <bcm_map_part.h>
+#include <board.h>
+
+#define  SER63XX_DEFAULT_BAUD      115200
+#define BD_BCM63XX_TIMER_CLOCK_INPUT    (FPERIPH)
+#define stUart ((volatile Uart * const) UART_BASE)
+
+// Transmit interrupts
+#define TXINT       (TXFIFOEMT | TXUNDERR | TXOVFERR)
+// Receive interrupts
+#define RXINT       (RXFIFONE | RXOVFERR)
+
+/* --------------------------------------------------------------------------
+    Name: serial_init
+ Purpose: Initalize the UART
+-------------------------------------------------------------------------- */
+void __init serial_init(void)
+{
+    UINT32 tmpVal = SER63XX_DEFAULT_BAUD;
+    ULONG clockFreqHz;    
+
+#if defined(CONFIG_BCM96345)
+    // Make sure clock is ticking
+    PERF->blkEnables |= UART_CLK_EN;
+#endif
+		
+    /* Dissable channel's receiver and transmitter.                */
+    stUart->control &= ~(BRGEN|TXEN|RXEN);
+		
+    /*--------------------------------------------------------------------*/
+    /* Write the table value to the clock select register.                */
+    /* DPullen - this is the equation to use:                             */
+    /*       value = clockFreqHz / baud / 32-1;                           */
+    /*   (snmod) Actually you should also take into account any necessary */
+    /*           rounding.  Divide by 16, look at lsb, if 0, divide by 2  */
+    /*           and subtract 1.  If 1, just divide by 2                  */
+    /*--------------------------------------------------------------------*/
+    clockFreqHz = BD_BCM63XX_TIMER_CLOCK_INPUT;
+    tmpVal = (clockFreqHz / tmpVal) / 16;
+    if( tmpVal & 0x01 )
+        tmpVal /= 2;  //Rounding up, so sub is already accounted for
+    else
+        tmpVal = (tmpVal / 2) - 1; // Rounding down so we must sub 1
+    stUart->baudword = tmpVal;
+        
+    /* Finally, re-enable the transmitter and receiver.            */
+    stUart->control |= (BRGEN|TXEN|RXEN);
+
+    stUart->config   = (BITS8SYM | ONESTOP);
+    // Set the FIFO interrupt depth ... stUart->fifocfg  = 0xAA;
+    stUart->fifoctl  =  RSTTXFIFOS | RSTRXFIFOS;
+    stUart->intMask  = 0;       
+    stUart->intMask = RXINT | TXINT;
+}
+
+
+/* prom_putc()
+ * Output a character to the UART
+ */
+void prom_putc(char c)
+{
+	/* Wait for Tx uffer to empty */
+	while (! (READ16(stUart->intStatus) & TXFIFOEMT));
+	/* Send character */
+	stUart->Data = c;
+}
+
+/* prom_puts()
+ * Write a string to the UART
+ */
+void prom_puts(const char *s)
+{
+	while (*s) {
+		if (*s == '\n') {
+			prom_putc('\r');
+		}
+		prom_putc(*s++);
+	}
+}
+
+
+/* prom_getc_nowait()
+ * Returns a character from the UART
+ * Returns -1 if no characters available or corrupted
+ */
+int prom_getc_nowait(void)
+{
+    uint16  uStatus;
+    int    cData = -1;
+
+     uStatus = READ16(stUart->intStatus);
+
+     if (uStatus & RXFIFONE) { /* Do we have a character? */
+           cData =  READ16(stUart->Data) & 0xff; /* Read character */
+           if (uStatus & (RXFRAMERR | RXPARERR)) {  /* If we got an error, throw it away */
+               cData = -1;
+           }
+  }
+
+   return cData;
+}
+
+/* prom_getc()
+ * Returns a charcter from the serial port
+ * Will block until it receives a valid character
+*/
+char prom_getc(void)
+{
+    int    cData = -1;
+
+    /* Loop until we get a valid character */
+    while(cData == -1) {
+	cData = prom_getc_nowait();
+    }
+   return (char) cData;
+}
+
+/* prom_testc()
+ * Returns 0 if no characters available
+ */
+int prom_testc(void)
+{
+    uint16  uStatus;
+
+     uStatus = READ16(stUart->intStatus);
+
+     return (uStatus & RXFIFONE);
+}
+
+#if defined (CONFIG_REMOTE_DEBUG)
+/* Prevent other code from writing to the serial port */
+void _putc(char c) { }
+void _puts(const char *ptr) { }
+#else
+/* Low level outputs call prom routines */
+void _putc(char c) {
+	prom_putc(c);
+}
+void _puts(const char *ptr) {
+	prom_puts(ptr);
+}
+#endif
diff -urN linux.old/arch/mips/bcm963xx/setup.c linux.dev/arch/mips/bcm963xx/setup.c
--- linux.old/arch/mips/bcm963xx/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/setup.c	2006-08-25 02:26:58.000000000 +0200
@@ -0,0 +1,525 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * Generic setup routines for Broadcom 963xx MIPS boards
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/console.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+
+#include <asm/addrspace.h>
+#include <asm/bcache.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+#include <asm/gdb-stub.h>
+
+extern void brcm_time_init(void);
+extern void brcm_timer_setup(struct irqaction *irq);
+extern unsigned long getMemorySize(void);
+
+#if defined(CONFIG_BCM96348) && defined(CONFIG_PCI)
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <bcm_map_part.h>
+#include <bcmpci.h>
+
+static volatile MpiRegisters * mpi = (MpiRegisters *)(MPI_BASE);
+#endif
+
+/* This function should be in a board specific directory.  For now,
+ * assume that all boards that include this file use a Broadcom chip
+ * with a soft reset bit in the PLL control register.
+ */
+static void brcm_machine_restart(char *command)
+{
+    const unsigned long ulSoftReset = 0x00000001;
+    unsigned long *pulPllCtrl = (unsigned long *) 0xfffe0008;
+    *pulPllCtrl |= ulSoftReset;
+}
+
+static void brcm_machine_halt(void)
+{
+    printk("System halted\n");
+    while (1);
+}
+
+#if defined(CONFIG_BCM96348) && defined(CONFIG_PCI)
+
+static void mpi_SetLocalPciConfigReg(uint32 reg, uint32 value)
+{
+    /* write index then value */
+    mpi->pcicfgcntrl = PCI_CFG_REG_WRITE_EN + reg;;
+    mpi->pcicfgdata = value;
+}
+
+static uint32 mpi_GetLocalPciConfigReg(uint32 reg)
+{
+    /* write index then get value */
+    mpi->pcicfgcntrl = PCI_CFG_REG_WRITE_EN + reg;;
+    return mpi->pcicfgdata;
+}
+
+/*
+ * mpi_ResetPcCard: Set/Reset the PcCard
+ */
+static void mpi_ResetPcCard(int cardtype, BOOL bReset)
+{
+    if (cardtype == MPI_CARDTYPE_NONE) {
+        return;
+    }
+
+    if (cardtype == MPI_CARDTYPE_CARDBUS) {
+        bReset = ! bReset;
+    }
+
+    if (bReset) {
+        mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 & ~PCCARD_CARD_RESET);
+    } else {
+        mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 | PCCARD_CARD_RESET);
+    }
+}
+
+/*
+ * mpi_ConfigCs: Configure an MPI/EBI chip select
+ */
+static void mpi_ConfigCs(uint32 cs, uint32 base, uint32 size, uint32 flags)
+{
+    mpi->cs[cs].base = ((base & 0x1FFFFFFF) | size);
+    mpi->cs[cs].config = flags;
+}
+
+/*
+ * mpi_InitPcmciaSpace
+ */
+static void mpi_InitPcmciaSpace(void)
+{
+    // ChipSelect 4 controls PCMCIA Memory accesses
+    mpi_ConfigCs(PCMCIA_COMMON_BASE, pcmciaMem, EBI_SIZE_1M, (EBI_WORD_WIDE|EBI_ENABLE));
+    // ChipSelect 5 controls PCMCIA Attribute accesses
+    mpi_ConfigCs(PCMCIA_ATTRIBUTE_BASE, pcmciaAttr, EBI_SIZE_1M, (EBI_WORD_WIDE|EBI_ENABLE));
+    // ChipSelect 6 controls PCMCIA I/O accesses
+    mpi_ConfigCs(PCMCIA_IO_BASE, pcmciaIo, EBI_SIZE_64K, (EBI_WORD_WIDE|EBI_ENABLE));
+
+    mpi->pcmcia_cntl2 = ((PCMCIA_ATTR_ACTIVE << RW_ACTIVE_CNT_BIT) | 
+                         (PCMCIA_ATTR_INACTIVE << INACTIVE_CNT_BIT) | 
+                         (PCMCIA_ATTR_CE_SETUP << CE_SETUP_CNT_BIT) | 
+                         (PCMCIA_ATTR_CE_HOLD << CE_HOLD_CNT_BIT));
+
+    mpi->pcmcia_cntl2 |= (PCMCIA_HALFWORD_EN | PCMCIA_BYTESWAP_DIS);
+}
+
+/*
+ * cardtype_vcc_detect: PC Card's card detect and voltage sense connection
+ * 
+ *   CD1#/      CD2#/     VS1#/     VS2#/    Card       Initial Vcc
+ *  CCD1#      CCD2#     CVS1      CVS2      Type
+ *
+ *   GND        GND       open      open     16-bit     5 vdc
+ *
+ *   GND        GND       GND       open     16-bit     3.3 vdc
+ *
+ *   GND        GND       open      GND      16-bit     x.x vdc
+ *
+ *   GND        GND       GND       GND      16-bit     3.3 & x.x vdc
+ *
+ *====================================================================
+ *
+ *   CVS1       GND       CCD1#     open     CardBus    3.3 vdc
+ *
+ *   GND        CVS2      open      CCD2#    CardBus    x.x vdc
+ *
+ *   GND        CVS1      CCD2#     open     CardBus    y.y vdc
+ *
+ *   GND        CVS2      GND       CCD2#    CardBus    3.3 & x.x vdc
+ *
+ *   CVS2       GND       open      CCD1#    CardBus    x.x & y.y vdc
+ *
+ *   GND        CVS1      CCD2#     open     CardBus    3.3, x.x & y.y vdc
+ *
+ */
+static int cardtype_vcc_detect(void)
+{
+    uint32 data32;
+    int cardtype;
+
+    cardtype = MPI_CARDTYPE_NONE;
+    mpi->pcmcia_cntl1 = 0x0000A000; // Turn on the output enables and drive
+                                        // the CVS pins to 0.
+    data32 = mpi->pcmcia_cntl1;
+    switch (data32 & 0x00000003)  // Test CD1# and CD2#, see if card is plugged in.
+    {
+    case 0x00000003:  // No Card is in the slot.
+        printk("mpi: No Card is in the PCMCIA slot\n");
+        break;
+
+    case 0x00000002:  // Partial insertion, No CD2#.
+        printk("mpi: Card in the PCMCIA slot partial insertion, no CD2 signal\n");
+        break;
+
+    case 0x00000001:  // Partial insertion, No CD1#.
+        printk("mpi: Card in the PCMCIA slot partial insertion, no CD1 signal\n");
+        break;
+
+    case 0x00000000:
+        mpi->pcmcia_cntl1 = 0x0000A0C0; // Turn off the CVS output enables and
+                                        // float the CVS pins.
+        mdelay(1);
+        data32 = mpi->pcmcia_cntl1;
+        // Read the Register.
+        switch (data32 & 0x0000000C)  // See what is on the CVS pins.
+        {
+        case 0x00000000: // CVS1 and CVS2 are tied to ground, only 1 option.
+            printk("mpi: Detected 3.3 & x.x 16-bit PCMCIA card\n");
+            cardtype = MPI_CARDTYPE_PCMCIA;
+            break;
+          
+        case 0x00000004: // CVS1 is open or tied to CCD1/CCD2 and CVS2 is tied to ground.
+                         // 2 valid voltage options.
+        switch (data32 & 0x00000003)  // Test the values of CCD1 and CCD2.
+        {
+            case 0x00000003:  // CCD1 and CCD2 are tied to 1 of the CVS pins.
+                              // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+      
+            case 0x00000002:  // CCD2 is tied to either CVS1 or CVS2. 
+                mpi->pcmcia_cntl1 = 0x0000A080; // Drive CVS1 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000002) { // CCD2 is tied to CVS2, not valid.
+                    printk("mpi: Unknown card plugged into slot\n"); 
+                } else {                   // CCD2 is tied to CVS1.
+                    printk("mpi: Detected 3.3, x.x and y.y Cardbus card\n");
+                    cardtype = MPI_CARDTYPE_CARDBUS;
+                }
+                break;
+                
+            case 0x00000001: // CCD1 is tied to either CVS1 or CVS2.
+                             // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+                
+            case 0x00000000:  // CCD1 and CCD2 are tied to ground.
+                printk("mpi: Detected x.x vdc 16-bit PCMCIA card\n");
+                cardtype = MPI_CARDTYPE_PCMCIA;
+                break;
+            }
+            break;
+          
+        case 0x00000008: // CVS2 is open or tied to CCD1/CCD2 and CVS1 is tied to ground.
+                         // 2 valid voltage options.
+            switch (data32 & 0x00000003)  // Test the values of CCD1 and CCD2.
+            {
+            case 0x00000003:  // CCD1 and CCD2 are tied to 1 of the CVS pins.
+                              // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+      
+            case 0x00000002:  // CCD2 is tied to either CVS1 or CVS2.
+                mpi->pcmcia_cntl1 = 0x0000A040; // Drive CVS2 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000002) { // CCD2 is tied to CVS1, not valid.
+                    printk("mpi: Unknown card plugged into slot\n"); 
+                } else {// CCD2 is tied to CVS2.
+                    printk("mpi: Detected 3.3 and x.x Cardbus card\n");
+                    cardtype = MPI_CARDTYPE_CARDBUS;
+                }
+                break;
+
+            case 0x00000001: // CCD1 is tied to either CVS1 or CVS2.
+                             // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+
+            case 0x00000000:  // CCD1 and CCD2 are tied to ground.
+                cardtype = MPI_CARDTYPE_PCMCIA;
+                printk("mpi: Detected 3.3 vdc 16-bit PCMCIA card\n");
+                break;
+            }
+            break;
+          
+        case 0x0000000C:  // CVS1 and CVS2 are open or tied to CCD1/CCD2.
+                          // 5 valid voltage options.
+      
+            switch (data32 & 0x00000003)  // Test the values of CCD1 and CCD2.
+            {
+            case 0x00000003:  // CCD1 and CCD2 are tied to 1 of the CVS pins.
+                              // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+      
+            case 0x00000002:  // CCD2 is tied to either CVS1 or CVS2.
+                              // CCD1 is tied to ground.
+                mpi->pcmcia_cntl1 = 0x0000A040; // Drive CVS2 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000002) {  // CCD2 is tied to CVS1.
+                    printk("mpi: Detected y.y vdc Cardbus card\n");
+                } else {                    // CCD2 is tied to CVS2.
+                    printk("mpi: Detected x.x vdc Cardbus card\n");
+                }
+                cardtype = MPI_CARDTYPE_CARDBUS;
+                break;
+      
+            case 0x00000001: // CCD1 is tied to either CVS1 or CVS2.
+                             // CCD2 is tied to ground.
+      
+                mpi->pcmcia_cntl1 = 0x0000A040; // Drive CVS2 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000001) {// CCD1 is tied to CVS1.
+                    printk("mpi: Detected 3.3 vdc Cardbus card\n");
+                } else {                    // CCD1 is tied to CVS2.
+                    printk("mpi: Detected x.x and y.y Cardbus card\n");
+                }
+                cardtype = MPI_CARDTYPE_CARDBUS;
+                break;
+      
+            case 0x00000000:  // CCD1 and CCD2 are tied to ground.
+                cardtype = MPI_CARDTYPE_PCMCIA;
+                printk("mpi: Detected 5 vdc 16-bit PCMCIA card\n");
+                break;
+            }
+            break;
+      
+        default:
+            printk("mpi: Unknown card plugged into slot\n"); 
+            break;
+        
+        }
+    }
+    return cardtype;
+}
+
+/*
+ * mpi_DetectPcCard: Detect the plugged in PC-Card
+ * Return: < 0 => Unknown card detected
+ *         0 => No card detected
+ *         1 => 16-bit card detected
+ *         2 => 32-bit CardBus card detected
+ */
+static int mpi_DetectPcCard(void)
+{
+    int cardtype;
+
+    cardtype = cardtype_vcc_detect();
+    switch(cardtype) {
+        case MPI_CARDTYPE_PCMCIA:
+            mpi->pcmcia_cntl1 &= ~0x0000e000; // disable enable bits
+            //mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 & ~PCCARD_CARD_RESET);
+            mpi->pcmcia_cntl1 |= (PCMCIA_ENABLE | PCMCIA_GPIO_ENABLE);
+            mpi_InitPcmciaSpace();
+            mpi_ResetPcCard(cardtype, FALSE);
+            // Hold card in reset for 10ms
+            mdelay(10);
+            mpi_ResetPcCard(cardtype, TRUE);
+            // Let card come out of reset
+            mdelay(100);
+            break;
+        case MPI_CARDTYPE_CARDBUS:
+            // 8 => CardBus Enable
+            // 1 => PCI Slot Number
+            // C => Float VS1 & VS2
+            mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 & 0xFFFF0000) | 
+                                CARDBUS_ENABLE | 
+                                (CARDBUS_SLOT << 8)| 
+                                VS2_OEN |
+                                VS1_OEN;
+            /* access to this memory window will be to/from CardBus */
+            mpi->l2pmremap1 |= CARDBUS_MEM;
+
+            // Need to reset the Cardbus Card. There's no CardManager to do this, 
+            // and we need to be ready for PCI configuration. 
+            mpi_ResetPcCard(cardtype, FALSE);
+            // Hold card in reset for 10ms
+            mdelay(10);
+            mpi_ResetPcCard(cardtype, TRUE);
+            // Let card come out of reset
+            mdelay(100);
+            break;
+        default:
+            break;
+    }
+    return cardtype;
+}
+
+static int mpi_init(void)
+{
+    unsigned long data;
+    unsigned int chipid;
+    unsigned int chiprev;
+    unsigned int sdramsize;
+
+    chipid  = (PERF->RevID & 0xFFFF0000) >> 16;
+    chiprev = (PERF->RevID & 0xFF);
+    sdramsize = getMemorySize();
+    /*
+     * Init the pci interface 
+     */
+    data = GPIO->GPIOMode; // GPIO mode register
+    data |= GROUP2_PCI | GROUP1_MII_PCCARD; // PCI internal arbiter + Cardbus
+    GPIO->GPIOMode = data; // PCI internal arbiter
+
+    /*
+     * In the BCM6348 CardBus support is defaulted to Slot 0
+     * because there is no external IDSEL for CardBus.  To disable
+     * the CardBus and allow a standard PCI card in Slot 0 
+     * set the cbus_idsel field to 0x1f.
+    */
+    /*
+    uData = mpi->pcmcia_cntl1;
+    uData |= CARDBUS_IDSEL;
+    mpi->pcmcia_cntl1 = uData;
+    */
+    // Setup PCI I/O Window range. Give 64K to PCI I/O
+    mpi->l2piorange = ~(BCM_PCI_IO_SIZE_64KB-1);
+    // UBUS to PCI I/O base address 
+    mpi->l2piobase = BCM_PCI_IO_BASE & BCM_PCI_ADDR_MASK;
+    // UBUS to PCI I/O Window remap
+    mpi->l2pioremap = (BCM_PCI_IO_BASE | MEM_WINDOW_EN);
+
+    // enable PCI related GPIO pins and data swap between system and PCI bus
+    mpi->locbuscntrl = (EN_PCI_GPIO | DIR_U2P_NOSWAP);
+
+    /* Enable 6348 BusMaster and Memory access mode */
+    data = mpi_GetLocalPciConfigReg(PCI_COMMAND);
+    data |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+    mpi_SetLocalPciConfigReg(PCI_COMMAND, data);
+
+    /* Configure two 16 MByte PCI to System memory regions. */
+    /* These memory regions are used when PCI device is a bus master */
+    /* Accesses to the SDRAM from PCI bus will be "byte swapped" for this region */
+    mpi_SetLocalPciConfigReg(PCI_BASE_ADDRESS_3, BCM_HOST_MEM_SPACE1);
+    mpi->sp0remap = 0x0;
+
+    /* Accesses to the SDRAM from PCI bus will not be "byte swapped" for this region */
+    mpi_SetLocalPciConfigReg(PCI_BASE_ADDRESS_4, BCM_HOST_MEM_SPACE2);
+    mpi->sp1remap = 0x0;
+    mpi->pcimodesel |= (PCI_BAR2_NOSWAP | 0x40);
+
+    if ((chipid == 0x6348) && (chiprev == 0xb0)) {
+        mpi->sp0range = ~(sdramsize-1);
+        mpi->sp1range = ~(sdramsize-1);
+    }
+    /*
+     * Change 6348 PCI Cfg Reg. offset 0x40 to PCI memory read retry count infinity
+     * by set 0 in bit 8~15.  This resolve read Bcm4306 srom return 0xffff in
+     * first read.
+     */
+    data = mpi_GetLocalPciConfigReg(BRCM_PCI_CONFIG_TIMER);
+    data &= ~BRCM_PCI_CONFIG_TIMER_RETRY_MASK;
+    data |= 0x00000080;
+    mpi_SetLocalPciConfigReg(BRCM_PCI_CONFIG_TIMER, data);
+
+    /* enable pci interrupt */
+    mpi->locintstat |= (EXT_PCI_INT << 16);
+
+    mpi_DetectPcCard();
+
+    ioport_resource.start = BCM_PCI_IO_BASE;
+    ioport_resource.end = BCM_PCI_IO_BASE + BCM_PCI_IO_SIZE_64KB;
+
+#if defined(CONFIG_USB)
+    PERF->blkEnables |= USBH_CLK_EN;
+    mdelay(100);
+    *USBH_NON_OHCI = NON_OHCI_BYTE_SWAP;
+#endif
+
+    return 0;
+}
+#endif
+
+static int __init brcm63xx_setup(void)
+{
+    extern int panic_timeout;
+
+    _machine_restart = brcm_machine_restart;
+    _machine_halt = brcm_machine_halt;
+    pm_power_off = brcm_machine_halt;
+
+    board_time_init = brcm_time_init;
+    board_timer_setup = brcm_timer_setup;
+
+    panic_timeout = 5;
+
+#if defined(CONFIG_BCM96348) && defined(CONFIG_PCI)
+    /* mpi initialization */
+    mpi_init();
+#endif
+    return 0;
+}
+
+void plat_setup(void)
+{
+    brcm63xx_setup();
+}
+
+/***************************************************************************
+ * C++ New and delete operator functions
+ ***************************************************************************/
+
+/* void *operator new(unsigned int sz) */
+void *_Znwj(unsigned int sz)
+{
+    return( kmalloc(sz, GFP_KERNEL) );
+}
+
+/* void *operator new[](unsigned int sz)*/
+void *_Znaj(unsigned int sz)
+{
+    return( kmalloc(sz, GFP_KERNEL) );
+}
+
+/* placement new operator */
+/* void *operator new (unsigned int size, void *ptr) */
+void *ZnwjPv(unsigned int size, void *ptr)
+{
+    return ptr;
+}
+
+/* void operator delete(void *m) */
+void _ZdlPv(void *m)
+{
+    kfree(m);
+}
+
+/* void operator delete[](void *m) */
+void _ZdaPv(void *m)
+{
+    kfree(m);
+}
+
+EXPORT_SYMBOL(_Znwj);
+EXPORT_SYMBOL(_Znaj);
+EXPORT_SYMBOL(ZnwjPv);
+EXPORT_SYMBOL(_ZdlPv);
+EXPORT_SYMBOL(_ZdaPv);
+
diff -urN linux.old/arch/mips/bcm963xx/softdsl/AdslCoreDefs.h linux.dev/arch/mips/bcm963xx/softdsl/AdslCoreDefs.h
--- linux.old/arch/mips/bcm963xx/softdsl/AdslCoreDefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/softdsl/AdslCoreDefs.h	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,2 @@
+#define ADSL_SDRAM_IMAGE_SIZE (384*1024)
+
diff -urN linux.old/arch/mips/bcm963xx/time.c linux.dev/arch/mips/bcm963xx/time.c
--- linux.old/arch/mips/bcm963xx/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/bcm963xx/time.c	2006-08-25 03:58:22.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+<:copyright-gpl
+ Copyright 2004 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+/*
+ * Setup time for Broadcom 963xx MIPS boards
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/div64.h>
+#include <asm/time.h>
+
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+static unsigned long r4k_offset;	/* Amount to increment compare reg each time */
+static unsigned long r4k_cur;		/* What counter should be at next timer irq */
+
+/*  *********************************************************************
+    *  calculateCpuSpeed()
+    *      Calculate the BCM6348 CPU speed by reading the PLL strap register
+    *      and applying the following formula:
+    *      cpu_clk = (.25 * 64MHz freq) * (N1 + 1) * (N2 + 2) / (M1_CPU + 1)
+    *  Input parameters:
+    *      none
+    *  Return value:
+    *      none
+    ********************************************************************* */
+
+static inline unsigned long __init calculateCpuSpeed(void)
+{
+    UINT32 pllStrap = PERF->PllStrap;
+    int n1 = (pllStrap & PLL_N1_MASK) >> PLL_N1_SHFT;
+    int n2 = (pllStrap & PLL_N2_MASK) >> PLL_N2_SHFT;
+    int m1cpu = (pllStrap & PLL_M1_CPU_MASK) >> PLL_M1_CPU_SHFT;
+
+	return (16 * (n1 + 1) * (n2 + 2) / (m1cpu + 1)) * 1000000;
+}
+
+
+static inline unsigned long __init cal_r4koff(void)
+{   
+	mips_hpt_frequency = calculateCpuSpeed() / 2;
+	return (mips_hpt_frequency / HZ);
+}
+
+
+/*
+ * There are a lot of conceptually broken versions of the MIPS timer interrupt
+ * handler floating around.  This one is rather different, but the algorithm
+ * is provably more robust.
+ */
+irqreturn_t brcm_timer_interrupt(struct pt_regs *regs)
+{
+	int irq = MIPS_TIMER_INT;
+
+	irq_enter();
+	kstat_this_cpu.irqs[irq]++;
+
+	timer_interrupt(irq, NULL, regs);
+	irq_exit();
+	return IRQ_HANDLED;
+}
+
+
+void __init brcm_time_init(void)
+{
+	unsigned int est_freq, flags;
+	local_irq_save(flags);
+
+	printk("calculating r4koff... ");
+	r4k_offset = cal_r4koff();
+	printk("%08lx(%d)\n", r4k_offset, (int)r4k_offset);
+
+	est_freq = 2 * r4k_offset * HZ;
+	est_freq += 5000;   /* round */
+	est_freq -= est_freq % 10000;
+	printk("CPU frequency %d.%02d MHz\n", est_freq / 1000000,
+		   (est_freq % 1000000) * 100 / 1000000);
+	local_irq_restore(flags);
+}
+
+
+void __init brcm_timer_setup(struct irqaction *irq)
+{
+	r4k_cur = (read_c0_count() + r4k_offset);
+	write_c0_compare(r4k_cur);
+	set_c0_status(IE_IRQ5);
+}
diff -urN linux.old/arch/mips/Kconfig linux.dev/arch/mips/Kconfig
--- linux.old/arch/mips/Kconfig	2006-08-25 00:43:39.000000000 +0200
+++ linux.dev/arch/mips/Kconfig	2006-08-25 01:57:46.000000000 +0200
@@ -12,6 +12,15 @@
 	prompt "System type"
 	default SGI_IP22
 
+config BCM963XX 
+	bool "Support for the Broadcom boards"
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_CPU_MIPS32_R1
+	select IRQ_CPU
+	help
+	 This is a fmaily of boards based on the Broadcom MIPS32
+
 config MIPS_MTX1
 	bool "4G Systems MTX-1 board"
 	select DMA_NONCOHERENT
@@ -780,6 +789,7 @@
 
 endchoice
 
+source "arch/mips/bcm963xx/Kconfig"
 source "arch/mips/ddb5xxx/Kconfig"
 source "arch/mips/gt64120/ev64120/Kconfig"
 source "arch/mips/jazz/Kconfig"
diff -urN linux.old/arch/mips/kernel/cpu-probe.c linux.dev/arch/mips/kernel/cpu-probe.c
--- linux.old/arch/mips/kernel/cpu-probe.c	2006-08-25 00:43:39.000000000 +0200
+++ linux.dev/arch/mips/kernel/cpu-probe.c	2006-08-25 00:39:38.000000000 +0200
@@ -568,6 +568,25 @@
 		return;
 }
 
+static inline void cpu_probe_broadcom(struct cpuinfo_mips *c)
+{
+       decode_configs(c);
+       switch (c->processor_id & 0xff00) {
+       case PRID_IMP_BCM6338:
+               c->cputype = CPU_BCM6338;
+               break;
+       case PRID_IMP_BCM6345:
+               c->cputype = CPU_BCM6345;
+               break;
+       case PRID_IMP_BCM6348:
+               c->cputype = CPU_BCM6348;
+               break;
+       default:
+               c->cputype = CPU_UNKNOWN;
+               break;
+       }
+}
+
 static inline void cpu_probe_mips(struct cpuinfo_mips *c)
 {
 	decode_configs(c);
@@ -704,6 +723,9 @@
 	case PRID_COMP_LEGACY:
 		cpu_probe_legacy(c);
 		break;
+        case PRID_COMP_BROADCOM:
+                cpu_probe_broadcom(c);
+                break;
 	case PRID_COMP_MIPS:
 		cpu_probe_mips(c);
 		break;
diff -urN linux.old/arch/mips/kernel/proc.c linux.dev/arch/mips/kernel/proc.c
--- linux.old/arch/mips/kernel/proc.c	2006-08-25 00:43:39.000000000 +0200
+++ linux.dev/arch/mips/kernel/proc.c	2006-08-25 00:39:38.000000000 +0200
@@ -85,6 +85,9 @@
 	[CPU_VR4181A]	= "NEC VR4181A",
 	[CPU_SR71000]	= "Sandcraft SR71000",
 	[CPU_PR4450]	= "Philips PR4450",
+	[CPU_BCM6338]   = "BCM6338",
+	[CPU_BCM6345]   = "BCM6345",
+	[CPU_BCM6348]   = "BCM6348",
 };
 
 
diff -urN linux.old/arch/mips/Makefile linux.dev/arch/mips/Makefile
--- linux.old/arch/mips/Makefile	2006-08-25 00:43:39.000000000 +0200
+++ linux.dev/arch/mips/Makefile	2006-08-25 15:39:54.000000000 +0200
@@ -145,6 +145,15 @@
 #
 
 #
+# Broadcom board
+#
+core-$(CONFIG_BCM963XX)	+= arch/mips/bcm963xx/
+cflags-$(CONFIG_BCM963XX)     	+= -Iinclude/asm-mips/mach-bcm963xx
+cflags-$(CONFIG_BCM963XX)     	+= -Iarch/mips/bcm963xx/include
+load-$(CONFIG_BCM963XX)	+= 0xffffffff80010000
+
+
+#
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
 core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
diff -urN linux.old/arch/mips/mm/c-r4k.c linux.dev/arch/mips/mm/c-r4k.c
--- linux.old/arch/mips/mm/c-r4k.c	2006-08-25 00:43:39.000000000 +0200
+++ linux.dev/arch/mips/mm/c-r4k.c	2006-08-25 00:39:38.000000000 +0200
@@ -914,6 +914,13 @@
 		if (!(config & MIPS_CONF_M))
 			panic("Don't know how to probe P-caches on this cpu.");
 
+		if (c->cputype == CPU_BCM6338 || c->cputype == CPU_BCM6345 || c->cputype == CPU_BCM6348)
+		{
+			printk("brcm mips: enabling icache and dcache...\n");
+			/* Enable caches */
+			write_c0_diag(read_c0_diag() | 0xC0000000);
+		}
+
 		/*
 		 * So we seem to be a MIPS32 or MIPS64 CPU
 		 * So let's probe the I-cache ...
diff -urN linux.old/arch/mips/mm/tlbex.c linux.dev/arch/mips/mm/tlbex.c
--- linux.old/arch/mips/mm/tlbex.c	2006-08-25 00:43:39.000000000 +0200
+++ linux.dev/arch/mips/mm/tlbex.c	2006-08-25 00:39:38.000000000 +0200
@@ -882,6 +882,9 @@
 	case CPU_4KSC:
 	case CPU_20KC:
 	case CPU_25KF:
+	case CPU_BCM6338:
+	case CPU_BCM6345:
+	case CPU_BCM6348:
 		tlbw(p);
 		break;
 
diff -urN linux-2.6.17/arch/mips/pci/fixup-bcm96348.c linux-2.6.17-brcm63xx/arch/mips/pci/fixup-bcm96348.c
--- linux-2.6.17/arch/mips/pci/fixup-bcm96348.c 1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-brcm63xx/arch/mips/pci/fixup-bcm96348.c        2006-08-29 10:25:22.000000000 +0200
@@ -0,0 +1,93 @@
+/*
+<:copyright-gpl
+ Copyright 2002 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <bcmpci.h>
+#include <bcm_intr.h>
+#include <bcm_map_part.h>
+
+static volatile MpiRegisters * mpi = (MpiRegisters *)(MPI_BASE);
+
+static char irq_tab_bcm96348[] __initdata = {
+    [0] = INTERRUPT_ID_MPI,
+    [1] = INTERRUPT_ID_MPI,
+#if defined(CONFIG_USB)
+    [USB_HOST_SLOT] = INTERRUPT_ID_USBH
+#endif
+};
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+    return irq_tab_bcm96348[slot];
+}
+
+static void bcm96348_fixup(struct pci_dev *dev)
+{
+    uint32 memaddr;
+    uint32 size;
+
+    memaddr = pci_resource_start(dev, 0);
+    size = pci_resource_len(dev, 0);
+
+    switch (PCI_SLOT(dev->devfn)) {
+        case 0:
+            // UBUS to PCI address range
+            // Memory Window 1. Mask determines which bits are decoded.
+            mpi->l2pmrange1 = ~(size-1);
+            // UBUS to PCI Memory base address. This is akin to the ChipSelect base
+            // register.
+            mpi->l2pmbase1 = memaddr & BCM_PCI_ADDR_MASK;
+            // UBUS to PCI Remap Address. Replaces the masked address bits in the
+            // range register with this setting.
+            // Also, enable direct I/O and direct Memory accesses
+            mpi->l2pmremap1 = (memaddr | MEM_WINDOW_EN);
+            break;
+
+        case 1:
+            // Memory Window 2
+            mpi->l2pmrange2 = ~(size-1);
+            // UBUS to PCI Memory base address.
+            mpi->l2pmbase2 = memaddr & BCM_PCI_ADDR_MASK;
+            // UBUS to PCI Remap Address
+            mpi->l2pmremap2 = (memaddr | MEM_WINDOW_EN);
+            break;
+
+#if defined(CONFIG_USB)
+        case USB_HOST_SLOT:
+            dev->resource[0].start = USB_HOST_BASE;
+            dev->resource[0].end = USB_HOST_BASE+USB_BAR0_MEM_SIZE-1;
+            break;
+#endif
+    }
+}
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+        return 0;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_BROADCOM, PCI_ANY_ID,
+          bcm96348_fixup);
+
+/*struct pci_fixup pcibios_fixups[] = {
+    { PCI_FIXUP_FINAL, PCI_ANY_ID, PCI_ANY_ID, bcm96348_fixup },
+    {0}
+};*/
diff -urN linux.old/arch/mips/pci/Makefile linux.dev/arch/mips/pci/Makefile
--- linux.old/arch/mips/pci/Makefile	2006-08-25 00:43:29.000000000 +0200
+++ linux.dev/arch/mips/pci/Makefile	2006-08-25 00:39:38.000000000 +0200
@@ -18,6 +18,7 @@
 obj-$(CONFIG_MIPS_TX3927)	+= ops-tx3927.o
 obj-$(CONFIG_PCI_VR41XX)	+= ops-vr41xx.o pci-vr41xx.o
 obj-$(CONFIG_NEC_CMBVR4133)	+= fixup-vr4133.o
+obj-$(CONFIG_BCM_PCI)		+= fixup-bcm96348.o pci-bcm96348.o ops-bcm96348.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
diff -urN linux.old/arch/mips/pci/ops-bcm96348.c linux.dev/arch/mips/pci/ops-bcm96348.c
--- linux.old/arch/mips/pci/ops-bcm96348.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/arch/mips/pci/ops-bcm96348.c	2006-08-25 00:39:38.000000000 +0200
@@ -0,0 +1,276 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/addrspace.h>
+
+#include <bcm_intr.h>
+#include <bcm_map_part.h>
+#include <bcmpci.h>
+
+#include <linux/delay.h>
+
+#if defined(CONFIG_USB)
+#if 0
+#define DPRINT(x...)        printk(x)
+#else
+#define DPRINT(x...)
+#endif
+
+static int 
+pci63xx_int_read(unsigned int devfn, int where, u32 * value, int size);
+static int 
+pci63xx_int_write(unsigned int devfn, int where, u32 * value, int size);
+
+static bool usb_mem_size_rd = FALSE;
+static uint32 usb_mem_base = 0;
+static uint32 usb_cfg_space_cmd_reg = 0;
+#endif
+static bool pci_mem_size_rd = FALSE;
+
+static volatile MpiRegisters * mpi = (MpiRegisters *)(MPI_BASE);
+
+static void mpi_SetupPciConfigAccess(uint32 addr)
+{
+    mpi->l2pcfgctl = (DIR_CFG_SEL | DIR_CFG_USEREG | addr) & ~CONFIG_TYPE;
+}
+
+static void mpi_ClearPciConfigAccess(void)
+{
+    mpi->l2pcfgctl = 0x00000000;
+}
+
+#if defined(CONFIG_USB)
+/* --------------------------------------------------------------------------
+    Name: pci63xx_int_write
+Abstract: PCI Config write on internal device(s)
+ -------------------------------------------------------------------------- */
+static int 
+pci63xx_int_write(unsigned int devfn, int where, u32 * value, int size)
+{
+    if (PCI_SLOT(devfn) != USB_HOST_SLOT) {
+        return PCIBIOS_SUCCESSFUL;
+    }
+
+    switch (size) {
+        case 1:
+            DPRINT("W => Slot: %d Where: %2X Len: %d Data: %02X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        case 2:
+            DPRINT("W => Slot: %d Where: %2X Len: %d Data: %04X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            switch (where) {
+                case PCI_COMMAND:
+                    usb_cfg_space_cmd_reg = *value;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case 4:
+            DPRINT("W => Slot: %d Where: %2X Len: %d Data: %08lX\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            switch (where) {
+                case PCI_BASE_ADDRESS_0:
+                    if (*value == 0xffffffff) {
+                        usb_mem_size_rd = TRUE;
+                    } else {
+                        usb_mem_base = *value;
+                    }
+                    break;
+                default:
+                    break;
+            }
+            break;
+        default:
+            break;
+    }
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+/* --------------------------------------------------------------------------
+    Name: pci63xx_int_read
+Abstract: PCI Config read on internal device(s)
+ -------------------------------------------------------------------------- */
+static int 
+pci63xx_int_read(unsigned int devfn, int where, u32 * value, int size)
+{
+    uint32 retValue = 0xFFFFFFFF;
+
+    if (PCI_SLOT(devfn) != USB_HOST_SLOT) {
+        return PCIBIOS_SUCCESSFUL;
+    }
+
+    // For now, this is specific to the USB Host controller. We can
+    // make it more general if we have to...
+    // Emulate PCI Config accesses
+    switch (where) {
+        case PCI_VENDOR_ID:     
+        case PCI_DEVICE_ID:
+            retValue = PCI_VENDOR_ID_BROADCOM | 0x63000000;
+            break;
+        case PCI_COMMAND:
+        case PCI_STATUS:
+            retValue = (0x0006 << 16) | usb_cfg_space_cmd_reg;
+            break;
+        case PCI_CLASS_REVISION:
+        case PCI_CLASS_DEVICE:
+            retValue = (PCI_CLASS_SERIAL_USB << 16) | (0x10 << 8) | 0x01;
+            break;
+        case PCI_BASE_ADDRESS_0:
+            if (usb_mem_size_rd) {
+                retValue = USB_BAR0_MEM_SIZE;
+            } else {
+                if (usb_mem_base != 0)
+                    retValue = usb_mem_base;
+                else
+                    retValue = USB_HOST_BASE;
+            }
+            usb_mem_size_rd = FALSE;
+            break;
+        case PCI_CACHE_LINE_SIZE:
+        case PCI_LATENCY_TIMER:
+            retValue = 0;
+            break;
+        case PCI_HEADER_TYPE:
+            retValue = PCI_HEADER_TYPE_NORMAL;
+            break;
+        case PCI_SUBSYSTEM_VENDOR_ID:
+            retValue = PCI_VENDOR_ID_BROADCOM;
+            break;
+        case PCI_SUBSYSTEM_ID:
+            retValue = 0x6300;
+            break;
+        case PCI_INTERRUPT_LINE:
+            retValue = INTERRUPT_ID_USBH; 
+            break;
+        default:
+            break;
+    }
+
+    switch (size) {
+        case 1:
+            *value = (retValue >> ((where & 3) << 3)) & 0xff;
+            DPRINT("R <= Slot: %d Where: %2X Len: %d Data: %02X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        case 2:
+            *value = (retValue >> ((where & 3) << 3)) & 0xffff;
+            DPRINT("R <= Slot: %d Where: %2X Len: %d Data: %04X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        case 4:
+            *value = retValue;
+            DPRINT("R <= Slot: %d Where: %2X Len: %d Data: %08lX\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        default:
+            break;
+    }
+
+    return PCIBIOS_SUCCESSFUL;
+}
+#endif
+
+static int bcm96348_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+	int where, int size, u32 * val)
+{
+    volatile unsigned char *ioBase = (unsigned char *)(mpi->l2piobase | KSEG1);
+    uint32 data;
+
+#if defined(CONFIG_USB)
+    if (PCI_SLOT(devfn) == USB_HOST_SLOT)
+        return pci63xx_int_read(devfn, where, val, size);
+#endif
+
+    mpi_SetupPciConfigAccess(BCM_PCI_CFG(PCI_SLOT(devfn), PCI_FUNC(devfn), where));
+    data = *(uint32 *)ioBase;
+    switch(size) {
+        case 1:
+            *val = (data >> ((where & 3) << 3)) & 0xff;
+            break;
+        case 2:
+            *val = (data >> ((where & 3) << 3)) & 0xffff;
+            break;
+        case 4:
+            *val = data;
+             /* Special case for reading PCI device range */
+            if ((where >= PCI_BASE_ADDRESS_0) && (where <= PCI_BASE_ADDRESS_5)) {
+                if (pci_mem_size_rd) {
+                    /* bcm6348 PCI memory window minimum size is 64K */
+                    *val &= PCI_SIZE_64K;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    pci_mem_size_rd = FALSE;
+    mpi_ClearPciConfigAccess();
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm96348_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+	int where, int size, u32 val)
+{
+    volatile unsigned char *ioBase = (unsigned char *)(mpi->l2piobase | KSEG1);
+    uint32 data;
+
+#if defined(CONFIG_USB)
+    if (PCI_SLOT(devfn) == USB_HOST_SLOT)
+        return pci63xx_int_write(devfn, where, &val, size);
+#endif
+    mpi_SetupPciConfigAccess(BCM_PCI_CFG(PCI_SLOT(devfn), PCI_FUNC(devfn), where));
+    data = *(uint32 *)ioBase;
+    switch(size) {
+        case 1:
+            data = (data & ~(0xff << ((where & 3) << 3))) |
+                (val << ((where & 3) << 3));
+            break;
+        case 2:
+            data = (data & ~(0xffff << ((where & 3) << 3))) |
+                (val << ((where & 3) << 3));
+            break;
+        case 4:
+            data = val;
+            /* Special case for reading PCI device range */
+            if ((where >= PCI_BASE_ADDRESS_0) && (where <= PCI_BASE_ADDRESS_5)) {
+                if (val == 0xffffffff)
+                    pci_mem_size_rd = TRUE;
+            }
+            break;
+        default:
+            break;
+    }
+    *(uint32 *)ioBase = data;
+    udelay(500);
+    mpi_ClearPciConfigAccess();
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops bcm96348_pci_ops = {
+    .read   = bcm96348_pcibios_read,
+    .write  = bcm96348_pcibios_write
+};
diff -urN linux-2.6.17/arch/mips/pci/pci-bcm96348.c linux-2.6.17-brcm63xx/arch/mips/pci/pci-bcm96348.c
--- linux-2.6.17/arch/mips/pci/pci-bcm96348.c   1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.17-brcm63xx/arch/mips/pci/pci-bcm96348.c  2006-08-29 10:25:13.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+<:copyright-gpl
+ Copyright 2002 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+//#include <asm/pci_channel.h>
+#include <bcmpci.h>
+
+static struct resource bcm_pci_io_resource = {
+    .name   = "bcm96348 pci IO space",
+    .start  = BCM_PCI_IO_BASE,
+    .end    = BCM_PCI_IO_BASE + BCM_PCI_IO_SIZE_64KB - 1,
+    .flags  = IORESOURCE_IO
+};
+
+static struct resource bcm_pci_mem_resource = {
+    .name   = "bcm96348 pci memory space",
+    .start  = BCM_PCI_MEM_BASE,
+    .end    = BCM_PCI_MEM_BASE + BCM_PCI_MEM_SIZE_16MB - 1,
+    .flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops bcm96348_pci_ops;
+
+struct pci_controller bcm96348_controller = {
+    .pci_ops   = &bcm96348_pci_ops,
+    .io_resource       = &bcm_pci_io_resource,
+    .mem_resource      = &bcm_pci_mem_resource,
+};
+
+static void bcm96348_pci_init(void)
+{
+    register_pci_controller(&bcm96348_controller);
+}
+
+arch_initcall(bcm96348_pci_init);
diff -urN linux.old/drivers/serial/bcm63xx_cons.c linux.dev/drivers/serial/bcm63xx_cons.c
--- linux.old/drivers/serial/bcm63xx_cons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/drivers/serial/bcm63xx_cons.c	2006-08-25 15:37:34.000000000 +0200
@@ -0,0 +1,1049 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+/* Description: Serial port driver for the BCM963XX. */
+
+#define CARDNAME    "bcm963xx_serial driver"
+#define VERSION     "2.0"
+#define VER_STR     CARDNAME " v" VERSION "\n"
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h> 
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+/* for definition of struct console */
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <asm/uaccess.h>
+
+#include <bcmtypes.h>
+#include <board.h>
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+static DEFINE_SPINLOCK(bcm963xx_serial_lock);
+
+extern void _putc(char);
+extern void _puts(const char *);
+
+typedef struct bcm_serial {
+    volatile Uart *         port;
+    int                     type;
+    int                     flags; 
+    int                     irq;
+    int                     baud_base;
+    int                     blocked_open;
+    unsigned short          close_delay;
+    unsigned short          closing_wait;
+    unsigned short          line;                /* port/line number */
+    unsigned short          cflags;              /* line configuration flag */
+    unsigned short          x_char;              /* xon/xoff character */
+    unsigned short          read_status_mask;    /* mask for read condition */
+    unsigned short          ignore_status_mask;  /* mask for ignore condition */
+    unsigned long           event;               /* mask used in BH */
+    int                     xmit_head;           /* Position of the head */
+    int                     xmit_tail;           /* Position of the tail */
+    int                     xmit_cnt;            /* Count of the chars in the buffer */
+    int                     count;               /* indicates how many times it has been opened */
+    int                     magic;
+
+    struct async_icount     icount;              /* keep track of things ... */
+    struct tty_struct       *tty;                /* tty associated */    
+    struct termios          normal_termios;
+
+    wait_queue_head_t       open_wait;
+    wait_queue_head_t       close_wait;
+
+    long                    session;             /* Session of opening process */
+    long                    pgrp;                /* pgrp of opening process */
+
+    unsigned char           is_initialized;
+} Context;
+
+
+/*---------------------------------------------------------------------*/
+/* Define bits in the Interrupt Enable register                        */
+/*---------------------------------------------------------------------*/
+/* Enable receive interrupt              */
+#define RXINT   (RXFIFONE|RXOVFERR)
+
+/* Enable transmit interrupt             */
+#define TXINT    (TXFIFOEMT|TXUNDERR|TXOVFERR) 
+
+/* Enable receiver line status interrupt */
+#define LSINT    (RXBRK|RXPARERR|RXFRAMERR)
+
+#define BCM_NUM_UARTS                   1
+
+#define BD_BCM63XX_TIMER_CLOCK_INPUT    (FPERIPH)
+
+
+static struct bcm_serial multi[BCM_NUM_UARTS];
+static struct bcm_serial *lines[BCM_NUM_UARTS];
+static struct tty_driver *serial_driver;
+static struct termios *serial_termios[BCM_NUM_UARTS];
+static struct termios *serial_termios_locked[BCM_NUM_UARTS];
+
+
+static void bcm_stop (struct tty_struct *tty);
+static void bcm_start (struct tty_struct *tty);
+static inline void receive_chars (struct bcm_serial * info);
+static int startup (struct bcm_serial *info);
+static void shutdown (struct bcm_serial * info);
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag );
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty);
+static int bcm63xx_cons_write (struct tty_struct *tty, 
+    const unsigned char *buf, int count);
+static int bcm63xx_cons_write_room (struct tty_struct *tty);
+static int bcm_chars_in_buffer (struct tty_struct *tty);
+static void bcm_flush_buffer (struct tty_struct *tty);
+static void bcm_throttle (struct tty_struct *tty);
+static void bcm_unthrottle (struct tty_struct *tty);
+static void bcm_send_xchar (struct tty_struct *tty, char ch);
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo);
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info);
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value);
+static void send_break (struct bcm_serial *info, int duration);
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg);
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios);
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp);
+static void bcm_hangup (struct tty_struct *tty);
+static int block_til_ready (struct tty_struct *tty, struct file *filp, struct bcm_serial *info);
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp);
+static int __init bcm63xx_serialinit(void);
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop () and rs_start ()
+ *
+ * These routines are called before setting or resetting 
+ * tty->stopped. They enable or disable transmitter interrupts, 
+ * as necessary.
+ * ------------------------------------------------------------
+ */
+static void bcm_stop (struct tty_struct *tty)
+{
+}  
+
+static void bcm_start (struct tty_struct *tty)
+{
+    _puts(CARDNAME " Start\n");
+}  
+
+/*
+ * ------------------------------------------------------------
+ * receive_char ()
+ *
+ * This routine deals with inputs from any lines.
+ * ------------------------------------------------------------
+ */
+static inline void receive_chars (struct bcm_serial * info)
+{
+    struct tty_struct *tty = 0;
+    struct async_icount * icount;
+    int ignore = 0;
+    unsigned short status, tmp;
+    UCHAR ch = 0;
+    while ((status = info->port->intStatus) & RXINT)
+    {
+		char flag_char = TTY_NORMAL;
+
+        if (status & RXFIFONE)
+            ch = info->port->Data;  // Read the character
+        tty = info->tty;                  /* now tty points to the proper dev */
+        icount = &info->icount;
+        if (! tty)
+            break;
+        if (!tty_buffer_request_room(tty, 1))
+            break;
+        icount->rx++;
+        if (status & RXBRK)
+        {
+            flag_char = TTY_BREAK;
+            icount->brk++;
+        }
+        // keep track of the statistics
+        if (status & (RXFRAMERR | RXPARERR | RXOVFERR))
+        {
+            if (status & RXPARERR)                /* parity error */
+                icount->parity++;
+            else
+                if (status & RXFRAMERR)           /* frame error */
+                    icount->frame++;
+            if (status & RXOVFERR)
+            {
+                // Overflow. Reset the RX FIFO
+                info->port->fifoctl |= RSTRXFIFOS;
+                icount->overrun++;
+            }
+            // check to see if we should ignore the character
+            // and mask off conditions that should be ignored
+            if (status & info->ignore_status_mask)
+            {
+                if (++ignore > 100 )
+                    break;
+                goto ignore_char;
+            }
+            // Mask off the error conditions we want to ignore
+            tmp = status & info->read_status_mask;
+            if (tmp & RXPARERR)
+            {
+                flag_char = TTY_PARITY;
+            }
+            else
+                if (tmp & RXFRAMERR)
+                {
+                    flag_char = TTY_FRAME;
+                }
+            if (tmp & RXOVFERR)
+            {
+	        tty_insert_flip_char(tty, ch, flag_char);
+		ch = 0;
+		flag_char = TTY_OVERRUN;
+		if (!tty_buffer_request_room(tty, 1))
+		  break;
+            }
+        }
+	tty_insert_flip_char(tty, ch, flag_char);
+    }
+ignore_char:;
+	tty_flip_buffer_push(tty);
+	tty_schedule_flip(tty);
+
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * bcm_interrupt ()
+ *
+ * this is the main interrupt routine for the chip.
+ * It deals with the multiple ports.
+ * ------------------------------------------------------------
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static irqreturn_t bcm_interrupt (int irq, void * dev)
+#else
+static void bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#endif
+{
+    struct bcm_serial * info = lines[0];
+    UINT16  intStat;
+
+    /* get pending interrupt flags from UART  */
+
+    /* Mask with only the serial interrupts that are enabled */
+    intStat = info->port->intStatus & info->port->intMask;
+    while (intStat)
+    {
+        if (intStat & RXINT)
+            receive_chars (info);          
+        else
+            if (intStat & TXINT)
+                info->port->intStatus = TXINT;
+            else /* don't know what it was, so let's mask it */
+                info->port->intMask &= ~intStat;
+
+        intStat = info->port->intStatus & info->port->intMask;
+    }
+
+    // Clear the interrupt
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    return IRQ_HANDLED;
+#endif    
+}
+
+/*
+ * -------------------------------------------------------------------
+ * startup ()
+ *
+ * various initialization tasks
+ * ------------------------------------------------------------------- 
+ */
+static int startup (struct bcm_serial *info)
+{
+    // Port is already started...
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * shutdown ()
+ *
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ * ------------------------------------------------------------------- 
+ */
+static void shutdown (struct bcm_serial * info)
+{
+    unsigned long flags;
+    if (!info->is_initialized)
+        return;
+
+    spin_lock_irqsave(&bcm963xx_serial_lock, flags);
+
+    info->port->control &= ~(BRGEN|TXEN|RXEN);
+    if (info->tty)
+        set_bit (TTY_IO_ERROR, &info->tty->flags);
+    info->is_initialized = 0;
+
+    spin_unlock_irqrestore(&bcm963xx_serial_lock, flags);
+}
+/* 
+ * -------------------------------------------------------------------
+ * change_speed ()
+ *
+ * Set the baud rate, character size, parity and stop bits.
+ * ------------------------------------------------------------------- 
+ */
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag )
+{
+    unsigned long ulFlags, ulBaud, ulClockFreqHz, ulTmp;
+	
+    spin_lock_irqsave(&bcm963xx_serial_lock, ulFlags);
+    switch( cFlag & (CBAUD | CBAUDEX) )
+    {
+    case B115200:
+        ulBaud = 115200;
+        break;
+    case B57600:
+        ulBaud = 57600;
+        break;
+    case B38400:
+        ulBaud = 38400;
+        break;
+    case B19200:
+        ulBaud = 19200;
+        break;
+    case B9600:
+        ulBaud = 9600;
+        break;
+    case B4800:
+        ulBaud = 4800;
+        break;
+    case B2400:
+        ulBaud = 2400;
+        break;
+    case B1800:
+        ulBaud = 1800;
+        break;
+    case B1200:
+        ulBaud = 1200;
+        break;
+    case B600:
+        ulBaud = 600;
+        break;
+    case B300:
+        ulBaud = 300;
+        break;
+    case B200:
+        ulBaud = 200;
+        break;
+    case B150:
+        ulBaud = 150;
+        break;
+    case B134:
+        ulBaud = 134;
+        break;
+    case B110:
+        ulBaud = 110;
+        break;
+    case B75:
+        ulBaud = 75;
+        break;
+    case B50:
+        ulBaud = 50;
+        break;
+    default:
+        ulBaud = 115200;
+        break;
+    }
+
+    /* Calculate buad rate.  */
+    ulClockFreqHz = BD_BCM63XX_TIMER_CLOCK_INPUT;
+    ulTmp = (ulClockFreqHz / ulBaud) / 16;
+    if( ulTmp & 0x01 )
+        ulTmp /= 2; /* Rounding up, so sub is already accounted for */
+    else
+        ulTmp = (ulTmp / 2) - 1; /* Rounding down so we must sub 1 */
+    pUart->baudword = ulTmp;
+
+    /* Set character size, stop bits and parity.  */
+    switch( cFlag & CSIZE )
+    {
+    case CS5:
+        ulTmp = BITS5SYM; /* select transmit 5 bit data size */
+        break;
+    case CS6:
+        ulTmp = BITS6SYM; /* select transmit 6 bit data size */
+        break;
+    case CS7:
+        ulTmp = BITS7SYM; /* select transmit 7 bit data size */
+        break;
+    default:
+        ulTmp = BITS8SYM; /* select transmit 8 bit data size */
+        break;
+    }
+    if( cFlag & CSTOPB )
+        ulTmp |= TWOSTOP;         /* select 2 stop bits */
+    else
+        ulTmp |= ONESTOP;         /* select one stop bit */
+
+    /* Write these values into the config reg.  */
+    pUart->config = ulTmp;
+    pUart->control &= ~(RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN);
+    switch( cFlag & (PARENB | PARODD) )
+    {
+    case PARENB|PARODD:
+        pUart->control |= RXPARITYEN | TXPARITYEN;
+        break;
+    case PARENB:
+        pUart->control |= RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN;
+        break;
+    default:
+        pUart->control |= 0;
+        break;
+    }
+
+    /* Reset and flush uart */
+    pUart->fifoctl = RSTTXFIFOS | RSTRXFIFOS;
+    spin_unlock_irqrestore(&bcm963xx_serial_lock, ulFlags);
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_char ()
+ *
+ * Nothing to flush.  Polled I/O is used.
+ * ------------------------------------------------------------------- 
+ */
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty)
+{
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write ()
+ *
+ * Main output routine using polled I/O.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write (struct tty_struct *tty, 
+    const unsigned char *buf, int count)
+{
+    int c;
+
+    for (c = 0; c < count; c++)
+        _putc(buf[c]);
+    return count;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write_room ()
+ *
+ * Compute the amount of space available for writing.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write_room (struct tty_struct *tty)
+{
+    /* Pick a number.  Any number.  Polled I/O is used. */
+    return 1024;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_chars_in_buffer ()
+ *
+ * compute the amount of char left to be transmitted
+ * ------------------------------------------------------------------- 
+ */
+static int bcm_chars_in_buffer (struct tty_struct *tty)
+{
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_buffer ()
+ *
+ * Empty the output buffer
+ * ------------------------------------------------------------------- 
+ */
+static void bcm_flush_buffer (struct tty_struct *tty)
+{
+	tty_wakeup(tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm_throttle () and bcm_unthrottle ()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled (or not).
+ * ------------------------------------------------------------
+ */
+static void bcm_throttle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+        info->x_char = STOP_CHAR(tty);
+}
+
+static void bcm_unthrottle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+    {
+        if (info->x_char)
+            info->x_char = 0;
+        else
+            info->x_char = START_CHAR(tty);
+    }
+}
+
+static void bcm_send_xchar (struct tty_struct *tty, char ch)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+    info->x_char = ch;
+    if (ch)
+        bcm_start (info->tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl () and friends
+ * ------------------------------------------------------------
+ */
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo)
+{
+    struct serial_struct tmp;
+
+    if (!retinfo)
+        return -EFAULT;
+
+    memset (&tmp, 0, sizeof(tmp));
+    tmp.type            = info->type;
+    tmp.line            = info->line;
+    tmp.port            = (int) info->port;
+    tmp.irq             = info->irq;
+    tmp.flags           = 0;
+    tmp.baud_base       = info->baud_base;
+    tmp.close_delay     = info->close_delay;
+    tmp.closing_wait    = info->closing_wait;
+
+    return copy_to_user (retinfo, &tmp, sizeof(*retinfo));
+}
+
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info)
+{
+    struct serial_struct new_serial;
+    struct bcm_serial old_info;
+    int retval = 0;
+
+    if (!new_info)
+        return -EFAULT;
+
+    copy_from_user (&new_serial, new_info, sizeof(new_serial));
+    old_info = *info;
+
+    if (!capable(CAP_SYS_ADMIN))
+        return -EPERM;
+
+
+    if (info->count > 1)
+        return -EBUSY;
+
+    /* OK, past this point, all the error checking has been done.
+     * At this point, we start making changes.....
+     */
+    info->baud_base = new_serial.baud_base;
+    info->type = new_serial.type;
+    info->close_delay = new_serial.close_delay;
+    info->closing_wait = new_serial.closing_wait;
+    retval = startup (info);
+    return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ *          is emptied.  On bus types like RS485, the transmitter must
+ *          release the bus after transmitting. This must be done when
+ *          the transmit shift register is empty, not be done when the
+ *          transmit holding register is empty.  This functionality
+ *          allows an RS485 driver to be written in user space. 
+ */
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value)
+{
+    return( 0 );
+}
+
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void send_break (struct bcm_serial *info, int duration)
+{
+    unsigned long flags;
+
+    if (!info->port)
+        return;
+
+    current->state = TASK_INTERRUPTIBLE;
+
+    /*save_flags (flags);
+    cli();*/
+    spin_lock_irqsave(&bcm963xx_serial_lock, flags);
+
+    info->port->control |= XMITBREAK;
+    schedule_timeout(duration);
+    info->port->control &= ~XMITBREAK;
+
+    spin_unlock_irqrestore(&bcm963xx_serial_lock, flags);
+    //restore_flags (flags);
+}
+
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg)
+{
+    int error;
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    int retval;
+
+    if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+        (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD)  &&
+        (cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT))
+    {
+        if (tty->flags & (1 << TTY_IO_ERROR))
+            return -EIO;
+    }
+    switch (cmd) 
+    {
+
+    case TCSBRK:    /* SVID version: non-zero arg --> no break */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        if (!arg)
+            send_break (info, HZ/4); /* 1/4 second */
+        return 0;
+
+    case TCSBRKP:   /* support for POSIX tcsendbreak() */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        send_break (info, arg ? arg*(HZ/10) : HZ/4);
+        return 0;
+
+    case TIOCGSOFTCAR:
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(long));
+        if (!error)
+            return -EFAULT;
+	else
+	{
+	    put_user (C_CLOCAL(tty) ? 1 : 0, (unsigned long *)arg);
+	    return 0;
+	}
+
+    case TIOCSSOFTCAR:
+        error = get_user (arg, (unsigned long *)arg);
+        if (error)
+            return error;
+        tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+        return 0;
+
+    case TIOCGSERIAL:
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(struct serial_struct));
+        if (!error)
+            return -EFAULT;
+	else
+	    return get_serial_info (info, (struct serial_struct *)arg);
+
+    case TIOCSSERIAL:
+        return set_serial_info (info, (struct serial_struct *) arg);
+
+    case TIOCSERGETLSR: /* Get line status register */
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(unsigned int));
+        if (!error)
+            return -EFAULT;
+        else
+            return get_lsr_info (info, (unsigned int *)arg);
+
+    case TIOCSERGSTRUCT:
+        error = access_ok (VERIFY_WRITE, (void *)arg, sizeof(struct bcm_serial));
+        if (!error)
+            return -EFAULT;
+	else
+	{
+	    copy_to_user((struct bcm_serial *)arg, info, sizeof(struct bcm_serial));
+	    return 0;
+	}
+
+    default:
+        return -ENOIOCTLCMD;
+    }
+    return 0;
+}
+
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    if( tty->termios->c_cflag != old_termios->c_cflag )
+        change_speed (info->port, tty->termios->c_cflag);
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm63xx_cons_close()
+ * 
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we turn off
+ * the transmit enable and receive enable flags.
+ * ------------------------------------------------------------
+ */
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp)
+{
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    unsigned long flags;
+
+    if (!info)
+        return;
+
+    /*save_flags (flags); 
+    cli();*/
+    spin_lock_irqsave(&bcm963xx_serial_lock, flags);
+
+    if (tty_hung_up_p (filp))
+    {
+        spin_unlock_irqrestore(&bcm963xx_serial_lock, flags);
+        //restore_flags (flags);
+        return;
+    }
+
+    if ((tty->count == 1) && (info->count != 1))
+    {
+
+        /* Uh, oh.  tty->count is 1, which means that the tty
+         * structure will be freed.  Info->count should always
+         * be one in these conditions.  If it's greater than
+         * one, we've got real problems, since it means the
+         * serial port won't be shutdown.
+         */
+        printk("bcm63xx_cons_close: bad serial port count; tty->count is 1, "
+            "info->count is %d\n", info->count);
+        info->count = 1;
+    }
+
+    if (--info->count < 0)
+    {
+        printk("ds_close: bad serial port count for ttys%d: %d\n",
+        info->line, info->count);
+        info->count = 0;
+    }
+
+    if (info->count)
+    {
+        //restore_flags (flags);
+	spin_unlock_irqrestore(&bcm963xx_serial_lock, flags);
+        return;
+    }
+
+    /* Now we wait for the transmit buffer to clear; and we notify 
+     * the line discipline to only process XON/XOFF characters.
+     */
+    tty->closing = 1;
+
+    /* At this point we stop accepting input.  To do this, we
+     * disable the receive line status interrupts.
+     */
+    shutdown (info);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (tty->driver->flush_buffer)
+        tty->driver->flush_buffer (tty);
+#else    
+    if (tty->driver.flush_buffer)
+        tty->driver.flush_buffer (tty);
+#endif
+    if (tty->ldisc.flush_buffer)
+        tty->ldisc.flush_buffer (tty);
+
+    tty->closing = 0;
+    info->event = 0;
+    info->tty = 0;
+    if (tty->ldisc.num != tty_ldisc_get(N_TTY)->num)
+    {
+        if (tty->ldisc.close)
+            (tty->ldisc.close)(tty);
+        tty->ldisc = *tty_ldisc_get(N_TTY);
+        tty->termios->c_line = N_TTY;
+        if (tty->ldisc.open)
+            (tty->ldisc.open)(tty);
+    }
+    if (info->blocked_open)
+    {
+        if (info->close_delay)
+        {
+            current->state = TASK_INTERRUPTIBLE;
+            schedule_timeout(info->close_delay);
+        }
+        wake_up_interruptible (&info->open_wait);
+    }
+    wake_up_interruptible (&info->close_wait);
+
+    //restore_flags (flags);
+    spin_unlock_irqrestore(&bcm963xx_serial_lock, flags);
+}
+
+/*
+ * bcm_hangup () --- called by tty_hangup() when a hangup is signaled.
+ */
+static void bcm_hangup (struct tty_struct *tty)
+{
+
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    shutdown (info);
+    info->event = 0;
+    info->count = 0;
+    info->tty = 0;
+    wake_up_interruptible (&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready (struct tty_struct *tty, struct file *filp,
+    struct bcm_serial *info)
+{
+    return 0;
+}       
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port. It also performs the 
+ * serial-specific initialization for the tty structure.
+ */
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp)
+{
+    struct bcm_serial *info;
+    int retval, line;
+
+    // Make sure we're only opening on of the ports we support
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    line = MINOR(tty->driver->cdev.dev) - tty->driver->minor_start;
+#else
+    line = MINOR(tty->device) - tty->driver.minor_start;
+#endif    
+
+    if ((line < 0) || (line >= BCM_NUM_UARTS))
+        return -ENODEV;
+
+    info = lines[line];
+
+    tty->low_latency=1;
+    info->port->intMask  = 0;     /* Clear any pending interrupts */
+    info->port->intMask  = RXINT; /* Enable RX */
+
+    info->count++;
+    tty->driver_data = info;
+    info->tty = tty;
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+
+    // Start up serial port
+    retval = startup (info);
+    if (retval)
+        return retval;
+
+    retval = block_til_ready (tty, filp, info);
+    if (retval)
+        return retval;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    info->pgrp = process_group(current);
+    info->session = current->signal->session;
+#else
+    info->session = current->session;    
+    info->pgrp = current->pgrp;
+#endif    
+
+    return 0;
+}
+
+
+static struct tty_operations rs_ops = {
+	.open = bcm63xx_cons_open,
+	.close = bcm63xx_cons_close,
+	.write = bcm63xx_cons_write,
+	.flush_chars = bcm63xx_cons_flush_chars,
+	.write_room = bcm63xx_cons_write_room,
+	.chars_in_buffer = bcm_chars_in_buffer,
+	.flush_buffer = bcm_flush_buffer,
+	.ioctl = bcm_ioctl,
+	.throttle = bcm_throttle,
+	.unthrottle = bcm_unthrottle,
+	.send_xchar = bcm_send_xchar,
+	.set_termios = bcm_set_termios,
+	.stop = bcm_stop,
+	.start = bcm_start,
+	.hangup = bcm_hangup,
+};
+
+/* --------------------------------------------------------------------------
+    Name: bcm63xx_serialinit
+ Purpose: Initialize our BCM63xx serial driver
+-------------------------------------------------------------------------- */
+static int __init bcm63xx_serialinit(void)
+{
+    int i, flags;
+    struct bcm_serial * info;
+
+    // Print the driver version information
+    printk(VER_STR);
+    serial_driver = alloc_tty_driver(BCM_NUM_UARTS);
+    if (!serial_driver)
+	return -ENOMEM;
+
+	serial_driver->owner 	    = THIS_MODULE;
+	serial_driver->devfs_name 	    = "tts/";
+//    serial_driver.magic             = TTY_DRIVER_MAGIC;
+    serial_driver->name              = "ttyS";
+    serial_driver->major             = TTY_MAJOR;
+    serial_driver->minor_start       = 64;
+//    serial_driver.num               = BCM_NUM_UARTS;
+    serial_driver->type              = TTY_DRIVER_TYPE_SERIAL;
+    serial_driver->subtype           = SERIAL_TYPE_NORMAL;
+    serial_driver->init_termios      = tty_std_termios;
+    serial_driver->init_termios.c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;
+    serial_driver->flags             = TTY_DRIVER_REAL_RAW;
+
+    serial_driver->termios           = serial_termios;
+    serial_driver->termios_locked    = serial_termios_locked;
+    
+    tty_set_operations(serial_driver, &rs_ops);
+
+    if (tty_register_driver (serial_driver))
+        panic("Couldn't register serial driver\n");
+
+    //save_flags(flags); cli();
+    spin_lock_irqsave(&bcm963xx_serial_lock, flags);
+    
+    for (i = 0; i < BCM_NUM_UARTS; i++)
+    {
+        info = &multi[i]; 
+        lines[i] = info;
+        info->magic = SERIAL_MAGIC;
+        info->port                  = (Uart *) ((char *)UART_BASE + (i * 0x20));
+        info->tty                   = 0;
+        info->irq                   = (2 - i) + 8;
+        info->line                  = i;
+        info->close_delay           = 50;
+        info->closing_wait          = 3000;
+        info->x_char                = 0;
+        info->event                 = 0;
+        info->count                 = 0;
+        info->blocked_open          = 0;	
+        info->normal_termios        = serial_driver->init_termios;
+        init_waitqueue_head(&info->open_wait); 
+        init_waitqueue_head(&info->close_wait); 
+
+        /* If we are pointing to address zero then punt - not correctly
+         * set up in setup.c to handle this. 
+         */
+        if (! info->port)
+            return 0;
+        BcmHalMapInterrupt(bcm_interrupt, 0, INTERRUPT_ID_UART);
+    }
+
+    /* order matters here... the trick is that flags
+     * is updated... in request_irq - to immediatedly obliterate
+     * it is unwise. 
+     */
+    spin_unlock_irqrestore(&bcm963xx_serial_lock, flags);
+    return 0;
+}
+
+module_init(bcm63xx_serialinit);
+
+/* --------------------------------------------------------------------------
+    Name: bcm_console_print
+ Purpose: bcm_console_print is registered for printk.
+          The console_lock must be held when we get here.
+-------------------------------------------------------------------------- */
+static void bcm_console_print (struct console * cons, const char * str,
+    unsigned int count)
+{
+    unsigned int i;
+    //_puts(str);
+    for(i=0; i<count; i++, str++)
+    {
+        _putc(*str);
+        if (*str == 10)
+        {
+            _putc(13);
+        }
+    }
+}
+
+static struct tty_driver * bcm_console_device(struct console * c, int *index)
+{
+    *index = c->index;
+    return serial_driver;
+}
+
+static int __init bcm_console_setup(struct console * co, char * options)
+{
+    return 0;
+}
+
+static struct console bcm_sercons = {
+    .name	= "ttyS",
+    .write	= bcm_console_print,
+    .device	= bcm_console_device,
+    .setup	= bcm_console_setup,
+    .flags	= CON_PRINTBUFFER,
+    .index	= -1,
+};
+
+static int __init bcm63xx_console_init(void)
+{
+    register_console(&bcm_sercons);
+    return 0;
+}
+
+console_initcall(bcm63xx_console_init);
diff -urN linux.old/drivers/serial/Makefile linux.dev/drivers/serial/Makefile
--- linux.old/drivers/serial/Makefile	2006-06-18 03:49:35.000000000 +0200
+++ linux.dev/drivers/serial/Makefile	2006-08-25 15:38:44.000000000 +0200
@@ -55,3 +55,4 @@
 obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
 obj-$(CONFIG_SERIAL_SGI_IOC3) += ioc3_serial.o
 obj-$(CONFIG_SERIAL_AT91) += at91_serial.o
+obj-$(CONFIG_BCM_SERIAL) += bcm63xx_cons.o
diff -urN linux.old/include/asm-mips/bootinfo.h linux.dev/include/asm-mips/bootinfo.h
--- linux.old/include/asm-mips/bootinfo.h	2006-08-25 00:43:22.000000000 +0200
+++ linux.dev/include/asm-mips/bootinfo.h	2006-08-25 00:39:38.000000000 +0200
@@ -218,6 +218,14 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+/*
+ * Valid machtype for group BRCM
+ */
+#define MACH_GROUP_BRCM        23      /* Broadcom boards              */
+#define MACH_BCM96338          0
+#define MACH_BCM96345          1
+#define MACH_BCM96348          2
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
diff -urN linux.old/include/asm-mips/cpu.h linux.dev/include/asm-mips/cpu.h
--- linux.old/include/asm-mips/cpu.h	2006-08-25 00:43:22.000000000 +0200
+++ linux.dev/include/asm-mips/cpu.h	2006-08-25 00:39:38.000000000 +0200
@@ -103,6 +103,13 @@
 
 #define PRID_IMP_SR71000        0x0400
 
+/* These are the PRID's for when 23:16 == PRID_COMP_BROADCOM
+ */
+
+#define PRID_IMP_BCM6338       	0x9000
+#define PRID_IMP_BCM6345       	0x8000
+#define PRID_IMP_BCM6348       	0x9100
+
 /*
  * Definitions for 7:0 on legacy processors
  */
@@ -200,7 +207,10 @@
 #define CPU_SB1A		62
 #define CPU_74K			63
 #define CPU_R14000		64
-#define CPU_LAST		64
+#define CPU_BCM6338             65
+#define CPU_BCM6345             66
+#define CPU_BCM6348             67
+#define CPU_LAST		67
 
 /*
  * ISA Level encodings
diff -urN linux.old/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h linux.dev/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h
--- linux.old/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.dev/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h	2006-08-25 11:27:40.000000000 +0200
@@ -0,0 +1,36 @@
+#ifndef __ASM_MACH_BCM963XX_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_BCM963XX_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_tlb			1
+#define cpu_has_4kex			4
+#define cpu_has_4ktlb			8
+#define cpu_has_fpu			0
+#define cpu_has_32fpr			0
+#define cpu_has_counter			0x40
+#define cpu_has_watch			0
+#define cpu_has_mips16			0
+#define cpu_has_divec			0x200
+#define cpu_has_vce			0
+#define cpu_has_cache_cdex_p		0
+#define cpu_has_cache_cdex_s		0
+#define cpu_has_prefetch		0x40000
+#define cpu_has_mcheck			0x2000
+#define cpu_has_ejtag			0x4000
+#define cpu_has_llsc			0x10000
+#define cpu_has_vtag_icache		0
+#define cpu_has_dc_aliases		0
+#define cpu_has_ic_fills_f_dc		0
+
+#define cpu_has_nofpuex			0
+#define cpu_has_64bits			0
+#define cpu_has_64bit_zero_reg		0
+#define cpu_has_64bit_gp_regs		0
+#define cpu_has_64bit_addresses		0
+
+#define cpu_has_subset_pcaches		0
+
+#define cpu_dcache_line_size()		16
+#define cpu_icache_line_size()		16
+#define cpu_scache_line_size()		0
+
+#endif /* __ASM_MACH_BCM963XX_CPU_FEATURE_OVERRIDES_H */
diff -urN linux.old/include/asm-mips/mach-generic/param.h linux.dev/include/asm-mips/mach-generic/param.h
--- linux.old/include/asm-mips/mach-generic/param.h	2006-08-25 00:43:22.000000000 +0200
+++ linux.dev/include/asm-mips/mach-generic/param.h	2006-08-25 00:39:38.000000000 +0200
@@ -8,6 +8,6 @@
 #ifndef __ASM_MACH_GENERIC_PARAM_H
 #define __ASM_MACH_GENERIC_PARAM_H
 
-#define HZ		1000		/* Internal kernel timer frequency */
+#define HZ		200		/* Internal kernel timer frequency */
 
 #endif /* __ASM_MACH_GENERIC_PARAM_H */
diff -urN linux.old/include/asm-mips/module.h linux.dev/include/asm-mips/module.h
--- linux.old/include/asm-mips/module.h	2006-08-25 00:43:22.000000000 +0200
+++ linux.dev/include/asm-mips/module.h	2006-08-25 00:39:38.000000000 +0200
@@ -113,6 +113,12 @@
 #define MODULE_PROC_FAMILY "RM9000 "
 #elif defined CONFIG_CPU_SB1
 #define MODULE_PROC_FAMILY "SB1 "
+#elif defined CONFIG_CPU_BCM6338
+#define MODULE_PROC_FAMILY "BCM6338 "
+#elif defined CONFIG_CPU_BCM6345
+#define MODULE_PROC_FAMILY "BCM6345 "
+#elif defined CONFIG_CPU_BCM6348
+#define MODULE_PROC_FAMILY "BCM6348 "
 #else
 #error MODULE_PROC_FAMILY undefined for your processor configuration
 #endif

