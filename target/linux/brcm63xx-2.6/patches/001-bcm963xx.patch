diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/Kconfig linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/Kconfig
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/Kconfig	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,169 @@
+# Kernel and Driver configuration for Broadcom Commengine ADSL board
+choice
+	prompt "Broadcom Commengine ADSL board"
+	depends on MIPS_BRCM
+	default BCM96345
+	help
+	  Select different Broadcom ADSL board
+
+config BCM96338
+	bool "96338 ADSL board"
+	select DMA_NONCOHERENT
+
+config BCM96345
+	bool "96345 ADSL board"
+	select DMA_NONCOHERENT
+
+config BCM96348
+	bool "96348 ADSL board"
+	select DMA_NONCOHERENT
+
+endchoice
+
+config BCM_BOARD
+	bool "Support for Broadcom Board"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SERIAL
+	bool "Support for Serial Port"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENET
+	tristate "Support for Ethernet"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_USB
+	tristate "Support for USB"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_WLAN
+	tristate "Support for Wireless"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_PCI
+	bool "Support for PCI"
+	depends on BCM96338 || BCM96345 || BCM96348
+	select PCI
+
+config BCM_ATMAPI
+	tristate "Support for ATM"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ATMTEST
+	tristate "Support for ATM Diagnostic"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ADSL
+	tristate "Support for ADSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENDPOINT
+	tristate "Support for VOICE"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_PROCFS
+	tristate "Support for PROCFS"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_VDSL
+	tristate "Support for VDSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SECURITY
+	tristate "Support for SECURITY"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_HPNA
+	tristate "Support for HPNA"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_BOARD_IMPL
+	int "Implementation index for ADSL Board"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SERIAL_IMPL
+	int "Implementation index for Serial"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENET_IMPL
+	int "Implementation index for Ethernet"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_USB_IMPL
+	int "Implementation index for USB"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_WLAN_IMPL
+	int "Implementation index for WIRELESS"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ATMAPI_IMPL
+	int "Implementation index for ATM"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ATMTEST_IMPL
+	int "Implementation index for ATM Diagnostic"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_BLAA_IMPL
+	int "Implementation index for BLAA"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ADSL_IMPL
+	int "Implementation index for ADSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_ENDPOINT_IMPL
+	int "Implementation index for VOICE"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_PROCFS_IMPL
+	int "Implementation index for PROCFS"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_VDSL_IMPL
+	int "Implementation index for VDSL"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_SECURITY_IMPL
+	int "Implementation index for SECURITY"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+config BCM_HPNA_IMPL
+	int "Implementation index for HPNA"
+	depends on BCM96338 || BCM96345 || BCM96348
+
+choice
+	prompt "Root File System"
+	depends on MIPS_BRCM
+	default ROOTFS_SQUASHFS
+	help
+	  Select root file system on the board flash. 
+
+config ROOTFS_SQUASHFS
+        bool "SQUASHFS"
+config ROOTFS_CRAMFS
+        bool "CRAMFS"
+config ROOTFS_JFFS2
+        bool "JFFS2"
+config ROOTFS_NFS
+        bool "NFS"
+
+endchoice
+
+config ROOT_FLASHFS
+	string "flash partition"
+	depends on ROOTFS_SQUASHFS || ROOTFS_CRAMFS || ROOTFS_JFFS2
+	default "root=31:0 ro noinitrd" if ROOTFS_SQUASHFS = y || ROOTFS_CRAMFS = y
+	default "root=31:2 ro noinitrd" if ROOTFS_JFFS2 = y
+	help
+	  This is the root file system partition on flash memory
+
+config ROOT_NFS_DIR
+	string "NFS server path"
+	depends on ROOTFS_NFS
+	default "/opt/bcm96338/targets/96338R/fs" if BCM96338 = y
+	default "/opt/bcm96345/targets/96345R/fs" if BCM96345 = y
+	default "/opt/bcm96348/targets/96348R/fs" if BCM96348 = y  
+	help
+	  This is the path of NFS server (host system)
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/Makefile linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/Makefile
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/Makefile	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,23 @@
+#
+# Makefile for generic Broadcom MIPS boards
+#
+# Copyright (C) 2004 Broadcom Corporation
+#
+obj-y           := irq.o prom.o setup.o time.o ser_init.o
+
+SRCBASE         := $(TOPDIR)
+EXTRA_CFLAGS    += -I$(INC_BRCMBOARDPARMS_PATH)/$(BRCM_BOARD) -I$(SRCBASE)/include -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+#EXTRA_CFLAGS    += -I$(INC_ADSLDRV_PATH) -DDBG
+EXTRA_CFLAGS    += -I$(INC_ADSLDRV_PATH) 
+
+
+ifeq "$(ADSL)" "ANNEX_B"
+EXTRA_CFLAGS += -DADSL_ANNEXB
+endif
+ifeq "$(ADSL)" "SADSL"
+EXTRA_CFLAGS += -DADSL_SADSL
+endif
+ifeq "$(ADSL)" "ANNEX_C"
+EXTRA_CFLAGS += -DADSL_ANNEXC
+endif
+
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/irq.c linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/irq.c
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/irq.c	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,276 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * Interrupt control functions for Broadcom 963xx MIPS boards
+ */
+
+#include <asm/atomic.h>
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/signal.h>
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+extern asmlinkage unsigned int do_IRQ(int irq, struct pt_regs *regs);
+
+static void irq_dispatch_int(struct pt_regs *regs)
+{
+    unsigned int pendingIrqs;
+    static unsigned int irqBit;
+    static unsigned int isrNumber = 31;
+
+    pendingIrqs = PERF->IrqStatus & PERF->IrqMask;
+    if (!pendingIrqs) {
+        return;
+    }
+
+    while (1) {
+	irqBit <<= 1;
+	isrNumber++;
+	if (isrNumber == 32) {
+		isrNumber = 0;
+		irqBit = 0x1;
+	}
+	if (pendingIrqs & irqBit) {
+	    	PERF->IrqMask &= ~irqBit; // mask
+        	do_IRQ(isrNumber + INTERNAL_ISR_TABLE_OFFSET, regs);
+		break;
+	}
+    }
+}
+
+static void irq_dispatch_ext(uint32 irq, struct pt_regs *regs)
+{
+    if (!(PERF->ExtIrqCfg & (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT)))) {
+	printk("**** Ext IRQ mask. Should not dispatch ****\n");
+    }
+    /* disable and clear interrupt in the controller */
+    PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_CLEAR_SHFT));
+    PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));
+    do_IRQ(irq, regs);
+}
+
+void brcm_irq_dispatch(struct pt_regs *regs)
+{
+    u32 cause;
+    while((cause = (read_c0_cause()& CAUSEF_IP))) {
+	if (cause & CAUSEF_IP7)
+		do_IRQ(MIPS_TIMER_INT, regs);
+	else if (cause & CAUSEF_IP2)
+		irq_dispatch_int(regs);
+	else if (cause & CAUSEF_IP3)
+		irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_0, regs);
+	else if (cause & CAUSEF_IP4)
+		irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_1, regs);
+	else if (cause & CAUSEF_IP5)
+		irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_2, regs);
+	else if (cause & CAUSEF_IP6)
+		irq_dispatch_ext(INTERRUPT_ID_EXTERNAL_3, regs);
+	cli();
+    }
+}
+
+
+void enable_brcm_irq(unsigned int irq)
+{
+    unsigned long flags;
+
+    local_irq_save(flags);
+    if( irq >= INTERNAL_ISR_TABLE_OFFSET ) {
+	PERF->IrqMask |= (1 << (irq - INTERNAL_ISR_TABLE_OFFSET));
+    }
+    else if (irq >= INTERRUPT_ID_EXTERNAL_0 && irq <= INTERRUPT_ID_EXTERNAL_3) {
+    /* enable and clear interrupt in the controller */
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_CLEAR_SHFT));
+	PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));
+    }
+    local_irq_restore(flags);
+}
+
+void disable_brcm_irq(unsigned int irq)
+{
+    unsigned long flags;
+
+    local_irq_save(flags);
+    if( irq >= INTERNAL_ISR_TABLE_OFFSET ) {
+	PERF->IrqMask &= ~(1 << (irq - INTERNAL_ISR_TABLE_OFFSET));
+    }
+    else if (irq >= INTERRUPT_ID_EXTERNAL_0 && irq <= INTERRUPT_ID_EXTERNAL_3) {
+    /* disable interrupt in the controller */
+	PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));
+    }
+    local_irq_restore(flags);
+}
+
+void ack_brcm_irq(unsigned int irq)
+{
+    /* Already done in brcm_irq_dispatch */
+}
+
+unsigned int startup_brcm_irq(unsigned int irq)
+{
+    enable_brcm_irq(irq);
+
+    return 0; /* never anything pending */
+}
+
+unsigned int startup_brcm_none(unsigned int irq)
+{
+    return 0;
+}
+
+void end_brcm_irq(unsigned int irq)
+{
+    if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+        enable_brcm_irq(irq);
+}
+
+void end_brcm_none(unsigned int irq)
+{
+}
+
+#define ALLINTS_NOTIMER (IE_IRQ0 | IE_IRQ1 | IE_IRQ2 | IE_IRQ3 | IE_IRQ4)
+
+static void __init brcm_irq_setup(void)
+{
+	extern asmlinkage void brcmIRQ(void);
+
+	clear_c0_status(ST0_BEV);
+    	set_except_vector(0, brcmIRQ);
+	change_c0_status(ST0_IM, ALLINTS_NOTIMER);
+
+#ifdef CONFIG_REMOTE_DEBUG
+	rs_kgdb_hook(0);
+#endif
+}
+
+static struct hw_interrupt_type brcm_irq_type = {
+    .typename	= "MIPS",
+    .startup	= startup_brcm_irq,
+    .shutdown	= disable_brcm_irq,
+    .enable	= enable_brcm_irq,
+    .disable	= disable_brcm_irq,
+    .ack	= ack_brcm_irq,
+    .end	= end_brcm_irq,
+    .set_affinity = NULL
+};
+
+static struct hw_interrupt_type brcm_irq_no_end_type = {
+    .typename	= "MIPS",
+    .startup	= startup_brcm_none,
+    .shutdown	= disable_brcm_irq,
+    .enable	= enable_brcm_irq,
+    .disable	= disable_brcm_irq,
+    .ack	= ack_brcm_irq,
+    .end	= end_brcm_none,
+    .set_affinity = NULL
+};
+
+void __init arch_init_irq(void)
+{
+    int i;
+
+    for (i = 0; i < NR_IRQS; i++) {
+        irq_desc[i].status = IRQ_DISABLED;
+        irq_desc[i].action = 0;
+        irq_desc[i].depth = 1;
+        irq_desc[i].handler = &brcm_irq_type;
+    }
+
+    brcm_irq_setup();
+}
+
+int request_external_irq(unsigned int irq, 
+	FN_HANDLER handler,
+        unsigned long irqflags, 
+        const char * devname,
+        void *dev_id)
+{
+    unsigned long flags;
+
+    local_irq_save(flags);
+
+    PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_CLEAR_SHFT));      // Clear
+    PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_MASK_SHFT));      // Mask
+    PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_INSENS_SHFT));    // Edge insesnsitive
+    PERF->ExtIrqCfg |= (1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_LEVEL_SHFT));      // Level triggered
+    PERF->ExtIrqCfg &= ~(1 << (irq - INTERRUPT_ID_EXTERNAL_0 + EI_SENSE_SHFT));     // Low level
+
+    local_irq_restore(flags);
+
+    return( request_irq(irq, handler, irqflags, devname, dev_id) );
+}
+
+/* VxWorks compatibility function(s). */
+
+unsigned int BcmHalMapInterrupt(FN_HANDLER pfunc, unsigned int param,
+    unsigned int interruptId)
+{
+    int nRet = -1;
+    char *devname;
+
+    devname = kmalloc(16, GFP_KERNEL);
+    if (devname)
+        sprintf( devname, "brcm_%d", interruptId );
+
+    /* Set the IRQ description to not automatically enable the interrupt at
+     * the end of an ISR.  The driver that handles the interrupt must
+     * explicitly call BcmHalInterruptEnable or enable_brcm_irq.  This behavior
+     * is consistent with interrupt handling on VxWorks.
+     */
+    irq_desc[interruptId].handler = &brcm_irq_no_end_type;
+
+    if( interruptId >= INTERNAL_ISR_TABLE_OFFSET )
+    {
+        nRet = request_irq( interruptId, pfunc, SA_SAMPLE_RANDOM | SA_INTERRUPT,
+            devname, (void *) param );
+    }
+    else if (interruptId >= INTERRUPT_ID_EXTERNAL_0 && interruptId <= INTERRUPT_ID_EXTERNAL_3)
+    {
+        nRet = request_external_irq( interruptId, pfunc, SA_SAMPLE_RANDOM | SA_INTERRUPT,
+            devname, (void *) param );
+    }
+
+    return( nRet );
+}
+
+
+/* Debug function. */
+
+void dump_intr_regs(void)
+{
+    printk("PERF->ExtIrqCfg [%08x]\n", *(&(PERF->ExtIrqCfg)));
+} 
+
+EXPORT_SYMBOL(enable_brcm_irq);
+EXPORT_SYMBOL(disable_brcm_irq);
+EXPORT_SYMBOL(request_external_irq);
+EXPORT_SYMBOL(BcmHalMapInterrupt);
+
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/prom.c linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/prom.c
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/prom.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/prom.c	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,233 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * prom.c: PROM library initialization code.
+ *
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+#include <linux/blkdev.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/time.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#include "boardparms.h"
+#include "softdsl/AdslCoreDefs.h"
+
+
+extern int  do_syslog(int, char *, int);
+extern void serial_init(void);
+extern void __init InitNvramInfo( void );
+extern void kerSysFlashInit( void );
+extern unsigned long get_nvram_start_addr(void);
+void __init create_root_nfs_cmdline( char *cmdline );
+
+#if defined(CONFIG_BCM96338)
+#define CPU_CLOCK                   240000000
+#define MACH_BCM                    MACH_BCM96338
+#endif
+#if defined(CONFIG_BCM96345)
+#define CPU_CLOCK                   140000000
+#define MACH_BCM                    MACH_BCM96345
+#endif
+#if defined(CONFIG_BCM96348)
+void __init calculateCpuSpeed(void);
+static unsigned long cpu_speed;
+#define CPU_CLOCK                   cpu_speed
+#define MACH_BCM                    MACH_BCM96348
+#endif
+
+const char *get_system_type(void)
+{
+    PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+
+    return( pNvramData->szBoardId );
+}
+
+unsigned long getMemorySize(void)
+{
+    unsigned long ulSdramType = BOARD_SDRAM_TYPE;
+
+    unsigned long ulSdramSize;
+
+    switch( ulSdramType )
+    {
+    case BP_MEMORY_16MB_1_CHIP:
+    case BP_MEMORY_16MB_2_CHIP:
+        ulSdramSize = 16 * 1024 * 1024;
+        break;
+    case BP_MEMORY_32MB_1_CHIP:
+    case BP_MEMORY_32MB_2_CHIP:
+        ulSdramSize = 32 * 1024 * 1024;
+        break;
+    case BP_MEMORY_64MB_2_CHIP:
+        ulSdramSize = 64 * 1024 * 1024;
+        break;
+    default:
+        ulSdramSize = 8 * 1024 * 1024;
+        break;
+    }
+
+    return ulSdramSize;
+}
+
+/* --------------------------------------------------------------------------
+    Name: prom_init
+ -------------------------------------------------------------------------- */
+void __init prom_init(void)
+{
+    extern ulong r4k_interval;
+
+    serial_init();
+
+    kerSysFlashInit();
+
+    do_syslog(8, NULL, 8);
+
+    printk( "%s prom init\n", get_system_type() );
+
+    PERF->IrqMask = 0;
+
+    arcs_cmdline[0] = '\0';
+
+#if defined(CONFIG_ROOT_NFS)
+    create_root_nfs_cmdline( arcs_cmdline );
+#elif defined(CONFIG_ROOT_FLASHFS)
+    strcpy(arcs_cmdline, CONFIG_ROOT_FLASHFS);
+#endif
+
+    add_memory_region(0, (getMemorySize() - ADSL_SDRAM_IMAGE_SIZE), BOOT_MEM_RAM);
+
+#if defined(CONFIG_BCM96348)
+    calculateCpuSpeed();
+#endif
+    /* Count register increments every other clock */
+    r4k_interval = CPU_CLOCK / HZ / 2;
+    mips_hpt_frequency = CPU_CLOCK / 2;
+
+    mips_machgroup = MACH_GROUP_BRCM;
+    mips_machtype = MACH_BCM;
+}
+
+/* --------------------------------------------------------------------------
+    Name: prom_free_prom_memory
+Abstract: 
+ -------------------------------------------------------------------------- */
+void __init prom_free_prom_memory(void)
+{
+
+}
+
+
+#if defined(CONFIG_ROOT_NFS)
+/* This function reads in a line that looks something like this:
+ *
+ *
+ * CFE bootline=bcmEnet(0,0)host:vmlinux e=192.169.0.100:ffffff00 h=192.169.0.1
+ *
+ *
+ * and retuns in the cmdline parameter some that looks like this:
+ *
+ * CONFIG_CMDLINE="root=/dev/nfs nfsroot=192.168.0.1:/opt/targets/96345R/fs
+ * ip=192.168.0.100:192.168.0.1::255.255.255.0::eth0:off rw"
+ */
+#define BOOT_LINE_ADDR   0x0
+#define HEXDIGIT(d) ((d >= '0' && d <= '9') ? (d - '0') : ((d | 0x20) - 'W'))
+#define HEXBYTE(b)  (HEXDIGIT((b)[0]) << 4) + HEXDIGIT((b)[1])
+extern unsigned long get_nvram_start_addr(void);
+
+void __init create_root_nfs_cmdline( char *cmdline )
+{
+    char root_nfs_cl[] = "root=/dev/nfs nfsroot=%s:" CONFIG_ROOT_NFS_DIR
+        " ip=%s:%s::%s::eth0:off rw";
+
+    char *localip = NULL;
+    char *hostip = NULL;
+    char mask[16] = "";
+    PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+    char bootline[128] = "";
+    char *p = bootline;
+
+    memcpy(bootline, pNvramData->szBootline, sizeof(bootline));
+    while( *p )
+    {
+        if( p[0] == 'e' && p[1] == '=' )
+        {
+            /* Found local ip address */
+            p += 2;
+            localip = p;
+            while( *p && *p != ' ' && *p != ':' )
+                p++;
+            if( *p == ':' )
+            {
+                /* Found network mask (eg FFFFFF00 */
+                *p++ = '\0';
+                sprintf( mask, "%u.%u.%u.%u", HEXBYTE(p), HEXBYTE(p + 2),
+                HEXBYTE(p + 4), HEXBYTE(p + 6) );
+                p += 4;
+            }
+            else if( *p == ' ' )
+                *p++ = '\0';
+        }
+        else if( p[0] == 'h' && p[1] == '=' )
+        {
+            /* Found host ip address */
+            p += 2;
+            hostip = p;
+            while( *p && *p != ' ' )
+                p++;
+            if( *p == ' ' )
+                    *p++ = '\0';
+        }
+        else 
+            p++;
+    }
+
+    if( localip && hostip ) 
+        sprintf( cmdline, root_nfs_cl, hostip, localip, hostip, mask );
+}
+#endif
+
+#if defined(CONFIG_BCM96348)
+/*  *********************************************************************
+    *  calculateCpuSpeed()
+    *      Calculate the BCM6348 CPU speed by reading the PLL strap register
+    *      and applying the following formula:
+    *      cpu_clk = (.25 * 64MHz freq) * (N1 + 1) * (N2 + 2) / (M1_CPU + 1)
+    *  Input parameters:
+    *      none
+    *  Return value:
+    *      none
+    ********************************************************************* */
+void __init calculateCpuSpeed(void)
+{
+    UINT32 pllStrap = PERF->PllStrap;
+    int n1 = (pllStrap & PLL_N1_MASK) >> PLL_N1_SHFT;
+    int n2 = (pllStrap & PLL_N2_MASK) >> PLL_N2_SHFT;
+    int m1cpu = (pllStrap & PLL_M1_CPU_MASK) >> PLL_M1_CPU_SHFT;
+
+    cpu_speed = (16 * (n1 + 1) * (n2 + 2) / (m1cpu + 1)) * 1000000;
+}
+#endif
+
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/ser_init.c linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/ser_init.c
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/ser_init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/ser_init.c	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,180 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ *  Broadcom bcm63xx serial port initialization, also prepare for printk
+ *  by registering with console_init
+ *   
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/console.h>
+#include <linux/sched.h>
+
+#include <asm/addrspace.h>
+#include <asm/irq.h>
+#include <asm/reboot.h>
+#include <asm/gdb-stub.h>
+#include <asm/mc146818rtc.h> 
+
+#include <bcm_map_part.h>
+#include <board.h>
+
+#define  SER63XX_DEFAULT_BAUD      115200
+#define BD_BCM63XX_TIMER_CLOCK_INPUT    (FPERIPH)
+#define stUart ((volatile Uart * const) UART_BASE)
+
+// Transmit interrupts
+#define TXINT       (TXFIFOEMT | TXUNDERR | TXOVFERR)
+// Receive interrupts
+#define RXINT       (RXFIFONE | RXOVFERR)
+
+/* --------------------------------------------------------------------------
+    Name: serial_init
+ Purpose: Initalize the UART
+-------------------------------------------------------------------------- */
+void __init serial_init(void)
+{
+    UINT32 tmpVal = SER63XX_DEFAULT_BAUD;
+    ULONG clockFreqHz;    
+
+#if defined(CONFIG_BCM96345)
+    // Make sure clock is ticking
+    PERF->blkEnables |= UART_CLK_EN;
+#endif
+		
+    /* Dissable channel's receiver and transmitter.                */
+    stUart->control &= ~(BRGEN|TXEN|RXEN);
+		
+    /*--------------------------------------------------------------------*/
+    /* Write the table value to the clock select register.                */
+    /* DPullen - this is the equation to use:                             */
+    /*       value = clockFreqHz / baud / 32-1;                           */
+    /*   (snmod) Actually you should also take into account any necessary */
+    /*           rounding.  Divide by 16, look at lsb, if 0, divide by 2  */
+    /*           and subtract 1.  If 1, just divide by 2                  */
+    /*--------------------------------------------------------------------*/
+    clockFreqHz = BD_BCM63XX_TIMER_CLOCK_INPUT;
+    tmpVal = (clockFreqHz / tmpVal) / 16;
+    if( tmpVal & 0x01 )
+        tmpVal /= 2;  //Rounding up, so sub is already accounted for
+    else
+        tmpVal = (tmpVal / 2) - 1; // Rounding down so we must sub 1
+    stUart->baudword = tmpVal;
+        
+    /* Finally, re-enable the transmitter and receiver.            */
+    stUart->control |= (BRGEN|TXEN|RXEN);
+
+    stUart->config   = (BITS8SYM | ONESTOP);
+    // Set the FIFO interrupt depth ... stUart->fifocfg  = 0xAA;
+    stUart->fifoctl  =  RSTTXFIFOS | RSTRXFIFOS;
+    stUart->intMask  = 0;       
+    stUart->intMask = RXINT | TXINT;
+}
+
+
+/* prom_putc()
+ * Output a character to the UART
+ */
+void prom_putc(char c)
+{
+	/* Wait for Tx uffer to empty */
+	while (! (READ16(stUart->intStatus) & TXFIFOEMT));
+	/* Send character */
+	stUart->Data = c;
+}
+
+/* prom_puts()
+ * Write a string to the UART
+ */
+void prom_puts(const char *s)
+{
+	while (*s) {
+		if (*s == '\n') {
+			prom_putc('\r');
+		}
+		prom_putc(*s++);
+	}
+}
+
+
+/* prom_getc_nowait()
+ * Returns a character from the UART
+ * Returns -1 if no characters available or corrupted
+ */
+int prom_getc_nowait(void)
+{
+    uint16  uStatus;
+    int    cData = -1;
+
+     uStatus = READ16(stUart->intStatus);
+
+     if (uStatus & RXFIFONE) { /* Do we have a character? */
+           cData =  READ16(stUart->Data) & 0xff; /* Read character */
+           if (uStatus & (RXFRAMERR | RXPARERR)) {  /* If we got an error, throw it away */
+               cData = -1;
+           }
+  }
+
+   return cData;
+}
+
+/* prom_getc()
+ * Returns a charcter from the serial port
+ * Will block until it receives a valid character
+*/
+char prom_getc(void)
+{
+    int    cData = -1;
+
+    /* Loop until we get a valid character */
+    while(cData == -1) {
+	cData = prom_getc_nowait();
+    }
+   return (char) cData;
+}
+
+/* prom_testc()
+ * Returns 0 if no characters available
+ */
+int prom_testc(void)
+{
+    uint16  uStatus;
+
+     uStatus = READ16(stUart->intStatus);
+
+     return (uStatus & RXFIFONE);
+}
+
+#if CONFIG_REMOTE_DEBUG
+/* Prevent other code from writing to the serial port */
+void _putc(char c) { }
+void _puts(const char *ptr) { }
+#else
+/* Low level outputs call prom routines */
+void _putc(char c) {
+	prom_putc(c);
+}
+void _puts(const char *ptr) {
+	prom_puts(ptr);
+}
+#endif
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/setup.c linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/setup.c
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/setup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/setup.c	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,519 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * Generic setup routines for Broadcom 963xx MIPS boards
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/console.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include <asm/addrspace.h>
+#include <asm/bcache.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+#include <asm/gdb-stub.h>
+
+extern void brcm_timer_setup(struct irqaction *irq);
+extern unsigned long getMemorySize(void);
+
+#if defined(CONFIG_BCM96348) && defined(CONFIG_PCI)
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <bcm_map_part.h>
+#include <bcmpci.h>
+
+static volatile MpiRegisters * mpi = (MpiRegisters *)(MPI_BASE);
+#endif
+
+/* This function should be in a board specific directory.  For now,
+ * assume that all boards that include this file use a Broadcom chip
+ * with a soft reset bit in the PLL control register.
+ */
+static void brcm_machine_restart(char *command)
+{
+    const unsigned long ulSoftReset = 0x00000001;
+    unsigned long *pulPllCtrl = (unsigned long *) 0xfffe0008;
+    *pulPllCtrl |= ulSoftReset;
+}
+
+static void brcm_machine_halt(void)
+{
+    printk("System halted\n");
+    while (1);
+}
+
+#if defined(CONFIG_BCM96348) && defined(CONFIG_PCI)
+
+static void mpi_SetLocalPciConfigReg(uint32 reg, uint32 value)
+{
+    /* write index then value */
+    mpi->pcicfgcntrl = PCI_CFG_REG_WRITE_EN + reg;;
+    mpi->pcicfgdata = value;
+}
+
+static uint32 mpi_GetLocalPciConfigReg(uint32 reg)
+{
+    /* write index then get value */
+    mpi->pcicfgcntrl = PCI_CFG_REG_WRITE_EN + reg;;
+    return mpi->pcicfgdata;
+}
+
+/*
+ * mpi_ResetPcCard: Set/Reset the PcCard
+ */
+static void mpi_ResetPcCard(int cardtype, BOOL bReset)
+{
+    if (cardtype == MPI_CARDTYPE_NONE) {
+        return;
+    }
+
+    if (cardtype == MPI_CARDTYPE_CARDBUS) {
+        bReset = ! bReset;
+    }
+
+    if (bReset) {
+        mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 & ~PCCARD_CARD_RESET);
+    } else {
+        mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 | PCCARD_CARD_RESET);
+    }
+}
+
+/*
+ * mpi_ConfigCs: Configure an MPI/EBI chip select
+ */
+static void mpi_ConfigCs(uint32 cs, uint32 base, uint32 size, uint32 flags)
+{
+    mpi->cs[cs].base = ((base & 0x1FFFFFFF) | size);
+    mpi->cs[cs].config = flags;
+}
+
+/*
+ * mpi_InitPcmciaSpace
+ */
+static void mpi_InitPcmciaSpace(void)
+{
+    // ChipSelect 4 controls PCMCIA Memory accesses
+    mpi_ConfigCs(PCMCIA_COMMON_BASE, pcmciaMem, EBI_SIZE_1M, (EBI_WORD_WIDE|EBI_ENABLE));
+    // ChipSelect 5 controls PCMCIA Attribute accesses
+    mpi_ConfigCs(PCMCIA_ATTRIBUTE_BASE, pcmciaAttr, EBI_SIZE_1M, (EBI_WORD_WIDE|EBI_ENABLE));
+    // ChipSelect 6 controls PCMCIA I/O accesses
+    mpi_ConfigCs(PCMCIA_IO_BASE, pcmciaIo, EBI_SIZE_64K, (EBI_WORD_WIDE|EBI_ENABLE));
+
+    mpi->pcmcia_cntl2 = ((PCMCIA_ATTR_ACTIVE << RW_ACTIVE_CNT_BIT) | 
+                         (PCMCIA_ATTR_INACTIVE << INACTIVE_CNT_BIT) | 
+                         (PCMCIA_ATTR_CE_SETUP << CE_SETUP_CNT_BIT) | 
+                         (PCMCIA_ATTR_CE_HOLD << CE_HOLD_CNT_BIT));
+
+    mpi->pcmcia_cntl2 |= (PCMCIA_HALFWORD_EN | PCMCIA_BYTESWAP_DIS);
+}
+
+/*
+ * cardtype_vcc_detect: PC Card's card detect and voltage sense connection
+ * 
+ *   CD1#/      CD2#/     VS1#/     VS2#/    Card       Initial Vcc
+ *  CCD1#      CCD2#     CVS1      CVS2      Type
+ *
+ *   GND        GND       open      open     16-bit     5 vdc
+ *
+ *   GND        GND       GND       open     16-bit     3.3 vdc
+ *
+ *   GND        GND       open      GND      16-bit     x.x vdc
+ *
+ *   GND        GND       GND       GND      16-bit     3.3 & x.x vdc
+ *
+ *====================================================================
+ *
+ *   CVS1       GND       CCD1#     open     CardBus    3.3 vdc
+ *
+ *   GND        CVS2      open      CCD2#    CardBus    x.x vdc
+ *
+ *   GND        CVS1      CCD2#     open     CardBus    y.y vdc
+ *
+ *   GND        CVS2      GND       CCD2#    CardBus    3.3 & x.x vdc
+ *
+ *   CVS2       GND       open      CCD1#    CardBus    x.x & y.y vdc
+ *
+ *   GND        CVS1      CCD2#     open     CardBus    3.3, x.x & y.y vdc
+ *
+ */
+static int cardtype_vcc_detect(void)
+{
+    uint32 data32;
+    int cardtype;
+
+    cardtype = MPI_CARDTYPE_NONE;
+    mpi->pcmcia_cntl1 = 0x0000A000; // Turn on the output enables and drive
+                                        // the CVS pins to 0.
+    data32 = mpi->pcmcia_cntl1;
+    switch (data32 & 0x00000003)  // Test CD1# and CD2#, see if card is plugged in.
+    {
+    case 0x00000003:  // No Card is in the slot.
+        printk("mpi: No Card is in the PCMCIA slot\n");
+        break;
+
+    case 0x00000002:  // Partial insertion, No CD2#.
+        printk("mpi: Card in the PCMCIA slot partial insertion, no CD2 signal\n");
+        break;
+
+    case 0x00000001:  // Partial insertion, No CD1#.
+        printk("mpi: Card in the PCMCIA slot partial insertion, no CD1 signal\n");
+        break;
+
+    case 0x00000000:
+        mpi->pcmcia_cntl1 = 0x0000A0C0; // Turn off the CVS output enables and
+                                        // float the CVS pins.
+        mdelay(1);
+        data32 = mpi->pcmcia_cntl1;
+        // Read the Register.
+        switch (data32 & 0x0000000C)  // See what is on the CVS pins.
+        {
+        case 0x00000000: // CVS1 and CVS2 are tied to ground, only 1 option.
+            printk("mpi: Detected 3.3 & x.x 16-bit PCMCIA card\n");
+            cardtype = MPI_CARDTYPE_PCMCIA;
+            break;
+          
+        case 0x00000004: // CVS1 is open or tied to CCD1/CCD2 and CVS2 is tied to ground.
+                         // 2 valid voltage options.
+        switch (data32 & 0x00000003)  // Test the values of CCD1 and CCD2.
+        {
+            case 0x00000003:  // CCD1 and CCD2 are tied to 1 of the CVS pins.
+                              // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+      
+            case 0x00000002:  // CCD2 is tied to either CVS1 or CVS2. 
+                mpi->pcmcia_cntl1 = 0x0000A080; // Drive CVS1 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000002) { // CCD2 is tied to CVS2, not valid.
+                    printk("mpi: Unknown card plugged into slot\n"); 
+                } else {                   // CCD2 is tied to CVS1.
+                    printk("mpi: Detected 3.3, x.x and y.y Cardbus card\n");
+                    cardtype = MPI_CARDTYPE_CARDBUS;
+                }
+                break;
+                
+            case 0x00000001: // CCD1 is tied to either CVS1 or CVS2.
+                             // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+                
+            case 0x00000000:  // CCD1 and CCD2 are tied to ground.
+                printk("mpi: Detected x.x vdc 16-bit PCMCIA card\n");
+                cardtype = MPI_CARDTYPE_PCMCIA;
+                break;
+            }
+            break;
+          
+        case 0x00000008: // CVS2 is open or tied to CCD1/CCD2 and CVS1 is tied to ground.
+                         // 2 valid voltage options.
+            switch (data32 & 0x00000003)  // Test the values of CCD1 and CCD2.
+            {
+            case 0x00000003:  // CCD1 and CCD2 are tied to 1 of the CVS pins.
+                              // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+      
+            case 0x00000002:  // CCD2 is tied to either CVS1 or CVS2.
+                mpi->pcmcia_cntl1 = 0x0000A040; // Drive CVS2 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000002) { // CCD2 is tied to CVS1, not valid.
+                    printk("mpi: Unknown card plugged into slot\n"); 
+                } else {// CCD2 is tied to CVS2.
+                    printk("mpi: Detected 3.3 and x.x Cardbus card\n");
+                    cardtype = MPI_CARDTYPE_CARDBUS;
+                }
+                break;
+
+            case 0x00000001: // CCD1 is tied to either CVS1 or CVS2.
+                             // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+
+            case 0x00000000:  // CCD1 and CCD2 are tied to ground.
+                cardtype = MPI_CARDTYPE_PCMCIA;
+                printk("mpi: Detected 3.3 vdc 16-bit PCMCIA card\n");
+                break;
+            }
+            break;
+          
+        case 0x0000000C:  // CVS1 and CVS2 are open or tied to CCD1/CCD2.
+                          // 5 valid voltage options.
+      
+            switch (data32 & 0x00000003)  // Test the values of CCD1 and CCD2.
+            {
+            case 0x00000003:  // CCD1 and CCD2 are tied to 1 of the CVS pins.
+                              // This is not a valid combination.
+                printk("mpi: Unknown card plugged into slot\n"); 
+                break;
+      
+            case 0x00000002:  // CCD2 is tied to either CVS1 or CVS2.
+                              // CCD1 is tied to ground.
+                mpi->pcmcia_cntl1 = 0x0000A040; // Drive CVS2 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000002) {  // CCD2 is tied to CVS1.
+                    printk("mpi: Detected y.y vdc Cardbus card\n");
+                } else {                    // CCD2 is tied to CVS2.
+                    printk("mpi: Detected x.x vdc Cardbus card\n");
+                }
+                cardtype = MPI_CARDTYPE_CARDBUS;
+                break;
+      
+            case 0x00000001: // CCD1 is tied to either CVS1 or CVS2.
+                             // CCD2 is tied to ground.
+      
+                mpi->pcmcia_cntl1 = 0x0000A040; // Drive CVS2 to a 0.
+                mdelay(1);
+                data32 = mpi->pcmcia_cntl1;
+                if (data32 & 0x00000001) {// CCD1 is tied to CVS1.
+                    printk("mpi: Detected 3.3 vdc Cardbus card\n");
+                } else {                    // CCD1 is tied to CVS2.
+                    printk("mpi: Detected x.x and y.y Cardbus card\n");
+                }
+                cardtype = MPI_CARDTYPE_CARDBUS;
+                break;
+      
+            case 0x00000000:  // CCD1 and CCD2 are tied to ground.
+                cardtype = MPI_CARDTYPE_PCMCIA;
+                printk("mpi: Detected 5 vdc 16-bit PCMCIA card\n");
+                break;
+            }
+            break;
+      
+        default:
+            printk("mpi: Unknown card plugged into slot\n"); 
+            break;
+        
+        }
+    }
+    return cardtype;
+}
+
+/*
+ * mpi_DetectPcCard: Detect the plugged in PC-Card
+ * Return: < 0 => Unknown card detected
+ *         0 => No card detected
+ *         1 => 16-bit card detected
+ *         2 => 32-bit CardBus card detected
+ */
+static int mpi_DetectPcCard(void)
+{
+    int cardtype;
+
+    cardtype = cardtype_vcc_detect();
+    switch(cardtype) {
+        case MPI_CARDTYPE_PCMCIA:
+            mpi->pcmcia_cntl1 &= ~0x0000e000; // disable enable bits
+            //mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 & ~PCCARD_CARD_RESET);
+            mpi->pcmcia_cntl1 |= (PCMCIA_ENABLE | PCMCIA_GPIO_ENABLE);
+            mpi_InitPcmciaSpace();
+            mpi_ResetPcCard(cardtype, FALSE);
+            // Hold card in reset for 10ms
+            mdelay(10);
+            mpi_ResetPcCard(cardtype, TRUE);
+            // Let card come out of reset
+            mdelay(100);
+            break;
+        case MPI_CARDTYPE_CARDBUS:
+            // 8 => CardBus Enable
+            // 1 => PCI Slot Number
+            // C => Float VS1 & VS2
+            mpi->pcmcia_cntl1 = (mpi->pcmcia_cntl1 & 0xFFFF0000) | 
+                                CARDBUS_ENABLE | 
+                                (CARDBUS_SLOT << 8)| 
+                                VS2_OEN |
+                                VS1_OEN;
+            /* access to this memory window will be to/from CardBus */
+            mpi->l2pmremap1 |= CARDBUS_MEM;
+
+            // Need to reset the Cardbus Card. There's no CardManager to do this, 
+            // and we need to be ready for PCI configuration. 
+            mpi_ResetPcCard(cardtype, FALSE);
+            // Hold card in reset for 10ms
+            mdelay(10);
+            mpi_ResetPcCard(cardtype, TRUE);
+            // Let card come out of reset
+            mdelay(100);
+            break;
+        default:
+            break;
+    }
+    return cardtype;
+}
+
+static int mpi_init(void)
+{
+    unsigned long data;
+    unsigned int chipid;
+    unsigned int chiprev;
+    unsigned int sdramsize;
+
+    chipid  = (PERF->RevID & 0xFFFF0000) >> 16;
+    chiprev = (PERF->RevID & 0xFF);
+    sdramsize = getMemorySize();
+    /*
+     * Init the pci interface 
+     */
+    data = GPIO->GPIOMode; // GPIO mode register
+    data |= GROUP2_PCI | GROUP1_MII_PCCARD; // PCI internal arbiter + Cardbus
+    GPIO->GPIOMode = data; // PCI internal arbiter
+
+    /*
+     * In the BCM6348 CardBus support is defaulted to Slot 0
+     * because there is no external IDSEL for CardBus.  To disable
+     * the CardBus and allow a standard PCI card in Slot 0 
+     * set the cbus_idsel field to 0x1f.
+    */
+    /*
+    uData = mpi->pcmcia_cntl1;
+    uData |= CARDBUS_IDSEL;
+    mpi->pcmcia_cntl1 = uData;
+    */
+    // Setup PCI I/O Window range. Give 64K to PCI I/O
+    mpi->l2piorange = ~(BCM_PCI_IO_SIZE_64KB-1);
+    // UBUS to PCI I/O base address 
+    mpi->l2piobase = BCM_PCI_IO_BASE & BCM_PCI_ADDR_MASK;
+    // UBUS to PCI I/O Window remap
+    mpi->l2pioremap = (BCM_PCI_IO_BASE | MEM_WINDOW_EN);
+
+    // enable PCI related GPIO pins and data swap between system and PCI bus
+    mpi->locbuscntrl = (EN_PCI_GPIO | DIR_U2P_NOSWAP);
+
+    /* Enable 6348 BusMaster and Memory access mode */
+    data = mpi_GetLocalPciConfigReg(PCI_COMMAND);
+    data |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+    mpi_SetLocalPciConfigReg(PCI_COMMAND, data);
+
+    /* Configure two 16 MByte PCI to System memory regions. */
+    /* These memory regions are used when PCI device is a bus master */
+    /* Accesses to the SDRAM from PCI bus will be "byte swapped" for this region */
+    mpi_SetLocalPciConfigReg(PCI_BASE_ADDRESS_3, BCM_HOST_MEM_SPACE1);
+    mpi->sp0remap = 0x0;
+
+    /* Accesses to the SDRAM from PCI bus will not be "byte swapped" for this region */
+    mpi_SetLocalPciConfigReg(PCI_BASE_ADDRESS_4, BCM_HOST_MEM_SPACE2);
+    mpi->sp1remap = 0x0;
+    mpi->pcimodesel |= (PCI_BAR2_NOSWAP | 0x40);
+
+    if ((chipid == 0x6348) && (chiprev == 0xb0)) {
+        mpi->sp0range = ~(sdramsize-1);
+        mpi->sp1range = ~(sdramsize-1);
+    }
+    /*
+     * Change 6348 PCI Cfg Reg. offset 0x40 to PCI memory read retry count infinity
+     * by set 0 in bit 8~15.  This resolve read Bcm4306 srom return 0xffff in
+     * first read.
+     */
+    data = mpi_GetLocalPciConfigReg(BRCM_PCI_CONFIG_TIMER);
+    data &= ~BRCM_PCI_CONFIG_TIMER_RETRY_MASK;
+    data |= 0x00000080;
+    mpi_SetLocalPciConfigReg(BRCM_PCI_CONFIG_TIMER, data);
+
+    /* enable pci interrupt */
+    mpi->locintstat |= (EXT_PCI_INT << 16);
+
+    mpi_DetectPcCard();
+
+    ioport_resource.start = BCM_PCI_IO_BASE;
+    ioport_resource.end = BCM_PCI_IO_BASE + BCM_PCI_IO_SIZE_64KB;
+
+#if defined(CONFIG_USB)
+    PERF->blkEnables |= USBH_CLK_EN;
+    mdelay(100);
+    *USBH_NON_OHCI = NON_OHCI_BYTE_SWAP;
+#endif
+
+    return 0;
+}
+#endif
+
+static int __init brcm63xx_setup(void)
+{
+    extern int panic_timeout;
+
+    _machine_restart = brcm_machine_restart;
+    _machine_halt = brcm_machine_halt;
+    _machine_power_off = brcm_machine_halt;
+
+    board_timer_setup = brcm_timer_setup;
+
+    panic_timeout = 180;
+
+#if defined(CONFIG_BCM96348) && defined(CONFIG_PCI)
+    /* mpi initialization */
+    mpi_init();
+#endif
+    return 0;
+}
+
+early_initcall(brcm63xx_setup);
+
+/***************************************************************************
+ * C++ New and delete operator functions
+ ***************************************************************************/
+
+/* void *operator new(unsigned int sz) */
+void *_Znwj(unsigned int sz)
+{
+    return( kmalloc(sz, GFP_KERNEL) );
+}
+
+/* void *operator new[](unsigned int sz)*/
+void *_Znaj(unsigned int sz)
+{
+    return( kmalloc(sz, GFP_KERNEL) );
+}
+
+/* placement new operator */
+/* void *operator new (unsigned int size, void *ptr) */
+void *ZnwjPv(unsigned int size, void *ptr)
+{
+    return ptr;
+}
+
+/* void operator delete(void *m) */
+void _ZdlPv(void *m)
+{
+    kfree(m);
+}
+
+/* void operator delete[](void *m) */
+void _ZdaPv(void *m)
+{
+    kfree(m);
+}
+
+EXPORT_SYMBOL(_Znwj);
+EXPORT_SYMBOL(_Znaj);
+EXPORT_SYMBOL(ZnwjPv);
+EXPORT_SYMBOL(_ZdlPv);
+EXPORT_SYMBOL(_ZdaPv);
+
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/time.c linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/time.c
--- linux-2.6.8.1/arch/mips/brcm-boards/bcm963xx/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/bcm963xx/time.c	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,277 @@
+/*
+<:copyright-gpl
+ Copyright 2004 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+/*
+ * Setup time for Broadcom 963xx MIPS boards
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/timex.h>
+
+#include <asm/mipsregs.h>
+#include <asm/ptrace.h>
+#include <asm/div64.h>
+#include <asm/time.h>
+
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+unsigned long r4k_interval;	/* Amount to increment compare reg each time */
+static unsigned long r4k_cur;	/* What counter should be at next timer irq */
+
+/* Cycle counter value at the previous timer interrupt.. */
+static unsigned int timerhi = 0, timerlo = 0;
+
+extern volatile unsigned long wall_jiffies;
+
+/* Optional board-specific timer routine */
+void (*board_timer_interrupt)(int irq, void *dev_id, struct pt_regs * regs);
+
+static inline void ack_r4ktimer(unsigned long newval)
+{
+	write_c0_compare(newval);
+}
+
+/*
+ * There are a lot of conceptually broken versions of the MIPS timer interrupt
+ * handler floating around.  This one is rather different, but the algorithm
+ * is provably more robust.
+ */
+static irqreturn_t brcm_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned int count;
+
+	if (r4k_interval == 0)
+		goto null;
+
+	do {
+		do_timer(regs);
+
+		if (board_timer_interrupt)
+			board_timer_interrupt(irq, dev_id, regs);
+
+		r4k_cur += r4k_interval;
+		ack_r4ktimer(r4k_cur);
+
+	} while (((count = (unsigned long)read_c0_count())
+		  - r4k_cur) < 0x7fffffff);
+
+	if (!jiffies) {
+		/*
+		 * If jiffies has overflowed in this timer_interrupt we must
+		 * update the timer[hi]/[lo] to make do_fast_gettimeoffset()
+		 * quotient calc still valid. -arca
+		 */
+		timerhi = timerlo = 0;
+	} else {
+		/*
+		 * The cycle counter is only 32 bit which is good for about
+		 * a minute at current count rates of upto 150MHz or so.
+		 */
+		timerhi += (count < timerlo);	/* Wrap around */
+		timerlo = count;
+	}
+
+	return IRQ_HANDLED;
+
+null:
+	ack_r4ktimer(0);
+	return IRQ_NONE;
+}
+
+static struct irqaction brcm_timer_action = {
+	.handler	= brcm_timer_interrupt,
+	.flags		= SA_INTERRUPT,
+	.mask		= CPU_MASK_NONE,
+	.name		= "timer",
+	.next		= NULL,
+	.dev_id		= brcm_timer_interrupt,
+};
+
+
+void __init brcm_timer_setup(struct irqaction *irq)
+{
+	r4k_cur = (read_c0_count() + r4k_interval);
+	write_c0_compare(r4k_cur);
+
+	/* we are using the cpu counter for timer interrupts */
+        irq->handler = no_action;     /* we use our own handler */
+	setup_irq(MIPS_TIMER_INT, &brcm_timer_action);
+	set_c0_status(IE_IRQ5);
+}
+
+#if 0
+/* This is for machines which generate the exact clock. */
+#define USECS_PER_JIFFY (1000000/HZ)
+#define USECS_PER_JIFFY_FRAC (0x100000000*1000000/HZ&0xffffffff)
+
+static void call_do_div64_32( unsigned long *res, unsigned int high,
+    unsigned int low, unsigned long base )
+{
+    do_div64_32(*res, high, low, base);
+}
+
+/*
+ * FIXME: Does playing with the RP bit in c0_status interfere with this code?
+ */
+static unsigned long do_fast_gettimeoffset(void)
+{
+	u32 count;
+	unsigned long res, tmp;
+
+	/* Last jiffy when do_fast_gettimeoffset() was called. */
+	static unsigned long last_jiffies=0;
+	unsigned long quotient;
+
+	/*
+	 * Cached "1/(clocks per usec)*2^32" value.
+	 * It has to be recalculated once each jiffy.
+	 */
+	static unsigned long cached_quotient=0;
+
+	tmp = jiffies;
+
+	quotient = cached_quotient;
+
+	if (tmp && last_jiffies != tmp) {
+		last_jiffies = tmp;
+#ifdef CONFIG_CPU_MIPS32
+		if (last_jiffies != 0) {
+
+			unsigned long r0;
+			/* gcc 3.0.1 gets an internal compiler error if there are two
+			 * do_div64_32 inline macros.  To work around this problem,
+			 * do_div64_32 is called as a function.
+			 */
+			call_do_div64_32(&r0, timerhi, timerlo, tmp);
+			call_do_div64_32(&quotient, USECS_PER_JIFFY,
+				    USECS_PER_JIFFY_FRAC, r0);
+
+			cached_quotient = quotient;
+
+		}
+#else
+		__asm__(".set\tnoreorder\n\t"
+			".set\tnoat\n\t"
+			".set\tmips3\n\t"
+			"lwu\t%0,%2\n\t"
+			"dsll32\t$1,%1,0\n\t"
+			"or\t$1,$1,%0\n\t"
+			"ddivu\t$0,$1,%3\n\t"
+			"mflo\t$1\n\t"
+			"dsll32\t%0,%4,0\n\t"
+			"nop\n\t"
+			"ddivu\t$0,%0,$1\n\t"
+			"mflo\t%0\n\t"
+			".set\tmips0\n\t"
+			".set\tat\n\t"
+			".set\treorder"
+			:"=&r" (quotient)
+			:"r" (timerhi),
+			 "m" (timerlo),
+			 "r" (tmp),
+			 "r" (USECS_PER_JIFFY)
+			:"$1");
+		cached_quotient = quotient;
+#endif
+	}
+
+	/* Get last timer tick in absolute kernel time */
+	count = read_c0_count();
+
+	/* .. relative to previous jiffy (32 bits is enough) */
+	count -= timerlo;
+
+	__asm__("multu\t%1,%2\n\t"
+		"mfhi\t%0"
+		:"=r" (res)
+		:"r" (count),
+		 "r" (quotient));
+
+	/*
+ 	 * Due to possible jiffies inconsistencies, we need to check 
+	 * the result so that we'll get a timer that is monotonic.
+	 */
+	if (res >= USECS_PER_JIFFY)
+		res = USECS_PER_JIFFY-1;
+
+	return res;
+}
+
+void do_gettimeofday(struct timeval *tv)
+{
+	unsigned int flags;
+
+	read_lock_irqsave (&xtime_lock, flags);
+	tv->tv_sec = xtime.tv_sec;
+	tv->tv_usec = xtime.tv_nsec/1000;
+	tv->tv_usec += do_fast_gettimeoffset();
+
+	/*
+	 * xtime is atomically updated in timer_bh. jiffies - wall_jiffies
+	 * is nonzero if the timer bottom half hasnt executed yet.
+	 */
+	if (jiffies - wall_jiffies)
+		tv->tv_usec += USECS_PER_JIFFY;
+
+	read_unlock_irqrestore (&xtime_lock, flags);
+
+	if (tv->tv_usec >= 1000000) {
+		tv->tv_usec -= 1000000;
+		tv->tv_sec++;
+	}
+}
+
+EXPORT_SYMBOL(do_gettimeofday);
+
+int do_settimeofday(struct timespec *tv)
+{
+	write_lock_irq (&xtime_lock);
+
+	/* This is revolting. We need to set the xtime.tv_usec correctly.
+	 * However, the value in this location is is value at the last tick.
+	 * Discover what correction gettimeofday would have done, and then
+	 * undo it!
+	 */
+	tv->tv_nsec -= do_fast_gettimeoffset()*NSEC_PER_USEC;
+
+	if (tv->tv_nsec < 0) {
+		tv->tv_nsec += 1000000*NSEC_PER_USEC;
+		tv->tv_sec--;
+	}
+
+	xtime.tv_sec = tv->tv_sec;
+	xtime.tv_nsec = tv->tv_nsec;
+	time_adjust = 0;		/* stop active adjtime() */
+	time_status |= STA_UNSYNC;
+	time_maxerror = NTP_PHASE_LIMIT;
+	time_esterror = NTP_PHASE_LIMIT;
+
+	write_unlock_irq (&xtime_lock);
+}
+
+EXPORT_SYMBOL(do_settimeofday);
+
+#endif
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/generic/Makefile linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/generic/Makefile
--- linux-2.6.8.1/arch/mips/brcm-boards/generic/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/generic/Makefile	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,11 @@
+#
+# Makefile for generic Broadcom MIPS boards
+#
+# Copyright (C) 2001 Broadcom Corporation
+#
+obj-y		:= int-handler.o
+
+ifdef CONFIG_REMOTE_DEBUG
+obj-y += dbg_io.o
+endif
+
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/generic/dbg_io.c linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/generic/dbg_io.c
--- linux-2.6.8.1/arch/mips/brcm-boards/generic/dbg_io.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/generic/dbg_io.c	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,260 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#include <linux/config.h>
+#include <linux/tty.h>
+#include <linux/major.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+
+#include <bcm_map_part.h>
+
+#undef	PRNT				/* define for debug printing */
+
+#define         UART16550_BAUD_2400             2400
+#define         UART16550_BAUD_4800             4800
+#define         UART16550_BAUD_9600             9600
+#define         UART16550_BAUD_19200            19200
+#define         UART16550_BAUD_38400            38400
+#define         UART16550_BAUD_57600            57600
+#define         UART16550_BAUD_115200           115200
+
+#define         UART16550_PARITY_NONE           0
+#define         UART16550_PARITY_ODD            0x08
+#define         UART16550_PARITY_EVEN           0x18
+#define         UART16550_PARITY_MARK           0x28
+#define         UART16550_PARITY_SPACE          0x38
+
+#define         UART16550_DATA_5BIT             0x0
+#define         UART16550_DATA_6BIT             0x1
+#define         UART16550_DATA_7BIT             0x2
+#define         UART16550_DATA_8BIT             0x3
+
+#define         UART16550_STOP_1BIT             0x0
+#define         UART16550_STOP_2BIT             0x4
+
+volatile Uart * stUart =  UART_BASE;
+
+#define WRITE16(addr, value)        ((*(volatile UINT16 *)((ULONG)&addr)) = value)
+
+/* Low level UART routines from promcon.c */
+extern void prom_putc(char c);
+extern char prom_getc(void);
+extern int prom_getc_nowait(void);
+extern int prom_testc(void);
+
+extern void set_debug_traps(void);
+extern void breakpoint(void);
+extern void enable_brcm_irq(unsigned int);
+extern void set_async_breakpoint(unsigned int epc);
+
+#ifdef CONFIG_GDB_CONSOLE
+extern void register_gdb_console(void);
+#endif
+
+int gdb_initialized = 0;
+
+#define	GDB_BUF_SIZE	512		/* power of 2, please */
+
+static char	gdb_buf[GDB_BUF_SIZE] ;
+static int	gdb_buf_in_inx ;
+static atomic_t	gdb_buf_in_cnt ;
+static int	gdb_buf_out_inx ;
+
+void debugInit(uint32 baud, uint8 data, uint8 parity, uint8 stop)
+{
+	/* Do nothing, assume boot loader has already set up serial port */
+	printk("debugInit called\n");
+}
+
+/*
+ * Get a char if available, return -1 if nothing available.
+ * Empty the receive buffer first, then look at the interface hardware.
+ */
+static int	read_char(void)
+{
+    if (atomic_read(&gdb_buf_in_cnt) != 0)	/* intr routine has q'd chars */
+    {
+	int		chr ;
+
+	chr = gdb_buf[gdb_buf_out_inx++] ;
+	gdb_buf_out_inx &= (GDB_BUF_SIZE - 1) ;
+	atomic_dec(&gdb_buf_in_cnt) ;
+	return(chr) ;
+    }
+    return(prom_getc_nowait()) ;	/* read from hardware */
+} /* read_char */
+
+/*
+ * This is the receiver interrupt routine for the GDB stub.
+ * It will receive a limited number of characters of input
+ * from the gdb  host machine and save them up in a buffer.
+ *
+ * When the gdb stub routine getDebugChar() is called it
+ * draws characters out of the buffer until it is empty and
+ * then reads directly from the serial port.
+ *
+ * We do not attempt to write chars from the interrupt routine
+ * since the stubs do all of that via putDebugChar() which
+ * writes one byte after waiting for the interface to become
+ * ready.
+ *
+ * The debug stubs like to run with interrupts disabled since,
+ * after all, they run as a consequence of a breakpoint in
+ * the kernel.
+ *
+ * Perhaps someone who knows more about the tty driver than I
+ * care to learn can make this work for any low level serial
+ * driver.
+ */
+static void gdb_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+{
+    int	 chr ;
+    int	more;
+    do
+    {
+	chr = prom_getc_nowait() ;
+	more = prom_testc();
+	if (chr < 0) continue ;
+
+        /* If we receive a Ctrl-C then this is GDB trying to break in */
+        if (chr == 3)
+	{
+	    /* Replace current instruction with breakpoint */
+	    set_async_breakpoint(regs->cp0_epc);
+            //breakpoint();
+	}
+		
+#ifdef PRNT
+	printk("gdb_interrupt: chr=%02x '%c', more = %x\n",
+		chr, chr > ' ' && chr < 0x7F ? chr : ' ', more) ;
+#endif
+
+	if (atomic_read(&gdb_buf_in_cnt) >= GDB_BUF_SIZE)
+	{				/* buffer overflow, clear it */
+	    gdb_buf_in_inx = 0 ;
+	    atomic_set(&gdb_buf_in_cnt, 0) ;
+	    gdb_buf_out_inx = 0 ;
+	    break ;
+	}
+
+	gdb_buf[gdb_buf_in_inx++] = chr ;
+	gdb_buf_in_inx &= (GDB_BUF_SIZE - 1) ;
+	atomic_inc(&gdb_buf_in_cnt) ;
+    }
+    while (more !=0);
+
+} /* gdb_interrupt */
+
+/*
+ * getDebugChar
+ *
+ * This is a GDB stub routine.  It waits for a character from the
+ * serial interface and then returns it.  If there is no serial
+ * interface connection then it returns a bogus value which will
+ * almost certainly cause the system to hang.
+ */
+int	getDebugChar(void)
+{
+    volatile int	chr ;
+
+#ifdef PRNT
+    printk("getDebugChar: ") ;
+#endif
+
+    while ( (chr = read_char()) < 0 ) ;
+
+#ifdef PRNT
+    printk("%c\n", chr > ' ' && chr < 0x7F ? chr : ' ') ;
+#endif
+    return(chr) ;
+
+} /* getDebugChar */
+
+/*
+ * putDebugChar
+ *
+ * This is a GDB stub routine.  It waits until the interface is ready
+ * to transmit a char and then sends it.  If there is no serial
+ * interface connection then it simply returns to its caller, having
+ * pretended to send the char.
+ */
+int putDebugChar(unsigned char chr)
+{
+#ifdef PRNT
+    printk("putDebugChar: chr=%02x '%c'\n", chr,
+		chr > ' ' && chr < 0x7F ? chr : ' ') ;
+#endif
+
+    prom_putc(chr) ;	/* this routine will wait */
+     return 1;
+
+} /* putDebugChar */
+
+/* Just a NULL routine for testing. */
+void gdb_null(void)
+{
+}
+
+void rs_kgdb_hook(int tty_no)
+{
+    printk("rs_kgdb_hook: tty %d\n", tty_no);
+
+    /* Call GDB routine to setup the exception vectors for the debugger */
+   set_debug_traps();
+
+   printk("Breaking into debugger...\n");
+   breakpoint();
+   gdb_null() ;
+   printk("Connected.\n");
+
+   gdb_initialized = 1;
+
+#ifdef CONFIG_GDB_CONSOLE
+    register_gdb_console();
+#endif
+}
+
+void kgdb_hook_irq()
+{
+    int         retval ;
+    uint16 uMask;
+
+    printk("GDB: Hooking UART interrupt\n");
+
+    retval = request_irq(INTERRUPT_ID_UART,
+                         gdb_interrupt,
+                         SA_INTERRUPT,
+                         "GDB-stub", NULL);
+
+    if (retval != 0)
+	printk("gdb_hook: request_irq(irq=%d) failed: %d\n", INTERRUPT_ID_UART, retval);
+
+      // Enable UART config Rx not empty IRQ
+     uMask = READ16(stUart->intMask) ;
+      //     printk("intMask: 0x%x\n", uMask);
+     WRITE16(stUart->intMask, uMask | RXFIFONE);
+}
+
+
diff -urN linux-2.6.8.1/arch/mips/brcm-boards/generic/int-handler.S linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/generic/int-handler.S
--- linux-2.6.8.1/arch/mips/brcm-boards/generic/int-handler.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/brcm-boards/generic/int-handler.S	2006-06-26 09:07:08.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/*
+ * Generic interrupt handler for Broadcom MIPS boards
+ */
+
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+/*
+ *	MIPS IRQ	Source
+ *      --------        ------
+ *             0	Software (ignored)
+ *             1        Software (ignored)
+ *             2        Combined hardware interrupt (hw0)
+ *             3        Hardware
+ *             4        Hardware
+ *             5        Hardware
+ *             6        Hardware
+ *             7        R4k timer
+ */
+
+	.text
+	.set	noreorder
+	.set	noat
+	.align	5
+	NESTED(brcmIRQ, PT_SIZE, sp)
+	SAVE_ALL
+	CLI
+	.set	noreorder
+	.set	at
+
+	jal		brcm_irq_dispatch
+	move	a0, sp
+
+	j	ret_from_irq
+	nop
+		
+	END(brcmIRQ)
--- linux-2.6.8.1/arch/mips/Kconfig	2004-08-14 12:55:32.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/Kconfig	2006-06-26 09:07:08.000000000 +0200
@@ -27,6 +27,17 @@
 
 menu "Machine selection"
 
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+
+config MIPS_BRCM
+	bool "Support for the Broadcom boards"
+	help
+	 This is a family of boards based on the Broadcom MIPS32
+
+source "arch/mips/brcm-boards/bcm963xx/Kconfig"
+	 
+# CONFIG_MIPS_BRCM End Broadcom changed code.
+
 config MACH_JAZZ
 	bool "Support for the Jazz family of machines"
 	select ISA
@@ -146,6 +157,7 @@
 	depends on MIPS32
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select SWAP_IO_SPACE
 
 config MIPS_COBALT
 	bool "Support for Cobalt Server (EXPERIMENTAL)"
@@ -198,6 +210,7 @@
 	select IRQ_CPU
 	select MIPS_GT96100
 	select RM7000_CPU_SCACHE
+	select SWAP_IO_SPACE
 	help
 	  This is an evaluation board based on the Galileo GT-96100 LAN/WAN
 	  communications controllers containing a MIPS R5000 compatible core
@@ -268,6 +281,7 @@
 	bool "Support for MIPS Atlas board"
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select SWAP_IO_SPACE
 	help
 	  This enables support for the QED R5231-based MIPS Atlas evaluation
 	  board.
@@ -277,6 +291,7 @@
 	select HAVE_STD_PC_SERIAL_PORT
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select SWAP_IO_SPACE
 	help
 	  This enables support for the VR5000-based MIPS Malta evaluation
 	  board.
@@ -294,6 +309,7 @@
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
 	select RM7000_CPU_SCACHE
+	select SWAP_IO_SPACE
 	help
 	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
@@ -306,6 +322,7 @@
 	select IRQ_CPU_RM7K
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
+	select SWAP_IO_SPACE
 	help
 	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
@@ -318,6 +335,7 @@
 	select IRQ_MV64340
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
+	select SWAP_IO_SPACE
 	help
 	  The Ocelot is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
@@ -332,6 +350,7 @@
 	select LIMITED_DMA
 	select PCI_MARVELL
 	select RM7000_CPU_SCACHE
+	select SWAP_IO_SPACE
 	help
 	  The Jaguar ATX is a MIPS-based Single Board Computer (SBC) made by
 	  Momentum Computer <http://www.momenco.com/>.
@@ -349,6 +368,7 @@
 	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
+	select SWAP_IO_SPACE
 	help
 	  Yosemite is an evaluation board for the RM9000x2 processor
 	  manufactured by PMC-Sierra
@@ -411,6 +431,7 @@
 	select DMA_NONCOHERENT
 	select IP22_CPU_SCACHE
 	select IRQ_CPU
+	select SWAP_IO_SPACE
 	help
 	  This are the SGI Indy, Challenge S and Indigo2, as well as certain
 	  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
@@ -529,12 +550,14 @@
 	depends on SOC_AU1000
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select SWAP_IO_SPACE
 
 config MIPS_PB1100
 	bool "PB1100 board"
 	depends on SOC_AU1100
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
+	select SWAP_IO_SPACE
 
 config MIPS_PB1500
 	bool "PB1500 board"
@@ -596,6 +619,7 @@
 	bool "Support for Broadcom BCM1xxx SOCs (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
 	select DMA_COHERENT
+	select SWAP_IO_SPACE
 
 choice
 	prompt "BCM1xxx SOC-based board"
@@ -818,6 +842,7 @@
 	select DMA_NONCOHERENT
 	select HW_HAS_PCI
 	select ISA
+	select SWAP_IO_SPACE
 
 config RWSEM_GENERIC_SPINLOCK
 	bool
@@ -934,8 +959,6 @@
 
 config SWAP_IO_SPACE
 	bool
-	depends on TOSHIBA_JMR3927 || TOSHIBA_RBTX4927 || SIBYTE_SB1xxx_SOC || SGI_IP22 || MOMENCO_OCELOT_C || MOMENCO_OCELOT_G || MOMENCO_OCELOT || MOMENCO_JAGUAR_ATX || MIPS_MALTA || MIPS_ATLAS || MIPS_EV96100 || MIPS_PB1100 || MIPS_PB1000
-	default y
 
 #
 # Unfortunately not all GT64120 systems run the chip at the same clock.
--- linux-2.6.8.1/arch/mips/kernel/cpu-probe.c	2004-08-14 12:55:10.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/cpu-probe.c	2006-06-26 09:07:09.000000000 +0200
@@ -538,6 +538,27 @@
 	}
 }
 
+#if defined(CONFIG_MIPS_BRCM)
+static inline void cpu_probe_broadcom(struct cpuinfo_mips *c)
+{
+	decode_config1(c);
+	switch (c->processor_id & 0xff00) {
+	case PRID_IMP_BCM6338:          
+		c->cputype = CPU_BCM6338;
+		break;
+	case PRID_IMP_BCM6345:
+		c->cputype = CPU_BCM6345;
+		break;
+	case PRID_IMP_BCM6348:
+		c->cputype = CPU_BCM6348;
+		break;
+	default:
+		c->cputype = CPU_UNKNOWN;
+		break;
+	}
+}
+#endif
+
 static inline void cpu_probe_sandcraft(struct cpuinfo_mips *c)
 {
 	decode_config1(c);
@@ -576,6 +597,11 @@
 	case PRID_COMP_SIBYTE:
 		cpu_probe_sibyte(c);
 		break;
+#if defined(CONFIG_MIPS_BRCM)
+	case PRID_COMP_BROADCOM:
+		cpu_probe_broadcom(c);
+		break;
+#endif
 
 	case PRID_COMP_SANDCRAFT:
 		cpu_probe_sandcraft(c);
--- linux-2.6.8.1/arch/mips/kernel/gdb-stub.c	2004-08-14 12:56:23.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/gdb-stub.c	2006-06-26 09:07:09.000000000 +0200
@@ -171,6 +171,8 @@
 static unsigned char *mem2hex(char *mem, char *buf, int count, int may_fault);
 void handle_exception(struct gdb_regs *regs);
 
+int kgdb_enabled;
+
 /*
  * spin locks for smp case
  */
--- linux-2.6.8.1/arch/mips/kernel/irq.c	2004-08-14 12:54:50.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/irq.c	2006-06-26 09:07:09.000000000 +0200
@@ -30,12 +30,7 @@
 /*
  * Controller mappings for all interrupt sources:
  */
-irq_desc_t irq_desc[NR_IRQS] __cacheline_aligned = {
-	[0 ... NR_IRQS-1] = {
-		.handler = &no_irq_type,
-		.lock = SPIN_LOCK_UNLOCKED
-	}
-};
+irq_desc_t irq_desc[NR_IRQS] __cacheline_aligned;
 
 static void register_irq_proc (unsigned int irq);
 
@@ -809,7 +804,20 @@
 	return 0;
 }
 
-void __init init_generic_irq(void)
+#ifdef CONFIG_KGDB
+extern void breakpoint(void);
+extern void set_debug_traps(void);
+
+static int kgdb_flag = 1;
+static int __init nokgdb(char *str)
+{
+	kgdb_flag = 0;
+	return 1;
+}
+__setup("nokgdb", nokgdb);
+#endif
+
+void __init init_IRQ(void)
 {
 	int i;
 
@@ -818,7 +826,18 @@
 		irq_desc[i].action  = NULL;
 		irq_desc[i].depth   = 1;
 		irq_desc[i].handler = &no_irq_type;
+		irq_desc[i].lock = SPIN_LOCK_UNLOCKED;
+	}
+
+	arch_init_irq();
+
+#ifdef CONFIG_KGDB
+	if (kgdb_flag) {
+		printk("Wait for gdb client connection ...\n");
+		set_debug_traps();
+		breakpoint();
 	}
+#endif
 }
 
 EXPORT_SYMBOL(disable_irq_nosync);
@@ -833,7 +852,7 @@
 
 static struct proc_dir_entry * smp_affinity_entry [NR_IRQS];
 
-static cpumask_t irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = ~0UL };
+static cpumask_t irq_affinity [NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
 static int irq_affinity_read_proc (char *page, char **start, off_t off,
 			int count, int *eof, void *data)
 {
--- linux-2.6.8.1/arch/mips/kernel/Makefile	2004-08-14 12:55:19.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/Makefile	2006-06-26 09:07:09.000000000 +0200
@@ -8,6 +8,13 @@
 		   ptrace.o reset.o semaphore.o setup.o signal.o syscall.o \
 		   time.o traps.o unaligned.o
 
+# CONFIG_MIPS_BRCM Begin Broadcom added code.
+# gcc 3.4.x reorders code with -Os and -O2, breaking the save_static stuff.
+CFLAGS_syscall.o		:= -O1
+CFLAGS_signal.o			:= -O1
+CFLAGS_signal32.o		:= -O1
+# CONFIG_MIPS_BRCM End Broadcom added code.
+
 ifdef CONFIG_MODULES
 obj-y				+= mips_ksyms.o module.o
 obj-$(CONFIG_MIPS32)		+= module-elf32.o
--- linux-2.6.8.1/arch/mips/kernel/proc.c	2004-08-14 12:55:09.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/proc.c	2006-06-26 09:07:09.000000000 +0200
@@ -75,6 +75,11 @@
 	[CPU_VR4133]	"NEC VR4133",
 	[CPU_VR4181]	"NEC VR4181",
 	[CPU_VR4181A]	"NEC VR4181A",
+#if defined(CONFIG_MIPS_BRCM)
+	[CPU_BCM6338]   "BCM6338",
+	[CPU_BCM6345]   "BCM6345",
+	[CPU_BCM6348]   "BCM6348",
+#endif
 	[CPU_SR71000]	"Sandcraft SR71000"
 };
 
--- linux-2.6.8.1/arch/mips/kernel/scall32-o32.S	2004-08-14 12:54:49.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/scall32-o32.S	2006-06-26 12:42:05.000000000 +0200
@@ -640,9 +640,9 @@
 	syscalltable
 	.size	sys_call_table, . - sys_call_table
 
-	.macro	sys function, nargs
+	/*.macro	sys function, nargs
 	.byte	\nargs
-	.endm
+	.endm*/
 
 sys_narg_table:
 	syscalltable
--- linux-2.6.8.1/arch/mips/kernel/time.c	2004-08-14 12:55:20.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/time.c	2006-06-26 09:07:09.000000000 +0200
@@ -274,11 +274,15 @@
 
 	/* .. relative to previous jiffy (32 bits is enough) */
 	count -= timerlo;
-
+	
 	__asm__("multu	%1,%2"
 		: "=h" (res)
 		: "r" (count), "r" (sll32_usecs_per_cycle)
+#if defined(CONFIG_MIPS_BRCM)		
+		: "lo");
+#else
 		: "lo", "accum");
+#endif		
 
 	/*
 	 * Due to possible jiffies inconsistencies, we need to check
@@ -333,7 +337,11 @@
 	__asm__("multu  %1,%2"
 		: "=h" (res)
 		: "r" (count), "r" (quotient)
+#if defined(CONFIG_MIPS_BRCM)
+		: "lo");
+#else		
 		: "lo", "accum");
+#endif		
 
 	/*
 	 * Due to possible jiffies inconsistencies, we need to check
@@ -375,7 +383,11 @@
 				: "r" (timerhi), "m" (timerlo),
 				  "r" (tmp), "r" (USECS_PER_JIFFY),
 				  "r" (USECS_PER_JIFFY_FRAC)
+#if defined(CONFIG_MIPS_BRCM)
+				: "hi", "lo");
+#else				  
 				: "hi", "lo", "accum");
+#endif				
 			cached_quotient = quotient;
 		}
 	}
@@ -389,7 +401,11 @@
 	__asm__("multu	%1,%2"
 		: "=h" (res)
 		: "r" (count), "r" (quotient)
+#if defined(CONFIG_MIPS_BRCM)
+		: "lo");
+#else		
 		: "lo", "accum");
+#endif		
 
 	/*
 	 * Due to possible jiffies inconsistencies, we need to check
@@ -738,6 +754,7 @@
 	board_timer_setup(&timer_irqaction);
 }
 
+
 #define FEBRUARY		2
 #define STARTOFTIME		1970
 #define SECDAY			86400L
--- linux-2.6.8.1/arch/mips/kernel/traps.c	2004-08-14 12:55:20.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/kernel/traps.c	2006-06-26 09:07:09.000000000 +0200
@@ -246,6 +246,13 @@
 
 static spinlock_t die_lock = SPIN_LOCK_UNLOCKED;
 
+#if defined(CONFIG_MIPS_BRCM)
+#ifdef CONFIG_REMOTE_DEBUG
+#include <asm/gdb-stub.h>
+extern void handle_exception(struct gdb_regs *regs);
+#endif
+#endif
+
 NORET_TYPE void __die(const char * str, struct pt_regs * regs,
 	const char * file, const char * func, unsigned long line)
 {
@@ -258,7 +265,33 @@
 		printk(" in %s:%s, line %ld", file, func, line);
 	printk("[#%d]:\n", ++die_counter);
 	show_registers(regs);
+#if defined(CONFIG_MIPS_BRCM)
+#ifdef CONFIG_REMOTE_DEBUG
+        {
+                struct gdb_regs regs2;
+                int i;
+                long *ptr;
+
+                ptr = &regs2.reg0;
+                /* Copy registers to GDB structure */
+                for(i=0; i<32;i++)
+                        *ptr++ = regs->regs[i];
+
+                regs2.lo = regs->lo;
+                regs2.hi = regs->hi;
+                regs2.cp0_epc = regs->cp0_epc;
+                regs2.cp0_badvaddr = regs->cp0_badvaddr;
+                regs2.cp0_status = regs->cp0_status;
+                regs2.cp0_cause = regs->cp0_cause;
+
+                handle_exception(&regs2); /* Break to GDB */
+        }
+#endif
+#endif
 	spin_unlock_irq(&die_lock);
+	/* Ron add for kernel crash */
+	(*(volatile unsigned int *)(0xfffe040c)) &= ~(1<<5);
+	machine_restart(NULL);
 	do_exit(SIGSEGV);
 }
 
--- linux-2.6.8.1/arch/mips/Makefile	2004-08-14 12:54:47.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/Makefile	2006-06-26 09:07:09.000000000 +0200
@@ -41,8 +41,14 @@
 endif
 
 ifdef CONFIG_CROSSCOMPILE
+# CONFIG_MIPS_BRCM Begin Broadcom added code.
+ifdef CONFIG_MIPS_BRCM
+CROSS_COMPILE		:= mips-linux-uclibc-#$(tool-prefix)
+else
 CROSS_COMPILE		:= $(tool-prefix)
 endif
+# CONFIG_MIPS_BRCM End Broadcom added code.
+endif
 
 #
 # GCC uses -G 0 -mabicalls -fpic as default.  We don't want PIC in the kernel
@@ -57,6 +63,9 @@
 cflags-y			:= -I $(TOPDIR)/include/asm/gcc
 cflags-y			+= -G 0 -mno-abicalls -fno-pic -pipe
 cflags-y			+= $(call check_gcc, -finline-limit=100000,)
+ifeq ($(strip $(JTAG_KERNEL_DEBUG)),y)
+cflags-y			+= -g
+endif
 LDFLAGS_vmlinux			+= -G 0 -static -n
 MODFLAGS			+= -mlong-calls
 
@@ -64,6 +73,12 @@
 
 check_warning = $(shell if $(CC) $(1) -c -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo "$(1)"; else echo "$(2)"; fi)
 
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+ifdef CONFIG_MIPS_BRCM 
+cflags-$(CONFIG_REMOTE_DEBUG)	+= -ggdb
+endif
+# CONFIG_MIPS_BRCM End Broadcom changed code.
+
 #
 # Use: $(call set_gccflags,<cpu0>,<isa0>,<cpu1>,<isa1>,<isa2>)
 #
@@ -302,6 +317,20 @@
 libs-$(CONFIG_BAGET_MIPS)	+= arch/mips/baget/ arch/mips/baget/prom/
 load-$(CONFIG_BAGET_MIPS)	+= 0x80001000
 
+# CONFIG_MIPS_BRCM Begin Broadcom added code.
+ifdef CONFIG_MIPS_BRCM
+#
+# Broadcom board
+core-$(CONFIG_BCM96338)		+= arch/mips/brcm-boards/generic/ arch/mips/brcm-boards/bcm963xx/
+cflags-$(CONFIG_BCM96338)     	+= -Iinclude/asm-mips/mach-bcm963xx
+core-$(CONFIG_BCM96345)		+= arch/mips/brcm-boards/generic/ arch/mips/brcm-boards/bcm963xx/
+cflags-$(CONFIG_BCM96345)     	+= -Iinclude/asm-mips/mach-bcm963xx
+core-$(CONFIG_BCM96348)		+= arch/mips/brcm-boards/generic/ arch/mips/brcm-boards/bcm963xx/
+cflags-$(CONFIG_BCM96348)     	+= -Iinclude/asm-mips/mach-bcm963xx
+load-$(CONFIG_MIPS_BRCM)	+= 0x80010000
+endif
+# CONFIG_MIPS_BRCM End Broadcom added code.
+
 #
 # Cobalt Server
 #
--- linux-2.6.8.1/arch/mips/mm/c-r4k.c	2004-08-14 12:56:22.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/mm/c-r4k.c	2006-06-26 09:07:09.000000000 +0200
@@ -86,7 +86,7 @@
 
 static void (* r4k_blast_dcache)(void);
 
-static void r4k_blast_dcache_setup(void)
+static inline void r4k_blast_dcache_setup(void)
 {
 	unsigned long dc_lsize = cpu_dcache_line_size();
 
@@ -385,6 +385,7 @@
 static void r4k_flush_icache_range(unsigned long start, unsigned long end)
 {
 	unsigned long dc_lsize = current_cpu_data.dcache.linesz;
+	unsigned long ic_lsize = current_cpu_data.icache.linesz;
 	unsigned long addr, aend;
 
 	if (!cpu_has_ic_fills_f_dc) {
@@ -407,14 +408,14 @@
 	if (end - start > icache_size)
 		r4k_blast_icache();
 	else {
-		addr = start & ~(dc_lsize - 1);
-		aend = (end - 1) & ~(dc_lsize - 1);
+		addr = start & ~(ic_lsize - 1);
+		aend = (end - 1) & ~(ic_lsize - 1);
 		while (1) {
 			/* Hit_Invalidate_I */
 			protected_flush_icache_line(addr);
 			if (addr == aend)
 				break;
-			addr += dc_lsize;
+			addr += ic_lsize;
 		}
 	}
 }
@@ -802,6 +803,13 @@
 		if (!(config & MIPS_CONF_M))
 			panic("Don't know how to probe P-caches on this cpu.");
 
+#if defined(CONFIG_MIPS_BRCM)
+        	if (c->cputype == CPU_BCM6338 || c->cputype == CPU_BCM6345 || c->cputype == CPU_BCM6348){
+			printk("brcm mips: enabling icache and dcache...\n");
+        	        /* Enable caches */
+        	        write_c0_diag(read_c0_diag() | 0xC0000000);
+        	}
+#endif
 		/*
 		 * So we seem to be a MIPS32 or MIPS64 CPU
 		 * So let's probe the I-cache ...
--- linux-2.6.8.1/arch/mips/pci/fixup-bcm96348.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/pci/fixup-bcm96348.c	2006-06-26 09:07:09.000000000 +0200
@@ -0,0 +1,85 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <bcmpci.h>
+#include <bcm_intr.h>
+#include <bcm_map_part.h>
+
+static volatile MpiRegisters * mpi = (MpiRegisters *)(MPI_BASE);
+
+static char irq_tab_bcm96348[] __initdata = {
+    [0] = INTERRUPT_ID_MPI,
+    [1] = INTERRUPT_ID_MPI,
+#if defined(CONFIG_USB)
+    [USB_HOST_SLOT] = INTERRUPT_ID_USBH
+#endif
+};
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+    return irq_tab_bcm96348[slot];
+}
+
+static void bcm96348_fixup(struct pci_dev *dev)
+{
+    uint32 memaddr;
+    uint32 size;
+
+    memaddr = pci_resource_start(dev, 0);
+    size = pci_resource_len(dev, 0);
+
+    switch (PCI_SLOT(dev->devfn)) {
+        case 0:
+            // UBUS to PCI address range
+            // Memory Window 1. Mask determines which bits are decoded.
+            mpi->l2pmrange1 = ~(size-1);
+            // UBUS to PCI Memory base address. This is akin to the ChipSelect base
+            // register. 
+            mpi->l2pmbase1 = memaddr & BCM_PCI_ADDR_MASK;
+            // UBUS to PCI Remap Address. Replaces the masked address bits in the
+            // range register with this setting. 
+            // Also, enable direct I/O and direct Memory accesses
+            mpi->l2pmremap1 = (memaddr | MEM_WINDOW_EN);
+            break;
+
+        case 1:
+            // Memory Window 2
+            mpi->l2pmrange2 = ~(size-1);
+            // UBUS to PCI Memory base address. 
+            mpi->l2pmbase2 = memaddr & BCM_PCI_ADDR_MASK;
+            // UBUS to PCI Remap Address
+            mpi->l2pmremap2 = (memaddr | MEM_WINDOW_EN);
+            break;
+
+#if defined(CONFIG_USB)
+        case USB_HOST_SLOT:
+            dev->resource[0].start = USB_HOST_BASE;
+            dev->resource[0].end = USB_HOST_BASE+USB_BAR0_MEM_SIZE-1;
+            break;
+#endif
+    }
+}
+
+struct pci_fixup pcibios_fixups[] = {
+    { PCI_FIXUP_FINAL, PCI_ANY_ID, PCI_ANY_ID, bcm96348_fixup },
+    {0}
+};
--- linux-2.6.8.1/arch/mips/pci/ops-bcm96348.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/pci/ops-bcm96348.c	2006-06-26 09:07:09.000000000 +0200
@@ -0,0 +1,276 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/addrspace.h>
+
+#include <bcm_intr.h>
+#include <bcm_map_part.h>
+#include <bcmpci.h>
+
+#include <linux/delay.h>
+
+#if defined(CONFIG_USB)
+#if 0
+#define DPRINT(x...)        printk(x)
+#else
+#define DPRINT(x...)
+#endif
+
+static int 
+pci63xx_int_read(unsigned int devfn, int where, u32 * value, int size);
+static int 
+pci63xx_int_write(unsigned int devfn, int where, u32 * value, int size);
+
+static bool usb_mem_size_rd = FALSE;
+static uint32 usb_mem_base = 0;
+static uint32 usb_cfg_space_cmd_reg = 0;
+#endif
+static bool pci_mem_size_rd = FALSE;
+
+static volatile MpiRegisters * mpi = (MpiRegisters *)(MPI_BASE);
+
+static void mpi_SetupPciConfigAccess(uint32 addr)
+{
+    mpi->l2pcfgctl = (DIR_CFG_SEL | DIR_CFG_USEREG | addr) & ~CONFIG_TYPE;
+}
+
+static void mpi_ClearPciConfigAccess(void)
+{
+    mpi->l2pcfgctl = 0x00000000;
+}
+
+#if defined(CONFIG_USB)
+/* --------------------------------------------------------------------------
+    Name: pci63xx_int_write
+Abstract: PCI Config write on internal device(s)
+ -------------------------------------------------------------------------- */
+static int 
+pci63xx_int_write(unsigned int devfn, int where, u32 * value, int size)
+{
+    if (PCI_SLOT(devfn) != USB_HOST_SLOT) {
+        return PCIBIOS_SUCCESSFUL;
+    }
+
+    switch (size) {
+        case 1:
+            DPRINT("W => Slot: %d Where: %2X Len: %d Data: %02X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        case 2:
+            DPRINT("W => Slot: %d Where: %2X Len: %d Data: %04X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            switch (where) {
+                case PCI_COMMAND:
+                    usb_cfg_space_cmd_reg = *value;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case 4:
+            DPRINT("W => Slot: %d Where: %2X Len: %d Data: %08lX\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            switch (where) {
+                case PCI_BASE_ADDRESS_0:
+                    if (*value == 0xffffffff) {
+                        usb_mem_size_rd = TRUE;
+                    } else {
+                        usb_mem_base = *value;
+                    }
+                    break;
+                default:
+                    break;
+            }
+            break;
+        default:
+            break;
+    }
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+/* --------------------------------------------------------------------------
+    Name: pci63xx_int_read
+Abstract: PCI Config read on internal device(s)
+ -------------------------------------------------------------------------- */
+static int 
+pci63xx_int_read(unsigned int devfn, int where, u32 * value, int size)
+{
+    uint32 retValue = 0xFFFFFFFF;
+
+    if (PCI_SLOT(devfn) != USB_HOST_SLOT) {
+        return PCIBIOS_SUCCESSFUL;
+    }
+
+    // For now, this is specific to the USB Host controller. We can
+    // make it more general if we have to...
+    // Emulate PCI Config accesses
+    switch (where) {
+        case PCI_VENDOR_ID:     
+        case PCI_DEVICE_ID:
+            retValue = PCI_VENDOR_ID_BROADCOM | 0x63000000;
+            break;
+        case PCI_COMMAND:
+        case PCI_STATUS:
+            retValue = (0x0006 << 16) | usb_cfg_space_cmd_reg;
+            break;
+        case PCI_CLASS_REVISION:
+        case PCI_CLASS_DEVICE:
+            retValue = (PCI_CLASS_SERIAL_USB << 16) | (0x10 << 8) | 0x01;
+            break;
+        case PCI_BASE_ADDRESS_0:
+            if (usb_mem_size_rd) {
+                retValue = USB_BAR0_MEM_SIZE;
+            } else {
+                if (usb_mem_base != 0)
+                    retValue = usb_mem_base;
+                else
+                    retValue = USB_HOST_BASE;
+            }
+            usb_mem_size_rd = FALSE;
+            break;
+        case PCI_CACHE_LINE_SIZE:
+        case PCI_LATENCY_TIMER:
+            retValue = 0;
+            break;
+        case PCI_HEADER_TYPE:
+            retValue = PCI_HEADER_TYPE_NORMAL;
+            break;
+        case PCI_SUBSYSTEM_VENDOR_ID:
+            retValue = PCI_VENDOR_ID_BROADCOM;
+            break;
+        case PCI_SUBSYSTEM_ID:
+            retValue = 0x6300;
+            break;
+        case PCI_INTERRUPT_LINE:
+            retValue = INTERRUPT_ID_USBH; 
+            break;
+        default:
+            break;
+    }
+
+    switch (size) {
+        case 1:
+            *value = (retValue >> ((where & 3) << 3)) & 0xff;
+            DPRINT("R <= Slot: %d Where: %2X Len: %d Data: %02X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        case 2:
+            *value = (retValue >> ((where & 3) << 3)) & 0xffff;
+            DPRINT("R <= Slot: %d Where: %2X Len: %d Data: %04X\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        case 4:
+            *value = retValue;
+            DPRINT("R <= Slot: %d Where: %2X Len: %d Data: %08lX\n", 
+                PCI_SLOT(devfn), where, size, *value);
+            break;
+        default:
+            break;
+    }
+
+    return PCIBIOS_SUCCESSFUL;
+}
+#endif
+
+static int bcm96348_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+	int where, int size, u32 * val)
+{
+    volatile unsigned char *ioBase = (unsigned char *)(mpi->l2piobase | KSEG1);
+    uint32 data;
+
+#if defined(CONFIG_USB)
+    if (PCI_SLOT(devfn) == USB_HOST_SLOT)
+        return pci63xx_int_read(devfn, where, val, size);
+#endif
+
+    mpi_SetupPciConfigAccess(BCM_PCI_CFG(PCI_SLOT(devfn), PCI_FUNC(devfn), where));
+    data = *(uint32 *)ioBase;
+    switch(size) {
+        case 1:
+            *val = (data >> ((where & 3) << 3)) & 0xff;
+            break;
+        case 2:
+            *val = (data >> ((where & 3) << 3)) & 0xffff;
+            break;
+        case 4:
+            *val = data;
+             /* Special case for reading PCI device range */
+            if ((where >= PCI_BASE_ADDRESS_0) && (where <= PCI_BASE_ADDRESS_5)) {
+                if (pci_mem_size_rd) {
+                    /* bcm6348 PCI memory window minimum size is 64K */
+                    *val &= PCI_SIZE_64K;
+                }
+            }
+            break;
+        default:
+            break;
+    }
+    pci_mem_size_rd = FALSE;
+    mpi_ClearPciConfigAccess();
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm96348_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+	int where, int size, u32 val)
+{
+    volatile unsigned char *ioBase = (unsigned char *)(mpi->l2piobase | KSEG1);
+    uint32 data;
+
+#if defined(CONFIG_USB)
+    if (PCI_SLOT(devfn) == USB_HOST_SLOT)
+        return pci63xx_int_write(devfn, where, &val, size);
+#endif
+    mpi_SetupPciConfigAccess(BCM_PCI_CFG(PCI_SLOT(devfn), PCI_FUNC(devfn), where));
+    data = *(uint32 *)ioBase;
+    switch(size) {
+        case 1:
+            data = (data & ~(0xff << ((where & 3) << 3))) |
+                (val << ((where & 3) << 3));
+            break;
+        case 2:
+            data = (data & ~(0xffff << ((where & 3) << 3))) |
+                (val << ((where & 3) << 3));
+            break;
+        case 4:
+            data = val;
+            /* Special case for reading PCI device range */
+            if ((where >= PCI_BASE_ADDRESS_0) && (where <= PCI_BASE_ADDRESS_5)) {
+                if (val == 0xffffffff)
+                    pci_mem_size_rd = TRUE;
+            }
+            break;
+        default:
+            break;
+    }
+    *(uint32 *)ioBase = data;
+    udelay(500);
+    mpi_ClearPciConfigAccess();
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops bcm96348_pci_ops = {
+    .read   = bcm96348_pcibios_read,
+    .write  = bcm96348_pcibios_write
+};
--- linux-2.6.8.1/arch/mips/pci/Makefile	2004-08-14 12:54:47.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/arch/mips/pci/Makefile	2006-06-26 09:07:09.000000000 +0200
@@ -17,6 +17,8 @@
 obj-$(CONFIG_MIPS_NILE4)	+= ops-nile4.o
 obj-$(CONFIG_MIPS_TX3927)	+= ops-jmr3927.o
 obj-$(CONFIG_PCI_VR41XX)	+= ops-vr41xx.o pci-vr41xx.o
+obj-$(CONFIG_PCI_VR41XX)	+= ops-vr41xx.o pci-vr41xx.o
+obj-$(CONFIG_BCM_PCI)		+= fixup-bcm96348.o pci-bcm96348.o ops-bcm96348.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
@@ -51,3 +53,7 @@
 obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o ops-tx4927.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
+
+ifeq "$(CONFIG_BCM_PCI)" "y"
+EXTRA_CFLAGS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+endif
--- linux-2.6.8.1/arch/mips/pci/pci-bcm96348.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/arch/mips/pci/pci-bcm96348.c	2006-06-26 09:07:09.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/pci_channel.h>
+#include <bcmpci.h>
+
+static struct resource bcm_pci_io_resource = {
+    .name   = "bcm96348 pci IO space",
+    .start  = BCM_PCI_IO_BASE,
+    .end    = BCM_PCI_IO_BASE + BCM_PCI_IO_SIZE_64KB - 1,
+    .flags  = IORESOURCE_IO
+};
+
+static struct resource bcm_pci_mem_resource = {
+    .name   = "bcm96348 pci memory space",
+    .start  = BCM_PCI_MEM_BASE,
+    .end    = BCM_PCI_MEM_BASE + BCM_PCI_MEM_SIZE_16MB - 1,
+    .flags  = IORESOURCE_MEM
+};
+
+extern struct pci_ops bcm96348_pci_ops;
+
+struct pci_controller bcm96348_controller = {
+    .pci_ops	= &bcm96348_pci_ops,
+    .io_resource	= &bcm_pci_io_resource,
+    .mem_resource	= &bcm_pci_mem_resource,
+};
+
+static void bcm96348_pci_init(void)
+{
+    register_pci_controller(&bcm96348_controller);
+}
+
+arch_initcall(bcm96348_pci_init);
--- linux-2.6.8.1/drivers/mtd/maps/bcm963xx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/drivers/mtd/maps/bcm963xx.c	2006-06-26 09:07:13.000000000 +0200
@@ -0,0 +1,162 @@
+/*
+ * A simple flash mapping code for BCM963xx board flash memory
+ * It is simple because it only treats all the flash memory as ROM
+ * It is used with chips/map_rom.c
+ *
+ *  Song Wang (songw@broadcom.com)
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/config.h>
+#include <linux/mtd/partitions.h>
+
+#include <board.h>
+#include <bcmTag.h>
+#define  VERSION	"1.0"
+
+
+extern PFILE_TAG kerSysImageTagGet(void);
+
+static struct mtd_info *mymtd;
+static struct mtd_partition brcm_partition_info[4];
+
+#define CFE_ADDR      	0xbfc00000
+#define CFE_SIZE      	64 << 10
+#define FLASH_2M_SIZE 	2048 << 10
+#define FLASH_4M_SIZE 	4096 << 10
+#define NVRAM_SIZE    	64 << 10
+#define TAG_SIZE	0x100
+#define FS_KERNEL_SIZE_4M	0x3E0000
+#define NVRAM_ADDR_4M	0x3F0000
+
+static map_word brcm_physmap_read16(struct map_info *map, unsigned long ofs)
+{
+	map_word val;
+	
+	val.x[0] = __raw_readw(map->map_priv_1 + ofs);
+	
+	return val;
+}
+
+void brcm_physmap_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy_fromio(to, map->map_priv_1 + from, len);
+}
+
+static void brcm_physmap_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	__raw_writew(d, map->map_priv_1 + adr);
+	mb();
+}
+
+void brcm_physmap_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy_toio(map->map_priv_1 + to, from, len);
+}
+
+struct map_info brcm_physmap_map = {
+	.name = "Physically mapped flash",
+	.bankwidth	= 2,
+	.read = brcm_physmap_read16,
+	.copy_from = brcm_physmap_copy_from,
+	.write = brcm_physmap_write16,
+	.copy_to = brcm_physmap_copy_to
+
+};
+
+
+
+int __init init_brcm_physmap(void)
+{
+        PFILE_TAG pTag = NULL;
+        u_int32_t rootfs_addr, kernel_addr,fs_len,cfe_len;
+        FLASH_ADDR_INFO info;
+
+        kerSysFlashAddrInfoGet( &info );
+
+        /* Read the flash memory map from flash memory. */
+        if (!(pTag = kerSysImageTagGet())) {
+                printk("Failed to read image tag from flash\n");
+                return -EIO;
+        }
+
+        rootfs_addr = (u_int32_t) simple_strtoul(pTag->rootfsAddress, NULL, 10);
+        kernel_addr = (u_int32_t) simple_strtoul(pTag->kernelAddress, NULL, 10);
+	
+	
+	brcm_physmap_map.size = FLASH_4M_SIZE;
+	
+	fs_len = kernel_addr - rootfs_addr;
+	cfe_len=CFE_SIZE;
+	/* Ron mapping from fs */
+	brcm_physmap_map.map_priv_1 = (unsigned long)CFE_ADDR;
+
+	if (!brcm_physmap_map.map_priv_1) {
+		printk("Wrong flash starting address\n");
+		return -EIO;
+	}
+	
+	if (brcm_physmap_map.size <= 0) {
+		printk("Wrong flash size\n");
+		return -EIO;
+	}	
+	
+	mymtd = do_map_probe("cfi_probe", &brcm_physmap_map);
+	if (!mymtd)
+		return -EIO;
+	
+	mymtd->owner = THIS_MODULE;
+	/* Ron file system */
+	brcm_partition_info[0].name = "fs";
+	brcm_partition_info[0].offset = (cfe_len + TAG_SIZE);
+	brcm_partition_info[0].size = fs_len;
+	brcm_partition_info[0].mask_flags = 0;
+	
+	/* Ron tag + file system + kernel */
+	brcm_partition_info[1].name = "tag+fs+kernel";
+	brcm_partition_info[1].offset = cfe_len;
+	brcm_partition_info[1].size = FS_KERNEL_SIZE_4M; 
+	brcm_partition_info[1].mask_flags = 0;
+
+	/* Ron bootloader */
+	brcm_partition_info[2].name = "bootloader";
+	brcm_partition_info[2].offset = 0x00;
+	brcm_partition_info[2].size = cfe_len;
+	brcm_partition_info[2].mask_flags = 0;
+
+	/* Ron nvram */
+	brcm_partition_info[3].name = "nvram";
+	brcm_partition_info[3].offset = NVRAM_ADDR_4M;
+	brcm_partition_info[3].size = NVRAM_SIZE;
+	brcm_partition_info[3].mask_flags = 0;
+	
+	add_mtd_partitions(mymtd, brcm_partition_info, 4);
+
+	return 0;
+
+}
+
+static void __exit cleanup_brcm_physmap(void)
+{
+if (mymtd) {
+	del_mtd_partitions(mymtd);
+	del_mtd_device(mymtd);
+	map_destroy(mymtd);
+}
+if (brcm_physmap_map.map_priv_1) {
+	brcm_physmap_map.map_priv_1 = 0;
+}
+}
+
+module_init(init_brcm_physmap);
+module_exit(cleanup_brcm_physmap);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Song Wang songw@broadcom.com");
+MODULE_DESCRIPTION("Configurable MTD map driver for read-only root file system");
--- linux-2.6.8.1/drivers/mtd/maps/Makefile	2004-08-14 12:54:46.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/drivers/mtd/maps/Makefile	2006-06-26 09:07:13.000000000 +0200
@@ -39,13 +39,13 @@
 obj-$(CONFIG_MTD_SCx200_DOCFLASH)+= scx200_docflash.o
 obj-$(CONFIG_MTD_DBOX2)		+= dbox2-flash.o
 obj-$(CONFIG_MTD_OCELOT)	+= ocelot.o
+obj-$(CONFIG_MTD_LASAT)		+= lasat.o
 obj-$(CONFIG_MTD_SOLUTIONENGINE)+= solutionengine.o
 obj-$(CONFIG_MTD_PCI)		+= pci.o
-obj-$(CONFIG_MTD_PB1XXX)	+= pb1xxx-flash.o
-obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
-obj-$(CONFIG_MTD_PB1550)        += pb1550-flash.o
-obj-$(CONFIG_MTD_DB1550)        += db1550-flash.o
 obj-$(CONFIG_MTD_LASAT)		+= lasat.o
+obj-$(CONFIG_MTD_DB1X00)	+= db1x00-flash.o
+obj-$(CONFIG_MTD_PB1550)	+= pb1550-flash.o
+obj-$(CONFIG_MTD_DB1550)	+= db1550-flash.o
 obj-$(CONFIG_MTD_AUTCPU12)	+= autcpu12-nvram.o
 obj-$(CONFIG_MTD_EDB7312)	+= edb7312.o
 obj-$(CONFIG_MTD_IMPA7)		+= impa7.o
@@ -64,3 +64,11 @@
 obj-$(CONFIG_MTD_IXP4XX)	+= ixp4xx.o
 obj-$(CONFIG_MTD_WRSBC8260)	+= wr_sbc82xx_flash.o
 obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
+obj-$(CONFIG_MTD_PB1000)        += pb1xxx-flash.o
+obj-$(CONFIG_MTD_PB1100)        += pb1xxx-flash.o
+obj-$(CONFIG_MTD_PB1500)        += pb1xxx-flash.o
+obj-$(CONFIG_MTD_DB1X00)        += db1x00-flash.o
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+obj-$(CONFIG_MTD_BCM963XX)      += bcm963xx.o
+EXTRA_CFLAGS    		+= -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+# CONFIG_MIPS_BRCM End Broadcom changed code.
--- linux-2.6.8.1/drivers/mtd/maps/Kconfig	2004-08-14 12:56:23.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/drivers/mtd/maps/Kconfig	2006-06-26 09:07:13.000000000 +0200
@@ -60,6 +60,12 @@
 	  Ignore this option if you use run-time physmap configuration
 	  (i.e., run-time calling physmap_configure()).
 
+config MTD_BCM963XX
+	tristate "Broadcom 963xx ADSL board flash memory support"
+	depends on MIPS_BRCM
+	help
+	  Broadcom 963xx ADSL board flash memory
+
 config MTD_SUN_UFLASH
 	tristate "Sun Microsystems userflash support"
 	depends on (SPARC32 || SPARC64) && MTD_CFI
@@ -182,41 +188,12 @@
 	help
 	  Support for the flash chip on Tsunami TIG bus.
 
-config MTD_LASAT
-	tristate "Flash chips on LASAT board"
-	depends on LASAT
-	help
-	  Support for the flash chips on the Lasat 100 and 200 boards.
-
 config MTD_NETtel
 	tristate "CFI flash device on SnapGear/SecureEdge"
 	depends on X86 && MTD_PARTITIONS && MTD_JEDECPROBE
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
-config MTD_PB1XXX
-	tristate "Flash devices on Alchemy PB1xxx boards"
-	depends on MIPS && ( MIPS_PB1000 || MIPS_PB1100 || MIPS_PB1500 )
-	help
-	  Flash memory access on Alchemy Pb1000/Pb1100/Pb1500 boards
-
-config MTD_PB1XXX_BOOT
-	bool "PB1x00 boot flash device"
-	depends on MTD_PB1XXX && ( MIPS_PB1100 || MIPS_PB1500 )
-	help
-	  Use the first of the two 32MiB flash banks on Pb1100/Pb1500 board.
-	  You can say 'Y' to both this and 'MTD_PB1XXX_USER' below, to use
-	  both banks.
-
-config MTD_PB1XXX_USER
-	bool "PB1x00 user flash device"
-	depends on MTD_PB1XXX && ( MIPS_PB1100 || MIPS_PB1500 )
-	default y if MTD_PB1XX_BOOT = n
-	help
-	  Use the second of the two 32MiB flash banks on Pb1100/Pb1500 board.
-	  You can say 'Y' to both this and 'MTD_PB1XXX_BOOT' above, to use
-	  both banks.
-
 config MTD_PB1550
 	tristate "Flash devices on Alchemy PB1550 board"
 	depends on MIPS && MIPS_PB1550
@@ -338,6 +315,80 @@
 	  Mapping for the Flaga digital module. If you dont have one, ignore
 	  this setting.
 
+config MTD_PB1000
+	tristate "Pb1000 Boot Flash device"
+	depends on MIPS && MIPS_PB1000
+	help
+	  Flash memory access on Alchemy Pb1000
+
+config MTD_PB1100
+	tristate "Pb1100 Flash device"
+	depends on MIPS && MIPS_PB1100
+	help
+	  Flash memory access on Alchemy Pb1100
+
+config MTD_PB1500
+	tristate "Pb1500 Flash device"
+	depends on MIPS && MIPS_PB1500
+	help
+	  Flash memory access on Alchemy Pb1500
+
+config MTD_PB1500_BOOT
+	bool "Pb1100/Pb1500 Boot Flash device"
+	depends on MIPS && (MTD_PB1500 || MTD_PB1100)
+	help
+	  Use the first of the two 32MB flash banks on Pb1100/Pb1500 board.
+	  You can say 'Y' to both this and the USER flash option, to use
+	  both banks.
+
+config MTD_PB1500_USER
+	bool "Pb1100/Pb1500 User Flash device (2nd 32MB bank)"
+	depends on MIPS && (MTD_PB1500 || MTD_PB1100)
+	help
+	  Use the second of the two 32MB flash banks on Pb1100/Pb1500 board.
+	  You can say 'Y' to both this and the BOOT flash option, to use
+	  both banks.
+
+config MTD_DB1X00
+	tristate "Db1X00 Flash device"
+	depends on MIPS && (MIPS_DB1000 || MIPS_DB1100 || MIPS_DB1500)
+	help
+	  Flash memory access on Alchemy Db1X00 Boards
+
+config MTD_DB1X00_BOOT
+	bool "Db1X00 Boot Flash device"
+	depends on MIPS && MTD_DB1X00
+	help
+	  Use the first of the two 32MB flash banks on Db1X00 board.
+	  You can say 'Y' to both this and the USER flash option, to use
+	  both banks.
+
+config MTD_DB1X00_USER
+	bool "Db1X00 User Flash device (2nd 32MB bank)"
+	depends on MIPS && MTD_DB1X00
+	help
+	  Use the second of the two 32MB flash banks on Db1X00 boards.
+	  You can say 'Y' to both this and the BOOT flash option, to use
+	  both banks.
+
+config MTD_BOSPORUS
+	tristate "Bosporus Flash device"
+	depends on MIPS && MIPS_BOSPORUS
+	help
+	  Flash memory access on Alchemy Bosporus Board
+
+config MTD_XXS1500
+	tristate "MyCable XXS1500 Flash device"
+	depends on MIPS && MIPS_XXS1500
+	help
+	  Flash memory access on MyCable XXS1500 Board
+
+config MTD_MTX1
+	tristate "4-G Systems MTX-1 Flash device"
+	depends on MIPS && MIPS_MTX1
+	help
+	  Flash memory access on 4-G Systems MTX-1 Board
+
 config MTD_BEECH
 	tristate "CFI Flash device mapped on IBM 405LP Beech"
 	depends on MTD_CFI && PPC32 && 40x && BEECH
@@ -422,6 +473,12 @@
 	  NVRAM on the Momenco Ocelot board. If you have one of these boards
 	  and would like access to either of these, say 'Y'.
 
+config MTD_LASAT
+	tristate "LASAT flash device"
+	depends on LASAT && MTD_CFI
+	help
+	  Support for the flash chips on the Lasat 100 and 200 boards.
+
 config MTD_SOLUTIONENGINE
 	tristate "CFI Flash device mapped on Hitachi SolutionEngine"
 	depends on SUPERH && MTD_CFI && MTD_REDBOOT_PARTS
--- linux-2.6.8.1/drivers/usb/host/Makefile	2004-08-14 12:56:23.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/drivers/usb/host/Makefile	2006-06-26 09:07:14.000000000 +0200
@@ -8,3 +8,7 @@
 obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
 
 obj-$(CONFIG_USB_SL811HS)	+= hc_sl811.o
+
+ifeq ($(CONFIG_MIPS_BRCM),y)
+EXTRA_CFLAGS	+= -DCONFIG_SWAP_IO_SPACE -D__MIPSEB__
+endif
\ No newline at end of file
--- linux-2.6.8.1/include/asm-mips/addrspace.h	2004-08-14 12:54:47.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/addrspace.h	2006-06-26 09:07:15.000000000 +0200
@@ -11,7 +11,13 @@
 #define _ASM_ADDRSPACE_H
 
 #include <linux/config.h>
+#ifdef __KERNEL__
+#if defined(CONFIG_BCM_ENDPOINT_MODULE)
+#include <asm/mach-generic/spaces.h>
+#else
 #include <spaces.h>
+#endif
+#endif
 
 /*
  *  Configure language
--- linux-2.6.8.1/include/asm-mips/bootinfo.h	2004-08-14 12:54:51.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/bootinfo.h	2006-06-26 09:07:15.000000000 +0200
@@ -210,6 +210,16 @@
 #define MACH_GROUP_TITAN       22	/* PMC-Sierra Titan		*/
 #define  MACH_TITAN_YOSEMITE	1	/* PMC-Sierra Yosemite		*/
 
+#if defined(CONFIG_MIPS_BRCM)
+/*
+ * Valid machtype for group BRCM
+ */
+#define MACH_GROUP_BRCM        23	/* Broadcom boards              */
+#define MACH_BCM96338		0
+#define MACH_BCM96345		1
+#define MACH_BCM96348		2
+#endif
+
 #define CL_SIZE			COMMAND_LINE_SIZE
 
 const char *get_system_type(void);
--- linux-2.6.8.1/include/asm-mips/cpu.h	2004-08-14 12:54:50.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/cpu.h	2006-06-26 09:07:15.000000000 +0200
@@ -71,6 +71,11 @@
 #define PRID_IMP_4KEMPR2	0x9100
 #define PRID_IMP_4KSD		0x9200
 #define PRID_IMP_24K		0x9300
+#if defined(CONFIG_MIPS_BRCM)
+#define PRID_IMP_BCM6338	0x9000
+#define PRID_IMP_BCM6345	0x8000
+#define PRID_IMP_BCM6348	0x9100
+#endif
 
 #define PRID_IMP_UNKNOWN	0xff00
 
@@ -177,7 +182,14 @@
 #define CPU_VR4133		56
 #define CPU_AU1550		57
 #define CPU_24K			58
+#if defined(CONFIG_MIPS_BRCM)
+#define CPU_BCM6338		59
+#define CPU_BCM6345		60
+#define CPU_BCM6348		61
+#define CPU_LAST		61
+#else
 #define CPU_LAST		58
+#endif
 
 /*
  * ISA Level encodings
diff -urN linux-2.6.8.1/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h linux-2.6.8.1-brcm63xx/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h
--- linux-2.6.8.1/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/mach-bcm963xx/cpu-feature-overrides.h	2006-06-26 09:07:15.000000000 +0200
@@ -0,0 +1,36 @@
+#ifndef __ASM_MACH_BCM963XX_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_BCM963XX_CPU_FEATURE_OVERRIDES_H
+
+#define cpu_has_tlb			1
+#define cpu_has_4kex			4
+#define cpu_has_4ktlb			8
+#define cpu_has_fpu			0
+#define cpu_has_32fpr			0
+#define cpu_has_counter			0x40
+#define cpu_has_watch			0
+#define cpu_has_mips16			0
+#define cpu_has_divec			0x200
+#define cpu_has_vce			0
+#define cpu_has_cache_cdex_p		0
+#define cpu_has_cache_cdex_s		0
+#define cpu_has_prefetch		0x40000
+#define cpu_has_mcheck			0x2000
+#define cpu_has_ejtag			0x4000
+#define cpu_has_llsc			0x10000
+#define cpu_has_vtag_icache		0
+#define cpu_has_dc_aliases		0
+#define cpu_has_ic_fills_f_dc		0
+
+#define cpu_has_nofpuex			0
+#define cpu_has_64bits			0
+#define cpu_has_64bit_zero_reg		0
+#define cpu_has_64bit_gp_regs		0
+#define cpu_has_64bit_addresses		0
+
+#define cpu_has_subset_pcaches		0
+
+#define cpu_dcache_line_size()		16
+#define cpu_icache_line_size()		16
+#define cpu_scache_line_size()		0
+
+#endif /* __ASM_MACH_BCM963XX_CPU_FEATURE_OVERRIDES_H */
--- linux-2.6.8.1/include/asm-mips/mach-generic/param.h	2004-08-14 12:55:10.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/mach-generic/param.h	2006-06-26 09:07:15.000000000 +0200
@@ -8,6 +8,10 @@
 #ifndef __ASM_MACH_GENERIC_PARAM_H
 #define __ASM_MACH_GENERIC_PARAM_H
 
+#if defined(CONFIG_MIPS_BRCM)
+#define HZ		200		    /* Internal kernel timer frequency */
+#else
 #define HZ		1000		/* Internal kernel timer frequency */
+#endif
 
 #endif /* __ASM_MACH_GENERIC_PARAM_H */
--- linux-2.6.8.1/include/asm-mips/page.h	2004-08-14 12:55:10.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/page.h	2006-06-26 09:07:15.000000000 +0200
@@ -13,7 +13,13 @@
 
 #ifdef __KERNEL__
 
+#if defined(CONFIG_BCM_ENDPOINT_MODULE)
+#include <asm/mach-generic/spaces.h>
+#else
 #include <spaces.h>
+#endif
+
+#endif
 
 /*
  * PAGE_SHIFT determines the page size
@@ -33,6 +39,7 @@
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
 #define PAGE_MASK	(~(PAGE_SIZE-1))
 
+#ifdef __KERNEL__
 #ifndef __ASSEMBLY__
 
 extern void clear_page(void * page);
--- linux-2.6.8.1/include/asm-mips/param.h	2004-08-14 12:54:51.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/param.h	2006-06-26 09:07:15.000000000 +0200
@@ -12,7 +12,11 @@
 #ifdef __KERNEL__
 
 # include <param.h>			/* Internal kernel timer frequency */
+#if defined(CONFIG_BCM_ENDPOINT_MODULE)
+# define USER_HZ	HZ		/* .. some user interfaces are in "ticks" */
+#else
 # define USER_HZ	100		/* .. some user interfaces are in "ticks" */
+#endif
 # define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
 #endif
 
--- linux-2.6.8.1/include/asm-mips/timex.h	2004-08-14 12:56:15.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/include/asm-mips/timex.h	2006-06-26 09:07:15.000000000 +0200
@@ -31,7 +31,11 @@
  * no reason to make this a separate architecture.
  */
 
+#if defined(CONFIG_BCM_ENDPOINT_MODULE)
+#include <asm/mach-generic/timex.h>
+#else
 #include <timex.h>
+#endif
 
 /*
  * Standard way to access the cycle counter.
diff -urN linux-2.6.8.1/bcmdrivers/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/Makefile
--- linux-2.6.8.1/bcmdrivers/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,17 @@
+# File: bcmdrivers/Makefile
+#
+# Makefile for the Linux kernel modules.
+#
+-include $(KERNEL_DIR)/.config
+
+obj-y += opensource/
+
+# If rootfs is nfs, we have to build Ethernet
+# driver as built-n
+ifeq ($(CONFIG_ROOTFS_NFS),y)
+obj-y += broadcom/
+endif
+
+obj-y += broadcom/
+obj-m += broadcom/
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/Makefile
--- linux-2.6.8.1/bcmdrivers/broadcom/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/Makefile	2006-06-26 10:29:23.000000000 +0200
@@ -0,0 +1,3 @@
+
+symlinks:
+	#cp ../../../tools/built-in.o built-in.o
Files linux-2.6.8.1/bcmdrivers/broadcom/built-in.o and linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/built-in.o differ
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_defs.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_defs.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_defs.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,133 @@
+/* TARGET=bcm6348-dmt-T1-dmtbis-adsl2plus-L2-SRA-firmware-Qproc-HW-RTL-pipeline-IncOneBit-Readsl2-doubleUS  */
+
+#define SOURCE_FILE_ 
+#define BCM6348_SRC 
+#define G994_T1P413_1024_FFT 
+#define ENABLE_DIG_USPWR_CUTBACK 
+#define ADSLCORE_ONLY 
+#define TEQ_DF 
+#define LOOP_TIMING_PLL 
+#define RCV_PHASE_TWEAK_ONLY 
+#define ADSL_MAX_POSSIBLE_RCV_RATE 
+#define HARDWARE_CHANNEL 
+#define ADSL_HARDWARE_AGC 
+#define HW_CHANNEL_ADC 
+#define HW_CHANNEL_DAC 
+#define HW_PGA 
+#define DIGITALEC_SINGLE_TAP_UPDATE 
+#define ANALOGEC_SINGLE_TAP_UPDATE 
+#define HWLOG 
+#define G992_TRELLIS_CODE_CLAMPING 
+#define G992DECODERTRELLISBOUNDARY 
+#define MEMORYLIMIT64K 
+#define bcm47xx 
+#define DSL_BIG_ENDIAN 
+#define MIPS_SRC 
+#define VP_INLINE -Winline 
+#define USE_ASM_API 
+#define RTL_SRC 
+#define RSENC_INLINE 
+#define BITENC_INLINE 
+#define USE_SLOW_DATA 
+#define USE_FAST_TEXT 
+#define PROFILE_INLINE 
+#define CHIP_SRC 
+#define G992_RESYNC_PILOT_PHASE_IN_SHOWTIME 
+#define G992_APPLY_SSVI 
+#define SHARE_TEQ_VARS 
+#define ANNEX_M 
+#define DOUBLE_UP_STREAM 
+#define G994P1_SUPPORT_A43C 
+#define USE_ASM_API 
+#define MIPS_ASM 
+#define MEMORYLIMIT64K 
+#define ADSL_FIRMWARE 
+#define G992DATA_XMT_COMPACT_WORD 
+#define ADSL_MAX_POSSIBLE_RCV_RATE 
+#define DSP_FRONTEND_ONLY 
+#define G992P3_ONE_BIT_CONSTELLATION 
+#define ADSL_MODEM 
+#define ATM 
+#define ADSL_ATUR 
+#define ADSL_SOFTWARE_TIME_ERROR_CALCULATION 
+#define DSL_REPORT_ALL_COUNTERS 
+#define ADSL_MONITOR_LCD 
+#define G994P1 
+#define G994P1_ATUR 
+#define G992 
+#define G992_ATUR 
+#define ADSL_FRAMER 
+#define G997_1 
+#define ATM_I432 
+#define TEQ_DF 
+#define G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G994P1_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G992_TRELLISCODE 
+#define ADSL_HARDWARE_ECHO_CANCELLOR 
+#define G992P1 
+#define G992P1_ATUR 
+#define G992P1_ANNEX_A 
+#define ADSL_HARDWARE_TIME_ERROR_TRACKING 
+#define G992P1_NEWFRAME 
+#define G992P1_NEWFRAME_ATUR 
+#define G992P1_ANNEX_A_USED_FOR_G992P2 
+#define T1P413 
+#define G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G992_CALC_DEBUG_SNR_BEFORE_TEQ 
+#define G992P3 
+#define RATE_SELECT_E14 
+#define G992P3_ATUR 
+#define G992P3AMENDMENT 
+#define GLOBESPAN_DM 
+#define G992P3_COMB_MSG_THREE_COPIES 
+#define G992P3_POWER_MANAGEMENT 
+#define G992P3_SRA 
+#define G992P5 
+#define G992P5_ATUR 
+#define ADSL_PIPELINE_CODE 
+#define ADSL_HARDWARE_TIME_ERROR_TRACKING 
+#define G994P1RCV_QPROC 
+#define G994P1XMT_QPROC 
+#define G992RCV_QPROC 
+#define G992XMT_QPROC 
+#define G992RCV_RS 
+#define VP_SIMULATOR 
+#define T1P413RCV_QPROC 
+#define T1P413XMT_QPROC 
+#define G992ENC_HW_DATAMODE 
+#define G992DATA_XMT_HW_RS 
+#define G992DATA_XMT_COMPACT_WORD 
+#define G992RCV_QPROC_FAST 
+#define G992_BIT_SWAP 
+#define ADSL_IDENTIFY_VENDOR_FIRMWARE 
+#define ADSL_ATUR_FORCE_BIGGER_UPSTREAM_MARGIN 
+#define G992_MORE_FRAME_MODE 
+#define XMT_RACT2_FOR_ADI_COMPATIBILITY 
+#define XMT_FFT_SIZE_2X 
+#define SYNCH_SYMBOL_DETECTION 
+#define ANSI_CACT12_PING_PONG 
+#define ADSL_SPECIAL_FIX_FOR_FRENCH_TELECOM 
+#define G994P1_CHECK_SECURITY 
+#define G994P1_NON_STD_INFO 
+#define I432_HEADER_COMPRESSION 
+#define TDC_IOP_FIX_ERICSSON_TI_4000C_350 
+#define TDC_IOP_FIX_SEIMENS_TI 
+#define FT_ADI_US_RATE_FIX 
+#define ANSI_CACT12_PING_PONG 
+#define G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G994P1_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define READSL2 
+#define G992_APPLY_SSVI 
+#define READSL2_FILTERS
+
+
+#define ADSL_PHY_XFACE_OFFSET 0x21F90
+
+
+#define ADSL_PHY_SDRAM_BIAS 0x1A0000
+
+
+#define ADSL_PHY_SDRAM_LINK_OFFSET 0x1A0000
+
+
+#define ADSL_PHY_SDRAM_PAGE_SIZE 0x200000
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_lmem.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_lmem.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_lmem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_lmem.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,6 @@
+/*
+**	Don't change!
+**	This file has been generated automatically by bin2c program
+*/
+
+extern const unsigned char adsl_lmem[51036];
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_sdram.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_sdram.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_sdram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/adslcore6348/adsl_sdram.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,6 @@
+/*
+**	Don't change!
+**	This file has been generated automatically by bin2c program
+*/
+
+extern const unsigned char adsl_sdram[364348];
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslCoreDefs.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslCoreDefs.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslCoreDefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslCoreDefs.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,245 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslCore.c -- Bcm ADSL core driver
+ *
+ * Description:
+ *	This file contains BCM ADSL core driver 
+ *
+ *
+ * Copyright (c) 2000-2001  Broadcom Corporation
+ * All Rights Reserved
+ * No portions of this material may be reproduced in any form without the
+ * written permission of:
+ *          Broadcom Corporation
+ *          16215 Alton Parkway
+ *          Irvine, California 92619
+ * All information contained in this document is Broadcom Corporation
+ * company private, proprietary, and trade secret.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.4 $
+ *
+ * $Id: AdslCoreDefs.h,v 1.4 2004/07/20 23:45:48 ilyas Exp $
+ *
+ * $Log: AdslCoreDefs.h,v $
+ * Revision 1.4  2004/07/20 23:45:48  ilyas
+ * Added driver version info, SoftDslPrintf support. Fixed G.997 related issues
+ *
+ * Revision 1.3  2004/06/10 00:20:33  ilyas
+ * Added L2/L3 and SRA
+ *
+ * Revision 1.2  2004/04/12 23:24:38  ilyas
+ * Added default G992P5 PHY definition
+ *
+ * Revision 1.1  2004/04/08 23:59:15  ilyas
+ * Initial CVS checkin
+ *
+ ****************************************************************************/
+
+#ifndef _ADSL_CORE_DEFS_H
+#define _ADSL_CORE_DEFS_H
+
+#if defined(__KERNEL__)
+#include <linux/config.h>
+#endif
+
+#if defined(CONFIG_BCM96348) || defined(BOARD_bcm96348) || defined(_BCM96348_) ||  defined(CONFIG_BCM96338) || defined(BOARD_bcm96338) || defined(_BCM96338_)
+#ifdef ADSL_ANNEXC
+#include "../adslcore6348C/adsl_defs.h"
+#elif defined(ADSL_ANNEXB)
+#include "../adslcore6348B/adsl_defs.h"
+#elif defined(ADSL_SADSL)
+#include "../adslcore6348SA/adsl_defs.h"
+#else
+#include "../adslcore6348/adsl_defs.h"
+#endif
+#endif
+
+#if defined(__KERNEL__) || defined(TARG_OS_RTEMS) || defined(_CFE_)
+#if defined(CONFIG_BCM96345) || defined(BOARD_bcm96345) || defined(_BCM96345_)
+#ifdef ADSL_ANNEXC
+#include "../adslcore6345C/adsl_defs.h"
+#elif defined(ADSL_ANNEXB)
+#include "../adslcore6345B/adsl_defs.h"
+#elif defined(ADSL_SADSL)
+#include "../adslcore6345SA/adsl_defs.h"
+#else
+#include "../adslcore6345/adsl_defs.h"
+#endif
+#endif /* of CONFIG_BCM96345 */
+#else
+#if defined(CONFIG_BCM96345)
+#ifdef ADSL_ANNEXC
+#include "../adslcoreC/adsl_defs.h"
+#elif defined(ADSL_ANNEXB)
+#include "../adslcoreB/adsl_defs.h"
+#elif defined(ADSL_SADSL)
+#include "../adslcoreSA/adsl_defs.h"
+#else
+#include "../adslcore/adsl_defs.h"
+#endif
+#endif /* of CONFIG_BCM96345 */
+#endif /* __KERNEL__ */
+
+#ifdef _WIN32_WCE
+#define	ASSERT(a)
+#endif
+
+#include "AdslXfaceData.h"
+
+/* adjust some definitions for the HOST */
+
+#undef	GLOBAL_PTR_BIAS
+#undef	ADSLCORE_ONLY
+#undef	USE_SLOW_DATA 
+#undef	USE_FAST_TEXT 
+#undef	VP_SIMULATOR 
+#undef	bcm47xx 
+#undef	ADSL_FRAMER
+#undef	ATM
+#undef	ATM_I432 
+#undef	DSL_OS
+
+#define HOST_ONLY
+#define G997_1_FRAMER
+#define ADSL_MIB
+
+#ifndef FLATTEN_ADDR_ADJUST
+#define FLATTEN_ADDR_ADJUST	0xFFF00000
+#endif
+
+/* definitions for combo PHY (AnnexA(ADSL2) and AnnexB) */
+ 
+#if !(defined(ADSL_SINGLE_PHY) || defined(G992_ANNEXC))
+
+#undef	G992P1_ANNEX_A
+#define	G992P1_ANNEX_A
+#undef	G992P3
+#define	G992P3
+#undef	G992P5
+#define	G992P5
+#define	G992P1_ANNEX_A
+#undef	READSL2
+#define	READSL2
+#undef	G992P1_ANNEX_A_USED_FOR_G992P2
+#define	G992P1_ANNEX_A_USED_FOR_G992P2
+#undef	T1P413
+#define	T1P413
+
+#undef	G992P1_ANNEX_B
+#define	G992P1_ANNEX_B
+
+#endif
+
+/* ADSL PHY definition */
+
+typedef struct {
+	unsigned long	sdramPageAddr;
+	unsigned long	sdramImageAddr;
+	unsigned long	sdramImageSize;
+	unsigned long	sdramPhyImageAddr;
+	unsigned short	fwType;
+	unsigned short	chipType;
+	unsigned short	mjVerNum;
+	unsigned short	mnVerNum;
+	char			*pVerStr;
+	unsigned long	features[4];
+} adslPhyInfo;
+extern adslPhyInfo	adslCorePhyDesc;
+
+/* chip list */ 
+
+#define	kAdslPhyChipMjMask			0xFF00
+#define	kAdslPhyChipMnMask			0x00FF
+#define	kAdslPhyChipUnknown			0
+#define	kAdslPhyChip6345			0x100
+#define	kAdslPhyChip6348			0x200
+#define	kAdslPhyChipRev0			0
+#define	kAdslPhyChipRev1			1
+#define	kAdslPhyChipRev2			2
+#define	kAdslPhyChipRev3			3
+#define	kAdslPhyChipRev4			4
+#define	kAdslPhyChipRev5			5
+
+#define	ADSL_PHY_SUPPORT(f)			AdslFeatureSupported(adslCorePhyDesc.features,f)
+#define	ADSL_PHY_SET_SUPPORT(p,f)	AdslFeatureSet((p)->features,f)
+
+/* ADSL Driver to/from PHY address and data conversion macros */
+
+#ifdef  ADSLDRV_LITTLE_ENDIAN
+#define	ADSL_ENDIAN_CONV_LONG(x)	( ((x) << 24) | (((x) << 8) & 0x00FF0000) | (((x) >> 8) & 0x0000FF00) | ((unsigned long)(x) >> 24) )
+#define	ADSL_ENDIAN_CONV_SHORT(x)	( ((x) << 8) | ((unsigned short)(x) >> 8) )
+#define ADSL_ENDIAN_CONV_2SHORTS(x)	( ((x) << 16) | ((unsigned long)(x) >> 16) )
+#else
+#define	ADSL_ENDIAN_CONV_LONG(x)	x
+#define	ADSL_ENDIAN_CONV_SHORT(x)	x
+#define ADSL_ENDIAN_CONV_2SHORTS(x)	x
+#endif
+
+#ifndef ADSL_PHY_XFACE_OFFSET
+#define ADSL_PHY_XFACE_OFFSET			0x00017F90
+#endif
+#define ADSL_LMEM_XFACE_DATA			(0xFFF00000 | ADSL_PHY_XFACE_OFFSET)
+
+#ifndef ADSL_PHY_SDRAM_START
+#define ADSL_PHY_SDRAM_START			0x10000000
+#endif
+#ifndef ADSL_PHY_SDRAM_BIAS
+#define ADSL_PHY_SDRAM_BIAS				0x00040000
+#endif
+#define	ADSL_PHY_SDRAM_START_4			(ADSL_PHY_SDRAM_START + ADSL_PHY_SDRAM_BIAS)
+
+#ifndef	ADSL_PHY_SDRAM_PAGE_SIZE
+#define ADSL_PHY_SDRAM_PAGE_SIZE		0x00080000
+#endif
+
+#ifdef ADSL_PHY_SDRAM_BIAS
+#define ADSL_SDRAM_IMAGE_SIZE			(ADSL_PHY_SDRAM_PAGE_SIZE - ADSL_PHY_SDRAM_BIAS)
+#else
+#define ADSL_SDRAM_IMAGE_SIZE			(256*1024)
+#endif
+
+
+#ifndef	ADSL_PHY_SDRAM_LINK_OFFSET
+#define ADSL_PHY_SDRAM_LINK_OFFSET		0x00040000
+#endif
+
+#define ADSL_SDRAM_TOTAL_SIZE			0x00800000
+#define ADSL_SDRAM_HOST_MIPS_DEFAULT	(0xA0000000 | (ADSL_SDRAM_TOTAL_SIZE - ADSL_PHY_SDRAM_PAGE_SIZE + ADSL_PHY_SDRAM_BIAS))
+
+#define ADSLXF							((AdslXfaceData *) ADSL_LMEM_XFACE_DATA)
+
+#define ADSL_MIPS_LMEM_ADDR(a)	(((ulong)(a) & 0x19000000) == 0x19000000)
+#define	SDRAM_ADDR_TO_HOST(a)	((void *) ((ulong)(a) - adslCorePhyDesc.sdramPhyImageAddr + \
+	(ADSLXF->sdramBaseAddr ? (unsigned long) ADSLXF->sdramBaseAddr : ADSL_SDRAM_HOST_MIPS_DEFAULT)))
+#define	SDRAM_ADDR_TO_ADSL(a)	((void *) (adslCorePhyDesc.sdramPhyImageAddr + ((ulong)(a) - \
+	(ADSLXF->sdramBaseAddr ? (unsigned long) ADSLXF->sdramBaseAddr : ADSL_SDRAM_HOST_MIPS_DEFAULT))))
+
+#define ADSL_ADDR_TO_HOST(addr)		ADSL_MIPS_LMEM_ADDR(addr) ? (void *) ((ulong) (addr) | FLATTEN_ADDR_ADJUST) : SDRAM_ADDR_TO_HOST(addr)
+
+
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+#ifndef __SoftDslPrintf
+void __SoftDslPrintf(void *gDslVars, char *fmt, int argNum, ...);
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,94 @@
+/****************************************************************************
+ *
+ * AdslMib.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for AdslMib
+ *	global variable structure.
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.8 $
+ *
+ * $Id: AdslMib.gh,v 1.8 2004/06/04 18:56:01 ilyas Exp $
+ *
+ * $Log: AdslMib.gh,v $
+ * Revision 1.8  2004/06/04 18:56:01  ilyas
+ * Added counter for ADSL2 framing and performance
+ *
+ * Revision 1.7  2003/10/17 21:02:12  ilyas
+ * Added more data for ADSL2
+ *
+ * Revision 1.6  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.5  2003/07/18 19:07:15  ilyas
+ * Merged with ADSL driver
+ *
+ * Revision 1.4  2002/11/13 21:32:49  ilyas
+ * Added adjustK support for Centillium non-standard framing mode
+ *
+ * Revision 1.3  2002/10/31 20:27:13  ilyas
+ * Merged with the latest changes for VxWorks/Linux driver
+ *
+ * Revision 1.2  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibGlobals
+#define	AdslMibGlobals
+
+#include "AdslMib.h"
+
+typedef struct
+	{
+	/* MIB data */
+
+	adslMibInfo				adslMib;
+
+	/* ADSL state data */
+
+	adslMibNotifyHandlerType notifyHandlerPtr;
+	ulong					timeSec;
+	ulong					timeMs;
+	Boolean					currSecondErrored;
+	Boolean					currSecondLOS;
+	Boolean					currSecondSES;
+	Boolean					currSecondFEC;
+	ulong					rcvPower;
+	ulong					rcvRateBps;
+	ulong					xmtRateBps;
+	ulong					linkStatus;
+	G992CodingParams		rcvParams;
+	G992CodingParams		xmtParams;
+	ulong					shtCounters[kG992ShowtimeNumOfMonitorCounters];
+	ulong					scratchData;
+	long					showtimeMarginThld;
+
+	/* ADSL diag data */
+
+	short					snr[kAdslMibMaxToneNum];
+	short					showtimeMargin[kAdslMibMaxToneNum];
+	uchar					bitAlloc[kAdslMibMaxToneNum];
+	short					gain[kAdslMibMaxToneNum];
+	ComplexShort			chanCharLin[kAdslMibMaxToneNum];
+	short					chanCharLog[kAdslMibMaxToneNum];
+	short					quietLineNoise[kAdslMibMaxToneNum];
+
+	ushort					nTones;
+	uchar					nMsgCnt;
+	ulong					g992MsgType;
+	uchar					rsOption[1+4];
+	Boolean					rsOptionValid;
+	}
+	adslMibVarsStruct;
+
+#endif	/* AdslMibGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMib.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslMib.h 
+ *
+ * Description:
+ *	This file contains the exported functions and definitions for AdslMib
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.9 $
+ *
+ * $Id: AdslMib.h,v 1.9 2004/04/12 23:34:52 ilyas Exp $
+ *
+ * $Log: AdslMib.h,v $
+ * Revision 1.9  2004/04/12 23:34:52  ilyas
+ * Merged the latest ADSL driver chnages for ADSL2+
+ *
+ * Revision 1.8  2004/03/03 20:14:05  ilyas
+ * Merged changes for ADSL2+ from ADSL driver
+ *
+ * Revision 1.7  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.6  2003/07/18 19:07:15  ilyas
+ * Merged with ADSL driver
+ *
+ * Revision 1.5  2002/10/31 20:27:13  ilyas
+ * Merged with the latest changes for VxWorks/Linux driver
+ *
+ * Revision 1.4  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.3  2002/01/13 22:25:40  ilyas
+ * Added functions to get channels rate
+ *
+ * Revision 1.2  2002/01/03 06:03:36  ilyas
+ * Handle byte moves tha are not multiple of 2
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibHeader
+#define	AdslMibHeader
+
+#if defined(_CFE_)
+#include "lib_types.h"
+#include "lib_string.h"
+#endif
+
+#include "AdslMibDef.h"
+
+/* Interface functions */
+
+typedef	int	(SM_DECL *adslMibNotifyHandlerType)	(void *gDslVars, ulong event);
+
+extern Boolean  AdslMibInit(void *gDslVars);
+extern void		AdslMibTimer(void *gDslVars, long timeMs);
+extern void		AdslMibStatusSnooper (void *gDslVars, dslStatusStruct *status);
+extern void		AdslMibSetNotifyHandler(void *gDslVars, adslMibNotifyHandlerType notifyHandlerPtr);
+extern int		AdslMibGetModulationType(void *gDslVars);
+extern Boolean	AdslMibIsAdsl2Mod(void *gDslVars);
+extern int		AdslMibGetActiveChannel(void *gDslVars);
+extern int		AdslMibGetGetChannelRate(void *gDslVars, int dir, int channel);
+extern Boolean  AdslMibIsLinkActive(void *gDslVars);
+extern int		AdslMibPowerState(void *gDslVars);
+extern int		AdslMibTrainingState (void *gDslVars);
+extern void		AdslMibClearData(void *gDslVars);
+extern void		AdslMibClearBertResults(void *gDslVars);
+extern void		AdslMibBertStartEx(void *gDslVars, ulong bertSec);
+extern void		AdslMibBertStopEx(void *gDslVars);
+extern ulong	AdslMibBertContinueEx(void *gDslVars, ulong totalBits, ulong errBits);
+extern void		AdslMibSetLPR(void *gDslVars);
+extern void		AdslMibSetShowtimeMargin(void *gDslVars, long showtimeMargin);
+extern void		AdslMibResetConectionStatCounters(void *gDslVars);
+
+extern void		AdslMibByteMove (int size, void* srcPtr, void* dstPtr);
+extern void		AdslMibByteClear(int size, void* dstPtr);
+extern int		AdslMibStrCopy(char *srcPtr, char *dstPtr);
+
+/* AdslMibGetData dataId codes */
+
+#define	kAdslMibDataAll					0
+
+extern void		*AdslMibGetData (void *gDslVars, int dataId, void *pAdslMibData);
+
+extern int		AdslMibGetObjectValue (
+					void	*gDslVars, 
+					uchar	*objId, 
+					int		objIdLen,
+					uchar	*dataBuf,
+					ulong	*dataBufLen);
+
+#endif	/* AdslMibHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMibOid.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMibOid.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMibOid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslMibOid.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,177 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslMibOid.h 
+ *
+ * Description:
+ *	SNMP object identifiers for ADSL MIB and other related MIBs
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: AdslMibOid.h,v 1.5 2004/06/04 18:56:01 ilyas Exp $
+ *
+ * $Log: AdslMibOid.h,v $
+ * Revision 1.5  2004/06/04 18:56:01  ilyas
+ * Added counter for ADSL2 framing and performance
+ *
+ * Revision 1.4  2003/10/17 21:02:12  ilyas
+ * Added more data for ADSL2
+ *
+ * Revision 1.3  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.2  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibOidHeader
+#define	AdslMibOidHeader
+
+#define kOidAdsl							94
+#define kOidAdslInterleave					124
+#define kOidAdslFast						125
+#define kOidAtm								37
+
+#define kOidAdslLine						1
+#define kOidAdslMibObjects					1
+
+#define kOidAdslLineTable					1
+#define kOidAdslLineEntry					1
+#define kOidAdslLineCoding					1
+#define kOidAdslLineType					2
+#define kOidAdslLineSpecific			    3
+#define kOidAdslLineConfProfile				4
+#define kOidAdslLineAlarmConfProfile		5
+
+#define kOidAdslAtucPhysTable				2
+#define kOidAdslAturPhysTable				3
+#define kOidAdslPhysEntry					1
+#define kOidAdslPhysInvSerialNumber     	1
+#define kOidAdslPhysInvVendorID             2
+#define kOidAdslPhysInvVersionNumber    	3
+#define kOidAdslPhysCurrSnrMgn          	4
+#define kOidAdslPhysCurrAtn             	5
+#define kOidAdslPhysCurrStatus          	6
+#define kOidAdslPhysCurrOutputPwr       	7
+#define kOidAdslPhysCurrAttainableRate  	8
+
+#define kOidAdslAtucChanTable				4
+#define kOidAdslAturChanTable				5
+#define kOidAdslChanEntry					1
+#define kOidAdslChanInterleaveDelay			1
+#define kOidAdslChanCurrTxRate				2
+#define kOidAdslChanPrevTxRate          	3
+#define kOidAdslChanCrcBlockLength      	4
+
+#define kOidAdslAtucPerfDataTable			6
+#define kOidAdslAturPerfDataTable			7
+#define kOidAdslPerfDataEntry				1
+#define kOidAdslPerfLofs                 	1
+#define kOidAdslPerfLoss                 	2
+#define kOidAdslPerfLprs                 	3
+#define kOidAdslPerfESs                  	4
+#define kOidAdslPerfValidIntervals          5
+#define kOidAdslPerfInvalidIntervals     	6
+#define kOidAdslPerfCurr15MinTimeElapsed 	7
+#define kOidAdslPerfCurr15MinLofs        	8
+#define kOidAdslPerfCurr15MinLoss        	9
+#define kOidAdslPerfCurr15MinLprs        	10
+#define kOidAdslPerfCurr15MinESs         	11
+#define kOidAdslPerfCurr1DayTimeElapsed     12
+#define kOidAdslPerfCurr1DayLofs         	13
+#define kOidAdslPerfCurr1DayLoss         	14
+#define kOidAdslPerfCurr1DayLprs         	15
+#define kOidAdslPerfCurr1DayESs          	16
+#define kOidAdslPerfPrev1DayMoniSecs     	17
+#define kOidAdslPerfPrev1DayLofs         	18
+#define kOidAdslPerfPrev1DayLoss            19
+#define kOidAdslPerfPrev1DayLprs         	20
+#define kOidAdslPerfPrev1DayESs          	21
+
+#define kOidAdslAtucPerfIntervalTable		8
+#define kOidAdslAturPerfIntervalTable		9
+#define kOidAdslPerfIntervalEntry			1
+#define kOidAdslIntervalNumber				1
+#define kOidAdslIntervalLofs				2
+#define kOidAdslIntervalLoss				3
+#define kOidAdslIntervalLprs				4
+#define kOidAdslIntervalESs					5
+#define kOidAdslIntervalValidData			6
+
+#define kOidAdslAtucChanPerfTable					10
+#define kOidAdslAturChanPerfTable					11
+#define kOidAdslChanPerfEntry						1
+#define kOidAdslChanReceivedBlks                 	1
+#define kOidAdslChanTransmittedBlks              	2
+#define kOidAdslChanCorrectedBlks                	3
+#define kOidAdslChanUncorrectBlks                	4
+#define kOidAdslChanPerfValidIntervals           	5
+#define kOidAdslChanPerfInvalidIntervals         	6
+#define kOidAdslChanPerfCurr15MinTimeElapsed     	7
+#define kOidAdslChanPerfCurr15MinReceivedBlks    	8
+#define kOidAdslChanPerfCurr15MinTransmittedBlks 	9
+#define kOidAdslChanPerfCurr15MinCorrectedBlks   	10
+#define kOidAdslChanPerfCurr15MinUncorrectBlks   	11
+#define kOidAdslChanPerfCurr1DayTimeElapsed      	12
+#define kOidAdslChanPerfCurr1DayReceivedBlks     	13
+#define kOidAdslChanPerfCurr1DayTransmittedBlks  	14
+#define kOidAdslChanPerfCurr1DayCorrectedBlks    	15
+#define kOidAdslChanPerfCurr1DayUncorrectBlks    	16
+#define kOidAdslChanPerfPrev1DayMoniSecs         	17
+#define kOidAdslChanPerfPrev1DayReceivedBlks     	18
+#define kOidAdslChanPerfPrev1DayTransmittedBlks  	19
+#define kOidAdslChanPerfPrev1DayCorrectedBlks    	20
+#define kOidAdslChanPerfPrev1DayUncorrectBlks    	21
+
+#define kOidAdslAtucChanIntervalTable				12
+#define kOidAdslAturChanIntervalTable				13
+#define kOidAdslChanIntervalEntry					1
+#define kOidAdslChanIntervalNumber					1
+#define kOidAdslChanIntervalReceivedBlks        	2
+#define kOidAdslChanIntervalTransmittedBlks     	3
+#define kOidAdslChanIntervalCorrectedBlks       	4
+#define kOidAdslChanIntervalUncorrectBlks       	5
+#define kOidAdslChanIntervalValidData           	6
+
+/* AdslExtra OIDs for kOidAdslPrivate, kOidAdslPrivExtraInfo (defined in AdslMibDef.h) */
+
+#define kOidAdslExtraConnectionInfo					1
+#define kOidAdslExtraConnectionStat					2
+#define kOidAdslExtraFramingMode					3
+#define kOidAdslExtraTrainingState					4
+#define kOidAdslExtraNonStdFramingAdjustK			5
+#define kOidAdslExtraAtmStat						6
+#define kOidAdslExtraDiagModeData					7
+#define kOidAdslExtraAdsl2Info						8
+#define kOidAdslExtraTxPerfCounterInfo				9
+
+#define kOidAtmMibObjects		1
+#define kOidAtmTcTable			4
+#define kOidAtmTcEntry			1
+#define kOidAtmOcdEvents		1
+#define kOidAtmAlarmState		2
+
+#endif	/* AdslMibOidHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslXfaceData.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslXfaceData.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslXfaceData.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/AdslXfaceData.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,129 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslXfaceData.h -- ADSL Core interface data structure
+ *
+ * Description:
+ *	To be included both in SoftDsl and BcmAdslCore driver
+ *
+ *
+ * Copyright (c) 2000-2001  Broadcom Corporation
+ * All Rights Reserved
+ * No portions of this material may be reproduced in any form without the
+ * written permission of:
+ *          Broadcom Corporation
+ *          16215 Alton Parkway
+ *          Irvine, California 92619
+ * All information contained in this document is Broadcom Corporation
+ * company private, proprietary, and trade secret.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.9 $
+ *
+ * $Id: AdslXfaceData.h,v 1.9 2004/02/03 02:57:22 ilyas Exp $
+ *
+ * $Log: AdslXfaceData.h,v $
+ * Revision 1.9  2004/02/03 02:57:22  ilyas
+ * Added PHY feature settings
+ *
+ * Revision 1.8  2003/07/18 04:50:21  ilyas
+ * Added shared buffer for clEoc messages to avoid copying thru command buffer
+ *
+ * Revision 1.7  2003/02/25 00:46:32  ilyas
+ * Added T1.413 EOC vendor ID
+ *
+ * Revision 1.6  2003/02/21 23:29:13  ilyas
+ * Added OEM vendor ID parameter for T1.413 mode
+ *
+ * Revision 1.5  2002/09/13 21:17:12  ilyas
+ * Added pointers to version and build string to OEM interface structure
+ *
+ * Revision 1.4  2002/09/07 04:16:29  ilyas
+ * Fixed HOST to ADSL MIPS SDRAM address translation for relocatable images
+ *
+ * Revision 1.3  2002/09/07 01:43:59  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.2  2002/01/22 19:03:10  khp
+ * -put sdramBaseAddr at end of Xface struct
+ *
+ * Revision 1.1  2002/01/15 06:25:08  ilyas
+ * Initial implementation of ADSL core firmware
+ *
+ ****************************************************************************/
+
+#ifndef	AdslXfaceDataHeader
+#define AdslXfaceDataHeader
+
+#include "CircBuf.h"
+
+typedef struct _AdslXfaceData {
+	stretchBufferStruct sbSta;
+	stretchBufferStruct sbCmd;
+	unsigned long		gfcTable[15];
+	void				*sdramBaseAddr;
+} AdslXfaceData;
+
+/* Shared SDRAM configuration data */
+
+#define	kAdslOemVendorIdMaxSize		8
+#define	kAdslOemVersionMaxSize		32
+#define	kAdslOemSerNumMaxSize		32
+#define	kAdslOemNonStdInfoMaxSize	64
+
+typedef struct _AdslOemSharedData {
+	unsigned long		g994VendorIdLen;
+	unsigned long		g994XmtNonStdInfoLen;
+	unsigned long		g994RcvNonStdInfoLen;
+	unsigned long		eocVendorIdLen;
+	unsigned long		eocVersionLen;
+	unsigned long		eocSerNumLen;
+	unsigned char		g994VendorId[kAdslOemVendorIdMaxSize];
+	unsigned char		eocVendorId[kAdslOemVendorIdMaxSize];
+	unsigned char		eocVersion[kAdslOemVersionMaxSize];
+	unsigned char		eocSerNum[kAdslOemSerNumMaxSize];
+	unsigned char		g994XmtNonStdInfo[kAdslOemNonStdInfoMaxSize];
+	unsigned char		g994RcvNonStdInfo[kAdslOemNonStdInfoMaxSize];
+	char				*gDslVerionStringPtr;
+	char				*gDslBuildDataStringPtr;
+	unsigned long		t1413VendorIdLen;
+	unsigned char		t1413VendorId[kAdslOemVendorIdMaxSize];
+	unsigned long		t1413EocVendorIdLen;
+	unsigned char		t1413EocVendorId[kAdslOemVendorIdMaxSize];
+	unsigned long		clEocBufLen;
+	unsigned char		*clEocBufPtr;
+} AdslOemSharedData;
+
+/* feature list */ 
+
+#define	kAdslPhyAnnexA				0
+#define	kAdslPhyAnnexB				1
+#define	kAdslPhyAnnexC				2
+#define	kAdslPhySADSL				3
+#define	kAdslPhyAdsl2				4
+#define	kAdslPhyAdslG992p3			4
+#define	kAdslPhyAdsl2p				5
+#define	kAdslPhyAdslG992p5			5
+#define	kAdslPhyAnnexI				6
+#define	kAdslPhyAdslReAdsl2			7
+#define	kAdslPhyG992p2Init			8
+#define	kAdslPhyT1P413				9
+
+#define	AdslFeatureSupported(fa,f)	((fa)[(f) >> 5] & (1 << ((f) & 0x1F)))
+#define	AdslFeatureSet(fa,f)		(fa)[(f) >> 5] |= (1 << ((f) & 0x1F))
+
+#endif /* AdslXfaceDataHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlankList.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlankList.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlankList.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlankList.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,87 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * BlankList.h 
+ *
+ * Description:
+ *	Definition and implementation (via macros and inline functions)
+ *  of blank list - list of unused items of any size (not less than 
+ *	sizeof(void *)
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ *****************************************************************************/
+
+#ifndef	BlankListHeader
+#define	BlankListHeader
+
+#define BlankListPeek(head)		((void *) (head))
+#define BlankListNext(p)		(*(void **) (p))
+
+#define BlankListAdd(pHead,p)	do {			\
+  BlankListNext(p)	   = BlankListNext(pHead);	\
+  BlankListNext(pHead) = (void *) (p);			\
+} while (0)
+
+#define BlankListAddList(pHead,pFirst,pLast) do {	\
+  if (NULL != (pLast)) {							\
+	BlankListNext(pLast) = BlankListNext(pHead);	\
+	BlankListNext(pHead) = (void *) (pFirst);		\
+  }													\
+} while (0)
+
+#define BlankListGet(pHead)							\
+  BlankListNext(pHead);								\
+  {													\
+	void	**__p;									\
+	__p = (void	**) BlankListNext(pHead);			\
+	if (NULL != __p)								\
+	  BlankListNext(pHead) = *__p;					\
+  }
+
+
+#define	BlankListForEach(pHead,f,ref)	do {		\
+  void	*p = BlankListNext(pHead);					\
+													\
+  while (NULL != p) {								\
+	if ( (f)((p), ref) ) break;						\
+	p = BlankListNext(p);							\
+  }													\
+} while (0)
+
+
+#include	"Que.h"
+
+#define BlankListAddQue(pHead,pqHdr)	do {							\
+  if (NULL != ((QueHeader *)(pqHdr))->tail) {							\
+	BlankListNext(((QueHeader *)(pqHdr))->tail) = BlankListNext(pHead);	\
+	BlankListNext(pHead) = ((QueHeader *)(pqHdr))->head;				\
+  }																		\
+} while (0)
+
+#include	"DList.h"
+
+#define BlankListAddDList(pHead,pDListHead)	do {						\
+  if (!DListEmpty(pDListHead)) {										\
+	BlankListNext(DListLast(pDListHead)) = BlankListNext(pHead);		\
+	BlankListNext(pHead) = DListFirst(pDListHead);						\
+  }																		\
+} while (0)
+
+#endif	/* BlankListHeader */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlockUtil.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlockUtil.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlockUtil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/BlockUtil.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,235 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/* BlockUtil.h
+ *
+ *	Description:
+ *		This file contains the interfaces for the fixed point block
+ *		processing utilities.
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.23 $
+ *
+ * $Id: BlockUtil.h,v 1.23 2004/04/13 00:31:10 ilyas Exp $
+ *
+ * $Log: BlockUtil.h,v $
+ * Revision 1.23  2004/04/13 00:31:10  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.22  2003/07/11 01:49:01  gsyu
+ * Added BlockShortClearByLong to speed up performance
+ *
+ * Revision 1.21  2003/07/10 22:35:23  gsyu
+ * Speed up BlockByteXXX performance
+ *
+ * Revision 1.20  2003/07/10 22:15:51  gsyu
+ * Added BlockByteMoveByWord to speed up performance
+ *
+ * Revision 1.19  2002/03/12 00:03:03  yongbing
+ * Modify cplxScaleCplxSymbols to accept a shift value instead of an array of shifts
+ *
+ * Revision 1.18  2001/03/14 00:50:25  georgep
+ * All targets use FEQ_PASS_FFTSHIFT, remove code for case where its not defined
+ *
+ * Revision 1.17  2000/11/30 03:54:09  khp
+ * -BlockRealScaleCplxSymbols instead of BlockScaleComplexSymbols
+ *
+ * Revision 1.16  2000/11/29 20:42:12  liang
+ * Add function for ADSL xmt gains with fixed shift.
+ *
+ * Revision 1.15  2000/10/02 19:24:08  georgep
+ * Modify FEQ for new fft, fft outputs a shift for each block
+ *
+ * Revision 1.14  2000/09/09 00:23:48  liang
+ * Add corresponding functions for the ComplexLong FEQ coef.
+ *
+ * Revision 1.13  2000/05/17 01:36:52  yongbing
+ * Add Pentium MMX assembly codes for more block related functions
+ *
+ * Revision 1.12  2000/04/19 19:22:22  yongbing
+ * Add BlockShortScaleby2 function used in G994p1
+ *
+ * Revision 1.11  2000/04/04 02:28:01  liang
+ * Merged with SoftDsl_0_2 from old tree.
+ *
+ * Revision 1.11  2000/03/14 23:29:01  yongbing
+ * Add Pentim MMX codes for BlockCplxSymbolUpdateCplxScale function
+ *
+ * Revision 1.10  2000/02/16 01:53:00  yongbing
+ * Add Pentium MMX module for FEQ
+ *
+ * Revision 1.9  1999/11/02 02:49:55  liang
+ * Add BlockComplexPower function.
+ *
+ * Revision 1.8  1999/08/05 19:42:34  liang
+ * Merged with the softmodem top of the tree on 08/04/99 for assembly files.
+ *
+ * Revision 1.7  1999/06/16 00:54:39  liang
+ * BlockRealScaleComplexSymbols takes a scale shift buffer now.
+ *
+ * Revision 1.6  1999/05/22 02:18:29  liang
+ * Add one more parameter to BlockCplxSymbolUpdateCplxScale function.
+ *
+ * Revision 1.5  1999/05/14 22:49:39  liang
+ * Added two more functions.
+ *
+ * Revision 1.4  1999/03/26 03:29:57  liang
+ * Add function BlockComplexMultLongAcc.
+ *
+ * Revision 1.3  1999/02/22 22:40:59  liang
+ * BlockByteSum takes uchar inputs instead of schar.
+ *
+ * Revision 1.2  1999/02/10 01:56:44  liang
+ * Added BlockByteSum, BlockRealScaleComplexSymbols and BlockCplxScaleComplexSymbols.
+ *
+ * Revision 1.1  1998/10/28 01:35:38  liang
+ * *** empty log message ***
+ *
+ * Revision 1.12  1998/07/08 17:09:25  scott
+ * Removed unnecessary undefs
+ *
+ * Revision 1.11  1998/04/02 06:19:44  mwg
+ * Added two new utilities.
+ *
+ * Revision 1.10  1998/03/26 23:20:55  liang
+ * Added function BlockShortMultiply.
+ *
+ * Revision 1.9  1998/02/16  18:41:00  scott
+ * Added MMX autodetect support
+ *
+ * Revision 1.8  1997/12/13 06:11:35  mwg
+ * Added new functions:
+ * BlockLongSubtract()
+ * BlockLongAdd()
+ * BlockLong2ShortSubtract()
+ * BlockShort2LongMove()
+ * BlockShortInterpolate()
+ * BlockLongCorrelate()
+ * BlockMapShort2Short()
+ *
+ * Revision 1.7  1997/03/19 18:35:10  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.6  1997/02/11  00:08:18  mwg
+ * Added BlockByteMove function
+ *
+ * Revision 1.5  1997/02/04  08:40:08  mwg
+ * Changed interface forBlockReal2ComplexMacc()
+ *
+ * Revision 1.4  1997/01/23  02:04:28  mwg
+ * Added return value to BlockShortMove
+ *
+ * Revision 1.3  1996/12/19  22:34:55  mwg
+ * Added new function BlockFullPower().
+ *
+ * Revision 1.2  1996/02/21  03:59:15  mwg
+ * Added new function BlockReal2ComplexMacc
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.5  1995/04/04  06:09:32  mwg
+ * Changed the SoftModem status reporting: now the status is a structure/union
+ * where different fields used for different status code. This will enable
+ * efficient status snooping for high level protocols on top of the softmodem.
+ *
+ */
+
+#ifndef	BlockUtilPh
+#define	BlockUtilPh
+
+extern	void	BlockLongAdd				(int, long*, long*, long*);
+extern	void	BlockLong2ShortSubtract		(int, long*, long*, short*);
+extern	void	BlockShort2LongMove			(int, short*, long*);
+extern	void	BlockShortMultiply			(int, int, short*, short*, short*);
+extern	void	BlockByteMoveUnaligned		(int size, uchar *srcPtr, uchar *dstPtr);
+extern	void	BlockShortOffset			(int, short, short*, short*);
+extern	long	BlockShortInterpolateWithIncrement (int size, long scaleFactor, long increment, int shift, short* src1Ptr, short* src2Ptr, short* dstPtr);
+extern	void	BlockReal2ComplexMult		(int, short*, ComplexShort*, ComplexShort*);
+extern	void	BlockComplexConjigateMult	(int, ComplexShort*, ComplexShort*, ComplexShort*);
+
+extern	long	BlockSum					(int, short*);
+extern	long	BlockByteSum				(int, uchar*);
+extern	void	BlockComplexSum				(int, ComplexShort*, ComplexLong*);
+extern	void	BlockComplexPower			(int, int, ComplexShort*, long*);
+extern	long	BlockFullPower				(int, short*);
+extern	long	BlockLongCorrelate			(int, long*, long*);
+
+extern	int		BlockSymbol2Byte			(int, int, ushort*, uchar*);
+extern	int		BlockByte2Symbol			(int, int, uchar*, ushort*);
+
+extern	void	BlockMapShort2Complex		(int, ushort*, ComplexByte*, ComplexShort*);
+extern	void	BlockMapShort2Short			(int size, ushort *srcPtr, short *mapPtr, short *dstPtr);
+extern	void	BlockMapByte2Byte			(int size, uchar *srcPtr, uchar *mapPtr, uchar *dstPtr);
+extern	void	BlockMapByte2Short			(int size, uchar *srcPtr, short *mapPtr, short *dstPtr);
+extern	void	BlockShortMult				(int size, int shift, short* src1Ptr, short* src2Ptr, short* dstPtr);
+
+extern	int		SM_DECL Idle(void);
+
+extern	void	BlockGenerateAngles(int size, ComplexShort *anglePtr, ComplexShort *incPtr, ComplexShort *dstPtr);
+extern	void	BlockExtractRealPart(int size, ComplexShort *srcPtr, short *dstPtr);
+extern	void	BlockShortScaleByShift (int size, int shift, short* srcPtr, short* dstPtr);
+
+#ifndef PENTIUM_REDEFS /* only if these have not been redefined to function pointers */
+extern	long	BlockPower					(int, short*);
+extern	void	BlockReal2ComplexMacc		(int, int, short*, ComplexShort*, ComplexLong*);
+extern	void	BlockComplexMult			(int, ComplexShort*, ComplexShort*, ComplexShort*);
+extern	void	BlockShortScale				(int, short, int, short*, short*);
+extern	int		SM_DECL BlockShortMove				(int, short*, short*);
+extern	long	BlockCorrelate				(int, short*, short*);
+
+extern	void	BlockRealScaleComplexSymbols(int, int, uchar*, short*, ComplexShort*, ComplexShort*);
+/* FIXME -- the following 3 functions can be removed */
+extern	void	BlockCplxScaleComplexSymbols(int, int, int, ComplexShort*, ComplexShort*, ComplexShort*);
+extern	void	BlockCplxSymbolUpdateCplxScale(int, int, int, uchar*, ComplexShort*,
+					ComplexShort*, ComplexShort*, ComplexShort*);
+extern	void	BlockComplexShortFill		(int, short, short, ComplexShort*);
+
+
+extern	void	BlockRealScaleCplxSymbols(int, int, int, short*, ComplexShort*, ComplexShort*);
+extern	void	BlockCplxLongConjigateMultCplxShort(int, ComplexLong*, ComplexShort*, ComplexLong*);
+
+extern	void	BlockCplxLongScaleCplxSymbols(int, int, int, ComplexLong*, ComplexShort*, short*, ComplexShort*);
+extern	void	BlockCplxSymbolUpdateCplxLongScale(int, int, int, int,
+					ComplexShort*, short *, ComplexLong*, ComplexShort*);
+
+extern	void	BlockComplexLongFill		(int, long, long, ComplexLong*);
+
+extern	void	BlockShortSubtract			(int, short*, short*, short*);
+extern	void	BlockLongSubtract			(int, long*, long*, long*);
+extern	void	BlockShortAdd				(int, short*, short*, short*);
+extern	void	BlockByteMove				(int, uchar*, uchar*);
+extern	void	BlockByteMoveByLong			(int, uchar*, uchar*);
+extern	void	SM_DECL BlockByteFill		(int, uchar, uchar*);
+extern	void	BlockByteFillByLong 		(int, uchar, uchar*);
+extern	void	BlockByteClear				(int, uchar*);
+extern	void	BlockByteClearByLong		(int, uchar*);
+extern	void	BlockShortFill				(int, short, short*);
+extern	void	BlockShortClear				(int, short*);
+extern	void	BlockShortClearByLong		(int, short*);
+extern	void	BlockLongFill				(int, long, long*);
+extern	void	BlockLongClear				(int, long*);
+extern	void	BlockComplexShortClear		(int, ComplexShort*);
+extern	void	BlockShortInvert			(int, short*, short*);
+extern	void	BlockShortScaleDown			(int, short*);
+extern	void	BlockLongMove				(int, long*, long*);
+extern	void	BlockShortInterpolate		(int, short, int, short*, short*, short*);
+extern	void	BlockComplexMultLongAcc     (int, int, ComplexShort*, ComplexShort*, ComplexLong*);
+
+#endif
+
+#endif	/* BlockUtilPh */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/CircBuf.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/CircBuf.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/CircBuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/CircBuf.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,217 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * CircBuf -- Generic Circular Buffer
+ *
+ * Description:
+ *	Implementation of generic circular buffer algorithms
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.14 $
+ *
+ * $Id: CircBuf.h,v 1.14 2004/06/24 03:10:37 ilyas Exp $
+ *
+ * $Log: CircBuf.h,v $
+ * Revision 1.14  2004/06/24 03:10:37  ilyas
+ * Added extra macro to be able to use un-cached variable (for status write)
+ *
+ * Revision 1.13  2004/02/09 23:47:02  ilyas
+ * Fixed last change
+ *
+ * Revision 1.12  2004/02/06 22:52:58  ilyas
+ * Improved stretch buffer write
+ *
+ * Revision 1.11  2002/12/30 23:27:55  ilyas
+ * Added macro for HostDma optimizations
+ *
+ * Revision 1.10  2002/10/26 02:15:02  ilyas
+ * Optimized and added new macros for HostDma
+ *
+ * Revision 1.9  2002/01/22 23:59:29  ilyas
+ * Added paraenthesis around macro argument
+ *
+ * Revision 1.8  2002/01/15 22:28:38  ilyas
+ * Extended macro to support readPtr from uncached address
+ *
+ * Revision 1.7  2001/09/21 19:47:05  ilyas
+ * Fixed compiler warnings for VxWorks build
+ *
+ * Revision 1.6  2001/06/07 18:47:56  ilyas
+ * Added more macros for circular buffer arithmetics
+ *
+ * Revision 1.5  2001/04/18 03:58:34  ilyas
+ * Added LOG file write granularity
+ *
+ * Revision 1.4  2001/01/19 04:34:12  ilyas
+ * Added more macros to circular buffer implementation
+ *
+ * Revision 1.3  2001/01/06 04:01:41  ilyas
+ * Changed the way we write status messages
+ *
+ * Revision 1.2  2001/01/04 05:52:21  ilyas
+ * Added implementation of stretchable circular buffer used in LOG and Status
+ * handlers
+ *
+ * Revision 1.1  2000/05/03 03:45:55  ilyas
+ * Original implementation
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	CircBufHeader_H_
+#define	CircBufHeader_H_
+
+
+typedef struct {
+	char	*pStart;
+	char	*pEnd;
+	char	*pRead;
+	char	*pWrite;
+} circBufferStruct;
+
+/* Initialize circular buffer */
+
+#define	CircBufferInit(pCB,buf,size)	do {			\
+	(pCB)->pStart = (char *) (buf);						\
+	(pCB)->pRead = (pCB)->pWrite = (pCB)->pStart;		\
+	(pCB)->pEnd = (pCB)->pStart + size;					\
+} while (0)
+
+#define	CircBufferGetSize(pCB)			((pCB)->pEnd - (pCB)->pStart)
+#define	CircBufferGetStartPtr(pCB)		((void *) (pCB)->pStart)
+#define	CircBufferGetEndPtr(pCB)		((void *) (pCB)->pEnd)
+
+#define	CircBufferReset(pCB)			(pCB)->pRead = (pCB)->pWrite = (pCB)->pStart
+
+
+#define	CircBufferGetReadPtr(pCB)		((void *) (pCB)->pRead)
+#define	CircBufferGetWritePtr(pCB)		((void *) (pCB)->pWrite)
+
+
+#ifndef bcm47xx
+#define	CircBufferDistance(pCB,p1,p2,d)	((char*)(p2) - (char*)(p1) - d >= 0 ?			\
+											(char*)(p2) - (char*)(p1) - d :			\
+											((char*)(p2)- (char*)(p1) - d + ((pCB)->pEnd - (pCB)->pStart)))
+
+#define	CircBufferAddContig(pCB,p,n)	((char*)(p) + (n) == (pCB)->pEnd ? (pCB)->pStart : (char*)(p) + (n))
+#else
+static __inline int CircBufferDistance(circBufferStruct *pCB, char *p1, char *p2, int d)
+{
+	int tmp = p2 - p1 - d;
+
+	return (tmp >= 0 ? tmp : tmp + (pCB->pEnd - pCB->pStart));
+}
+
+static __inline char * CircBufferAddContig(circBufferStruct *pCB, char *p, int n)
+{
+	p += n;
+	return (p == pCB->pEnd ? pCB->pStart : p);
+}
+#endif
+
+#define	CircBufferAdd(pCB,p,n)			((char*)(p) + (n) >= (pCB)->pEnd ?						\
+											(pCB)->pStart + ((char*)(p) + (n) - (pCB)->pEnd) :	\
+											(char*)(p) + (n))
+
+#define	CircBufferReadUpdate(pCB,n)		(pCB)->pRead = CircBufferAdd(pCB,(pCB)->pRead,n)
+#define	CircBufferWriteUpdate(pCB,n)	(pCB)->pWrite= CircBufferAdd(pCB,(pCB)->pWrite,n)
+
+#define	CircBufferReadUpdateContig(pCB,n)	(pCB)->pRead = CircBufferAddContig(pCB,(pCB)->pRead,n)
+#define	CircBufferWriteUpdateContig(pCB,n)	(pCB)->pWrite= CircBufferAddContig(pCB,(pCB)->pWrite,n)
+
+#define	CircBufferGetReadAvail(pCB)		CircBufferDistance(pCB,(pCB)->pRead,(pCB)->pWrite,0)
+#define	CircBufferIsReadEmpty(pCB)		((pCB)->pRead == (pCB)->pWrite)
+#define	CircBufferGetWriteAvail(pCB)	CircBufferDistance(pCB,(pCB)->pWrite,(pCB)->pRead,1)
+#define	CircBufferGetWriteAvailN(pCB,n)	CircBufferDistance(pCB,(pCB)->pWrite,(pCB)->pRead,n)
+
+#define	CircBufferGetReadContig(pCB)	((unsigned long)(pCB)->pWrite >= (unsigned long) (pCB)->pRead ?	\
+											(pCB)->pWrite - (pCB)->pRead :		\
+											(pCB)->pEnd	  - (pCB)->pRead)
+
+#define	CircBufferGetWriteContig(pCB)	((pCB)->pEnd - (pCB)->pWrite > CircBufferGetWriteAvail(pCB) ?	\
+											CircBufferGetWriteAvail(pCB) :		\
+											(pCB)->pEnd - (pCB)->pWrite)
+
+/*
+**
+**		structure and macros for "strectch" buffer
+**
+*/
+
+typedef struct {
+	char	*pStart;
+	char	*pEnd;
+	char	*pExtraEnd;
+	char	*pStretchEnd;
+	char	*pRead;
+	char	*pWrite;
+} stretchBufferStruct;
+
+#define	StretchBufferInit(pSB,buf,size,extra)	do {	\
+	(pSB)->pStart = (char *) (buf);						\
+	(pSB)->pRead = (pSB)->pWrite = (pSB)->pStart;		\
+	(pSB)->pEnd = (pSB)->pStart + (size);				\
+	(pSB)->pStretchEnd = (pSB)->pEnd;					\
+	(pSB)->pExtraEnd = (pSB)->pEnd+(extra);				\
+} while (0)
+
+#define	StretchBufferGetSize(pSB)		((pSB)->pEnd - (pSB)->pStart)
+#define	StretchBufferGetStartPtr(pSB)	((void *) (pSB)->pStart)
+#define	StretchBufferGetReadPtr(pSB)	((void *) (pSB)->pRead)
+#define	StretchBufferGetWritePtr(pSB)	((void *) (pSB)->pWrite)
+#define	StretchBufferReset(pSB)			((pSB)->pRead = (pSB)->pWrite = (pSB)->pStart)
+
+#define	StretchBufferGetReadToEnd(pSB)	((pSB)->pStretchEnd - (pSB)->pRead)
+
+#define	StretchBufferGetReadAvail(pSB)		((pSB)->pWrite - (pSB)->pRead >= 0 ?	\
+											(pSB)->pWrite - (pSB)->pRead   :		\
+											(pSB)->pStretchEnd - (pSB)->pRead)
+#define	_StretchBufferGetWriteAvail(pSB,rd) ((rd) - (pSB)->pWrite > 0 ?				\
+											(rd) - (pSB)->pWrite - 1 :				\
+											((pSB)->pExtraEnd - (pSB)->pWrite))
+#define	StretchBufferGetWriteAvail(pSB)		_StretchBufferGetWriteAvail(pSB, (pSB)->pRead)
+
+#define	StretchBufferReadUpdate(pSB,n)		do {								\
+	char	*p;																	\
+																				\
+	p = (pSB)->pRead + (n);														\
+	(pSB)->pRead = (p >= (pSB)->pStretchEnd ? (pSB)->pStart : p);				\
+} while (0)
+
+#define	_StretchBufferWriteUpdate(pSB,rd,n)	do {								\
+	char	*p;																	\
+																				\
+	p = (pSB)->pWrite + (n);													\
+	if (p >= (pSB)->pEnd) {														\
+	  if ((rd) != (pSB)->pStart) {												\
+		(pSB)->pStretchEnd = p;													\
+		(pSB)->pWrite = (pSB)->pStart;											\
+	  }																			\
+	}																			\
+	else																		\
+		(pSB)->pWrite = p;														\
+} while (0)
+
+#define	StretchBufferWriteUpdate(pSB,n)		_StretchBufferWriteUpdate(pSB,(pSB)->pRead,n)	
+
+#endif	/* CircBufHeader_H_ */
+
+
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DList.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DList.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DList.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DList.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,131 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * DList.h
+ *
+ * Description:
+ *	Definition and implementation (via macros and inline functions)
+ *  of double-linked list
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ *****************************************************************************/
+
+#ifndef	DListHeader_H_
+#define	DListHeader_H_
+
+typedef struct _DListHeader
+	{
+	struct _DListHeader	*next;		/* next item in the list */
+	struct _DListHeader	*prev;		/* prev item in the list */
+	} DListHeader;
+
+typedef struct _DListUpHeader
+	{
+	struct _DListUpHeader	*next;	/* next item in the list */
+	struct _DListUpHeader	*prev;	/* prev item in the list */
+	struct _DListUpHeader	*head;	/* head of the list */
+	} DListUpHeader;
+
+/* Double linked list DList management macros */
+
+#define	DListInit(pDListHead)	do {					\
+	((DListHeader *)(pDListHead))->next = pDListHead;	\
+	((DListHeader *)(pDListHead))->prev = pDListHead;	\
+} while (0)
+
+#define	DListNext(pDListEntry)		(((DListHeader *)(pDListEntry))->next)
+#define	DListPrev(pDListEntry)		(((DListHeader *)(pDListEntry))->prev)
+
+#define	DListEntryLinked(pDListEntry)	(NULL != DListNext(pDListEntry))
+#define	DListUnlinkEntry(pDListEntry)	(DListNext(pDListEntry) = DListPrev(pDListEntry) = NULL)
+
+#define	DListFirst(pDListHead)		DListNext(pDListHead)
+#define	DListLast(pDListHead)		DListPrev(pDListHead)
+#define	DListValid(pDListHead,pEntry)	((void *)(pDListHead) != (pEntry))
+#define	DListEmpty(pDListHead)		((void *)pDListHead == ((DListHeader *)pDListHead)->next)
+
+#define	DListInsertAfter(pDListEntry,pEntry)	 do {						\
+	((DListHeader *)(pEntry))->next = ((DListHeader *)(pDListEntry))->next;	\
+	((DListHeader *)(pEntry))->prev = (DListHeader *)(pDListEntry);			\
+	((DListHeader *)(pDListEntry))->next->prev = (DListHeader *) (pEntry);	\
+	((DListHeader *)(pDListEntry))->next = (DListHeader *) (pEntry);		\
+} while (0)
+
+#define	DListInsertBefore(pDListEntry,pEntry) do {							\
+	((DListHeader *)(pEntry))->next = (DListHeader *)(pDListEntry);			\
+	((DListHeader *)(pEntry))->prev = ((DListHeader *)(pDListEntry))->prev;	\
+	((DListHeader *)(pDListEntry))->prev->next = (DListHeader *) (pEntry);	\
+	((DListHeader *)(pDListEntry))->prev = (DListHeader *) (pEntry);		\
+} while (0)
+
+#define	DListInsertTail(pDListHead,pEntry)	DListInsertBefore(pDListHead,pEntry)
+#define	DListInsertHead(pDListHead,pEntry)	DListInsertAfter(pDListHead,pEntry)
+
+#define	DListRemove(pDListEntry)	do {				\
+	((DListHeader *)(pDListEntry))->prev->next = ((DListHeader *)(pDListEntry))->next;	\
+	((DListHeader *)(pDListEntry))->next->prev = ((DListHeader *)(pDListEntry))->prev;	\
+} while (0)
+
+
+#define	DListForEach(pDListHead,f,ref)		do {			\
+	DListHeader	*p = ((DListHeader *)(pDListHead))->next;	\
+															\
+	while (DListValid(pDListHead,p)) {						\
+	  DListHeader *p0 = p;									\
+	  p = DListNext(p);										\
+	  if ( (f)((void *)p0, ref) ) break;					\
+	}														\
+} while (0)
+
+
+/* Double linked list with up link DListUp management macros */
+
+#define	DListUpInit(pDListHead)	do {										\
+	((DListUpHeader *)(pDListHead))->next = (DListUpHeader *) (pDListHead);	\
+	((DListUpHeader *)(pDListHead))->prev = (DListUpHeader *) (pDListHead);	\
+	((DListUpHeader *)(pDListHead))->head = (DListUpHeader *) (pDListHead);	\
+} while (0)
+
+#define	DListUpNext(pDListEntry)	((DListUpHeader *) DListNext(pDListEntry))
+#define	DListUpPrev(pDListEntry)	((DListUpHeader *) DListPrev(pDListEntry))
+#define	DListUpHead(pDListEntry)	(((DListUpHeader *)(pDListEntry))->head)
+
+#define	DListUpFirst(pDListHead)	DListUpNext(pDListHead)
+#define	DListUpLast(pDListHead)		DListUpPrev(pDListHead)		
+#define	DListUpValid(pEntry)		(((DListUpHeader *)(pEntry))->head != (void *) pEntry)
+#define	DListUpEmpty(pDListHead)	DListEmpty(pDListHead)		
+
+#define	DListUpInsertAfter(pDListEntry,pEntry)	 do {							\
+	DListInsertAfter(pDListEntry,pEntry);										\
+	((DListUpHeader *)(pEntry))->head = ((DListUpHeader *)(pDListEntry))->head;	\
+} while (0)
+
+#define	DListUpInsertBefore(pDListEntry,pEntry)  do {							\
+	DListInsertBefore(pDListEntry,pEntry);										\
+	((DListUpHeader *)(pEntry))->head = ((DListUpHeader *)(pDListEntry))->head;	\
+} while (0)
+
+#define	DListUpInsertTail(pDListHead,pEntry)	DListUpInsertBefore(pDListHead,pEntry)
+#define	DListUpInsertHead(pDListHead,pEntry)	DListUpInsertAfter(pDListHead,pEntry)
+
+#define	DListUpRemove(pDListEntry)		DListRemove(pDListEntry)
+#define	DListUpForEach(pDListHead,f,ref) DListForEach((DListHeader *)(pDListHead),f,ref)
+
+#endif	/* DListHeader_H_ */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DslFramer.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DslFramer.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DslFramer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/DslFramer.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,159 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * DslFramer.h 
+ *
+ * Description:
+ *	This file contains common DSL framer definitions
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.3 $
+ *
+ * $Id: DslFramer.h,v 1.3 2004/07/21 01:39:41 ilyas Exp $
+ *
+ * $Log: DslFramer.h,v $
+ * Revision 1.3  2004/07/21 01:39:41  ilyas
+ * Reset entire G.997 state on retrain. Timeout in G.997 if no ACK
+ *
+ * Revision 1.2  2004/04/12 23:41:10  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	DslFramerHeader
+#define	DslFramerHeader
+
+#include "DList.h"
+
+#define	kDslFramerInitialized			0x80000000
+
+/* status codes */
+
+#define	kDslFramerRxFrame				1
+#define	kDslFramerRxFrameErr			2
+#define kDslFramerTxFrame				3
+#define	kDslFramerTxFrameErr			4
+
+#define	kDslFramerRxFrameErrFlushed		1
+#define	kDslFramerRxFrameErrAbort		2
+#define	kDslFramerRxFrameErrPhy			3
+
+#define	kDslFramerTxFrameErrFlushed		1
+
+
+typedef	struct _dslFramerBufDesc {
+	long		pkId;
+	long		bufFlags;
+	void		*bufPtr;
+	long		bufLen;
+} dslFramerBufDesc;
+
+/* data bufDesc flags */
+
+#define kDslFramerStartNewFrame			1
+#define kDslFramerEndOfFrame			2
+#define kDslFramerAbortFrame			4
+
+#define kDslFramerExtraByteShift		3
+#define kDslFramerExtraByteMask			(0x7 << kDslFramerExtraByteShift)
+
+typedef struct _dslFramerControl {
+	bitMap					setup;
+	dslFrameHandlerType		rxIndicateHandlerPtr;
+	dslFrameHandlerType		txCompleteHandlerPtr;
+	dslStatusHandlerType	statusHandlerPtr;
+	ulong					statusCode;
+	ulong					statusOffset;
+
+	int						nRxBuffers;
+	int						nRxBufSize;
+	int						nRxPackets;
+
+	dslFrame				*freeBufListPtr;
+	void					*freeBufPool;
+	void					*pBufMemory;
+
+	dslFrame				*freePacketListPtr;
+	void					*freePacketPool;
+
+	/* RX working data set */
+
+	dslFrame				*pRxFrame;
+	dslFrameBuffer			*pRxBuf;
+	uchar					*pRxBufData;
+	uchar					*pRxBufDataEnd;
+	int						rxFrameLen;
+
+	/* TX working data set */
+
+	DListHeader				dlistTxWaiting;
+	dslFrame				*pTxFrame;
+	dslFrameBuffer			*pTxBuf;
+	uchar					*pTxBufData;
+	uchar					*pTxBufDataEnd;
+
+	/* stats data */
+
+	ulong					dslByteCntRxTotal;
+	ulong					dslByteCntTxTotal;
+
+	ulong					dslFrameCntRxTotal;
+	ulong					dslFrameCntRxErr;
+	ulong					dslFrameCntTxTotal;
+	
+} dslFramerControl;
+
+
+extern Boolean  DslFramerInit(
+			void					*gDslVars,
+			dslFramerControl		*dfCtrl,
+			bitMap					setup,
+			ulong					statusCode,
+			ulong					statusOffset,
+			dslFrameHandlerType		rxIndicateHandlerPtr,
+			dslFrameHandlerType		txCompleteHandlerPtr,
+			dslStatusHandlerType	statusHandlerPtr,
+			ulong					rxBufNum,
+			ulong					rxBufSize,
+			ulong					rxPacketNum);
+extern void DslFramerClose(void *gDslVars, dslFramerControl *dfCtrl);
+extern void DslFramerSendFrame(void *gDslVars, dslFramerControl *dfCtrl, dslFrame *pFrame);
+extern void DslFramerReturnFrame(void *gDslVars, dslFramerControl *dfCtrl, dslFrame *pFrame);
+
+
+extern Boolean DslFramerRxGetPtr(void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern void	DslFramerRxDone  (void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern Boolean	DslFramerTxGetPtr(void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern void	DslFramerTxDone(void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern Boolean DslFramerTxIdle (void *gDslVars, dslFramerControl *dfCtrl);
+extern void DslFramerTxFlush(void *gDslVars, dslFramerControl *dfCtrl);
+
+extern void * DslFramerGetFramePoolHandler(dslFramerControl *dfCtrl);
+extern void DslFramerClearStat(dslFramerControl *dfCtrl);
+
+extern void DslFramerRxFlushFrame (void *gDslVars, dslFramerControl *dfCtrl, int errCode);
+extern void DslFramerRxFlush(void *gDslVars, dslFramerControl *dfCtrl);
+
+#endif	/* DslFramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Flatten.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Flatten.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Flatten.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Flatten.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,115 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * Flatten.h -- Header for Flatten/Unflatten command/status
+ *
+ * Copyright (c) 1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.14 $
+ *
+ * $Id: Flatten.h,v 1.14 2004/03/04 19:48:52 linyin Exp $
+ *
+ * $Log: Flatten.h,v $
+ * Revision 1.14  2004/03/04 19:48:52  linyin
+ * Support adsl2plus
+ *
+ * Revision 1.13  2003/10/17 22:45:14  yongbing
+ * Increase buffer size for large B&G table of G992P3
+ *
+ * Revision 1.12  2003/08/12 23:16:26  khp
+ * - for Haixiang: added support for ADSL_MARGIN_TWEAK_TEST
+ *
+ * Revision 1.11  2003/02/27 06:33:03  ilyas
+ * Improved free space checking in command buffer (became a problem with
+ * 2 commands SetXmtgain and StartPhy)
+ *
+ * Revision 1.10  2003/01/11 01:27:07  ilyas
+ * Improved checking for available space in status buffer
+ *
+ * Revision 1.9  2002/09/07 01:43:59  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.8  2002/05/16 00:01:52  khp
+ * -added missing #endif
+ *
+ * Revision 1.7  2002/05/15 00:04:48  mprahlad
+ * increase the status buffer size - prevent memory overflow for annexC cases
+ *
+ * Revision 1.6  2002/04/05 04:10:33  linyin
+ * -hack to fit in Annex C firmware in LMEM
+ *
+ * Revision 1.5  2002/04/05 02:45:25  linyin
+ * Make the buffer side larger for annexC
+ *
+ * Revision 1.4  2002/01/30 07:19:06  ilyas
+ * Moved showtime code to LMEM
+ *
+ * Revision 1.3  2001/08/29 02:56:01  ilyas
+ * Added tests for flattening/unflatenning command and statuses (dual mode)
+ *
+ * Revision 1.2  2001/04/25 00:30:54  ilyas
+ * Adjusted MaxFrameLen
+ *
+ * Revision 1.1  2001/04/24 21:41:21  ilyas
+ * Implemented status flattening/unflattaning to transfer statuses between
+ * modules asynchronously through the circular buffer
+ *
+ *
+ *****************************************************************************/
+
+#ifndef _Flatten_H_
+#define _Flatten_H_
+
+#include	"CircBuf.h"
+
+#ifdef ADSL_MARGIN_TWEAK_TEST
+#define kMaxFlattenedCommandSize	272		/* maximum no. of bytes in flattened cmd */
+#else
+#define kMaxFlattenedCommandSize	128		/* maximum no. of bytes in flattened cmd */
+#endif
+#if	defined(G992_ANNEXC) || defined(G992P3)
+#if defined(G992P5)
+#define kMaxFlattenedStatusSize		2200   	/* maximum no. of bytes in flattened status */
+#else
+#define kMaxFlattenedStatusSize		1100   	/* maximum no. of bytes in flattened status */
+#endif
+#else
+#define kMaxFlattenedStatusSize		 550   	/* maximum no. of bytes in flattened status */
+#endif
+
+#define	kMaxFlattenFramelength		(kMaxFlattenedStatusSize - (4*sizeof(long)) - 20)
+
+extern int	SM_DECL FlattenCommand	(dslCommandStruct *cmd, ulong *dstPtr, ulong nAvail);
+extern int	SM_DECL UnflattenCommand(ulong *srcPtr, dslCommandStruct *cmd);
+extern int	SM_DECL FlattenStatus	(dslStatusStruct *status, ulong *dstPtr, ulong nAvail);
+extern int	SM_DECL UnflattenStatus	(ulong *srcPtr, dslStatusStruct *status);
+
+#define	FlattenBufferInit(fb,fbData,bufSize,itemSize)		\
+	StretchBufferInit(fb, fbData, bufSize, itemSize)
+	
+extern int	SM_DECL FlattenBufferStatusWrite(stretchBufferStruct *fBuf, dslStatusStruct *status);
+extern int	SM_DECL FlattenBufferStatusRead(stretchBufferStruct *fBuf, dslStatusStruct *status);
+
+extern int	SM_DECL FlattenBufferCommandWrite(stretchBufferStruct *fBuf, dslCommandStruct *cmd);
+extern int	SM_DECL FlattenBufferCommandRead(stretchBufferStruct *fBuf, dslCommandStruct *cmd);
+
+#define FlattenBufferReadComplete(fb,nBytes)				\
+	StretchBufferReadUpdate (fb, nBytes)
+
+#endif /* _Flatten_H_ */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * G992p3OvhMsg.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for the G992p3 overhead 
+ *  channel messages global variable structure.
+ *
+ *
+ * Copyright (c) 1999-2003 BroadCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: G992p3OvhMsg.gh,v 1.5 2004/09/11 03:52:25 ilyas Exp $
+ *
+ * $Log: G992p3OvhMsg.gh,v $
+ * Revision 1.5  2004/09/11 03:52:25  ilyas
+ * Added support for overhead message segmentation
+ *
+ * Revision 1.4  2004/07/07 01:27:20  ilyas
+ * Fixed OHC message stuck problem on L2 entry/exit
+ *
+ * Revision 1.3  2004/06/10 00:13:31  ilyas
+ * Added L2/L3 and SRA
+ *
+ * Revision 1.2  2004/04/12 23:34:52  ilyas
+ * Merged the latest ADSL driver chnages for ADSL2+
+ *
+ * Revision 1.1  2003/07/18 19:39:18  ilyas
+ * Initial G.992.3 overhead channel message implementation (from ADSL driver)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G992p3OvhMsgFramerGlobals
+#define	G992p3OvhMsgFramerGlobals
+
+#define	kG992p3OvhMsgMaxCmdSize			(16 + 16)
+#define	kG992p3OvhMsgMaxRspSize			(16 + 2*512)
+
+typedef struct
+	{
+	dslFrame				*segFrame;
+	dslFrameBuffer			*segFrBufCur;
+	dslFrameBuffer			segFrBuf;
+	ulong					timeSegOut;
+	uchar					tryCnt;
+	uchar					segTotal;
+	uchar					segId;
+	}
+	g992p3SegFrameCtlStruct;
+
+typedef struct
+	{
+	bitMap					setup;
+	dslFrameHandlerType		rxReturnFramePtr;
+	dslFrameHandlerType		txSendFramePtr;
+	dslCommandHandlerType	cmdHandlerPtr;
+	dslStatusHandlerType	statusHandlerPtr;
+
+	dslFrame				txRspFrame;
+	dslFrameBuffer			txRspFrBuf;
+	dslFrameBuffer			txRspFrBuf1;
+	uchar					txRspBuf[kG992p3OvhMsgMaxRspSize];
+	dslFrame				txPwrRspFrame;
+	dslFrameBuffer			txPwrRspFrBuf0;
+	dslFrameBuffer			txPwrRspFrBuf0a;
+	dslFrameBuffer			txPwrRspFrBuf1;
+	uchar					txPwrRspBuf0[8];
+	dslFrame				txCmdFrame;
+	dslFrameBuffer			txCmdFrBuf0;
+	dslFrameBuffer			txCmdFrBuf0a;
+	dslFrameBuffer			txCmdFrBuf1;
+	uchar					txCmdBuf[kG992p3OvhMsgMaxCmdSize];
+	g992p3SegFrameCtlStruct	txSegFrameCtl;
+	ulong					txFlags;
+	uchar					txL0Rq;
+	uchar					txL3Rq;
+
+	ulong					timeMs;
+	ulong					timeCmdOut;
+	ulong					cmdTryCnt;
+	ulong					cmdNum;
+	ulong					timeRspOut;
+	uchar					*txPmdCmd;
+
+	uchar					rxCmdMsgNum;
+	uchar					rxRspMsgNum;
+	uchar					txCmdMsgNum;
+	uchar					txRspMsgNum;
+	}
+	g992p3OvhMsgVarsStruct;
+
+#endif	/* G992p3OvhMsgFramerGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G992p3OvhMsg.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * G992p3OvhMsg.h 
+ *
+ * Description:
+ *	This file contains the exported functions and definitions for G992p3 
+ *  overhead channel messages
+ *
+ *
+ * Copyright (c) 1999-2003 BroadCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.1 $
+ *
+ * $Id: G992p3OvhMsg.h,v 1.1 2003/07/18 19:39:18 ilyas Exp $
+ *
+ * $Log: G992p3OvhMsg.h,v $
+ * Revision 1.1  2003/07/18 19:39:18  ilyas
+ * Initial G.992.3 overhead channel message implementation (from ADSL driver)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G992p3OvhMsgFramerHeader
+#define	G992p3OvhMsgFramerHeader
+
+#define	kG992p3OvhMsgFrameBufCnt	-1
+
+extern Boolean  G992p3OvhMsgInit(
+		void					*gDslVars, 
+		bitMap					setup,
+		dslFrameHandlerType		rxReturnFramePtr,
+		dslFrameHandlerType		txSendFramePtr,
+		dslCommandHandlerType	commandHandler,
+		dslStatusHandlerType	statusHandler);
+
+extern void		G992p3OvhMsgReset(void *gDslVars);
+extern void		G992p3OvhMsgClose(void *gDslVars);
+extern void		G992p3OvhMsgTimer(void *gDslVars, long timeQ24ms);
+extern Boolean	G992p3OvhMsgCommandHandler (void *gDslVars, dslCommandStruct *cmd);
+extern void		G992p3OvhMsgStatusSnooper (void *gDslVars, dslStatusStruct *status);
+
+extern	int		G992p3OvhMsgSendCompleteFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+extern  int		G992p3OvhMsgIndicateRcvFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+
+extern void		G992p3OvhMsgSetL3(void *gDslVars);
+extern void		G992p3OvhMsgSetL0(void *gDslVars);
+
+#endif	/* G992p3OvhMsgFramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,66 @@
+/****************************************************************************
+ *
+ * G997.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for the G997 Framer
+ *	global variable structure.
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: G997.gh,v 1.5 2004/07/21 01:39:41 ilyas Exp $
+ *
+ * $Log: G997.gh,v $
+ * Revision 1.5  2004/07/21 01:39:41  ilyas
+ * Reset entire G.997 state on retrain. Timeout in G.997 if no ACK
+ *
+ * Revision 1.4  2004/04/27 00:27:16  ilyas
+ * Implemented double buffering to ensure G.997 HDLC frame is continuous
+ *
+ * Revision 1.3  2003/07/18 18:56:59  ilyas
+ * Added support for shared TX buffer (for ADSL driver)
+ *
+ * Revision 1.2  2002/01/11 06:48:27  ilyas
+ * Added command handler pointer
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G997FramerGlobals
+#define	G997FramerGlobals
+
+#include "DslFramer.h"
+#include "HdlcFramer.h"
+
+#define	kG997MsgBufSize		64
+
+typedef struct
+	{
+	bitMap					setup;
+	dslFramerControl		dslFramer;
+	hdlcByteControl			hdlcByte;
+	dslCommandHandlerType	commandHandler;
+
+	ulong					timeMs;
+	ulong					timeCmdOut;
+
+	uchar					rxMsgNum;		
+	uchar					txMsgNum;
+	Boolean					txIdle;		
+	uchar					txMsgBuf[kG997MsgBufSize];
+	ulong					txMsgBufLen;
+	uchar					*txMsgBufPtr;
+	ulong					txMsgLen;
+	ulong					txMsgBufs;
+	ulong					txMsgBufNum;
+	}
+	g997VarsStruct;
+
+#endif	/* G997FramerGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/G997.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * G997.h 
+ *
+ * Description:
+ *	This file contains the exported functions and definitions for G97Framer
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.3 $
+ *
+ * $Id: G997.h,v 1.3 2003/07/18 18:56:59 ilyas Exp $
+ *
+ * $Log: G997.h,v $
+ * Revision 1.3  2003/07/18 18:56:59  ilyas
+ * Added support for shared TX buffer (for ADSL driver)
+ *
+ * Revision 1.2  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G997FramerHeader
+#define	G997FramerHeader
+
+extern Boolean  G997Init(
+		void					*gDslVars, 
+		bitMap					setup, 
+		ulong					rxBufNum,
+		ulong					rxBufSize,
+		ulong					rxPacketNum,
+		upperLayerFunctions		*pUpperLayerFunctions,
+		dslCommandHandlerType	g997PhyCommandHandler);
+
+extern void		G997Close(void *gDslVars);
+extern void		G997Timer(void *gDslVars, long timeQ24ms);
+extern Boolean	G997CommandHandler (void *gDslVars, dslCommandStruct *cmd);
+extern void		G997StatusSnooper (void *gDslVars, dslStatusStruct *status);
+
+extern	int		G997SendFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+extern  int		G997ReturnFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+
+extern  Boolean G997SetTxBuffer(void *gDslVars, ulong len, void *bufPtr);
+extern	void *	G997GetFramePoolHandler(void *gDslVars);
+
+#endif	/* G997FramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/HdlcFramer.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/HdlcFramer.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/HdlcFramer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/HdlcFramer.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,237 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * HdlcFramer.h 
+ *
+ * Description:
+ *	This file contains common HDLC definitions for bit/byte stuffing
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.3 $
+ *
+ * $Id: HdlcFramer.h,v 1.3 2004/07/21 01:39:41 ilyas Exp $
+ *
+ * $Log: HdlcFramer.h,v $
+ * Revision 1.3  2004/07/21 01:39:41  ilyas
+ * Reset entire G.997 state on retrain. Timeout in G.997 if no ACK
+ *
+ * Revision 1.2  2003/07/18 18:51:05  ilyas
+ * Added mode (default) to pass address and control field
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	HdlcFramerHeader
+#define	HdlcFramerHeader
+
+/* setup bitmap definitions */
+
+#define	kHdlcSetupShift			16
+#define	kHdlcSetupMask			((long)0xFFFF << kHdlcSetupShift)
+
+#define	kHdlcCrcMask			0x00030000
+#define	kHdlcCrcNone			0x00000000
+#define	kHdlcCrc16				0x00010000
+#define	kHdlcCrc32				0x00020000
+
+#define	kHdlcTxIdleStop			0x00040000
+#define	kHdlcSpecialAddrCtrl	0x00080000
+
+extern	ushort HdlcCrc16Table[];
+
+#define HDLC16_CRC_INIT			0xFFFF
+#define HDLC16_CRC_FINAL(crc)	((crc) ^ 0xFFFF)
+#define HDLC16_GOOD_CRC			0xF0B8
+#define	Hdlc16UpdateCrc(crc,b)	((crc) >> 8) ^ HdlcCrc16Table[((crc) ^ (b)) & 0xFF]
+
+extern	ulong  HdlcCrc32Table[];
+
+#define HDLC32_CRC_INIT			0xFFFFFFFF
+#define HDLC32_CRC_FINAL(crc)	((crc) ^ 0xFFFFFFFF)
+#define HDLC32_GOOD_CRC			0xDEBB20E3
+#define	Hdlc32UpdateCrc(crc,b)	((crc) >> 8) ^ HdlcCrc32Table[((crc) ^ (b)) & 0xFF]
+
+extern	ulong  HdlcCrc32Table[];
+
+/* HDLC common fields */
+
+#define	HDLC_ADDR				0xFF
+#define	HDLC_CTRL				0x3
+
+#define	HDLC_BYTE_FLAG			0x7E
+#define	HDLC_BYTE_ESC			0x7D
+
+/* HDLC frame assembly states */
+
+#define	HDLC_STATE_START_FLAG	0
+#define	HDLC_STATE_ADDRESS		(HDLC_STATE_START_FLAG + 1)
+#define	HDLC_STATE_CONTROL		(HDLC_STATE_START_FLAG + 2)
+#define	HDLC_STATE_DATA			(HDLC_STATE_START_FLAG + 3)
+#define	HDLC_STATE_FCS1			(HDLC_STATE_START_FLAG + 4)
+#define	HDLC_STATE_FCS2			(HDLC_STATE_START_FLAG + 5)
+#define	HDLC_STATE_END_FLAG		(HDLC_STATE_START_FLAG + 6)
+
+
+/* HDLC common types */
+
+typedef struct _hdlcByteControl {
+	bitMap					setup;
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	rxDataDoneHandler;
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	txDataDoneHandler;
+
+	/* RX working data set */
+
+	uchar					rxFrameState;
+	int						rxFrameLen;
+	ulong					rxCrc;
+	Boolean					rxEscChar;
+
+	uchar					*pRxData;
+	uchar					*pRxDataEnd;
+	long					rxDataLen;
+
+	/* TX working data set */
+
+	uchar					txFrameState;
+	int						txFrameLen;
+	ulong					txCrc;
+	int						txCharPending;
+
+	uchar					*pTxData;
+	uchar					*pTxDataEnd;
+	long					txDataLen;
+} hdlcByteControl;
+
+typedef struct _hdlcBitControl {
+	bitMap					setup;
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	rxDataDoneHandler;
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	txDataDoneHandler;
+
+	/* RX working data set */
+
+	uchar					rxFrameState;
+	int						rxFrameLen;
+	ulong					rxCrc;
+	int						rxNibblePending;
+	int						rxOutVal;
+	uchar					rxOutBits;
+	uchar					rxRem1Bits;
+	Boolean					rxEscChar; /* ???? */
+
+	uchar					*pRxData;
+	uchar					*pRxDataEnd;
+	long					rxDataLen;
+
+	/* TX working data set */
+
+	uchar					txFrameState;
+	int						txFrameLen;
+	ulong					txCrc;
+	int						txOutVal;
+	uchar					txOutBits;
+	uchar					txLast1Bits;
+	int						txCharPending;	/* ???? */
+
+	uchar					*pTxData;
+	uchar					*pTxDataEnd;
+	long					txDataLen;
+} hdlcBitControl;
+
+/* HDLC common functions */
+
+#define HdlcFramerTxFrameInit(ctrl)	do {			\
+	ctrl->txFrameState = HDLC_STATE_START_FLAG;		\
+	ctrl->txFrameLen   = 0;							\
+	ctrl->txCrc		   = HDLC16_CRC_INIT;			\
+	ctrl->txCharPending= -1;						\
+} while (0)
+
+#define HdlcFramerRxFrameInit(ctrl) do {			\
+	ctrl->rxFrameState = HDLC_STATE_START_FLAG;		\
+	ctrl->rxFrameLen   = 0;							\
+	ctrl->rxCrc		   = HDLC16_CRC_INIT;			\
+	ctrl->rxEscChar	   = false;						\
+} while (0)
+
+#define HdlcFramerTxGetData(ctrl)  do {								\
+	dslFramerBufDesc	bufDesc;									\
+																	\
+	if ((ctrl->txDataGetPtrHandler) (gDslVars, &bufDesc)) {			\
+		ctrl->pTxData = bufDesc.bufPtr;								\
+		ctrl->pTxDataEnd = (uchar*)bufDesc.bufPtr + bufDesc.bufLen;	\
+		ctrl->txDataLen	 = bufDesc.bufLen;							\
+		if (bufDesc.bufFlags & kDslFramerStartNewFrame)				\
+			HdlcFramerTxFrameInit(ctrl);							\
+	}																\
+	else {															\
+		HdlcFramerTxFrameInit(ctrl);								\
+	}																\
+} while (0);
+
+#define HdlcFramerRxGetData(ctrl, frFlag)  do {						\
+	dslFramerBufDesc		bufDesc;								\
+																	\
+	bufDesc.bufFlags = frFlag;										\
+	if ((ctrl->rxDataGetPtrHandler) (gDslVars, &bufDesc)) {			\
+		ctrl->pRxData = bufDesc.bufPtr;								\
+		ctrl->pRxDataEnd = (uchar*)bufDesc.bufPtr + bufDesc.bufLen;	\
+		ctrl->rxDataLen	 = bufDesc.bufLen;							\
+	}																\
+} while (0);
+
+/* HDLC functions headers */
+
+extern Boolean HdlcByteInit(
+	void							*gDslVars, 
+	hdlcByteControl					*hbyCtrl,
+	bitMap							setup, 
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	rxDataDoneHandler,
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	txDataDoneHandler);
+
+extern void HdlcByteReset(void *gDslVars, hdlcByteControl *hbyCtrl);
+extern void HdlcByteRxFlush(void *gDslVars, hdlcByteControl *hbyCtrl);
+extern int HdlcByteRx(void *gDslVars, hdlcByteControl *hbyCtrl, int nBytes, uchar *srcPtr) FAST_TEXT;
+extern int HdlcByteTx(void *gDslVars, hdlcByteControl *hbyCtrl, int nBytes, uchar *dstPtr) FAST_TEXT;
+extern Boolean HdlcByteTxIdle(void *gDslVars, hdlcByteControl *hbyCtrl);
+
+extern Boolean HdlcBitInit(
+	void							*gDslVars, 
+	hdlcBitControl					*hbiCtrl,
+	bitMap							setup, 
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	rxDataDoneHandler,
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	txDataDoneHandler);
+
+extern void HdlcBitReset(void *gDslVars, hdlcByteControl *hbiCtrl);
+extern int HdlcBitRx(void *gDslVars, hdlcBitControl *hbiCtrl, int nBytes, uchar *srcPtr) FAST_TEXT;
+extern int HdlcBitTx(void *gDslVars, hdlcBitControl *hbiCtrl, int nBytes, uchar *dstPtr) FAST_TEXT;
+
+#endif	/* HdlcFramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MathUtil.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MathUtil.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MathUtil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MathUtil.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,135 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/************************************************************************
+ *
+ *	MathUtil.h:
+ *
+ *	Description:
+ *	This file contains the exported interface for MathUtil.c module.
+ *
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.6 $
+ *
+ * $Id: MathUtil.h,v 1.6 2004/04/13 00:21:13 ilyas Exp $
+ *
+ * $Log: MathUtil.h,v $
+ * Revision 1.6  2004/04/13 00:21:13  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.5  2001/08/16 02:18:08  khp
+ * - mark functions with FAST_TEXT to reduce cycle counts for QPROC targets
+ *   (replaces use of LMEM_INSN)
+ *
+ * Revision 1.4  1999/10/06 04:55:22  liang
+ * Added function to multiply two long values to save result as VeryLong.
+ *
+ * Revision 1.3  1999/08/05 19:42:52  liang
+ * Merged with the softmodem top of the tree on 08/04/99 for assembly files.
+ *
+ * Revision 1.2  1999/03/26 03:29:59  liang
+ * Export CosSin table.
+ *
+ * Revision 1.1  1998/10/28 01:28:07  liang
+ * *** empty log message ***
+ *
+ * Revision 1.12  1998/02/10  17:19:49  scott
+ * Changed MathVL routines to return arguments using pointers
+ *
+ * Revision 1.11  1997/12/13 06:12:07  mwg
+ * Added more Atan2 flavors
+ *
+ * Revision 1.10  1997/11/18 01:11:48  mwg
+ * Removed <CR> symbols which accidently slipped in.
+ *
+ * Revision 1.9  1997/11/03  19:07:52  scott
+ * No longer redefine max() and min() if already defined
+ *
+ * Revision 1.8  1997/07/30 01:35:20  liang
+ * Add more accurate atan2 function UtilLongLongAtan2.
+ *
+ * Revision 1.7  1997/07/21  20:23:19  mwg
+ * Added new function: UtilBlockCos()
+ *
+ * Revision 1.6  1997/03/21  23:50:10  liang
+ * Added initial version of V8bis module to CVS tree.
+ *
+ * Revision 1.5  1997/03/19  18:35:34  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.4  1997/01/21  00:36:15  mwg
+ * Added new function: UtilBlockCosSin()
+ *
+ * Revision 1.3  1996/06/18  21:14:45  mwg
+ * Modified VLDivVL by allowing to specify the result scaling.
+ *
+ * Revision 1.2  1996/06/12  02:31:59  mwg
+ * Added 64bit arithmetic functions.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:15  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.4  1995/12/04  23:08:15  liang
+ * Add file Math/LinearToLog.c.
+ *
+ ************************************************************************/
+#ifndef	MathUtilPh
+#define	MathUtilPh
+
+/* Exported tables */
+extern	const short		UtilCosTable[];
+
+/* Exported functions */
+extern	ComplexShort	UtilCosSin(ushort angle);
+extern	long			UtilBlockCosSin (int nValues, long angle, long delta, ComplexShort *dstPtr);
+extern	long			UtilBlockCos (int nValues, long angle, long delta, short *dstPtr);
+extern	ushort			UtilShortShortAtan2(ComplexShort point);
+extern	ushort			UtilLongShortAtan2(ComplexLong point);
+extern	ulong			UtilShortLongAtan2(ComplexShort point) FAST_TEXT;
+extern	ulong			UtilLongLongAtan2(ComplexLong point) FAST_TEXT;
+extern	ushort			UtilSqrt(ulong y);
+extern	ushort			UtilMaxMagnitude(int blkSize, ComplexShort *dataPtr);
+extern	short			UtilQ0LinearToQ4dB (ulong x);
+extern	ulong			UtilQ4dBToQ12Linear (short x);
+extern	void			UtilAdjustComplexMagnitude(ComplexShort	*srcPtr, short mag, short adjustment);
+
+extern	void VLMultLongByLong(long x, long y, VeryLong *dst);
+extern	void VLMultShort	(VeryLong x, short y, VeryLong *dst);
+extern	void VLAddVL		(VeryLong x, VeryLong y, VeryLong *dst);
+extern	void VLAddLong	(VeryLong x, long y, VeryLong *dst);
+extern	void VLSubVL		(VeryLong x, VeryLong y, VeryLong *dst);
+extern	void VLSubLong	(VeryLong x, long y, VeryLong *dst);
+extern	void VLDivVL		(VeryLong x, VeryLong y, int scale, long *dst);
+extern	void VLShiftLeft(VeryLong x, int shift, VeryLong *dst);
+extern	void VLShiftRight(VeryLong x, int shift, VeryLong *dst);
+
+
+#define	UtilAtan2		UtilShortShortAtan2
+#define	UtilLongAtan2	UtilLongShortAtan2
+
+/* Standard Macros	*/
+#undef abs
+#define		abs(x)			((x) >= 0   ? (x) : -(x))
+
+#undef max
+#define		max(x, y)		((x) >= (y) ? (x) : (y))
+
+#undef min
+#define		min(x, y)		((x) <= (y) ? (x) : (y))
+
+#endif	/* MathUtilPh */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MipsAsm.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MipsAsm.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MipsAsm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MipsAsm.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,264 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/************************************************************************
+ *
+ *	MipsAsm.h:
+ *
+ *	Description:
+ *	This file contains definitions specific to MIPS assembly 
+ *
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: MipsAsm.h,v 1.5 2004/04/13 00:16:59 ilyas Exp $
+ *
+ * $Log: MipsAsm.h,v $
+ * Revision 1.5  2004/04/13 00:16:59  ilyas
+ * Merged the latest ADSL driver changes
+ *
+ * Revision 1.4  2002/09/12 04:08:50  ilyas
+ * Added macros for BCM MIPS specific instructions
+ *
+ * Revision 1.3  2000/11/18 21:28:19  mprahlad
+ * ifdef bcm47xx -
+ * define MSUB(src1,src2) msub src1, src2
+ * change Mult(dst, src1, src2) to use "mul" instead of "mult; mflo"
+ * define Mul(src1, src2) mult src1, src2
+ *
+ * Revision 1.2  2000/07/28 21:05:05  mprahlad
+ * Macros specific to bcm47xx added.
+ *
+ * Revision 1.1  1999/08/05 19:52:57  liang
+ * Copied from the softmodem top of the tree on 08/04/99.
+ *
+ * Revision 1.5  1999/04/02 23:16:21  mwg
+ * Fixed a minor comatibility issue with mult
+ *
+ * Revision 1.4  1999/02/03 20:25:43  mwg
+ * Added an option for R4010
+ *
+ * Revision 1.3  1998/10/30 02:21:34  mwg
+ * Added targets for 4640
+ *
+ * Revision 1.2  1998/10/16 18:52:09  ilyas
+ * Added ASM_PROLOG[5-7] macros to save on stores
+ *
+ * Revision 1.1  1998/06/03 23:28:39  mwg
+ * Renamed from DinoDefs.h
+ *
+ * Revision 1.6  1998/02/09  18:23:11  scott
+ * Added EMBEDDED_CALLING_CONVENTION (GreenHill) and R3900/R4102
+ *
+ * Revision 1.5  1997/03/19 18:35:02  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.4  1996/10/02  20:28:41  liang
+ * Remove parameter "acc" from the non-DINO version of MAD.
+ *
+ * Revision 1.3  1996/10/02  19:44:36  liang
+ * Separated MultAdd into MAD and MADW, added NO_DINO_WRITEBACK option.
+ *
+ * Revision 1.2  1996/08/14  03:06:07  liang
+ * Modified macro MultAdd so that the assembly code build works.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.5  1994/11/04  22:41:29  mwg
+ * Added #ifdefs for different targets.
+ *
+ ************************************************************************/
+
+#ifndef _MIPS_ASM_H_
+#define	_MIPS_ASM_H_
+
+#define zero	$0
+#define v0	$2
+#define v1	$3
+#define a0	$4
+#define a1	$5
+#define a2	$6
+#define a3	$7
+#define t0	$8
+#define t1	$9
+#define t2	$10
+#define t3	$11
+#define t4	$12
+#define t5	$13
+#define t6	$14
+#define t7	$15
+#define s0	$16	
+#define s1	$17
+#define s2	$18
+#define s3	$19
+#define s4	$20
+#define s5	$21
+#define s6	$22
+#define s7	$23
+#define t8	$24
+#define t9	$25
+#define k0	$26
+#define k1	$27
+#define gp	$28
+#define sp	$29
+#define fp	$30
+#define s8	$30
+#define ra	$31
+
+#ifdef EMBEDDED_CALLING_CONVENTION
+
+/* Support for GreenHills embedded calling convention */
+
+#define ASM_PROLOG	subu	sp, 32; \
+					sw		$8, 16(sp); \
+					sw		$9, 20(sp); \
+					sw		$10, 24(sp); \
+					sw		$11, 28(sp);
+
+#define ASM_PROLOG5	subu	sp, 32; \
+					sw		$8, 16(sp);
+
+#define ASM_PROLOG6	subu	sp, 32; \
+					sw		$8, 16(sp); \
+					sw		$9, 20(sp);
+
+#define ASM_PROLOG7	subu	sp, 32; \
+					sw		$8, 16(sp); \
+					sw		$9, 20(sp); \
+					sw		$10, 24(sp);
+
+#define ASM_EPILOG	addu	sp, 32
+
+#else
+#define ASM_PROLOG
+#define ASM_PROLOG5
+#define ASM_PROLOG6
+#define ASM_PROLOG7
+#define ASM_EPILOG
+#endif
+
+#ifdef	DINO	/* Special DSP extensions to MIPS core */
+
+#ifndef	NO_DINO_WRITEBACK	/* DSP extensions with writeback register */
+
+#define	MAD(src1, src2)			.set	noreorder	; mad	$0, src1, src2	; .set	reorder
+#define	MADW(acc, src1, src2)	.set	noreorder	; mad	acc, src1, src2	; .set	reorder
+#define	Mult(dst, src1, src2)	.set	noreorder	; mult	dst, src1, src2	; .set	reorder	
+#define	MultU(dst, src1, src2)	.set	noreorder	; multu	dst, src1, src2	; .set	reorder		
+
+#else	/* NO_DINO_WRITEBACK */
+
+#define	MAD(src1, src2)			.set	noreorder	; mad	$0, src1, src2	; .set	reorder
+#define	MADW(acc, src1, src2)	.set	noreorder	; mad	$0, src1, src2	; mflo acc ; .set	reorder
+#define	Mult(dst, src1, src2)	multu	src1, src2 ; mflo dst
+#define	MultU(dst, src1, src2)	multu	src1, src2 ; mflo dst		
+
+#endif	/* NO_DINO_WRITEBACK */
+
+#else	/* DINO */
+
+#if defined(R3900)
+
+#define	MAD(src1, src2)		madd	$0, src1, src2
+#define	MADW(acc, src1, src2)	madd	acc, src1, src2
+#define	Mult(dst, src1, src2)	mult	dst, src1, src2
+#define	MultU(dst, src1, src2)	multu	dst, src1, src2
+
+#elif defined(bcm47xx_INSTR_MACROS) && defined(bcm47xx)
+
+#define mips_froo(s1,s2,s3)			s1##s2##s3
+#define	MSUB(s1,s2)					.set noreorder ; mips_froo(msub_,s1,s2) ; .set reorder
+#define MAD(s1,s2) 					.set noreorder ; mips_froo(mad_,s1,s2) ; .set reorder
+#define MADW(acc, s1,s2)			.set noreorder ; mips_froo(mad_,s1,s2) ; mflo acc ; .set reorder
+
+#include "BCM4710.h"
+
+#define	Mult(dst, src1, src2)		mul		dst, src1, src2
+#define	Mul( src1, src2)			mult	src1, src2 ; 
+#define	MultU(dst, src1, src2)		multu	src1, src2	; mflo dst
+
+#elif defined(bcm47xx)
+#define	MSUB(src1, src2)			msub	src1, src2
+#define	MAD(src1, src2)			madd	src1, src2
+#define	MADW(acc, src1, src2)	.set noreorder ; madd	src1, src2; mflo acc ; .set reorder
+/*
+#define	Mult(dst, src1, src2)	mult	src1, src2 ; mflo dst
+*/
+#define	Mult(dst, src1, src2)	mul	dst , src1, src2 ; 
+#define	Mul( src1, src2)	mult	src1, src2 ; 
+#define	MultU(dst, src1, src2)	multu	src1, src2 ; mflo dst
+
+#else
+
+#ifdef R4102
+#define	MAD(src1, src2)			madd16	src1, src2
+#define	MADW(acc, src1, src2)	madd16	src1, src2	; mflo acc
+#else /* R4102 */
+
+#ifdef R4640
+
+#define	MAD(src1, src2)			madd	$0, src1, src2
+#define	MADW(acc, src1, src2)	madd	src1, src2; mflo acc
+
+#else /* R4640 */
+
+#ifdef R4010
+
+#define	MAD(src1, src2)			madd	src1, src2
+#define	MADW(acc, src1, src2)	madd	src1, src2; mflo acc
+
+#else
+#define	MAD(src1, src2)				.set	noat		;\
+									mflo	$at			;\
+									sw		$2,   -4(sp)	;\
+									multu	src1, src2	;\
+									mflo	$2			;\
+									addu	$at, $2, $at	;\
+									lw		$2,   -4(sp)	;\
+									mtlo	$at		;\
+									.set	at
+
+#define	MADW(acc, src1, src2)		.set	noat		;\
+									mflo	$at			;\
+									sw		$2,   -4(sp)	;\
+									multu	src1, src2	;\
+									mflo	$2			;\
+									addu	$at, $2, $at	;\
+									lw		$2,   -4(sp)	;\
+									move	acc, $at	;\
+									mtlo	$at		;\
+									.set	at
+#endif /* R4010 */
+#endif /* R4102 */
+#endif /* R4640 */
+
+#define	Mult(dst, src1, src2)		mul		dst, src1, src2
+#define	MultU(dst, src1, src2)		multu	src1, src2	; mflo dst
+
+#endif	/* !3900 */
+#endif	/* DINO */
+
+
+
+
+
+
+
+
+#endif	/* _MIPS_ASM_H_ */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MiscUtil.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MiscUtil.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MiscUtil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/MiscUtil.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * MiscUtil.h -- Miscellaneous utilities
+ *
+ * Description:
+ *
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg Haixiang Liang
+ *
+ * $Revision: 1.4 $
+ *
+ * $Id: MiscUtil.h,v 1.4 2004/04/13 00:21:46 ilyas Exp $
+ *
+ * $Log: MiscUtil.h,v $
+ * Revision 1.4  2004/04/13 00:21:46  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.3  2001/07/21 01:21:06  ilyas
+ * Added more functions for int to string conversion used by log file
+ *
+ * Revision 1.2  1999/08/05 19:42:56  liang
+ * Merged with the softmodem top of the tree on 08/04/99 for assembly files.
+ *
+ * Revision 1.1  1999/01/27 22:10:12  liang
+ * Initial version.
+ *
+ * Revision 1.1  1997/07/10 01:18:45  mwg
+ * Initial revision.
+ *
+ *
+ *
+ *****************************************************************************/
+#ifndef _MISC_UTIL_H_
+#define _MISC_UTIL_H_
+
+extern long		SM_DECL	GetRateValue(dataRateMap rate);
+extern int 		SM_DECL	DecToString(ulong value, uchar *dstPtr, uint nDigits);
+extern int 		SM_DECL	HexToString(ulong value, uchar *dstPtr, uint nDigits);
+extern char *	SM_DECL	DecToStr(char *s, ulong num);
+extern char *	SM_DECL	SignedToStr(char *s, long num);
+extern char *	SM_DECL	HexToStr(char *s, ulong num);
+
+#define	EvenParityBit(x)	((z = (y = x ^ (x >> 4)) ^ (y >> 2)) ^ (z >> 1))
+#define	OddParityBit(x)		(EvenParityBit(x) ^ 1)
+
+extern void	ParityApply(int nBytes, int nDataBits, int parity, uchar *srcPtr, uchar *dstPtr);
+extern void	ParityStrip(int nBytes, int nDataBits, int parity, uchar *srcPtr, uchar *dstPtr, statusHandlerType	statusHandler);
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Que.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Que.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Que.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/Que.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,106 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * Que.h
+ *
+ * Description:
+ *	Definition and implementation (via macros and inline functions)
+ *  of a simple queue
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ *****************************************************************************/
+
+#ifndef	QueHeader_H_
+#define	QueHeader_H_
+
+typedef void *		_QueItem;
+
+typedef struct _QueHeader
+	{
+	_QueItem	*head;		/* first item in the queue */
+	_QueItem	*tail;		/* last item in the queue */
+	} QueHeader;
+
+/* Queue management macros */
+
+#define QueInit(pqHdr)		(((QueHeader *)(pqHdr))->head = ((QueHeader *)(pqHdr))->tail = NULL)
+#define QueEmpty(pqHdr)     (NULL == ((QueHeader *)(pqHdr))->head)
+
+#define QueFirst(pqHdr)		((QueHeader *)(pqHdr))->head
+#define QueLast(pqHdr)		((QueHeader *)(pqHdr))->tail 
+#define QueNext(pqItem)		(*((void **)(pqItem)))
+
+
+#define QueRemoveFirst(pqHdr)	do {										\
+    if (!QueEmpty(pqHdr)) {													\
+      ((QueHeader *)(pqHdr))->head = *((QueHeader *)(pqHdr))->head;			\
+      if (QueEmpty(pqHdr))													\
+        ((QueHeader *)(pqHdr))->tail = NULL;								\
+    }																		\
+} while (0)
+#define QueRemove(pqHdr)		QueRemoveFirst(pqHdr)
+
+
+#define QueAddLast(pqHdr,pqItem) do {						\
+    QueNext(pqItem) = NULL;									\
+    if (NULL != ((QueHeader *)(pqHdr))->tail)				\
+      *((QueHeader *)(pqHdr))->tail = (pqItem);				\
+    else													\
+      ((QueHeader *)(pqHdr))->head = (_QueItem *)(pqItem);  \
+    ((QueHeader *)(pqHdr))->tail = (_QueItem *)(pqItem);    \
+} while (0)
+#define QueAdd(pqHdr,pItem)    QueAddLast(pqHdr,pItem)
+
+#define QueAddFirst(pqHdr,pqItem)	do {					\
+    if (NULL == ((QueHeader *)(pqHdr))->tail)				\
+	  ((QueHeader *)(pqHdr))->tail = (_QueItem *)(pqItem);  \
+    QueNext(pqItem) = ((QueHeader *)(pqHdr))->head;			\
+    ((QueHeader *)(pqHdr))->head = (_QueItem *)(pqItem);	\
+} while (0)
+
+
+#define QueGet(pqHdr)			\
+  (void *) QueFirst(pqHdr);		\
+  QueRemove(pqHdr);
+
+#define QueMerge(pqHdr1,pqHdr2)	do {											\
+  if (NULL == ((QueHeader *)(pqHdr1))->tail)									\
+	((QueHeader *)(pqHdr1))->head = ((QueHeader *)(pqHdr2))->head;				\
+  else																			\
+    QueNext(((QueHeader *)(pqHdr1))->tail) = ((QueHeader *)(pqHdr2))->head;		\
+  if (NULL != ((QueHeader *)(pqHdr2))->tail)                 					\
+	((QueHeader *)(pqHdr1))->tail = ((QueHeader *)(pqHdr2))->tail;				\
+} while (0)
+
+#define QueCopy(pqHdr1,pqHdr2)	do {											\
+	((QueHeader *)(pqHdr1))->head = ((QueHeader *)(pqHdr2))->head;				\
+	((QueHeader *)(pqHdr1))->tail = ((QueHeader *)(pqHdr2))->tail;				\
+} while (0)
+
+#define	QueForEach(pqHdr,f,ref)		do {			\
+	_QueItem	*p = ((QueHeader *)(pqHdr))->head;	\
+													\
+	while (NULL != p) {								\
+	  if ( (f)((void *)p, ref) ) break;				\
+	  p = QueNext(p);								\
+	}												\
+} while (0)
+
+#endif	/* QueHeader_H_ */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftAtmVc.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftAtmVc.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftAtmVc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftAtmVc.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,569 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * SoftAtmVc.h 
+ *
+ * Description:
+ *	This file contains ATM VC definitions
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.27 $
+ *
+ * $Id: SoftAtmVc.h,v 1.27 2004/06/02 22:26:17 ilyas Exp $
+ *
+ * $Log: SoftAtmVc.h,v $
+ * Revision 1.27  2004/06/02 22:26:17  ilyas
+ * Added ATM counters for G.992.3
+ *
+ * Revision 1.26  2004/03/10 22:57:20  ilyas
+ * Added I.432 scramling control
+ *
+ * Revision 1.25  2003/09/23 00:21:59  ilyas
+ * Added status to indicate ATM header compression
+ *
+ * Revision 1.24  2003/08/27 02:00:50  ilyas
+ * Original implementation of ATM header compression
+ *
+ * Revision 1.23  2003/02/25 04:13:15  ilyas
+ * Added standard Broadcom header
+ *
+ * Revision 1.22  2003/01/10 23:25:48  ilyas
+ * Added ATM status definition
+ *
+ * Revision 1.21  2002/09/12 21:07:19  ilyas
+ * Added HEC, OCD and LCD counters
+ *
+ * Revision 1.20  2002/04/02 09:58:00  ilyas
+ * Initial implementatoin of BERT
+ *
+ * Revision 1.19  2001/10/09 22:35:14  ilyas
+ * Added more ATM statistics and OAM support
+ *
+ * Revision 1.18  2001/06/18 19:49:36  ilyas
+ * Changes to include support for HOST_ONLY mode
+ *
+ * Revision 1.17  2001/02/23 05:49:57  ilyas
+ * Added routed 1483 encapsulation
+ *
+ * Revision 1.16  2001/02/09 04:18:18  ilyas
+ * Added framer for bridged ethernet PDUs
+ *
+ * Revision 1.15  2001/02/09 01:55:27  ilyas
+ * Added status codes and macros to support printing of AAL packets
+ *
+ * Revision 1.14  2000/09/21 17:28:35  ilyas
+ * Added VBR support to traffic management code, separated UBR to a different
+ * Tx list, changed some of the algorithms
+ *
+ * Revision 1.13  2000/08/23 18:42:13  ilyas
+ * Added AAL2, added VcConfigure functions, moved commonly used look-up
+ * tables for CRC calculation to AtmLayer
+ *
+ * Revision 1.12  2000/08/02 03:06:22  ilyas
+ * Added support for reserving space in RX packets for ATm protocols
+ *
+ * Revision 1.11  2000/07/28 17:23:39  ilyas
+ * Added ATM connect/disconnect statuses
+ *
+ * Revision 1.10  2000/07/25 02:16:12  ilyas
+ * Added EClip (with Eth to ATM ARP translation) implementation
+ *
+ * Revision 1.9  2000/07/23 20:57:14  ilyas
+ * Added ATM framer and protocol layers
+ *
+ * Revision 1.8  2000/07/17 21:08:16  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.7  2000/06/09 18:33:04  liang
+ * Fixed Irix compiler warnings.
+ *
+ * Revision 1.6  2000/05/18 21:47:31  ilyas
+ * Added detection of preassigned cells such as OAM F4, F5
+ *
+ * Revision 1.5  2000/05/14 01:50:11  ilyas
+ * Added more statuses to ATM code
+ *
+ * Revision 1.4  2000/05/10 02:41:28  liang
+ * Added status report for no cell memory
+ *
+ * Revision 1.3  2000/05/09 23:00:27  ilyas
+ * Added ATM status messages, ATM timer, Tx frames flush on timeout
+ * Fixed a bug - adding flushed Tx frames to the list of free Rx frames
+ *
+ * Revision 1.2  2000/05/03 03:53:00  ilyas
+ * Added support for pVc to vcID translation needed for LOG file and other
+ * definitions for ATM data in LOG file
+ *
+ * Revision 1.1  2000/04/19 00:21:35  ilyas
+ * Fixed some problems and added Out Of Band (OOB) support to ATM packets
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	SoftAtmVcHeader
+#define	SoftAtmVcHeader
+
+/*
+**
+**		ATM UNI types
+**
+*/
+
+#define AtmLinkFlags(bMap,name)		(((bMap) >> name##Shift) & name##Mask)
+
+/* ATM service category types */
+
+#define	kAtmSrvcCBR		1	/* Constant Bit Rate	*/
+#define	kAtmSrvcVBR		2	/* Variable Bit Rate	*/
+#define	kAtmSrvcUBR		4	/* Unspecified Bit Rate	*/
+#define	kAtmSrvcABR		8	/* Available Bit Rate	*/
+#define	kAtmSrvcUnknown	0xFF
+
+/* ATM AAL types (as encoded at UNI) */
+
+#define	kAtmAalIE		0x58
+
+#define	kAtmRaw			0
+#define	kAtmAal1		1
+#define	kAtmAal2		2
+#define	kAtmAal34		3
+#define	kAtmAal5		5
+#define	kAtmAalUser		16
+#define	kAtmAalUnknown	0xFF
+
+/* ATM AAL1 parameters  */
+
+#define	kAal1SubTypeId			0x85
+
+#define	kAal1TransportShift		0
+#define	kAal1TransportMask		0x7
+
+#define	kAal1NullTransport		0
+#define	kAal1VoiceTransport		1
+#define	kAal1CircuitTransport	2
+#define	kAal1AudioTransport		4
+#define	kAal1VideoTransport		5
+
+
+#define	kAal1CBRId				0x86
+
+#define	kAal1CBRShift			24
+#define	kAal1CBRMask			0xFF
+
+#define	kAal1CBR64				1
+#define	kAal1CBR1544			4		/* DS1 */
+#define	kAal1CBR6312			5		/* DS2 */
+#define	kAal1CBR32064			6
+#define	kAal1CBR44736			7		/* DS3 */
+#define	kAal1CBR97728			8
+#define	kAal1CBR2048			0x10	/* E1 */
+#define	kAal1CBR8448			0x11	/* E2 */
+#define	kAal1CBR34368			0x12	/* E3 */
+#define	kAal1CBR139264			0x13
+#define	kAal1CBR64xN			0x40
+#define	kAal1CBR8xN				0x41
+
+
+#define	kAal1MultiplierId		0x87
+
+#define	kAal1ClockRecoveryId	0x88
+
+#define	kAal1ClockRecoveryShift	3
+#define	kAal1ClockRecoveryMask	0x3
+
+#define	kAal1ClockRecoveryNull	1		/* synchronous transport */
+#define	kAal1ClockRecoverySRTS	1		/* asynchronous transport */
+#define	kAal1ClockRecoveryAdaptive	2
+
+
+#define	kAal1ECMId				0x89	/* Error correction method */
+
+#define	kAal1ECMShift			(kAal1ClockRecoveryShift + 2)
+#define	kAal1ECMMask			0x3
+
+#define	kAal1ECMNull			0
+#define	kAal1ECMLossSensitive	1
+#define	kAal1ECMDelaySensitive	2
+
+
+#define	kAal1SDTBlockSizeId		0x8A
+
+#define	kAal1CellFillId			0x8B
+
+/* ATM AAL34 and AAL5 parameters  */
+
+#define	kAalFwdMaxSDUSizeId		0x8C
+#define	kAalBacMaxkSDUSizeId	0x81
+
+#define	kAal34MidRangeId		0x82
+
+#define	kAalSSCSTypeId			0x84
+
+#define	kAalSSCSAssured			1
+#define	kAalSSCSNonAssured		2
+#define	kAalSSCSFrameRelay		4
+
+/* ATM AAL2 parameters  */
+
+#define	kAal2SSNone				0
+#define	kAal2SSSAR				1
+#define	kAal2SSTED				2
+#define	kAal2SSSARMask			3
+#define	kAal2SSType1			4
+#define	kAal2SSType3			5
+
+typedef struct {
+  uchar			aalType;
+  union {
+	struct {
+	  bitMap	aal1Flags;
+	  ulong		cbrRate;
+	  ushort	blkSize;
+	  uchar		sarUsed;
+	} aal1Params;
+	struct {
+	  ushort	fwdMaxCpSize;			/* Max "common part" packet size */
+	  ushort	backMaxCpSize;
+	  ushort	cidLow;
+	  ushort	cidHigh;
+	  ushort	fwdMaxSsSize;			/* Max "service specific" packet size */
+	  ushort	backMaxSsSize;
+	  uchar		sscsType;
+	} aal2Params;
+	struct {
+	  ushort	fwdMaxSDUSize;
+	  ushort	backMaxSDUSize;
+	  ushort	midLow;
+	  ushort	midHigh;
+	  uchar		sscsType;
+	} aal34Params;
+	struct {
+	  ushort	fwdMaxSDUSize;
+	  ushort	backMaxSDUSize;
+	  uchar		sscsType;
+	} aal5Params;
+  } param;
+} atmAalParams;
+
+/* ATM Traffic Descriptor types (as encoded at UNI) */
+
+#define	kAtmTrafficIE		0x59
+
+#define	kTrafficFwdPeakCellRateId0	0x82
+#define	kTrafficBackPeakCellRateId0	0x83
+#define	kTrafficFwdPeakCellRateId	0x84
+#define	kTrafficBackPeakCellRateId	0x85
+
+#define	kTrafficFwdSustainCellRateId0	0x88
+#define	kTrafficBackSustainCellRateId0	0x89
+#define	kTrafficFwdSustainCellRateId	0x90
+#define	kTrafficBackSustainCellRateId	0x91
+
+#define	kTrafficFwdMaxBurstSizeId0	0xA0
+#define	kTrafficBackMaxBurstSizeId0	0xA1
+#define	kTrafficFwdMaxBurstSizeId	0xB0
+#define	kTrafficBackMaxBurstSizeId	0xB1
+
+#define	kTrafficBestEffortId		0xBE
+#define	kTrafficMgrOptionsId		0xBF
+
+#define	kTrafficMaxTolerance		0x7FFFFFFF
+
+/*	trafficFlags coding */
+
+#define	kTrafficTagFwd				1
+#define	kTrafficTagBack				2
+#define	kTrafficBestEffort			4
+
+typedef struct {
+  ulong			tPCR0;					/* CLP = 0, time between cells in us */
+  ulong			tPCR;					/* CLP = 0+1 */
+  ulong			tolPCR;					/* tolerance for PCR in us */
+
+  ulong			tSCR0;					/* CLP = 0 */
+  ulong			tSCR;					/* CLP = 0+1 */
+  ulong			tolSCR;					/* tolerance for SCR in us */
+
+  uchar			atmServiceType;			/* CBR, VBR, UBR, etc. */
+  uchar			trafficFlags;
+} atmTrafficParams;
+
+/* ATM Broadband Bearer Capabilty (BBC) types (as encoded at UNI) */
+
+#define	kAtmBBCIE			0x5E
+
+#define	kBBCClassShift		0
+#define	kBBCClassMask		0x1F
+
+#define	kBBCClassA			0x1
+#define	kBBCClassC			0x3
+#define	kBBCClassX			0x10
+
+
+#define	kBBCTrafficShift	(kBBCClassShift + 5)
+#define	kBBCTrafficMask		0x7
+
+#define	kBBCTrafficNull		0
+#define	kBBCTrafficCBR		1
+#define	kBBCTrafficVBR		2
+
+
+#define	kBBCTimingShift		(kBBCTrafficShift + 3)
+#define	kBBCTimingMask		0x3
+
+#define	kBBCTimingNull			0
+#define	kBBCTimingRequired		1
+#define	kBBCTimingNotRequired	2
+
+
+#define	kBBCClippingShift	(kBBCTimingShift + 2)
+#define	kBBCClippingMask	0x3
+
+#define	kBBCNoClipping		0
+#define	kBBCClippingOk		1
+
+#define	kBBCConnectionShift	(kBBCClippingShift + 2)
+#define	kBBCConnectionMask	0x3
+
+#define	kBBCPoint2Point		0
+#define	kBBCPoint2MPoint	1
+
+/* ATM Broadband High/Low Layer Information (BHLI/BLLI) types (as encoded at UNI) */
+
+#define	kAtmBHLIIE			0x5D
+#define	kAtmBLLIIE			0x5F
+
+/* ATM QoS types (as encoded at UNI) */
+
+#define	kAtmQoSIE			0x5C
+
+#define	kQoSNull			0
+#define	kQoSClass1			1
+#define	kQoSClass2			2
+#define	kQoSClass3			3
+#define	kQoSClass4			4
+#define	kQoSReserved		0xFF
+
+typedef struct {
+  uchar				fwdQoSClass;
+  uchar				backQoSClass;
+} atmQoSParams;
+
+/* ATM MID definitions (ConfigureHandler) */
+
+#define	kAtmMidEntireVc		((ulong) -1)
+
+typedef struct {
+  void				*pUserVc;			/* VC id from the caller: has to be 1st !!! */
+  ulong				vci;
+  uchar				defaultCLP;			/* default CLP for tx packets on this VC */
+  uchar				framerId;
+  uchar				protoId;
+  uchar				protoRxBytesReserved; /* # bytes reserved by protocol in the beginning of Rx packet */
+  uchar				protoTxBytesReserved; /* # bytes reserved by protocol in the beginning of Tx packet */
+
+  atmAalParams		aalParams;
+  atmTrafficParams	rxTrafficParams;
+  atmTrafficParams	txTrafficParams;
+  bitMap			bbcFlags;
+  atmQoSParams		qosParams;
+} atmVcParams;
+
+/*
+**
+**		ATM Out of Band (OOB) packet information
+**
+*/
+
+typedef struct {
+  Boolean			clp;				/* Cell Loss Prioroty */
+  uchar				aalType;
+  union {
+	struct {
+	  uchar			payloadType;
+	} aalRawParams;
+	struct {
+	  uchar			payloadType;
+	  ushort		mid;
+	} aal34Params;
+	struct {
+	  uchar			uui;				/* Uses to user indicator */
+	  uchar			cpi;				/* common part indicator */
+	} aal5Params;
+  } aalParam;
+} atmOobPacketInfo;
+
+/*
+**
+**		ATM setup bit definition
+**
+*/
+
+#define	kAtmCorrectHecErrors		1
+#define	kCorrectHecErrors			kAtmCorrectHecErrors
+#define	kAtmPhyHeaderCompression	2
+#define	kAtmPhyNoDataScrambling		4
+
+#define	kAtmTxIdleTimeoutMask	0x6
+#define	kAtmTxIdleNoTimeout		0
+#define	kAtmTxIdleTimeout10s	2
+#define	kAtmTxIdleTimeout30s	4
+#define	kAtmTxIdleTimeout60s	6
+
+/*
+**
+**		ATM framer modes and protocol definitions
+**
+*/
+
+#define	kAtmFramerNone			0
+#define	kAtmFramerISO			1
+#define	kAtmFramerIP			2
+#define	kAtmFramerEth			3
+#define	kAtmFramerEthWithCRC	4
+
+#define	kAtmProtoNone			0
+#define	kAtmProtoEClip			1
+#define kAtmProtoERouted1483	2
+#define	kAtmProtoPPP			3
+
+
+/*
+**
+**		ATM status codes
+**
+*/
+
+typedef	void (*atmStatusHandler) (void *gDslVars, ulong statusCode, ...);
+
+/* physical layer I.432 */
+
+#define	kAtmStatRxHunt					1
+#define	kAtmStatRxPreSync				2
+#define	kAtmStatRxSync					3
+#define	kAtmStatRxPlOamCell				4
+#define	kAtmStatBertResult				5
+#define	kAtmStatHec						6
+#define	kAtmStatHdrCompr				7
+#define	kAtmStatCounters				8
+
+/* ATM layer */
+
+#define	kAtmLayerStatFirst				100
+#define	kAtmStatRxDiscarded				100
+#define	kAtmStatTxDelayed				101
+
+#define	kAtmStatVcCreated				102
+#define	kAtmStatVcStarted				103
+#define	kAtmStatVcStopped				104
+#define	kAtmStatVcDeleted				105
+
+#define	kAtmStatTimeout					106
+#define	kAtmStatNoCellMemory			107
+#define	kAtmStatPrintCell				108
+#define kAtmStatInvalidCell				109
+#define kAtmStatUnassignedCell			110
+#define kAtmStatOamF4SegmentCell		111
+#define kAtmStatOamF4End2EndCell		112
+#define kAtmStatOamI371Cell				113
+#define kAtmStatOamF5SegmentCell		114
+#define kAtmStatOamF5End2EndCell		115
+#define kAtmStatReservedCell			116
+
+#define	kAtmStatConnected				117
+#define	kAtmStatDisconnected			118
+
+#define	kAtmStatRxPacket				119
+#define	kAtmStatTxPacket				120
+
+#define	kAtmStatOamLoopback				121
+
+
+typedef struct _atmPhyCounters {
+	ushort						id;
+	ushort						bertStatus;
+	ulong						bertCellTotal;
+	ulong						bertCellCnt;
+	ulong						bertBitErrors;
+
+	ulong						rxHecCnt;
+	ulong						rxCellTotal;
+	ulong						rxCellData;
+	ulong						rxCellDrop;
+} atmPhyCounters;
+
+/* AAL layer */
+
+
+
+/*
+**
+**		ATM log file definitions
+**
+*/
+
+/* ATM log file flags */
+
+#define		kAtmLogFrameFlagMask		3		/* mask */
+
+#define		kAtmLogFrameFlagNone		0		/* nothing */
+#define		kAtmLogFrameFlagNoData		1		/* no data only frame size */
+#define		kAtmLogFrameFlagBinData		2		/* data in binary form */
+#define		kAtmLogFrameFlagTextData	3		/* data in text form */
+
+#define		kAtmLogSendFrameShift		0
+#define		kAtmLogSendFrameNoData		(kAtmLogFrameFlagNoData << kAtmLogSendFrameShift)
+#define		kAtmLogSendFrameBinData		(kAtmLogFrameFlagBinData << kAtmLogSendFrameShift)
+#define		kAtmLogSendFrameTextData	(kAtmLogFrameFlagTextData << kAtmLogSendFrameShift)
+
+#define		kAtmLogRcvFrameShift		2
+#define		kAtmLogRcvFrameNone			(kAtmLogFrameFlagNone << kAtmLogRcvFrameShift)
+#define		kAtmLogRcvFrameNoData		(kAtmLogFrameFlagNoData << kAtmLogRcvFrameShift)
+#define		kAtmLogRcvFrameBinData		(kAtmLogFrameFlagBinData << kAtmLogRcvFrameShift)
+#define		kAtmLogRcvFrameTextData		(kAtmLogFrameFlagTextData << kAtmLogRcvFrameShift)		
+
+#define		kAtmLogSendCompleteFrameShift	4
+#define		kAtmLogSendCompleteFrameNone	(kAtmLogFrameFlagNone << kAtmLogSendCompleteFrameShift)
+#define		kAtmLogSendCompleteFrameNoData	(kAtmLogFrameFlagNoData << kAtmLogSendCompleteFrameShift)
+
+#define		kAtmLogReturnFrameShift		6
+#define		kAtmLogReturnFrameNoData	(kAtmLogFrameFlagNoData << kAtmLogReturnFrameShift)
+
+#define		kAtmLogCellFlag				(1 << 8)
+
+/* ATM log codes */
+
+#define		kAtmLogSendFrame					1
+#define		kAtmLogRcvFrame						2
+#define		kAtmLogSendFrameComplete			3
+#define		kAtmLogReturnFrame					4
+#define		kAtmLogVcAllocate					5
+#define		kAtmLogVcFree						6
+#define		kAtmLogVcActivate					7
+#define		kAtmLogVcDeactivate					8
+#define		kAtmLogTimer						9
+#define		kAtmLogCell							10
+#define		kAtmLogVcConfigure					11
+
+#define		kAtmLogRxCellHeader					12
+#define		kAtmLogRxCellData					13
+#define		kAtmLogTxCell						14
+
+#endif	/* SoftAtmVcHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,675 @@
+/****************************************************************************
+ *
+ * SoftDsl.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for the DSL
+ *	global variable structure.
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.72 $
+ *
+ * $Id: SoftDsl.gh,v 1.72 2004/04/30 23:05:19 kdu Exp $
+ *
+ * $Log: SoftDsl.gh,v $
+ * Revision 1.72  2004/04/30 23:05:19  kdu
+ * Fixed interop issues in TDC lab for TMM.
+ *
+ * Revision 1.70  2004/04/10 23:30:48  ilyas
+ * Defined gloval structure for slow (SDRAM) data
+ *
+ * Revision 1.69  2004/04/02 18:33:45  gsyu
+ * Share MuxFramer buffers with scratch memory
+ *
+ * Revision 1.68  2004/02/04 20:12:38  linyin
+ * Support adsl2plus
+ *
+ * Revision 1.67  2004/02/03 19:10:37  gsyu
+ * Added separated carrierInfo structures for G992P5
+ *
+ * Revision 1.66  2004/01/26 04:21:06  yongbing
+ * Merge changes in ADSL2 branch into Annex A branch
+ *
+ * Revision 1.65  2004/01/13 19:12:07  gsyu
+ * Added two more variables for Double upstream
+ *
+ * Revision 1.64  2003/12/04 02:10:37  linyin
+ * Add a variable for FbmsOL mode
+ *
+ * Revision 1.63  2003/11/20 00:57:50  yongbing
+ * Merge ADSL2 functionalities into Annex A branch
+ *
+ * Revision 1.62  2003/11/05 01:59:12  liang
+ * Add vendor ID code for Infineon.
+ *
+ * Revision 1.61  2003/08/12 22:59:41  khp
+ * - for Haixiang: added support for ADSL_MARGIN_TWEAK_TEST
+ *
+ * Revision 1.60  2003/08/01 00:08:19  liang
+ * Added firmware ID for Samsung ADI 930 DSLAM.
+ *
+ * Revision 1.59  2003/07/14 14:40:08  khp
+ * - AnnexB: added bad SNR2 retrain counter to connectin setup
+ *
+ * Revision 1.58  2003/06/25 02:40:22  liang
+ * Added firmware ID for Annex A UE9000 ADI918 (from Aliant, Canada).
+ *
+ * Revision 1.57  2003/06/25 00:00:40  ilyas
+ * -added firmware IDs for TI 4000C and AC5 (Annex B)
+ *
+ * Revision 1.56  2003/05/31 01:50:38  khp
+ * -add firmware IDs for ECI16 and ECI16A
+ *
+ * Revision 1.55  2003/03/27 19:30:52  liang
+ * Add and initialize new connectionSetup field coVendorFirmwareID under module ADSL_IDENTIFY_VENDOR_FIRMWARE.
+ *
+ * Revision 1.54  2002/12/13 18:35:48  yongbing
+ * Add support for G.992.2 Annex C in start up
+ *
+ * Revision 1.53  2002/12/06 02:06:33  liang
+ * Moved the T1.413 RAck1/RAck2 switching variables to connection setup structure.
+ *
+ * Revision 1.52  2002/11/26 02:49:46  liang
+ * Added variable codingGainDecrement to the connectionSetup structure to solve the C-Rates-RA option failure problem.
+ *
+ * Revision 1.51  2002/10/20 18:56:16  khp
+ * - for linyin:
+ *   - #ifdef NEC_NSIF_WORKAROUND:
+ *     - add status and fail counter for NSIF
+ *
+ * Revision 1.50  2002/09/28 02:36:50  yongbing
+ * Add retrain in T1.413 with R-Ack1 tone
+ *
+ * Revision 1.49  2002/09/12 21:07:19  ilyas
+ * Added HEC, OCD and LCD counters
+ *
+ * Revision 1.48  2002/07/19 01:51:35  liang
+ * Added vendor ID constant for Alcatel.
+ *
+ * Revision 1.47  2002/06/27 21:51:08  liang
+ * Added xmt and rcv tone selection bitmap in connection setup.
+ *
+ * Revision 1.46  2002/06/11 20:48:06  liang
+ * Added CO vendor ID field to connectionSetup structure.
+ *
+ * Revision 1.45  2002/06/06 03:05:43  khp
+ * -use boolean in connectup setup instead of localCapabilities.features to indicate FBM mode
+ *
+ * Revision 1.44  2002/03/22 19:38:58  yongbing
+ * Modify for co-exist of G994P1 and T1P413
+ *
+ * Revision 1.43  2002/03/02 00:52:40  ilyas
+ * AnnexC delay needs to be long for prototype
+ *
+ * Revision 1.42  2002/01/19 23:59:17  ilyas
+ * Added support for LOG and eye data to ADSL core target
+ *
+ * Revision 1.41  2002/01/16 19:03:59  ilyas
+ * Added HOST_ONLY ifdefs around ADSL core data
+ *
+ * Revision 1.40  2002/01/14 17:41:04  liang
+ * Move xmt & rcv sample buffers to top level.
+ *
+ * Revision 1.39  2001/12/21 22:45:34  ilyas
+ * Added support for ADSL MIB data object
+ *
+ * Revision 1.38  2001/12/13 02:24:22  ilyas
+ * Added G997 (Clear EOC and G997 framer) support
+ *
+ * Revision 1.37  2001/11/30 05:56:31  liang
+ * Merged top of the branch AnnexBDevelopment onto top of the tree.
+ *
+ * Revision 1.36  2001/10/19 00:12:07  ilyas
+ * Added support for frame oriented (no ATM) data link layer
+ *
+ * Revision 1.29.2.5  2001/10/03 01:44:00  liang
+ * Merged with codes from main tree (tag SoftDsl_2_18).
+ *
+ * Revision 1.29.2.4  2001/08/18 00:00:36  georgep
+ * Add variable to store annexC pathDelay
+ *
+ * Revision 1.29.2.3  2001/08/08 17:33:27  yongbing
+ * Merge with tag SoftDsl_2_17
+ *
+ * Revision 1.35  2001/08/29 02:56:01  ilyas
+ * Added tests for flattening/unflatenning command and statuses (dual mode)
+ *
+ * Revision 1.34  2001/08/28 03:26:32  ilyas
+ * Added support for running host and adsl core parts separately ("dual" mode)
+ *
+ * Revision 1.33  2001/06/18 19:49:36  ilyas
+ * Changes to include support for HOST_ONLY mode
+ *
+ * Revision 1.32  2001/05/18 21:21:44  liang
+ * Save the current number of rcv samples to line handler for QProc test.
+ *
+ * Revision 1.31  2001/04/25 01:20:11  ilyas
+ *
+ * Don't use DSL frame functions if ATM_LAYER is not defined
+ *
+ * Revision 1.30  2001/03/25 06:11:20  liang
+ * Combined separate loop attenuation status for ATUR & ATUC into one status.
+ * Replace separate hardware AGC info status for ATUR & ATUC into hardware AGC
+ * request status and hardware AGC obtained status.
+ * Use store AGC command to save hardware AGC value instead of returning value
+ * from status report.
+ *
+ * Revision 1.29  2001/03/17 03:00:46  georgep
+ * Added agcInfo to connectionSetupStruct
+ *
+ * Revision 1.28  2001/02/10 03:03:09  ilyas
+ * Added one more DslFrame function
+ *
+ * Revision 1.27  2000/08/31 19:04:24  liang
+ * Added scratch buffer structure definition.
+ *
+ * Revision 1.26  2000/07/23 20:52:52  ilyas
+ * Added xxxFrameBufSetAddress() function for ATM framer layers
+ * Rearranged linkLayer functions in one structure which is passed as a
+ * parameter to xxxLinkLayerInit() function to be set there
+ *
+ * Revision 1.25  2000/07/18 21:42:25  ilyas
+ * Fixed compiler warning about pointer casting
+ *
+ * Revision 1.24  2000/07/18 21:18:45  ilyas
+ * Added GLOBAL_PTR_BIAS feature to utilize full 64K MIPS relative addressing space
+ *
+ * Revision 1.23  2000/07/18 20:03:24  ilyas
+ * Changed DslFrame functions definitions to macros,
+ * Removed gDslVars from their parameter list
+ *
+ * Revision 1.22  2000/07/17 21:08:15  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.21  2000/05/09 23:00:26  ilyas
+ * Added ATM status messages, ATM timer, Tx frames flush on timeout
+ * Fixed a bug - adding flushed Tx frames to the list of free Rx frames
+ *
+ * Revision 1.20  2000/05/03 03:57:04  ilyas
+ * Added LOG file support for writing ATM data
+ *
+ * Revision 1.19  2000/04/19 00:31:47  ilyas
+ * Added global SoftDsl functions for Vc, added OOB info functions
+ *
+ * Revision 1.18  2000/04/13 08:36:22  yura
+ * Added SoftDslSetRefData, SoftDslGetRefData functions
+ *
+ * Revision 1.17  2000/04/13 05:38:54  georgep
+ * Added T1p413 "Activation and Acknowledgement" which can substitute G994P1
+ *
+ * Revision 1.16  2000/04/05 22:30:42  liang
+ * Changed function & constant names from G992p2 to G992 for the Main module.
+ *
+ * Revision 1.15  2000/04/04 04:16:06  liang
+ * Merged with SoftDsl_0_03 from old tree.
+ *
+ * Revision 1.15  2000/04/04 01:47:21  ilyas
+ * Implemented abstract dslFrame and dslFrameBuffer objects
+ *
+ * Revision 1.14  2000/04/01 02:53:33  georgep
+ * Added pointer to G992p2Profile inside connectionSetup
+ *
+ * Revision 1.13  2000/03/18 01:27:56  georgep
+ * Changed connectionSetup to include G992p1 Capabilities
+ *
+ * Revision 1.12  2000/02/29 01:39:05  georgep
+ * put variable haveRemoteCapabilities inside connectionSetupStruct
+ *
+ * Revision 1.11  2000/02/08 00:44:36  liang
+ * Fix the gDslVars definition for Irix environment.
+ *
+ * Revision 1.10  1999/11/19 00:59:29  george
+ * Define physicalLayerVars as a union
+ *
+ * Revision 1.9  1999/11/11 19:19:42  george
+ * Porting to 16Bit Compiler
+ *
+ * Revision 1.8  1999/11/09 20:26:17  george
+ * Added G992P2_PROFILE to modules list
+ *
+ * Revision 1.7  1999/10/27 23:01:54  wan
+ * Add G.994.1 setup in dslConnectionSetupStruct for setting up Initiation side
+ *
+ * Revision 1.6  1999/08/12 21:16:27  george
+ * Move profileVars definition to G992p2/G992p2Profile.gh
+ *
+ * Revision 1.5  1999/08/10 18:20:43  george
+ * Define fastRetrainVars
+ *
+ * Revision 1.4  1999/07/16 02:03:02  liang
+ * Added Tx & Rx data handler function pointers.
+ *
+ * Revision 1.3  1999/07/03 01:40:15  liang
+ * Redefined dsl command parameter list and added connection setup struct.
+ *
+ * Revision 1.2  1999/02/10 01:56:37  liang
+ * Added hooks for G994.1 and G992.2.
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	SoftDslGlobals
+#define	SoftDslGlobals
+
+#include "SoftDsl.h"
+
+#ifdef G992P2_PROFILE
+#include "G992p2Profile.gh"
+#endif
+
+typedef enum
+	{
+	kVendorUnknown = 0,
+	kVendorBroadcom,
+	kVendorGlobespan,
+	kVendorADI,
+	kVendorTI,
+	kVendorCentillium,
+	kVendorAlcatel,
+	kVendorInfineon
+	} VendorIDType;
+
+#define	kDslVendorFirwareUnknown	0
+typedef	enum
+	{
+	kVendorADI_Anaconda = 1,
+	kVendorADI_ECI918,
+	kVendorADI_ECI930,
+	kVendorADI_Cisco,
+	kVendorADI_UE9000_918,
+	kVendorADI_Samsung_930,
+	kVendorTI_4000C_ERICSSON_350,
+	kVendorTI_4000C_SEIMENS,
+	kVendorADI_ECI16_AnnexB = 50,		/* leave space for more Annex A types */
+	kVendorADI_ECI16A_AnnexB,
+	kVendorTI_4000C_AnnexB,
+	kVendorTI_AC5_AnnexB
+	} VendorFirmwareIDType;
+
+#define	kDslXmtToneSelectionStartTone		0
+#ifdef G992P1_ANNEX_B
+#define	kDslXmtToneSelectionEndTone			63
+#else
+#define	kDslXmtToneSelectionEndTone			31
+#endif
+#define	kDslXmtToneSelectionNumOfTones		(kDslXmtToneSelectionEndTone-kDslXmtToneSelectionStartTone+1)
+#define	kDslXmtToneSelectionNumOfBytes		((kDslXmtToneSelectionNumOfTones+7)/8)
+#define	kDslRcvToneSelectionStartTone		32
+#define	kDslRcvToneSelectionEndTone			255
+#define	kDslRcvToneSelectionNumOfTones		(kDslRcvToneSelectionEndTone-kDslRcvToneSelectionStartTone+1)
+#define	kDslRcvToneSelectionNumOfBytes		((kDslRcvToneSelectionNumOfTones+7)/8)
+
+#define	kDslT1p413RAckModeTryRAck1				0x01
+#define	kDslT1p413RAckModeTryRAck2				0x02
+#define	kDslT1p413RAckModeTrialMask				0x0F
+#define	kDslT1p413RAckModeSelected				0x10
+#define	kDslT1p413RAckModeTrialCount			10		/* when in trial mode */
+#define	kDslT1p413RAckModeSwitchCount			20		/* when mode is selected */
+
+#ifdef ADSL_MARGIN_TWEAK_TEST
+#define	kDslMarginTweakNumOfTones				256
+#endif
+
+typedef struct
+	{
+	Boolean	                        haveRemoteCapabilities;		
+	dslModulationType				selectedModulation;
+	dslModulationType				startupModulation;
+#if defined(G992P1_ANNEX_I) || defined(G992P5)
+	ushort							downstreamMinCarr, downstreamMaxCarr;
+#else
+	uchar							downstreamMinCarr, downstreamMaxCarr;
+#endif
+	uchar							upstreamMinCarr, upstreamMaxCarr;
+#if defined(DOUBLE_UP_STREAM)							
+    Boolean                         isDoubleUsEnabled;
+    short                           selectedPilotTone;
+#endif
+	dslDataPumpCapabilities			localCapabilities, remoteCapabilities;
+#ifdef G992P3
+	g992p3DataPumpCapabilities		localCarrierInfoG992p3AnnexA;
+	g992p3DataPumpCapabilities		remoteCarrierInfoG992p3AnnexA;
+	g992p3DataPumpCapabilities		selectedCarrierInfoG992p3AnnexA;
+	uchar							xmtG992p3State;
+#ifdef G992P5
+	g992p3DataPumpCapabilities		localCarrierInfoG992p5AnnexA;
+	g992p3DataPumpCapabilities		remoteCarrierInfoG992p5AnnexA;
+	g992p3DataPumpCapabilities		selectedCarrierInfoG992p5AnnexA;
+#endif  /* G992P5 */
+#endif  /* G992P3 */
+	uchar							handshakingDuplexMode;
+	Boolean							handshakingClientInitiation;
+	short							handshakingXmtPowerLevel;
+	uchar							handshakingXmtCarrierSet;
+	short							hwAgcQ4dB;	/* for loop attenuation calculation */
+	uchar							coVendorID;
+#ifdef	ADSL_IDENTIFY_VENDOR_FIRMWARE
+	uchar							coVendorFirmwareID;
+#endif
+	uchar							codingGainDecrement;	/* coding gain decrement in Q4dB for initial rate calculation */
+	uchar							xmtToneSelection[kDslXmtToneSelectionNumOfBytes];
+	uchar							rcvToneSelection[kDslRcvToneSelectionNumOfBytes];
+#ifdef G992_ANNEXC	
+	Boolean							isFbmMode;
+	Boolean							isFbmsOLMode;
+	long							xmtToRcvPathDelay;
+#endif	
+#if defined(T1P413) && defined(XMT_RACT2_FOR_ADI_COMPATIBILITY)
+	uchar							t1p413RAckModeUsed;
+	uchar							t1p413RAckModeCounter;
+#endif
+#ifdef G992P1_ANNEX_B
+	uchar							badSNR2RetrainCounter;
+#endif
+#ifdef ADSL_MARGIN_TWEAK_TEST
+	short							marginTweakExtraPowerQ4dB;
+	char							marginTweakTableQ4dB[kDslMarginTweakNumOfTones];
+#endif
+#ifdef G992P2_PROFILE	
+	G992p2ProfileVarsStruct*		profileVarsPtr;
+#endif
+#ifdef TDC_IOP_FIX_SEIMENS_TI
+	char					t1p413RetrainCounter;		/* 0: no retrain needed; 1: force to T1.413 mode and retrain after R-MSG1; 2: 2nd T1.413 session, go to showtime */
+#endif
+#ifdef ANSI_CACT12_PING_PONG
+    char t1p413SkipToneIndex; /* to alternate between CAct1 and CAct2 detection */
+#endif
+	} dslConnectionSetupStruct;
+
+#ifdef ADSL_FRAMER
+#include "MuxFramer.gh"
+#endif
+
+#ifdef ATM
+#include "SoftAtm.gh"
+#endif
+
+#ifdef DSL_PACKET
+#include "DslPacket.gh"
+#endif
+
+#ifdef G997_1_FRAMER
+#include "G997.gh"
+#ifdef G992P3
+#include "G992p3OvhMsg.gh"
+#endif
+#endif
+
+#ifdef ADSL_MIB
+#include "AdslMib.gh"
+#endif
+
+#ifndef HOST_ONLY
+#ifdef T1P413
+#include "T1p413Main.gh"
+#endif
+
+#ifdef G994P1
+#include "G994p1Main.gh"
+#endif
+
+#ifdef G992
+#include "G992Main.gh"
+#endif
+
+#include "SoftDslSampleBuffers.gh"
+#endif
+
+typedef struct __dslSlowVarsStruct
+	{
+	int								tmp;
+	}
+	 dslSlowVarsStruct;
+
+typedef struct __dslVarsStruct
+	{
+	bitMap							setup;
+	eyeHandlerType					eyeHandlerPtr;
+	logHandlerType					logHandlerPtr;
+	dslDriverCallbackType			driverCallback;
+
+	rcvHandlerType					rcvHandlerPtr;
+	xmtHandlerType					xmtHandlerPtr;
+
+#ifndef ADSLCORE_ONLY
+	dslCommandHandlerType			adslCoreCommandHandlerPtr;
+#endif
+	dslCommandHandlerType			dataPumpCommandHandlerPtr;
+
+	dslStatusHandlerType			internalStatusHandlerPtr;
+	dslStatusHandlerType			externalStatusHandlerPtr;
+#ifndef ADSLCORE_ONLY
+	dslStatusHandlerType			externalLinkLayerStatusHandlerPtr;
+#endif
+
+	dslDirectionType				direction;
+	dslConnectionSetupStruct		connectionSetup;
+
+#ifdef NEC_NSIF_WORKAROUND
+	uchar 					G994NsStatus;
+	uchar 					G994NsFailCounter;
+#endif
+
+	dslFrameHandlerType				rxIndicateHandlerPtr;
+	dslFrameHandlerType				txCompleteHandlerPtr;
+
+	linkLayerFunctions				LinkLayerFunctions;
+	dslSlowVarsStruct				*dslSlowVars;
+
+#ifdef DSL_FRAME_FUNCTIONS
+	dslFrameFunctions				DslFrameFunctions;
+#endif
+	ulong							refData;
+	ulong							execTime;
+	int								currRcvNSamps;
+
+#ifndef HOST_ONLY
+	DslSampleBuffersStruct			sampleBuffersVars;
+
+#ifdef G992P2_PROFILE
+	G992p2ProfileVarsStruct			G992p2ProfileVars;
+#endif
+			
+#ifdef ADSL_FRAMER
+	muxFramerVarsStruct				muxFramerVars;
+#endif
+#endif /* HOST_ONLY */
+
+#ifdef DSL_LINKLAYER
+	union
+		{
+#ifdef ATM
+		atmVarsStruct				atmVars;
+#endif
+#ifdef DSL_PACKET
+		dslPacketVarsStruct			dslPacketVars;
+#endif
+		} linkLayerVars;
+#endif
+
+#ifdef G997_1_FRAMER
+	g997VarsStruct					G997Vars;
+#ifdef G992P3
+	g992p3OvhMsgVarsStruct			G992p3OvhMsgVars;
+#endif
+#endif
+
+#ifdef ADSL_MIB
+	adslMibVarsStruct				adslMibVars;
+#endif
+
+#ifndef HOST_ONLY
+	union
+		{
+#ifdef T1P413
+ 		T1p413VarsStruct			T1p413Vars; 		
+#endif		
+#ifdef G994P1
+		G994p1VarsStruct			G994p1Vars;			
+#endif
+#ifdef G992
+		G992VarsStruct				G992Vars;
+#endif
+		} physicalLayerVars;
+	union
+		{
+#ifdef G992
+		G992ScratchVarsStruct		G992ScratchVars;
+#endif
+#if defined(ADSL_FRAMER) && defined(SHARE_MUX_FRAMER_VARS)
+        muxFramerSharedVarsStruct	muxFramerSharedVars;
+#endif
+		} scratchVars;
+#endif /* HOST_ONLY */
+
+	}
+	 dslVarsStruct;
+
+#ifndef GLOBAL_PTR_BIAS
+#define	gDslGlobalVarPtr			((struct __dslVarsStruct *)gDslVars)
+#define	gDslGlobalSlowVarPtr		(gDslGlobalVarPtr->dslSlowVars)
+#else
+#define	gDslGlobalVarPtr			((struct __dslVarsStruct *) (void*)((uchar*)(gDslVars) - GLOBAL_PTR_BIAS))
+#define	gDslGlobalSlowVarPtr		((struct __dslSlowVarsStruct *) (void*)((uchar*)(gDslGlobalVarPtr->dslSlowVars) - GLOBAL_PTR_BIAS))
+#endif
+
+#define	gDslSampleBuffersVars		(gDslGlobalVarPtr->sampleBuffersVars)
+
+#define	gDslMuxFramerVars			(gDslGlobalVarPtr->muxFramerVars)
+#define	gDslMuxFramerSharedVars		(gDslGlobalVarPtr->scratchVars.muxFramerSharedVars)
+#define	gDslLinkLayerVars			(gDslGlobalVarPtr->linkLayerVars)
+#define	gDslAtmVars					(gDslGlobalVarPtr->linkLayerVars.atmVars)
+#define	gDslPacketVars				(gDslGlobalVarPtr->linkLayerVars.dslPacketVars)
+#define	gG997Vars					(gDslGlobalVarPtr->G997Vars)
+
+#ifdef G992P3
+#define	gG992p3OvhMsgVars			(gDslGlobalVarPtr->G992p3OvhMsgVars)
+#endif
+
+#define	gAdslMibVars				(gDslGlobalVarPtr->adslMibVars)
+
+#define	gT1p413Vars					(gDslGlobalVarPtr->physicalLayerVars.T1p413Vars)
+#define	gG994p1Vars					(gDslGlobalVarPtr->physicalLayerVars.G994p1Vars)
+#define	gG992Vars					(gDslGlobalVarPtr->physicalLayerVars.G992Vars)
+#define gG992p2ProfileVars			(gDslGlobalVarPtr->G992p2ProfileVars)
+
+#define	gG992ScratchVars			(gDslGlobalVarPtr->scratchVars.G992ScratchVars)
+
+#ifndef gEyeHandlerPtr
+#define	gEyeHandlerPtr				(gDslGlobalVarPtr->eyeHandlerPtr)
+#endif
+
+#ifndef gLogHandlerPtr
+#define	gLogHandlerPtr				(gDslGlobalVarPtr->logHandlerPtr)
+#endif
+
+#ifdef VP_SIMULATOR
+#define	gDriverCallback(x)			(gDslGlobalVarPtr->driverCallback)(x)
+#else
+#define	gDriverCallback(x)
+#endif
+
+/*
+**
+**		Frame functions callouts
+**
+*/
+
+#define	gDslFrameFunc				(gDslGlobalVarPtr->DslFrameFunctions)
+
+#define	DslFrameBufferGetLength(gDslVars, fb) \
+	gDslFrameFunc.__DslFrameBufferGetLength(fb)
+
+#define DslFrameBufferGetAddress(gDslVars, fb) \
+	gDslFrameFunc.__DslFrameBufferGetAddress(fb)
+
+#define DslFrameBufferSetLength(gDslVars, fb, l) \
+	gDslFrameFunc.__DslFrameBufferSetLength(fb, l)
+
+#define DslFrameBufferSetAddress(gDslVars, fb, p) \
+	gDslFrameFunc.__DslFrameBufferSetAddress(fb, p)
+
+#define DslFrameInit(gDslVars, f) \
+	gDslFrameFunc.__DslFrameInit(f)
+
+#define DslFrameGetLength(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetLength(pFrame)
+
+#define DslFrameGetBufCnt(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetBufCnt(pFrame)
+
+#define DslFrameGetFirstBuffer(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetFirstBuffer(pFrame)
+
+#define DslFrameGetNextBuffer(gDslVars, pFrBuffer) \
+	gDslFrameFunc.__DslFrameGetNextBuffer(pFrBuffer)
+
+#define DslFrameSetNextBuffer(gDslVars, pFrBuf, pFrBufNext) \
+	gDslFrameFunc.__DslFrameSetNextBuffer(pFrBuf, pFrBufNext)
+
+#define DslFrameGetLastBuffer(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetLastBuffer(pFrame)
+
+#define DslFrameGetLinkFieldAddress(gDslVars, f) \
+	gDslFrameFunc.__DslFrameGetLinkFieldAddress(f)
+
+#define DslFrameGetFrameAddressFromLink(gDslVars, lnk) \
+	gDslFrameFunc.__DslFrameGetFrameAddressFromLink(lnk)
+
+
+#define DslFrameGetOobInfo(gDslVars, f, pOobInfo) \
+	gDslFrameFunc.__DslFrameGetOobInfo(f, pOobInfo)
+
+#define DslFrameSetOobInfo(gDslVars, f, pOobInfo) \
+	gDslFrameFunc.__DslFrameSetOobInfo(f, pOobInfo)
+
+
+#define DslFrameEnqueBufferAtBack(gDslVars, f, b) \
+	gDslFrameFunc.__DslFrameEnqueBufferAtBack(f, b)
+
+#define DslFrameEnqueFrameAtBack(gDslVars, fMain, f) \
+	gDslFrameFunc.__DslFrameEnqueFrameAtBack(fMain, f)
+
+#define DslFrameEnqueBufferAtFront(gDslVars, f, b) \
+	gDslFrameFunc.__DslFrameEnqueBufferAtFront(f, b)
+
+#define DslFrameEnqueFrameAtFront(gDslVars, fMain, f) \
+	gDslFrameFunc.__DslFrameEnqueFrameAtFront(fMain, f)
+
+#define DslFrameDequeBuffer(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameDequeBuffer(pFrame)
+
+#define DslFrameAllocMemForFrames(gDslVars, frameNum) \
+	gDslFrameFunc.__DslFrameAllocMemForFrames(frameNum)
+
+#define DslFrameFreeMemForFrames(gDslVars, hMem) \
+	gDslFrameFunc.__DslFrameFreeMemForFrames(hMem)
+
+#define DslFrameAllocFrame(gDslVars, handle) \
+	gDslFrameFunc.__DslFrameAllocFrame(handle)
+
+#define DslFrameFreeFrame(gDslVars, handle, pFrame) \
+	gDslFrameFunc.__DslFrameFreeFrame(handle, pFrame)
+
+#define DslFrameAllocMemForBuffers(gDslVars, ppMemPool, bufNum, memSize) \
+	gDslFrameFunc.__DslFrameAllocMemForBuffers(ppMemPool, bufNum, memSize)
+
+#define DslFrameFreeMemForBuffers(gDslVars, hMem, memSize, pMemPool) \
+	gDslFrameFunc.__DslFrameFreeMemForBuffers(hMem, memSize, pMemPool)
+
+#define DslFrameAllocBuffer(gDslVars, handle, pMem, length) \
+	gDslFrameFunc.__DslFrameAllocBuffer(handle, pMem, length)
+
+#define DslFrameFreeBuffer(gDslVars, handle, pBuf) \
+	gDslFrameFunc.__DslFrameFreeBuffer(handle, pBuf)
+
+#define DslFrame2Id(gDslVars, handle, pFrame) \
+	gDslFrameFunc.__DslFrame2Id(handle, pFrame)
+
+#define DslFrameId2Frame(gDslVars, handle, frameId) \
+	gDslFrameFunc.__DslFrameId2Frame (handle, frameId)
+
+
+#endif	/* SoftDslGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftDsl.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,2920 @@
+/****************************************************************************
+ *
+ * SoftDsl.h 
+ *
+ *
+ * Description:
+ *	This file contains the exported interface for SoftDsl.c
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.275 $
+ *
+ * $Id: SoftDsl.h,v 1.275 2005/04/28 22:55:36 ilyas Exp $
+ *
+ * $Log: SoftDsl.h,v $
+ * Revision 1.275  2005/04/28 22:55:36  ilyas
+ * Cleaned up kDslG992RunAnnexaP3ModeInAnnexaP5, kG992EnableAnnexM and kDslAtuChangeTxFilterRequest definitions
+ *
+ * Revision 1.274  2005/04/27 20:57:32  yongbing
+ * Implement 32 frequency break points for TSSI, PR 30211
+ *
+ * Revision 1.273  2005/04/02 03:27:52  kdu
+ * PR30236: Define kDslEnableRoundUpDSLoopAttn, this is shared with kDslCentilliumCRCWorkAroundEnabled.
+ *
+ * Revision 1.272  2005/04/01 21:56:39  ilyas
+ * Added more test commands definitions
+ *
+ * Revision 1.271  2005/02/11 05:03:57  ilyas
+ * Added support for DslOs
+ *
+ * Revision 1.270  2005/02/11 03:33:22  lke
+ * Support 2X, 4X, and 8X spectrum in ANNEX_I DS
+ *
+ * Revision 1.269  2005/01/08 00:11:58  ilyas
+ * Added definition for AnnexL status
+ *
+ * Revision 1.268  2004/12/18 00:52:35  mprahlad
+ * Add Dig US Pwr cutback status
+ *
+ * Revision 1.267  2004/11/08 22:21:38  ytan
+ * init swap state after retrain
+ *
+ * Revision 1.266  2004/11/05 21:16:50  ilyas
+ * Added support for pwmSyncClock
+ *
+ * Revision 1.265  2004/10/28 20:05:17  gsyu
+ * Fixed compilation errors for simulation targets
+ *
+ * Revision 1.264  2004/10/23 00:16:35  nino
+ * Added kDslHardwareSetRcvAGC status to set absolute rcv agc gain.
+ *
+ * Revision 1.263  2004/10/22 21:21:06  ilyas
+ * Fixed bit definition overlap in demodCapabilities
+ *
+ * Revision 1.262  2004/10/20 00:43:20  gsyu
+ * Added constants to support new xmt sample buffer control scheme
+ *
+ * Revision 1.261  2004/10/12 01:09:28  nino
+ * Remove kDslHardwareEnablePwmSyncClk and kDslHardwareSetPwmSyncClkFreq
+ * status definitions. Add kDslEnablePwmSyncClk and kDslSetPwmSyncClkFreq
+ * command definitions.
+ *
+ * Revision 1.260  2004/10/11 20:21:26  nino
+ * Added kDslHardwareEnablePwmSyncClk and kDslHardwareSetPwmSynClkFreq hardware statuses.
+ *
+ * Revision 1.259  2004/10/07 19:17:29  nino
+ * Added kDslHardwareGetRcvAGC status.
+ *
+ * Revision 1.258  2004/10/02 00:17:14  nino
+ * Added kDslHardwareAGCSetPga2 and kDslSetPilotEyeDisplay status definitions.
+ *
+ * Revision 1.257  2004/08/27 01:00:30  mprahlad
+ *
+ * Keep kDslAtuChangeTxFilterRequest defined by default so ADSL1 only targets can
+ * build
+ *
+ * Revision 1.256  2004/08/20 19:00:34  ilyas
+ * Added power management code for 2+
+ *
+ * Revision 1.255  2004/08/17 23:18:25  kdu
+ * Merged interop changes for TDC lab from a023e9.
+ *
+ * Revision 1.254  2004/07/22 00:56:03  yongbing
+ * Add ADSL2 Annex B modulation definition
+ *
+ * Revision 1.253  2004/07/16 22:23:28  nino
+ * - Defined macros to extract subcarrier and supported set information
+ *   for tssi. Subcarrier and suported set indicator is packed into
+ *   dsSubcarrier index array.
+ *
+ * Revision 1.252  2004/07/01 00:11:22  nino
+ * Added preliminary code for debugDataHandler (inside of #if DEBUG_DATA_HANDLER).
+ *
+ * Revision 1.251  2004/06/24 03:08:39  ilyas
+ * Added GFC mapping control for ATM bonding
+ *
+ * Revision 1.250  2004/06/23 00:03:20  khp
+ * - shorten self test result register length to 1 (satisfied requirement
+ *   at DT, no known requirement anywhere else)
+ *
+ * Revision 1.249  2004/06/15 20:18:33  ilyas
+ * Made D uchar again for compatibility with older ADSl drivers that use this structure. ADSL driver will rely on G992p3 parameters for large D
+ *
+ * Revision 1.248  2004/06/12 00:26:03  gsyu
+ * Added constants for AnnexM
+ *
+ * Revision 1.247  2004/06/10 18:53:24  yjchen
+ * add large D support
+ *
+ * Revision 1.246  2004/06/04 01:55:00  linyin
+ * Add a constant for SRA enable/disable
+ *
+ * Revision 1.245  2004/05/19 23:22:23  linyin
+ * Support L2
+ *
+ * Revision 1.244  2004/05/15 03:04:58  ilyas
+ * Added L3 test definition
+ *
+ * Revision 1.243  2004/05/14 03:04:38  ilyas
+ * Fixed structure name typo
+ *
+ * Revision 1.242  2004/05/14 02:01:01  ilyas
+ * Fixed structure name typo
+ *
+ * Revision 1.241  2004/05/14 01:21:49  nino
+ * Added kDslSignalAttenuation, kDslAttainableNetDataRate kDslHLinScale constant definitions.
+ *
+ * Revision 1.240  2004/05/13 19:07:58  ilyas
+ * Added new statuses for ADSL2
+ *
+ * Revision 1.239  2004/05/01 01:09:51  ilyas
+ * Added power management command and statuses
+ *
+ * Revision 1.238  2004/04/23 22:50:38  ilyas
+ * Implemented double buffering to ensure G.997 HDLC frame (OvhMsg) is continuous
+ *
+ * Revision 1.237  2004/03/31 18:57:39  ilyas
+ * Added drop on data error capability control
+ *
+ * Revision 1.236  2004/03/30 03:11:30  ilyas
+ * Added #ifdef for CFE build
+ *
+ * Revision 1.235  2004/03/29 23:06:39  ilyas
+ * Added status for BG table update
+ *
+ * Revision 1.234  2004/03/17 02:49:49  ilyas
+ * Turn off ATM bit reversal for Alcatel DSLAM only
+ *
+ * Revision 1.233  2004/03/11 03:09:48  mprahlad
+ * Add test mode for afeloopback test
+ *
+ * Revision 1.232  2004/03/10 23:15:53  ilyas
+ * Added ETSI modem support
+ *
+ * Revision 1.231  2004/03/04 19:28:14  linyin
+ * Support adsl2plus
+ *
+ * Revision 1.230  2004/02/28 00:06:21  ilyas
+ * Added OLR message definitions for ADSL2+
+ *
+ * Revision 1.229  2004/02/13 03:21:15  mprahlad
+ * define kDslAturHwAgcMaxGain correctly for 6348
+ *
+ * Revision 1.228  2004/02/09 05:06:17  yongbing
+ * Add ADSL2 bit swap function
+ *
+ * Revision 1.227  2004/02/04 02:08:19  linyin
+ * remove the redefined kG992p5AnnexA
+ *
+ * Revision 1.226  2004/02/04 01:41:48  linyin
+ * Add some variables for G992P5
+ *
+ * Revision 1.225  2004/02/03 19:12:22  gsyu
+ * Added a dedicate structure and constants for G992P5
+ *
+ * Revision 1.224  2004/01/24 01:18:34  ytan
+ * add multi-section swapping flag
+ *
+ * Revision 1.223  2004/01/17 00:21:48  ilyas
+ * Added commands and statuses for OLR
+ *
+ * Revision 1.222  2004/01/13 19:12:37  gsyu
+ * Added more constants for Double upstream
+ *
+ * Revision 1.221  2003/12/23 21:19:04  mprahlad
+ * Define BCM6348_TEMP_MOVE_TO_LMEM to FAST_TEXT for 6348 targets - this is for
+ * ADSL2/AnnexA multimode builds - move a few functions to Lmem for now to avoid
+ * changes for swap on 6348.
+ *
+ * Revision 1.220  2003/12/19 21:21:53  ilyas
+ * Added dying gasp support for ADSL2
+ *
+ * Revision 1.219  2003/12/05 02:09:51  mprahlad
+ * Leave the AnalogEC defs in - saves ifdef-ing all uses of these defines.
+ * Include Bcm6345_To_Bcm6348.h - to be able to pick up macros for the
+ * transition
+ *
+ * Revision 1.218  2003/12/04 02:10:58  linyin
+ * Redefine some constants for supporting different pilot and TTR
+ *
+ * Revision 1.217  2003/12/03 02:24:39  gsyu
+ * Reverse previous check in for Double Upstream demo
+ *
+ * Revision 1.215  2003/11/20 00:58:47  yongbing
+ * Merge ADSL2 functionalities into Annex A branch
+ *
+ * Revision 1.214  2003/11/06 00:35:06  nino
+ * Added kDslWriteAfeRegCmd and kDslReadAfeRegCmd commands.
+ *
+ * Revision 1.213  2003/11/05 21:04:23  ilyas
+ * Added more codes for LOG data
+ *
+ * Revision 1.212  2003/10/22 00:51:52  yjchen
+ * define constant for quiet line noise
+ *
+ * Revision 1.211  2003/10/20 22:08:57  nino
+ * Added kDslSetRcvGainCmd and kDslBypassRcvHpfCmd debug commands.
+ *
+ * Revision 1.210  2003/10/18 00:04:59  yjchen
+ * define constants for G992P3 diagnostic mode channel response
+ *
+ * Revision 1.209  2003/10/17 22:41:29  yongbing
+ * Add INP message support
+ *
+ * Revision 1.208  2003/10/16 00:06:09  uid1249
+ * Moved G.994 definitions from G.994p1MainTypes.h
+ *
+ * Revision 1.207  2003/10/15 20:45:11  linyin
+ * Add some constants for support Revision 2
+ *
+ * Revision 1.206  2003/10/14 22:04:02  ilyas
+ * Added Nino's AFE statuses for 6348
+ *
+ * Revision 1.205  2003/10/10 18:49:26  gsyu
+ * Added test modes to workaround the clock domain crossing bug, PR18038
+ *
+ * Revision 1.204  2003/09/30 19:27:46  mprahlad
+ * ifdef AnalogEC definies with #ifndef BCM6348_SRC
+ *
+ * Revision 1.203  2003/09/26 19:36:34  linyin
+ * Add annexi constant and vars
+ *
+ * Revision 1.202  2003/09/25 20:16:13  yjchen
+ * remove featureNTR definition
+ *
+ * Revision 1.201  2003/09/08 20:29:51  ilyas
+ * Added test commands for chip regression tests
+ *
+ * Revision 1.200  2003/08/26 00:58:14  ilyas
+ * Added I432 reset command (for header compression)
+ * Fixed SoftDsl time (for I432 header compression)
+ *
+ * Revision 1.199  2003/08/26 00:37:29  ilyas
+ * #ifdef'ed DslFrameFunctions in dslCommand structure to save space
+ *
+ * Revision 1.198  2003/08/22 22:45:00  liang
+ * Change the NF field in G992CodingParams from uchar to ushort to support K=256 (dataRate=255*32kbps) in fast path.
+ *
+ * Revision 1.197  2003/08/21 21:19:05  ilyas
+ * Changed dataPumpCapabilities structure for G992P3
+ *
+ * Revision 1.196  2003/08/12 22:44:28  khp
+ * - for Haixiang: added kDslTestMarginTweak command and marginTweakSpec
+ *
+ * Revision 1.195  2003/07/24 17:28:16  ovandewi
+ * added Tx filter change request code
+ *
+ * Revision 1.194  2003/07/24 15:48:55  yongbing
+ * Reduce TSSI buffer size to avoid crash at the beginning of G.994.1. Need to find out why
+ *
+ * Revision 1.193  2003/07/19 07:11:47  nino
+ * Revert back to version 1.191.
+ *
+ * Revision 1.191  2003/07/17 21:25:25  yongbing
+ * Add support for READSL2 and TSSI
+ *
+ * Revision 1.190  2003/07/14 19:42:33  yjchen
+ * add constants for G992P3
+ *
+ * Revision 1.189  2003/07/10 23:07:11  liang
+ * Add demodCapability bit to minimize showtime ATUC xmt power through b&g table.
+ *
+ * Revision 1.188  2003/07/08 22:18:50  liang
+ * Added demodCapability bit for G.994.1 Annex A multimode operation.
+ *
+ * Revision 1.187  2003/07/07 23:24:43  ilyas
+ * Added G.dmt.bis definitions
+ *
+ * Revision 1.186  2003/06/25 02:44:02  liang
+ * Added demod capability bit kDslUE9000ADI918FECFixEnabled.
+ * Added back kDslHWEnableAnalogECUpdate & kDslHWEnableAnalogEC for backward compatibility (annex A).
+ *
+ * Revision 1.185  2003/06/18 01:39:19  ilyas
+ * Added AFE test commands. Add #defines for driver's builds
+ *
+ * Revision 1.184  2003/06/06 23:58:09  ilyas
+ * Added command and status for standalone AFE tests
+ *
+ * Revision 1.183  2003/05/29 21:09:32  nino
+ * - kDslHWEnableAnalogECUpdate define replaced with kDslHWSetDigitalEcUpdateMode
+ * - kDslHWEnableAnalogEC       define replaced with kDslHWDisableDigitalECUpdate
+ *
+ * Revision 1.182  2003/04/15 22:08:15  liang
+ * Changed one of the demodCapability bit name from last checkin.
+ *
+ * Revision 1.181  2003/04/13 19:25:54  liang
+ * Added three more demodCapability bits.
+ *
+ * Revision 1.180  2003/04/02 02:09:17  liang
+ * Added demodCapability bit for ADI low rate option fix disable.
+ *
+ * Revision 1.179  2003/03/18 18:22:06  yongbing
+ * Use 32 tap TEQ for Annex I
+ *
+ * Revision 1.178  2003/03/06 00:58:07  ilyas
+ * Added SetStausBuffer command
+ *
+ * Revision 1.177  2003/02/25 00:46:26  ilyas
+ * Added T1.413 EOC vendor ID
+ *
+ * Revision 1.176  2003/02/21 23:30:54  ilyas
+ * Added Xmtgain command framing mode status and T1413VendorId parameters
+ *
+ * Revision 1.175  2003/02/07 22:13:55  liang
+ * Add demodCapabilities bits for sub-sample alignment and higher T1.413 level (used internally only).
+ *
+ * Revision 1.174  2003/01/23 02:54:07  liang
+ * Added demod capability bit for bitswap enable.
+ *
+ * Revision 1.173  2002/12/13 18:36:33  yongbing
+ * Add support for G.992.2 Annex C
+ *
+ * Revision 1.172  2002/12/10 23:27:12  ilyas
+ * Extended dslException parameter structure to allow printout from DslDiags
+ *
+ * Revision 1.171  2002/12/06 02:10:19  liang
+ * Moved the T1.413 RAck1/RAck2 switching variables to connection setup structure.
+ * Added/Modified the training progress codes for T1.413 RAck1/RAck2 and upstream 2x IFFT disable.
+ *
+ * Revision 1.170  2002/11/11 00:20:05  liang
+ * Add demod capability constant for internally disabling upstream 2x IFFT in T1.413 mode.
+ *
+ * Revision 1.169  2002/11/06 03:46:19  liang
+ * Add training progress code for upstream 2x IFFT disable.
+ *
+ * Revision 1.168  2002/11/01 01:41:06  ilyas
+ * Added flags for Centillium 4103 workarround
+ *
+ * Revision 1.167  2002/10/26 01:26:11  gsyu
+ * Move SoftDslLineHandler from SDRAM to LMEM
+ *
+ * Revision 1.166  2002/10/20 18:56:20  khp
+ * - for linyin
+ *   - #ifdef NEC_NSIF_WORKAROUND:
+ *     - add macros to extract NSIF status and fail counter vars
+ *
+ * Revision 1.165  2002/10/14 05:24:35  liang
+ * Add training status code to request alternate xmt filter (for Samsung 6-port ADI918 DSLAMs) to meet KT 2km spec.
+ *
+ * Revision 1.164  2002/10/08 21:44:50  ilyas
+ * Fixed EOC stuffing byte to indicate "no synchronization" action
+ *
+ * Revision 1.163  2002/10/03 19:34:24  ilyas
+ * Added size for EOC serial number register
+ *
+ * Revision 1.162  2002/09/28 02:42:27  yongbing
+ * Add retrain in T1.413 with R-Ack1 tone
+ *
+ * Revision 1.161  2002/09/28 01:23:35  gsyu
+ * Reverse us2xifft change so that we can install new us2xifft on the tree
+ *
+ * Revision 1.160  2002/09/26 23:30:48  yongbing
+ * Add synch symbol detection in Showtime
+ *
+ * Revision 1.159  2002/09/20 23:47:52  khp
+ * - for gsyu: enable 2X IFFT for Annex A (XMT_FFT_SIZE_2X)
+ *
+ * Revision 1.158  2002/09/14 03:26:39  ilyas
+ * Changed far-end RDI reporting
+ *
+ * Revision 1.157  2002/09/13 21:10:54  ilyas
+ * Added reporting of remote modem LOS and RDI.
+ * Moved G992CodingParams definition to SoftDsl.h
+ *
+ * Revision 1.156  2002/09/12 21:07:19  ilyas
+ * Added HEC, OCD and LCD counters
+ *
+ * Revision 1.155  2002/09/09 21:31:30  linyin
+ * Add two constant to support long reach
+ *
+ * Revision 1.154  2002/09/07 01:31:51  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.153  2002/09/04 22:36:14  mprahlad
+ * defines for non standard info added
+ *
+ * Revision 1.152  2002/08/02 21:59:09  liang
+ * Enable G.992.2 carrierInfo in capabitilities when G.992.1 annex A is used for G.992.2.
+ *
+ * Revision 1.151  2002/07/29 20:01:03  ilyas
+ * Added command for Atm VC map table change
+ *
+ * Revision 1.150  2002/07/18 22:30:47  liang
+ * Add xmt power and power cutback related constants.
+ *
+ * Revision 1.149  2002/07/11 01:30:58  ilyas
+ * Changed status for ShowtimeMargin reporting
+ *
+ * Revision 1.148  2002/07/09 19:19:09  ilyas
+ * Added status parameters for ShowtimeSNRMargin info and command to filter
+ * out SNR margin data
+ *
+ * Revision 1.147  2002/06/27 21:50:24  liang
+ * Added test command related demodCapabilities bits.
+ *
+ * Revision 1.146  2002/06/26 21:29:00  liang
+ * Added dsl test cmd structure and showtime margin connection info status.
+ *
+ * Revision 1.145  2002/06/15 05:15:51  ilyas
+ * Added definitions for Ping, Dying Gasp and other test commands
+ *
+ * Revision 1.144  2002/05/30 19:55:15  ilyas
+ * Added status for ADSL PHY MIPS exception
+ * Changed conflicting definition for higher rates (S=1/2)
+ *
+ * Revision 1.143  2002/05/21 23:41:07  yongbing
+ * First check-in of Annex C S=1/2 codes
+ *
+ * Revision 1.142  2002/04/29 22:25:09  georgep
+ * Merge from branch annexC_demo - add status message constants
+ *
+ * Revision 1.141  2002/04/18 19:00:35  ilyas
+ * Added include file for builds in CommEngine environment
+ *
+ * Revision 1.140  2002/04/18 00:18:36  yongbing
+ * Add detailed timeout error messages
+ *
+ * Revision 1.139  2002/04/02 10:03:18  ilyas
+ * Merged BERT from AnnexA branch
+ *
+ * Revision 1.138  2002/03/26 01:42:29  ilyas
+ * Added timeout message constants for annex C
+ *
+ * Revision 1.137  2002/03/22 19:39:22  yongbing
+ * Modify for co-exist of G994P1 and T1P413
+ *
+ * Revision 1.136  2002/03/22 01:19:40  ilyas
+ * Add status message constants for total FEXT Bits, NEXT bits
+ *
+ * Revision 1.135  2002/03/10 22:32:24  liang
+ * Added report constants for LOS recovery and timing tone index.
+ *
+ * Revision 1.134  2002/03/07 22:06:32  georgep
+ * Replace ifdef G992P1 with G992P1_ANNEX_A for annex A variables
+ *
+ * Revision 1.133  2002/02/16 01:08:18  georgep
+ * Add log constant for showtime mse
+ *
+ * Revision 1.132  2002/02/08 04:36:27  ilyas
+ * Added commands for LOG file and fixed Idle mode pointer update
+ *
+ * Revision 1.131  2002/01/24 20:21:30  georgep
+ * Add logging defines, remove fast retrain defines
+ *
+ * Revision 1.130  2002/01/19 23:59:17  ilyas
+ * Added support for LOG and eye data to ADSL core target
+ *
+ * Revision 1.129  2002/01/16 23:43:54  liang
+ * Remove the carriage return character from last checkin.
+ *
+ * Revision 1.128  2002/01/15 22:27:13  ilyas
+ * Added command for ADSL loopback
+ *
+ * Revision 1.127  2002/01/10 07:18:22  ilyas
+ * Added status for printf (mainly for ADSL core debugging)
+ *
+ * Revision 1.126  2001/12/21 22:45:34  ilyas
+ * Added support for ADSL MIB data object
+ *
+ * Revision 1.125  2001/12/13 02:24:22  ilyas
+ * Added G997 (Clear EOC and G997 framer) support
+ *
+ * Revision 1.124  2001/11/30 05:56:31  liang
+ * Merged top of the branch AnnexBDevelopment onto top of the tree.
+ *
+ * Revision 1.123  2001/11/15 19:01:07  yongbing
+ * Modify only T1.413 part to the top of tree based on AnnexBDevelopment branch
+ *
+ * Revision 1.122  2001/10/19 00:12:07  ilyas
+ * Added support for frame oriented (no ATM) data link layer
+ *
+ * Revision 1.121  2001/10/09 22:35:13  ilyas
+ * Added more ATM statistics and OAM support
+ *
+ * Revision 1.105.2.20  2001/11/27 02:32:03  liang
+ * Combine vendor ID, serial #, and version number into SoftModemVersionNumber.c.
+ *
+ * Revision 1.105.2.19  2001/11/21 01:29:14  georgep
+ * Add a status message define for annexC
+ *
+ * Revision 1.105.2.18  2001/11/08 23:26:28  yongbing
+ * Add carrier selection function for Annex A and B
+ *
+ * Revision 1.105.2.17  2001/11/07 22:55:30  liang
+ * Report G992 rcv msg CRC error as what it is instead of time out.
+ *
+ * Revision 1.105.2.16  2001/11/05 19:56:21  liang
+ * Add DC offset info code.
+ *
+ * Revision 1.105.2.15  2001/10/16 00:47:16  yongbing
+ * Add return-to-T1p413 starting point if in error
+ *
+ * Revision 1.105.2.14  2001/10/15 23:14:01  yjchen
+ * remove ADSL_SINGLE_SYMBOL_BLOCK
+ *
+ * Revision 1.105.2.13  2001/10/12 18:07:16  yongbing
+ * Add support for T1.413
+ *
+ * Revision 1.105.2.12  2001/10/04 00:23:52  liang
+ * Add connection info constants for TEQ coef and PSD.
+ *
+ * Revision 1.105.2.11  2001/10/03 01:44:01  liang
+ * Merged with codes from main tree (tag SoftDsl_2_18).
+ *
+ * Revision 1.105.2.10  2001/09/28 22:10:04  liang
+ * Add G994 exchange message status reports.
+ *
+ * Revision 1.105.2.9  2001/09/26 18:08:21  georgep
+ * Send status error message in case features field is not setup properly
+ *
+ * Revision 1.105.2.8  2001/09/05 01:58:13  georgep
+ * Added status message for annexC measured delay
+ *
+ * Revision 1.105.2.7  2001/08/29 00:37:52  georgep
+ * Add log constants for annexC
+ *
+ * Revision 1.105.2.6  2001/08/18 00:01:34  georgep
+ * Add constants for annexC
+ *
+ * Revision 1.105.2.5  2001/08/08 17:33:28  yongbing
+ * Merge with tag SoftDsl_2_17
+ *
+ * Revision 1.120  2001/08/29 02:56:01  ilyas
+ * Added tests for flattening/unflatenning command and statuses (dual mode)
+ *
+ * Revision 1.119  2001/08/28 03:26:32  ilyas
+ * Added support for running host and adsl core parts separately ("dual" mode)
+ *
+ * Revision 1.118  2001/08/16 02:16:10  khp
+ * - mark functions with FAST_TEXT to reduce cycle counts for QPROC targets
+ *   (replaces use of LMEM_INSN)
+ *
+ * Revision 1.117  2001/06/18 20:06:35  ilyas
+ * Added forward declaration of dslCommandStruc to avoid gcc warnings
+ *
+ * Revision 1.116  2001/06/18 19:49:36  ilyas
+ * Changes to include support for HOST_ONLY mode
+ *
+ * Revision 1.115  2001/06/01 22:00:33  ilyas
+ * Changed ATM PHY interface to accomodate UTOPIA needs
+ *
+ * Revision 1.114  2001/05/16 06:22:24  liang
+ * Added status reports for xmt & rcv prefix enable position.
+ *
+ * Revision 1.113  2001/05/02 20:34:32  georgep
+ * Added log constants for snr1 calculation
+ *
+ * Revision 1.112  2001/04/25 01:20:11  ilyas
+ *
+ * Don't use DSL frame functions if ATM_LAYER is not defined
+ *
+ * Revision 1.111  2001/04/17 21:13:00  georgep
+ * Define status constant kDslHWSetDigitalEcUpdateShift
+ *
+ * Revision 1.110  2001/04/16 23:38:36  georgep
+ * Add HW AGC constants for ATUR
+ *
+ * Revision 1.109  2001/04/06 23:44:53  georgep
+ * Added status constant for setting up digitalEcGainShift
+ *
+ * Revision 1.108  2001/03/29 05:58:34  liang
+ * Replaced the Aware compatibility codes with automatic detection codes.
+ *
+ * Revision 1.107  2001/03/25 06:11:22  liang
+ * Combined separate loop attenuation status for ATUR & ATUC into one status.
+ * Replace separate hardware AGC info status for ATUR & ATUC into hardware AGC
+ * request status and hardware AGC obtained status.
+ * Use store AGC command to save hardware AGC value instead of returning value
+ * from status report.
+ *
+ * Revision 1.106  2001/03/24 00:43:22  liang
+ * Report more checksum results (NumOfCalls, txSignal, rxSignal & eyeData).
+ *
+ * Revision 1.105  2001/03/16 23:57:31  georgep
+ * Added more loop attenuation reporting status constants
+ *
+ * Revision 1.104  2001/03/15 00:22:07  liang
+ * Back to version 1.101.
+ *
+ * Revision 1.103  2001/03/15 00:03:44  yjchen
+ * use kDslATURHardwareAGCInfo for AltoE14 AGC as well
+ *
+ * Revision 1.102  2001/03/14 23:10:56  yjchen
+ * add defns for AltoE14 AGC
+ *
+ * Revision 1.101  2001/03/08 23:31:34  georgep
+ * Added R, S, D, coding parameters to dslDataPumpCapabilities
+ *
+ * Revision 1.100  2001/02/10 03:03:09  ilyas
+ * Added one more DslFrame function
+ *
+ * Revision 1.99  2001/02/09 01:55:27  ilyas
+ * Added status codes and macros to support printing of AAL packets
+ *
+ * Revision 1.98  2001/01/30 23:28:10  georgep
+ * Added kDslDspControlStatus for handling changes to dsp params
+ *
+ * Revision 1.97  2001/01/12 01:17:18  georgep
+ * Added bit in demodCapabilities for analog echo cancellor
+ *
+ * Revision 1.96  2001/01/04 05:51:03  ilyas
+ * Added more dslStatuses
+ *
+ * Revision 1.95  2000/12/21 05:46:07  ilyas
+ * Added name for struct _dslFrame
+ *
+ * Revision 1.94  2000/12/13 22:04:39  liang
+ * Add Reed-Solomon coding enable bit in demodCapabilities.
+ *
+ * Revision 1.93  2000/11/29 20:42:02  liang
+ * Add defines for SNR & max achivable rate status and DEC enable demodCapabilities bit.
+ *
+ * Revision 1.92  2000/09/22 21:55:13  ilyas
+ * Added support for DSL + Atm physical layer only (I.432) simulations
+ *
+ * Revision 1.91  2000/09/10 09:20:53  lkaplan
+ * Improve interface for sending Eoc messages
+ *
+ * Revision 1.90  2000/09/08 19:37:58  lkaplan
+ * Added code for handling EOC messages
+ *
+ * Revision 1.89  2000/09/07 23:02:27  georgep
+ * Add HarwareAGC Bit to demod Capabilities
+ *
+ * Revision 1.88  2000/09/01 00:57:34  georgep
+ * Added Hardware AGC status defines
+ *
+ * Revision 1.87  2000/08/31 19:04:26  liang
+ * Added external reference for stack size requirement test functions.
+ *
+ * Revision 1.86  2000/08/24 23:16:46  liang
+ * Increased sample block size for noBlock.
+ *
+ * Revision 1.85  2000/08/23 18:34:39  ilyas
+ * Added XxxVcConfigure function
+ *
+ * Revision 1.84  2000/08/05 00:25:04  georgep
+ * Redefine sampling freq constants
+ *
+ * Revision 1.83  2000/08/03 14:04:00  liang
+ * Add hardware time tracking clock error reset code.
+ *
+ * Revision 1.82  2000/07/23 20:52:52  ilyas
+ * Added xxxFrameBufSetAddress() function for ATM framer layers
+ * Rearranged linkLayer functions in one structure which is passed as a
+ * parameter to xxxLinkLayerInit() function to be set there
+ *
+ * Revision 1.81  2000/07/18 20:03:24  ilyas
+ * Changed DslFrame functions definitions to macros,
+ * Removed gDslVars from their parameter list
+ *
+ * Revision 1.80  2000/07/17 21:08:15  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.79  2000/06/21 20:38:44  georgep
+ * Added bit to demodCapabilities for HW_TIME_TRACKING
+ *
+ * Revision 1.78  2000/06/19 19:57:55  georgep
+ * Added constants for logging of HWResampler data
+ *
+ * Revision 1.77  2000/06/02 18:57:21  ilyas
+ * Added support for DSL buffers consisting of many ATM cells
+ *
+ * Revision 1.76  2000/05/27 02:19:28  liang
+ * G992MonitorParams structure is moved here, and Tx/Rx data handler type definitions changed.
+ *
+ * Revision 1.75  2000/05/15 18:17:21  liang
+ * Added statuses for sent and received frames
+ *
+ * Revision 1.74  2000/05/14 01:56:38  ilyas
+ * Added ATM cell printouts
+ *
+ * Revision 1.73  2000/05/09 23:00:26  ilyas
+ * Added ATM status messages, ATM timer, Tx frames flush on timeout
+ * Fixed a bug - adding flushed Tx frames to the list of free Rx frames
+ *
+ * Revision 1.72  2000/05/03 18:01:18  georgep
+ * Removed old function declarations for Eoc/Aoc
+ *
+ * Revision 1.71  2000/05/03 03:57:04  ilyas
+ * Added LOG file support for writing ATM data
+ *
+ * Revision 1.70  2000/05/02 00:04:36  liang
+ * Add showtime monitoring and message exchange info constants.
+ *
+ * Revision 1.69  2000/04/28 23:34:20  yongbing
+ * Add constants for reporting error events in performance monitoring
+ *
+ * Revision 1.68  2000/04/21 23:09:04  liang
+ * Added G992 time out training progress constant.
+ *
+ * Revision 1.67  2000/04/19 00:31:47  ilyas
+ * Added global SoftDsl functions for Vc, added OOB info functions
+ *
+ * Revision 1.66  2000/04/18 00:45:31  yongbing
+ * Add G.DMT new frame structure, define G992P1_NEWFRAME to enable, need ATM layer to work
+ *
+ * Revision 1.65  2000/04/15 01:48:34  georgep
+ * Added T1p413 status constants
+ *
+ * Revision 1.64  2000/04/13 08:36:22  yura
+ * Added SoftDslSetRefData, SoftDslGetRefData functions
+ *
+ * Revision 1.63  2000/04/13 05:42:35  georgep
+ * Added constant for T1p413
+ *
+ * Revision 1.62  2000/04/05 21:49:54  liang
+ * minor change.
+ *
+ * Revision 1.61  2000/04/04 04:16:06  liang
+ * Merged with SoftDsl_0_03 from old tree.
+ *
+ * Revision 1.65  2000/04/04 01:47:21  ilyas
+ * Implemented abstract dslFrame and dslFrameBuffer objects
+ *
+ * Revision 1.64  2000/04/01 08:12:10  yura
+ * Added preliminary revision of the SoftDsl driver architecture
+ *
+ * Revision 1.63  2000/04/01 02:55:33  georgep
+ * New defines for G992p2Profile Structure
+ *
+ * Revision 1.62  2000/04/01 00:50:36  yongbing
+ * Add initial version of new frame structure for full-rate
+ *
+ * Revision 1.61  2000/03/24 03:30:45  georgep
+ * Define new constant kDslUpstreamSamplingFreq
+ *
+ * Revision 1.60  2000/03/23 19:51:30  georgep
+ * Define new features bits for G992p1
+ *
+ * Revision 1.59  2000/03/18 01:28:41  georgep
+ * Changed connectionSetup to include G992p1 Capabilities
+ *
+ * Revision 1.58  2000/02/29 01:40:03  georgep
+ * Changed modulationtype defines to be the same as SPAR1 in G994p1
+ *
+ * Revision 1.57  1999/11/19 01:03:19  george
+ * Use Block Size 256 for single symbol Mode
+ *
+ * Revision 1.56  1999/11/18 02:37:43  george
+ * Porting to 16Bit
+ *
+ * Revision 1.55  1999/11/12 02:12:55  george
+ * Added status constant for reporting of profile channel matching calculation
+ *
+ * Revision 1.54  1999/11/11 19:19:42  george
+ * Porting to 16Bit Compiler
+ *
+ * Revision 1.53  1999/11/05 01:27:06  liang
+ * Add recovery-from-inpulse-noise progress report.
+ *
+ * Revision 1.52  1999/11/02 02:06:27  george
+ * Added SNRMargin training status value
+ *
+ * Revision 1.51  1999/10/27 23:02:03  wan
+ * Add G.994.1 setup in dslConnectionSetupStruct for setting up Initiation side
+ *
+ * Revision 1.50  1999/10/25 21:55:36  liang
+ * Renamed the constant for FEQ output error.
+ *
+ * Revision 1.49  1999/10/23 02:20:55  george
+ * Add debug data codes
+ *
+ * Revision 1.48  1999/10/19 23:59:06  liang
+ * Change line handler interface to work with nonsymmetric sampling freq.
+ *
+ * Revision 1.47  1999/10/09 01:38:04  george
+ * Define maxProfileNumber
+ *
+ * Revision 1.46  1999/10/07 23:30:51  wan
+ * Add G.994.1 Tone and Fast Retrain Recov detections in G.992p2 SHOWTIME and Fast Retrain
+ *
+ * Revision 1.45  1999/10/06 13:59:27  liang
+ * Escape to G994.1 should be done through status instead of command.
+ *
+ * Revision 1.44  1999/10/06 02:01:28  george
+ * Add kDslReturnToG994p1Cmd
+ *
+ * Revision 1.43  1999/09/30 19:29:58  george
+ * Add reporting constant for Fast Retrain
+ *
+ * Revision 1.42  1999/09/16 23:41:56  liang
+ * Added command for host forced retrain.
+ *
+ * Revision 1.41  1999/08/20 00:47:25  wan
+ * Add constants for Fast Retrain progress status
+ *
+ * Revision 1.40  1999/08/16 18:06:01  wan
+ * Add more reporting constants for Fast Retrain
+ *
+ * Revision 1.39  1999/08/12 00:18:10  wan
+ * Add several Fast Retrain Status constants
+ *
+ * Revision 1.38  1999/08/10 18:25:38  george
+ * Define constants used for Fast Retrain
+ *
+ * Revision 1.37  1999/07/31 01:47:43  george
+ * Add status constants for eoc/aoc
+ *
+ * Revision 1.36  1999/07/27 18:19:52  george
+ * declare aoc/eoc functions
+ *
+ * Revision 1.35  1999/07/19 22:44:47  george
+ * Add constants for G994p1 Message Exchange
+ *
+ * Revision 1.34  1999/07/16 02:03:03  liang
+ * Modified Dsl link layer command spec structure.
+ *
+ * Revision 1.33  1999/07/14 22:53:16  george
+ * Add Constants for G994p1
+ *
+ * Revision 1.32  1999/07/13 00:02:26  liang
+ * Added more feature bits.
+ *
+ * Revision 1.31  1999/07/09 01:58:14  wan
+ * Added more constants G.994.1 testing reports
+ *
+ * Revision 1.30  1999/07/07 23:51:04  liang
+ * Added rcv power and loop attenuation reports.
+ *
+ * Revision 1.29  1999/07/06 21:32:01  liang
+ * Added some aux. feature bits, and field performanceMargin was changed to noiseMargin in Capabilities.
+ *
+ * Revision 1.28  1999/07/03 01:40:17  liang
+ * Redefined dsl command parameter list and added connection setup struct.
+ *
+ * Revision 1.27  1999/07/02 00:41:18  liang
+ * Add bit and gain logging as well as rcv carrier range status.
+ *
+ * Revision 1.26  1999/06/25 21:37:10  wan
+ * Work in progress for G994.1.
+ *
+ * Revision 1.25  1999/06/16 00:54:36  liang
+ * Added Tx/Rx SHOWTIME active training progress codes.
+ *
+ * Revision 1.24  1999/06/11 21:59:37  wan
+ * Added G994.1 fail status constant.
+ *
+ * Revision 1.23  1999/06/11 21:29:01  liang
+ * Constants for C/R-Msgs was changed to C/R-Msg.
+ *
+ * Revision 1.22  1999/06/08 02:49:42  liang
+ * Added SNR data logging.
+ *
+ * Revision 1.21  1999/06/07 21:05:08  liang
+ * Added more training status values.
+ *
+ * Revision 1.20  1999/05/22 02:18:26  liang
+ * More constant defines.
+ *
+ * Revision 1.19  1999/05/14 22:49:35  liang
+ * Added more status codes and debug data codes.
+ *
+ * Revision 1.18  1999/04/12 22:41:39  liang
+ * Work in progress.
+ *
+ * Revision 1.17  1999/04/01 20:28:07  liang
+ * Added RReverb detect event status.
+ *
+ * Revision 1.16  1999/03/26 03:29:54  liang
+ * Add DSL debug data constants.
+ *
+ * Revision 1.15  1999/03/08 21:58:00  liang
+ * Added more constant definitions.
+ *
+ * Revision 1.14  1999/03/02 01:49:36  liang
+ * Added more connection info codes.
+ *
+ * Revision 1.13  1999/03/02 00:25:55  liang
+ * Added DSL tx and rx data handler type definitions.
+ *
+ * Revision 1.12  1999/02/27 01:16:55  liang
+ * Increase allowable static memory size to a VERY large number for now.
+ *
+ * Revision 1.11  1999/02/25 00:24:06  liang
+ * Increased symbol block size to 16.
+ *
+ * Revision 1.10  1999/02/23 22:03:26  liang
+ * Increased maximal static memory size allowed.
+ *
+ * Revision 1.9  1999/02/17 02:39:21  ilyas
+ * Changes for NDIS
+ *
+ * Revision 1.8  1999/02/11 22:44:30  ilyas
+ * More definitions for ATM
+ *
+ * Revision 1.7  1999/02/10 01:56:38  liang
+ * Added hooks for G994.1 and G992.2.
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	SoftDslHeader
+#define	SoftDslHeader
+
+/* for builds in Linux/VxWorks CommEngine environment */
+#if (defined(__KERNEL__) && !defined(LINUX_DRIVER)) || defined(VXWORKS) || defined(_WIN32_WCE) || defined(TARG_OS_RTEMS) || defined(_CFE_)
+#include "AdslCoreDefs.h"
+#else
+#include "Bcm6345_To_Bcm6348.h"		/* File for 45->48 changes */
+#endif
+
+#ifndef	SoftModemPh
+#include "SoftModem.h"
+#endif
+
+#ifdef DSL_OS
+#include "DslOs.h"
+#endif
+
+/*
+**
+**		Type definitions 
+**
+*/
+
+#if defined(ATM) || defined(DSL_PACKET)
+#define DSL_LINKLAYER
+#endif
+
+#if defined(ATM_LAYER) || defined(DSL_PACKET_LAYER) || defined(G997_1_FRAMER)
+#define DSL_FRAME_FUNCTIONS
+#endif
+
+#define FLD_OFFSET(type,fld)	((int)(void *)&(((type *)0)->fld))
+
+#include "Que.h"
+#include "SoftAtmVc.h"
+
+typedef struct _dslFrameBuffer
+	{
+	struct _dslFrameBuffer *next;	/* link to the next buffer in the frame */
+	void				   *pData;	/* pointer to data */
+	ulong				   length;	/* size (in bytes) of data */
+	} dslFrameBuffer;
+
+typedef struct _dslFrame
+	{
+	ulong			Reserved[3];
+
+	ulong			totalLength;	/* total amount of data in the packet */
+	int				bufCnt;			/* buffer counter */
+	struct _dslFrameBuffer *head;	/* first buffer in the chain */
+	struct _dslFrameBuffer *tail;	/* last buffer in the chain  */
+	} dslFrame;
+
+
+/* VC types and parameters */
+
+#define	kDslVcAtm		1
+
+typedef	struct
+	{
+	ulong	vcType;
+	union
+		{
+		atmVcParams	atmParams;
+		} params;
+	} dslVcParams;
+
+/*
+**	Assuming that dslVcParams.params is the first field in VC
+**	and RefData is the first field in dslVcParams.params
+*/
+
+#define	DslVcGetRefData(pVc)	(*(void **) (pVc))
+
+/* Frame OOB types */
+
+#define	kDslFrameAtm	1
+
+typedef	struct
+	{
+	ulong	frameType;		
+	union
+		{
+		atmOobPacketInfo	atmInfo;
+		} param;
+	} dslOobFrameInfo;
+
+
+typedef struct
+	{
+	ulong (SM_DECL *__DslFrameBufferGetLength) (dslFrameBuffer *fb);
+	void * (SM_DECL *__DslFrameBufferGetAddress) (dslFrameBuffer *fb);
+	void (SM_DECL *__DslFrameBufferSetLength) (dslFrameBuffer *fb, ulong l);
+	void (SM_DECL *__DslFrameBufferSetAddress) (dslFrameBuffer *fb, void *p);
+
+	void (SM_DECL *__DslFrameInit) (dslFrame *f);
+	ulong (SM_DECL *__DslFrameGetLength) (dslFrame *pFrame);
+	ulong (SM_DECL *__DslFrameGetBufCnt) (dslFrame *pFrame);
+	dslFrameBuffer * (SM_DECL *__DslFrameGetFirstBuffer) (dslFrame *pFrame);
+	dslFrameBuffer * (SM_DECL *__DslFrameGetNextBuffer) (dslFrameBuffer *pFrBuffer);
+	void  (SM_DECL *__DslFrameSetNextBuffer) (dslFrameBuffer *pFrBuf, dslFrameBuffer *pFrBufNext);
+	dslFrameBuffer * (SM_DECL *__DslFrameGetLastBuffer) (dslFrame *pFrame);
+	void * (SM_DECL *__DslFrameGetLinkFieldAddress) (dslFrame *f);
+	dslFrame * (SM_DECL *__DslFrameGetFrameAddressFromLink) (void *lnk);
+
+	Boolean (SM_DECL *__DslFrameGetOobInfo) (dslFrame *f, dslOobFrameInfo	*pOobInfo);
+	Boolean (SM_DECL *__DslFrameSetOobInfo) (dslFrame *f, dslOobFrameInfo	*pOobInfo);
+
+	void (SM_DECL *__DslFrameEnqueBufferAtBack) (dslFrame *f, dslFrameBuffer *b);
+	void (SM_DECL *__DslFrameEnqueFrameAtBack) (dslFrame *fMain, dslFrame *f);
+	void (SM_DECL *__DslFrameEnqueBufferAtFront) (dslFrame *f, dslFrameBuffer *b);
+	void (SM_DECL *__DslFrameEnqueFrameAtFront) (dslFrame *fMain, dslFrame *f);
+	dslFrameBuffer * (SM_DECL *__DslFrameDequeBuffer) (dslFrame *pFrame);
+
+	void * (SM_DECL *__DslFrameAllocMemForFrames) (ulong frameNum);
+	void (SM_DECL *__DslFrameFreeMemForFrames) (void *hMem);
+	dslFrame * (SM_DECL *__DslFrameAllocFrame) (void *handle);
+	void (SM_DECL *__DslFrameFreeFrame) (void *handle, dslFrame *pFrame);
+	void * (SM_DECL *__DslFrameAllocMemForBuffers) (void **ppMemPool, ulong bufNum, ulong memSize);
+	void (SM_DECL *__DslFrameFreeMemForBuffers) (void *hMem, ulong memSize, void *pMemPool);
+	dslFrameBuffer * (SM_DECL *__DslFrameAllocBuffer) (void *handle, void *pMem, ulong length);
+	void (SM_DECL *__DslFrameFreeBuffer) (void *handle, dslFrameBuffer *pBuf);
+
+	/* for LOG file support */
+
+	ulong (SM_DECL *__DslFrame2Id)(void *handle, dslFrame *pFrame);
+	void * (SM_DECL *__DslFrameId2Frame)(void *handle, ulong frameId);
+	} dslFrameFunctions;
+
+#define	 DslFrameDeclareFunctions( name_prefix )								\
+extern ulong SM_DECL name_prefix##BufferGetLength(dslFrameBuffer *fb);			\
+extern void * SM_DECL name_prefix##BufferGetAddress(dslFrameBuffer *fb);		\
+extern void SM_DECL name_prefix##BufferSetLength(dslFrameBuffer *fb, ulong l);	\
+extern void SM_DECL name_prefix##BufferSetAddress(dslFrameBuffer *fb, void *p); \
+																				\
+extern void SM_DECL name_prefix##Init(dslFrame *f);								\
+extern ulong SM_DECL name_prefix##GetLength (dslFrame *pFrame);					\
+extern ulong SM_DECL name_prefix##GetBufCnt(dslFrame *pFrame);					\
+extern dslFrameBuffer * SM_DECL name_prefix##GetFirstBuffer(dslFrame *pFrame);	\
+extern dslFrameBuffer * SM_DECL name_prefix##GetNextBuffer(dslFrameBuffer *pFrBuffer);	\
+extern void SM_DECL name_prefix##SetNextBuffer(dslFrameBuffer *pFrBuf, dslFrameBuffer *pFrBufNext);	\
+extern dslFrameBuffer * SM_DECL name_prefix##GetLastBuffer(dslFrame *pFrame);			\
+extern void * SM_DECL name_prefix##GetLinkFieldAddress(dslFrame *f);					\
+extern Boolean SM_DECL name_prefix##GetOobInfo(dslFrame *f, dslOobFrameInfo *pOobInfo);	\
+extern Boolean SM_DECL name_prefix##SetOobInfo(dslFrame *f, dslOobFrameInfo *pOobInfo);	\
+extern dslFrame* SM_DECL name_prefix##GetFrameAddressFromLink(void *lnk);				\
+extern void SM_DECL name_prefix##EnqueBufferAtBack(dslFrame *f, dslFrameBuffer *b);		\
+extern void SM_DECL name_prefix##EnqueFrameAtBack(dslFrame *fMain, dslFrame *f);		\
+extern void SM_DECL name_prefix##EnqueBufferAtFront(dslFrame *f, dslFrameBuffer *b);	\
+extern void SM_DECL name_prefix##EnqueFrameAtFront(dslFrame *fMain, dslFrame *f);		\
+extern dslFrameBuffer * SM_DECL name_prefix##DequeBuffer(dslFrame *pFrame);				\
+																						\
+extern void * SM_DECL name_prefix##AllocMemForFrames(ulong frameNum);					\
+extern void SM_DECL name_prefix##FreeMemForFrames(void *hMem);							\
+extern dslFrame * SM_DECL name_prefix##AllocFrame(void *handle);						\
+extern void SM_DECL name_prefix##FreeFrame(void *handle, dslFrame *pFrame);				\
+extern void * SM_DECL name_prefix##AllocMemForBuffers(void **ppMemPool, ulong bufNum, ulong memSize);	\
+extern void SM_DECL name_prefix##FreeMemForBuffers(void *hMem, ulong memSize, void *pMemPool);			\
+extern dslFrameBuffer * SM_DECL name_prefix##AllocBuffer(void *handle, void *pMem, ulong length);		\
+extern void SM_DECL name_prefix##FreeBuffer(void *handle, dslFrameBuffer *pBuf);		\
+extern ulong SM_DECL name_prefix##2Id(void *handle, dslFrame *pFrame);					\
+extern void * SM_DECL name_prefix##Id2Frame(void *handle, ulong frameId);
+
+
+#define	 DslFrameAssignFunctions( var, name_prefix )	do {			\
+	(var).__DslFrameBufferGetLength	= name_prefix##BufferGetLength;		\
+	(var).__DslFrameBufferGetAddress= name_prefix##BufferGetAddress;	\
+	(var).__DslFrameBufferSetLength	= name_prefix##BufferSetLength;		\
+	(var).__DslFrameBufferSetAddress= name_prefix##BufferSetAddress;	\
+																		\
+	(var).__DslFrameInit			= name_prefix##Init;				\
+	(var).__DslFrameGetLength		= name_prefix##GetLength;			\
+	(var).__DslFrameGetBufCnt		= name_prefix##GetBufCnt;			\
+	(var).__DslFrameGetFirstBuffer	= name_prefix##GetFirstBuffer;		\
+	(var).__DslFrameGetNextBuffer	= name_prefix##GetNextBuffer;		\
+	(var).__DslFrameSetNextBuffer	= name_prefix##SetNextBuffer;		\
+	(var).__DslFrameGetLastBuffer	= name_prefix##GetLastBuffer;		\
+	(var).__DslFrameGetLinkFieldAddress		= name_prefix##GetLinkFieldAddress;		\
+	(var).__DslFrameGetFrameAddressFromLink	= name_prefix##GetFrameAddressFromLink; \
+																		\
+	(var).__DslFrameGetOobInfo		= name_prefix##GetOobInfo;			\
+	(var).__DslFrameSetOobInfo		= name_prefix##SetOobInfo;			\
+																		\
+	(var).__DslFrameEnqueBufferAtBack	= name_prefix##EnqueBufferAtBack;	\
+	(var).__DslFrameEnqueFrameAtBack	= name_prefix##EnqueFrameAtBack;	\
+	(var).__DslFrameEnqueBufferAtFront= name_prefix##EnqueBufferAtFront;	\
+	(var).__DslFrameEnqueFrameAtFront	= name_prefix##EnqueFrameAtFront;	\
+	(var).__DslFrameDequeBuffer		= name_prefix##DequeBuffer;			\
+																		\
+	(var).__DslFrameAllocMemForFrames	= name_prefix##AllocMemForFrames;	\
+	(var).__DslFrameFreeMemForFrames	= name_prefix##FreeMemForFrames;	\
+	(var).__DslFrameAllocFrame			= name_prefix##AllocFrame;			\
+	(var).__DslFrameFreeFrame			= name_prefix##FreeFrame;			\
+	(var).__DslFrameAllocMemForBuffers= name_prefix##AllocMemForBuffers;	\
+	(var).__DslFrameFreeMemForBuffers = name_prefix##FreeMemForBuffers;	\
+	(var).__DslFrameAllocBuffer		= name_prefix##AllocBuffer;			\
+	(var).__DslFrameFreeBuffer		= name_prefix##FreeBuffer;			\
+																		\
+	(var).__DslFrame2Id				= name_prefix##2Id;					\
+	(var).__DslFrameId2Frame		= name_prefix##Id2Frame;			\
+} while (0)
+
+typedef	struct
+	{
+	Boolean		febe_I;
+	Boolean		fecc_I;
+	Boolean		los, rdi;
+	Boolean		ncd_I;
+	Boolean		hec_I;
+#ifdef G992P3 
+	Boolean		lpr;
+#endif
+
+#ifdef	G992P1_NEWFRAME
+
+	Boolean		febe_F;
+	Boolean		fecc_F;
+	Boolean		ncd_F;
+	Boolean		hec_F;
+	
+#endif
+	} G992MonitorParams;
+
+typedef struct
+	{
+	ushort	K;
+	uchar	S, R;
+	uchar   D;
+#ifdef G992P3 
+	uchar	T, SEQ;
+#endif
+	directionType	direction;
+
+#ifdef		G992P1_NEWFRAME
+
+	ushort	N;
+	ushort	NF;
+	uchar	RSF;
+
+	uchar	AS0BF, AS1BF, AS2BF, AS3BF, AEXAF;
+	ushort	AS0BI;
+	uchar	AS1BI, AS2BI, AS3BI, AEXAI;
+
+	uchar	LS0CF, LS1BF, LS2BF, LEXLF;
+	uchar	LS0CI, LS1BI, LS2BI, LEXLI;
+	
+	uchar	mergedModeEnabled;
+	
+#endif
+
+	} G992CodingParams;
+
+typedef struct
+	{
+	uchar	Nlp;
+	uchar	Nbc;
+	uchar	MSGlp;
+	ushort	MSGc;
+
+	ulong	L;
+	ushort	M;
+	ushort	T;
+	ushort	D;
+	ushort	R;
+	ushort	B;
+	} G992p3CodingParams;
+
+/* Power Management Message definitions (used in command and status) */
+
+typedef struct
+	{
+	long			msgType;
+	union
+		{
+		long		value;
+		struct
+			{
+			long	msgLen;
+			void	*msgData;
+			} msg;
+		} param;
+	} dslPwrMessage;
+
+/* Power Management commands and responses */
+
+#define	kPwrSimpleRequest							1
+#define	kPwrL2Request								2
+#define	kPwrL2TrimRequest							3
+
+#define	kPwrGrant									0x80
+#define	kPwrReject									0x81
+#define	kPwrL2Grant									0x82
+#define	kPwrL2Reject								0x83
+#define	kPwrL2TrimGrant								0x84
+#define	kPwrL2TrimReject							0x85
+#define	kPwrL2Grant2p								0x86
+
+#define	kPwrBusy									0x01
+#define	kPwrInvalid									0x02
+#define	kPwrNotDesired								0x03
+#define	kPwrInfeasibleParam							0x04
+
+/* Power Management reason codes */
+
+/* OLR definitions (used in command and status) */
+
+typedef struct
+	{
+	ushort	msgType;
+	ushort	nCarrs;
+	ushort	L[4];
+	uchar	B[4];
+	void	*carrParamPtr;
+	} dslOLRMessage;
+
+typedef struct
+	{
+	uchar	ind;
+	uchar	gain;
+	uchar	gb;
+	} dslOLRCarrParam;
+
+typedef struct
+	{
+	ushort	ind;
+	uchar	gain;
+	uchar	gb;
+	} dslOLRCarrParam2p;
+
+/* OLR messages */
+
+#define	kOLRRequestType1							1
+#define	kOLRRequestType2							2
+#define	kOLRRequestType3							3
+#define	kOLRRequestType4							4
+#define	kOLRRequestType5							5
+#define	kOLRRequestType6							6
+
+#define	kOLRDeferType1								0x81
+#define	kOLRRejectType2								0x82
+#define	kOLRRejectType3								0x83
+
+/* OLR reason codes */
+
+#define	kOLRBusy									1
+#define	kOLRInvalidParam							2
+#define	kOLRNotEnabled								3
+#define	kOLRNotSupported							4
+
+/* common EOC definitions  */
+#define	kG992EocStuffingByte						0x0C
+
+/* showtime monitor counters */
+#define	kG992ShowtimeRSCodewordsRcved				0	/* number of Reed-Solomon codewords received */
+#define kG992ShowtimeRSCodewordsRcvedOK				1	/* number of Reed-Solomon codewords received with all symdromes zero */
+#define	kG992ShowtimeRSCodewordsRcvedCorrectable	2	/* number of Reed-Solomon codewords received with correctable errors */
+#define	kG992ShowtimeRSCodewordsRcvedUncorrectable	3	/* number of Reed-Solomon codewords received with un-correctable errors */
+#define	kG992ShowtimeSuperFramesRcvd				4	/* number of super frames received */
+#define	kG992ShowtimeSuperFramesRcvdWrong			5	/* number of super frames received with CRC error */
+#define	kG992ShowtimeLastUncorrectableRSCount		6	/* last recorded value for kG992ShowtimeRSCodewordsRcvedUncorrectable */
+#define	kG992ShowtimeLastWrongSuperFrameCount		7	/* last recorded value for kG992ShowtimeSuperFramesRcvdWrong */
+#define	kG992ShowtimeNumOfShortResync				8	/* number of short interrupt recoveries by FEQ */
+
+#define	kG992ShowtimeNumOfFEBE						9	/* number of other side superframe errors */
+#define	kG992ShowtimeNumOfFECC						10	/* number of other side superframe FEC errors */
+#define	kG992ShowtimeNumOfFHEC						11	/* number of far-end ATM header CRC errors */
+#define	kG992ShowtimeNumOfFOCD						12	/* number of far-end OCD events */
+#define	kG992ShowtimeNumOfFLCD						13	/* number of far-end LCD events */
+#define	kG992ShowtimeNumOfHEC						14	/* number of ATM header CRC errors */
+#define	kG992ShowtimeNumOfOCD						15	/* number of OCD events */
+#define	kG992ShowtimeNumOfLCD						16	/* number of LCD events */
+
+#define	kG992ShowtimeNumOfMonitorCounters			(kG992ShowtimeNumOfLCD+1)	/* always last number + 1 */
+#define	kG992ShowtimeMonitorReportNumber			9
+
+#define	kG992ShowtimeLCDNumShift					1
+#define	kG992ShowtimeLCDFlag						1
+
+typedef	int		(SM_DECL *dslFrameHandlerType)	(void *gDslVars, void *pVc, ulong mid, dslFrame *);
+
+typedef	void*   (SM_DECL *dslHeaderHandlerType) (void *gDslVars, ulong hdr, uchar hdrHec);
+typedef	void*	(SM_DECL *dslTxFrameBufferHandlerType)	(void *gDslVars, int*,	void*);
+typedef	void*	(SM_DECL *dslRxFrameBufferHandlerType)	(void *gDslVars, int,	void*);
+
+typedef	void*	(SM_DECL *dslVcAllocateHandlerType)	(void *gDslVars, void *);
+typedef	void	(SM_DECL *dslVcFreeHandlerType)	(void *gDslVars, void *);
+typedef	Boolean	(SM_DECL *dslVcActivateHandlerType)	(void *gDslVars, void *);
+typedef	void	(SM_DECL *dslVcDeactivateHandlerType) (void *gDslVars, void *);
+typedef	Boolean	(SM_DECL *dslVcConfigureHandlerType) (void *gDslVars, void *pVc, ulong mid, void *);
+
+typedef	ulong	(SM_DECL *dslLinkVc2IdHandlerType) (void *gDslVars, void *);
+typedef	void*	(SM_DECL *dslLinkVcId2VcHandlerType) (void *gDslVars, ulong);
+typedef void*	(SM_DECL *dslGetFramePoolHandlerType) (void *gDslVars);
+
+typedef	void	(SM_DECL *dslLinkCloseHandlerType) (void *gDslVars);
+typedef	int		(SM_DECL *dslTxDataHandlerType)(void *gDslVars, int, int, uchar*, G992MonitorParams*);
+typedef	int		(SM_DECL *dslRxDataHandlerType)(void *gDslVars, int, uchar*, G992MonitorParams*);
+
+typedef	void	(SM_DECL *dslLinkStatusHandler) (void *gDslVars, ulong statusCode, ...);
+
+typedef Boolean (SM_DECL *dslPhyInitType) (
+	void						*gDslVars, 
+	bitMap						setupMap,
+	dslHeaderHandlerType		rxCellHeaderHandlerPtr,
+	dslRxFrameBufferHandlerType	rxFrameHandlerPtr,  
+	dslTxFrameBufferHandlerType txFrameHandlerPtr,
+	atmStatusHandler			statusHandlerPtr);
+
+struct _dslFramerBufDesc;
+
+typedef	Boolean (SM_DECL *dslFramerDataGetPtrHandlerType) (void *gDslVars, struct _dslFramerBufDesc *pBufDesc);
+typedef	void	(SM_DECL *dslFramerDataDoneHandlerType) (void *gDslVars, struct _dslFramerBufDesc *pBufDesc);
+
+typedef	void	(SM_DECL *dslDriverCallbackType) (void *gDslVars);
+
+#ifdef DSL_PACKET
+
+typedef	struct 
+	{
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	rxDataDoneHandler;
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	txDataDoneHandler;
+	} dslPacketPhyFunctions;
+
+typedef Boolean (SM_DECL *dslPacketPhyInitType) (
+	void						*gDslVars, 
+	bitMap						setupMap,
+	dslPacketPhyFunctions		dslPhyFunctions,
+	dslLinkStatusHandler		statusHandlerPtr);
+
+
+#endif /* DSL_PACKET */
+
+
+typedef	int			dslDirectionType;
+typedef	bitMap		dslModulationType;
+typedef	bitMap		dslLinkLayerType;
+
+/*
+**
+**		Log data codes 
+**
+*/
+
+#define	kDslEyeData					eyeData
+
+#define	kDslLogComplete				(inputSignalData - 1)
+#define	kDslLogInputData			inputSignalData
+#define	kDslLogInputData1			(inputSignalData + 1)
+#define	kDslLogInputData2			(inputSignalData + 2)
+#define	kDslLogInputData3			(inputSignalData + 3)
+
+/*
+**
+**		Status codes 
+**
+*/
+
+typedef long						dslStatusCode;
+#define	kFirstDslStatusCode			256
+#define	kDslError					(kFirstDslStatusCode + 0)
+#define	kAtmStatus					(kFirstDslStatusCode + 1)
+#define	kDslTrainingStatus			(kFirstDslStatusCode + 2)
+#define	kDslConnectInfoStatus		(kFirstDslStatusCode + 3)
+#define	kDslEscapeToG994p1Status	(kFirstDslStatusCode + 4)
+#define	kDslFrameStatus				(kFirstDslStatusCode + 5)
+#define kDslReceivedEocCommand		(kFirstDslStatusCode + 6)
+#define kDslSendEocCommandDone		(kFirstDslStatusCode + 7)
+#define kDslSendEocCommandFailed	(kFirstDslStatusCode + 8)
+#define kDslWriteRemoteRegisterDone	(kFirstDslStatusCode + 9)
+#define kDslReadRemoteRegisterDone	(kFirstDslStatusCode + 10)
+#define	kDslExternalError			(kFirstDslStatusCode + 11)
+#define kDslDspControlStatus		(kFirstDslStatusCode + 12)
+#define kDslATUHardwareAGCRequest	(kFirstDslStatusCode + 13)
+#define	kDslPacketStatus			(kFirstDslStatusCode + 14)
+#define	kDslG997Status				(kFirstDslStatusCode + 15)
+#define	kDslPrintfStatus			(kFirstDslStatusCode + 16)
+#define	kDslPrintfStatus1			(kFirstDslStatusCode + 17)
+#define	kDslExceptionStatus			(kFirstDslStatusCode + 18)
+#define	kDslPingResponse			(kFirstDslStatusCode + 19)
+#define	kDslShowtimeSNRMarginInfo	(kFirstDslStatusCode + 20)
+#define	kDslGetOemParameter			(kFirstDslStatusCode + 21)
+#define	kDslOemDataAddrStatus		(kFirstDslStatusCode + 22)
+#define	kDslDataAvailStatus			(kFirstDslStatusCode + 23)
+/* #define kDslAtuChangeTxFilterRequest (kFirstDslStatusCode + 24) */
+#define kDslTestPllPhaseResult      (kFirstDslStatusCode + 25)
+#ifdef BCM6348_SRC
+#define kDslHardwareAGCSetPga1      (kFirstDslStatusCode + 26)
+#define kDslHardwareAGCDecPga1      (kFirstDslStatusCode + 27)
+#define kDslHardwareAGCIncPga1      (kFirstDslStatusCode + 28)
+#define kDslHardwareAGCSetPga2Delta (kFirstDslStatusCode + 29)
+#endif
+#define	kDslOLRRequestStatus		(kFirstDslStatusCode + 30)
+#define	kDslOLRResponseStatus		(kFirstDslStatusCode + 31)
+#define	kDslOLRBitGainUpdateStatus	(kFirstDslStatusCode + 32)
+#define	kDslPwrMgrStatus		    (kFirstDslStatusCode + 33)
+#define	kDslEscapeToT1p413Status	(kFirstDslStatusCode + 34)
+#ifdef BCM6348_SRC
+#define kDslHardwareAGCSetPga2      (kFirstDslStatusCode + 35)
+#define kDslHardwareGetRcvAGC       (kFirstDslStatusCode + 36)
+#endif
+#define kDslUpdateXmtReadPtr        (kFirstDslStatusCode + 37)
+#define kDslHardwareSetRcvAGC       (kFirstDslStatusCode + 38)
+#ifdef BCM6348_SRC
+#define kDslSetDigUsPwrCutback      (kFirstDslStatusCode + 39)
+#endif
+
+#define	kClientSideInitiation		0
+#define	kClientSideRespond			1
+#define	kCentralSideInitiation		2
+#define	kCentralSideRespond			3
+
+/* OEM parameter ID definition */
+
+#define	kDslOemG994VendorId			1
+#define	kDslOemG994XmtNSInfo		2
+#define	kDslOemG994RcvNSInfo		3
+#define	kDslOemEocVendorId			4
+#define	kDslOemEocVersion			5
+#define	kDslOemEocSerNum			6
+#define	kDslOemT1413VendorId		7
+#define	kDslOemT1413EocVendorId		8
+
+typedef long	dslErrorCode;
+
+typedef long	atmStatusCode;
+typedef long	dslFramerStatusCode;
+
+typedef long	atmErrorCode;
+
+typedef long	dslTrainingStatusCode;
+
+#define kDslStartedG994p1					0
+#define kDslStartedT1p413HS					1
+
+/* reserved for G.994.1: 1 ~ 8 */
+
+#define	kDslG994p1MessageDet				100
+#define	kDslG994p1ToneDet					101
+#define	kDslG994p1RToneDet					102
+#define	kDslG994p1FlagDet					103
+#define	kDslG994p1GalfDet					104
+#define	kDslG994p1ErrorFrameDet				105
+#define	kDslG994p1BadFrameDet				106
+#define	kDslG994p1SilenceDet				107
+#define	kDslG994p1RcvTimeout				108
+#define	kDslG994p1XmtFinished				109
+#define	kDslG994p1ReturntoStartup			110
+#define	kDslG994p1InitiateCleardown			111
+#define	kDslG994p1StartupFinished			112
+#define	kDslG994p1RcvNonStandardInfo		113
+#define	kDslG994p1XmtNonStandardInfo		114
+
+#define	kG994p1MaxNonstdMessageLength		64
+
+#define kDslFinishedT1p413					1100
+#define kDslT1p413DetectedCTone				1101
+#define kDslT1p413DetectedCAct				1102
+#define kDslT1p413DetectedCReveille			1103
+#define kDslT1p413DetectedRActReq			1104
+#define kDslT1p413DetectedRQuiet1			1105
+#define kDslT1p413DetectedRAct				1106
+#define kDslT1p413TimeoutCReveille			1107
+#define	kDslT1p413ReturntoStartup			1108
+
+#define	kDslG994p1Timeout					8
+#define kDslFinishedG994p1					9
+#define kDslStartedG992p2Training			10
+#define	kDslG992p2DetectedPilotSymbol		11
+#define	kDslG992p2DetectedReverbSymbol		12
+#define	kDslG992p2TEQCalculationDone		13
+#define	kDslG992p2TrainingFEQ				14
+#define	kDslG992p2Phase3Started				15
+#define	kDslG992p2ReceivedRates1			16
+#define	kDslG992p2ReceivedMsg1				17
+#define	kDslG992p2Phase4Started				18
+#define	kDslG992p2ReceivedRatesRA			19
+#define	kDslG992p2ReceivedMsgRA				20
+#define	kDslG992p2ReceivedRates2			21
+#define	kDslG992p2ReceivedMsg2				22
+#define	kDslG992p2ReceivedBitGainTable		23
+#define	kDslG992p2TxShowtimeActive			24
+#define	kDslG992p2RxShowtimeActive			25
+#define	kDslG992p2TxAocMessage				26
+#define	kDslG992p2RxAocMessage				27
+#define	kDslG992p2TxEocMessage				28
+#define	kDslG992p2RxEocMessage				29
+#define kDslFinishedG992p2Training			30
+#define	kDslRecoveredFromImpulseNoise		31
+#define	kDslG992Timeout						32
+#define	kDslT1p413Isu1SglByteSymDetected	33	/* detected T1.413 Issue 1 single byte per symbol mode */
+#define	kDslG992RxPrefixOnInAFewSymbols		34
+#define	kDslG992TxPrefixOnInAFewSymbols		35
+#define	kDslAnnexCXmtCPilot1Starting		36
+#define	kDslXmtToRcvPathDelay				37
+#define kDslFeaturesUnsupported				38
+#define	kDslG992RcvMsgCrcError				39
+#define	kDslAnnexCDetectedStartHyperframe	40
+
+#define kDslG992AnnexCTimeoutCPilot1Detection	41
+#define kDslG992AnnexCTimeoutCReverb1Detection	42
+#define kDslG992AnnexCTimeoutECTraining			43
+#define kDslG992AnnexCTimeoutHyperframeDetector	44
+#define kDslG992AnnexCTimeoutSendRSegue2		45
+#define kDslG992AnnexCTimeoutDetectCSegue1		46
+#define kDslG992AnnexCAlignmentErrDetected		47
+#define kDslG992AnnexCTimeoutSendRSegueRA		48
+#define kDslG992AnnexCTimeoutSendRSegue4		49
+#define kDslG992AnnexCTimeoutCSegue2Detection	50
+#define kDslG992AnnexCTimeoutCSegue3Detection	51
+/* Progress report for fast retrain */
+
+#define	kG994p1EventToneDetected				54
+#define	kDslG992p2RcvVerifiedBitAndGain         55
+#define	kDslG992p2ProfileChannelResponseCalc    56
+#define kDslG992AnnexCTotalFEXTBits				57
+#define kDslG992AnnexCTotalNEXTBits				58
+#define kDslG992AnnexCTotalFEXTCarrs			59
+#define kDslG992AnnexCTotalNEXTCarrs			60
+
+#define	kDslG992p3ReceivedMsgFmt				61
+#define	kDslG992p3ReceivedMsgPcb				62
+
+#define	kDslG992p3AnnexLMode					63
+
+/* performance monitoring report */
+
+#define	kG992DataRcvDetectFastRSCorrection				70
+#define	kG992DataRcvDetectInterleaveRSCorrection		71
+#define	kG992DataRcvDetectFastCRCError					72
+#define	kG992DataRcvDetectInterleaveCRCError			73
+#define	kG992DataRcvDetectFastRSError					74
+#define	kG992DataRcvDetectInterleaveRSError				75
+#define	kG992DataRcvDetectLOS							76
+#define	kG992DecoderDetectRDI							77
+#define	kG992DataRcvDetectLOSRecovery					78
+#define	kG992AtmDetectHEC								79
+#define	kG992AtmDetectOCD								180
+#define	kG992AtmDetectCD								181
+#define	kG992DecoderDetectRemoteLOS						182
+#define	kG992DecoderDetectRemoteLOSRecovery				183
+#define	kG992DecoderDetectRemoteRDI						184
+#define	kG992DecoderDetectRemoteRDIRecovery				185
+#define	kG992RcvDetectSyncSymbolOffset					186
+#define	kG992Upstream2xIfftDisabled						187
+#if defined(G992P5)
+#define	kDslG992RunAnnexaP3ModeInAnnexaP5	   	        188	 /* run Annex C mode in Annex I compiled codes */
+#else
+#define	kDslG992RunAnnexCModeInAnnexI			        188	 /* run Annex C mode in Annex I compiled codes */
+#endif
+
+/* OLR PHY status */
+
+#define	kG992EventSynchSymbolDetected					189
+#define	kG992EventReverseSynchSymbolDetected			190
+#define	kG992EventL2CReverbSymbolDetected				191
+#define	kG992EventL2CSegueSymbolDetected				192
+
+/* ANNEX_M */
+#define kG992EnableAnnexM                               191
+
+#define kDslAtuChangeTxFilterRequest					192
+
+/* detailed error messages reports */
+
+#define	kDslG992XmtRReverbRAOver4000			80
+#define	kDslG992XmtRReverb5Over4000				81
+#define	kDslG992RcvCSegue2Failed				82
+#define	kDslG992RcvCSegueRAFailed				83
+#define	kDslG992RcvCSegue3Failed				84
+#define	kDslG992RcvShowtimeStartedTooLate		85
+#define	kDslG992XmtRReverb3Over4000				86
+#define	kDslG992RcvFailDetCSegue1InWindow		87
+#define	kDslG992RcvCPilot1Failed				88
+#define	kDslG992RcvCReverb1Failed				89
+#define	kG992ControlAllRateOptionsFailedErr		90
+#define	kG992ControlInvalidRateOptionErr		91
+#define	kDslG992XmtInvalidXmtDErr				92
+#define	kDslG992BitAndGainCalcFailed			93
+#define	kDslG992BitAndGainVerifyFailed			94
+
+#define	kDslT1p413RetrainToUseCorrectRAck		95
+#define	kDslUseAlternateTxFilter				96
+#define	kDslT1p413RetrainToUseCorrectIFFT		97
+
+typedef	long	dslConnectInfoStatusCode;
+#define	kG992p2XmtToneOrderingInfo			0
+#define	kG992p2RcvToneOrderingInfo			1
+#define	kG992p2XmtCodingParamsInfo			2
+#define	kG992p2RcvCodingParamsInfo			3
+#define	kG992p2TrainingRcvCarrEdgeInfo		4
+#define	kG992ShowtimeMonitoringStatus		5
+#define	kG992MessageExchangeRcvInfo			6
+#define	kG992MessageExchangeXmtInfo			7
+#define	kG994MessageExchangeRcvInfo			8
+#define	kG994MessageExchangeXmtInfo			9
+
+#define	kDslATURClockErrorInfo				10
+#define	kDslATURcvPowerInfo					11
+#define	kDslATUAvgLoopAttenuationInfo		12
+#define	kDslHWTimeTrackingResetClockError	13
+#define	kDslHWTimeTrackingClockTweak		14
+#define kDslATUHardwareAGCObtained			15
+#define	kDslTEQCoefInfo						16
+#define	kDslRcvCarrierSNRInfo				17
+#define	kDslMaxReceivableBitRateInfo		18
+#define kDslHWSetDigitalEcUpdateMode		19
+#define kDslHWEnableDigitalECUpdate			20
+#define kDslHWDisableDigitalECUpdate 		21
+#define kDslHWEnableDigitalEC				22
+#define kDslHWSetDigitalEcGainShift			23
+#define kDslHWSetDigitalEcUpdateShift		24
+#define	kDslRcvPsdInfo						25
+#define	kDslHWdcOffsetInfo					26
+#define	kG994SelectedG994p1CarrierIndex		27
+#define	kDslSelectedTimingTone				28
+
+#define	kDslHWEnableAnalogECUpdate			kDslHWSetDigitalEcUpdateMode	
+#define	kDslHWEnableAnalogEC				kDslHWDisableDigitalECUpdate
+
+#define	kG992AocMessageExchangeRcvInfo		29
+#define	kG992AocMessageExchangeXmtInfo		30
+#define	kG992AocBitswapTxStarted			31
+#define	kG992AocBitswapRxStarted			32
+#define	kG992AocBitswapTxCompleted			33
+#define	kG992AocBitswapRxCompleted			34
+#define kDslChannelResponseLog				35
+#define kDslChannelResponseLinear			36
+#define kDslChannelQuietLineNoise			37
+
+#define	kDslATUCXmtPowerCutbackInfo			40
+#define	kDslATURXmtPowerCutbackInfo			41
+#define	kDslATUCXmtPowerInfo				42
+#define	kDslATURXmtPowerInfo				43
+
+#define	kDslFramingModeInfo					50
+#define	kDslG992VendorID					51
+
+#ifdef BCM6348_SRC
+#define kDslHWSetRcvFir2OutputScale			52
+#endif
+
+#define kDslSignalAttenuation               53
+#define kDslAttainableNetDataRate           54
+#define kDslHLinScale                       55
+
+#define	kG992p3XmtCodingParamsInfo			60
+#define	kG992p3RcvCodingParamsInfo			61
+#define	kG992p3PwrStateInfo					62
+#define	kG992PilotToneInfo					63
+
+#define kDslSetPilotEyeDisplay              64
+
+#define kDslAturHwAgcResolutionMask			(0xFFFFFFF8)
+#define kDslAturHwAgcMinGain				((-12)<<4)
+#ifndef BCM6348_SRC
+#define kDslAturHwAgcMaxGain				(30<<4)
+#else
+#define kDslAturHwAgcMaxGain				(36<<4)
+#endif
+
+#define	kDslFrameStatusSend					1
+#define	kDslFrameStatusSendComplete			2
+#define	kDslFrameStatusRcv					3
+#define	kDslFrameStatusReturn				4
+
+typedef struct _dslFramerStatus
+	{
+	dslFramerStatusCode		code;
+	union
+		{
+		long				value;
+		dslErrorCode		error;
+		struct
+			{
+			long	length;
+			uchar	*framePtr;
+			} frame;
+		struct
+			{
+			long	nRxFrameTotal;
+			long	nRxFrameError;
+			long	nTxFrameTotal;
+			} statistic;
+		} param;
+	} dslFramerStatus;
+
+typedef	struct
+	{
+	dslStatusCode					code;
+	union
+		{
+		long						value;
+		dslErrorCode				error;
+		struct
+			{
+			atmStatusCode			code;
+			union
+				{
+				long				value;
+				dslErrorCode		error;
+				struct
+					{
+					long	vci;
+					long	mid;
+					long	aalType;
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	vcId;
+					long	vci;
+					long	aalType;
+					ulong   fwdPeakCellTime;
+					ulong   backPeakCellTime;
+					} vcInfo;
+				struct
+					{
+					long	cellHdr;
+					long	oamCmd;
+					} oamInfo;
+				struct 
+					{
+					void	*pVc;
+					char	*pHdr;
+					void	*cellHdr;
+					void	*cellData;
+					} cellInfo;
+				struct 
+					{
+					long	totalBits;
+					long	errBits;
+					} bertInfo;
+				} param;			
+			} atmStatus;
+#ifdef DSL_PACKET
+		dslFramerStatus		dslPacketStatus;
+#endif
+#ifdef G997_1_FRAMER
+		dslFramerStatus		g997Status;
+#endif
+		struct
+			{
+			dslTrainingStatusCode		code;
+			long						value;
+			} dslTrainingInfo;
+		struct
+			{
+			dslConnectInfoStatusCode	code;
+			long						value;
+			void						*buffPtr;
+			} dslConnectInfo;
+		struct
+			{
+			long						maxMarginCarrier;
+			long						maxSNRMargin;
+			long						minMarginCarrier;
+			long						minSNRMargin;
+			long						avgSNRMargin;
+			long						nCarriers;
+			void						*buffPtr;
+			} dslShowtimeSNRMarginInfo;
+		struct 
+			{
+			long						code;
+			long						vcId;
+			long						timeStamp;
+			} dslFrameInfo;
+#ifdef G997_1
+		struct
+			{
+			long	msgId;
+			long	msgType;
+			char	*dataPtr;
+			} dslClearEocMsg;
+#endif
+		struct
+			{
+			char	*fmt;
+			long	argNum;
+			void	*argPtr;
+			} dslPrintfMsg;
+		struct
+			{
+			ulong	nBits;
+			ulong	nBlocks;
+			ulong	nBitErrors;
+			ulong	nBlockErrors;
+
+			ulong	nAudioBits;
+			ulong	nAudioBlocks;
+			ulong	nAudioSyncErrors;
+			ulong	nAudioBlockErrors;
+			} testResults;
+		struct
+			{
+			ulong	code;
+			uchar	*valuePtr;
+			ulong	length;
+			} dslDataRegister;
+		struct
+			{
+			ulong	code;
+			char	*desc;
+			} dslExternalError;
+		struct
+			{
+			ulong	numberOfCalls;
+			ulong	txSignalChecksum;
+			ulong	rxSignalChecksum;
+			ulong	eyeDataChecksum;
+			} checksums;
+		struct
+			{
+			int		sp;
+			int		argc;
+			int		*argv;
+			int		*stackPtr;
+			int		stackLen;
+			} dslException;
+		struct
+			{
+			ulong	paramId;
+			void	*dataPtr;
+			ulong	dataLen;
+			} dslOemParameter;
+		struct
+			{
+			void	*dataPtr;
+			ulong	dataLen;
+			} dslDataAvail;
+		dslOLRMessage		dslOLRRequest;
+		dslPwrMessage		dslPwrMsg;
+		} param;
+	} dslStatusStruct;
+	
+typedef	void	(SM_DECL *dslStatusHandlerType)		(void *gDslVars, dslStatusStruct*);
+
+
+/*
+**
+**		Command codes 
+**
+*/
+
+typedef long						dslCommandCode;
+#define	kFirstDslCommandCode		256
+#define kDslIdleCmd					(kFirstDslCommandCode + 0)
+#define kDslIdleRcvCmd				(kFirstDslCommandCode + 1)
+#define kDslIdleXmtCmd				(kFirstDslCommandCode + 2)
+#define	kDslStartPhysicalLayerCmd	(kFirstDslCommandCode + 3)
+#define	kDslStartRetrainCmd			(kFirstDslCommandCode + 4)
+#define	kDslSetFrameFunctions		(kFirstDslCommandCode + 5)
+#define kDslSendEocCommand			(kFirstDslCommandCode + 6)
+#define kDslWriteRemoteRegister		(kFirstDslCommandCode + 7)
+#define kDslReadRemoteRegister		(kFirstDslCommandCode + 8)
+#define kDslWriteLocalRegister		(kFirstDslCommandCode + 9)
+#define kDslReadLocalRegister		(kFirstDslCommandCode + 10)
+#define	kDslStoreHardwareAGCCmd		(kFirstDslCommandCode + 11)
+#define kDslSetCommandHandlerCmd	(kFirstDslCommandCode + 12)
+#define kSetLinkLayerStatusHandlerCmd (kFirstDslCommandCode + 13)
+#define kDslSetG997Cmd				(kFirstDslCommandCode + 14)
+#define kDslLoopbackCmd				(kFirstDslCommandCode + 15)
+#define kDslDiagSetupCmd			(kFirstDslCommandCode + 16)
+#define kDslSetDriverCallbackCmd	(kFirstDslCommandCode + 17)
+#define kDslDiagStopLogCmd			(kFirstDslCommandCode + 18)
+#define kDslDiagStartBERT			(kFirstDslCommandCode + 19)
+#define kDslDiagStopBERT			(kFirstDslCommandCode + 20)
+#define kDslPingCmd					(kFirstDslCommandCode + 21)
+#define kDslDyingGaspCmd			(kFirstDslCommandCode + 22)
+#define kDslTestCmd					(kFirstDslCommandCode + 23)
+#define kDslFilterSNRMarginCmd		(kFirstDslCommandCode + 24)
+#define kDslAtmVcMapTableChanged	(kFirstDslCommandCode + 25)
+#define	kDslGetOemDataAddrCmd		(kFirstDslCommandCode + 26)
+#define kDslAtmReportHEC			(kFirstDslCommandCode + 27)
+#define kDslAtmReportCD				(kFirstDslCommandCode + 28)
+#define kDslSetXmtGainCmd			(kFirstDslCommandCode + 29)
+#define kDslSetStatusBufferCmd		(kFirstDslCommandCode + 30)
+#define kDslAfeTestCmd				(kFirstDslCommandCode + 31)
+#define kDslI432ResetCmd			(kFirstDslCommandCode + 32)
+#define kDslSetRcvGainCmd           (kFirstDslCommandCode + 33)
+#define kDslBypassRcvHpfCmd         (kFirstDslCommandCode + 34)
+#define kDslWriteAfeRegCmd          (kFirstDslCommandCode + 35)
+#define kDslReadAfeRegCmd           (kFirstDslCommandCode + 36)
+#define	kDslOLRRequestCmd			(kFirstDslCommandCode + 37)
+#define	kDslOLRResponseCmd			(kFirstDslCommandCode + 38)
+#define kDslI432SetScrambleCmd		(kFirstDslCommandCode + 39)
+#define	kDslPwrMgrCmd				(kFirstDslCommandCode + 40)
+#define kDslAtmGfcMappingCmd		(kFirstDslCommandCode + 41)
+
+#ifdef BCM6348_SRC
+#define kDslEnablePwmSyncClk        (kFirstDslCommandCode + 42)
+#define kDslSetPwmSyncClkFreq       (kFirstDslCommandCode + 43)
+#endif
+
+#define	kG994p1Duplex								1
+#define	kG994p1HalfDuplex  							2
+
+/* Eoc Messages from ATU-C to ATU-R */
+#define kDslEocHoldStateCmd						1
+#define kDslEocReturnToNormalCmd				2
+#define kDslEocPerformSelfTestCmd				3
+#define kDslEocRequestCorruptCRCCmd				4
+#define kDslEocRequestEndCorruptCRCCmd			5
+#define kDslEocNotifyCorruptCRCCmd				6
+#define kDslEocNotifyEndCorruptCRCCmd			7
+#define kDslEocRequestTestParametersUpdateCmd	8
+#define kDslEocGrantPowerDownCmd				9
+#define kDslEocRejectPowerDownCmd				10
+
+/* Eoc Messages  from ATU-R to ATU-C */
+#define kDslEocRequestPowerDownCmd				11
+#define kDslEocDyingGaspCmd						12
+
+/* Clear Eoc Messages  */
+#define kDslClearEocFirstCmd					100
+#define kDslClearEocSendFrame					100
+#define kDslClearEocSendComplete				101
+#define kDslClearEocRcvedFrame					102
+#define kDslClearEocSendComplete2				103
+
+#define kDslClearEocMsgLengthMask				0xFFFF
+#define kDslClearEocMsgNumMask					0xFF0000
+#define kDslClearEocMsgDataVolatileMask			0x1000000
+#define kDslClearEocMsgDataVolatile				kDslClearEocMsgDataVolatileMask
+#define kDslClearEocMsgExtraSendComplete		0x2000000
+
+/* ADSL Link Power States */
+#define kDslPowerFullOn						0
+#define kDslPowerLow						1
+#define kDslPowerIdle						3
+
+/* ATU-R Data Registers */
+#define kDslVendorIDRegister				1
+#define kDslRevisionNumberRegister			2
+#define kDslSerialNumberRegister			3
+#define kDslSelfTestResultsRegister			4
+#define kDslLineAttenuationRegister			5
+#define kDslSnrMarginRegister				6
+#define kDslAturConfigurationRegister		7
+#define kDslLinkStateRegister				8
+
+#define kDslVendorIDRegisterLength			8
+#define kDslRevisionNumberRegisterLength	32
+#define kDslSerialNumberRegisterLength		32
+#define kDslSelfTestResultsRegisterLength	1
+#define kDslLineAttenuationRegisterLength	1
+#define kDslSnrMarginRegisterLength			1
+#define kDslAturConfigurationRegisterLength	30
+#define kDslLinkStateRegisterLength			1
+
+/* Dsl Diags setup flags */
+#define kDslDiagEnableEyeData				1
+#define kDslDiagEnableLogData				2
+
+/* Dsl test commands */
+typedef	long								dslTestCmdType;
+#define	kDslTestBackToNormal				0
+#define kDslTestReverb						1
+#define kDslTestMedley						2
+#define kDslTestToneSelection				3
+#define	kDslTestNoAutoRetrain				4
+#define	kDslTestMarginTweak					5
+#define kDslTestEstimatePllPhase            6
+#define kDslTestReportPllPhaseStatus        7
+#define kDslTestAfeLoopback					8
+#define kDslTestL3							9
+#define kDslTestAdsl2DiagMode				10
+#define kDslTestRetL0						11
+
+/* Xmt gain default setting */
+#define	kDslXmtGainAuto						0x80000000
+
+/* Unit (AFE) test commands */
+#define	kDslAfeTestLoadImage				0
+#define	kDslAfeTestPatternSend				1
+#define	kDslAfeTestLoadImageOnly			2
+#define	kDslAfeTestPhyRun					3
+#define	kDslAfeTestLoadBuffer				4
+
+typedef struct
+	{
+#if defined(G992P1_ANNEX_I) || defined(G992P5) 
+	ushort 				downstreamMinCarr, downstreamMaxCarr;
+#else
+	uchar 				downstreamMinCarr, downstreamMaxCarr;
+#endif
+	uchar           	upstreamMinCarr, upstreamMaxCarr;
+	}carrierInfo;
+
+#if defined(G992P3) && !defined(BCM6348_SRC) 
+#define	FAST_TEXT_TYPE
+#else
+#define	FAST_TEXT_TYPE			FAST_TEXT
+#endif
+
+#if defined(BCM6348_SRC) 
+#define BCM6348_TEMP_MOVE_TO_LMEM 
+#else
+#define BCM6348_TEMP_MOVE_TO_LMEM
+#endif
+
+#ifdef	G992P3
+#define	PRINT_DEBUG_INFO
+#else
+#define	PRINT_DEBUG_INFO
+#endif
+
+#ifdef G992P3
+
+#define		kG992p3MaxSpectBoundsUpSize		16
+#define		kG992p3MaxSpectBoundsDownSize	16
+
+/* G.994 definitions */
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 1 ***/
+
+#define	kG994p1G992p3AnnexASpectrumBoundsUpstream	0x01
+#define	kG994p1G992p3AnnexASpectrumShapingUpstream	0x02
+#define	kG994p1G992p3AnnexASpectrumBoundsDownstream	0x04
+#define	kG994p1G992p3AnnexASpectrumShapingDownstream	0x08
+#define	kG994p1G992p3AnnexATxImageAboveNyquistFreq	0x10
+#define	kG994p1G992p3AnnexLReachExtended			0x20
+#define kG994p1G992p3AnnexMSubModePSDMasks          0x20
+
+#define	kG994p1G992p3AnnexLUpNarrowband				0x02
+#define	kG994p1G992p3AnnexLUpWideband				0x01
+#define	kG994p1G992p3AnnexLDownNonoverlap			0x01
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 2 ***/
+
+#define	kG994p1G992p3AnnexADownOverheadDataRate		0x01
+#define	kG994p1G992p3AnnexAUpOverheadDataRate		0x02
+#define	kG994p1G992p3AnnexAMaxNumberDownTPSTC		0x04
+#define	kG994p1G992p3AnnexAMaxNumberUpTPSTC			0x08
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 3,5,7,9 ***/
+
+#define	kG994p1G992p3AnnexADownSTM_TPS_TC			0x01
+#define	kG994p1G992p3AnnexAUpSTM_TPS_TC				0x02
+#define	kG994p1G992p3AnnexADownATM_TPS_TC			0x04
+#define	kG994p1G992p3AnnexAUpATM_TPS_TC				0x08
+#define	kG994p1G992p3AnnexADownPTM_TPS_TC			0x10
+#define	kG994p1G992p3AnnexAUpPTM_TPS_TC				0x20
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 4,6,8,10 ***/
+
+#define	kG994p1G992p3AnnexADownPMS_TC_Latency		0x01
+#define	kG994p1G992p3AnnexAUpPMS_TC_Latency			0x02
+
+/*** 
+ *   TSSI
+ *
+ *   TSSI information is specified in 2 parts: subcarrier index,
+ *   tssi value, and an indication of whether or no the tone specified
+ *   is part of the supported set.
+ *
+ *   The subcarrier index information is currently stored in the
+ *   dsSubcarrierIndex array defined below. The tssi value are stored
+ *   in the dsLog_tss array.
+ *
+ *   The subcarrier index information only occupies the lower 12 bits
+ *   of the available 16 bits (short type). Therefore, we will pack the
+ *   supported set information in bit 15.
+ */
+#define kG992DsSubCarrierIndexMask          (0x0fff)   /* AND mask to ectract ds subcarrier index */
+#define kG992DsSubCarrierSuppSetMask        (0x8000)   /* AND mask to extract supported set indication */
+
+#define G992GetDsSubCarrierIndex(arg)               ((arg)  & kG992DsSubCarrierIndexMask)
+#define G992GetDsSubCarrierSuppSetIndication(arg)   (((arg) & kG992DsSubCarrierSuppSetMask) >> 15)
+
+/* Caution: Do not change anything in this structure definition, including associated constant */
+/* This structure definition is used only by the driver and any change impose incompatibility issue in driver */
+/* The structure following this structure (g992p3PhyDataPumpCapabilities) can be changed in PHY application */
+
+typedef struct
+	{
+	Boolean				rcvNTREnabled, shortInitEnabled, diagnosticsModeEnabled;
+	
+	char				featureSpectrum, featureOverhead;
+	char				featureTPS_TC[4], featurePMS_TC[4];
+	
+	short				rcvNOMPSDus, rcvMAXNOMPSDus, rcvMAXNOMATPus;
+	short				usSubcarrierIndex[kG992p3MaxSpectBoundsUpSize],
+						usLog_tss[kG992p3MaxSpectBoundsUpSize];
+	short				numUsSubcarrier;
+	short				rcvNOMPSDds, rcvMAXNOMPSDds, rcvMAXNOMATPds;
+	short				dsSubcarrierIndex[kG992p3MaxSpectBoundsDownSize],
+						dsLog_tss[kG992p3MaxSpectBoundsDownSize];
+	short				numDsSubcarrier;
+	uchar				sizeIDFT, fillIFFT;
+	uchar				readsl2Upstream, readsl2Downstream;
+	uchar				minDownOverheadDataRate, minUpOverheadDataRate;
+	uchar				maxDownSTM_TPSTC, maxDownATM_TPSTC, maxDownPTM_TPSTC;
+	uchar				maxUpSTM_TPSTC, maxUpATM_TPSTC, maxUpPTM_TPSTC;
+
+	short				minDownSTM_TPS_TC[4], maxDownSTM_TPS_TC[4],
+						minRevDownSTM_TPS_TC[4], maxDelayDownSTM_TPS_TC[4];
+	uchar				maxErrorDownSTM_TPS_TC[4], minINPDownSTM_TPS_TC[4];
+	short				minUpSTM_TPS_TC[4], maxUpSTM_TPS_TC[4],
+						minRevUpSTM_TPS_TC[4], maxDelayUpSTM_TPS_TC[4];
+	uchar				maxErrorUpSTM_TPS_TC[4], minINPUpSTM_TPS_TC[4];
+
+	short				maxDownPMS_TC_Latency[4], maxUpPMS_TC_Latency[4];
+	short				maxDownR_PMS_TC_Latency[4], maxDownD_PMS_TC_Latency[4];
+	short				maxUpR_PMS_TC_Latency[4], maxUpD_PMS_TC_Latency[4];
+
+	short				minDownATM_TPS_TC[4], maxDownATM_TPS_TC[4],
+						minRevDownATM_TPS_TC[4], maxDelayDownATM_TPS_TC[4];
+	uchar				maxErrorDownATM_TPS_TC[4], minINPDownATM_TPS_TC[4];
+	short				minUpATM_TPS_TC[4], maxUpATM_TPS_TC[4],
+						minRevUpATM_TPS_TC[4], maxDelayUpATM_TPS_TC[4];
+	uchar				maxErrorUpATM_TPS_TC[4], minINPUpATM_TPS_TC[4];
+
+	short				minDownPTM_TPS_TC[4], maxDownPTM_TPS_TC[4],
+						minRevDownPTM_TPS_TC[4], maxDelayDownPTM_TPS_TC[4];
+	uchar				maxErrorDownPTM_TPS_TC[4], minINPDownPTM_TPS_TC[4];
+	short				minUpPTM_TPS_TC[4], maxUpPTM_TPS_TC[4],
+						minRevUpPTM_TPS_TC[4], maxDelayUpPTM_TPS_TC[4];
+	uchar				maxErrorUpPTM_TPS_TC[4], minINPUpPTM_TPS_TC[4];
+
+    ushort              subModePSDMasks;
+	} g992p3DataPumpCapabilities;
+
+#define		kG992p3p5MaxSpectBoundsUpSize		16
+#define		kG992p3p5MaxSpectBoundsDownSize		32
+
+typedef struct
+	{
+	Boolean				rcvNTREnabled, shortInitEnabled, diagnosticsModeEnabled;
+	
+	char				featureSpectrum, featureOverhead;
+	char				featureTPS_TC[4], featurePMS_TC[4];
+	
+	short				rcvNOMPSDus, rcvMAXNOMPSDus, rcvMAXNOMATPus;
+	short				usSubcarrierIndex[kG992p3p5MaxSpectBoundsUpSize],
+						usLog_tss[kG992p3p5MaxSpectBoundsUpSize];
+	short				numUsSubcarrier;
+	short				rcvNOMPSDds, rcvMAXNOMPSDds, rcvMAXNOMATPds;
+	short				dsSubcarrierIndex[kG992p3p5MaxSpectBoundsDownSize],
+						dsLog_tss[kG992p3p5MaxSpectBoundsDownSize];
+	short				numDsSubcarrier;
+	uchar				sizeIDFT, fillIFFT;
+	uchar				readsl2Upstream, readsl2Downstream;
+	uchar				minDownOverheadDataRate, minUpOverheadDataRate;
+	uchar				maxDownSTM_TPSTC, maxDownATM_TPSTC, maxDownPTM_TPSTC;
+	uchar				maxUpSTM_TPSTC, maxUpATM_TPSTC, maxUpPTM_TPSTC;
+
+	short				minDownSTM_TPS_TC[4], maxDownSTM_TPS_TC[4],
+						minRevDownSTM_TPS_TC[4], maxDelayDownSTM_TPS_TC[4];
+	uchar				maxErrorDownSTM_TPS_TC[4], minINPDownSTM_TPS_TC[4];
+	short				minUpSTM_TPS_TC[4], maxUpSTM_TPS_TC[4],
+						minRevUpSTM_TPS_TC[4], maxDelayUpSTM_TPS_TC[4];
+	uchar				maxErrorUpSTM_TPS_TC[4], minINPUpSTM_TPS_TC[4];
+
+	short				maxDownPMS_TC_Latency[4], maxUpPMS_TC_Latency[4];
+	short				maxDownR_PMS_TC_Latency[4], maxDownD_PMS_TC_Latency[4];
+	short				maxUpR_PMS_TC_Latency[4], maxUpD_PMS_TC_Latency[4];
+
+	short				minDownATM_TPS_TC[4], maxDownATM_TPS_TC[4],
+						minRevDownATM_TPS_TC[4], maxDelayDownATM_TPS_TC[4];
+	uchar				maxErrorDownATM_TPS_TC[4], minINPDownATM_TPS_TC[4];
+	short				minUpATM_TPS_TC[4], maxUpATM_TPS_TC[4],
+						minRevUpATM_TPS_TC[4], maxDelayUpATM_TPS_TC[4];
+	uchar				maxErrorUpATM_TPS_TC[4], minINPUpATM_TPS_TC[4];
+
+	short				minDownPTM_TPS_TC[4], maxDownPTM_TPS_TC[4],
+						minRevDownPTM_TPS_TC[4], maxDelayDownPTM_TPS_TC[4];
+	uchar				maxErrorDownPTM_TPS_TC[4], minINPDownPTM_TPS_TC[4];
+	short				minUpPTM_TPS_TC[4], maxUpPTM_TPS_TC[4],
+						minRevUpPTM_TPS_TC[4], maxDelayUpPTM_TPS_TC[4];
+	uchar				maxErrorUpPTM_TPS_TC[4], minINPUpPTM_TPS_TC[4];
+
+    ushort              subModePSDMasks;
+	} g992p3PhyDataPumpCapabilities;
+#endif
+
+typedef struct
+	{
+	dslModulationType	modulations;
+	bitMap				auxFeatures;
+	bitMap          	features;	
+	bitMap				demodCapabilities;
+	bitMap				demodCapabilities2;
+	ushort				noiseMargin;		/* Q4 dB */
+#ifdef G992_ATUC
+	short				xmtRSf, xmtRS, xmtS, xmtD;
+	short				rcvRSf, rcvRS, rcvS, rcvD;
+#endif	
+#ifdef G992P1_ANNEX_A	
+	bitMap          	subChannelInfo;
+	carrierInfo     	carrierInfoG992p1;
+#endif
+#ifdef G992P1_ANNEX_B	
+	bitMap          	subChannelInfoAnnexB;
+	carrierInfo     	carrierInfoG992p1AnnexB;
+#endif
+#ifdef G992_ANNEXC	
+	bitMap          	subChannelInfoAnnexC;
+	carrierInfo     	carrierInfoG992p1AnnexC;
+#endif
+#if defined(G992P1_ANNEX_I)
+	bitMap          	subChannelInfoAnnexI;
+	carrierInfo     	carrierInfoG992p1AnnexI;
+#endif
+#ifdef G992P5
+	bitMap          	subChannelInfop5;
+	carrierInfo     	carrierInfoG992p5;
+#endif
+#if defined(G992P2) || (defined(G992P1_ANNEX_A) && defined(G992P1_ANNEX_A_USED_FOR_G992P2))
+	carrierInfo     	carrierInfoG992p2;
+#endif
+	ushort           	maxDataRate;
+	uchar           	minDataRate;	     
+#ifdef G992P3
+	g992p3DataPumpCapabilities	*carrierInfoG992p3AnnexA;
+#endif
+#ifdef G992P5
+	g992p3DataPumpCapabilities	*carrierInfoG992p5AnnexA;
+#endif
+	} dslDataPumpCapabilities;
+		
+struct __dslCommandStruct;
+typedef	Boolean	(*dslCommandHandlerType)	(void *gDslVars, struct __dslCommandStruct*);
+typedef	struct __dslCommandStruct
+	{
+	dslCommandCode						command;
+	union
+		{
+		long							value;
+		Boolean							flag;
+		struct
+			{
+			dslTestCmdType				type;
+			union
+				{
+				struct
+					{
+					ulong				xmtStartTone, xmtNumOfTones;
+					ulong				rcvStartTone, rcvNumOfTones;
+					uchar				*xmtMap, *rcvMap;
+					} toneSelectSpec;
+				struct
+					{
+					long				extraPowerRequestQ4dB;
+					long				numOfCarriers;
+					char				*marginTweakTableQ4dB;
+					} marginTweakSpec;
+				} param;
+			} dslTestSpec;
+		struct
+			{
+			dslDirectionType			direction;			
+			dslDataPumpCapabilities		capabilities;
+			} dslModeSpec;
+		struct
+			{
+			bitMap						setup;			
+			ulong						eyeConstIndex1;
+			ulong						eyeConstIndex2;
+			ulong						logTime;
+			} dslDiagSpec;
+		struct
+			{
+			void						*pBuf;			
+			ulong						bufSize;
+			} dslStatusBufSpec;
+		struct
+			{
+			ulong						type;
+			void						*afeParamPtr;
+			ulong						afeParamSize;
+			void						*imagePtr;
+			ulong						imageSize;
+			} dslAfeTestSpec;
+		struct
+			{
+			dslLinkLayerType			type;
+			bitMap						setup;
+			union
+				{
+				struct
+					{
+					dataRateMap					rxDataRate;
+					dataRateMap					txDataRate;
+					long						rtDelayQ4ms;				
+					ulong						rxBufNum;
+					ulong						rxCellsInBuf;
+					ulong						rxPacketNum;
+					dslFrameHandlerType			rxIndicateHandlerPtr;
+					dslFrameHandlerType 		txCompleteHandlerPtr;
+					dslPhyInitType				atmPhyInitPtr;
+					} atmLinkSpec;
+				struct
+					{
+					dslHeaderHandlerType		rxHeaderHandlerPtr;
+					dslRxFrameBufferHandlerType	rxDataHandlerPtr;
+					dslTxFrameBufferHandlerType txHandlerPtr;
+					} atmPhyLinkSpec;
+#ifdef DSL_PACKET
+				struct
+					{
+					ulong						rxBufNum;
+					ulong						rxBufSize;
+					ulong						rxPacketNum;
+					dslFrameHandlerType			rxIndicateHandlerPtr;
+					dslFrameHandlerType 		txCompleteHandlerPtr;
+					dslPacketPhyInitType		dslPhyInitPtr;
+					} dslPacketLinkSpec;
+				dslPacketPhyFunctions			dslPacketPhyLinkSpec;
+#endif
+				struct
+					{
+					txDataHandlerType			txDataHandlerPtr;
+					rxDataHandlerType			rxDataHandlerPtr;
+					} nullLinkSpec;
+				} param;
+			} dslLinkLayerSpec;
+#ifdef G997_1
+#ifdef G997_1_FRAMER
+		struct
+			{
+			bitMap						setup;
+			ulong						rxBufNum;
+			ulong						rxBufSize;
+			ulong						rxPacketNum;
+			dslFrameHandlerType			rxIndicateHandlerPtr;
+			dslFrameHandlerType 		txCompleteHandlerPtr;
+			} dslG997Cmd;
+#endif
+		struct
+			{
+			long	msgId;
+			long	msgType;
+			char	*dataPtr;
+			} dslClearEocMsg;
+#endif
+		struct
+			{
+			ulong						code;
+			uchar						*valuePtr;
+			ulong						length;
+			} dslDataRegister;
+		union
+			{
+			dslStatusHandlerType		statusHandlerPtr;
+			dslCommandHandlerType		commandHandlerPtr;
+			eyeHandlerType				eyeHandlerPtr;
+			logHandlerType				logHandlerPtr;
+#if defined(DEBUG_DATA_HANDLER)
+            debugDataHandlerType        debugDataHandlerPtr;
+#endif
+			dslFrameHandlerType			rxIndicateHandlerPtr;
+			dslFrameHandlerType			txCompleteHandlerPtr;
+			dslDriverCallbackType		driverCallback;
+			} handlerSpec;
+#if !defined(CHIP_SRC) || defined(DSL_FRAME_FUNCTIONS)
+		dslFrameFunctions				DslFunctions;
+#endif
+		dslOLRMessage					dslOLRRequest;
+		dslPwrMessage					dslPwrMsg;
+		} param;
+	} dslCommandStruct;
+	
+
+
+
+typedef struct
+	{
+	dslCommandHandlerType			linkCommandHandlerPtr;
+	timerHandlerType				linkTimerHandlerPtr;
+	dslLinkCloseHandlerType			linkCloseHandlerPtr;
+
+	dslFrameHandlerType				linkSendHandlerPtr;
+	dslFrameHandlerType				linkReturnHandlerPtr;
+
+	dslVcAllocateHandlerType		linkVcAllocateHandlerPtr;
+	dslVcFreeHandlerType			linkVcFreeHandlerPtr;
+	dslVcActivateHandlerType		linkVcActivateHandlerPtr;
+	dslVcDeactivateHandlerType		linkVcDeactivateHandlerPtr;
+	dslVcConfigureHandlerType		linkVcConfigureHandlerPtr;
+
+	dslLinkVc2IdHandlerType			linkVc2IdHandlerPtr;
+	dslLinkVcId2VcHandlerType		linkVcId2VcHandlerPtr;
+	dslGetFramePoolHandlerType		linkGetFramePoolHandlerPtr;
+
+#ifndef ADSLCORE_ONLY
+	dslHeaderHandlerType			linkRxCellHeaderHandlerPtr;
+	dslRxFrameBufferHandlerType		linkRxCellDataHandlerPtr;
+	dslTxFrameBufferHandlerType		linkTxCellHandlerPtr;
+#endif
+
+	txDataHandlerType				linkTxDataHandlerPtr;
+	rxDataHandlerType				linkRxDataHandlerPtr;
+	} linkLayerFunctions;
+
+#ifndef ADSLCORE_ONLY
+
+#define	 LinkLayerAssignFunctions( var, name_prefix )	do {					\
+	(var).linkCommandHandlerPtr = name_prefix##CommandHandler;					\
+	(var).linkTimerHandlerPtr	= name_prefix##TimerHandler;					\
+	(var).linkCloseHandlerPtr	= name_prefix##CloseHandler;					\
+																				\
+	(var).linkSendHandlerPtr	= name_prefix##SendFrameHandler;				\
+	(var).linkReturnHandlerPtr	= name_prefix##ReturnFrameHandler;				\
+																				\
+	(var).linkVcAllocateHandlerPtr		= name_prefix##VcAllocateHandler;		\
+	(var).linkVcFreeHandlerPtr			= name_prefix##VcFreeHandler;			\
+	(var).linkVcActivateHandlerPtr		= name_prefix##VcActivateHandler;		\
+	(var).linkVcDeactivateHandlerPtr	= name_prefix##VcDeactivateHandler;		\
+	(var).linkVcConfigureHandlerPtr		= name_prefix##VcConfigureHandler;		\
+																				\
+	(var).linkVc2IdHandlerPtr			= name_prefix##Vc2IdHandler;			\
+	(var).linkVcId2VcHandlerPtr			= name_prefix##VcId2VcHandler;			\
+	(var).linkGetFramePoolHandlerPtr	= name_prefix##GetFramePoolHandler;		\
+																				\
+	(var).linkRxCellHeaderHandlerPtr	= name_prefix##RxCellHeaderHandler;		\
+	(var).linkRxCellDataHandlerPtr		= name_prefix##RxCellDataHandler;		\
+	(var).linkTxCellHandlerPtr			= name_prefix##TxCellHandler;			\
+																				\
+	(var).linkTxDataHandlerPtr	= name_prefix##TxDataHandler;					\
+	(var).linkRxDataHandlerPtr	= name_prefix##RxDataHandler;					\
+} while (0)
+
+#else
+
+#define	 LinkLayerAssignFunctions( var, name_prefix )	do {					\
+	(var).linkCommandHandlerPtr = name_prefix##CommandHandler;					\
+	(var).linkTimerHandlerPtr	= name_prefix##TimerHandler;					\
+	(var).linkCloseHandlerPtr	= name_prefix##CloseHandler;					\
+																				\
+	(var).linkSendHandlerPtr	= name_prefix##SendFrameHandler;				\
+	(var).linkReturnHandlerPtr	= name_prefix##ReturnFrameHandler;				\
+																				\
+	(var).linkVcAllocateHandlerPtr		= name_prefix##VcAllocateHandler;		\
+	(var).linkVcFreeHandlerPtr			= name_prefix##VcFreeHandler;			\
+	(var).linkVcActivateHandlerPtr		= name_prefix##VcActivateHandler;		\
+	(var).linkVcDeactivateHandlerPtr	= name_prefix##VcDeactivateHandler;		\
+	(var).linkVcConfigureHandlerPtr		= name_prefix##VcConfigureHandler;		\
+																				\
+	(var).linkVc2IdHandlerPtr			= name_prefix##Vc2IdHandler;			\
+	(var).linkVcId2VcHandlerPtr			= name_prefix##VcId2VcHandler;			\
+	(var).linkGetFramePoolHandlerPtr	= name_prefix##GetFramePoolHandler;		\
+																				\
+	(var).linkTxDataHandlerPtr	= name_prefix##TxDataHandler;					\
+	(var).linkRxDataHandlerPtr	= name_prefix##RxDataHandler;					\
+} while (0)
+
+#endif
+
+typedef struct
+	{
+	dslFrameHandlerType				rxIndicateHandlerPtr;
+	dslFrameHandlerType				txCompleteHandlerPtr;
+	dslStatusHandlerType			statusHandlerPtr;
+	} upperLayerFunctions;
+
+
+/*
+ * Debug data
+ */
+#define	kDslFirstDebugData					1000
+#define	kDslXmtPerSymTimeCompData			(kDslFirstDebugData + 0)
+#define	kDslRcvPerSymTimeCompData			(kDslFirstDebugData + 1)
+#define	kDslXmtAccTimeCompData				(kDslFirstDebugData + 2)
+#define	kDslRcvAccTimeCompData				(kDslFirstDebugData + 3)
+#define	kDslRcvPilotToneData				(kDslFirstDebugData + 4)
+#define	kDslTEQCoefData						(kDslFirstDebugData + 5)
+#define	kDslTEQInputData					(kDslFirstDebugData + 6)
+#define	kDslTEQOutputData					(kDslFirstDebugData + 7)
+#define	kDslRcvFFTInputData					(kDslFirstDebugData + 8)
+#define	kDslRcvFFTOutputData				(kDslFirstDebugData + 9)
+#define	kDslRcvCarrierSNRData				(kDslFirstDebugData + 10)
+#define	kDslXmtToneOrderingData				(kDslFirstDebugData + 11)
+#define	kDslRcvToneOrderingData				(kDslFirstDebugData + 12)
+#define	kDslXmtGainData						(kDslFirstDebugData + 13)
+#define	kDslRcvGainData						(kDslFirstDebugData + 14)
+#define	kDslMseData							(kDslFirstDebugData + 15)
+#define	kDslFEQOutErrData					(kDslFirstDebugData + 16)
+#define kDslFEQCoefData 					(kDslFirstDebugData + 17)
+#define kDslShowtimeMseData					(kDslFirstDebugData + 18)
+#define kDslTimeEstimationHWPhaseTweak		(kDslFirstDebugData + 24)
+#define	kDslSlicerInput						(kDslFirstDebugData + 40)
+#define	kDslXmtConstellations				(kDslFirstDebugData + 41)
+#define kDslSnr1ShiftData					(kDslFirstDebugData + 50)
+#define kDslSnr1InputData					(kDslFirstDebugData + 51)
+#define kDslSnr1ReverbAvgData				(kDslFirstDebugData + 52)
+#define kDslAnnexCFextSnrData				(kDslFirstDebugData + 53)
+#define kDslAnnexCNextSnrData				(kDslFirstDebugData + 54)
+#define	kG994p1OutputXmtSample				(kDslFirstDebugData + 100)
+#define	kG994p1OutputMicroBit				(kDslFirstDebugData + 101)
+#define	kG994p1OutputBit					(kDslFirstDebugData + 102)
+#define	kG994p1OutputTimer					(kDslFirstDebugData + 103)
+
+/****************************************************************************/
+/*	2.	Constant definitions.												*/
+/*																			*/
+/*	2.1	Defininitive constants												*/
+/****************************************************************************/
+
+/* dslDirectionType */
+
+#define	kATU_C		0
+#define	kATU_R		1
+
+/* ATM setup maps	*/
+
+#define	kAtmCallMgrEnabled			0x00000001		/* Bit 0  */
+#define	kAtmAAL1FecEnabledMask		0x00000006		/* Bit 1  */
+#define	kAtmAAL1HiDelayFecEnabled	0x00000002		/* Bit 2  */
+#define	kAtmAAL1LoDelayFecEnabled	0x00000004		/* Bit 3  */
+
+/* dslLinkLayerType */
+
+#define kNoDataLink			0
+#define kAtmLink			0x00000001
+#define kAtmPhyLink			0x00000002
+#define kDslPacketLink		0x00000003
+#define kDslPacketPhyLink	0x00000004
+
+/* dslModulationType */
+#define	kNoCommonModulation	0x00000000				
+#define	kG994p1				0x00000020				/* G.994.1 or G.hs */
+#define	kT1p413				0x00000040				/* T1.413 handshaking */
+#define	kG992p1AnnexA		0x00000001				/* G.992.1 or G.dmt Annex A */
+#define	kG992p1AnnexB		0x00000002				/* G.992.1 or G.dmt Annex B */
+#define	kG992p1AnnexC		0x00000004				/* G.992.1 or G.dmt Annex C */
+#define	kG992p2AnnexAB		0x00000008				/* G.992.2 or G.lite Annex A/B */
+#define	kG992p2AnnexC		0x00000010				/* G.992.2 or G.lite Annex C */
+#define	kG992p3AnnexA		0x00000100				/* G.992.3 or G.DMTbis Annex A */
+#define	kG992p3AnnexB		0x00000200				/* G.992.3 or G.DMTbis Annex A */
+#define	kG992p1AnnexI		0x00000400				/* G.992.1 Annex I */
+#define kG992p5AnnexA       0x00010000              /* G.992.5 Annex A */
+#define kG992p5AnnexB       0x00020000              /* G.992.5 Annex B */
+#define kG992p5AnnexI       0x00040000              /* G.992.5 Annex I */
+#define kG992p3AnnexM       0x00080000              /* G.992.3 Annex M */
+#define kG992p5AnnexM       0x01000000              /* G.992.5 Annex M */
+
+/* demodCapabilities bitmap */
+#define	kEchoCancellorEnabled					0x00000001
+#define	kSoftwareTimeErrorDetectionEnabled		0x00000002
+#define	kSoftwareTimeTrackingEnabled			0x00000004
+#define kDslTrellisEnabled			            0x00000008
+#define	kHardwareTimeTrackingEnabled			0x00000010
+#define kHardwareAGCEnabled						0x00000020
+#define kDigitalEchoCancellorEnabled			0x00000040
+#define kReedSolomonCodingEnabled				0x00000080
+#define kAnalogEchoCancellorEnabled				0x00000100
+#define	kT1p413Issue1SingleByteSymMode			0x00000200
+#define	kDslAturXmtPowerCutbackEnabled			0x00000400
+#ifdef G992_ANNEXC_LONG_REACH
+#define kDslAnnexCPilot48                       0x00000800
+#define kDslAnnexCReverb33_63                   0x00001000
+#endif
+#ifdef G992_ANNEXC
+#define kDslCentilliumCRCWorkAroundEnabled		0x00002000
+#else
+#define kDslEnableRoundUpDSLoopAttn		        0x00002000
+#endif
+#define	kDslBitSwapEnabled						0x00004000
+#define	kDslADILowRateOptionFixDisabled			0x00008000
+#define	kDslAnymediaGSPNCrcFixEnabled			0x00010000
+#define	kDslMultiModesPreferT1p413				0x00020000
+#define	kDslT1p413UseRAck1Only					0x00040000
+#define	kDslUE9000ADI918FECFixEnabled			0x00080000
+#define	kDslG994AnnexAMultimodeEnabled			0x00100000
+#define	kDslATUCXmtPowerMinimizeEnabled			0x00200000
+#define	kDropOnDataErrorsDisabled			    0x00400000
+#define	kDslSRAEnabled						    0x00800000
+
+#define	kDslT1p413HigherToneLevelNeeded			0x01000000
+#define	kDslT1p413SubsampleAlignmentEnabled		0x02000000
+#define	kDslT1p413DisableUpstream2xIfftMode		0x04000000
+
+/* test mode related demodCapabilities, for internal use only */
+#define	kDslTestDemodCapMask					0xF8000000
+#define	kDslSendReverbModeEnabled				0x10000000
+#define	kDslSendMedleyModeEnabled				0x20000000
+#define	kDslAutoRetrainDisabled					0x40000000
+#define kDslPllWorkaroundEnabled                0x80000000
+#define kDslAfeLoopbackModeEnabled              0x08000000
+
+/* demodCapabilities bitmap2 */
+
+#define kDslAnnexCProfile1	    			    0x00000001
+#define kDslAnnexCProfile2	    			    0x00000002
+#define kDslAnnexCProfile3	    			    0x00000004
+#define kDslAnnexCProfile4	    			    0x00000008
+#define kDslAnnexCProfile5	    			    0x00000010
+#define kDslAnnexCProfile6	    			    0x00000020
+#define kDslAnnexCPilot64			   	        0x00000040
+#define kDslAnnexCPilot48                       0x00000080
+#define kDslAnnexCPilot32			   	        0x00000100
+#define kDslAnnexCPilot16			   	        0x00000200
+#define kDslAnnexCA48B48			   		    0x00000400
+#define kDslAnnexCA24B24			    	    0x00000800
+#define kDslAnnexCReverb33_63                   0x00001000
+#define kDslAnnexCCReverb6_31	  		        0x00002000
+
+#define kDslAnnexIShapedSSVI                    0x00004000
+#define kDslAnnexIFlatSSVI                      0x00008000
+
+#define kDslAnnexIPilot64			   	        0x00010000
+#define kDslAnnexIA48B48			   		    0x00020000
+#define kDslAnnexIPilot128			   	        0x00040000
+#define kDslAnnexIPilot96			   	        0x00080000
+
+/* Features bitmap */
+#define	kG992p2RACK1   						    0x00000001
+#define	kG992p2RACK2							0x00000002
+#define	kG992p2DBM								0x00000004
+#define	kG992p2FastRetrain						0x00000008
+#define	kG992p2RS16								0x00000010
+#define	kG992p2ClearEOCOAM						0x00000020
+#define	kG992NTREnabled							0x00000040
+#define	kG992p2EraseAllStoredProfiles			0x00000080
+#define kG992p2FeaturesNPar2Mask                0x0000003B
+#define kG992p2FeaturesNPar2Shift                        0
+
+#define kG992p1RACK1                            0x00000100
+#define kG992p1RACK2                            0x00000200
+#define kG992p1STM                              0x00000800
+#define kG992p1ATM                              0x00001000
+#define	kG992p1ClearEOCOAM						0x00002000
+#define kG992p1FeaturesNPar2Mask                0x00003B00
+#define kG992p1FeaturesNPar2Shift                        8	
+#define kG992p1DualLatencyUpstream				0x00004000
+#define kG992p1DualLatencyDownstream			0x00008000
+#define kG992p1HigherBitRates					0x40000000
+
+#if defined(G992P1_ANNEX_I)
+#define kG992p1HigherBitRates1over3				0x80000000
+#define kG992p1AnnexIShapedSSVI                 0x00000001
+#define kG992p1AnnexIFlatSSVI                   0x00000002
+#define kG992p1AnnexIPilotFlag			   		0x00000008
+#define kG992p1AnnexIPilot64			   		0x00000001
+#define kG992p1AnnexIPilot128			   		0x00000004
+#define kG992p1AnnexIPilot96			   		0x00000008
+#define kG992p1AnnexIPilotA48B48                0x00000010
+#endif
+
+#define kG992p1AnnexBRACK1                      0x00010000
+#define kG992p1AnnexBRACK2                      0x00020000
+#define kG992p1AnnexBUpstreamTones1to32			0x00040000
+#define kG992p1AnnexBSTM                        0x00080000
+#define kG992p1AnnexBATM                        0x00100000
+#define	kG992p1AnnexBClearEOCOAM				0x00200000
+#define kG992p1AnnexBFeaturesNPar2Mask          0x003F0000
+#define kG992p1AnnexBFeaturesNPar2Shift                 16	
+
+#define kG992p1AnnexCRACK1                      0x01000000
+#define kG992p1AnnexCRACK2                      0x02000000
+#define kG992p1AnnexCDBM						0x04000000
+#define kG992p1AnnexCSTM                        0x08000000
+#define kG992p1AnnexCATM                        0x10000000
+#define	kG992p1AnnexCClearEOCOAM				0x20000000
+#define kG992p1AnnexCFeaturesNPar2Mask          0x3F000000
+#define kG992p1AnnexCFeaturesNPar2Shift                 24	
+
+#define kG992p1HigherBitRates1over3				0x80000000
+
+/* auxFeatures bitmap */
+#define	kG994p1PreferToExchangeCaps				0x00000001
+#define	kG994p1PreferToDecideMode				0x00000002
+#define	kG994p1PreferToMPMode				    0x00000004
+#define	kAfePwmSyncClockShift					3
+#define	kAfePwmSyncClockMask					(0xF << kAfePwmSyncClockShift)
+#define	AfePwmSyncClockEnabled(val)				(((val) & kAfePwmSyncClockMask) != 0)
+#define	AfePwmGetSyncClockFreq(val)				((((val) & kAfePwmSyncClockMask) >> kAfePwmSyncClockShift) - 1)
+#define	AfePwmSetSyncClockFreq(val,freq)		((val) |= ((((freq)+1) << kAfePwmSyncClockShift) & kAfePwmSyncClockMask))
+
+/* SubChannel Info bitMap for G992p1 */
+#define kSubChannelASODownstream                0x00000001
+#define kSubChannelAS1Downstream                0x00000002
+#define kSubChannelAS2Downstream                0x00000004
+#define kSubChannelAS3Downstream                0x00000008
+#define kSubChannelLSODownstream                0x00000010
+#define kSubChannelLS1Downstream                0x00000020
+#define kSubChannelLS2Downstream                0x00000040
+#define kSubChannelLS0Upstream                  0x00000080
+#define kSubChannelLS1Upstream                  0x00000100
+#define kSubChannelLS2Upstream                  0x00000200
+#define kSubChannelInfoOctet1Mask               0x0000001F
+#define kSubChannelInfoOctet2Mask               0x000003E0
+#define kSubChannelInfoOctet1Shift              		 0	
+#define kSubChannelInfoOctet2Shift              		 5	
+
+/****************************************************************************/
+/*	3.	Interface functions.												*/
+/*																			*/
+/****************************************************************************/
+
+#ifdef G992P1
+#if defined(G992P1_ANNEX_I2X) || defined(G992P5) 
+/* lke */
+#define	kDslSamplingFreq			4416000
+#define	kDslMaxFFTSize			 	1024	
+#define	kDslMaxFFTSizeShift			10
+#elif defined(G992P1_ANNEX_I4X)
+#define	kDslSamplingFreq			8832000
+#define	kDslMaxFFTSize			 	2048	
+#define	kDslMaxFFTSizeShift			11
+#elif defined(G992P1_ANNEX_I8X)
+#define	kDslSamplingFreq			17664000
+#define	kDslMaxFFTSize			 	4096	
+#define	kDslMaxFFTSizeShift			12
+#else
+#define	kDslSamplingFreq			2208000
+#define	kDslMaxFFTSize				512
+#define	kDslMaxFFTSizeShift			9
+#endif
+#else
+#define	kDslSamplingFreq			1104000
+#define	kDslMaxFFTSize				256
+#define	kDslMaxFFTSizeShift			8
+#endif
+
+#if defined(G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ)
+#define kDslATURUpstreamSamplingFreq    276000
+#define	kDslATURFFTSizeShiftUpstream	6
+#elif defined(G992_ATUR_UPSTREAM_SAMPLING_FREQ_552KHZ)
+#define kDslATURUpstreamSamplingFreq    552000
+#define	kDslATURFFTSizeShiftUpstream	7
+#else
+#define kDslATURUpstreamSamplingFreq    kDslSamplingFreq
+#define	kDslATURFFTSizeShiftUpstream	kDslMaxFFTSizeShift
+#endif 
+
+#if defined(G992_ATUC_UPSTREAM_SAMPLING_FREQ_276KHZ)
+#define kDslATUCUpstreamSamplingFreq    276000
+#define	kDslATUCFFTSizeShiftUpstream	6
+#elif defined(G992_ATUC_UPSTREAM_SAMPLING_FREQ_552KHZ)
+#define kDslATUCUpstreamSamplingFreq    552000
+#define	kDslATUCFFTSizeShiftUpstream	7
+#else
+#define kDslATUCUpstreamSamplingFreq    kDslSamplingFreq
+#define	kDslATUCFFTSizeShiftUpstream	kDslMaxFFTSizeShift
+#endif 
+
+#define	kDslMaxSamplesPerSymbol		(kDslMaxFFTSize+kDslMaxFFTSize/16)
+
+#if defined(G992P1_ANNEX_I) || defined(G992P5)
+#define kDslMaxTEQLength	        32
+#else
+#define kDslMaxTEQLength	        16
+#endif
+
+#define	kDslMaxSymbolBlockSize		1
+#define	kDslMaxSampleBlockSize		(kDslMaxSymbolBlockSize*kDslMaxSamplesPerSymbol)
+
+#ifdef G992_ANNEXC
+#define	kG992AnnexCXmtToRcvPathDelay	512   /* In samples at kDslSamplingFreq */
+#endif
+
+/*** For compatibility with existing test codes ***/
+#if !defined(TARG_OS_RTEMS)
+typedef dslStatusCode				modemStatusCode;
+typedef	dslStatusStruct				modemStatusStruct;
+typedef	dslStatusHandlerType		statusHandlerType;
+typedef dslCommandCode				modemCommandCode;
+typedef	dslCommandStruct			modemCommandStruct;
+typedef	dslCommandHandlerType		commandHandlerType;
+#endif
+
+extern void		SM_DECL SoftDslSetRefData	(void *gDslVars, ulong refData);
+extern ulong	SM_DECL SoftDslGetRefData	(void *gDslVars);
+extern int		SM_DECL SoftDslGetMemorySize(void);
+extern void		SM_DECL SoftDslInit			(void *gDslVars);
+extern void		SM_DECL SoftDslReset		(void *gDslVars);
+extern void		SM_DECL SoftDslLineHandler	(void *gDslVars, int rxNSamps, int txNSamps, short *rcvPtr, short *xmtPtr) FAST_TEXT;
+extern Boolean	SM_DECL SoftDslCommandHandler (void *gDslVars, dslCommandStruct *cmdPtr);
+
+/* swap Lmem functions */
+#if defined(bcm47xx) && defined(SWAP_LMEM)
+extern int SoftDslSwapLmem(void *gDslVars, int sectionN, int imageN);
+extern void init_SoftDslSwapLmem(void);
+#endif
+
+/* SoftDsl time functions	*/
+
+extern ulong	SM_DECL SoftDslGetTime(void *gDslVars);
+#define			__SoftDslGetTime(gv)		gDslGlobalVarPtr->execTime
+
+extern void		SM_DECL SoftDslTimer(void *gDslVars, ulong timeMs);
+
+/* SoftDsl IO functions	*/
+
+extern void		SM_DECL SoftDslClose (void *gDslVars);
+extern int		SM_DECL SoftDslSendFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+extern int		SM_DECL SoftDslReturnFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+
+/* SoftDsl connection functions	*/
+
+extern	void*	SM_DECL SoftDslVcAllocate(void *gDslVars, dslVcParams *pVcParams);
+extern	void	SM_DECL SoftDslVcFree(void *gDslVars, void *pVc);
+extern	Boolean SM_DECL SoftDslVcActivate(void *gDslVars, void *pVc);
+extern  void	SM_DECL SoftDslVcDeactivate(void *gDslVars, void *pVc);
+extern  Boolean SM_DECL SoftDslVcConfigure(void *gDslVars, void *pVc, ulong mid, dslVcParams *pVcParams);
+
+/* Special functions for LOG support */
+
+extern  ulong	SM_DECL SoftDslVc2Id(void *gDslVars, void *pVc);
+extern  void*	SM_DECL SoftDslVcId2Vc(void *gDslVars, ulong vcId);
+extern	void*	SM_DECL SoftDslGetFramePool(void *gDslVars);
+
+/* Functions for host mode execution */
+
+extern  void*   SM_DECL SoftDslRxCellHeaderHandler (void *gDslVars, ulong hdr, uchar hdrHec);
+extern	void*	SM_DECL SoftDslRxCellDataHandler (void *gDslVars, int,	void*);
+extern  void*	SM_DECL SoftDslTxCellHandler	(void *gDslVars, int*,	void*);
+extern  Boolean	SM_DECL SoftDslPhyCommandHandler (void *gDslVars, dslCommandStruct *cmdPtr);
+
+/* Functions getting OEM parameters including G994 non standard info management */
+
+extern	char*	SM_DECL SoftDslGetTrainingVendorIDString(void *gDslVars);
+extern	char*	SM_DECL SoftDslGetVendorIDString(void *gDslVars);
+extern	char*	SM_DECL SoftDslGetSerialNumberString(void *gDslVars);
+extern	char*	SM_DECL SoftDslGetRevString(void *gDslVars);
+extern	int		SM_DECL SoftDslRevStringSize(void *gDslVars);
+extern	int		SM_DECL SoftDslSerNumStringSize(void *gDslVars);
+							   
+extern  void*	SM_DECL SoftDslGetG994p1RcvNonStdInfo(void *gDslVars, ulong *pLen);
+extern  void*	SM_DECL SoftDslGetG994p1XmtNonStdInfo(void *gDslVars, ulong *pLen);
+
+#ifdef G997_1_FRAMER
+
+/* G997 functions */
+
+extern int		SM_DECL SoftDslG997SendFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+extern int		SM_DECL SoftDslG997ReturnFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+
+#endif
+
+#ifdef ADSL_MIB
+extern void	 *	SM_DECL	SoftDslMibGetData (void *gDslVars, int dataId, void *pAdslMibData);
+#endif
+
+#define	SoftDsl					SoftDslLineHandler
+#define	kSoftDslMaxMemorySize	(32768*16384)
+
+/*
+ * Internal functions
+ */
+
+extern  void	SoftDslStatusHandler	(void *gDslVars, dslStatusStruct *status) FAST_TEXT;
+extern  void	SoftDslInternalStatusHandler (void *gDslVars, dslStatusStruct *status);
+
+/*
+ *		DSL OS functions
+ */
+
+#ifdef DSL_OS
+
+#define	SoftDslIsBgAvailable(gDslVars)		(DSLOS_THREAD_INACTIVE == DslOsGetThreadState(&(gDslGlobalVarPtr->tcbDslBg)))
+#define	SoftDslGetBgThread(gDslVars)		\
+	((DSLOS_THREAD_INACTIVE != DslOsGetThreadState(&(gDslGlobalVarPtr->tcbDslBg))) ? &gDslGlobalVarPtr->tcbDslBg : NULL)
+#define	SoftDslBgStart(gDslVars, pFunc)		\
+	DslOsCreateThread(&gDslGlobalVarPtr->tcbDslBg, DSLOS_PRIO_HIGHEST - 10, pFunc, gDslVars,	\
+	WB_ADDR(gDslGlobalVarPtr->bgStack), sizeof(gDslGlobalVarPtr->bgStack))
+#define	SoftDslBgStop(gDslVars)				DslOsDeleteThread(&gDslGlobalVarPtr->tcbDslBg)
+
+#define	SoftDslEnterCritical()				DslOsEnterCritical()
+#define	SoftDslLeaveCritical(id)			DslOsLeaveCritical(id)
+
+#else
+
+#define	SoftDslIsBgAvailable(gDslVars)		1
+#define	SoftDslGetBgThread(gDslVars)		1
+#define	SoftDslBgStart(gDslVars, pFunc)		(*pFunc)(gDslVars)
+#define	SoftDslBgStop(gDslVars)
+
+#define	SoftDslEnterCritical()				0
+#define	SoftDslLeaveCritical(id)
+
+#endif
+
+/*
+ *		DSL frames and native frame functions
+ */
+
+DslFrameDeclareFunctions (DslFrameNative)
+
+/*
+ * These functions are for testing purpose, they are defined outside.
+ */
+#ifdef STACK_SIZE_REQUIREMENT_TEST
+extern	void		StackSizeTestInitializeStackBeforeEntry(void);
+extern	void		StackSizeTestCheckStackAfterExit(void);
+extern	void		StackSizeTestBackupStack(void);
+extern	void		StackSizeTestRestoreStack(void);
+#endif /* STACK_SIZE_REQUIREMENT_TEST */
+
+#ifdef NEC_NSIF_WORKAROUND
+#define	SoftDslGetG994NsStatus(gDslVars)		        (gDslGlobalVarPtr->G994NsStatus)
+#define	SoftDslGetG994NsFailCounter(gDslVars)		    (gDslGlobalVarPtr->G994NsFailCounter)
+#endif
+
+#endif	/* SoftDslHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModem.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModem.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModem.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,3128 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * SoftModem.h 
+ *
+ *
+ * Description:
+ *	This file contains the exported interface for SoftModem.c
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.16 $
+ *
+ * $Id: SoftModem.h,v 1.16 2004/04/14 21:16:51 ilyas Exp $
+ *
+ * $Log: SoftModem.h,v $
+ * Revision 1.16  2004/04/14 21:16:51  ilyas
+ * Merged with the latest changes in ADSL driver
+ *
+ * Revision 1.15  2004/04/13 00:56:10  ilyas
+ * Merged the latest ADSL driver changes for RTEMS
+ *
+ * Revision 1.14  2004/04/13 00:16:59  ilyas
+ * Merged the latest ADSL driver changes
+ *
+ * Revision 1.13  2003/02/22 05:07:11  ilyas
+ * Added VendorID for T1.413 mode
+ *
+ * Revision 1.12  2002/10/03 19:34:24  ilyas
+ * Added size for EOC serial number register
+ *
+ * Revision 1.11  2002/09/07 01:37:22  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.10  2001/12/13 02:25:34  ilyas
+ * Added definitions for G997
+ *
+ * Revision 1.9  2001/11/30 05:56:34  liang
+ * Merged top of the branch AnnexBDevelopment onto top of the tree.
+ *
+ * Revision 1.7.2.2  2001/11/27 02:32:05  liang
+ * Combine vendor ID, serial #, and version number into SoftModemVersionNumber.c.
+ *
+ * Revision 1.7.2.1  2001/10/03 01:44:10  liang
+ * Merged with codes from main tree (tag SoftDsl_2_18).
+ *
+ * Revision 1.8  2001/09/21 19:19:01  ilyas
+ * Minor fixes for VxWorks build
+ *
+ * Revision 1.7  2000/07/17 21:08:16  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.6  2000/05/03 04:09:11  ilyas
+ * Added ID for ATM log data
+ *
+ * Revision 1.5  2000/04/01 01:07:44  liang
+ * Changed file names and some module names.
+ *
+ * Revision 1.4  2000/03/02 20:18:12  ilyas
+ * Added test status code for ATM VC finished
+ *
+ * Revision 1.3  1999/08/05 20:02:11  liang
+ * Merged with the softmodem top of the tree on 08/04/99.
+ *
+ * Revision 1.2  1999/01/27 22:19:08  liang
+ * Merge with SoftModem_3_1_02.
+ * Include SoftDsl.h conditionlly so that the test utilities from SoftModem
+ * can be used without major change. It can be merged easily to SoftModem.
+ *
+ * Revision 1.170  1998/12/22 00:52:52  liang
+ * Added auxFeatures bit kV8HoldANSamUntilDetCI. When it is set, ANSam won't be
+ * sent until CI is detected (normally ANSam will be sent after 200ms). This is
+ * useful in V34 half duplex fax mode.
+ *
+ * Revision 1.169  1998/12/19 04:46:52  mwg
+ * Added bits for fax/data calling tones
+ *
+ * Revision 1.168  1998/12/17 02:46:10  scott
+ * Removed overlay-related commands/statuses and added
+ * kSetTrainingDelayReductionCmd
+ *
+ * Revision 1.167  1998/12/12 03:17:42  scott
+ * Added overlay commands and statuses
+ *
+ * Revision 1.166  1998/12/02 05:34:23  mwg
+ * Fixed a problem with bong tone detection
+ *
+ * Revision 1.165  1998/11/26 00:22:44  yura
+ * Added two more log data types: modulatorInputData & modulatorOutputData
+ *
+ * Revision 1.164  1998/11/19 03:08:04  mwg
+ * Added kSetCallProgressParamsCmd
+ *
+ * Revision 1.163  1998/11/18 23:00:03  liang
+ * Added a separate command kLoopbackTestAutoRespEnableCmd to enable or disable
+ * the loopback test auto respond feature when the modem is already on-line.
+ *
+ * Revision 1.162  1998/11/13 20:50:21  scott
+ * SoftModemInternalStatusHandler is now SM_DECL as well
+ *
+ * Revision 1.161  1998/11/13 20:42:25  scott
+ * Added SM_DECL type to entrypoint functions
+ *
+ * Revision 1.160  1998/11/13 03:02:54  scott
+ * Added SoftModemTimer prototype.
+ * Also include V.8bis types if AT_COMMANDS_V8BIS is defined.
+ *
+ * Revision 1.159  1998/11/12 01:22:46  scott
+ * Increased number of AT registers to 46
+ *
+ * Revision 1.158  1998/11/05 22:35:18  yura
+ * Added two more S-registers
+ *
+ * Revision 1.157  1998/11/05 03:09:54  mwg
+ * Added kLapmRetryFailed to the list of LAPM errors
+ *
+ * Revision 1.156  1998/11/05 00:13:20  liang
+ * Add new connectionInfo status kLoopbackSelfTestNewErrs to report
+ * new bit errors whenever it happens.
+ *
+ * Revision 1.155  1998/11/04 07:11:33  mwg
+ * Moved declaration for SoftModemATPrintf() to SoftModem.h
+ *
+ * Revision 1.154  1998/10/29 07:24:49  mwg
+ * *** empty log message ***
+ *
+ * Revision 1.153  1998/10/15 02:09:37  luisgm
+ * added separate data rate mask for Flex to dataPumpCapabilities structure
+ *
+ * Revision 1.152  1998/10/14 00:12:15  scott
+ * Added kMnpOOBFrameCmd and command.frameSpec
+ *
+ * Revision 1.151  1998/10/09 02:19:22  luisgm
+ * added FlexV8bisStruct member to dataPumpCapabilities struc to store flex v8bis info, added define for kFlexSkipV8bis
+ *
+ * Revision 1.150  1998/10/06 19:36:33  mwg
+ * Limited 56K rates to 53K
+ *
+ * Revision 1.149  1998/10/03 03:43:38  ilyas
+ * Added status codes for Audio
+ *
+ * Revision 1.148  1998/10/01 02:03:17  mwg
+ * Added external pulse dialer option
+ *
+ * Revision 1.147  1998/09/30 01:44:26  mwg
+ * Added new functions SoftModemGetWriteBufferSize() & SoftModemGetReadBufferSize()
+ *
+ * Revision 1.146  1998/09/22 03:44:38  scott
+ * Added ALWAYS_LONG_ALIGN() macro
+ *
+ * Revision 1.145  1998/09/21 21:49:22  scott
+ * Added logDataCodes for mnpDecoder(Input/Output)Data
+ *
+ * Revision 1.144  1998/08/31 22:57:21  luisgm
+ * added constants for Flex data rates + kFlexEventTRN2AFinished
+ *
+ * Revision 1.143  1998/08/18 05:09:53  mwg
+ * Increased AT command buffer size to 128
+ *
+ * Revision 1.142  1998/08/18 03:45:54  ilyas
+ * Integrated Audio into V70 test
+ *
+ * Revision 1.141  1998/08/14 17:46:04  ilyas
+ * Integrated Audio and G729a
+ *
+ * Revision 1.140  1998/08/10 21:42:19  mwg
+ * Added space and mark parity
+ *
+ * Revision 1.139  1998/08/08 03:39:33  scott
+ * Moved the C6xDefs and PentiumDefs includes before the internal function
+ * prototypes (to permit their redefinitions)
+ *
+ * Revision 1.138  1998/08/07 20:37:27  yura
+ * Added new S-register for &T commands
+ *
+ * Revision 1.137  1998/08/01 05:22:09  mwg
+ * Implemented split memory model
+ *
+ * Revision 1.136  1998/07/22 02:12:22  liang
+ * Added self test mode for loopback test.
+ *
+ * Revision 1.135  1998/07/21 01:19:03  liang
+ * Changed loopback test command parameter interface to use regular modeSpec.
+ *
+ * Revision 1.134  1998/07/18 03:52:10  liang
+ * Added V54 loop 2 test for V22.
+ *
+ * Revision 1.133  1998/07/15 02:45:03  mwg
+ * Added new connection info code: kPCMSpectralShapingBits
+ *
+ * Revision 1.132  1998/07/15 00:18:48  liang
+ * Add special turn off command for V34 fax to handle different turn off procedures.
+ *
+ * Revision 1.131  1998/07/13 22:19:49  liang
+ * Add V8 CI detection status and ANSam disable aux feature.
+ *
+ * Revision 1.130  1998/07/08 17:09:13  scott
+ * Added USE_LONG_ALIGN; support for 6 and PentiumDefs.h files
+ *
+ * Revision 1.129  1998/07/03 23:28:13  mwg
+ * Added Fax Class 2 defines
+ *
+ * Revision 1.128  1998/07/03 23:17:33  mwg
+ * Insuread command/status structures are long aligned
+ *
+ * Revision 1.127  1998/06/23 16:48:01  mwg
+ * Fixed a longstanding problem typical for Win95 VxD: whenever new
+ * VxD is intalled the confuguration profile may not match the old one but
+ * since the crc is correct it is still being downloaded. To avoid the problem
+ * a crc for the version number was added to avoid confusion between profiles
+ * of different versions.
+ *
+ * Revision 1.126  1998/06/19 21:04:06  liang
+ * Add auxiliary feature bit kV90ServerNotDetSbarAfterJdbarFix.
+ *
+ * Revision 1.125  1998/06/11 22:48:14  liang
+ * Add kPCM28000bpsShift constant.
+ *
+ * Revision 1.124  1998/06/05 22:11:51  liang
+ * New V90 DIL works through data mode.
+ *
+ * Revision 1.123  1998/06/01 23:03:41  liang
+ * Add v90RcvdDilDiffData logging.
+ *
+ * Revision 1.122  1998/06/01 21:24:38  mwg
+ * Changed some of the names.
+ *
+ * Revision 1.121  1998/05/13 04:55:22  mwg
+ * Now passing the number of spectral shaping bits in aux features
+ *
+ * Revision 1.120  1998/05/13 02:53:13  liang
+ * Add field "value" to command param structure.
+ *
+ * Revision 1.119  1998/05/12 04:42:23  mwg
+ * Replaced some of the status messages
+ *
+ * Revision 1.118  1998/05/11 23:36:10  mwg
+ * Added 8000Hz symbol rate to the map
+ *
+ * Revision 1.117  1998/05/05 04:28:39  liang
+ * V90 works up to data mode first version.
+ *
+ * Revision 1.116  1998/04/21 09:36:45  mwg
+ * Fixed a few problems for 16Khz and added 32Khz.
+ *
+ * Revision 1.115  1998/04/17  22:33:54  liang
+ * Added V90 DIL for mu-law PCM.
+ *
+ * Revision 1.114  1998/04/15  22:36:39  mwg
+ * Added new parameters to kDialCmd to allow individual control of each
+ * DTMF group attenuation.
+ *
+ * Revision 1.113  1998/04/15 18:16:22  ilyas
+ * Integrated V.8bis and changed coding of LinkLayerType to bitMap
+ *
+ * Revision 1.112  1998/04/15 07:59:06  mwg
+ * Added new status codes for V.90
+ *
+ * Revision 1.111  1998/04/11 00:29:16  mwg
+ * Fixed the warnings which appeared when Irix builds were upgraded to
+ * gcc 2.8.1
+ *
+ * Revision 1.110  1998/04/11  00:25:01  ilyas
+ * More V.70 statuses
+ *
+ * Revision 1.109  1998/04/10 23:29:31  mwg
+ * Added new field to capabilities: dataRates56K
+ *
+ * Revision 1.108  1998/04/09 02:02:56  mwg
+ * Added status for Ja detection.
+ *
+ * Revision 1.107  1998/04/03 02:05:30  ilyas
+ * More V.70 commands added
+ *
+ * Revision 1.106  1998/04/02 06:15:39  mwg
+ * Added coding type (Mu-law/A-law) status reporting.
+ *
+ * Revision 1.105  1998/03/30 09:53:57  mwg
+ * Added definition for k56Flex modulation for future use.
+ *
+ * Revision 1.104  1998/03/27  17:56:09  ilyas
+ * Added definitions for V.70
+ *
+ * Revision 1.103  1998/03/26 23:29:04  liang
+ * Added first version of IMD estimation.
+ *
+ * Revision 1.102  1998/03/20  04:37:26  mwg
+ * Increased the size of the nominal variance to 32 bit.
+ *
+ * Revision 1.101  1998/03/06 01:22:04  yura
+ * Improved Win95 VxD segmentation handling
+ *
+ * Revision 1.100  1998/03/06  01:06:18  liang
+ * Add initial version of V90 phase 1 and 2.
+ *
+ * Revision 1.99  1998/03/05  23:42:22  mwg
+ * (hxl) Implemented enable/disable call waiting command.
+ *
+ * Revision 1.98  1998/02/26  06:13:06  mwg
+ * Increased the number of AT S-registers to account for newly introduced
+ * S9 and S10.
+ *
+ * Revision 1.97  1998/02/25  18:18:25  scott
+ * Added v42bisCycleCount for V42BIS_THROUGHPUT_CONTROL
+ *
+ * Revision 1.96  1998/02/24 05:31:20  mwg
+ * Added stuff required by international version of AT command processor.
+ *
+ * Revision 1.95  1998/02/17  01:14:10  scott
+ * Reenabled sys/types.h for Linux builds
+ *
+ * Revision 1.94  1998/02/16 22:32:23  scott
+ * Changed copyright notice
+ *
+ * Revision 1.93  1998/02/16 22:17:44  scott
+ * Turned off include of sys/types.h for normal builds
+ *
+ * Revision 1.92  1998/02/16 21:53:28  scott
+ * Exclude sys/types.h for another compiler
+ *
+ * Revision 1.91  1998/02/09 18:24:10  scott
+ * Fixed ComplexShort type to work around bugs in MS and GreenHill compilers
+ *
+ * Revision 1.90  1998/01/27 01:37:36  mwg
+ * Added new log identifier for pcm infidelity data.
+ *
+ * Revision 1.89  1998/01/22  19:49:32  liang
+ * Add auxFeature bit kFaxV34HDXAllowAsymCtrlChan.
+ *
+ * Revision 1.88  1998/01/21  02:32:01  liang
+ * Add more V34 half duplex training progress codes.
+ *
+ * Revision 1.87  1997/12/23  03:28:25  liang
+ * Add more half duplex V34 related constants.
+ *
+ * Revision 1.86  1997/12/18  19:38:50  scott
+ * Added agcData log type.
+ * Added kDisableFaxFastClearDown demod capability
+ *
+ * Revision 1.85  1997/12/18 06:02:45  mwg
+ * Added a function to reenable DC offset tracking.
+ *
+ * Revision 1.84  1997/12/17  22:46:30  mwg
+ * Minor modifications to X2 escape status reporting.
+ *
+ * Revision 1.83  1997/12/16  06:49:45  mwg
+ * Implemented proper data rate reporting for PCM modem.
+ *
+ * Revision 1.82  1997/12/13  06:11:08  mwg
+ * Added X2 interface hooks
+ *
+ * Revision 1.81  1997/12/02 06:21:33  mwg
+ * Implemented kSetATRegister command.
+ *
+ * Revision 1.80  1997/11/27  02:11:41  liang
+ * Add code for half duplex V34 control channel.
+ *
+ * Revision 1.79  1997/11/19  19:52:48  guy
+ * Added constant to define V.34 half duplex operation
+ *
+ * Revision 1.78  1997/10/24 05:15:53  scott
+ * Added AGC and phase hit recovery to demodCapabilities
+ *
+ * Revision 1.77  1997/10/01 02:47:50  liang
+ * Add PCM interface.
+ *
+ * Revision 1.76  1997/09/29  15:48:04  yura
+ * Added #pragma statement for W95 Vxd
+ *
+ * Revision 1.75  1997/09/18 20:32:39  scott
+ * Do not include VxD support files if GENERATE_DEPENDENCIES is defined.
+ *
+ * Revision 1.74  1997/09/18 12:40:55  yura
+ * Removed #ifdef statments to be more robust
+ *
+ * Revision 1.73  1997/09/17 17:32:41  scott
+ * Do not include sys/types.h for 6
+ *
+ * Revision 1.72  1997/08/08 00:53:48  mwg
+ * Added fields for LAP-M frames printout.
+ * Added fields in auxFeatures to pass preemphasis filter parameters
+ * to V.34 phase 3 when doing PTT testing.
+ *
+ * Revision 1.71  1997/08/06  03:41:45  yura
+ * Added a few includes and defines needed by Win 95 driver.
+ *
+ * Revision 1.70  1997/08/05  03:22:10  liang
+ * Add equalizer center tap adjustment calculation related constants.
+ *
+ * Revision 1.69  1997/07/29  02:44:19  mwg
+ * Added new field to dataPumpCapabilities structure. This field is not
+ * yet exposed to external interface and currently is only used to
+ * enable PTT testing.
+ * Added new commands: kStartDataModemPTTTestCmd & kStartDataModemLoopbackTestCmd
+ *
+ * Revision 1.68  1997/07/22  22:05:10  liang
+ * Change sample rate setup as a normal command.
+ *
+ * Revision 1.67  1997/07/21  23:23:30  liang
+ * Define SoftModemSetSampleRate as null when SAMPLE_RATE_CONVERSION is not defined.
+ *
+ * Revision 1.66  1997/07/21  22:38:36  liang
+ * Change sample rate converter structure so that sample rate can be changed
+ * on the fly (at very begining) to either 8KHz or 9600Hz.
+ *
+ * Revision 1.65  1997/07/21  20:22:01  mwg
+ * Added statusInfoData to the log identifiers.
+ *
+ * Revision 1.64  1997/07/16  20:40:07  scott
+ * Added multitone monitor fields
+ *
+ * Revision 1.63  1997/07/10 02:31:08  mwg
+ * 1. Added kRxFrameHDLCFlags detected status for the
+ *    framingInfo.
+ * 2. Added kLapmMNPFrameDetected status to lapmStatusCode.
+ * 3. Increased the number of AT registers to 35
+ * 4. Modified LinkLayerSpec structure in modemCommandStruc
+ *    to provide the initial values of rxDataRate &
+ *    txDataRate and RT delay for the cases when
+ *    link layer is started *after* the data connection
+ *    is established and the status snooper is unable
+ *    to determine the rates and RT delay.
+ * 5. Added a few extra *empty* constant definitions for
+ *    disabled features.
+ *
+ * Revision 1.62  1997/07/02  19:15:05  scott
+ * Added bits for Bel103 & Bel212 modulations.
+ *
+ * Revision 1.61  1997/07/02 05:15:16  mwg
+ * Added MNP code.
+ *
+ * Revision 1.60  1997/07/01  23:52:48  mwg
+ * Modified the record test setup to log and use all the commands.
+ *
+ * Revision 1.59  1997/06/25  19:11:26  mwg
+ * 1. Added new framingInfoCode values for Async framing error reporting;
+ * 2. Added a substructure to pass serial data format for kSetDTERate cmd;
+ *
+ * Revision 1.58  1997/05/28  02:05:08  liang
+ * Add PCM modem phase 2 codes.
+ *
+ * Revision 1.57  1997/05/12  21:55:08  liang
+ * Add call waiting tone detector module.
+ *
+ * Revision 1.56  1997/03/21  23:50:08  liang
+ * Added initial version of V8bis module to CVS tree.
+ *
+ * Revision 1.55  1997/03/19  18:35:05  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.54  1997/03/11  11:11:45  mwg
+ * Added code to report V42bis statistics.
+ *
+ * Revision 1.53  1997/03/04  06:21:08  mwg
+ * Added logging of most commands.
+ *
+ * Revision 1.52  1997/02/28  23:45:13  liang
+ * Added training progress status report kPhaseJitterDeactivated.
+ *
+ * Revision 1.51  1997/02/28  22:23:22  mwg
+ * Implemented the following features:
+ * - Cleardown for fax modulations V.27, V.29 V.17
+ * - Rockwell compatible bitmap report (needed by a customer)
+ *
+ * Revision 1.50  1997/02/28  03:05:31  mwg
+ * Added more logging data types.
+ *
+ * Revision 1.49  1997/02/27  05:28:58  mwg
+ * Added RxFrameOK report.
+ *
+ * Revision 1.48  1997/02/27  01:48:53  liang
+ * Add kV8MenuDataWord1 and kV8MenuDataWord2 connectionInfo status.
+ *
+ * Revision 1.47  1997/02/24  02:30:27  mwg
+ * Added new log  data: predictorErrData
+ *
+ * Revision 1.46  1997/02/22  03:00:22  liang
+ * Add echoCancelledSignalData.
+ *
+ * Revision 1.45  1997/02/21  01:26:42  liang
+ * Add six more bits for the Demodulator capabilities to deal with 2nd order
+ * time tracking & PLLs, as well as shorter NEEC & PFEEC, and front end HBF.
+ *
+ * Revision 1.44  1997/02/17  03:09:00  mwg
+ * Added LAPM statistics printout.
+ *
+ * Revision 1.43  1997/02/04  08:38:47  mwg
+ * Added dc cancelled samples printout.
+ *
+ * Revision 1.42  1997/01/29  21:40:28  mwg
+ * Changed the way timers work: now time is passed as Q4 ms instead of ticks.
+ * Completed the 8KHz front end implementation.
+ * Got rid of kSamplesPerSecond constant.
+ *
+ * Revision 1.41  1997/01/24  07:13:50  mwg
+ * Added new statuses for automoder.
+ *
+ * Revision 1.40  1997/01/23  02:03:08  mwg
+ * Replaced old sample rate conversion with the newer one.
+ * Still has to resolve the automoding issue.
+ *
+ * Revision 1.39  1997/01/21  00:55:04  mwg
+ * Added 8KHz front end functionality.
+ *
+ * Revision 1.38  1996/11/13  00:30:55  liang
+ * Add kAutoLoadReductionEnabled to demodCapabilities so that PFEEC, FEEC, IEEC
+ * can be disabled automatically, but for worst processor loading test they
+ * won't be disabled when this bit is not set.
+ *
+ * Revision 1.37  1996/11/07  23:07:18  mwg
+ * Rearranged global variables to allow V.17 short training.
+ *
+ * Revision 1.36  1996/09/17  23:55:05  liang
+ * Change kMaxDataBlockSize from 16 to 24 to handle high data rates.
+ *
+ * Revision 1.35  1996/09/05  19:43:39  liang
+ * Removed caller ID error status code kCallerIDUnknownMessageType, and
+ * added caller ID status codes kCallerIDUnknownMessage & kCallerIDWholeMessage.
+ * Changed the callerIDStatus report structure.
+ *
+ * Revision 1.34  1996/08/29  00:36:57  liang
+ * Added kLapmTxFrameStatus and kLapmRxFrameStatus.
+ *
+ * Revision 1.33  1996/08/27  22:56:01  liang
+ * Added kResetHardware status code.
+ *
+ * Revision 1.32  1996/08/23  23:35:35  liang
+ * Add kATDebugStatus and function SoftModemGetHybridDelay.
+ *
+ * Revision 1.31  1996/08/22  01:13:19  yg
+ * Added AT command processor.
+ *
+ * Revision 1.30  1996/08/12  21:46:47  mwg
+ * Added code to report capabilities.
+ *
+ * Revision 1.29  1996/08/10  01:59:59  mwg
+ * Added report of the sent rate sequence;
+ *
+ * Revision 1.28  1996/08/07  22:15:02  mwg
+ * Added new status reports:
+ * kRemoteFreqOffset
+ * kIEECDeactivated
+ * kPFEECDeactivated
+ *
+ * Revision 1.27  1996/06/27  05:15:48  mwg
+ * Added V.24 circuit status.
+ *
+ * Revision 1.26  1996/06/27  02:12:43  mwg
+ * Cleaned the code.
+ *
+ * Revision 1.25  1996/06/20  23:57:30  mwg
+ * Added new training progress status.
+ *
+ * Revision 1.24  1996/06/18  21:13:50  mwg
+ * Added trellis MSE data logging.
+ *
+ * Revision 1.23  1996/06/12  02:31:10  mwg
+ * Added new type: VeryLong
+ *
+ * Revision 1.22  1996/06/08  22:15:39  mwg
+ * Added new status report: kCleardownStarted
+ * Added new field for the features: kV34bisEnabled
+ *
+ * Revision 1.21  1996/05/31  00:29:11  liang
+ * Add feature bit kV34ExtraINFOPreamble.
+ *
+ * Revision 1.20  1996/05/30  23:28:31  mwg
+ * Replaced enums with #defines
+ *
+ * Revision 1.19  1996/05/25  00:38:27  mwg
+ * Added kProjectedDataRate training progress report.
+ *
+ * Revision 1.18  1996/05/24  23:27:15  mwg
+ * Added mode status codes.
+ *
+ * Revision 1.17  1996/05/10  05:39:59  liang
+ * Move the includes for DEBUG inside "ifndef SoftModemTypes" so that
+ * cap build won't break.
+ *
+ * Revision 1.16  1996/05/08  01:49:34  mwg
+ * Added capability to setup auxiliary data channel handlers.
+ *
+ * Revision 1.15  1996/05/07  22:51:08  liang
+ * Added group delay estimation and improved symbol rate selection process.
+ *
+ * Revision 1.14  1996/05/06  06:49:09  mwg
+ * Fixed linux problems.
+ *
+ * Revision 1.13  1996/05/02  08:40:16  mwg
+ * Merged in Chromatic bug fixes.
+ *
+ * Revision 1.12  1996/05/02  02:26:21  mwg
+ * Added code to implement dozing functionality for v.34.
+ *
+ * Revision 1.11  1996/05/01  22:43:13  mwg
+ * Added new command: kDozeCmd;
+ *
+ * Revision 1.10  1996/05/01  19:20:16  liang
+ * Add command codes kInitiateRetrainCmd and kInitiateRateRenegotiationCmd.
+ *
+ * Revision 1.9  1996/04/25  01:12:37  mwg
+ * Added new flag: rapid preliminary EC training.
+ *
+ * Revision 1.8  1996/04/20  02:26:22  mwg
+ * Added preliminary far-end echo support
+ *
+ * Revision 1.7  1996/04/15  23:26:16  mwg
+ * Changed flag definitions for v34 modem.
+ *
+ * Revision 1.6  1996/04/04  02:35:50  liang
+ * Change kCid from 0x0080 to 0x0004 (0x0080 is defined as kV32).
+ *
+ * Revision 1.5  1996/03/08  23:07:01  mwg
+ * Added name for the struct.
+ *
+ * Revision 1.4  1996/03/02  00:59:27  liang
+ * Added typedef for V34CodingParameters structure.
+ *
+ * Revision 1.3  1996/02/27  02:28:31  mwg
+ * Fixed a bug in kLapmLongADPEnabled definition.
+ *
+ * Revision 1.2  1996/02/19  23:50:59  liang
+ * Removed compressionSetup parameter from the link layer command structure.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.5  1996/01/15  23:26:04  liang
+ * Change the softmodem command structure name from SoftwareModemCommand
+ * to SoftwareModemCommandParameters.
+ *
+ *****************************************************************************/
+#ifndef	SoftModemPh
+#define	SoftModemPh
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.1	General types														*/
+/****************************************************************************/
+
+#ifndef SM_DECL
+#define SM_DECL
+#endif
+
+#ifdef __VxWORKS__
+#include <types/vxTypesOld.h>
+#endif
+
+#ifdef DEBUG
+/* We have to define __wchar_t for Linux	*/
+#if defined __linux__ && !defined _NO_WHCAR_DEF_
+typedef	long int __wchar_t;
+#endif
+#if !defined(__KERNEL__) && !defined(_CFE_)
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+#if defined(__linux__) || defined (__unix__) || defined (__unix) || (defined (__mips__) && !defined(_CFE_) && !defined(VXWORKS) && !defined(TARG_OS_RTEMS))/* enable if necessary, but not for dos-based builds */
+#include <linux/types.h>
+#endif
+
+
+#endif	/* DEBUG */
+
+#if defined(W95_DRIVER) 
+#pragma code_seg("_LTEXT", "LCODE")
+#pragma data_seg("_LDATA", "LCODE")
+#pragma const_seg("_LDATA", "LCODE")
+#pragma bss_seg("_LDATA", "LCODE")
+#pragma pack(1)
+#endif /* W95_DRIVER */
+
+#ifndef SoftModemTypes
+#include "SoftModemTypes.h"
+#endif	/* SoftModemTypes */
+
+
+typedef struct
+	{
+	schar x, y;
+	} ComplexByte;
+
+typedef struct
+	{
+	uchar numerator;
+	uchar denominator;
+	} Ratio;
+
+#ifdef PEGASUS
+typedef union
+	{
+	struct
+		{
+		short x, y;
+		};
+	
+	long foo;
+	} ComplexShort;
+#else
+typedef struct
+	{
+	short x, y;
+#ifdef GREENHILL
+    long a[0];
+#endif
+	} ComplexShort;
+#endif
+
+typedef struct
+	{
+	long x, y;
+	} ComplexLong;
+
+typedef struct
+	{
+	ushort 	x0, x1, x2;
+	short	x3;
+	} VeryLong;
+
+typedef union
+	{
+	struct
+		{
+		uchar number;
+		uchar defaultValue;			/* default value */			
+		uchar maxValue;			/* max allowed value */
+		uchar minValue;			/* should be greater then maxValue to make reg readonly */
+		} param;
+	long alignment;
+	} SRegisterDefinition;
+
+#define MacroPaste2(a,b) a##b
+#define MacroPaste(a,b) MacroPaste2(a,b)
+#define ALWAYS_LONG_ALIGN() long MacroPaste(ALIGNMENT,__LINE__);
+
+#ifdef USE_LONG_ALIGN
+#define LONG_ALIGN() ALWAYS_LONG_ALIGN()
+#else
+#define LONG_ALIGN()
+#endif
+
+typedef	ulong	bitMap;
+
+typedef	int	pace;
+#define kStop		0
+#define kVerySlow	1
+#define kSlow		2
+#define kMedium		3
+#define kFast		4
+
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.2	Modem specific types												*/
+/****************************************************************************/
+
+typedef	long directionType;
+#define kXmt	0
+#define kRcv	1
+#define kXmtRcv	2
+
+
+#define	originating		kXmt
+#define	answering		kRcv
+#define	kOrg			kXmt
+#define	kAns			kRcv
+#define	kOrgAns			kXmtRcv
+
+#define	ORIGINATING		originating
+#define	ANSWERING		answering
+
+typedef	int	pcmCodingType;
+#define	kMuLawPCM	0
+#define	kALawPCM	1
+
+#define	kMuLawPCMScaleShift		2
+#define	kALawPCMScaleShift		3
+
+/* link layer and framer share defines */
+typedef	bitMap	framerType;
+typedef	bitMap	linkLayerType;
+#define kNoFramer	0
+#define kSync		0x00000001
+#define kAsync		0x00000002
+#define kHDLC		0x00000004
+#define kLapm		0x00000008
+#define kMnp		0x00000010
+#define kV70		0x00000020
+#define kSAM		0x00000040
+
+	
+typedef	bitMap	modulationMap;
+typedef	bitMap	symbolRateMap;
+typedef	bitMap	dataRateMap;
+typedef	bitMap	featureMap;
+typedef	bitMap	breakType;
+
+typedef	bitMap	audioType;
+#define	kRawAudio		0
+#define	kAudioG729A		1
+#define	kAudioG729		2
+#define	kAudioG723		3
+
+
+#ifndef ADSL_MODEM
+typedef long	modemStatusCode;
+#endif
+	/* Information status Codes: 1-31		*/
+#define kSetSampleRate				1
+#define kModulationKnown			2
+#define kRxSymbolRate				3
+#define kTxSymbolRate				4
+#define kRxCarrierFreq				5
+#define kTxCarrierFreq				6
+#define kTxPreemphasisFilter		7
+#define kTxPowerAdjustment			8
+#define kRemoteTxPreemphasisFilter	9
+#define kRemoteTxPowerAdjustment	10
+#define kRxRateKnown				11
+#define kTxRateKnown				12
+#define kRxDataModeActive			13
+#define kTxDataModeActive			14
+#define kTxSignalCompleted			15
+#define kDTMFSignalDetected			16
+#define kModemSignalDetected		17
+#define kCallProgressSignalDetected	18
+#define kCustomSignalDetected		19
+#define kFaxPreambleDetected		20
+#define kV24CircuitStatusChange		21
+#define kHookStateChange			22
+#define kCallWaitingToneDetected	23
+#define kMultiToneSignalDetected	24
+#define kPulseShuntStateChange		25
+#define kRingFrequency              26
+
+
+	/* Warning status Codes:		32-64	*/
+#define kError						32
+#define kV34Exception				33
+#define kClearDownLocal				34
+#define kClearDownRemote			35
+#define kCarrierPresent				36
+#define kCarrierLost				37
+#define kRetrainingLocal			38
+#define kRetrainingRemote			39
+#define kRateRenegotiationLocal		40
+#define kRateRenegotiationRemote	41
+#define kFallbackStarted			42
+#define kFallForwardStarted			43
+#define kCleardownStarted			44
+#define kIllegalCommand				45
+	
+	/* Auxiliary status Codes:	64-..	*/	
+#define kTrainingProgress			64
+#define kConnectionInfo				65
+#define kDialerStatus				66
+#define kFramingInfo				67
+#define kBreakReceived				68
+#define kLapmStatus					69
+#define kLapmParameter				70
+#define kV42bisStatus				71
+#define kCallerIDStatus				72
+#define kIOStatus					73
+#define kCapabilitiesStatus			74
+#define kSpeakerStatus				75
+#define kATProfileChanged			76
+#define kATDebugStatus				77
+#define	kResetHardware				78
+#define	kV8bisStatus				79
+#define kMnpStatus					80
+#define kMnpParameter				81
+#define kV70Status					82
+#define kV70Parameter				83
+#define kFaxClass2Status			84
+#define kAudioStatus				85
+#define kAudioParameter				86
+#define kOverlayStatus				87
+#define kCallerIDCircuitStatus		88
+#define kV80Status					89
+#define kV80Parameter				90
+#define kLocalCountryChanged		91
+#define kDTERateChanged				92
+#define kATResponse					93
+#define kFramerConfigured			94
+#define kA8RStatus					95
+#define kA8TStatus					96
+#define	kVersionStatus				97
+
+	/* Testing status codes:	128-...	*/
+	/* These statuses are generated by modem test suit	*/
+#define kTestFinished				128
+#define kConnectivityTestFinished	129
+#define kTestCheckSum				130
+#define kLogFileControl				131
+#define kTestAtmVcFinished			132
+#define kTestClearEocFinished		133
+#define kTestG997Finished			134
+
+typedef long	modemErrorCode;
+#define kNoError				0
+#define kErrorTimerExpired		1
+#define kErrorNoSReceived		2
+#define kErrorNoSbarReceived	3
+
+
+typedef long	dialerStatusCode;
+#define kDialCompleted				0
+#define kNoDialToneDetected			1
+#define kBongToneDetected			2
+#define kNoBongToneDetected			3
+#define kErrorIllegalDialModifier	5
+#define kDialStarted				6
+#define kExternalPulseDialDigit		7
+
+
+typedef long	framingInfoCode;
+#define kRxFrameOK					0
+#define kRxFrameTooLong				1
+#define kRxFrameCRCError			2
+#define kTxFrameUnderrun			3
+#define kRxFrameOverrun				4
+#define kRxFrameAborted				5
+#define kRxFrameParityError			6
+#define kRxFrameFormatError			7
+#define	kRxFrameHDLCFlagsDetected	8
+
+
+typedef long	IOStatusCode;
+#define kRxDataReady		0
+#define kRxBufferOverflow	1
+#define kTxSpaceAvailable	2
+#define kTxBufferEmpty		3
+
+typedef long	capabilitiesStatusCode;
+#define kSymbolRates				0
+#define kDataRates					1
+#define kFeatures					2
+#define kDemodCapabilities			3
+#define kRateThresholdAdjustment	4
+#define kXmtLevel					5
+#define kHybridDelay				6
+#define kAuxFeatures				7
+
+
+typedef long	A8TStatusCode;
+#define kA8TFinished				0
+
+typedef long	callerIDStatusCode;
+#define kCallerIDError					0
+#define kCallerIDChannelSeizureReceived	1
+#define kCallerIDMarkSignalReceived		2
+#define kCallerIDTime					3
+#define kCallerIDTelnum					4
+#define kCallerIDName					5
+#define kCallerIDEnd					6
+#define kCallerIDUnknownMessage			7
+#define kCallerIDWholeMessage			8
+
+
+typedef long	callerIDErrorCode;
+#define kCallerIDNoError			0
+#define kCallerIDMarkSignalError	1
+#define kCallerIDTooManyMarkBits	2
+#define kCallerIDMessageTooLong		3
+#define kCallerIDChecksumError		4
+
+
+typedef long	connectionInfoCode;
+#define kRTDelay			1
+#define kRxSignalLevel		2
+#define kTimingOffset		3
+#define kFreqOffset			4
+#define kPhaseJitter		5
+#define kSNR				6
+#define kNearEchoLevel		7
+#define kSER				8
+#define kNearEndDelay		9
+#define kFarEchoLevel		10
+#define kL1L2SNRDifference	11
+#define	kDCOffset			12
+#define	kTotalRxPower		13
+#define	kRemoteFreqOffset	14
+/* obsolete	#define	kV8MenuDataWord1	15 */
+/* obsolete	#define	kV8MenuDataWord2	16 */
+#define	kPCMP2AnalogDetSNR	17
+#define	kPCMP2DigitalDetSNR	18
+#define	kPCMP2RBSDetSNR		19
+#define	kEqCenterTapOffset	20
+#define	kPCMPadValue		21
+#define	kPCMRBSMap			22
+#define	kPCMCodingType		23
+#define	kPCMSpectralShapingBits			24
+#define	kLoopbackSelfTestResult			25
+#define	kEyeQuality						26
+#define	kLoopbackSelfTestNewErrs		27
+#define kV34EqlLengthStatus 28
+#define kV34EqlOffsetStatus 29
+#define	kV8CallMenuData		30
+#define	kV8JointMenuData	31
+#define kPCMClientIeecLengthStatus 32
+#define kPCMClientIeecOffsetStatus 33
+#define	kSeamlessRateChange	34
+
+typedef long	trainingProgressCode;
+#define kPeriodicalSignalDetected		0
+#define kPhaseReversalDetected			1
+#define kSignalStartDetected			2
+#define kSignalEndDetected				3
+#define kSSignalDetected				4
+#define kSbarSignalDetected				5
+#define kJ4SignalDetected				6
+#define kJ16SignalDetected				7
+#define kJprimeSignalDetected			8
+#define kMPSignalDetected				9
+#define kMPprimeSignalDetected			10
+#define kMPSignalSent					11
+#define kMPprimeSignalSent				12
+#define kRateSignalDetected				13
+#define kESignalDetected				14
+#define kRateSignalSent					15
+
+#define	kAutomodingTryModulation		16
+#define	kAutomodingCompleted			17
+#define	kRCFaxBitMapStatus				18
+	
+#define kV8CIDetected					19
+#define kV8ANSToneDetected				20
+#define kV8ANSamDetected				21
+#define kV8CMDetected					22
+#define kV8JMDetected					23
+#define kV8CJDetected					24
+#define kV8Finished						25
+	
+#define kV34Phase2Started				26
+#define kV34Phase2INFOSequenceDetected	27
+#define kV34Phase2NearEndEchoDetected	28
+#define kV34Phase2L1Receiving			29
+#define kV34Phase2L2Receiving			30
+#define kV34Phase2Finished				31
+#define kV34Phase3Started				32
+#define kV34Phase3Finished				33
+#define kV34Phase4Started				34
+#define kV34Phase4Finished				35
+#define kV34DecoderParameters			36
+#define kV34EncoderParameters			37
+
+#define kMaxLocalRxDataRate				38
+#define kMaxLocalTxDataRate				39
+#define kMaxRemoteRxDataRate			40
+#define kMaxRemoteTxDataRate			41
+#define kProjectedDataRate				42
+#define kFEECDeactivated				43
+#define kIEECDeactivated				44
+#define kPFEECDeactivated				45
+#define kPhaseJitterDeactivated			46
+
+#define	kPCMP2DetectedDigitalConnection	47
+#define	kPCMP2DetectedRBS				48
+#define	kX2DetectedPhase1Escape			49
+
+#define kStarted1200BpsTraining			50
+#define kStarted2400BpsTraining			51
+#define kUnscrambledOneDetected			52
+#define kScrambled1200BpsOneDetected	53
+#define kScrambled2400BpsOneDetected	54
+#define kV22BisS1Detected				55
+#define	kV22InitiateLoop2Test			56
+#define	kV22RespondLoop2Test			57
+#define	kV22Loop2TestAlt01Detected		58
+
+#define	kDataModemLoop1TestStarted		59
+#define	kDataModemLoop1TestFinished		60
+#define	kDataModemLoop2TestStarted		61
+#define	kDataModemLoop2TestFinished		62
+#define	kDataModemLoop3TestStarted		63
+#define	kDataModemLoop3TestFinished		64
+#define	kDataModemSelfLoopTestEnabled	65
+
+#define kPCMPhase3Started				70
+#define kPCMPhase3Finished				71
+#define kPCMPhase4Started				72
+#define kPCMPhase4Finished				73
+
+#define	kV90JaSignalDetected			74		
+#define	kV90JdSignalDetected			75		
+#define	kV90JdPrimeSignalDetected		76		
+#define	kV90RSignalDetected				77		
+#define	kV90RBarSignalDetected			78	
+#define	kV90CPSignalDetected			79	
+
+#define	kV90CPtSignalSent				80
+#define	kV90CPSignalSent				81
+#define	kV90CPprimeSignalSent			82
+
+
+#define	kV34SeamlessRateChangeRequestSent		83
+#define	kV34SeamlessRateChangeUpdateSent		84
+#define	kV34SeamlessRateChangeRequestReceived	85
+#define	kV34SeamlessRateChangeUpdateReceived	86
+#define	kV34SeamlessRateChangeUpdateTimeout		87
+
+#define kV90JaSignalAcknowledged				88
+
+#define	kV34HCtrlChanPPhDetected		100
+#define	kV34HCtrlChanMPhDetected		101
+#define	kV34HCtrlChanRatesKnown			102
+#define	kV34HDXCtrlChanBinary1Detected	103
+#define	kV34HDXPhase3Started			104
+#define	kV34HDXPhase3Finished			105
+#define	kV34HDXPrimChanBinary1Detected	106
+#define kFlexEventTRN2AFinished         107
+
+#define kV32RanginigStarted				108
+#define kV32RangingStarted				108
+#define kV32RanginigFinished			109
+#define kV32RangingFinished				109
+
+
+typedef long	lapmStatusCode;
+#define kLapmDisconnected			0	/* LAPM disconnected */
+#define kLapmConnected				1	/* LAPM is connected */
+#define kLapmV42ODPDetected			2	/* LAPM ODP is detected	*/
+#define kLapmV42ADPDetected			3	/* LAPM V.42 ADP is detected	*/
+#define kLapmUnknownADPDetected		4	/* LAPM Unsupported ADP is detected	*/
+#define kLapmTimeout				5	/* LAPM Timeout		*/
+#define	kLapmMNPFrameDetected		6	/* LAPM detected MNP frame	*/
+#define kLapmDPDetectionTimedOut	7	/* LAPM Unsupported ADP is detected	*/
+#define kLapmError					8	/* LAPM Error	*/
+#define kLapmTestResult				9	/* LAPM loopback test result */
+#define	kLapmTxFrameStatus			10
+#define	kLapmRxFrameStatus			11
+#define	kLapmTxStatistics			12
+#define	kLapmRxStatistics			13
+
+typedef long	lapmTakedownReason;
+#define kLapmRemoteDisconnect	0
+#define kLapmLocalDisconnect	1
+#define kLapmCannotConnect		2
+#define kLapmProtocolError		3
+#define kLapmCompressionError	4
+#define kLapmInactivityTimer	5
+#define kLapmRetryFailed		6
+
+
+typedef long	lapmParameterCode;
+#define kLapmXmtK			0
+#define kLapmRcvK			1
+#define kLapmXmtN401		2
+#define kLapmRcvN401		3
+#define kLapmTESTSupport	4
+#define kLapmSREJSupport	5
+#define kLapmCompDir		6
+#define kLapmCompDictSize	7
+#define kLapmCompStringSize	8
+
+
+typedef long	lapmErrorCode;
+#define kLapmNoError		0
+#define kLapmBufferOverflow	1
+#define kLapmFrameTooLong	2
+#define kLapmBadFrame		3
+#define kLapmUnknownEvent	4
+/* 6 is reserved for kLapmRetryFailed defined above */
+
+
+typedef long	lapmTestResultCode;
+#define kLapmTestPassed				0
+#define kLapmTestRequestIgnored		1
+#define kLapmTestAlreadyInProgress	2
+#define kLapmTestNotSupported		3
+#define kLapmTestFailed				4
+
+
+typedef long	v42bisStatusCode;
+#define kV42bisEncoderTransparentMode	0	/* V.42bis encoder transparent mode active */
+#define kV42bisEncoderCompressedMode	1	/* V.42bis encoder compressed mode active */
+#define kV42bisDecoderTransparentMode	2	/* V.42bis decoder transparent mode active */
+#define kV42bisDecoderCompressedMode	3	/* V.42bis decoder compressed mode active */
+#define kV42bisError					4	/* V.42bis error */
+#define	kV42bisEncoderStatistics		5
+#define	kV42bisDecoderStatistics		6
+
+
+typedef long	v42bisErrorCode;
+#define kV42bisUndefinedEscSequence	0	/* V.42bis undefined escape sequence		*/
+#define kV42bisCodewordSizeOverflow	1	/* V.42bis codeword size overflow			*/
+#define kV42bisUndefinedCodeword	2	/* V.42bis undefined codeword				*/
+
+typedef long	mnpStatusCode;
+#define kMnpDisconnected			0	/* Mnp disconnected */
+#define kMnpConnected				1	/* Mnp is connected */
+#define kMnpFallback				2	/* Mnp is falling back to buffer mode */
+#define kMnpError					3	/* Mnp Error	*/
+#define	kMnpTimeout					4	/* Mnp Timeout */
+#define	kMnpInvalidLT				5	/* Invalid LT received */
+#define	kMnpRetransmitFrame			6
+#define	kMnpNack					7
+#define	kMnpTxFrameStatus			8
+#define	kMnpRxFrameStatus			9
+#define	kMnpTxStatistics			10
+#define	kMnpRxStatistics			11
+
+typedef long	mnpTakedownReason;
+#define kMnpRemoteDisconnect		0
+#define kMnpLocalDisconnect			1
+#define kMnpCannotConnect			2
+#define kMnpProtocolError			3
+#define kMnpCompressionError		4
+#define kMnpInactivityTimer			5
+#define kMnpRetryFailed				6
+
+
+typedef long	mnpParameterCode;
+#define kMnpProtocolLevel			0
+#define kMnpServiceClass			1
+#define kMnpOptimizationSupport		2
+#define kMnpCompressionSupport		3
+#define kMnpN401					4
+#define kMnpK						5
+
+
+typedef long	mnpErrorCode;
+#define kMnpNoError					0			
+#define kMnpBufferOverflow			1
+#define kMnpFrameTooLong			2
+#define kMnpBadFrame				3
+#define kMnpUnknownEvent			4
+
+
+typedef long	v70StatusCode;
+#define kV70Disconnected			0	/* V70 disconnected */
+#define kV70Connected				1	/* V70 is connected */
+#define kV70Error					2	/* V70 Error	*/
+#define	kV70Timeout					3	/* V70 Timeout */
+#define kV70ChannelDown             4	/* V70 channel released */
+#define kV70ChannelUp               5	/* V70 channel established */
+#define kV70AudioChannelDown        6	/* V70 audio channel released */
+#define kV70AudioChannelUp          7	/* V70 audio channel established */
+#define kV70DataChannelDown         8	/* V70 data channel released */
+#define kV70DataChannelUp           9	/* V70 data channel established */
+#define kV70OOBChannelDown          10	/* V70 out-of-band channel released */
+#define kV70OOBChannelUp            11  /* V70 out-of-band channel established */
+#define	kV70TxFrameStatus			12
+#define	kV70RxFrameStatus			13
+#define	kV70TxStatistics			14
+#define	kV70RxStatistics			15
+#define	kV70StateTransition			16
+
+typedef long	v70TakedownReason;
+#define kV70RemoteDisconnect		0
+#define kV70LocalDisconnect			1
+#define kV70CannotConnect			2
+#define kV70ProtocolError			3
+#define kV70CompressionError		4
+#define kV70InactivityTimer			5
+#define kV70RetryFailed				6
+
+
+typedef long	v70ParameterCode;
+#define kV70SuspendResume	        0
+#define kV70CrcLength	            1
+#define kV70NumberOfDLCs	        2
+#define kV70uIH	                    3
+
+#define kV70LapmXmtK				10
+#define kV70LapmRcvK				11
+#define kV70LapmXmtN401				12
+#define kV70LapmRcvN401				13
+#define kV70LapmTESTSupport			14
+#define kV70LapmSREJSupport			15
+#define kV70LapmCompDir				16
+#define kV70LapmCompDictSize		17
+#define kV70LapmCompStringSize		18
+
+#define kV70AudioHeader	            20   /* if audio header is present in audio frames */
+#define kV70BlockingFactor	        21   /* audio blocking factor (default 1)  */
+#define kV70SilenceSuppression      22   /* audio silence suppression */
+
+
+
+typedef long	v70ErrorCode;
+#define kV70NoError					0			
+#define kV70BadFrame				1			
+
+typedef long	audioStatusCode;
+#define kAudioFramesLost			0	 /* One or more audio frames were lost */
+#define kAudioTxBufferOverflow		1
+#define kAudioRxBufferOverflow		2
+#define kAudioRxBufferUnderflow		3
+
+
+typedef long	v80StatusCode;
+#define kV80Disconnected			0	/* V80 disconnected */
+#define kV80Connected				1	/* V80 is connected */
+#define kV80Error					2	/* V80 Error	*/
+#define kV80InBandStatus			3	/* V80 in-band SAM status */
+#define	kV80TxFrameStatus			12
+#define	kV80RxFrameStatus			13
+#define	kV80TxStatistics			14
+#define	kV80RxStatistics			15
+
+typedef long	v80TakedownReason;
+#define kV80RemoteDisconnect		0
+#define kV80LocalDisconnect			1
+
+typedef long	v80ErrorCode;
+#define kV80NoError					0			
+#define kV80BadFrame				1			
+
+typedef long	overlayStatusCode;
+#define kOverlayBegin				0	/* DSP has halted */
+#define kOverlayEnd					1	/* DSP has received entire overlay */
+#define kOverlayElapsedTime			2	/* time elapsed(as viewed by datapump) during overlay */
+#define kOverlayRecordingData		3	/* ms of data that we are recording */
+#define kOverlayReplayingData		4	/* ms of data that we have replayed so far */
+#define kOverlayReplayDone			5	/* playback is done */
+
+/* types for kOverlayRecording/ReplayingData */
+#define kOverlayTxData				0
+#define kOverlayRxData				1
+
+/*
+ * Rockwell faxmodem compatible bitmap (kRCFaxBitMapStatus)
+ */
+#define	kRCFaxFCD	0x01
+#define	kRCFaxP2	0x02
+#define	kRCFaxPN	0x04
+#define	kRCFaxDCD	0x08
+#define	kRCFaxTX	0x10
+#define	kRCFaxCTS	0x20
+
+
+#ifndef ADSL_MODEM
+typedef long	modemCommandCode;
+#endif
+	/* Basic Action commands		00-63		*/
+#define kIdleCmd						0
+#define kStartFaxModemCmd				1
+#define kStartDataModemCmd				2
+#define kStartCallProgressMonitorCmd	3
+#define kSendTonesCmd					4
+#define kStartCallerIDRcvCmd			5
+#define kSetLinkLayerCmd				6
+#define kSetFramerCmd					7
+#define kTestLinkLayerCmd				8
+#define kIdleRcvCmd						9
+#define kIdleXmtCmd						10
+#define kSetStatusHandlerCmd			11
+#define kSetEyeHandlerCmd				12
+#define kSetLogHandlerCmd				13
+#define kSendBreakCmd					14
+#define kSendTestCmd					15
+#define kDisconnectLinkCmd				16
+#define kSetXmtGainCmd					17
+#define kStartADSICmd					18
+#define kSetHybridDelayCmd				19
+#define kCleardownCmd					20
+#define kInitiateRetrainCmd				21
+#define kInitiateRateRenegotiationCmd	22
+#define	kDialToneIndicator				23
+#define kSetRxDataHandler				24	/* not used yet */
+#define kSetTxDataHandler				25	/* not used yet */
+#define kSetAuxRxDataHandler			26
+#define kSetAuxTxDataHandler			27
+#define kRingIndicatorCmd				28
+#define kDTERateIndicatorCmd			29
+#define	kStartV8bisCmd					30
+#define kSendMultiTonesCmd				31
+#define kSetMultiToneParamsCmd			32
+#define kSetModemSampleRateCmd			33
+#define kStartDataModemPTTTestCmd		34
+#define kStartDataModemLoopbackTestCmd	35
+#define kRingFrequencyCmd				36
+#define kSetCallWaitingDetectorStateCmd	37
+#define kV34HDXTurnOffCurrentModeCmd	38
+#define	kSetAudioCmd					39
+#define	kLoopbackTestAutoRespEnableCmd	40
+#define kSetCallProgressParamsCmd		41
+#define kSetTrainingDelayReductionCmd	42
+#define	kSetFaxECMPageBufferPtrCmd		43
+#define kSetLineCurrentStateCmd			44
+#define	kSetFramerParameterCmd			45
+#define kStartDozeCmd                   46
+#define kEndDozeCmd                     47
+#define kStartRingFrequencyDetectorCmd  48
+#define	kSetBufferingDelayAdjustmentCmd	49
+
+	/* Composite action commands	64-127		*/
+#define kDialCmd						64
+#define kSendCallingToneCmd				65
+#define kV24CircuitChangeCmd			66
+#define	kStartATModeCmd					67
+#define	kStopATModeCmd					68
+#define	kSetATRegister					69
+#define	kSetATRegisterLimits			70
+#define	kSetATIResponse					71
+#define	kEnableATDebugMode				72
+#define	kSetWhiteListEntry				73
+#define	kSetBlackListEntry				74
+
+#define kV70Setup					    75      /* additional V70 configuration */
+#define kEstablishChannel			    76      /* Establish new link layer channel (V70) */
+#define kReleaseChannel					77      /* Release link layer channel (V70) */
+#define kWaitChannelEstablished			78      /* Wait for establishment of the new link layer channel (V70) */
+
+/* unused	79 */
+#define kMnpOOBFrameCmd					80
+#define kV80InBandCmd					81		/* V80 In-band commands */
+#define kSetV250IdString				82
+#define	kSetInternationalTablesCmd		83
+#define	kConfigureCountryCmd			84
+#define	kConigureCountryCmd				84
+#define	kV8ControlCmd					85
+#define kV8bisSendMessage				86
+#define	kSetHWIdCmd						87
+#define	kSetCodecIdCmd					88
+#define	kOverCurrentDetected			89
+
+
+
+typedef long v8ControlType;
+#define kEnableDTEControl				1
+#define kSetV8ControlTimeout			2
+#define kSetCIValue						3
+#define kSetCMValue						4
+#define kSetJMValue						5
+#define kSendCJ							6
+#define kSetCallFunctionCategory		7
+
+typedef long v250IdStringCode;
+#define kGMIString						1
+#define kGMMString						2
+#define kGMRString						3
+#define kGSNString						4
+#define kGOIString						5
+
+typedef long	kCallProgressParameterCode;
+#define	kModemSignalPowerThreshold		1
+#define	kDialtonePowerThreshold			2
+#define	kRingBackPowerThreshold			3
+#define	kBusyPowerThreshold				4
+#define	kReorderPowerThreshold			5
+#define	k2ndDTnPowerThreshold			6
+#define	kMinDialtoneTime				7
+#define	kDialtoneFreqRange				8
+#define	kRingBackFreqRange				9
+#define	kBusyFreqRange					10
+#define	kReorderFreqRange				11
+#define	k2ndDTnFreqRange				12
+
+
+typedef	long	framerParameterCode;
+#define	kSetHDLCLeadingFlags		0
+#define	kHDLCResetFlagDetection		1
+#define	kSyncFramerSetup			2
+#define	kHDLCSendCRC				3
+#define kHDLCSendFlags				4
+#define	kHDLCSendAborts				5
+
+
+typedef	long logDataCode;
+#define eyeData				0
+#define mseData				1
+#define rxData				2
+#define txData				3
+#define neecData			4
+#define eqlData				5
+#define ieecData			6
+#define feecData			7
+#define eqlPllData			8
+#define feecPllData			9
+#define timingData			10
+#define pjPhaseErrData		11
+#define pjEstimateData		12
+#define pjEstDiffData		13
+#define pjCoefData			14
+#define inputSignalData		15
+#define outputSignalData	16
+#define agcGainData			17
+#define automoderData		18
+#define v8CMData			19
+#define v8JMData			20
+#define inputAfterNeecData	21
+#define eqlErrData			22
+#define dpskMicrobitsData	23
+#define v34P2LSamplesData	24
+#define phaseSplittedLData	25
+#define fftedLData			26
+#define channelSNRData		27
+#define noiseEstimateData	28
+#define signalEstimateData	29
+#define v34INFOData			30
+#define v34ChanProbData		31
+#define v34P2OutputData		32
+#define v8ANSamDetectData	33
+#define pFeecData			34
+#define channelDelayData	35
+#define timingOffsetData	36
+#define trellisMSEData		37
+#define interpolatedSignalData		38
+#define dcCancelledSignalData		39
+#define echoCancelledSignalData		40
+#define predictorErrData			41
+#define commandInfoData				42
+#define unusedInfoData				43
+#define atCommandInfoData			44
+#define atResponseInfoData			45
+#define hwTerminalTxData			46
+#define hwTerminalRxData			47
+#define statusInfoData				48
+#define	channelResponseData			49
+#define	channelImpulseRespData		50
+#define	x2PcmP1DetectorInData		51
+#define	x2PcmP1DetectorOutData		52
+#define eqlRealData					53
+#define ieecRealData				54
+#define neecOutputData				55
+#define precodedEqlOutputData		56
+#define eqlRealErrData				57
+#define idealEqlOutputData			58
+#define agcData						59
+#define pcmInfidelityData			60
+#define v42bisCycleCount			61
+#define pcmImdOffsetCoefData		62
+#define pcmImdOffsetData			63
+#define	v90RcvdDilLongData			64
+#define	v90RcvdDilShortData			65
+#define	v90DilProducedData			66
+#define	pcmEncoderKbitsData			67
+#define	pcmEncoderMbitsData			68
+#define	pcmEncoderSbitsData			69
+#define	pcmDecoderKbitsData			70
+#define	pcmDecoderMbitsData			71
+#define	pcmDecoderSbitsData			72
+#define	v90CPorCPtData				73
+#define	mnpDecoderInputData			74
+#define	mnpDecoderOutputData		75
+#define	v42bisEncoderInputData		76
+#define	v42bisDecoderInputData		77
+#define	modulatorInputData			78
+#define	modulatorOutputData			79
+#define encodedStatusData			80
+#define blockFramerTxData			81
+#define blockFramerRxData			82
+#define framerTxData				83
+#define framerRxData				84
+#define	dpskBasebandData			85
+#define	dpskBasebandLPFedData		86
+#define	dpskRealData				87
+#define bandEdgeCorrectedSignalData	88
+#define atmLogData					89
+#define clearEocLogData				90
+#define g997LogData					91
+
+
+#define	kLogDataDelimiter	0xFEFEFEFE
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.3	Handlers															*/
+/****************************************************************************/
+
+typedef	void	(SM_DECL *rcvHandlerType)			(void *gDslVars, int, short*);
+typedef	void	(SM_DECL *xmtHandlerType)			(void *gDslVars, int, short*);
+typedef	int		(SM_DECL *xmtHandlerWithRtnValType)	(void *gDslVars, int, short*);
+typedef	void	(SM_DECL *timerHandlerType)			(void *gDslVars, long);
+typedef	int		(SM_DECL *interpolatorHandlerType)	(void *gDslVars, int, short*, short*);
+typedef	void	(SM_DECL *controlHandlerType)		(void *gDslVars, int);
+
+typedef	int		(SM_DECL *txDataHandlerType)	(void *gDslVars, int,	uchar*);
+typedef	int		(SM_DECL *rxDataHandlerType)	(void *gDslVars, int,	uchar*);
+
+typedef	bitMap	(SM_DECL *signalDetectorType)	(void *gDslVars, int, long, long*);
+
+
+typedef	void	(SM_DECL *hookHandlerType)		(void *gDslVars, Boolean);
+
+typedef	short*	(SM_DECL *sampBuffPtrType)		(void *gDslVars, int);
+
+typedef	void	(SM_DECL *eyeHandlerType)		(void *gDslVars, int, ComplexShort*);
+typedef	void	(SM_DECL *logHandlerType)		(void *gDslVars, logDataCode, ...);
+
+typedef	void	(SM_DECL *voidFuncType)			(void *gDslVars);
+
+typedef	int		(SM_DECL *txAudioHandlerType)	(void *gDslVars, int,	short*);
+typedef	int		(SM_DECL *rxAudioHandlerType)	(void *gDslVars, int,	short*);
+
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.4	Structures															*/
+/****************************************************************************/
+
+/*
+ * AT command processor definitions
+ */
+#define kATRegistersNumber				56
+#define	kFirstConfigurationRegister		500
+#define	kLastConfigurationRegister		515
+#define	kFirstInternationalRegister		516
+#define	kLastInternationalRegister		595
+
+
+
+#define kATMaxDialStringSize	128
+typedef struct
+	{
+	struct 
+		{
+		uchar loadNumber;								/* Which profile to load upon powerup/reset */
+		uchar countryCode;								/* T.35 Country Code */
+		uchar profile[2][kATRegistersNumber];
+		uchar dialString[4][kATMaxDialStringSize + 1];
+		} config;
+	ulong versionCode;
+	ulong crcCheckSum;
+	} NVRAMConfiguration;
+
+/* Structure to hold international settings */
+typedef	struct
+	{
+	char						*name;
+	int							countryCode;
+	const SRegisterDefinition	*userRegisters;
+	const ulong					*configRegisters;
+	} CountryDescriptor;
+
+/*
+ * V.34 coding parameters structure
+ */
+
+typedef struct
+	{
+	/* DO NOT CHANGE THE ORDER OF FIELDS IN THIS STRUCTURE!
+	 * (Some assembly code depends on it!)  If you
+ 	 * must add fields, please do so at the bottom.
+	 */
+
+	int					symbolRateIndex,
+						dataRateIndex,
+						userSNRAdjustment;
+	Boolean				auxChannel, 
+						expConstellation, 
+						precoding,
+						nonlinearCoding; 
+	schar	J,			/* number of data frames in superframe				*/
+			P,			/* number of mapping frames in a data frame			*/
+			r,			/* number of high mapping frames in a data frame	*/
+			b,			/* number of data bits in a mapping frame			*/
+			W,			/* number of aux bits in a data frame				*/
+			K,			/* number of S bits in a mapping frame				*/
+			q, 			/* number of Q bits in a 2D symbol					*/
+			M;			/* number of rings in shell mapping					*/
+	long	nominalVariance;	/* the signal variance which gives 1e-2 BLER Q10 */
+	int		bitsPerDataFrame;
+	short	quantRoundOff,
+			quantMask;
+	uchar	nTrellisStates, 
+			log2NTrellisStates; 
+	short	gain1xmt,
+			gain2xmt,
+			gain1rcv,
+			gain2rcv;
+	ushort	bitInversionPattern;
+	} V34CodingParams;
+
+typedef	long				v8bisStatusCode;
+typedef	bitMap				v8bisConnectionSetup;
+#if defined(V8BIS) || defined(AT_COMMANDS_V8BIS)
+#include "V8bisMainTypes.h"
+#endif
+
+#define kMaxMultiTones				4	/* MultiTone: search for up to this many tones at once */
+
+#ifndef ADSL_MODEM
+typedef	struct
+	{
+	modemStatusCode		code;
+	union
+		{
+		long						value;
+		long						freq;
+		modemErrorCode				error;
+		modulationMap				modulation;
+		modulationMap				modemSignal;
+		dataRateMap					dataRate;
+		long						dtmfSignal;
+		bitMap						callProgressSignal;
+		bitMap						customSignal;
+		void						*ptr;
+		struct
+			{
+			long				detected;
+			long				numTones;
+			long				tones[kMaxMultiTones];
+			} multiToneInfo;
+		struct
+			{
+			v8bisStatusCode		code;
+			long				value;
+			} v8bisStatus;
+		struct
+			{
+			trainingProgressCode	code;	
+			long					value;			
+			} trainingInfo;
+		struct
+			{
+			long					code;	
+			long					value;			
+			} v24Circuit;
+		struct
+			{
+			trainingProgressCode	code;	
+			void*					ptr;			
+			} advancedTrainingInfo;
+		struct
+			{
+			capabilitiesStatusCode	code;	
+			long					value;			
+			} capabilitiesStatusInfo;
+		struct
+			{
+			connectionInfoCode		code;
+			long					value;			
+			} connectionInfo;
+		struct
+			{
+			connectionInfoCode		code;
+			int						length;
+			uchar					*ptr;
+			} advancedConnectionInfo;
+		struct
+			{
+			dialerStatusCode		code;
+			long					value;
+			long					makeTime;			
+			long					breakTime;			
+			} dialerStatus;
+		struct
+			{
+			long					enabled;
+			long					volume;			
+			} speakerStatus;
+		framingInfoCode				framingInfo;
+		IOStatusCode				ioStatus;
+		struct
+			{
+			lapmStatusCode			code;
+			union
+				{
+				long				value;
+				lapmTakedownReason	reason;
+				lapmErrorCode		error;
+				lapmTestResultCode	testResult;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				} param;			
+			} lapmStatus;
+		struct
+			{
+			lapmParameterCode		code;
+			long					value;
+			} lapmParameter;
+		struct
+			{
+			v42bisStatusCode		code;
+			union
+				{
+				long				value;
+				v42bisErrorCode		error;
+				struct
+					{
+					long	nBytesIn;
+					long	nBytesOut;
+					} statistic;
+				} param;			
+			} v42bisStatus;
+		struct
+			{
+			mnpStatusCode			code;
+			union
+				{
+				long				value;
+				mnpTakedownReason	reason;
+				mnpErrorCode		error;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					ulong	nSize;
+					uchar  *Buffer;
+					} fallback;
+				struct
+					{
+					char	*header;
+					void	*frame;
+					} frame;
+				struct
+					{
+					long	nack;
+					long	rFrameNo;
+					} timeout;
+				struct
+					{
+					long	frameNo;
+					long	framesPending;
+					} retrFrame;
+				} param;			
+			} mnpStatus;
+		struct
+			{
+			mnpParameterCode		code;
+			long					value;
+			} mnpParameter;
+		struct
+			{
+			v70StatusCode			code;
+			union
+				{
+				long				value;
+				v70TakedownReason	reason;
+				v70ErrorCode		error;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	nack;
+					long	rFrameNo;
+					} timeout;
+				struct
+					{
+					long	frameNo;
+					long	framesPending;
+					} retrFrame;
+				struct 	
+					{
+					long	ChannelId;
+					long	DLCI;
+					ulong	LcNum;
+					v70TakedownReason	reason;
+					} channelInfo;			
+				struct 	
+					{
+					long	ChannelId;
+					long	stateOld;
+					long	stateNew;
+					} stateInfo;			
+				} param;
+			ulong	v70Time;
+			} v70Status;
+		struct
+			{
+			audioStatusCode			code;
+			union
+				{
+				long		value;
+				struct
+					{
+					long	nReq;
+					long	nAvail;
+					} buffer;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				} param;
+			} audioStatus;
+		struct
+			{
+			v80StatusCode			code;
+			union
+				{
+				long				value;
+				v80TakedownReason	reason;
+				v80ErrorCode		error;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	code;
+					long	value;
+					} inBand;
+				} param;
+			ulong	v80Time;
+			} v80Status;
+		struct
+			{
+			v70ParameterCode		code;
+			long					value;
+			} v70Parameter;
+		struct
+			{
+			breakType			type;
+			long				length;
+			} breakStatus;
+		struct
+			{
+			callerIDStatusCode			code;
+			union
+				{
+				long				value;
+				struct
+					{
+					callerIDErrorCode	code;
+					long				value;	
+					} callerIDError;
+				struct
+					{
+					long			length;
+					char*			ptr;	
+					} message;
+				} param;			
+			} callerIDStatus;
+		struct
+			{
+			ulong		signal;
+			uchar		*msg1;
+			long		msg1Length;	
+			uchar		*msg2;
+			long		msg2Length;	
+			} A8RStatus;
+		struct
+			{
+			overlayStatusCode		code;
+			long					value;
+			long					value2;
+			} overlayStatus;
+		struct
+			{
+			ulong	nBits;
+			ulong	nBlocks;
+			ulong	nBitErrors;
+			ulong	nBlockErrors;
+
+			ulong	nAudioBits;
+			ulong	nAudioBlocks;
+			ulong	nAudioSyncErrors;
+			ulong	nAudioBlockErrors;
+			} testResults;
+		ulong					checksum;
+		struct
+			{
+			ulong	sizeM;
+			uchar	*filename;
+			} logFileControlStatus;
+		struct
+			{
+			long	direction;
+			long	module;
+			long	message;
+			long	data;
+			}
+		faxClass2Status;
+		
+		} param;
+	} modemStatusStruct;
+	
+typedef	void	(SM_DECL *statusHandlerType)	(void *gDslVars, modemStatusStruct*);
+#endif	/* ADSL_MODEM */
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.5	Command structure													*/
+/****************************************************************************/
+
+typedef struct
+	{
+    Boolean remoteModemIsFlex;
+    uchar   countryCode;
+    ushort  manufacturerId;
+    uchar   licenseeId;
+    uchar   productCapabilities;
+    Boolean digitalModeFlag;
+    Boolean prototypeFlag;
+    uchar   version;
+	}
+FlexV8bisStruct;
+
+typedef struct
+	{
+	symbolRateMap	symbolRates;
+	dataRateMap		dataRates;
+	dataRateMap		dataRates56k;
+	dataRateMap     dataRatesFlex;
+	featureMap		features;
+	bitMap			auxFeatures;
+	bitMap			demodCapabilities;
+	long			rateThresholdAdjustment;	/* dB Q4	*/
+    FlexV8bisStruct flexRemoteV8bisInfo;
+	}	dataPumpCapabilities;
+
+#ifndef ADSL_MODEM
+typedef	struct	SoftwareModemCommandParameters
+	{
+	modemCommandCode		command;
+	union
+		{
+		long				xmtGain;
+		ulong				hybridDelayQ4ms;
+		long				modemSampleRate;
+		long				timeInMs;
+		long				state;
+		long				freq;
+		NVRAMConfiguration	*nvramConfigurationPtr;
+		long				enabled;
+		long				value;
+		uchar				*phoneNumber;
+		uchar				*faxECMPageBufferPtr;
+		CountryDescriptor	*countryDescriptorTable;
+		struct
+			{
+			dataRateMap			dteRate;
+			bitMap				format;
+			} dteRateSpec;
+		struct
+			{
+			v8ControlType		code;
+			long				value;
+			uchar				*buffer;
+			} v8ControlSpec;
+		struct
+			{
+			directionType			direction;
+			v8bisConnectionSetup	setup;
+			void					*capPtr;
+			voidFuncType			confirmMsFunc;
+			voidFuncType			genMsFunc;
+			xmtHandlerWithRtnValType	ogmFunc;
+			} v8bisSpec;
+		struct
+			{
+			directionType	direction;
+			} ADSISpec;
+		struct
+			{
+			directionType			direction;
+			modulationMap			modulations;
+			dataPumpCapabilities	capabilities;
+			} modeSpec;
+		struct
+			{
+			long			time, 
+							freq1, 
+							freq2, 
+							freq3, 
+							freq4,
+							mag1, 
+							mag2,
+							mag3,
+							mag4;
+			} toneSpec;
+		struct
+			{
+			long		signal;
+			uchar		*msg1;
+			long		msg1Length;	
+			uchar		*msg2;
+			long		msg2Length;	
+			long		sig_en;
+			long		msg_en;
+			long		supp_delay;
+			}
+			v8bisMessageSpec;
+		struct
+			{
+			linkLayerType		type;
+			bitMap				setup;
+			dataRateMap			rxDataRate;
+			dataRateMap			txDataRate;
+			long				rtDelayQ4ms;				
+			rxDataHandlerType	rxDataHandlerPtr;
+			txDataHandlerType	txDataHandlerPtr;
+			} linkLayerSpec;
+		struct
+			{
+			framerType			type;
+			bitMap				setup;
+			directionType		direction;
+			long				fill[2]; /* need to match linkLayerSpec */
+			rxDataHandlerType	rxDataHandlerPtr;
+			txDataHandlerType	txDataHandlerPtr;
+			} framerSpec;
+		struct
+			{
+			framerParameterCode	code;
+			long				value;
+			} framerParameterSpec;
+		struct
+			{
+			bitMap				callProgressDetectorSetup;
+			signalDetectorType	callProgressDetectorPtr;	/* if nil, use defaults			*/
+			signalDetectorType	customDetectorPtr;			/* if nil, no custom detector	*/
+			} callProgressMonitorSpec;
+		struct
+			{
+			ulong			maxTones;					/* maximum number of simultaneous tones to detect */
+			ulong			allowableVariance;			/* maximum cumulative variance in the eight interpolated frequencies */
+			ulong			totalPowerThreshold;		/* ignore complete block if power less than this */
+			ulong			powerShiftThreshold;		/* ignore a bin if its power is less than (totalPowerValue >> powerShiftThreshold) */
+			ulong			toneMatchThresholdHz;		/* tones within +/- this many Hz of original tone are considered the same tone */
+			ulong			binSeparation;				/* ignore tones with a spacing of less than this */
+			ulong			outsideFreqDeviation;		/* an individual value in the interpolated array can be up to this many Hz outside of the expected angle range */
+			} multiToneSpec;
+		struct
+			{
+			uchar				*dialString;	/* nil limited string for DTMF dialing sequence	*/
+			long				pulseBreakTime, 
+								pulseMakeTime, 
+								pulseInterDigitTime,
+								toneDigitTime, 
+								toneInterDigitTime, 
+								toneLoGroupMag,
+								toneHiGroupMag,
+								flashTime, 
+								pauseTime,
+								signalWaitTimeout,	
+								blindDialingTimeout; 	
+			bitMap				dialerSetup;
+			bitMap				callProgressDetectorSetup;
+			signalDetectorType	callProgressDetectorPtr;	/* if nil, use defaults			*/	
+			signalDetectorType	customDetectorPtr;			/* if nil, no custom detector	*/
+			hookHandlerType		hookHandlerPtr;				/* nil if DTMF dialing specified*/
+			} dialSpec;
+		struct
+			{
+			long			timeOn, 
+							timeOff, 
+							freq;
+			} callingToneSpec;
+		union
+			{
+			statusHandlerType	statusHandlerPtr;
+			eyeHandlerType		eyeHandlerPtr;
+			logHandlerType		logHandlerPtr;
+			rxDataHandlerType	rxDataHandlerPtr;
+			txDataHandlerType	txDataHandlerPtr;
+			} handlerSpec;
+		struct
+			{
+			breakType			type;
+			long				length;
+			} breakSpec;
+		struct
+			{
+			long				length;
+			uchar				*dataPtr;
+			} lapmTestSpec;
+		struct
+			{
+			bitMap				setupLapm;
+			rxDataHandlerType	rxAudioHandlerPtr;
+			txDataHandlerType	txAudioHandlerPtr;
+            } v70SetupSpec;
+		struct
+			{
+			ulong				ChannelId;
+			ulong				LogChannelNum;
+			ulong				PortNum;
+            } EstChannelSpec;
+		struct
+			{
+			ulong				ChannelId;
+            } WaitChannelSpec;
+		struct
+			{
+			ulong				ChannelId;
+			ulong				LogChannelNum;
+			ulong				PortNum;
+			ulong				DLCI;
+            } RelChannelSpec;
+		struct
+			{
+			audioType			type;
+			bitMap				setup;
+			dataRateMap			rxAudioRate;
+			dataRateMap			txAudioRate;
+			rxAudioHandlerType	rxAudioHandlerPtr;
+			txAudioHandlerType	txAudioHandlerPtr;
+			} audioSpec;
+		struct
+			{
+			long					code;	
+			long					value;			
+			} v24Circuit;
+		struct
+			{
+			ulong					code;	
+			ulong					value;			
+			ulong					minValue;
+			ulong					maxValue;
+			} atRegister;
+		struct
+			{
+			long					code;	
+			uchar					*response;
+			} atiSpec;
+		struct
+			{
+			long					length;
+			uchar					*framePtr;
+			} frameSpec;
+		struct
+			{
+			long					code;
+			union
+				{
+				long				value;
+				struct
+					{
+					long			loFreq1;
+					long			hiFreq1;
+					long			loFreq2;
+					long			hiFreq2;
+					} freqRange;
+				} params;
+			} callProgressParamSpec;
+		struct
+			{
+			v250IdStringCode	v250IdCode;
+			uchar				*v250IdString;
+			} v250IdSpec;
+
+		} param;
+	} modemCommandStruct;
+	
+typedef	Boolean	(*commandHandlerType)	(modemCommandStruct*);
+#endif /* ADSL_MODEM */
+
+
+
+/****************************************************************************/
+/*	2.	Constant definitions.												*/
+/*																			*/
+/*	2.1	Definitive constants												*/
+/****************************************************************************/
+
+#define kMaxSampleBlockSize			48
+#define kMaxDataBlockSize			48
+
+#define	kMaxDialStringLength		127
+#define	kCallProgressSampleRate		7200
+
+#define	kMaxCallerIDMessageLength	80
+
+/****************************************************************************/
+/*	2.	Constant definitions.												*/
+/*																			*/
+/*	2.2	Bit maps														*/
+/****************************************************************************/
+
+/* modulationMap */
+
+#define	kIdle					0x00000000
+#define	kV25					0x00000001
+#define	kV8						0x00000002
+#define	kCid					0x00000004
+#define	kV8bis					0x00000008
+#define	kV21					0x00000010
+#define	kV22					0x00000020
+#define	kV23					0x00000040
+#define	kV32					0x00000080
+#define	kV34					0x00000100
+#define	kX2						0x00000200
+#define	kV90					0x00000400
+#define	k56Flex					0x00000800
+#define	kV27					0x00001000
+#define	kV29					0x00002000
+#define	kV17					0x00004000
+#define	kV34HDX					0x00008000
+#define	kV34HDXC				0x00010000
+#define	kBell103				0x00100000
+#define	kBell212				0x00200000
+#define	kDataCallingTone		0x01000000
+#define	kFaxCallingTone			0x02000000
+
+#define	kV22FastNZConnect	    0x04000000
+#define kV22FastNNZConnect      0x08000000
+#define kV22FastConnect         (kV22FastNZConnect|kV22FastNNZConnect)
+#define kV22bisFastConnect      0x10000000
+
+
+#define	kDataModulations	(kV25 | kV8 | kV21 | kV22FastConnect | kV22bisFastConnect | kV22 | kV23 | kV32 | kV34 | kBell103 | kBell212)
+#define	kDataOnlyModulations (kV21 | kV22 | kV23 | kV32 | kBell103 | kBell212)
+#define	kPCMModulations		(kV90 | kX2 | k56Flex)
+
+#define	kFaxModulations		(kV25 | kV21 | kV27 | kV29 | kV17)
+#define	kFaxOnlyModulations	(kV27 | kV29 | kV17)
+#define	kFaxModulationShift		12
+
+/* symbolRateMap	*/
+
+#define	k1200Hz			0x00000001
+#define	k1600Hz			0x00000002
+#define	k2400Hz			0x00000004
+#define	k2743Hz			0x00000008
+#define	k2800Hz			0x00000010
+#define	k3000Hz			0x00000020
+#define	k3200Hz			0x00000040
+#define	k3429Hz			0x00000080
+#define	k8000Hz			0x00000100
+
+#define	kAllSymbolRates	(	k1200Hz | k1600Hz | k2400Hz | k2743Hz | \
+							k2800Hz | k3000Hz | k3429Hz | k8000Hz )
+
+/* dataRateMap	*/
+
+#define	k75bps			0x00000002
+#define	k300bps			0x00000004
+#define	k600bps			0x00000008
+#define	k1200bps		0x00000010
+#define	k2400bps		0x00000020
+#define	k4800bps		0x00000040
+#define	k7200bps		0x00000080
+#define	k9600bps		0x00000100
+#define	k12000bps		0x00000200
+#define	k14400bps		0x00000400
+#define	k16800bps		0x00000800
+#define	k19200bps		0x00001000
+#define	k21600bps		0x00002000
+#define	k24000bps		0x00004000
+#define	k26400bps		0x00008000
+#define	k28800bps		0x00010000
+#define	k31200bps		0x00020000
+#define	k33600bps		0x00040000
+#define	k36000bps		0x00080000
+#define	k38400bps		0x00100000
+#define	k57600bps		0x00200000
+#define	k115200bps		0x00400000
+#define	k230400bps		0x00800000
+#define	k460800bps		0x01000000
+#define	k921600bps		0x02000000
+/*
+ * kPCMRate is used to identify that the reported rate is
+ * PCM modulation rate, and is only used for PCM modulation while
+ * reporting rate !!!!
+ */
+#define	kPCMRate		0x40000000
+#define kPCMFlexRate    0x80000000
+#define	kAllDataRates   0x0FFFFFFF
+
+/* rates specific for X2  and V.90 */
+#define	kPCM25333bps	0x00000001
+#define	kPCM26666bps	0x00000002
+#define	kPCM28000bps	0x00000004
+#define	kPCM29333bps	0x00000008
+#define	kPCM30666bps	0x00000010
+#define	kPCM32000bps	0x00000020
+#define	kPCM33333bps	0x00000040
+#define	kPCM34666bps	0x00000080
+#define	kPCM36000bps	0x00000100
+#define	kPCM37333bps	0x00000200
+#define	kPCM38666bps	0x00000400
+#define	kPCM40000bps	0x00000800
+#define	kPCM41333bps	0x00001000
+#define	kPCM42666bps	0x00002000
+#define	kPCM44000bps	0x00004000
+#define	kPCM45333bps	0x00008000
+#define	kPCM46666bps	0x00010000
+#define	kPCM48000bps	0x00020000
+#define	kPCM49333bps	0x00040000
+#define	kPCM50666bps	0x00080000
+#define	kPCM52000bps	0x00100000
+#define	kPCM53333bps	0x00200000
+#define	kPCM54666bps	0x00400000
+#define	kPCM56000bps	0x00800000
+#define	kPCM57333bps	0x01000000
+
+#define	kV90ServerToClientDataRates	\
+						(	kPCM28000bps | kPCM29333bps | kPCM30666bps | \
+							kPCM32000bps | kPCM33333bps | kPCM34666bps | \
+							kPCM36000bps | kPCM37333bps | kPCM38666bps | \
+							kPCM40000bps | kPCM41333bps | kPCM42666bps | \
+							kPCM44000bps | kPCM45333bps | kPCM46666bps | \
+							kPCM48000bps | kPCM49333bps | kPCM50666bps | \
+							kPCM52000bps | kPCM53333bps | kPCM54666bps | \
+							kPCM56000bps | kPCM57333bps )
+
+#define	kV90ClientToServerDataRates	\
+						(	k4800bps  | k7200bps  | k9600bps  | k12000bps | \
+							k14400bps | k16800bps | k19200bps | k21600bps | \
+							k24000bps | k26400bps | k28800bps | k31200bps | \
+							k33600bps )	
+
+
+
+#define	kX2ServerToClientDataRates	\
+						(	kPCM25333bps | kPCM26666bps | kPCM28000bps | \
+							kPCM29333bps | kPCM30666bps | kPCM32000bps | \
+							kPCM33333bps | \
+							kPCM34666bps | kPCM36000bps | kPCM37333bps | \
+							kPCM38666bps | kPCM40000bps | kPCM41333bps | \
+							kPCM42666bps | kPCM44000bps | kPCM45333bps | \
+							kPCM46666bps | kPCM48000bps | kPCM49333bps | \
+							kPCM50666bps | kPCM52000bps | kPCM53333bps | \
+							kPCM54666bps | kPCM56000bps | kPCM57333bps )
+#define	kX2ClientToServerDataRates	\
+						(	k4800bps | k7200bps | k9600bps | k12000bps | k14400bps | \
+								k16800bps | k19200bps | k21600bps | k24000bps | k26400bps | k28800bps | \
+								k31200bps )
+
+  /*
+  Rates specific for Flex
+  */
+#define kPCMFlex32000bps  0x00000001
+#define kPCMFlex34000bps  0x00000002
+#define kPCMFlex36000bps  0x00000004
+#define kPCMFlex38000bps  0x00000008
+#define kPCMFlex40000bps  0x00000010
+#define kPCMFlex42000bps  0x00000020
+#define kPCMFlex44000bps  0x00000040
+#define kPCMFlex46000bps  0x00000080
+#define kPCMFlex48000bps  0x00000100
+#define kPCMFlex50000bps  0x00000200
+#define kPCMFlex52000bps  0x00000400
+#define kPCMFlex54000bps  0x00000800
+#define kPCMFlex56000bps  0x00001000
+#define kPCMFlex58000bps  0x00002000
+#define kPCMFlex60000bps  0x00004000
+
+#define	kFlexServerToClientDataRates \
+                        (   kPCMFlex32000bps | kPCMFlex34000bps | kPCMFlex36000bps | kPCMFlex38000bps | \
+							kPCMFlex40000bps | kPCMFlex42000bps | kPCMFlex44000bps | kPCMFlex46000bps | \
+							kPCMFlex48000bps | kPCMFlex50000bps | kPCMFlex52000bps | kPCMFlex52000bps | \
+							kPCMFlex54000bps | kPCMFlex56000bps | kPCMFlex58000bps | kPCMFlex60000bps )
+
+#define	kFlexClientToServerDataRates	\
+						(	k4800bps  | k7200bps  | k9600bps  | k12000bps | \
+							k14400bps | k16800bps | k19200bps | k21600bps | \
+							k24000bps | k26400bps | k28800bps | k31200bps )
+
+
+#define	k2400BitShift	5
+#define	k4800BitShift	6
+
+#define	kPCM28000bpsShift	2
+
+#define	kV21Rates			k300bps
+#define	kV22Rates			k1200bps
+#define	kV22bisRates		(k1200bps | k2400bps)
+#define	kV23Rates			(k75bps | k1200bps)
+#define	kCidRates			(k1200bps)
+#define	kV32Rates			(k4800bps | k9600bps)
+#define	kV32bisRates		(kV32Rates | k7200bps | k12000bps | k14400bps)
+#define	kV32terboRates		(kV32bisRates | k16800bps | k19200bps)	
+#define	kV34Rates			(	k2400bps | k4800bps | k7200bps | k9600bps | k12000bps | k14400bps | \
+								k16800bps | k19200bps | k21600bps | k24000bps | k26400bps | k28800bps | \
+								k31200bps | k33600bps )	
+
+#define	kV27Rates			(k2400bps | k4800bps)
+#define	kV29Rates			(k4800bps | k7200bps | k9600bps)
+#define	kBell103Rates       k300bps
+#define	kBell212Rates       k1200bps
+
+
+/* Demodulator capabilities	*/
+#define	kNeecEnabled					0x00000001
+#define	kPFeecEnabled					0x00000002
+#define	kIeecEnabled					0x00000004
+#define	kFeecEnabled					0x00000008
+
+#define	kRapidEqualizerTraining			0x00000010
+#define	kRapidPECTraining				0x00000020
+#define	kRapidECTraining				0x00000040
+#define	kAutoLoadReductionEnabled		0x00000080
+
+#define	kTimingTrackingEnabled			0x00000100
+#define	kPhaseLockedLoopEnabled			0x00000200
+#define	kFeecPhaseLockedLoopEnabled		0x00000400
+#define	kPhaseJitterTrackingEnabled		0x00000800
+
+#define	kClockErrorTrackingEnabled		0x00001000
+#define	kFreqOffsetTrackingEnabled		0x00002000
+#define	kFeecFreqOffsetTrackingEnabled	0x00004000
+
+#define	kShorterNeecEnabled				0x00008000
+#define	kShorterPFeecEnabled			0x00010000
+#define	kFrondEndHPFilterEnabled		0x00020000
+#define kGainControlEnabled				0x00040000
+#define kPhaseHitControlEnabled			0x00080000
+#define	kBandEdgeCorrectorEnabled		0x00100000
+#define kDisableFaxFastClearDown		0x00200000
+
+#define kImdOffsetCompensationEnabled	0x00400000
+
+#define kV34ShortEqlLengthExtShift  23
+#define kV34ShortEqlLengthExtMask      (0x3<<kV34ShortEqlLengthExtShift)
+#define kV34EqlLengthReductionEnabled  (1<<(kV34ShortEqlLengthExtShift+2))
+#define kPCMIeecLengthReductionEnabled (1<<(kV34ShortEqlLengthExtShift+3))
+
+/* featureMap	*/
+
+#define	kAllFeatures				0xFFFFFFFF
+
+#define	kAutomodingEnabled			0x00000001	/* bit 1	*/
+#define	kAutomodingDisabled			0x00000000	/* bit 1	*/
+
+#define	kV8SendCIEnabled			0x00000002	/* bit 2	*/
+#define	kV8SendCIDisabled			0x00000000	/* bit 2	*/
+
+#define	kV34CMEModem				0x00000004	/* bit 3	*/
+#define	kV34NotCMEModem				0x00000000	/* bit 3	*/
+
+#define	kV34ExtraINFOPreamble		0x00000008	/* bit 4	*/
+
+#define	kRetrainingEnabled			0x00000010
+#define	kRateRenegotiationEnabled	0x00000020
+#define	kTrellisCodingEnabled		0x00000040
+
+/* Fax specific features	*/
+#define	kFaxShortTraining			0x00000080
+#define	kFaxEchoSuppressionEnabled	0x00000100
+
+/* V.22/V.22bis specific features	*/
+#define	kV22GuardTone1800HzEnabled	0x00000200
+#define	kV22GuardTone550HzEnabled	0x00000400
+
+
+/* V.34 specific features	*/
+
+#define	kV34bisEnabled				0x00000800
+
+#define	kV34PowerReductionAllowed	0x00001000
+#define	kAuxChannelEnabled			0x00002000
+#define	kAuxChannelDisabled			0x00000000
+#define	kV34TrellisEncoderTypeMask	0x0000C000
+#define	kV34TrellisEncoderTypeShift	14
+
+#define	kTRN16						0x00010000
+#define	kAssymDataRatesEnabled		0x00020000
+#define	kNonLinearCodingEnabled		0x00040000
+#define	kConstShapingEnabled		0x00080000
+#define	kPrecodingEnabled			0x00100000
+
+#define	kV34LoFcAt2400HzEnabled		0x00200000
+#define	kV34HiFcAt2400HzEnabled		0x00400000
+#define	kV34LoFcAt2743HzEnabled		0x00800000
+#define	kV34HiFcAt2743HzEnabled		0x01000000
+#define	kV34LoFcAt2800HzEnabled		0x02000000
+#define	kV34HiFcAt2800HzEnabled		0x04000000
+#define	kV34LoFcAt3000HzEnabled		0x08000000
+#define	kV34HiFcAt3000HzEnabled		0x10000000
+#define	kV34LoFcAt3200HzEnabled		0x20000000
+#define	kV34HiFcAt3200HzEnabled		0x40000000
+#define	kV34LoFcAt3429HzEnabled		0x80000000
+#define	kV34HiFcAt3429HzEnabled		0x80000000
+
+/* auxiliary features definintions map */
+
+#define	kLoopbackTestFinish				0x00000000
+#define	kLoopbackTestV54Loop1			0x00000001
+#define	kLoopbackTestV54Loop2			0x00000002
+#define	kLoopbackTestV54Loop3			0x00000003
+#define	kLoopbackTestTypeMask			0x00000003
+#define	kLoopbackTestAutoRespondEnabled	0x00000004
+#define	kLoopbackSelfTest				0x00000008
+
+#define	kPreempFilterMask			0x000000F0
+#define	kPreempFilterShift			4
+
+#define	kPcmCodingTypeMuLaw			0x00000100
+#define	kPcmServerToServerEnabled	0x00000200
+#define	kPcmIsServerModem			0x00000400
+#define	kPcmAnalogModemAvailable	0x00000800
+#define	kPcmDigitalModemAvailable	0x00001000
+#define	kPcmDceOnDigitalNetwork		0x00002000
+#define	kPcmDModemPwrCalAtCodecOut	0x00004000
+#define	kPcm3429UpstreamAvailable	0x00008000
+
+#define	kPcmSpectralShapingBitsMask		0x00070000
+#define	kPcmSpectralShapingBitsShift	16
+#define	kV90ServerNotDetSbarAfterJdbarFix	0x00080000
+
+#define kAutomoderPassive			0x00400000
+
+#define	kV8HoldANSamUntilDetCI		0x00800000
+#define	kFaxSendFromOrgSide			0x01000000
+#define	kFaxV34HDX2400bpsCtrlChan	0x02000000
+#define	kFaxV34HDXAllowAsymCtrlChan	0x04000000
+#define	kV8ANSamStageDisabled		0x08000000
+
+#define kFlexSkipV8bis              0x10000000
+#define kV34ControlChannelEnabled   0x20000000
+#define kV34SeamlessRateChangeEnabled 0x40000000
+
+#define	kPTTTest					0x80000000
+
+/* call progress detection Map	*/
+
+#define	kDialTone				0x00000001
+#define	kRingBack				0x00000002
+#define	kBusy					0x00000004
+#define	kReorder				0x00000008
+#define	k2ndDTn					0x00000010
+#define	kBongTone				0x00000020
+
+/* Break type bit settings	*/
+#define	kExpedited		0x0001
+#define	kDestructive	0x0002
+
+/* async Framer setup map		*/
+
+#define	kNDataBitsMask	0x03
+#define	k5DataBits		0x00
+#define	k6DataBits		0x01
+#define	k7DataBits		0x02
+#define	k8DataBits		0x03
+
+#define	kNDataBitsShift		0
+#define	kNDataBitsOffset	5
+
+#define	kParityTypeMask	0x1C
+#define	kNoParity		0x00
+#define	kOddParity		0x04
+#define	kEvenParity		0x08
+#define	kMarkParity		0x0C
+#define	kSpaceParity	0x10
+
+#define	kNStopBitsMask	0x60
+#define	k1StopBits		0x00
+#define	k2StopBits		0x20
+
+#define	kNStopBitsShift		5
+#define	kNStopBitsOffset	1
+
+/* Sync Framer setup map		*/
+
+#define kUnderrunCharMask			0xff
+#define kRepeatLastCharOnUnderrun	0x100
+
+/* HDLC sync framer setup maps	*/
+#define	kNFlagsBeforeFramesMask		0x3F
+#define	kNFlagsBeforeFramesShift	0
+
+#define	kNFlagsBetweenFramesMask	0x3F
+#define	kNFlagsBetweenFramesShift	6
+
+#define	k32BitCRC					0x1000
+#define	kFlagSharingEnabled			0x2000
+
+#define kNFlagsBeforeReportMask		0x03	/* no. of *extra* flags reqd before frame */
+#define kNFlagsBeforeReportShift	14
+
+#define	kTxDeferredCRC				0x10000
+#define	kRxDeferredCRC				0x20000
+#define	kTxIdleMarks				0x40000
+#define kNoCRC						0x80000
+
+/* SAM framer setup maps	*/
+
+#define	kSAMTransparentIdleTypeMask		0x00000003
+#define	kSAMTransparentIdleTypeShift	0
+#define	kSAMFramedIdleTypeMask			0x00000004
+#define	kSAMFramedIdleTypeShift			2
+#define	kSAMFramedOverrunActionMask		0x00000010
+#define	kSAMFramedOverrunActionShift	4
+#define	kSAMHalfDuplexModeMask			0x00000020
+#define	kSAMHalfDuplexModeShift			5
+#define	kSAMCRCTypeMask					0x000000C0
+#define	kSAMCRCTypeShift				6
+#define	kSAMNRZIEnabledMask				0x00000100
+#define	kSAMNRZIEnabledShift			8
+#define	kSAMSyn1Mask					0x00FF0000
+#define	kSAMSyn1Shift					16
+#define	kSAMSyn2Mask					0xFF000000
+#define	kSAMSyn2Shift					24
+
+/* <trans_idle> */
+#define	kSAM8bitSYNHuntDisabled		0
+#define	kSAM8bitSYNHuntEnabled		((ulong)1 << kSAMTransparentIdleTypeShift)
+#define	kSAM16bitSYNHuntEnabled		((ulong)2 << kSAMTransparentIdleTypeShift)
+
+/* <framed_idle> */
+#define	kSAMSendFlagsOnIdle			0
+#define	kSAMSendMarksOnIdle			((ulong)1 << kSAMFramedIdleTypeShift)
+
+/* <framed_un_ov> */
+#define	kSAMAbortOnUnderrun			0
+#define	kSAMFlagsOnUnderrun			((ulong)1 << kSAMFramedOverrunActionShift)
+
+/* <hd_auto> */
+#define	kSAMHalfDuplexNoAuto		0
+#define	kSAMHalfDuplexAuto			((ulong)1 << kSAMHalfDuplexModeShift)
+
+
+/* <crc_type> */
+#define	kSAMNoCRC					0
+#define	kSAM16bitCRC				((ulong)1 << kSAMCRCTypeShift) 
+#define	kSAM32bitCRC				((ulong)2 << kSAMCRCTypeShift) 
+				
+/* <nrzi_en> */
+#define	kSAMNRZIDisabled			0
+#define	kSAMNRZIEnabled				((ulong)1 << kSAMNRZIEnabledShift)
+
+
+/* LAPM setup maps	*/
+#define	kLapmDirection				0x00000001		/* Bit 0  */
+#define	kLapmSREJEnabled			0x00000002		/* Bit 1  */
+#define	kLapmDetectionEnabled		0x00000004		/* Bit 2  */
+#define	kLapmLongADPEnabled			0x00000008		/* Bit 3  */
+
+#define	kLapmCompressionEnabledMask	0x00000030
+#define	kLapmTxCompressionEnabled	0x00000010		/* Bit 4  */
+#define	kLapmRxCompressionEnabled	0x00000020		/* Bit 5  */
+#define	kLapmCompressionEnabledShift		4
+
+#define	kLapmRetryLimitMask			0x000000C0		/* Bits 6,7  */
+
+#define	kLapmNoRetryLimit			0x00000000
+#define	kLapm4Retries				0x00000040
+#define	kLapm8Retries				0x00000080
+#define	kLapm20Retries				0x000000C0
+
+#define	kLapmWindowSizeMask			0x00001F00		/* Bits 8-12  */
+#define	kLapmWindowSizeShift		8
+
+#define	kLapmWindowSize8			0x00000800
+#define	kLapmWindowSize15			0x00000F00
+
+
+#define	kLapmInfoFieldSizeMask		0x0000E000		/* Bits 13-15  */
+#define	kLapmInfoField8Bytes		0x00000000
+#define	kLapmInfoField16Bytes		0x00002000
+#define	kLapmInfoField32Bytes		0x00004000
+#define	kLapmInfoField64Bytes		0x00006000
+#define	kLapmInfoField128Bytes		0x00008000
+#define	kLapmInfoField192Bytes		0x0000A000
+#define	kLapmInfoField256Bytes		0x0000C000
+#define	kLapmInfoField512Bytes		0x0000E000
+#define	kLapmInfoFieldSizeShift		13
+
+#define	kLapmT400Mask				0x00030000		/* Bits 16-17	*/
+#define	kLapmAutoT400				0x00000000
+#define	kLapm750msT400				0x00010000
+#define	kLapm3secT400				0x00020000
+#define	kLapm30secT400				0x00030000
+
+#define	kLapmT401Mask				0x000C0000		/* Bits 18-19	*/
+#define	kLapmAutoT401				0x00000000
+#define	kLapm750msT401				0x00040000
+#define	kLapm3secT401				0x00080000
+#define	kLapm6secT401				0x000C0000
+
+#define	kLapmT403Mask				0x00300000		/* Bits 20-21	*/
+#define	kLapmAutoT403				0x00000000
+#define	kLapm750msT403				0x00100000
+#define	kLapm2secT403				0x00200000
+#define	kLapm4secT403				0x00300000
+
+
+
+#define	kLapmDictSizeMask			0x00C00000		/* Bits 22-23  */
+#define	kLapmDictSize512			0x00000000
+#define	kLapmDictSize1024			0x00400000
+#define	kLapmDictSize2048			0x00800000
+#define	kLapmDictSize4096			0x00C00000
+
+#define	kLapmStringSizeMask			0xFF000000		/* Bits 24-31  */
+#define	kLapmStringSizeShift		24
+
+/* MNP setup maps	*/
+
+#define	kMnpMinPLevel				0x00000001		/* Bit 0: 1 - Minimal, 0 - Standard */
+#define	kMnpStdPLevel				0x00000000		/* Bit 0: 1 - Minimal, 0 - Standard */
+
+#define	kMnpOptimizationEnabled		0x00000002		/* Bit 1  */
+#define	kMnpOptimizationDisabled	0x00000000		/* Bit 1  */
+
+#define	kMnpCompressionEnabled		0x00000004		/* Bit 2  */
+#define	kMnpCompressionDisabled		0x00000000		/* Bit 2  */
+
+#define	kMnpClassMask				0x00000018
+#define	kMnpClassShift						 3
+#define	kMnpClass1					0x00000008
+#define	kMnpClass2					0x00000010
+#define	kMnpClass3					0x00000018		/* Bits 3,4 */
+
+#define kMnpMaxRetryMask		    0x00000060		/* Bits 5,6 */
+#define kMnpMaxRetryShift					 5
+#define	kMnpNoRetryLimit			0x00000000
+#define	kMnp4Retries				0x00000020
+#define	kMnp8Retries				0x00000040
+#define	kMnp20Retries				0x00000060
+
+#define	kMnpInfoFieldSizeMask		0x00000380		/* Bits 7-9  */
+#define	kMnpInfoFieldSizeShift				 7
+#define	kMnpInfoField8Bytes			0x00000000
+#define	kMnpInfoField16Bytes		0x00000080
+#define	kMnpInfoField32Bytes		0x00000100
+#define	kMnpInfoField64Bytes		0x00000180
+#define	kMnpInfoField128Bytes		0x00000200
+#define	kMnpInfoField192Bytes		0x00000280
+#define	kMnpInfoField256Bytes		0x00000300
+#define	kMnpInfoField260Bytes		0x00000380
+
+#define	kMnpT400Mask				0x00003000		/* Bits 12,13 */
+#define	kMnpT400Shift						12
+#define	kMnpAutoT400				0x00000000
+#define	kMnp750msT400				0x00001000
+#define	kMnp3secT400				0x00002000
+#define	kMnp6secT400				0x00003000
+
+#define	kMnpT401Mask				0x0000C000		/* Bits 14,15 */
+#define	kMnpT401Shift						14
+#define	kMnpAutoT401				0x00000000
+#define	kMnp750msT401				0x00004000
+#define	kMnp3secT401				0x00008000
+#define	kMnp6secT401				0x0000C000
+
+#define	kMnpT403Mask				0x00030000		/* Bits 16,17 */
+#define	kMnpT403Shift						16
+#define	kMnpAutoT403				0x00000000
+#define	kMnp60secT403				0x00010000
+#define	kMnp600secT403				0x00020000
+#define	kMnp3600secT403				0x00030000
+
+#define kMnpFallbackTypeMask		0x000C0000		/* Bits 18,19 */
+#define kMnpFallbackTypeShift				18
+#define kMnpNoFallback				0x00000000
+#define kMnpFallbackTime			0x00040000
+#define kMnpFallback200				0x00080000
+#define kMnpFallbackChar			0x000C0000
+
+#define	kMnpWindowSizeMask			0x00300000		/* Bits 20,21  */
+#define	kMnpWindowSizeShift					20
+#define	kMnp1Frame 					0x00000000
+#define	kMnp4Frames 				0x00100000
+#define	kMnp8Frames 				0x00200000
+#define	kMnp16Frames 				0x00300000
+
+#define	kMnpDirection				0x00800000		/* Bit 22  */
+
+#define kMnpFallbackCharMask		0xFF000000		/* Bit 24-31  */
+#define kMnpFallbackCharShift				24
+
+/* kV34HDXTurnOffCurrentModeCmd state parameter values */
+
+#define	kV34HDXTurnOffAsClearDown				0
+#define	kV34HDXTurnOffFromControlSource			1
+#define	kV34HDXTurnOffFromControlDestination	2
+#define	kV34HDXTurnOffFromPrimarySource			3
+#define	kV34HDXTurnOffFromPrimaryDestination	4
+
+/* V70 setup maps */
+
+#define	kV70Direction				0x00000001		/* Bit 0  */
+#define	kV70uIHEnabled			    0x00000002		/* Bit 1  */
+#define	kV70AudioHeaderEnabled	    0x00000004		/* Bit 2  */
+#define kV70SilenceSupprEnabled     0x00000008		/* Bit 3  */
+
+#define	kV70SuspendResumeShift      4 
+#define	kV70SuspendResumeMask	    (3 << kV70SuspendResumeShift)
+#define	kV70SuspendResumeDisabled   0x00000000		/* Bit 4,5  */
+#define	kV70SuspendResumeWAddr      0x00000010		/* Bit 4  */
+#define	kV70SuspendResumeWoAddr     0x00000020		/* Bit 5  */
+
+#define	kV70CrcLengthShift          6 
+#define	kV70CrcLengthMask	        (3 << kV70CrcLengthShift)
+#define	kV70CrcLength16             0x00000000		/* Bit 6,7  */
+#define	kV70CrcLength8              0x00000040		/* Bit 6  */
+#define	kV70CrcLength32             0x00000080		/* Bit 7  */
+
+#define	kV70BlockingFactorShift     8 
+#define	kV70BlockingFactorMask	    (3 << kV70BlockingFactorShift)
+#define	kV70BlockingFactor1         0x00000000		/* Bit 8,9  */
+#define	kV70BlockingFactor2         0x00000100		/* Bit 8  */
+#define	kV70BlockingFactor3			0x00000200		/* Bit 9  */
+#define	kV70BlockingFactor4			0x00000300		/* Bit 8,9  */
+
+#define kV70InitChannelsShift		10
+#define kV70InitChannelsMask		(1 << kV70InitChannelsShift)
+#define	kV70InitNoChannels			0x00000000		/* Bit 10,11  */
+#define	kV70InitDataChannel			0x00000400		/* Bit 10,11  */
+#define	kV70InitAudioChannel		0x00000800		/* Bit 10,11  */
+#define	kV70InitBothChannels		0x00000C00		/* Bit 10,11  */
+
+#define kV70OOBEnabled				0x00001000		/* Bit 12 */
+
+/* V80 setup maps */
+
+#define	kV80Direction				0x00000001		/* Bit 0  */
+
+#define	kV80ModeShift				1 
+#define	kV80ModeMask				(3 << kV80ModeShift)
+#define	kV80SyncMode				(0 << kV80ModeShift)
+#define	kV80TunnellingMode			(1 << kV80ModeShift)
+#define	kV80SamMode					(2 << kV80ModeShift)
+#define	kV80SamTransparentMode		(2 << kV80ModeShift)
+#define	kV80SamFramedMode			(3 << kV80ModeShift)
+
+#define	kV80TransIdleShift			3 
+#define	kV80TransIdleMask			(3 << kV80TransIdleShift)
+#define	kV80TransIdleNoHunt			(0 << kV80TransIdleShift)
+#define	kV80TransIdleHunt8			(1 << kV80TransIdleShift)
+#define	kV80TransIdleHunt16			(2 << kV80TransIdleShift)
+
+#define	kV80FrameIdleShift			5 
+#define	kV80FrameIdleMask			(1 << kV80FrameIdleShift)
+#define	kV80FrameIdleFlags			(0 << kV80FrameIdleShift)
+#define	kV80FrameIdleMarks			(1 << kV80FrameIdleShift)
+
+#define	kV80FrameUnOvShift			6 
+#define	kV80FrameUnOvMask			(1 << kV80FrameUnOvShift)
+#define	kV80FrameUnOvAbort			(0 << kV80FrameUnOvShift)
+#define	kV80FrameUnOvFlag			(1 << kV80FrameUnOvShift)
+ 
+#define	kV80HdAutoShift				7 
+#define	kV80HdAutoMask				(1 << kV80HdAutoShift)
+#define	kV80HdAutoNormal			(0 << kV80HdAutoShift)
+#define	kV80HdAutoExtended			(1 << kV80HdAutoShift)
+
+#define	kV80CrcTypeShift			8 
+#define	kV80CrcTypeMask				(3 << kV80CrcTypeShift)
+#define	kV80NoCrc					(0 << kV80CrcTypeShift)
+#define	kV80Crc16					(1 << kV80CrcTypeShift)
+#define	kV80Crc32					(2 << kV80CrcTypeShift)
+
+#define	kV80NrziShift				10
+#define	kV80NrziMask				(1 << kV80NrziShift)
+#define	kV80NrziDisabled			(0 << kV80NrziShift)
+#define	kV80NrziEnabled				(1 << kV80NrziShift)
+
+#define kV80Syn1Mask				0x00FF0000		/* Bit 16-23  */
+#define kV80Syn1Shift				16
+#define kV80Syn2Mask				0xFF000000		/* Bit 24-31  */
+#define kV80Syn2Shift				24
+
+/* kStartCallProgressMonitorCmd setup masks */
+
+#define	kDTMFDetectorDebouncerEnabled			0x0001
+#define	kModemSignalDetectorDebouncerEnabled	0x0002
+#define	kCallProgressDetectorDebouncerEnabled	0x0004
+#define	kCustomSignalDebouncerEnabled			0x0008
+#define	kFaxCallingToneSuppressionEnabled		0x0010
+#define	kDataCallingToneSuppressionEnabled		0x0020
+#define	kCISuppressionEnabled					0x0040
+#define	kAnsSuppressionEnabled					0x0080
+
+/* kDialCmd setup masks (dialerSetup bit fields) */
+
+#define	kDTMFDialingEnabled						0x0001
+#define	kPulseDialingEnabled					0x0002
+#define	kModeSwitchEnabled						0x0004
+#define	kBlindDialingEnabled					0x0008
+#define	kPulseDialingMethodMask					0x0030
+#define	kDialModifierTranslationMask			0x00C0
+#define	kFlashWhilePulseDialingEnabled			0x0100
+
+/* Pulse dialing method */
+#define	kPulseDialingNPulsesPerDigit			0x0000
+#define	kPulseDialingNplusOnePulsesPerDigit		0x0010
+#define	kPulseDialingTenMinusNPulsesPerDigit	0x0020
+
+/* Dial modifier translation */
+#define	kTreatWasPause							0x0040	/* Tread 'W' modifier as pause */
+#define	kTreatCommaAsWaitForDialtone			0x0080
+
+#ifdef TI_C6X
+#include "C6xDefs.h"
+#endif
+#ifdef PENTIUM_MMX
+#include "PentiumDefs.h"
+#endif
+
+
+#if defined(DSP16K) && !defined(SoftModemGlobals)
+/* ensure that code generator does not use r5 */
+register int *softmodem_h_should_not_be_included_after_softmodem_gh asm("r5");
+#endif
+
+/****************************************************************************/
+/*	3.	Interface functions.												*/
+/*																			*/
+/****************************************************************************/
+
+#ifdef ADSL_MODEM
+
+#ifndef SoftDslHeader
+#include "SoftDsl.h"
+#endif
+extern	char*	SM_DECL SoftModemGetRevString(void);
+extern	char*	SM_DECL SoftModemGetProductName(void);
+extern	char*	SM_DECL	SoftModemGetBuildDate(void);
+extern	char*	SM_DECL SoftModemGetFullManufacturerName(void);
+extern	char*	SM_DECL SoftModemGetShortManufacturerName(void);
+extern	int		SM_DECL SoftModemRevStringSize(void);
+extern	char*	SM_DECL SoftModemGetVendorIDString(void);
+extern	char*	SM_DECL SoftModemGetT1413VendorIDString(void);
+extern	char*	SM_DECL SoftModemGetSerialNumberString(void);
+extern	int		SM_DECL SoftModemSerNumStringSize(void);
+#define	SoftDslGetProductName			SoftModemGetProductName
+#define	SoftDslGetBuildDate				SoftModemGetBuildDate
+#define	SoftDslGetFullManufacturerName	SoftModemGetFullManufacturerName
+#define	SoftDslGetShortManufacturerName	SoftModemGetShortManufacturerName
+
+#else /* !ADSL_MODEM */
+
+extern void		SM_DECL SoftModemSetMemoryPtr	(void	*varsPtr);
+extern void*	SM_DECL SoftModemGetMemoryPtr	(void);
+extern void		SM_DECL SoftModemSetRefData		(void	*varsPtr);
+extern void*	SM_DECL SoftModemGetRefData		(void);
+extern int		SM_DECL SoftModemGetMemorySize	(void);
+extern void		SM_DECL SoftModemInit			(void);
+extern void		SM_DECL SoftModemReset			(void);
+extern void		SM_DECL SoftModemLineHandler	(int sampleCount, short *srcPtr, short *dstPtr);
+extern void		SM_DECL SoftModemTimer			(long timeQ24ms);
+extern Boolean	SM_DECL SoftModemCommandHandler	(modemCommandStruct *cmdPtr);
+extern int		SM_DECL SoftModemGetExternalMemorySize(void);
+extern void		SM_DECL SoftModemSetExternalMemoryPtr(void	*varsPtr);
+
+extern void		SM_DECL SoftModemSetPcmCoding	(pcmCodingType pcmCoding);
+extern void		SM_DECL SoftModemPcmLineHandler	(int sampleCount, uchar *srcPtr, uchar *dstPtr);
+
+/* SoftModem IO functions	*/
+extern int		SM_DECL SoftModemWrite(int nBytes, uchar* srcPtr);
+extern int		SM_DECL SoftModemRead(int nBytes, uchar* dstPtr);
+extern int		SM_DECL SoftModemWriteFrame(int nBytes, uchar* srcPtr);
+extern int		SM_DECL SoftModemReadFrame(int maxFrameSize, uchar* dstPtr);
+extern int		SM_DECL SoftModemCountWritePending(void);
+extern int		SM_DECL SoftModemCountReadPending(void);
+extern int		SM_DECL SoftModemWriteSpaceAvailable(void);
+extern void		SM_DECL SoftModemWriteFlush(void);
+extern void		SM_DECL SoftModemReadFlush(void);
+extern int		SM_DECL SoftModemGetWriteBufferSize(void);
+extern int		SM_DECL SoftModemGetReadBufferSize(void);
+
+#ifdef AUDIO
+extern int		SM_DECL SoftModemAudioHandler(int sampleCount, short *srcPtr, short *dstPtr);
+extern int		SM_DECL SoftModemAudioRxDataHandler(int nBytes, uchar* srcPtr);
+extern int		SM_DECL SoftModemAudioTxDataHandler(int nBytes, uchar* dstPtr);
+#endif
+
+
+#define	SoftModemSetGlobalPtr	SoftModemSetMemoryPtr
+#define	SoftModem				SoftModemLineHandler
+#ifndef LINKLAYER_V42BIS_LARGE_DICTIONARY
+#define	kSoftModemMaxMemorySize	(65536)
+#else
+#define	kSoftModemMaxMemorySize	(65536 + 8192)
+#endif
+
+/*
+ * Internal functions
+ */
+extern	long	SM_DECL SoftModemGetDCOffset(void);
+extern	void	SM_DECL SoftModemDisableDCOffsetTracking(void);
+extern	void	SM_DECL SoftModemEnableDCOffsetTracking(void);
+extern	long	SM_DECL SoftModemGetRcvPower(void);
+extern	ulong	SM_DECL SoftModemGetHybridDelay(void);
+extern  void	SM_DECL SoftModemStatusHandler	(modemStatusStruct *status);
+extern Boolean	SM_DECL SoftModemInternalCommandHandler	(modemCommandStruct *cmdPtr);
+extern  void	SM_DECL	SoftModemInternalStatusHandler	(modemStatusStruct *status);
+extern	void	SM_DECL SoftModemSetControllerOnlyMode(commandHandlerType externalDataPumpCommandHandlerPtr);
+extern	char*	SM_DECL SoftModemGetRevString(void);
+extern	char*	SM_DECL SoftModemGetProductName(void);
+extern	char*	SM_DECL	SoftModemGetBuildDate(void);
+extern	char*	SM_DECL SoftModemGetFullManufacturerName(void);
+extern	char*	SM_DECL SoftModemGetShortManufacturerName(void);
+extern	int		SM_DECL SoftModemRevStringSize(void);
+extern	char*	SM_DECL SoftModemGetVendorIDString(void);
+extern	char*	SM_DECL SoftModemGetSerialNumberString(void);
+extern  void	SM_DECL SoftModemAuxTxDataHandler(int nBytes, uchar *dataPtr);
+extern	void	SM_DECL SoftModemAuxRxDataHandler(int nBytes, uchar *dataPtr);
+extern  void	SM_DECL SoftModemTxDataHandler(int nBytes, uchar *dataPtr);
+extern	void	SM_DECL SoftModemRxDataHandler(int nBytes, uchar *dataPtr);
+extern	void	SM_DECL SoftModemATPrintf(uchar *format, void *arg1, void *arg2, void *arg3);
+
+#define	SoftModemSetInputSaturationLimit(limit)		(gSystemVars.inputSignalLimit = limit)	
+#define	SoftModemResetInputSaturationLimit()		(gSystemVars.inputSignalLimit = 0)
+
+#endif	/* !ADSL_MODEM */
+
+#endif	/* SoftModemPh */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModemTypes.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModemTypes.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModemTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/bcm96348/softdsl/SoftModemTypes.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,292 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * SoftModemTypes.h 
+ *
+ *
+ * Description:
+ *	This file contains some of the type declarations for SoftModem
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.9 $
+ *
+ * $Id: SoftModemTypes.h,v 1.9 2004/04/13 00:16:59 ilyas Exp $
+ *
+ * $Log: SoftModemTypes.h,v $
+ * Revision 1.9  2004/04/13 00:16:59  ilyas
+ * Merged the latest ADSL driver changes
+ *
+ * Revision 1.8  2004/01/24 01:35:33  ytan
+ * add multi-section lmem swap
+ *
+ * Revision 1.7  2001/09/21 19:19:01  ilyas
+ * Minor fixes for VxWorks build
+ *
+ * Revision 1.6  2001/08/16 02:16:39  khp
+ * - added definitions for SLOW_DATA and FAST_TEXT, defined to nothing
+ *   except when bcm47xx && USE_SLOW_DATA or USE_FAST_TEXT.  Any function
+ *   that needs to run fast should be marked with FAST_TEXT.  Any data that
+ *   is not referenced often should be marked with SLOW_DATA.
+ *
+ * Revision 1.5  2001/03/30 00:49:59  liang
+ * Changed warning output message.
+ *
+ * Revision 1.4  2000/06/21 22:24:40  yongbing
+ * Modify WARN micro to limit the number of same warnings printed
+ *
+ * Revision 1.3  1999/08/05 20:02:13  liang
+ * Merged with the softmodem top of the tree on 08/04/99.
+ *
+ * Revision 1.2  1999/01/27 22:14:29  liang
+ * Merge with SoftModem_3_1_02.
+ *
+ * Revision 1.19  1998/11/17 04:02:39  yura
+ * Fixed WARN and ASSERT redefinition warning for WinNT targets
+ *
+ * Revision 1.18  1998/08/26 19:20:43  scott
+ * Commented out EXCLUDE_CYGWIN32_TYPES define
+ *
+ * Revision 1.17  1998/08/13 19:03:06  scott
+ * Added BitField definition and INT_IS_LONG
+ *
+ * Revision 1.16  1998/08/08 03:39:55  scott
+ * The DEBUG_PTR_ENABLED macro can be used to enable only the DEBUG_PTR macros
+ *
+ * Revision 1.15  1998/07/28 22:21:31  mwg
+ * Fixed problems with NULL & nil being defined incorrectly
+ *
+ * Revision 1.14  1998/07/08 17:09:17  scott
+ * Define ASSERT and WARN only if not already defined
+ *
+ * Revision 1.13  1998/07/02 20:46:34  scott
+ * Added workaround for building certain builds with older SunOS
+ *
+ * Revision 1.12  1998/02/09 18:24:49  scott
+ * Defined "Private" as nothing for GreenHill (to prevent erroneous section
+ * allocations for data)
+ *
+ * Revision 1.11  1997/08/29 21:39:24  scott
+ * Added check for LONG_IS_INT define (for TI C6X support)
+ *
+ * Revision 1.10  1997/05/29 19:50:23  mwg
+ * Added code to avoid type redefintions under SunOS.
+ *
+ * Revision 1.9  1997/03/19 18:35:08  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.8  1997/02/11  00:05:53  mwg
+ * Minor adjustments for Pentium optimization.
+ *
+ * Revision 1.7  1997/01/11  01:30:47  mwg
+ * Added new macro WARN -- the same as ASSERT but without exit.
+ *
+ * Revision 1.6  1996/08/22  20:07:39  liang
+ * When ASSERT fires, only print out information, don't exit.
+ *
+ * Revision 1.5  1996/05/06  06:49:10  mwg
+ * Fixed linux problems.
+ *
+ * Revision 1.4  1996/05/02  08:40:16  mwg
+ * Merged in Chromatic bug fixes.
+ *
+ * Revision 1.3  1996/04/01  20:59:53  mwg
+ * Added macros to setup and use debug pointer.
+ *
+ * Revision 1.2  1996/02/27  01:50:04  mwg
+ * Added ASSERT() macro.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.2  1995/12/03  06:59:31  mwg
+ * Fixed all gcc varnings. We are now running under Linux on a PC!
+ *
+ *****************************************************************************/
+#ifndef	SoftModemTypesh
+#define	SoftModemTypesh
+
+#ifdef LONG_SHORTS
+#define	short	long
+#define	ushort	unsigned long
+#endif
+
+typedef signed char			schar;
+typedef unsigned char		uchar;
+
+#if 0 /* This is not currently required */
+#if defined(_CYGWIN32) && defined(DEBUG)
+#define EXCLUDE_CYGWIN32_TYPES
+#endif
+#endif
+
+#if !defined(_SYS_TYPES_H) || !defined(TARG_OS_RTEMS)
+#if defined(_CFE_)
+ typedef unsigned int		uint;
+ typedef unsigned long		ulong;
+ typedef unsigned short		ushort;
+#elif defined(TARG_OS_RTEMS)
+#if defined(HOST_ARCH_LINUX)
+ typedef unsigned int		uint;
+#endif
+ typedef unsigned long		ulong;
+#if defined(HOST_ARCH_LINUX)
+ typedef unsigned short		ushort;
+#endif
+#elif defined(EXCLUDE_CYGWIN32_TYPES) || (!defined _NO_TYPE_DEFS_ && !defined _SYS_TYPES_H && !defined __SYS_TYPES_H__ && !defined _SYS_BSD_TYPES_H && !defined _LINUX_TYPES_H) || defined(__sparc__)
+#ifndef EXCLUDE_CYGWIN32_TYPES
+ typedef unsigned int		uint;
+#endif
+#ifndef _LINUX_TYPES_H
+ typedef unsigned long		ulong;
+#endif
+#if !defined(ushort) && !defined(EXCLUDE_CYGWIN32_TYPES) && !defined(__INCvxTypesOldh)
+ typedef unsigned short		ushort;
+#endif
+#endif
+#else
+typedef unsigned long		ulong;
+#endif
+
+#if defined(GREENHILL) || defined(GNUTX39) /* GH allocates private data to incorrect section */
+#define Private
+#else
+#define Private             static
+#endif
+
+#define Public
+
+#ifdef NULL
+#undef NULL
+#endif
+#ifdef nil
+#undef nil
+#endif
+
+#define NULL 0
+#define nil 0
+
+#define false 0
+#define true 1
+typedef unsigned char Boolean;
+typedef unsigned int BitField; /* this must occur BEFORE long_is_int/int_is_long defs */
+
+#ifdef LONG_IS_INT
+#define long int
+#define ulong uint
+#endif
+
+#ifdef INT_IS_LONG
+#define int long
+#define uint ulong
+#endif
+
+#define POSTULATE(postulate)											\
+   do																	\
+	   {																\
+	   typedef struct													\
+		   {															\
+		   char	NegativeSizeIfPostulateFalse[((int)(postulate))*2 - 1];	\
+		   } PostulateCheckStruct;										\
+	   }																\
+   while (0)
+
+#if defined(DEBUG) && !defined(__KERNEL__)
+#ifndef WARN
+#define	kDSLNumberWarnTimes	10
+#define WARN(assertion) \
+	{ static int	warnSeveralTimes=0;	\
+	  if ((!(assertion))&(warnSeveralTimes<kDSLNumberWarnTimes)) \
+		{ \
+		fprintf(stderr, "Warning, failed: %s\n", #assertion); \
+		fprintf(stderr, "%s:%d\n", __FILE__, __LINE__); \
+		warnSeveralTimes++;	\
+		} \
+	}
+#endif
+#ifndef ASSERT
+#define ASSERT(assertion) \
+	{ if (!(assertion)) \
+		{ \
+		fprintf(stderr, "Assertion failed: %s\n", #assertion); \
+		fprintf(stderr, "%s:%d\n", __FILE__, __LINE__); \
+		exit(1); \
+		} \
+	}
+#endif
+#else
+
+#undef WARN
+#define	WARN(a)
+
+#undef ASSERT
+#define	ASSERT(a)
+
+#endif
+
+/*
+ * memory allocation macros
+ */
+
+#if defined(bcm47xx) && defined(USE_SLOW_DATA)
+#define SLOW_DATA __attribute__ ((section(".slow_data")))
+#else
+#define SLOW_DATA
+#endif
+
+#if defined(bcm47xx) && defined(USE_FAST_TEXT)
+#define FAST_TEXT __attribute__ ((section(".fast_text")))
+#else
+#define FAST_TEXT
+#endif
+
+#if defined(bcm47xx) && defined(SWAP_LMEM)
+#define SWAP_TEXT1_1 __attribute__ ((section(".swap_text1_1")))
+#define SWAP_TEXT1_2 __attribute__ ((section(".swap_text1_2")))
+#define SWAP_TEXT2_1 __attribute__ ((section(".swap_text2_1")))
+#define SWAP_TEXT2_2 __attribute__ ((section(".swap_text2_2")))
+#define SWAP_TEXT3_1 __attribute__ ((section(".swap_text3_1")))
+#define SWAP_TEXT3_2 __attribute__ ((section(".swap_text3_2")))
+#else
+#define SWAP_TEXT1_1 FAST_TEXT
+#define SWAP_TEXT1_2 FAST_TEXT
+#define SWAP_TEXT2_1 FAST_TEXT
+#define SWAP_TEXT2_2 FAST_TEXT
+#define SWAP_TEXT3_1 FAST_TEXT
+#define SWAP_TEXT3_2 FAST_TEXT
+#endif
+
+/*
+ * Debug stuff
+ */
+#if defined(DEBUG) || defined(DEBUG_PTR_ENABLED)
+#define	DECLARE_DEBUG_PTR(type)		static	type	*gv;
+#define	SETUP_DEBUG_PTR()			gv = &globalVar
+#else
+#define	DECLARE_DEBUG_PTR(type)
+#define	SETUP_DEBUG_PTR()
+#endif
+/*
+ * Obsolete stuff
+ */
+#ifdef DEBUG
+#define	HereIsTheGlobalVarPointerMacro		SETUP_DEBUG_PTR();
+#else
+#define	HereIsTheGlobalVarPointerMacro
+#endif
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_defs.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_defs.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_defs.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,133 @@
+/* TARGET=bcm6348-dmt-T1-dmtbis-adsl2plus-L2-SRA-firmware-Qproc-HW-RTL-pipeline-IncOneBit-Readsl2-doubleUS  */
+
+#define SOURCE_FILE_ 
+#define BCM6348_SRC 
+#define G994_T1P413_1024_FFT 
+#define ENABLE_DIG_USPWR_CUTBACK 
+#define ADSLCORE_ONLY 
+#define TEQ_DF 
+#define LOOP_TIMING_PLL 
+#define RCV_PHASE_TWEAK_ONLY 
+#define ADSL_MAX_POSSIBLE_RCV_RATE 
+#define HARDWARE_CHANNEL 
+#define ADSL_HARDWARE_AGC 
+#define HW_CHANNEL_ADC 
+#define HW_CHANNEL_DAC 
+#define HW_PGA 
+#define DIGITALEC_SINGLE_TAP_UPDATE 
+#define ANALOGEC_SINGLE_TAP_UPDATE 
+#define HWLOG 
+#define G992_TRELLIS_CODE_CLAMPING 
+#define G992DECODERTRELLISBOUNDARY 
+#define MEMORYLIMIT64K 
+#define bcm47xx 
+#define DSL_BIG_ENDIAN 
+#define MIPS_SRC 
+#define VP_INLINE -Winline 
+#define USE_ASM_API 
+#define RTL_SRC 
+#define RSENC_INLINE 
+#define BITENC_INLINE 
+#define USE_SLOW_DATA 
+#define USE_FAST_TEXT 
+#define PROFILE_INLINE 
+#define CHIP_SRC 
+#define G992_RESYNC_PILOT_PHASE_IN_SHOWTIME 
+#define G992_APPLY_SSVI 
+#define SHARE_TEQ_VARS 
+#define ANNEX_M 
+#define DOUBLE_UP_STREAM 
+#define G994P1_SUPPORT_A43C 
+#define USE_ASM_API 
+#define MIPS_ASM 
+#define MEMORYLIMIT64K 
+#define ADSL_FIRMWARE 
+#define G992DATA_XMT_COMPACT_WORD 
+#define ADSL_MAX_POSSIBLE_RCV_RATE 
+#define DSP_FRONTEND_ONLY 
+#define G992P3_ONE_BIT_CONSTELLATION 
+#define ADSL_MODEM 
+#define ATM 
+#define ADSL_ATUR 
+#define ADSL_SOFTWARE_TIME_ERROR_CALCULATION 
+#define DSL_REPORT_ALL_COUNTERS 
+#define ADSL_MONITOR_LCD 
+#define G994P1 
+#define G994P1_ATUR 
+#define G992 
+#define G992_ATUR 
+#define ADSL_FRAMER 
+#define G997_1 
+#define ATM_I432 
+#define TEQ_DF 
+#define G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G994P1_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G992_TRELLISCODE 
+#define ADSL_HARDWARE_ECHO_CANCELLOR 
+#define G992P1 
+#define G992P1_ATUR 
+#define G992P1_ANNEX_A 
+#define ADSL_HARDWARE_TIME_ERROR_TRACKING 
+#define G992P1_NEWFRAME 
+#define G992P1_NEWFRAME_ATUR 
+#define G992P1_ANNEX_A_USED_FOR_G992P2 
+#define T1P413 
+#define G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G992_CALC_DEBUG_SNR_BEFORE_TEQ 
+#define G992P3 
+#define RATE_SELECT_E14 
+#define G992P3_ATUR 
+#define G992P3AMENDMENT 
+#define GLOBESPAN_DM 
+#define G992P3_COMB_MSG_THREE_COPIES 
+#define G992P3_POWER_MANAGEMENT 
+#define G992P3_SRA 
+#define G992P5 
+#define G992P5_ATUR 
+#define ADSL_PIPELINE_CODE 
+#define ADSL_HARDWARE_TIME_ERROR_TRACKING 
+#define G994P1RCV_QPROC 
+#define G994P1XMT_QPROC 
+#define G992RCV_QPROC 
+#define G992XMT_QPROC 
+#define G992RCV_RS 
+#define VP_SIMULATOR 
+#define T1P413RCV_QPROC 
+#define T1P413XMT_QPROC 
+#define G992ENC_HW_DATAMODE 
+#define G992DATA_XMT_HW_RS 
+#define G992DATA_XMT_COMPACT_WORD 
+#define G992RCV_QPROC_FAST 
+#define G992_BIT_SWAP 
+#define ADSL_IDENTIFY_VENDOR_FIRMWARE 
+#define ADSL_ATUR_FORCE_BIGGER_UPSTREAM_MARGIN 
+#define G992_MORE_FRAME_MODE 
+#define XMT_RACT2_FOR_ADI_COMPATIBILITY 
+#define XMT_FFT_SIZE_2X 
+#define SYNCH_SYMBOL_DETECTION 
+#define ANSI_CACT12_PING_PONG 
+#define ADSL_SPECIAL_FIX_FOR_FRENCH_TELECOM 
+#define G994P1_CHECK_SECURITY 
+#define G994P1_NON_STD_INFO 
+#define I432_HEADER_COMPRESSION 
+#define TDC_IOP_FIX_ERICSSON_TI_4000C_350 
+#define TDC_IOP_FIX_SEIMENS_TI 
+#define FT_ADI_US_RATE_FIX 
+#define ANSI_CACT12_PING_PONG 
+#define G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define G994P1_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ 
+#define READSL2 
+#define G992_APPLY_SSVI 
+#define READSL2_FILTERS
+
+
+#define ADSL_PHY_XFACE_OFFSET 0x21F90
+
+
+#define ADSL_PHY_SDRAM_BIAS 0x1A0000
+
+
+#define ADSL_PHY_SDRAM_LINK_OFFSET 0x1A0000
+
+
+#define ADSL_PHY_SDRAM_PAGE_SIZE 0x200000
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_lmem.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_lmem.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_lmem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_lmem.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,6 @@
+/*
+**	Don't change!
+**	This file has been generated automatically by bin2c program
+*/
+
+extern const unsigned char adsl_lmem[51036];
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_sdram.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_sdram.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_sdram.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/adslcore6348/adsl_sdram.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,6 @@
+/*
+**	Don't change!
+**	This file has been generated automatically by bin2c program
+*/
+
+extern const unsigned char adsl_sdram[364348];
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslCoreDefs.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslCoreDefs.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslCoreDefs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslCoreDefs.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,245 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslCore.c -- Bcm ADSL core driver
+ *
+ * Description:
+ *	This file contains BCM ADSL core driver 
+ *
+ *
+ * Copyright (c) 2000-2001  Broadcom Corporation
+ * All Rights Reserved
+ * No portions of this material may be reproduced in any form without the
+ * written permission of:
+ *          Broadcom Corporation
+ *          16215 Alton Parkway
+ *          Irvine, California 92619
+ * All information contained in this document is Broadcom Corporation
+ * company private, proprietary, and trade secret.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.4 $
+ *
+ * $Id: AdslCoreDefs.h,v 1.4 2004/07/20 23:45:48 ilyas Exp $
+ *
+ * $Log: AdslCoreDefs.h,v $
+ * Revision 1.4  2004/07/20 23:45:48  ilyas
+ * Added driver version info, SoftDslPrintf support. Fixed G.997 related issues
+ *
+ * Revision 1.3  2004/06/10 00:20:33  ilyas
+ * Added L2/L3 and SRA
+ *
+ * Revision 1.2  2004/04/12 23:24:38  ilyas
+ * Added default G992P5 PHY definition
+ *
+ * Revision 1.1  2004/04/08 23:59:15  ilyas
+ * Initial CVS checkin
+ *
+ ****************************************************************************/
+
+#ifndef _ADSL_CORE_DEFS_H
+#define _ADSL_CORE_DEFS_H
+
+#if defined(__KERNEL__)
+#include <linux/config.h>
+#endif
+
+#if defined(CONFIG_BCM96348) || defined(BOARD_bcm96348) || defined(_BCM96348_) ||  defined(CONFIG_BCM96338) || defined(BOARD_bcm96338) || defined(_BCM96338_)
+#ifdef ADSL_ANNEXC
+#include "../adslcore6348C/adsl_defs.h"
+#elif defined(ADSL_ANNEXB)
+#include "../adslcore6348B/adsl_defs.h"
+#elif defined(ADSL_SADSL)
+#include "../adslcore6348SA/adsl_defs.h"
+#else
+#include "../adslcore6348/adsl_defs.h"
+#endif
+#endif
+
+#if defined(__KERNEL__) || defined(TARG_OS_RTEMS) || defined(_CFE_)
+#if defined(CONFIG_BCM96345) || defined(BOARD_bcm96345) || defined(_BCM96345_)
+#ifdef ADSL_ANNEXC
+#include "../adslcore6345C/adsl_defs.h"
+#elif defined(ADSL_ANNEXB)
+#include "../adslcore6345B/adsl_defs.h"
+#elif defined(ADSL_SADSL)
+#include "../adslcore6345SA/adsl_defs.h"
+#else
+#include "../adslcore6345/adsl_defs.h"
+#endif
+#endif /* of CONFIG_BCM96345 */
+#else
+#if defined(CONFIG_BCM96345)
+#ifdef ADSL_ANNEXC
+#include "../adslcoreC/adsl_defs.h"
+#elif defined(ADSL_ANNEXB)
+#include "../adslcoreB/adsl_defs.h"
+#elif defined(ADSL_SADSL)
+#include "../adslcoreSA/adsl_defs.h"
+#else
+#include "../adslcore/adsl_defs.h"
+#endif
+#endif /* of CONFIG_BCM96345 */
+#endif /* __KERNEL__ */
+
+#ifdef _WIN32_WCE
+#define	ASSERT(a)
+#endif
+
+#include "AdslXfaceData.h"
+
+/* adjust some definitions for the HOST */
+
+#undef	GLOBAL_PTR_BIAS
+#undef	ADSLCORE_ONLY
+#undef	USE_SLOW_DATA 
+#undef	USE_FAST_TEXT 
+#undef	VP_SIMULATOR 
+#undef	bcm47xx 
+#undef	ADSL_FRAMER
+#undef	ATM
+#undef	ATM_I432 
+#undef	DSL_OS
+
+#define HOST_ONLY
+#define G997_1_FRAMER
+#define ADSL_MIB
+
+#ifndef FLATTEN_ADDR_ADJUST
+#define FLATTEN_ADDR_ADJUST	0xFFF00000
+#endif
+
+/* definitions for combo PHY (AnnexA(ADSL2) and AnnexB) */
+ 
+#if !(defined(ADSL_SINGLE_PHY) || defined(G992_ANNEXC))
+
+#undef	G992P1_ANNEX_A
+#define	G992P1_ANNEX_A
+#undef	G992P3
+#define	G992P3
+#undef	G992P5
+#define	G992P5
+#define	G992P1_ANNEX_A
+#undef	READSL2
+#define	READSL2
+#undef	G992P1_ANNEX_A_USED_FOR_G992P2
+#define	G992P1_ANNEX_A_USED_FOR_G992P2
+#undef	T1P413
+#define	T1P413
+
+#undef	G992P1_ANNEX_B
+#define	G992P1_ANNEX_B
+
+#endif
+
+/* ADSL PHY definition */
+
+typedef struct {
+	unsigned long	sdramPageAddr;
+	unsigned long	sdramImageAddr;
+	unsigned long	sdramImageSize;
+	unsigned long	sdramPhyImageAddr;
+	unsigned short	fwType;
+	unsigned short	chipType;
+	unsigned short	mjVerNum;
+	unsigned short	mnVerNum;
+	char			*pVerStr;
+	unsigned long	features[4];
+} adslPhyInfo;
+extern adslPhyInfo	adslCorePhyDesc;
+
+/* chip list */ 
+
+#define	kAdslPhyChipMjMask			0xFF00
+#define	kAdslPhyChipMnMask			0x00FF
+#define	kAdslPhyChipUnknown			0
+#define	kAdslPhyChip6345			0x100
+#define	kAdslPhyChip6348			0x200
+#define	kAdslPhyChipRev0			0
+#define	kAdslPhyChipRev1			1
+#define	kAdslPhyChipRev2			2
+#define	kAdslPhyChipRev3			3
+#define	kAdslPhyChipRev4			4
+#define	kAdslPhyChipRev5			5
+
+#define	ADSL_PHY_SUPPORT(f)			AdslFeatureSupported(adslCorePhyDesc.features,f)
+#define	ADSL_PHY_SET_SUPPORT(p,f)	AdslFeatureSet((p)->features,f)
+
+/* ADSL Driver to/from PHY address and data conversion macros */
+
+#ifdef  ADSLDRV_LITTLE_ENDIAN
+#define	ADSL_ENDIAN_CONV_LONG(x)	( ((x) << 24) | (((x) << 8) & 0x00FF0000) | (((x) >> 8) & 0x0000FF00) | ((unsigned long)(x) >> 24) )
+#define	ADSL_ENDIAN_CONV_SHORT(x)	( ((x) << 8) | ((unsigned short)(x) >> 8) )
+#define ADSL_ENDIAN_CONV_2SHORTS(x)	( ((x) << 16) | ((unsigned long)(x) >> 16) )
+#else
+#define	ADSL_ENDIAN_CONV_LONG(x)	x
+#define	ADSL_ENDIAN_CONV_SHORT(x)	x
+#define ADSL_ENDIAN_CONV_2SHORTS(x)	x
+#endif
+
+#ifndef ADSL_PHY_XFACE_OFFSET
+#define ADSL_PHY_XFACE_OFFSET			0x00017F90
+#endif
+#define ADSL_LMEM_XFACE_DATA			(0xFFF00000 | ADSL_PHY_XFACE_OFFSET)
+
+#ifndef ADSL_PHY_SDRAM_START
+#define ADSL_PHY_SDRAM_START			0x10000000
+#endif
+#ifndef ADSL_PHY_SDRAM_BIAS
+#define ADSL_PHY_SDRAM_BIAS				0x00040000
+#endif
+#define	ADSL_PHY_SDRAM_START_4			(ADSL_PHY_SDRAM_START + ADSL_PHY_SDRAM_BIAS)
+
+#ifndef	ADSL_PHY_SDRAM_PAGE_SIZE
+#define ADSL_PHY_SDRAM_PAGE_SIZE		0x00080000
+#endif
+
+#ifdef ADSL_PHY_SDRAM_BIAS
+#define ADSL_SDRAM_IMAGE_SIZE			(ADSL_PHY_SDRAM_PAGE_SIZE - ADSL_PHY_SDRAM_BIAS)
+#else
+#define ADSL_SDRAM_IMAGE_SIZE			(256*1024)
+#endif
+
+
+#ifndef	ADSL_PHY_SDRAM_LINK_OFFSET
+#define ADSL_PHY_SDRAM_LINK_OFFSET		0x00040000
+#endif
+
+#define ADSL_SDRAM_TOTAL_SIZE			0x00800000
+#define ADSL_SDRAM_HOST_MIPS_DEFAULT	(0xA0000000 | (ADSL_SDRAM_TOTAL_SIZE - ADSL_PHY_SDRAM_PAGE_SIZE + ADSL_PHY_SDRAM_BIAS))
+
+#define ADSLXF							((AdslXfaceData *) ADSL_LMEM_XFACE_DATA)
+
+#define ADSL_MIPS_LMEM_ADDR(a)	(((ulong)(a) & 0x19000000) == 0x19000000)
+#define	SDRAM_ADDR_TO_HOST(a)	((void *) ((ulong)(a) - adslCorePhyDesc.sdramPhyImageAddr + \
+	(ADSLXF->sdramBaseAddr ? (unsigned long) ADSLXF->sdramBaseAddr : ADSL_SDRAM_HOST_MIPS_DEFAULT)))
+#define	SDRAM_ADDR_TO_ADSL(a)	((void *) (adslCorePhyDesc.sdramPhyImageAddr + ((ulong)(a) - \
+	(ADSLXF->sdramBaseAddr ? (unsigned long) ADSLXF->sdramBaseAddr : ADSL_SDRAM_HOST_MIPS_DEFAULT))))
+
+#define ADSL_ADDR_TO_HOST(addr)		ADSL_MIPS_LMEM_ADDR(addr) ? (void *) ((ulong) (addr) | FLATTEN_ADDR_ADJUST) : SDRAM_ADDR_TO_HOST(addr)
+
+
+#ifndef DEBUG
+#define DEBUG
+#endif
+
+#ifndef __SoftDslPrintf
+void __SoftDslPrintf(void *gDslVars, char *fmt, int argNum, ...);
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,94 @@
+/****************************************************************************
+ *
+ * AdslMib.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for AdslMib
+ *	global variable structure.
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.8 $
+ *
+ * $Id: AdslMib.gh,v 1.8 2004/06/04 18:56:01 ilyas Exp $
+ *
+ * $Log: AdslMib.gh,v $
+ * Revision 1.8  2004/06/04 18:56:01  ilyas
+ * Added counter for ADSL2 framing and performance
+ *
+ * Revision 1.7  2003/10/17 21:02:12  ilyas
+ * Added more data for ADSL2
+ *
+ * Revision 1.6  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.5  2003/07/18 19:07:15  ilyas
+ * Merged with ADSL driver
+ *
+ * Revision 1.4  2002/11/13 21:32:49  ilyas
+ * Added adjustK support for Centillium non-standard framing mode
+ *
+ * Revision 1.3  2002/10/31 20:27:13  ilyas
+ * Merged with the latest changes for VxWorks/Linux driver
+ *
+ * Revision 1.2  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibGlobals
+#define	AdslMibGlobals
+
+#include "AdslMib.h"
+
+typedef struct
+	{
+	/* MIB data */
+
+	adslMibInfo				adslMib;
+
+	/* ADSL state data */
+
+	adslMibNotifyHandlerType notifyHandlerPtr;
+	ulong					timeSec;
+	ulong					timeMs;
+	Boolean					currSecondErrored;
+	Boolean					currSecondLOS;
+	Boolean					currSecondSES;
+	Boolean					currSecondFEC;
+	ulong					rcvPower;
+	ulong					rcvRateBps;
+	ulong					xmtRateBps;
+	ulong					linkStatus;
+	G992CodingParams		rcvParams;
+	G992CodingParams		xmtParams;
+	ulong					shtCounters[kG992ShowtimeNumOfMonitorCounters];
+	ulong					scratchData;
+	long					showtimeMarginThld;
+
+	/* ADSL diag data */
+
+	short					snr[kAdslMibMaxToneNum];
+	short					showtimeMargin[kAdslMibMaxToneNum];
+	uchar					bitAlloc[kAdslMibMaxToneNum];
+	short					gain[kAdslMibMaxToneNum];
+	ComplexShort			chanCharLin[kAdslMibMaxToneNum];
+	short					chanCharLog[kAdslMibMaxToneNum];
+	short					quietLineNoise[kAdslMibMaxToneNum];
+
+	ushort					nTones;
+	uchar					nMsgCnt;
+	ulong					g992MsgType;
+	uchar					rsOption[1+4];
+	Boolean					rsOptionValid;
+	}
+	adslMibVarsStruct;
+
+#endif	/* AdslMibGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMib.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,114 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslMib.h 
+ *
+ * Description:
+ *	This file contains the exported functions and definitions for AdslMib
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.9 $
+ *
+ * $Id: AdslMib.h,v 1.9 2004/04/12 23:34:52 ilyas Exp $
+ *
+ * $Log: AdslMib.h,v $
+ * Revision 1.9  2004/04/12 23:34:52  ilyas
+ * Merged the latest ADSL driver chnages for ADSL2+
+ *
+ * Revision 1.8  2004/03/03 20:14:05  ilyas
+ * Merged changes for ADSL2+ from ADSL driver
+ *
+ * Revision 1.7  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.6  2003/07/18 19:07:15  ilyas
+ * Merged with ADSL driver
+ *
+ * Revision 1.5  2002/10/31 20:27:13  ilyas
+ * Merged with the latest changes for VxWorks/Linux driver
+ *
+ * Revision 1.4  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.3  2002/01/13 22:25:40  ilyas
+ * Added functions to get channels rate
+ *
+ * Revision 1.2  2002/01/03 06:03:36  ilyas
+ * Handle byte moves tha are not multiple of 2
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibHeader
+#define	AdslMibHeader
+
+#if defined(_CFE_)
+#include "lib_types.h"
+#include "lib_string.h"
+#endif
+
+#include "AdslMibDef.h"
+
+/* Interface functions */
+
+typedef	int	(SM_DECL *adslMibNotifyHandlerType)	(void *gDslVars, ulong event);
+
+extern Boolean  AdslMibInit(void *gDslVars);
+extern void		AdslMibTimer(void *gDslVars, long timeMs);
+extern void		AdslMibStatusSnooper (void *gDslVars, dslStatusStruct *status);
+extern void		AdslMibSetNotifyHandler(void *gDslVars, adslMibNotifyHandlerType notifyHandlerPtr);
+extern int		AdslMibGetModulationType(void *gDslVars);
+extern Boolean	AdslMibIsAdsl2Mod(void *gDslVars);
+extern int		AdslMibGetActiveChannel(void *gDslVars);
+extern int		AdslMibGetGetChannelRate(void *gDslVars, int dir, int channel);
+extern Boolean  AdslMibIsLinkActive(void *gDslVars);
+extern int		AdslMibPowerState(void *gDslVars);
+extern int		AdslMibTrainingState (void *gDslVars);
+extern void		AdslMibClearData(void *gDslVars);
+extern void		AdslMibClearBertResults(void *gDslVars);
+extern void		AdslMibBertStartEx(void *gDslVars, ulong bertSec);
+extern void		AdslMibBertStopEx(void *gDslVars);
+extern ulong	AdslMibBertContinueEx(void *gDslVars, ulong totalBits, ulong errBits);
+extern void		AdslMibSetLPR(void *gDslVars);
+extern void		AdslMibSetShowtimeMargin(void *gDslVars, long showtimeMargin);
+extern void		AdslMibResetConectionStatCounters(void *gDslVars);
+
+extern void		AdslMibByteMove (int size, void* srcPtr, void* dstPtr);
+extern void		AdslMibByteClear(int size, void* dstPtr);
+extern int		AdslMibStrCopy(char *srcPtr, char *dstPtr);
+
+/* AdslMibGetData dataId codes */
+
+#define	kAdslMibDataAll					0
+
+extern void		*AdslMibGetData (void *gDslVars, int dataId, void *pAdslMibData);
+
+extern int		AdslMibGetObjectValue (
+					void	*gDslVars, 
+					uchar	*objId, 
+					int		objIdLen,
+					uchar	*dataBuf,
+					ulong	*dataBufLen);
+
+#endif	/* AdslMibHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMibOid.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMibOid.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMibOid.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslMibOid.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,177 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslMibOid.h 
+ *
+ * Description:
+ *	SNMP object identifiers for ADSL MIB and other related MIBs
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: AdslMibOid.h,v 1.5 2004/06/04 18:56:01 ilyas Exp $
+ *
+ * $Log: AdslMibOid.h,v $
+ * Revision 1.5  2004/06/04 18:56:01  ilyas
+ * Added counter for ADSL2 framing and performance
+ *
+ * Revision 1.4  2003/10/17 21:02:12  ilyas
+ * Added more data for ADSL2
+ *
+ * Revision 1.3  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.2  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibOidHeader
+#define	AdslMibOidHeader
+
+#define kOidAdsl							94
+#define kOidAdslInterleave					124
+#define kOidAdslFast						125
+#define kOidAtm								37
+
+#define kOidAdslLine						1
+#define kOidAdslMibObjects					1
+
+#define kOidAdslLineTable					1
+#define kOidAdslLineEntry					1
+#define kOidAdslLineCoding					1
+#define kOidAdslLineType					2
+#define kOidAdslLineSpecific			    3
+#define kOidAdslLineConfProfile				4
+#define kOidAdslLineAlarmConfProfile		5
+
+#define kOidAdslAtucPhysTable				2
+#define kOidAdslAturPhysTable				3
+#define kOidAdslPhysEntry					1
+#define kOidAdslPhysInvSerialNumber     	1
+#define kOidAdslPhysInvVendorID             2
+#define kOidAdslPhysInvVersionNumber    	3
+#define kOidAdslPhysCurrSnrMgn          	4
+#define kOidAdslPhysCurrAtn             	5
+#define kOidAdslPhysCurrStatus          	6
+#define kOidAdslPhysCurrOutputPwr       	7
+#define kOidAdslPhysCurrAttainableRate  	8
+
+#define kOidAdslAtucChanTable				4
+#define kOidAdslAturChanTable				5
+#define kOidAdslChanEntry					1
+#define kOidAdslChanInterleaveDelay			1
+#define kOidAdslChanCurrTxRate				2
+#define kOidAdslChanPrevTxRate          	3
+#define kOidAdslChanCrcBlockLength      	4
+
+#define kOidAdslAtucPerfDataTable			6
+#define kOidAdslAturPerfDataTable			7
+#define kOidAdslPerfDataEntry				1
+#define kOidAdslPerfLofs                 	1
+#define kOidAdslPerfLoss                 	2
+#define kOidAdslPerfLprs                 	3
+#define kOidAdslPerfESs                  	4
+#define kOidAdslPerfValidIntervals          5
+#define kOidAdslPerfInvalidIntervals     	6
+#define kOidAdslPerfCurr15MinTimeElapsed 	7
+#define kOidAdslPerfCurr15MinLofs        	8
+#define kOidAdslPerfCurr15MinLoss        	9
+#define kOidAdslPerfCurr15MinLprs        	10
+#define kOidAdslPerfCurr15MinESs         	11
+#define kOidAdslPerfCurr1DayTimeElapsed     12
+#define kOidAdslPerfCurr1DayLofs         	13
+#define kOidAdslPerfCurr1DayLoss         	14
+#define kOidAdslPerfCurr1DayLprs         	15
+#define kOidAdslPerfCurr1DayESs          	16
+#define kOidAdslPerfPrev1DayMoniSecs     	17
+#define kOidAdslPerfPrev1DayLofs         	18
+#define kOidAdslPerfPrev1DayLoss            19
+#define kOidAdslPerfPrev1DayLprs         	20
+#define kOidAdslPerfPrev1DayESs          	21
+
+#define kOidAdslAtucPerfIntervalTable		8
+#define kOidAdslAturPerfIntervalTable		9
+#define kOidAdslPerfIntervalEntry			1
+#define kOidAdslIntervalNumber				1
+#define kOidAdslIntervalLofs				2
+#define kOidAdslIntervalLoss				3
+#define kOidAdslIntervalLprs				4
+#define kOidAdslIntervalESs					5
+#define kOidAdslIntervalValidData			6
+
+#define kOidAdslAtucChanPerfTable					10
+#define kOidAdslAturChanPerfTable					11
+#define kOidAdslChanPerfEntry						1
+#define kOidAdslChanReceivedBlks                 	1
+#define kOidAdslChanTransmittedBlks              	2
+#define kOidAdslChanCorrectedBlks                	3
+#define kOidAdslChanUncorrectBlks                	4
+#define kOidAdslChanPerfValidIntervals           	5
+#define kOidAdslChanPerfInvalidIntervals         	6
+#define kOidAdslChanPerfCurr15MinTimeElapsed     	7
+#define kOidAdslChanPerfCurr15MinReceivedBlks    	8
+#define kOidAdslChanPerfCurr15MinTransmittedBlks 	9
+#define kOidAdslChanPerfCurr15MinCorrectedBlks   	10
+#define kOidAdslChanPerfCurr15MinUncorrectBlks   	11
+#define kOidAdslChanPerfCurr1DayTimeElapsed      	12
+#define kOidAdslChanPerfCurr1DayReceivedBlks     	13
+#define kOidAdslChanPerfCurr1DayTransmittedBlks  	14
+#define kOidAdslChanPerfCurr1DayCorrectedBlks    	15
+#define kOidAdslChanPerfCurr1DayUncorrectBlks    	16
+#define kOidAdslChanPerfPrev1DayMoniSecs         	17
+#define kOidAdslChanPerfPrev1DayReceivedBlks     	18
+#define kOidAdslChanPerfPrev1DayTransmittedBlks  	19
+#define kOidAdslChanPerfPrev1DayCorrectedBlks    	20
+#define kOidAdslChanPerfPrev1DayUncorrectBlks    	21
+
+#define kOidAdslAtucChanIntervalTable				12
+#define kOidAdslAturChanIntervalTable				13
+#define kOidAdslChanIntervalEntry					1
+#define kOidAdslChanIntervalNumber					1
+#define kOidAdslChanIntervalReceivedBlks        	2
+#define kOidAdslChanIntervalTransmittedBlks     	3
+#define kOidAdslChanIntervalCorrectedBlks       	4
+#define kOidAdslChanIntervalUncorrectBlks       	5
+#define kOidAdslChanIntervalValidData           	6
+
+/* AdslExtra OIDs for kOidAdslPrivate, kOidAdslPrivExtraInfo (defined in AdslMibDef.h) */
+
+#define kOidAdslExtraConnectionInfo					1
+#define kOidAdslExtraConnectionStat					2
+#define kOidAdslExtraFramingMode					3
+#define kOidAdslExtraTrainingState					4
+#define kOidAdslExtraNonStdFramingAdjustK			5
+#define kOidAdslExtraAtmStat						6
+#define kOidAdslExtraDiagModeData					7
+#define kOidAdslExtraAdsl2Info						8
+#define kOidAdslExtraTxPerfCounterInfo				9
+
+#define kOidAtmMibObjects		1
+#define kOidAtmTcTable			4
+#define kOidAtmTcEntry			1
+#define kOidAtmOcdEvents		1
+#define kOidAtmAlarmState		2
+
+#endif	/* AdslMibOidHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslXfaceData.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslXfaceData.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslXfaceData.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/AdslXfaceData.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,129 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslXfaceData.h -- ADSL Core interface data structure
+ *
+ * Description:
+ *	To be included both in SoftDsl and BcmAdslCore driver
+ *
+ *
+ * Copyright (c) 2000-2001  Broadcom Corporation
+ * All Rights Reserved
+ * No portions of this material may be reproduced in any form without the
+ * written permission of:
+ *          Broadcom Corporation
+ *          16215 Alton Parkway
+ *          Irvine, California 92619
+ * All information contained in this document is Broadcom Corporation
+ * company private, proprietary, and trade secret.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.9 $
+ *
+ * $Id: AdslXfaceData.h,v 1.9 2004/02/03 02:57:22 ilyas Exp $
+ *
+ * $Log: AdslXfaceData.h,v $
+ * Revision 1.9  2004/02/03 02:57:22  ilyas
+ * Added PHY feature settings
+ *
+ * Revision 1.8  2003/07/18 04:50:21  ilyas
+ * Added shared buffer for clEoc messages to avoid copying thru command buffer
+ *
+ * Revision 1.7  2003/02/25 00:46:32  ilyas
+ * Added T1.413 EOC vendor ID
+ *
+ * Revision 1.6  2003/02/21 23:29:13  ilyas
+ * Added OEM vendor ID parameter for T1.413 mode
+ *
+ * Revision 1.5  2002/09/13 21:17:12  ilyas
+ * Added pointers to version and build string to OEM interface structure
+ *
+ * Revision 1.4  2002/09/07 04:16:29  ilyas
+ * Fixed HOST to ADSL MIPS SDRAM address translation for relocatable images
+ *
+ * Revision 1.3  2002/09/07 01:43:59  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.2  2002/01/22 19:03:10  khp
+ * -put sdramBaseAddr at end of Xface struct
+ *
+ * Revision 1.1  2002/01/15 06:25:08  ilyas
+ * Initial implementation of ADSL core firmware
+ *
+ ****************************************************************************/
+
+#ifndef	AdslXfaceDataHeader
+#define AdslXfaceDataHeader
+
+#include "CircBuf.h"
+
+typedef struct _AdslXfaceData {
+	stretchBufferStruct sbSta;
+	stretchBufferStruct sbCmd;
+	unsigned long		gfcTable[15];
+	void				*sdramBaseAddr;
+} AdslXfaceData;
+
+/* Shared SDRAM configuration data */
+
+#define	kAdslOemVendorIdMaxSize		8
+#define	kAdslOemVersionMaxSize		32
+#define	kAdslOemSerNumMaxSize		32
+#define	kAdslOemNonStdInfoMaxSize	64
+
+typedef struct _AdslOemSharedData {
+	unsigned long		g994VendorIdLen;
+	unsigned long		g994XmtNonStdInfoLen;
+	unsigned long		g994RcvNonStdInfoLen;
+	unsigned long		eocVendorIdLen;
+	unsigned long		eocVersionLen;
+	unsigned long		eocSerNumLen;
+	unsigned char		g994VendorId[kAdslOemVendorIdMaxSize];
+	unsigned char		eocVendorId[kAdslOemVendorIdMaxSize];
+	unsigned char		eocVersion[kAdslOemVersionMaxSize];
+	unsigned char		eocSerNum[kAdslOemSerNumMaxSize];
+	unsigned char		g994XmtNonStdInfo[kAdslOemNonStdInfoMaxSize];
+	unsigned char		g994RcvNonStdInfo[kAdslOemNonStdInfoMaxSize];
+	char				*gDslVerionStringPtr;
+	char				*gDslBuildDataStringPtr;
+	unsigned long		t1413VendorIdLen;
+	unsigned char		t1413VendorId[kAdslOemVendorIdMaxSize];
+	unsigned long		t1413EocVendorIdLen;
+	unsigned char		t1413EocVendorId[kAdslOemVendorIdMaxSize];
+	unsigned long		clEocBufLen;
+	unsigned char		*clEocBufPtr;
+} AdslOemSharedData;
+
+/* feature list */ 
+
+#define	kAdslPhyAnnexA				0
+#define	kAdslPhyAnnexB				1
+#define	kAdslPhyAnnexC				2
+#define	kAdslPhySADSL				3
+#define	kAdslPhyAdsl2				4
+#define	kAdslPhyAdslG992p3			4
+#define	kAdslPhyAdsl2p				5
+#define	kAdslPhyAdslG992p5			5
+#define	kAdslPhyAnnexI				6
+#define	kAdslPhyAdslReAdsl2			7
+#define	kAdslPhyG992p2Init			8
+#define	kAdslPhyT1P413				9
+
+#define	AdslFeatureSupported(fa,f)	((fa)[(f) >> 5] & (1 << ((f) & 0x1F)))
+#define	AdslFeatureSet(fa,f)		(fa)[(f) >> 5] |= (1 << ((f) & 0x1F))
+
+#endif /* AdslXfaceDataHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlankList.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlankList.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlankList.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlankList.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,87 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * BlankList.h 
+ *
+ * Description:
+ *	Definition and implementation (via macros and inline functions)
+ *  of blank list - list of unused items of any size (not less than 
+ *	sizeof(void *)
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ *****************************************************************************/
+
+#ifndef	BlankListHeader
+#define	BlankListHeader
+
+#define BlankListPeek(head)		((void *) (head))
+#define BlankListNext(p)		(*(void **) (p))
+
+#define BlankListAdd(pHead,p)	do {			\
+  BlankListNext(p)	   = BlankListNext(pHead);	\
+  BlankListNext(pHead) = (void *) (p);			\
+} while (0)
+
+#define BlankListAddList(pHead,pFirst,pLast) do {	\
+  if (NULL != (pLast)) {							\
+	BlankListNext(pLast) = BlankListNext(pHead);	\
+	BlankListNext(pHead) = (void *) (pFirst);		\
+  }													\
+} while (0)
+
+#define BlankListGet(pHead)							\
+  BlankListNext(pHead);								\
+  {													\
+	void	**__p;									\
+	__p = (void	**) BlankListNext(pHead);			\
+	if (NULL != __p)								\
+	  BlankListNext(pHead) = *__p;					\
+  }
+
+
+#define	BlankListForEach(pHead,f,ref)	do {		\
+  void	*p = BlankListNext(pHead);					\
+													\
+  while (NULL != p) {								\
+	if ( (f)((p), ref) ) break;						\
+	p = BlankListNext(p);							\
+  }													\
+} while (0)
+
+
+#include	"Que.h"
+
+#define BlankListAddQue(pHead,pqHdr)	do {							\
+  if (NULL != ((QueHeader *)(pqHdr))->tail) {							\
+	BlankListNext(((QueHeader *)(pqHdr))->tail) = BlankListNext(pHead);	\
+	BlankListNext(pHead) = ((QueHeader *)(pqHdr))->head;				\
+  }																		\
+} while (0)
+
+#include	"DList.h"
+
+#define BlankListAddDList(pHead,pDListHead)	do {						\
+  if (!DListEmpty(pDListHead)) {										\
+	BlankListNext(DListLast(pDListHead)) = BlankListNext(pHead);		\
+	BlankListNext(pHead) = DListFirst(pDListHead);						\
+  }																		\
+} while (0)
+
+#endif	/* BlankListHeader */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlockUtil.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlockUtil.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlockUtil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/BlockUtil.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,235 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/* BlockUtil.h
+ *
+ *	Description:
+ *		This file contains the interfaces for the fixed point block
+ *		processing utilities.
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.23 $
+ *
+ * $Id: BlockUtil.h,v 1.23 2004/04/13 00:31:10 ilyas Exp $
+ *
+ * $Log: BlockUtil.h,v $
+ * Revision 1.23  2004/04/13 00:31:10  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.22  2003/07/11 01:49:01  gsyu
+ * Added BlockShortClearByLong to speed up performance
+ *
+ * Revision 1.21  2003/07/10 22:35:23  gsyu
+ * Speed up BlockByteXXX performance
+ *
+ * Revision 1.20  2003/07/10 22:15:51  gsyu
+ * Added BlockByteMoveByWord to speed up performance
+ *
+ * Revision 1.19  2002/03/12 00:03:03  yongbing
+ * Modify cplxScaleCplxSymbols to accept a shift value instead of an array of shifts
+ *
+ * Revision 1.18  2001/03/14 00:50:25  georgep
+ * All targets use FEQ_PASS_FFTSHIFT, remove code for case where its not defined
+ *
+ * Revision 1.17  2000/11/30 03:54:09  khp
+ * -BlockRealScaleCplxSymbols instead of BlockScaleComplexSymbols
+ *
+ * Revision 1.16  2000/11/29 20:42:12  liang
+ * Add function for ADSL xmt gains with fixed shift.
+ *
+ * Revision 1.15  2000/10/02 19:24:08  georgep
+ * Modify FEQ for new fft, fft outputs a shift for each block
+ *
+ * Revision 1.14  2000/09/09 00:23:48  liang
+ * Add corresponding functions for the ComplexLong FEQ coef.
+ *
+ * Revision 1.13  2000/05/17 01:36:52  yongbing
+ * Add Pentium MMX assembly codes for more block related functions
+ *
+ * Revision 1.12  2000/04/19 19:22:22  yongbing
+ * Add BlockShortScaleby2 function used in G994p1
+ *
+ * Revision 1.11  2000/04/04 02:28:01  liang
+ * Merged with SoftDsl_0_2 from old tree.
+ *
+ * Revision 1.11  2000/03/14 23:29:01  yongbing
+ * Add Pentim MMX codes for BlockCplxSymbolUpdateCplxScale function
+ *
+ * Revision 1.10  2000/02/16 01:53:00  yongbing
+ * Add Pentium MMX module for FEQ
+ *
+ * Revision 1.9  1999/11/02 02:49:55  liang
+ * Add BlockComplexPower function.
+ *
+ * Revision 1.8  1999/08/05 19:42:34  liang
+ * Merged with the softmodem top of the tree on 08/04/99 for assembly files.
+ *
+ * Revision 1.7  1999/06/16 00:54:39  liang
+ * BlockRealScaleComplexSymbols takes a scale shift buffer now.
+ *
+ * Revision 1.6  1999/05/22 02:18:29  liang
+ * Add one more parameter to BlockCplxSymbolUpdateCplxScale function.
+ *
+ * Revision 1.5  1999/05/14 22:49:39  liang
+ * Added two more functions.
+ *
+ * Revision 1.4  1999/03/26 03:29:57  liang
+ * Add function BlockComplexMultLongAcc.
+ *
+ * Revision 1.3  1999/02/22 22:40:59  liang
+ * BlockByteSum takes uchar inputs instead of schar.
+ *
+ * Revision 1.2  1999/02/10 01:56:44  liang
+ * Added BlockByteSum, BlockRealScaleComplexSymbols and BlockCplxScaleComplexSymbols.
+ *
+ * Revision 1.1  1998/10/28 01:35:38  liang
+ * *** empty log message ***
+ *
+ * Revision 1.12  1998/07/08 17:09:25  scott
+ * Removed unnecessary undefs
+ *
+ * Revision 1.11  1998/04/02 06:19:44  mwg
+ * Added two new utilities.
+ *
+ * Revision 1.10  1998/03/26 23:20:55  liang
+ * Added function BlockShortMultiply.
+ *
+ * Revision 1.9  1998/02/16  18:41:00  scott
+ * Added MMX autodetect support
+ *
+ * Revision 1.8  1997/12/13 06:11:35  mwg
+ * Added new functions:
+ * BlockLongSubtract()
+ * BlockLongAdd()
+ * BlockLong2ShortSubtract()
+ * BlockShort2LongMove()
+ * BlockShortInterpolate()
+ * BlockLongCorrelate()
+ * BlockMapShort2Short()
+ *
+ * Revision 1.7  1997/03/19 18:35:10  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.6  1997/02/11  00:08:18  mwg
+ * Added BlockByteMove function
+ *
+ * Revision 1.5  1997/02/04  08:40:08  mwg
+ * Changed interface forBlockReal2ComplexMacc()
+ *
+ * Revision 1.4  1997/01/23  02:04:28  mwg
+ * Added return value to BlockShortMove
+ *
+ * Revision 1.3  1996/12/19  22:34:55  mwg
+ * Added new function BlockFullPower().
+ *
+ * Revision 1.2  1996/02/21  03:59:15  mwg
+ * Added new function BlockReal2ComplexMacc
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.5  1995/04/04  06:09:32  mwg
+ * Changed the SoftModem status reporting: now the status is a structure/union
+ * where different fields used for different status code. This will enable
+ * efficient status snooping for high level protocols on top of the softmodem.
+ *
+ */
+
+#ifndef	BlockUtilPh
+#define	BlockUtilPh
+
+extern	void	BlockLongAdd				(int, long*, long*, long*);
+extern	void	BlockLong2ShortSubtract		(int, long*, long*, short*);
+extern	void	BlockShort2LongMove			(int, short*, long*);
+extern	void	BlockShortMultiply			(int, int, short*, short*, short*);
+extern	void	BlockByteMoveUnaligned		(int size, uchar *srcPtr, uchar *dstPtr);
+extern	void	BlockShortOffset			(int, short, short*, short*);
+extern	long	BlockShortInterpolateWithIncrement (int size, long scaleFactor, long increment, int shift, short* src1Ptr, short* src2Ptr, short* dstPtr);
+extern	void	BlockReal2ComplexMult		(int, short*, ComplexShort*, ComplexShort*);
+extern	void	BlockComplexConjigateMult	(int, ComplexShort*, ComplexShort*, ComplexShort*);
+
+extern	long	BlockSum					(int, short*);
+extern	long	BlockByteSum				(int, uchar*);
+extern	void	BlockComplexSum				(int, ComplexShort*, ComplexLong*);
+extern	void	BlockComplexPower			(int, int, ComplexShort*, long*);
+extern	long	BlockFullPower				(int, short*);
+extern	long	BlockLongCorrelate			(int, long*, long*);
+
+extern	int		BlockSymbol2Byte			(int, int, ushort*, uchar*);
+extern	int		BlockByte2Symbol			(int, int, uchar*, ushort*);
+
+extern	void	BlockMapShort2Complex		(int, ushort*, ComplexByte*, ComplexShort*);
+extern	void	BlockMapShort2Short			(int size, ushort *srcPtr, short *mapPtr, short *dstPtr);
+extern	void	BlockMapByte2Byte			(int size, uchar *srcPtr, uchar *mapPtr, uchar *dstPtr);
+extern	void	BlockMapByte2Short			(int size, uchar *srcPtr, short *mapPtr, short *dstPtr);
+extern	void	BlockShortMult				(int size, int shift, short* src1Ptr, short* src2Ptr, short* dstPtr);
+
+extern	int		SM_DECL Idle(void);
+
+extern	void	BlockGenerateAngles(int size, ComplexShort *anglePtr, ComplexShort *incPtr, ComplexShort *dstPtr);
+extern	void	BlockExtractRealPart(int size, ComplexShort *srcPtr, short *dstPtr);
+extern	void	BlockShortScaleByShift (int size, int shift, short* srcPtr, short* dstPtr);
+
+#ifndef PENTIUM_REDEFS /* only if these have not been redefined to function pointers */
+extern	long	BlockPower					(int, short*);
+extern	void	BlockReal2ComplexMacc		(int, int, short*, ComplexShort*, ComplexLong*);
+extern	void	BlockComplexMult			(int, ComplexShort*, ComplexShort*, ComplexShort*);
+extern	void	BlockShortScale				(int, short, int, short*, short*);
+extern	int		SM_DECL BlockShortMove				(int, short*, short*);
+extern	long	BlockCorrelate				(int, short*, short*);
+
+extern	void	BlockRealScaleComplexSymbols(int, int, uchar*, short*, ComplexShort*, ComplexShort*);
+/* FIXME -- the following 3 functions can be removed */
+extern	void	BlockCplxScaleComplexSymbols(int, int, int, ComplexShort*, ComplexShort*, ComplexShort*);
+extern	void	BlockCplxSymbolUpdateCplxScale(int, int, int, uchar*, ComplexShort*,
+					ComplexShort*, ComplexShort*, ComplexShort*);
+extern	void	BlockComplexShortFill		(int, short, short, ComplexShort*);
+
+
+extern	void	BlockRealScaleCplxSymbols(int, int, int, short*, ComplexShort*, ComplexShort*);
+extern	void	BlockCplxLongConjigateMultCplxShort(int, ComplexLong*, ComplexShort*, ComplexLong*);
+
+extern	void	BlockCplxLongScaleCplxSymbols(int, int, int, ComplexLong*, ComplexShort*, short*, ComplexShort*);
+extern	void	BlockCplxSymbolUpdateCplxLongScale(int, int, int, int,
+					ComplexShort*, short *, ComplexLong*, ComplexShort*);
+
+extern	void	BlockComplexLongFill		(int, long, long, ComplexLong*);
+
+extern	void	BlockShortSubtract			(int, short*, short*, short*);
+extern	void	BlockLongSubtract			(int, long*, long*, long*);
+extern	void	BlockShortAdd				(int, short*, short*, short*);
+extern	void	BlockByteMove				(int, uchar*, uchar*);
+extern	void	BlockByteMoveByLong			(int, uchar*, uchar*);
+extern	void	SM_DECL BlockByteFill		(int, uchar, uchar*);
+extern	void	BlockByteFillByLong 		(int, uchar, uchar*);
+extern	void	BlockByteClear				(int, uchar*);
+extern	void	BlockByteClearByLong		(int, uchar*);
+extern	void	BlockShortFill				(int, short, short*);
+extern	void	BlockShortClear				(int, short*);
+extern	void	BlockShortClearByLong		(int, short*);
+extern	void	BlockLongFill				(int, long, long*);
+extern	void	BlockLongClear				(int, long*);
+extern	void	BlockComplexShortClear		(int, ComplexShort*);
+extern	void	BlockShortInvert			(int, short*, short*);
+extern	void	BlockShortScaleDown			(int, short*);
+extern	void	BlockLongMove				(int, long*, long*);
+extern	void	BlockShortInterpolate		(int, short, int, short*, short*, short*);
+extern	void	BlockComplexMultLongAcc     (int, int, ComplexShort*, ComplexShort*, ComplexLong*);
+
+#endif
+
+#endif	/* BlockUtilPh */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/CircBuf.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/CircBuf.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/CircBuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/CircBuf.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,217 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * CircBuf -- Generic Circular Buffer
+ *
+ * Description:
+ *	Implementation of generic circular buffer algorithms
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.14 $
+ *
+ * $Id: CircBuf.h,v 1.14 2004/06/24 03:10:37 ilyas Exp $
+ *
+ * $Log: CircBuf.h,v $
+ * Revision 1.14  2004/06/24 03:10:37  ilyas
+ * Added extra macro to be able to use un-cached variable (for status write)
+ *
+ * Revision 1.13  2004/02/09 23:47:02  ilyas
+ * Fixed last change
+ *
+ * Revision 1.12  2004/02/06 22:52:58  ilyas
+ * Improved stretch buffer write
+ *
+ * Revision 1.11  2002/12/30 23:27:55  ilyas
+ * Added macro for HostDma optimizations
+ *
+ * Revision 1.10  2002/10/26 02:15:02  ilyas
+ * Optimized and added new macros for HostDma
+ *
+ * Revision 1.9  2002/01/22 23:59:29  ilyas
+ * Added paraenthesis around macro argument
+ *
+ * Revision 1.8  2002/01/15 22:28:38  ilyas
+ * Extended macro to support readPtr from uncached address
+ *
+ * Revision 1.7  2001/09/21 19:47:05  ilyas
+ * Fixed compiler warnings for VxWorks build
+ *
+ * Revision 1.6  2001/06/07 18:47:56  ilyas
+ * Added more macros for circular buffer arithmetics
+ *
+ * Revision 1.5  2001/04/18 03:58:34  ilyas
+ * Added LOG file write granularity
+ *
+ * Revision 1.4  2001/01/19 04:34:12  ilyas
+ * Added more macros to circular buffer implementation
+ *
+ * Revision 1.3  2001/01/06 04:01:41  ilyas
+ * Changed the way we write status messages
+ *
+ * Revision 1.2  2001/01/04 05:52:21  ilyas
+ * Added implementation of stretchable circular buffer used in LOG and Status
+ * handlers
+ *
+ * Revision 1.1  2000/05/03 03:45:55  ilyas
+ * Original implementation
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	CircBufHeader_H_
+#define	CircBufHeader_H_
+
+
+typedef struct {
+	char	*pStart;
+	char	*pEnd;
+	char	*pRead;
+	char	*pWrite;
+} circBufferStruct;
+
+/* Initialize circular buffer */
+
+#define	CircBufferInit(pCB,buf,size)	do {			\
+	(pCB)->pStart = (char *) (buf);						\
+	(pCB)->pRead = (pCB)->pWrite = (pCB)->pStart;		\
+	(pCB)->pEnd = (pCB)->pStart + size;					\
+} while (0)
+
+#define	CircBufferGetSize(pCB)			((pCB)->pEnd - (pCB)->pStart)
+#define	CircBufferGetStartPtr(pCB)		((void *) (pCB)->pStart)
+#define	CircBufferGetEndPtr(pCB)		((void *) (pCB)->pEnd)
+
+#define	CircBufferReset(pCB)			(pCB)->pRead = (pCB)->pWrite = (pCB)->pStart
+
+
+#define	CircBufferGetReadPtr(pCB)		((void *) (pCB)->pRead)
+#define	CircBufferGetWritePtr(pCB)		((void *) (pCB)->pWrite)
+
+
+#ifndef bcm47xx
+#define	CircBufferDistance(pCB,p1,p2,d)	((char*)(p2) - (char*)(p1) - d >= 0 ?			\
+											(char*)(p2) - (char*)(p1) - d :			\
+											((char*)(p2)- (char*)(p1) - d + ((pCB)->pEnd - (pCB)->pStart)))
+
+#define	CircBufferAddContig(pCB,p,n)	((char*)(p) + (n) == (pCB)->pEnd ? (pCB)->pStart : (char*)(p) + (n))
+#else
+static __inline int CircBufferDistance(circBufferStruct *pCB, char *p1, char *p2, int d)
+{
+	int tmp = p2 - p1 - d;
+
+	return (tmp >= 0 ? tmp : tmp + (pCB->pEnd - pCB->pStart));
+}
+
+static __inline char * CircBufferAddContig(circBufferStruct *pCB, char *p, int n)
+{
+	p += n;
+	return (p == pCB->pEnd ? pCB->pStart : p);
+}
+#endif
+
+#define	CircBufferAdd(pCB,p,n)			((char*)(p) + (n) >= (pCB)->pEnd ?						\
+											(pCB)->pStart + ((char*)(p) + (n) - (pCB)->pEnd) :	\
+											(char*)(p) + (n))
+
+#define	CircBufferReadUpdate(pCB,n)		(pCB)->pRead = CircBufferAdd(pCB,(pCB)->pRead,n)
+#define	CircBufferWriteUpdate(pCB,n)	(pCB)->pWrite= CircBufferAdd(pCB,(pCB)->pWrite,n)
+
+#define	CircBufferReadUpdateContig(pCB,n)	(pCB)->pRead = CircBufferAddContig(pCB,(pCB)->pRead,n)
+#define	CircBufferWriteUpdateContig(pCB,n)	(pCB)->pWrite= CircBufferAddContig(pCB,(pCB)->pWrite,n)
+
+#define	CircBufferGetReadAvail(pCB)		CircBufferDistance(pCB,(pCB)->pRead,(pCB)->pWrite,0)
+#define	CircBufferIsReadEmpty(pCB)		((pCB)->pRead == (pCB)->pWrite)
+#define	CircBufferGetWriteAvail(pCB)	CircBufferDistance(pCB,(pCB)->pWrite,(pCB)->pRead,1)
+#define	CircBufferGetWriteAvailN(pCB,n)	CircBufferDistance(pCB,(pCB)->pWrite,(pCB)->pRead,n)
+
+#define	CircBufferGetReadContig(pCB)	((unsigned long)(pCB)->pWrite >= (unsigned long) (pCB)->pRead ?	\
+											(pCB)->pWrite - (pCB)->pRead :		\
+											(pCB)->pEnd	  - (pCB)->pRead)
+
+#define	CircBufferGetWriteContig(pCB)	((pCB)->pEnd - (pCB)->pWrite > CircBufferGetWriteAvail(pCB) ?	\
+											CircBufferGetWriteAvail(pCB) :		\
+											(pCB)->pEnd - (pCB)->pWrite)
+
+/*
+**
+**		structure and macros for "strectch" buffer
+**
+*/
+
+typedef struct {
+	char	*pStart;
+	char	*pEnd;
+	char	*pExtraEnd;
+	char	*pStretchEnd;
+	char	*pRead;
+	char	*pWrite;
+} stretchBufferStruct;
+
+#define	StretchBufferInit(pSB,buf,size,extra)	do {	\
+	(pSB)->pStart = (char *) (buf);						\
+	(pSB)->pRead = (pSB)->pWrite = (pSB)->pStart;		\
+	(pSB)->pEnd = (pSB)->pStart + (size);				\
+	(pSB)->pStretchEnd = (pSB)->pEnd;					\
+	(pSB)->pExtraEnd = (pSB)->pEnd+(extra);				\
+} while (0)
+
+#define	StretchBufferGetSize(pSB)		((pSB)->pEnd - (pSB)->pStart)
+#define	StretchBufferGetStartPtr(pSB)	((void *) (pSB)->pStart)
+#define	StretchBufferGetReadPtr(pSB)	((void *) (pSB)->pRead)
+#define	StretchBufferGetWritePtr(pSB)	((void *) (pSB)->pWrite)
+#define	StretchBufferReset(pSB)			((pSB)->pRead = (pSB)->pWrite = (pSB)->pStart)
+
+#define	StretchBufferGetReadToEnd(pSB)	((pSB)->pStretchEnd - (pSB)->pRead)
+
+#define	StretchBufferGetReadAvail(pSB)		((pSB)->pWrite - (pSB)->pRead >= 0 ?	\
+											(pSB)->pWrite - (pSB)->pRead   :		\
+											(pSB)->pStretchEnd - (pSB)->pRead)
+#define	_StretchBufferGetWriteAvail(pSB,rd) ((rd) - (pSB)->pWrite > 0 ?				\
+											(rd) - (pSB)->pWrite - 1 :				\
+											((pSB)->pExtraEnd - (pSB)->pWrite))
+#define	StretchBufferGetWriteAvail(pSB)		_StretchBufferGetWriteAvail(pSB, (pSB)->pRead)
+
+#define	StretchBufferReadUpdate(pSB,n)		do {								\
+	char	*p;																	\
+																				\
+	p = (pSB)->pRead + (n);														\
+	(pSB)->pRead = (p >= (pSB)->pStretchEnd ? (pSB)->pStart : p);				\
+} while (0)
+
+#define	_StretchBufferWriteUpdate(pSB,rd,n)	do {								\
+	char	*p;																	\
+																				\
+	p = (pSB)->pWrite + (n);													\
+	if (p >= (pSB)->pEnd) {														\
+	  if ((rd) != (pSB)->pStart) {												\
+		(pSB)->pStretchEnd = p;													\
+		(pSB)->pWrite = (pSB)->pStart;											\
+	  }																			\
+	}																			\
+	else																		\
+		(pSB)->pWrite = p;														\
+} while (0)
+
+#define	StretchBufferWriteUpdate(pSB,n)		_StretchBufferWriteUpdate(pSB,(pSB)->pRead,n)	
+
+#endif	/* CircBufHeader_H_ */
+
+
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DList.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DList.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DList.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DList.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,131 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * DList.h
+ *
+ * Description:
+ *	Definition and implementation (via macros and inline functions)
+ *  of double-linked list
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ *****************************************************************************/
+
+#ifndef	DListHeader_H_
+#define	DListHeader_H_
+
+typedef struct _DListHeader
+	{
+	struct _DListHeader	*next;		/* next item in the list */
+	struct _DListHeader	*prev;		/* prev item in the list */
+	} DListHeader;
+
+typedef struct _DListUpHeader
+	{
+	struct _DListUpHeader	*next;	/* next item in the list */
+	struct _DListUpHeader	*prev;	/* prev item in the list */
+	struct _DListUpHeader	*head;	/* head of the list */
+	} DListUpHeader;
+
+/* Double linked list DList management macros */
+
+#define	DListInit(pDListHead)	do {					\
+	((DListHeader *)(pDListHead))->next = pDListHead;	\
+	((DListHeader *)(pDListHead))->prev = pDListHead;	\
+} while (0)
+
+#define	DListNext(pDListEntry)		(((DListHeader *)(pDListEntry))->next)
+#define	DListPrev(pDListEntry)		(((DListHeader *)(pDListEntry))->prev)
+
+#define	DListEntryLinked(pDListEntry)	(NULL != DListNext(pDListEntry))
+#define	DListUnlinkEntry(pDListEntry)	(DListNext(pDListEntry) = DListPrev(pDListEntry) = NULL)
+
+#define	DListFirst(pDListHead)		DListNext(pDListHead)
+#define	DListLast(pDListHead)		DListPrev(pDListHead)
+#define	DListValid(pDListHead,pEntry)	((void *)(pDListHead) != (pEntry))
+#define	DListEmpty(pDListHead)		((void *)pDListHead == ((DListHeader *)pDListHead)->next)
+
+#define	DListInsertAfter(pDListEntry,pEntry)	 do {						\
+	((DListHeader *)(pEntry))->next = ((DListHeader *)(pDListEntry))->next;	\
+	((DListHeader *)(pEntry))->prev = (DListHeader *)(pDListEntry);			\
+	((DListHeader *)(pDListEntry))->next->prev = (DListHeader *) (pEntry);	\
+	((DListHeader *)(pDListEntry))->next = (DListHeader *) (pEntry);		\
+} while (0)
+
+#define	DListInsertBefore(pDListEntry,pEntry) do {							\
+	((DListHeader *)(pEntry))->next = (DListHeader *)(pDListEntry);			\
+	((DListHeader *)(pEntry))->prev = ((DListHeader *)(pDListEntry))->prev;	\
+	((DListHeader *)(pDListEntry))->prev->next = (DListHeader *) (pEntry);	\
+	((DListHeader *)(pDListEntry))->prev = (DListHeader *) (pEntry);		\
+} while (0)
+
+#define	DListInsertTail(pDListHead,pEntry)	DListInsertBefore(pDListHead,pEntry)
+#define	DListInsertHead(pDListHead,pEntry)	DListInsertAfter(pDListHead,pEntry)
+
+#define	DListRemove(pDListEntry)	do {				\
+	((DListHeader *)(pDListEntry))->prev->next = ((DListHeader *)(pDListEntry))->next;	\
+	((DListHeader *)(pDListEntry))->next->prev = ((DListHeader *)(pDListEntry))->prev;	\
+} while (0)
+
+
+#define	DListForEach(pDListHead,f,ref)		do {			\
+	DListHeader	*p = ((DListHeader *)(pDListHead))->next;	\
+															\
+	while (DListValid(pDListHead,p)) {						\
+	  DListHeader *p0 = p;									\
+	  p = DListNext(p);										\
+	  if ( (f)((void *)p0, ref) ) break;					\
+	}														\
+} while (0)
+
+
+/* Double linked list with up link DListUp management macros */
+
+#define	DListUpInit(pDListHead)	do {										\
+	((DListUpHeader *)(pDListHead))->next = (DListUpHeader *) (pDListHead);	\
+	((DListUpHeader *)(pDListHead))->prev = (DListUpHeader *) (pDListHead);	\
+	((DListUpHeader *)(pDListHead))->head = (DListUpHeader *) (pDListHead);	\
+} while (0)
+
+#define	DListUpNext(pDListEntry)	((DListUpHeader *) DListNext(pDListEntry))
+#define	DListUpPrev(pDListEntry)	((DListUpHeader *) DListPrev(pDListEntry))
+#define	DListUpHead(pDListEntry)	(((DListUpHeader *)(pDListEntry))->head)
+
+#define	DListUpFirst(pDListHead)	DListUpNext(pDListHead)
+#define	DListUpLast(pDListHead)		DListUpPrev(pDListHead)		
+#define	DListUpValid(pEntry)		(((DListUpHeader *)(pEntry))->head != (void *) pEntry)
+#define	DListUpEmpty(pDListHead)	DListEmpty(pDListHead)		
+
+#define	DListUpInsertAfter(pDListEntry,pEntry)	 do {							\
+	DListInsertAfter(pDListEntry,pEntry);										\
+	((DListUpHeader *)(pEntry))->head = ((DListUpHeader *)(pDListEntry))->head;	\
+} while (0)
+
+#define	DListUpInsertBefore(pDListEntry,pEntry)  do {							\
+	DListInsertBefore(pDListEntry,pEntry);										\
+	((DListUpHeader *)(pEntry))->head = ((DListUpHeader *)(pDListEntry))->head;	\
+} while (0)
+
+#define	DListUpInsertTail(pDListHead,pEntry)	DListUpInsertBefore(pDListHead,pEntry)
+#define	DListUpInsertHead(pDListHead,pEntry)	DListUpInsertAfter(pDListHead,pEntry)
+
+#define	DListUpRemove(pDListEntry)		DListRemove(pDListEntry)
+#define	DListUpForEach(pDListHead,f,ref) DListForEach((DListHeader *)(pDListHead),f,ref)
+
+#endif	/* DListHeader_H_ */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DslFramer.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DslFramer.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DslFramer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/DslFramer.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,159 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * DslFramer.h 
+ *
+ * Description:
+ *	This file contains common DSL framer definitions
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.3 $
+ *
+ * $Id: DslFramer.h,v 1.3 2004/07/21 01:39:41 ilyas Exp $
+ *
+ * $Log: DslFramer.h,v $
+ * Revision 1.3  2004/07/21 01:39:41  ilyas
+ * Reset entire G.997 state on retrain. Timeout in G.997 if no ACK
+ *
+ * Revision 1.2  2004/04/12 23:41:10  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	DslFramerHeader
+#define	DslFramerHeader
+
+#include "DList.h"
+
+#define	kDslFramerInitialized			0x80000000
+
+/* status codes */
+
+#define	kDslFramerRxFrame				1
+#define	kDslFramerRxFrameErr			2
+#define kDslFramerTxFrame				3
+#define	kDslFramerTxFrameErr			4
+
+#define	kDslFramerRxFrameErrFlushed		1
+#define	kDslFramerRxFrameErrAbort		2
+#define	kDslFramerRxFrameErrPhy			3
+
+#define	kDslFramerTxFrameErrFlushed		1
+
+
+typedef	struct _dslFramerBufDesc {
+	long		pkId;
+	long		bufFlags;
+	void		*bufPtr;
+	long		bufLen;
+} dslFramerBufDesc;
+
+/* data bufDesc flags */
+
+#define kDslFramerStartNewFrame			1
+#define kDslFramerEndOfFrame			2
+#define kDslFramerAbortFrame			4
+
+#define kDslFramerExtraByteShift		3
+#define kDslFramerExtraByteMask			(0x7 << kDslFramerExtraByteShift)
+
+typedef struct _dslFramerControl {
+	bitMap					setup;
+	dslFrameHandlerType		rxIndicateHandlerPtr;
+	dslFrameHandlerType		txCompleteHandlerPtr;
+	dslStatusHandlerType	statusHandlerPtr;
+	ulong					statusCode;
+	ulong					statusOffset;
+
+	int						nRxBuffers;
+	int						nRxBufSize;
+	int						nRxPackets;
+
+	dslFrame				*freeBufListPtr;
+	void					*freeBufPool;
+	void					*pBufMemory;
+
+	dslFrame				*freePacketListPtr;
+	void					*freePacketPool;
+
+	/* RX working data set */
+
+	dslFrame				*pRxFrame;
+	dslFrameBuffer			*pRxBuf;
+	uchar					*pRxBufData;
+	uchar					*pRxBufDataEnd;
+	int						rxFrameLen;
+
+	/* TX working data set */
+
+	DListHeader				dlistTxWaiting;
+	dslFrame				*pTxFrame;
+	dslFrameBuffer			*pTxBuf;
+	uchar					*pTxBufData;
+	uchar					*pTxBufDataEnd;
+
+	/* stats data */
+
+	ulong					dslByteCntRxTotal;
+	ulong					dslByteCntTxTotal;
+
+	ulong					dslFrameCntRxTotal;
+	ulong					dslFrameCntRxErr;
+	ulong					dslFrameCntTxTotal;
+	
+} dslFramerControl;
+
+
+extern Boolean  DslFramerInit(
+			void					*gDslVars,
+			dslFramerControl		*dfCtrl,
+			bitMap					setup,
+			ulong					statusCode,
+			ulong					statusOffset,
+			dslFrameHandlerType		rxIndicateHandlerPtr,
+			dslFrameHandlerType		txCompleteHandlerPtr,
+			dslStatusHandlerType	statusHandlerPtr,
+			ulong					rxBufNum,
+			ulong					rxBufSize,
+			ulong					rxPacketNum);
+extern void DslFramerClose(void *gDslVars, dslFramerControl *dfCtrl);
+extern void DslFramerSendFrame(void *gDslVars, dslFramerControl *dfCtrl, dslFrame *pFrame);
+extern void DslFramerReturnFrame(void *gDslVars, dslFramerControl *dfCtrl, dslFrame *pFrame);
+
+
+extern Boolean DslFramerRxGetPtr(void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern void	DslFramerRxDone  (void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern Boolean	DslFramerTxGetPtr(void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern void	DslFramerTxDone(void *gDslVars, dslFramerControl *dfCtrl, dslFramerBufDesc *pBufDesc);
+extern Boolean DslFramerTxIdle (void *gDslVars, dslFramerControl *dfCtrl);
+extern void DslFramerTxFlush(void *gDslVars, dslFramerControl *dfCtrl);
+
+extern void * DslFramerGetFramePoolHandler(dslFramerControl *dfCtrl);
+extern void DslFramerClearStat(dslFramerControl *dfCtrl);
+
+extern void DslFramerRxFlushFrame (void *gDslVars, dslFramerControl *dfCtrl, int errCode);
+extern void DslFramerRxFlush(void *gDslVars, dslFramerControl *dfCtrl);
+
+#endif	/* DslFramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Flatten.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Flatten.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Flatten.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Flatten.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,115 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * Flatten.h -- Header for Flatten/Unflatten command/status
+ *
+ * Copyright (c) 1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.14 $
+ *
+ * $Id: Flatten.h,v 1.14 2004/03/04 19:48:52 linyin Exp $
+ *
+ * $Log: Flatten.h,v $
+ * Revision 1.14  2004/03/04 19:48:52  linyin
+ * Support adsl2plus
+ *
+ * Revision 1.13  2003/10/17 22:45:14  yongbing
+ * Increase buffer size for large B&G table of G992P3
+ *
+ * Revision 1.12  2003/08/12 23:16:26  khp
+ * - for Haixiang: added support for ADSL_MARGIN_TWEAK_TEST
+ *
+ * Revision 1.11  2003/02/27 06:33:03  ilyas
+ * Improved free space checking in command buffer (became a problem with
+ * 2 commands SetXmtgain and StartPhy)
+ *
+ * Revision 1.10  2003/01/11 01:27:07  ilyas
+ * Improved checking for available space in status buffer
+ *
+ * Revision 1.9  2002/09/07 01:43:59  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.8  2002/05/16 00:01:52  khp
+ * -added missing #endif
+ *
+ * Revision 1.7  2002/05/15 00:04:48  mprahlad
+ * increase the status buffer size - prevent memory overflow for annexC cases
+ *
+ * Revision 1.6  2002/04/05 04:10:33  linyin
+ * -hack to fit in Annex C firmware in LMEM
+ *
+ * Revision 1.5  2002/04/05 02:45:25  linyin
+ * Make the buffer side larger for annexC
+ *
+ * Revision 1.4  2002/01/30 07:19:06  ilyas
+ * Moved showtime code to LMEM
+ *
+ * Revision 1.3  2001/08/29 02:56:01  ilyas
+ * Added tests for flattening/unflatenning command and statuses (dual mode)
+ *
+ * Revision 1.2  2001/04/25 00:30:54  ilyas
+ * Adjusted MaxFrameLen
+ *
+ * Revision 1.1  2001/04/24 21:41:21  ilyas
+ * Implemented status flattening/unflattaning to transfer statuses between
+ * modules asynchronously through the circular buffer
+ *
+ *
+ *****************************************************************************/
+
+#ifndef _Flatten_H_
+#define _Flatten_H_
+
+#include	"CircBuf.h"
+
+#ifdef ADSL_MARGIN_TWEAK_TEST
+#define kMaxFlattenedCommandSize	272		/* maximum no. of bytes in flattened cmd */
+#else
+#define kMaxFlattenedCommandSize	128		/* maximum no. of bytes in flattened cmd */
+#endif
+#if	defined(G992_ANNEXC) || defined(G992P3)
+#if defined(G992P5)
+#define kMaxFlattenedStatusSize		2200   	/* maximum no. of bytes in flattened status */
+#else
+#define kMaxFlattenedStatusSize		1100   	/* maximum no. of bytes in flattened status */
+#endif
+#else
+#define kMaxFlattenedStatusSize		 550   	/* maximum no. of bytes in flattened status */
+#endif
+
+#define	kMaxFlattenFramelength		(kMaxFlattenedStatusSize - (4*sizeof(long)) - 20)
+
+extern int	SM_DECL FlattenCommand	(dslCommandStruct *cmd, ulong *dstPtr, ulong nAvail);
+extern int	SM_DECL UnflattenCommand(ulong *srcPtr, dslCommandStruct *cmd);
+extern int	SM_DECL FlattenStatus	(dslStatusStruct *status, ulong *dstPtr, ulong nAvail);
+extern int	SM_DECL UnflattenStatus	(ulong *srcPtr, dslStatusStruct *status);
+
+#define	FlattenBufferInit(fb,fbData,bufSize,itemSize)		\
+	StretchBufferInit(fb, fbData, bufSize, itemSize)
+	
+extern int	SM_DECL FlattenBufferStatusWrite(stretchBufferStruct *fBuf, dslStatusStruct *status);
+extern int	SM_DECL FlattenBufferStatusRead(stretchBufferStruct *fBuf, dslStatusStruct *status);
+
+extern int	SM_DECL FlattenBufferCommandWrite(stretchBufferStruct *fBuf, dslCommandStruct *cmd);
+extern int	SM_DECL FlattenBufferCommandRead(stretchBufferStruct *fBuf, dslCommandStruct *cmd);
+
+#define FlattenBufferReadComplete(fb,nBytes)				\
+	StretchBufferReadUpdate (fb, nBytes)
+
+#endif /* _Flatten_H_ */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,110 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * G992p3OvhMsg.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for the G992p3 overhead 
+ *  channel messages global variable structure.
+ *
+ *
+ * Copyright (c) 1999-2003 BroadCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: G992p3OvhMsg.gh,v 1.5 2004/09/11 03:52:25 ilyas Exp $
+ *
+ * $Log: G992p3OvhMsg.gh,v $
+ * Revision 1.5  2004/09/11 03:52:25  ilyas
+ * Added support for overhead message segmentation
+ *
+ * Revision 1.4  2004/07/07 01:27:20  ilyas
+ * Fixed OHC message stuck problem on L2 entry/exit
+ *
+ * Revision 1.3  2004/06/10 00:13:31  ilyas
+ * Added L2/L3 and SRA
+ *
+ * Revision 1.2  2004/04/12 23:34:52  ilyas
+ * Merged the latest ADSL driver chnages for ADSL2+
+ *
+ * Revision 1.1  2003/07/18 19:39:18  ilyas
+ * Initial G.992.3 overhead channel message implementation (from ADSL driver)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G992p3OvhMsgFramerGlobals
+#define	G992p3OvhMsgFramerGlobals
+
+#define	kG992p3OvhMsgMaxCmdSize			(16 + 16)
+#define	kG992p3OvhMsgMaxRspSize			(16 + 2*512)
+
+typedef struct
+	{
+	dslFrame				*segFrame;
+	dslFrameBuffer			*segFrBufCur;
+	dslFrameBuffer			segFrBuf;
+	ulong					timeSegOut;
+	uchar					tryCnt;
+	uchar					segTotal;
+	uchar					segId;
+	}
+	g992p3SegFrameCtlStruct;
+
+typedef struct
+	{
+	bitMap					setup;
+	dslFrameHandlerType		rxReturnFramePtr;
+	dslFrameHandlerType		txSendFramePtr;
+	dslCommandHandlerType	cmdHandlerPtr;
+	dslStatusHandlerType	statusHandlerPtr;
+
+	dslFrame				txRspFrame;
+	dslFrameBuffer			txRspFrBuf;
+	dslFrameBuffer			txRspFrBuf1;
+	uchar					txRspBuf[kG992p3OvhMsgMaxRspSize];
+	dslFrame				txPwrRspFrame;
+	dslFrameBuffer			txPwrRspFrBuf0;
+	dslFrameBuffer			txPwrRspFrBuf0a;
+	dslFrameBuffer			txPwrRspFrBuf1;
+	uchar					txPwrRspBuf0[8];
+	dslFrame				txCmdFrame;
+	dslFrameBuffer			txCmdFrBuf0;
+	dslFrameBuffer			txCmdFrBuf0a;
+	dslFrameBuffer			txCmdFrBuf1;
+	uchar					txCmdBuf[kG992p3OvhMsgMaxCmdSize];
+	g992p3SegFrameCtlStruct	txSegFrameCtl;
+	ulong					txFlags;
+	uchar					txL0Rq;
+	uchar					txL3Rq;
+
+	ulong					timeMs;
+	ulong					timeCmdOut;
+	ulong					cmdTryCnt;
+	ulong					cmdNum;
+	ulong					timeRspOut;
+	uchar					*txPmdCmd;
+
+	uchar					rxCmdMsgNum;
+	uchar					rxRspMsgNum;
+	uchar					txCmdMsgNum;
+	uchar					txRspMsgNum;
+	}
+	g992p3OvhMsgVarsStruct;
+
+#endif	/* G992p3OvhMsgFramerGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G992p3OvhMsg.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * G992p3OvhMsg.h 
+ *
+ * Description:
+ *	This file contains the exported functions and definitions for G992p3 
+ *  overhead channel messages
+ *
+ *
+ * Copyright (c) 1999-2003 BroadCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.1 $
+ *
+ * $Id: G992p3OvhMsg.h,v 1.1 2003/07/18 19:39:18 ilyas Exp $
+ *
+ * $Log: G992p3OvhMsg.h,v $
+ * Revision 1.1  2003/07/18 19:39:18  ilyas
+ * Initial G.992.3 overhead channel message implementation (from ADSL driver)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G992p3OvhMsgFramerHeader
+#define	G992p3OvhMsgFramerHeader
+
+#define	kG992p3OvhMsgFrameBufCnt	-1
+
+extern Boolean  G992p3OvhMsgInit(
+		void					*gDslVars, 
+		bitMap					setup,
+		dslFrameHandlerType		rxReturnFramePtr,
+		dslFrameHandlerType		txSendFramePtr,
+		dslCommandHandlerType	commandHandler,
+		dslStatusHandlerType	statusHandler);
+
+extern void		G992p3OvhMsgReset(void *gDslVars);
+extern void		G992p3OvhMsgClose(void *gDslVars);
+extern void		G992p3OvhMsgTimer(void *gDslVars, long timeQ24ms);
+extern Boolean	G992p3OvhMsgCommandHandler (void *gDslVars, dslCommandStruct *cmd);
+extern void		G992p3OvhMsgStatusSnooper (void *gDslVars, dslStatusStruct *status);
+
+extern	int		G992p3OvhMsgSendCompleteFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+extern  int		G992p3OvhMsgIndicateRcvFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+
+extern void		G992p3OvhMsgSetL3(void *gDslVars);
+extern void		G992p3OvhMsgSetL0(void *gDslVars);
+
+#endif	/* G992p3OvhMsgFramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,66 @@
+/****************************************************************************
+ *
+ * G997.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for the G997 Framer
+ *	global variable structure.
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: G997.gh,v 1.5 2004/07/21 01:39:41 ilyas Exp $
+ *
+ * $Log: G997.gh,v $
+ * Revision 1.5  2004/07/21 01:39:41  ilyas
+ * Reset entire G.997 state on retrain. Timeout in G.997 if no ACK
+ *
+ * Revision 1.4  2004/04/27 00:27:16  ilyas
+ * Implemented double buffering to ensure G.997 HDLC frame is continuous
+ *
+ * Revision 1.3  2003/07/18 18:56:59  ilyas
+ * Added support for shared TX buffer (for ADSL driver)
+ *
+ * Revision 1.2  2002/01/11 06:48:27  ilyas
+ * Added command handler pointer
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G997FramerGlobals
+#define	G997FramerGlobals
+
+#include "DslFramer.h"
+#include "HdlcFramer.h"
+
+#define	kG997MsgBufSize		64
+
+typedef struct
+	{
+	bitMap					setup;
+	dslFramerControl		dslFramer;
+	hdlcByteControl			hdlcByte;
+	dslCommandHandlerType	commandHandler;
+
+	ulong					timeMs;
+	ulong					timeCmdOut;
+
+	uchar					rxMsgNum;		
+	uchar					txMsgNum;
+	Boolean					txIdle;		
+	uchar					txMsgBuf[kG997MsgBufSize];
+	ulong					txMsgBufLen;
+	uchar					*txMsgBufPtr;
+	ulong					txMsgLen;
+	ulong					txMsgBufs;
+	ulong					txMsgBufNum;
+	}
+	g997VarsStruct;
+
+#endif	/* G997FramerGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/G997.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * G997.h 
+ *
+ * Description:
+ *	This file contains the exported functions and definitions for G97Framer
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.3 $
+ *
+ * $Id: G997.h,v 1.3 2003/07/18 18:56:59 ilyas Exp $
+ *
+ * $Log: G997.h,v $
+ * Revision 1.3  2003/07/18 18:56:59  ilyas
+ * Added support for shared TX buffer (for ADSL driver)
+ *
+ * Revision 1.2  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	G997FramerHeader
+#define	G997FramerHeader
+
+extern Boolean  G997Init(
+		void					*gDslVars, 
+		bitMap					setup, 
+		ulong					rxBufNum,
+		ulong					rxBufSize,
+		ulong					rxPacketNum,
+		upperLayerFunctions		*pUpperLayerFunctions,
+		dslCommandHandlerType	g997PhyCommandHandler);
+
+extern void		G997Close(void *gDslVars);
+extern void		G997Timer(void *gDslVars, long timeQ24ms);
+extern Boolean	G997CommandHandler (void *gDslVars, dslCommandStruct *cmd);
+extern void		G997StatusSnooper (void *gDslVars, dslStatusStruct *status);
+
+extern	int		G997SendFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+extern  int		G997ReturnFrame(void *gDslVars, void *pVc, ulong mid, dslFrame *pFrame);
+
+extern  Boolean G997SetTxBuffer(void *gDslVars, ulong len, void *bufPtr);
+extern	void *	G997GetFramePoolHandler(void *gDslVars);
+
+#endif	/* G997FramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/HdlcFramer.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/HdlcFramer.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/HdlcFramer.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/HdlcFramer.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,237 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * HdlcFramer.h 
+ *
+ * Description:
+ *	This file contains common HDLC definitions for bit/byte stuffing
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.3 $
+ *
+ * $Id: HdlcFramer.h,v 1.3 2004/07/21 01:39:41 ilyas Exp $
+ *
+ * $Log: HdlcFramer.h,v $
+ * Revision 1.3  2004/07/21 01:39:41  ilyas
+ * Reset entire G.997 state on retrain. Timeout in G.997 if no ACK
+ *
+ * Revision 1.2  2003/07/18 18:51:05  ilyas
+ * Added mode (default) to pass address and control field
+ *
+ * Revision 1.1  2001/12/13 02:28:27  ilyas
+ * Added common framer (DslPacket and G997) and G997 module
+ *
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	HdlcFramerHeader
+#define	HdlcFramerHeader
+
+/* setup bitmap definitions */
+
+#define	kHdlcSetupShift			16
+#define	kHdlcSetupMask			((long)0xFFFF << kHdlcSetupShift)
+
+#define	kHdlcCrcMask			0x00030000
+#define	kHdlcCrcNone			0x00000000
+#define	kHdlcCrc16				0x00010000
+#define	kHdlcCrc32				0x00020000
+
+#define	kHdlcTxIdleStop			0x00040000
+#define	kHdlcSpecialAddrCtrl	0x00080000
+
+extern	ushort HdlcCrc16Table[];
+
+#define HDLC16_CRC_INIT			0xFFFF
+#define HDLC16_CRC_FINAL(crc)	((crc) ^ 0xFFFF)
+#define HDLC16_GOOD_CRC			0xF0B8
+#define	Hdlc16UpdateCrc(crc,b)	((crc) >> 8) ^ HdlcCrc16Table[((crc) ^ (b)) & 0xFF]
+
+extern	ulong  HdlcCrc32Table[];
+
+#define HDLC32_CRC_INIT			0xFFFFFFFF
+#define HDLC32_CRC_FINAL(crc)	((crc) ^ 0xFFFFFFFF)
+#define HDLC32_GOOD_CRC			0xDEBB20E3
+#define	Hdlc32UpdateCrc(crc,b)	((crc) >> 8) ^ HdlcCrc32Table[((crc) ^ (b)) & 0xFF]
+
+extern	ulong  HdlcCrc32Table[];
+
+/* HDLC common fields */
+
+#define	HDLC_ADDR				0xFF
+#define	HDLC_CTRL				0x3
+
+#define	HDLC_BYTE_FLAG			0x7E
+#define	HDLC_BYTE_ESC			0x7D
+
+/* HDLC frame assembly states */
+
+#define	HDLC_STATE_START_FLAG	0
+#define	HDLC_STATE_ADDRESS		(HDLC_STATE_START_FLAG + 1)
+#define	HDLC_STATE_CONTROL		(HDLC_STATE_START_FLAG + 2)
+#define	HDLC_STATE_DATA			(HDLC_STATE_START_FLAG + 3)
+#define	HDLC_STATE_FCS1			(HDLC_STATE_START_FLAG + 4)
+#define	HDLC_STATE_FCS2			(HDLC_STATE_START_FLAG + 5)
+#define	HDLC_STATE_END_FLAG		(HDLC_STATE_START_FLAG + 6)
+
+
+/* HDLC common types */
+
+typedef struct _hdlcByteControl {
+	bitMap					setup;
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	rxDataDoneHandler;
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	txDataDoneHandler;
+
+	/* RX working data set */
+
+	uchar					rxFrameState;
+	int						rxFrameLen;
+	ulong					rxCrc;
+	Boolean					rxEscChar;
+
+	uchar					*pRxData;
+	uchar					*pRxDataEnd;
+	long					rxDataLen;
+
+	/* TX working data set */
+
+	uchar					txFrameState;
+	int						txFrameLen;
+	ulong					txCrc;
+	int						txCharPending;
+
+	uchar					*pTxData;
+	uchar					*pTxDataEnd;
+	long					txDataLen;
+} hdlcByteControl;
+
+typedef struct _hdlcBitControl {
+	bitMap					setup;
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	rxDataDoneHandler;
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	txDataDoneHandler;
+
+	/* RX working data set */
+
+	uchar					rxFrameState;
+	int						rxFrameLen;
+	ulong					rxCrc;
+	int						rxNibblePending;
+	int						rxOutVal;
+	uchar					rxOutBits;
+	uchar					rxRem1Bits;
+	Boolean					rxEscChar; /* ???? */
+
+	uchar					*pRxData;
+	uchar					*pRxDataEnd;
+	long					rxDataLen;
+
+	/* TX working data set */
+
+	uchar					txFrameState;
+	int						txFrameLen;
+	ulong					txCrc;
+	int						txOutVal;
+	uchar					txOutBits;
+	uchar					txLast1Bits;
+	int						txCharPending;	/* ???? */
+
+	uchar					*pTxData;
+	uchar					*pTxDataEnd;
+	long					txDataLen;
+} hdlcBitControl;
+
+/* HDLC common functions */
+
+#define HdlcFramerTxFrameInit(ctrl)	do {			\
+	ctrl->txFrameState = HDLC_STATE_START_FLAG;		\
+	ctrl->txFrameLen   = 0;							\
+	ctrl->txCrc		   = HDLC16_CRC_INIT;			\
+	ctrl->txCharPending= -1;						\
+} while (0)
+
+#define HdlcFramerRxFrameInit(ctrl) do {			\
+	ctrl->rxFrameState = HDLC_STATE_START_FLAG;		\
+	ctrl->rxFrameLen   = 0;							\
+	ctrl->rxCrc		   = HDLC16_CRC_INIT;			\
+	ctrl->rxEscChar	   = false;						\
+} while (0)
+
+#define HdlcFramerTxGetData(ctrl)  do {								\
+	dslFramerBufDesc	bufDesc;									\
+																	\
+	if ((ctrl->txDataGetPtrHandler) (gDslVars, &bufDesc)) {			\
+		ctrl->pTxData = bufDesc.bufPtr;								\
+		ctrl->pTxDataEnd = (uchar*)bufDesc.bufPtr + bufDesc.bufLen;	\
+		ctrl->txDataLen	 = bufDesc.bufLen;							\
+		if (bufDesc.bufFlags & kDslFramerStartNewFrame)				\
+			HdlcFramerTxFrameInit(ctrl);							\
+	}																\
+	else {															\
+		HdlcFramerTxFrameInit(ctrl);								\
+	}																\
+} while (0);
+
+#define HdlcFramerRxGetData(ctrl, frFlag)  do {						\
+	dslFramerBufDesc		bufDesc;								\
+																	\
+	bufDesc.bufFlags = frFlag;										\
+	if ((ctrl->rxDataGetPtrHandler) (gDslVars, &bufDesc)) {			\
+		ctrl->pRxData = bufDesc.bufPtr;								\
+		ctrl->pRxDataEnd = (uchar*)bufDesc.bufPtr + bufDesc.bufLen;	\
+		ctrl->rxDataLen	 = bufDesc.bufLen;							\
+	}																\
+} while (0);
+
+/* HDLC functions headers */
+
+extern Boolean HdlcByteInit(
+	void							*gDslVars, 
+	hdlcByteControl					*hbyCtrl,
+	bitMap							setup, 
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	rxDataDoneHandler,
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	txDataDoneHandler);
+
+extern void HdlcByteReset(void *gDslVars, hdlcByteControl *hbyCtrl);
+extern void HdlcByteRxFlush(void *gDslVars, hdlcByteControl *hbyCtrl);
+extern int HdlcByteRx(void *gDslVars, hdlcByteControl *hbyCtrl, int nBytes, uchar *srcPtr) FAST_TEXT;
+extern int HdlcByteTx(void *gDslVars, hdlcByteControl *hbyCtrl, int nBytes, uchar *dstPtr) FAST_TEXT;
+extern Boolean HdlcByteTxIdle(void *gDslVars, hdlcByteControl *hbyCtrl);
+
+extern Boolean HdlcBitInit(
+	void							*gDslVars, 
+	hdlcBitControl					*hbiCtrl,
+	bitMap							setup, 
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	rxDataDoneHandler,
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler,
+	dslFramerDataDoneHandlerType	txDataDoneHandler);
+
+extern void HdlcBitReset(void *gDslVars, hdlcByteControl *hbiCtrl);
+extern int HdlcBitRx(void *gDslVars, hdlcBitControl *hbiCtrl, int nBytes, uchar *srcPtr) FAST_TEXT;
+extern int HdlcBitTx(void *gDslVars, hdlcBitControl *hbiCtrl, int nBytes, uchar *dstPtr) FAST_TEXT;
+
+#endif	/* HdlcFramerHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MathUtil.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MathUtil.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MathUtil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MathUtil.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,135 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/************************************************************************
+ *
+ *	MathUtil.h:
+ *
+ *	Description:
+ *	This file contains the exported interface for MathUtil.c module.
+ *
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.6 $
+ *
+ * $Id: MathUtil.h,v 1.6 2004/04/13 00:21:13 ilyas Exp $
+ *
+ * $Log: MathUtil.h,v $
+ * Revision 1.6  2004/04/13 00:21:13  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.5  2001/08/16 02:18:08  khp
+ * - mark functions with FAST_TEXT to reduce cycle counts for QPROC targets
+ *   (replaces use of LMEM_INSN)
+ *
+ * Revision 1.4  1999/10/06 04:55:22  liang
+ * Added function to multiply two long values to save result as VeryLong.
+ *
+ * Revision 1.3  1999/08/05 19:42:52  liang
+ * Merged with the softmodem top of the tree on 08/04/99 for assembly files.
+ *
+ * Revision 1.2  1999/03/26 03:29:59  liang
+ * Export CosSin table.
+ *
+ * Revision 1.1  1998/10/28 01:28:07  liang
+ * *** empty log message ***
+ *
+ * Revision 1.12  1998/02/10  17:19:49  scott
+ * Changed MathVL routines to return arguments using pointers
+ *
+ * Revision 1.11  1997/12/13 06:12:07  mwg
+ * Added more Atan2 flavors
+ *
+ * Revision 1.10  1997/11/18 01:11:48  mwg
+ * Removed <CR> symbols which accidently slipped in.
+ *
+ * Revision 1.9  1997/11/03  19:07:52  scott
+ * No longer redefine max() and min() if already defined
+ *
+ * Revision 1.8  1997/07/30 01:35:20  liang
+ * Add more accurate atan2 function UtilLongLongAtan2.
+ *
+ * Revision 1.7  1997/07/21  20:23:19  mwg
+ * Added new function: UtilBlockCos()
+ *
+ * Revision 1.6  1997/03/21  23:50:10  liang
+ * Added initial version of V8bis module to CVS tree.
+ *
+ * Revision 1.5  1997/03/19  18:35:34  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.4  1997/01/21  00:36:15  mwg
+ * Added new function: UtilBlockCosSin()
+ *
+ * Revision 1.3  1996/06/18  21:14:45  mwg
+ * Modified VLDivVL by allowing to specify the result scaling.
+ *
+ * Revision 1.2  1996/06/12  02:31:59  mwg
+ * Added 64bit arithmetic functions.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:15  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.4  1995/12/04  23:08:15  liang
+ * Add file Math/LinearToLog.c.
+ *
+ ************************************************************************/
+#ifndef	MathUtilPh
+#define	MathUtilPh
+
+/* Exported tables */
+extern	const short		UtilCosTable[];
+
+/* Exported functions */
+extern	ComplexShort	UtilCosSin(ushort angle);
+extern	long			UtilBlockCosSin (int nValues, long angle, long delta, ComplexShort *dstPtr);
+extern	long			UtilBlockCos (int nValues, long angle, long delta, short *dstPtr);
+extern	ushort			UtilShortShortAtan2(ComplexShort point);
+extern	ushort			UtilLongShortAtan2(ComplexLong point);
+extern	ulong			UtilShortLongAtan2(ComplexShort point) FAST_TEXT;
+extern	ulong			UtilLongLongAtan2(ComplexLong point) FAST_TEXT;
+extern	ushort			UtilSqrt(ulong y);
+extern	ushort			UtilMaxMagnitude(int blkSize, ComplexShort *dataPtr);
+extern	short			UtilQ0LinearToQ4dB (ulong x);
+extern	ulong			UtilQ4dBToQ12Linear (short x);
+extern	void			UtilAdjustComplexMagnitude(ComplexShort	*srcPtr, short mag, short adjustment);
+
+extern	void VLMultLongByLong(long x, long y, VeryLong *dst);
+extern	void VLMultShort	(VeryLong x, short y, VeryLong *dst);
+extern	void VLAddVL		(VeryLong x, VeryLong y, VeryLong *dst);
+extern	void VLAddLong	(VeryLong x, long y, VeryLong *dst);
+extern	void VLSubVL		(VeryLong x, VeryLong y, VeryLong *dst);
+extern	void VLSubLong	(VeryLong x, long y, VeryLong *dst);
+extern	void VLDivVL		(VeryLong x, VeryLong y, int scale, long *dst);
+extern	void VLShiftLeft(VeryLong x, int shift, VeryLong *dst);
+extern	void VLShiftRight(VeryLong x, int shift, VeryLong *dst);
+
+
+#define	UtilAtan2		UtilShortShortAtan2
+#define	UtilLongAtan2	UtilLongShortAtan2
+
+/* Standard Macros	*/
+#undef abs
+#define		abs(x)			((x) >= 0   ? (x) : -(x))
+
+#undef max
+#define		max(x, y)		((x) >= (y) ? (x) : (y))
+
+#undef min
+#define		min(x, y)		((x) <= (y) ? (x) : (y))
+
+#endif	/* MathUtilPh */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MipsAsm.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MipsAsm.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MipsAsm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MipsAsm.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,264 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/************************************************************************
+ *
+ *	MipsAsm.h:
+ *
+ *	Description:
+ *	This file contains definitions specific to MIPS assembly 
+ *
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.5 $
+ *
+ * $Id: MipsAsm.h,v 1.5 2004/04/13 00:16:59 ilyas Exp $
+ *
+ * $Log: MipsAsm.h,v $
+ * Revision 1.5  2004/04/13 00:16:59  ilyas
+ * Merged the latest ADSL driver changes
+ *
+ * Revision 1.4  2002/09/12 04:08:50  ilyas
+ * Added macros for BCM MIPS specific instructions
+ *
+ * Revision 1.3  2000/11/18 21:28:19  mprahlad
+ * ifdef bcm47xx -
+ * define MSUB(src1,src2) msub src1, src2
+ * change Mult(dst, src1, src2) to use "mul" instead of "mult; mflo"
+ * define Mul(src1, src2) mult src1, src2
+ *
+ * Revision 1.2  2000/07/28 21:05:05  mprahlad
+ * Macros specific to bcm47xx added.
+ *
+ * Revision 1.1  1999/08/05 19:52:57  liang
+ * Copied from the softmodem top of the tree on 08/04/99.
+ *
+ * Revision 1.5  1999/04/02 23:16:21  mwg
+ * Fixed a minor comatibility issue with mult
+ *
+ * Revision 1.4  1999/02/03 20:25:43  mwg
+ * Added an option for R4010
+ *
+ * Revision 1.3  1998/10/30 02:21:34  mwg
+ * Added targets for 4640
+ *
+ * Revision 1.2  1998/10/16 18:52:09  ilyas
+ * Added ASM_PROLOG[5-7] macros to save on stores
+ *
+ * Revision 1.1  1998/06/03 23:28:39  mwg
+ * Renamed from DinoDefs.h
+ *
+ * Revision 1.6  1998/02/09  18:23:11  scott
+ * Added EMBEDDED_CALLING_CONVENTION (GreenHill) and R3900/R4102
+ *
+ * Revision 1.5  1997/03/19 18:35:02  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.4  1996/10/02  20:28:41  liang
+ * Remove parameter "acc" from the non-DINO version of MAD.
+ *
+ * Revision 1.3  1996/10/02  19:44:36  liang
+ * Separated MultAdd into MAD and MADW, added NO_DINO_WRITEBACK option.
+ *
+ * Revision 1.2  1996/08/14  03:06:07  liang
+ * Modified macro MultAdd so that the assembly code build works.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.5  1994/11/04  22:41:29  mwg
+ * Added #ifdefs for different targets.
+ *
+ ************************************************************************/
+
+#ifndef _MIPS_ASM_H_
+#define	_MIPS_ASM_H_
+
+#define zero	$0
+#define v0	$2
+#define v1	$3
+#define a0	$4
+#define a1	$5
+#define a2	$6
+#define a3	$7
+#define t0	$8
+#define t1	$9
+#define t2	$10
+#define t3	$11
+#define t4	$12
+#define t5	$13
+#define t6	$14
+#define t7	$15
+#define s0	$16	
+#define s1	$17
+#define s2	$18
+#define s3	$19
+#define s4	$20
+#define s5	$21
+#define s6	$22
+#define s7	$23
+#define t8	$24
+#define t9	$25
+#define k0	$26
+#define k1	$27
+#define gp	$28
+#define sp	$29
+#define fp	$30
+#define s8	$30
+#define ra	$31
+
+#ifdef EMBEDDED_CALLING_CONVENTION
+
+/* Support for GreenHills embedded calling convention */
+
+#define ASM_PROLOG	subu	sp, 32; \
+					sw		$8, 16(sp); \
+					sw		$9, 20(sp); \
+					sw		$10, 24(sp); \
+					sw		$11, 28(sp);
+
+#define ASM_PROLOG5	subu	sp, 32; \
+					sw		$8, 16(sp);
+
+#define ASM_PROLOG6	subu	sp, 32; \
+					sw		$8, 16(sp); \
+					sw		$9, 20(sp);
+
+#define ASM_PROLOG7	subu	sp, 32; \
+					sw		$8, 16(sp); \
+					sw		$9, 20(sp); \
+					sw		$10, 24(sp);
+
+#define ASM_EPILOG	addu	sp, 32
+
+#else
+#define ASM_PROLOG
+#define ASM_PROLOG5
+#define ASM_PROLOG6
+#define ASM_PROLOG7
+#define ASM_EPILOG
+#endif
+
+#ifdef	DINO	/* Special DSP extensions to MIPS core */
+
+#ifndef	NO_DINO_WRITEBACK	/* DSP extensions with writeback register */
+
+#define	MAD(src1, src2)			.set	noreorder	; mad	$0, src1, src2	; .set	reorder
+#define	MADW(acc, src1, src2)	.set	noreorder	; mad	acc, src1, src2	; .set	reorder
+#define	Mult(dst, src1, src2)	.set	noreorder	; mult	dst, src1, src2	; .set	reorder	
+#define	MultU(dst, src1, src2)	.set	noreorder	; multu	dst, src1, src2	; .set	reorder		
+
+#else	/* NO_DINO_WRITEBACK */
+
+#define	MAD(src1, src2)			.set	noreorder	; mad	$0, src1, src2	; .set	reorder
+#define	MADW(acc, src1, src2)	.set	noreorder	; mad	$0, src1, src2	; mflo acc ; .set	reorder
+#define	Mult(dst, src1, src2)	multu	src1, src2 ; mflo dst
+#define	MultU(dst, src1, src2)	multu	src1, src2 ; mflo dst		
+
+#endif	/* NO_DINO_WRITEBACK */
+
+#else	/* DINO */
+
+#if defined(R3900)
+
+#define	MAD(src1, src2)		madd	$0, src1, src2
+#define	MADW(acc, src1, src2)	madd	acc, src1, src2
+#define	Mult(dst, src1, src2)	mult	dst, src1, src2
+#define	MultU(dst, src1, src2)	multu	dst, src1, src2
+
+#elif defined(bcm47xx_INSTR_MACROS) && defined(bcm47xx)
+
+#define mips_froo(s1,s2,s3)			s1##s2##s3
+#define	MSUB(s1,s2)					.set noreorder ; mips_froo(msub_,s1,s2) ; .set reorder
+#define MAD(s1,s2) 					.set noreorder ; mips_froo(mad_,s1,s2) ; .set reorder
+#define MADW(acc, s1,s2)			.set noreorder ; mips_froo(mad_,s1,s2) ; mflo acc ; .set reorder
+
+#include "BCM4710.h"
+
+#define	Mult(dst, src1, src2)		mul		dst, src1, src2
+#define	Mul( src1, src2)			mult	src1, src2 ; 
+#define	MultU(dst, src1, src2)		multu	src1, src2	; mflo dst
+
+#elif defined(bcm47xx)
+#define	MSUB(src1, src2)			msub	src1, src2
+#define	MAD(src1, src2)			madd	src1, src2
+#define	MADW(acc, src1, src2)	.set noreorder ; madd	src1, src2; mflo acc ; .set reorder
+/*
+#define	Mult(dst, src1, src2)	mult	src1, src2 ; mflo dst
+*/
+#define	Mult(dst, src1, src2)	mul	dst , src1, src2 ; 
+#define	Mul( src1, src2)	mult	src1, src2 ; 
+#define	MultU(dst, src1, src2)	multu	src1, src2 ; mflo dst
+
+#else
+
+#ifdef R4102
+#define	MAD(src1, src2)			madd16	src1, src2
+#define	MADW(acc, src1, src2)	madd16	src1, src2	; mflo acc
+#else /* R4102 */
+
+#ifdef R4640
+
+#define	MAD(src1, src2)			madd	$0, src1, src2
+#define	MADW(acc, src1, src2)	madd	src1, src2; mflo acc
+
+#else /* R4640 */
+
+#ifdef R4010
+
+#define	MAD(src1, src2)			madd	src1, src2
+#define	MADW(acc, src1, src2)	madd	src1, src2; mflo acc
+
+#else
+#define	MAD(src1, src2)				.set	noat		;\
+									mflo	$at			;\
+									sw		$2,   -4(sp)	;\
+									multu	src1, src2	;\
+									mflo	$2			;\
+									addu	$at, $2, $at	;\
+									lw		$2,   -4(sp)	;\
+									mtlo	$at		;\
+									.set	at
+
+#define	MADW(acc, src1, src2)		.set	noat		;\
+									mflo	$at			;\
+									sw		$2,   -4(sp)	;\
+									multu	src1, src2	;\
+									mflo	$2			;\
+									addu	$at, $2, $at	;\
+									lw		$2,   -4(sp)	;\
+									move	acc, $at	;\
+									mtlo	$at		;\
+									.set	at
+#endif /* R4010 */
+#endif /* R4102 */
+#endif /* R4640 */
+
+#define	Mult(dst, src1, src2)		mul		dst, src1, src2
+#define	MultU(dst, src1, src2)		multu	src1, src2	; mflo dst
+
+#endif	/* !3900 */
+#endif	/* DINO */
+
+
+
+
+
+
+
+
+#endif	/* _MIPS_ASM_H_ */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MiscUtil.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MiscUtil.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MiscUtil.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/MiscUtil.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,65 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * MiscUtil.h -- Miscellaneous utilities
+ *
+ * Description:
+ *
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg Haixiang Liang
+ *
+ * $Revision: 1.4 $
+ *
+ * $Id: MiscUtil.h,v 1.4 2004/04/13 00:21:46 ilyas Exp $
+ *
+ * $Log: MiscUtil.h,v $
+ * Revision 1.4  2004/04/13 00:21:46  ilyas
+ * Added standard header for shared ADSL driver files
+ *
+ * Revision 1.3  2001/07/21 01:21:06  ilyas
+ * Added more functions for int to string conversion used by log file
+ *
+ * Revision 1.2  1999/08/05 19:42:56  liang
+ * Merged with the softmodem top of the tree on 08/04/99 for assembly files.
+ *
+ * Revision 1.1  1999/01/27 22:10:12  liang
+ * Initial version.
+ *
+ * Revision 1.1  1997/07/10 01:18:45  mwg
+ * Initial revision.
+ *
+ *
+ *
+ *****************************************************************************/
+#ifndef _MISC_UTIL_H_
+#define _MISC_UTIL_H_
+
+extern long		SM_DECL	GetRateValue(dataRateMap rate);
+extern int 		SM_DECL	DecToString(ulong value, uchar *dstPtr, uint nDigits);
+extern int 		SM_DECL	HexToString(ulong value, uchar *dstPtr, uint nDigits);
+extern char *	SM_DECL	DecToStr(char *s, ulong num);
+extern char *	SM_DECL	SignedToStr(char *s, long num);
+extern char *	SM_DECL	HexToStr(char *s, ulong num);
+
+#define	EvenParityBit(x)	((z = (y = x ^ (x >> 4)) ^ (y >> 2)) ^ (z >> 1))
+#define	OddParityBit(x)		(EvenParityBit(x) ^ 1)
+
+extern void	ParityApply(int nBytes, int nDataBits, int parity, uchar *srcPtr, uchar *dstPtr);
+extern void	ParityStrip(int nBytes, int nDataBits, int parity, uchar *srcPtr, uchar *dstPtr, statusHandlerType	statusHandler);
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Que.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Que.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Que.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/Que.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,106 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * Que.h
+ *
+ * Description:
+ *	Definition and implementation (via macros and inline functions)
+ *  of a simple queue
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ *****************************************************************************/
+
+#ifndef	QueHeader_H_
+#define	QueHeader_H_
+
+typedef void *		_QueItem;
+
+typedef struct _QueHeader
+	{
+	_QueItem	*head;		/* first item in the queue */
+	_QueItem	*tail;		/* last item in the queue */
+	} QueHeader;
+
+/* Queue management macros */
+
+#define QueInit(pqHdr)		(((QueHeader *)(pqHdr))->head = ((QueHeader *)(pqHdr))->tail = NULL)
+#define QueEmpty(pqHdr)     (NULL == ((QueHeader *)(pqHdr))->head)
+
+#define QueFirst(pqHdr)		((QueHeader *)(pqHdr))->head
+#define QueLast(pqHdr)		((QueHeader *)(pqHdr))->tail 
+#define QueNext(pqItem)		(*((void **)(pqItem)))
+
+
+#define QueRemoveFirst(pqHdr)	do {										\
+    if (!QueEmpty(pqHdr)) {													\
+      ((QueHeader *)(pqHdr))->head = *((QueHeader *)(pqHdr))->head;			\
+      if (QueEmpty(pqHdr))													\
+        ((QueHeader *)(pqHdr))->tail = NULL;								\
+    }																		\
+} while (0)
+#define QueRemove(pqHdr)		QueRemoveFirst(pqHdr)
+
+
+#define QueAddLast(pqHdr,pqItem) do {						\
+    QueNext(pqItem) = NULL;									\
+    if (NULL != ((QueHeader *)(pqHdr))->tail)				\
+      *((QueHeader *)(pqHdr))->tail = (pqItem);				\
+    else													\
+      ((QueHeader *)(pqHdr))->head = (_QueItem *)(pqItem);  \
+    ((QueHeader *)(pqHdr))->tail = (_QueItem *)(pqItem);    \
+} while (0)
+#define QueAdd(pqHdr,pItem)    QueAddLast(pqHdr,pItem)
+
+#define QueAddFirst(pqHdr,pqItem)	do {					\
+    if (NULL == ((QueHeader *)(pqHdr))->tail)				\
+	  ((QueHeader *)(pqHdr))->tail = (_QueItem *)(pqItem);  \
+    QueNext(pqItem) = ((QueHeader *)(pqHdr))->head;			\
+    ((QueHeader *)(pqHdr))->head = (_QueItem *)(pqItem);	\
+} while (0)
+
+
+#define QueGet(pqHdr)			\
+  (void *) QueFirst(pqHdr);		\
+  QueRemove(pqHdr);
+
+#define QueMerge(pqHdr1,pqHdr2)	do {											\
+  if (NULL == ((QueHeader *)(pqHdr1))->tail)									\
+	((QueHeader *)(pqHdr1))->head = ((QueHeader *)(pqHdr2))->head;				\
+  else																			\
+    QueNext(((QueHeader *)(pqHdr1))->tail) = ((QueHeader *)(pqHdr2))->head;		\
+  if (NULL != ((QueHeader *)(pqHdr2))->tail)                 					\
+	((QueHeader *)(pqHdr1))->tail = ((QueHeader *)(pqHdr2))->tail;				\
+} while (0)
+
+#define QueCopy(pqHdr1,pqHdr2)	do {											\
+	((QueHeader *)(pqHdr1))->head = ((QueHeader *)(pqHdr2))->head;				\
+	((QueHeader *)(pqHdr1))->tail = ((QueHeader *)(pqHdr2))->tail;				\
+} while (0)
+
+#define	QueForEach(pqHdr,f,ref)		do {			\
+	_QueItem	*p = ((QueHeader *)(pqHdr))->head;	\
+													\
+	while (NULL != p) {								\
+	  if ( (f)((void *)p, ref) ) break;				\
+	  p = QueNext(p);								\
+	}												\
+} while (0)
+
+#endif	/* QueHeader_H_ */
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftAtmVc.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftAtmVc.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftAtmVc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftAtmVc.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,569 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * SoftAtmVc.h 
+ *
+ * Description:
+ *	This file contains ATM VC definitions
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.27 $
+ *
+ * $Id: SoftAtmVc.h,v 1.27 2004/06/02 22:26:17 ilyas Exp $
+ *
+ * $Log: SoftAtmVc.h,v $
+ * Revision 1.27  2004/06/02 22:26:17  ilyas
+ * Added ATM counters for G.992.3
+ *
+ * Revision 1.26  2004/03/10 22:57:20  ilyas
+ * Added I.432 scramling control
+ *
+ * Revision 1.25  2003/09/23 00:21:59  ilyas
+ * Added status to indicate ATM header compression
+ *
+ * Revision 1.24  2003/08/27 02:00:50  ilyas
+ * Original implementation of ATM header compression
+ *
+ * Revision 1.23  2003/02/25 04:13:15  ilyas
+ * Added standard Broadcom header
+ *
+ * Revision 1.22  2003/01/10 23:25:48  ilyas
+ * Added ATM status definition
+ *
+ * Revision 1.21  2002/09/12 21:07:19  ilyas
+ * Added HEC, OCD and LCD counters
+ *
+ * Revision 1.20  2002/04/02 09:58:00  ilyas
+ * Initial implementatoin of BERT
+ *
+ * Revision 1.19  2001/10/09 22:35:14  ilyas
+ * Added more ATM statistics and OAM support
+ *
+ * Revision 1.18  2001/06/18 19:49:36  ilyas
+ * Changes to include support for HOST_ONLY mode
+ *
+ * Revision 1.17  2001/02/23 05:49:57  ilyas
+ * Added routed 1483 encapsulation
+ *
+ * Revision 1.16  2001/02/09 04:18:18  ilyas
+ * Added framer for bridged ethernet PDUs
+ *
+ * Revision 1.15  2001/02/09 01:55:27  ilyas
+ * Added status codes and macros to support printing of AAL packets
+ *
+ * Revision 1.14  2000/09/21 17:28:35  ilyas
+ * Added VBR support to traffic management code, separated UBR to a different
+ * Tx list, changed some of the algorithms
+ *
+ * Revision 1.13  2000/08/23 18:42:13  ilyas
+ * Added AAL2, added VcConfigure functions, moved commonly used look-up
+ * tables for CRC calculation to AtmLayer
+ *
+ * Revision 1.12  2000/08/02 03:06:22  ilyas
+ * Added support for reserving space in RX packets for ATm protocols
+ *
+ * Revision 1.11  2000/07/28 17:23:39  ilyas
+ * Added ATM connect/disconnect statuses
+ *
+ * Revision 1.10  2000/07/25 02:16:12  ilyas
+ * Added EClip (with Eth to ATM ARP translation) implementation
+ *
+ * Revision 1.9  2000/07/23 20:57:14  ilyas
+ * Added ATM framer and protocol layers
+ *
+ * Revision 1.8  2000/07/17 21:08:16  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.7  2000/06/09 18:33:04  liang
+ * Fixed Irix compiler warnings.
+ *
+ * Revision 1.6  2000/05/18 21:47:31  ilyas
+ * Added detection of preassigned cells such as OAM F4, F5
+ *
+ * Revision 1.5  2000/05/14 01:50:11  ilyas
+ * Added more statuses to ATM code
+ *
+ * Revision 1.4  2000/05/10 02:41:28  liang
+ * Added status report for no cell memory
+ *
+ * Revision 1.3  2000/05/09 23:00:27  ilyas
+ * Added ATM status messages, ATM timer, Tx frames flush on timeout
+ * Fixed a bug - adding flushed Tx frames to the list of free Rx frames
+ *
+ * Revision 1.2  2000/05/03 03:53:00  ilyas
+ * Added support for pVc to vcID translation needed for LOG file and other
+ * definitions for ATM data in LOG file
+ *
+ * Revision 1.1  2000/04/19 00:21:35  ilyas
+ * Fixed some problems and added Out Of Band (OOB) support to ATM packets
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	SoftAtmVcHeader
+#define	SoftAtmVcHeader
+
+/*
+**
+**		ATM UNI types
+**
+*/
+
+#define AtmLinkFlags(bMap,name)		(((bMap) >> name##Shift) & name##Mask)
+
+/* ATM service category types */
+
+#define	kAtmSrvcCBR		1	/* Constant Bit Rate	*/
+#define	kAtmSrvcVBR		2	/* Variable Bit Rate	*/
+#define	kAtmSrvcUBR		4	/* Unspecified Bit Rate	*/
+#define	kAtmSrvcABR		8	/* Available Bit Rate	*/
+#define	kAtmSrvcUnknown	0xFF
+
+/* ATM AAL types (as encoded at UNI) */
+
+#define	kAtmAalIE		0x58
+
+#define	kAtmRaw			0
+#define	kAtmAal1		1
+#define	kAtmAal2		2
+#define	kAtmAal34		3
+#define	kAtmAal5		5
+#define	kAtmAalUser		16
+#define	kAtmAalUnknown	0xFF
+
+/* ATM AAL1 parameters  */
+
+#define	kAal1SubTypeId			0x85
+
+#define	kAal1TransportShift		0
+#define	kAal1TransportMask		0x7
+
+#define	kAal1NullTransport		0
+#define	kAal1VoiceTransport		1
+#define	kAal1CircuitTransport	2
+#define	kAal1AudioTransport		4
+#define	kAal1VideoTransport		5
+
+
+#define	kAal1CBRId				0x86
+
+#define	kAal1CBRShift			24
+#define	kAal1CBRMask			0xFF
+
+#define	kAal1CBR64				1
+#define	kAal1CBR1544			4		/* DS1 */
+#define	kAal1CBR6312			5		/* DS2 */
+#define	kAal1CBR32064			6
+#define	kAal1CBR44736			7		/* DS3 */
+#define	kAal1CBR97728			8
+#define	kAal1CBR2048			0x10	/* E1 */
+#define	kAal1CBR8448			0x11	/* E2 */
+#define	kAal1CBR34368			0x12	/* E3 */
+#define	kAal1CBR139264			0x13
+#define	kAal1CBR64xN			0x40
+#define	kAal1CBR8xN				0x41
+
+
+#define	kAal1MultiplierId		0x87
+
+#define	kAal1ClockRecoveryId	0x88
+
+#define	kAal1ClockRecoveryShift	3
+#define	kAal1ClockRecoveryMask	0x3
+
+#define	kAal1ClockRecoveryNull	1		/* synchronous transport */
+#define	kAal1ClockRecoverySRTS	1		/* asynchronous transport */
+#define	kAal1ClockRecoveryAdaptive	2
+
+
+#define	kAal1ECMId				0x89	/* Error correction method */
+
+#define	kAal1ECMShift			(kAal1ClockRecoveryShift + 2)
+#define	kAal1ECMMask			0x3
+
+#define	kAal1ECMNull			0
+#define	kAal1ECMLossSensitive	1
+#define	kAal1ECMDelaySensitive	2
+
+
+#define	kAal1SDTBlockSizeId		0x8A
+
+#define	kAal1CellFillId			0x8B
+
+/* ATM AAL34 and AAL5 parameters  */
+
+#define	kAalFwdMaxSDUSizeId		0x8C
+#define	kAalBacMaxkSDUSizeId	0x81
+
+#define	kAal34MidRangeId		0x82
+
+#define	kAalSSCSTypeId			0x84
+
+#define	kAalSSCSAssured			1
+#define	kAalSSCSNonAssured		2
+#define	kAalSSCSFrameRelay		4
+
+/* ATM AAL2 parameters  */
+
+#define	kAal2SSNone				0
+#define	kAal2SSSAR				1
+#define	kAal2SSTED				2
+#define	kAal2SSSARMask			3
+#define	kAal2SSType1			4
+#define	kAal2SSType3			5
+
+typedef struct {
+  uchar			aalType;
+  union {
+	struct {
+	  bitMap	aal1Flags;
+	  ulong		cbrRate;
+	  ushort	blkSize;
+	  uchar		sarUsed;
+	} aal1Params;
+	struct {
+	  ushort	fwdMaxCpSize;			/* Max "common part" packet size */
+	  ushort	backMaxCpSize;
+	  ushort	cidLow;
+	  ushort	cidHigh;
+	  ushort	fwdMaxSsSize;			/* Max "service specific" packet size */
+	  ushort	backMaxSsSize;
+	  uchar		sscsType;
+	} aal2Params;
+	struct {
+	  ushort	fwdMaxSDUSize;
+	  ushort	backMaxSDUSize;
+	  ushort	midLow;
+	  ushort	midHigh;
+	  uchar		sscsType;
+	} aal34Params;
+	struct {
+	  ushort	fwdMaxSDUSize;
+	  ushort	backMaxSDUSize;
+	  uchar		sscsType;
+	} aal5Params;
+  } param;
+} atmAalParams;
+
+/* ATM Traffic Descriptor types (as encoded at UNI) */
+
+#define	kAtmTrafficIE		0x59
+
+#define	kTrafficFwdPeakCellRateId0	0x82
+#define	kTrafficBackPeakCellRateId0	0x83
+#define	kTrafficFwdPeakCellRateId	0x84
+#define	kTrafficBackPeakCellRateId	0x85
+
+#define	kTrafficFwdSustainCellRateId0	0x88
+#define	kTrafficBackSustainCellRateId0	0x89
+#define	kTrafficFwdSustainCellRateId	0x90
+#define	kTrafficBackSustainCellRateId	0x91
+
+#define	kTrafficFwdMaxBurstSizeId0	0xA0
+#define	kTrafficBackMaxBurstSizeId0	0xA1
+#define	kTrafficFwdMaxBurstSizeId	0xB0
+#define	kTrafficBackMaxBurstSizeId	0xB1
+
+#define	kTrafficBestEffortId		0xBE
+#define	kTrafficMgrOptionsId		0xBF
+
+#define	kTrafficMaxTolerance		0x7FFFFFFF
+
+/*	trafficFlags coding */
+
+#define	kTrafficTagFwd				1
+#define	kTrafficTagBack				2
+#define	kTrafficBestEffort			4
+
+typedef struct {
+  ulong			tPCR0;					/* CLP = 0, time between cells in us */
+  ulong			tPCR;					/* CLP = 0+1 */
+  ulong			tolPCR;					/* tolerance for PCR in us */
+
+  ulong			tSCR0;					/* CLP = 0 */
+  ulong			tSCR;					/* CLP = 0+1 */
+  ulong			tolSCR;					/* tolerance for SCR in us */
+
+  uchar			atmServiceType;			/* CBR, VBR, UBR, etc. */
+  uchar			trafficFlags;
+} atmTrafficParams;
+
+/* ATM Broadband Bearer Capabilty (BBC) types (as encoded at UNI) */
+
+#define	kAtmBBCIE			0x5E
+
+#define	kBBCClassShift		0
+#define	kBBCClassMask		0x1F
+
+#define	kBBCClassA			0x1
+#define	kBBCClassC			0x3
+#define	kBBCClassX			0x10
+
+
+#define	kBBCTrafficShift	(kBBCClassShift + 5)
+#define	kBBCTrafficMask		0x7
+
+#define	kBBCTrafficNull		0
+#define	kBBCTrafficCBR		1
+#define	kBBCTrafficVBR		2
+
+
+#define	kBBCTimingShift		(kBBCTrafficShift + 3)
+#define	kBBCTimingMask		0x3
+
+#define	kBBCTimingNull			0
+#define	kBBCTimingRequired		1
+#define	kBBCTimingNotRequired	2
+
+
+#define	kBBCClippingShift	(kBBCTimingShift + 2)
+#define	kBBCClippingMask	0x3
+
+#define	kBBCNoClipping		0
+#define	kBBCClippingOk		1
+
+#define	kBBCConnectionShift	(kBBCClippingShift + 2)
+#define	kBBCConnectionMask	0x3
+
+#define	kBBCPoint2Point		0
+#define	kBBCPoint2MPoint	1
+
+/* ATM Broadband High/Low Layer Information (BHLI/BLLI) types (as encoded at UNI) */
+
+#define	kAtmBHLIIE			0x5D
+#define	kAtmBLLIIE			0x5F
+
+/* ATM QoS types (as encoded at UNI) */
+
+#define	kAtmQoSIE			0x5C
+
+#define	kQoSNull			0
+#define	kQoSClass1			1
+#define	kQoSClass2			2
+#define	kQoSClass3			3
+#define	kQoSClass4			4
+#define	kQoSReserved		0xFF
+
+typedef struct {
+  uchar				fwdQoSClass;
+  uchar				backQoSClass;
+} atmQoSParams;
+
+/* ATM MID definitions (ConfigureHandler) */
+
+#define	kAtmMidEntireVc		((ulong) -1)
+
+typedef struct {
+  void				*pUserVc;			/* VC id from the caller: has to be 1st !!! */
+  ulong				vci;
+  uchar				defaultCLP;			/* default CLP for tx packets on this VC */
+  uchar				framerId;
+  uchar				protoId;
+  uchar				protoRxBytesReserved; /* # bytes reserved by protocol in the beginning of Rx packet */
+  uchar				protoTxBytesReserved; /* # bytes reserved by protocol in the beginning of Tx packet */
+
+  atmAalParams		aalParams;
+  atmTrafficParams	rxTrafficParams;
+  atmTrafficParams	txTrafficParams;
+  bitMap			bbcFlags;
+  atmQoSParams		qosParams;
+} atmVcParams;
+
+/*
+**
+**		ATM Out of Band (OOB) packet information
+**
+*/
+
+typedef struct {
+  Boolean			clp;				/* Cell Loss Prioroty */
+  uchar				aalType;
+  union {
+	struct {
+	  uchar			payloadType;
+	} aalRawParams;
+	struct {
+	  uchar			payloadType;
+	  ushort		mid;
+	} aal34Params;
+	struct {
+	  uchar			uui;				/* Uses to user indicator */
+	  uchar			cpi;				/* common part indicator */
+	} aal5Params;
+  } aalParam;
+} atmOobPacketInfo;
+
+/*
+**
+**		ATM setup bit definition
+**
+*/
+
+#define	kAtmCorrectHecErrors		1
+#define	kCorrectHecErrors			kAtmCorrectHecErrors
+#define	kAtmPhyHeaderCompression	2
+#define	kAtmPhyNoDataScrambling		4
+
+#define	kAtmTxIdleTimeoutMask	0x6
+#define	kAtmTxIdleNoTimeout		0
+#define	kAtmTxIdleTimeout10s	2
+#define	kAtmTxIdleTimeout30s	4
+#define	kAtmTxIdleTimeout60s	6
+
+/*
+**
+**		ATM framer modes and protocol definitions
+**
+*/
+
+#define	kAtmFramerNone			0
+#define	kAtmFramerISO			1
+#define	kAtmFramerIP			2
+#define	kAtmFramerEth			3
+#define	kAtmFramerEthWithCRC	4
+
+#define	kAtmProtoNone			0
+#define	kAtmProtoEClip			1
+#define kAtmProtoERouted1483	2
+#define	kAtmProtoPPP			3
+
+
+/*
+**
+**		ATM status codes
+**
+*/
+
+typedef	void (*atmStatusHandler) (void *gDslVars, ulong statusCode, ...);
+
+/* physical layer I.432 */
+
+#define	kAtmStatRxHunt					1
+#define	kAtmStatRxPreSync				2
+#define	kAtmStatRxSync					3
+#define	kAtmStatRxPlOamCell				4
+#define	kAtmStatBertResult				5
+#define	kAtmStatHec						6
+#define	kAtmStatHdrCompr				7
+#define	kAtmStatCounters				8
+
+/* ATM layer */
+
+#define	kAtmLayerStatFirst				100
+#define	kAtmStatRxDiscarded				100
+#define	kAtmStatTxDelayed				101
+
+#define	kAtmStatVcCreated				102
+#define	kAtmStatVcStarted				103
+#define	kAtmStatVcStopped				104
+#define	kAtmStatVcDeleted				105
+
+#define	kAtmStatTimeout					106
+#define	kAtmStatNoCellMemory			107
+#define	kAtmStatPrintCell				108
+#define kAtmStatInvalidCell				109
+#define kAtmStatUnassignedCell			110
+#define kAtmStatOamF4SegmentCell		111
+#define kAtmStatOamF4End2EndCell		112
+#define kAtmStatOamI371Cell				113
+#define kAtmStatOamF5SegmentCell		114
+#define kAtmStatOamF5End2EndCell		115
+#define kAtmStatReservedCell			116
+
+#define	kAtmStatConnected				117
+#define	kAtmStatDisconnected			118
+
+#define	kAtmStatRxPacket				119
+#define	kAtmStatTxPacket				120
+
+#define	kAtmStatOamLoopback				121
+
+
+typedef struct _atmPhyCounters {
+	ushort						id;
+	ushort						bertStatus;
+	ulong						bertCellTotal;
+	ulong						bertCellCnt;
+	ulong						bertBitErrors;
+
+	ulong						rxHecCnt;
+	ulong						rxCellTotal;
+	ulong						rxCellData;
+	ulong						rxCellDrop;
+} atmPhyCounters;
+
+/* AAL layer */
+
+
+
+/*
+**
+**		ATM log file definitions
+**
+*/
+
+/* ATM log file flags */
+
+#define		kAtmLogFrameFlagMask		3		/* mask */
+
+#define		kAtmLogFrameFlagNone		0		/* nothing */
+#define		kAtmLogFrameFlagNoData		1		/* no data only frame size */
+#define		kAtmLogFrameFlagBinData		2		/* data in binary form */
+#define		kAtmLogFrameFlagTextData	3		/* data in text form */
+
+#define		kAtmLogSendFrameShift		0
+#define		kAtmLogSendFrameNoData		(kAtmLogFrameFlagNoData << kAtmLogSendFrameShift)
+#define		kAtmLogSendFrameBinData		(kAtmLogFrameFlagBinData << kAtmLogSendFrameShift)
+#define		kAtmLogSendFrameTextData	(kAtmLogFrameFlagTextData << kAtmLogSendFrameShift)
+
+#define		kAtmLogRcvFrameShift		2
+#define		kAtmLogRcvFrameNone			(kAtmLogFrameFlagNone << kAtmLogRcvFrameShift)
+#define		kAtmLogRcvFrameNoData		(kAtmLogFrameFlagNoData << kAtmLogRcvFrameShift)
+#define		kAtmLogRcvFrameBinData		(kAtmLogFrameFlagBinData << kAtmLogRcvFrameShift)
+#define		kAtmLogRcvFrameTextData		(kAtmLogFrameFlagTextData << kAtmLogRcvFrameShift)		
+
+#define		kAtmLogSendCompleteFrameShift	4
+#define		kAtmLogSendCompleteFrameNone	(kAtmLogFrameFlagNone << kAtmLogSendCompleteFrameShift)
+#define		kAtmLogSendCompleteFrameNoData	(kAtmLogFrameFlagNoData << kAtmLogSendCompleteFrameShift)
+
+#define		kAtmLogReturnFrameShift		6
+#define		kAtmLogReturnFrameNoData	(kAtmLogFrameFlagNoData << kAtmLogReturnFrameShift)
+
+#define		kAtmLogCellFlag				(1 << 8)
+
+/* ATM log codes */
+
+#define		kAtmLogSendFrame					1
+#define		kAtmLogRcvFrame						2
+#define		kAtmLogSendFrameComplete			3
+#define		kAtmLogReturnFrame					4
+#define		kAtmLogVcAllocate					5
+#define		kAtmLogVcFree						6
+#define		kAtmLogVcActivate					7
+#define		kAtmLogVcDeactivate					8
+#define		kAtmLogTimer						9
+#define		kAtmLogCell							10
+#define		kAtmLogVcConfigure					11
+
+#define		kAtmLogRxCellHeader					12
+#define		kAtmLogRxCellData					13
+#define		kAtmLogTxCell						14
+
+#endif	/* SoftAtmVcHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.gh linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.gh
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.gh	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.gh	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,675 @@
+/****************************************************************************
+ *
+ * SoftDsl.gh 
+ *
+ * Description:
+ *	This is a header file which defines the type for the DSL
+ *	global variable structure.
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.72 $
+ *
+ * $Id: SoftDsl.gh,v 1.72 2004/04/30 23:05:19 kdu Exp $
+ *
+ * $Log: SoftDsl.gh,v $
+ * Revision 1.72  2004/04/30 23:05:19  kdu
+ * Fixed interop issues in TDC lab for TMM.
+ *
+ * Revision 1.70  2004/04/10 23:30:48  ilyas
+ * Defined gloval structure for slow (SDRAM) data
+ *
+ * Revision 1.69  2004/04/02 18:33:45  gsyu
+ * Share MuxFramer buffers with scratch memory
+ *
+ * Revision 1.68  2004/02/04 20:12:38  linyin
+ * Support adsl2plus
+ *
+ * Revision 1.67  2004/02/03 19:10:37  gsyu
+ * Added separated carrierInfo structures for G992P5
+ *
+ * Revision 1.66  2004/01/26 04:21:06  yongbing
+ * Merge changes in ADSL2 branch into Annex A branch
+ *
+ * Revision 1.65  2004/01/13 19:12:07  gsyu
+ * Added two more variables for Double upstream
+ *
+ * Revision 1.64  2003/12/04 02:10:37  linyin
+ * Add a variable for FbmsOL mode
+ *
+ * Revision 1.63  2003/11/20 00:57:50  yongbing
+ * Merge ADSL2 functionalities into Annex A branch
+ *
+ * Revision 1.62  2003/11/05 01:59:12  liang
+ * Add vendor ID code for Infineon.
+ *
+ * Revision 1.61  2003/08/12 22:59:41  khp
+ * - for Haixiang: added support for ADSL_MARGIN_TWEAK_TEST
+ *
+ * Revision 1.60  2003/08/01 00:08:19  liang
+ * Added firmware ID for Samsung ADI 930 DSLAM.
+ *
+ * Revision 1.59  2003/07/14 14:40:08  khp
+ * - AnnexB: added bad SNR2 retrain counter to connectin setup
+ *
+ * Revision 1.58  2003/06/25 02:40:22  liang
+ * Added firmware ID for Annex A UE9000 ADI918 (from Aliant, Canada).
+ *
+ * Revision 1.57  2003/06/25 00:00:40  ilyas
+ * -added firmware IDs for TI 4000C and AC5 (Annex B)
+ *
+ * Revision 1.56  2003/05/31 01:50:38  khp
+ * -add firmware IDs for ECI16 and ECI16A
+ *
+ * Revision 1.55  2003/03/27 19:30:52  liang
+ * Add and initialize new connectionSetup field coVendorFirmwareID under module ADSL_IDENTIFY_VENDOR_FIRMWARE.
+ *
+ * Revision 1.54  2002/12/13 18:35:48  yongbing
+ * Add support for G.992.2 Annex C in start up
+ *
+ * Revision 1.53  2002/12/06 02:06:33  liang
+ * Moved the T1.413 RAck1/RAck2 switching variables to connection setup structure.
+ *
+ * Revision 1.52  2002/11/26 02:49:46  liang
+ * Added variable codingGainDecrement to the connectionSetup structure to solve the C-Rates-RA option failure problem.
+ *
+ * Revision 1.51  2002/10/20 18:56:16  khp
+ * - for linyin:
+ *   - #ifdef NEC_NSIF_WORKAROUND:
+ *     - add status and fail counter for NSIF
+ *
+ * Revision 1.50  2002/09/28 02:36:50  yongbing
+ * Add retrain in T1.413 with R-Ack1 tone
+ *
+ * Revision 1.49  2002/09/12 21:07:19  ilyas
+ * Added HEC, OCD and LCD counters
+ *
+ * Revision 1.48  2002/07/19 01:51:35  liang
+ * Added vendor ID constant for Alcatel.
+ *
+ * Revision 1.47  2002/06/27 21:51:08  liang
+ * Added xmt and rcv tone selection bitmap in connection setup.
+ *
+ * Revision 1.46  2002/06/11 20:48:06  liang
+ * Added CO vendor ID field to connectionSetup structure.
+ *
+ * Revision 1.45  2002/06/06 03:05:43  khp
+ * -use boolean in connectup setup instead of localCapabilities.features to indicate FBM mode
+ *
+ * Revision 1.44  2002/03/22 19:38:58  yongbing
+ * Modify for co-exist of G994P1 and T1P413
+ *
+ * Revision 1.43  2002/03/02 00:52:40  ilyas
+ * AnnexC delay needs to be long for prototype
+ *
+ * Revision 1.42  2002/01/19 23:59:17  ilyas
+ * Added support for LOG and eye data to ADSL core target
+ *
+ * Revision 1.41  2002/01/16 19:03:59  ilyas
+ * Added HOST_ONLY ifdefs around ADSL core data
+ *
+ * Revision 1.40  2002/01/14 17:41:04  liang
+ * Move xmt & rcv sample buffers to top level.
+ *
+ * Revision 1.39  2001/12/21 22:45:34  ilyas
+ * Added support for ADSL MIB data object
+ *
+ * Revision 1.38  2001/12/13 02:24:22  ilyas
+ * Added G997 (Clear EOC and G997 framer) support
+ *
+ * Revision 1.37  2001/11/30 05:56:31  liang
+ * Merged top of the branch AnnexBDevelopment onto top of the tree.
+ *
+ * Revision 1.36  2001/10/19 00:12:07  ilyas
+ * Added support for frame oriented (no ATM) data link layer
+ *
+ * Revision 1.29.2.5  2001/10/03 01:44:00  liang
+ * Merged with codes from main tree (tag SoftDsl_2_18).
+ *
+ * Revision 1.29.2.4  2001/08/18 00:00:36  georgep
+ * Add variable to store annexC pathDelay
+ *
+ * Revision 1.29.2.3  2001/08/08 17:33:27  yongbing
+ * Merge with tag SoftDsl_2_17
+ *
+ * Revision 1.35  2001/08/29 02:56:01  ilyas
+ * Added tests for flattening/unflatenning command and statuses (dual mode)
+ *
+ * Revision 1.34  2001/08/28 03:26:32  ilyas
+ * Added support for running host and adsl core parts separately ("dual" mode)
+ *
+ * Revision 1.33  2001/06/18 19:49:36  ilyas
+ * Changes to include support for HOST_ONLY mode
+ *
+ * Revision 1.32  2001/05/18 21:21:44  liang
+ * Save the current number of rcv samples to line handler for QProc test.
+ *
+ * Revision 1.31  2001/04/25 01:20:11  ilyas
+ *
+ * Don't use DSL frame functions if ATM_LAYER is not defined
+ *
+ * Revision 1.30  2001/03/25 06:11:20  liang
+ * Combined separate loop attenuation status for ATUR & ATUC into one status.
+ * Replace separate hardware AGC info status for ATUR & ATUC into hardware AGC
+ * request status and hardware AGC obtained status.
+ * Use store AGC command to save hardware AGC value instead of returning value
+ * from status report.
+ *
+ * Revision 1.29  2001/03/17 03:00:46  georgep
+ * Added agcInfo to connectionSetupStruct
+ *
+ * Revision 1.28  2001/02/10 03:03:09  ilyas
+ * Added one more DslFrame function
+ *
+ * Revision 1.27  2000/08/31 19:04:24  liang
+ * Added scratch buffer structure definition.
+ *
+ * Revision 1.26  2000/07/23 20:52:52  ilyas
+ * Added xxxFrameBufSetAddress() function for ATM framer layers
+ * Rearranged linkLayer functions in one structure which is passed as a
+ * parameter to xxxLinkLayerInit() function to be set there
+ *
+ * Revision 1.25  2000/07/18 21:42:25  ilyas
+ * Fixed compiler warning about pointer casting
+ *
+ * Revision 1.24  2000/07/18 21:18:45  ilyas
+ * Added GLOBAL_PTR_BIAS feature to utilize full 64K MIPS relative addressing space
+ *
+ * Revision 1.23  2000/07/18 20:03:24  ilyas
+ * Changed DslFrame functions definitions to macros,
+ * Removed gDslVars from their parameter list
+ *
+ * Revision 1.22  2000/07/17 21:08:15  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.21  2000/05/09 23:00:26  ilyas
+ * Added ATM status messages, ATM timer, Tx frames flush on timeout
+ * Fixed a bug - adding flushed Tx frames to the list of free Rx frames
+ *
+ * Revision 1.20  2000/05/03 03:57:04  ilyas
+ * Added LOG file support for writing ATM data
+ *
+ * Revision 1.19  2000/04/19 00:31:47  ilyas
+ * Added global SoftDsl functions for Vc, added OOB info functions
+ *
+ * Revision 1.18  2000/04/13 08:36:22  yura
+ * Added SoftDslSetRefData, SoftDslGetRefData functions
+ *
+ * Revision 1.17  2000/04/13 05:38:54  georgep
+ * Added T1p413 "Activation and Acknowledgement" which can substitute G994P1
+ *
+ * Revision 1.16  2000/04/05 22:30:42  liang
+ * Changed function & constant names from G992p2 to G992 for the Main module.
+ *
+ * Revision 1.15  2000/04/04 04:16:06  liang
+ * Merged with SoftDsl_0_03 from old tree.
+ *
+ * Revision 1.15  2000/04/04 01:47:21  ilyas
+ * Implemented abstract dslFrame and dslFrameBuffer objects
+ *
+ * Revision 1.14  2000/04/01 02:53:33  georgep
+ * Added pointer to G992p2Profile inside connectionSetup
+ *
+ * Revision 1.13  2000/03/18 01:27:56  georgep
+ * Changed connectionSetup to include G992p1 Capabilities
+ *
+ * Revision 1.12  2000/02/29 01:39:05  georgep
+ * put variable haveRemoteCapabilities inside connectionSetupStruct
+ *
+ * Revision 1.11  2000/02/08 00:44:36  liang
+ * Fix the gDslVars definition for Irix environment.
+ *
+ * Revision 1.10  1999/11/19 00:59:29  george
+ * Define physicalLayerVars as a union
+ *
+ * Revision 1.9  1999/11/11 19:19:42  george
+ * Porting to 16Bit Compiler
+ *
+ * Revision 1.8  1999/11/09 20:26:17  george
+ * Added G992P2_PROFILE to modules list
+ *
+ * Revision 1.7  1999/10/27 23:01:54  wan
+ * Add G.994.1 setup in dslConnectionSetupStruct for setting up Initiation side
+ *
+ * Revision 1.6  1999/08/12 21:16:27  george
+ * Move profileVars definition to G992p2/G992p2Profile.gh
+ *
+ * Revision 1.5  1999/08/10 18:20:43  george
+ * Define fastRetrainVars
+ *
+ * Revision 1.4  1999/07/16 02:03:02  liang
+ * Added Tx & Rx data handler function pointers.
+ *
+ * Revision 1.3  1999/07/03 01:40:15  liang
+ * Redefined dsl command parameter list and added connection setup struct.
+ *
+ * Revision 1.2  1999/02/10 01:56:37  liang
+ * Added hooks for G994.1 and G992.2.
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	SoftDslGlobals
+#define	SoftDslGlobals
+
+#include "SoftDsl.h"
+
+#ifdef G992P2_PROFILE
+#include "G992p2Profile.gh"
+#endif
+
+typedef enum
+	{
+	kVendorUnknown = 0,
+	kVendorBroadcom,
+	kVendorGlobespan,
+	kVendorADI,
+	kVendorTI,
+	kVendorCentillium,
+	kVendorAlcatel,
+	kVendorInfineon
+	} VendorIDType;
+
+#define	kDslVendorFirwareUnknown	0
+typedef	enum
+	{
+	kVendorADI_Anaconda = 1,
+	kVendorADI_ECI918,
+	kVendorADI_ECI930,
+	kVendorADI_Cisco,
+	kVendorADI_UE9000_918,
+	kVendorADI_Samsung_930,
+	kVendorTI_4000C_ERICSSON_350,
+	kVendorTI_4000C_SEIMENS,
+	kVendorADI_ECI16_AnnexB = 50,		/* leave space for more Annex A types */
+	kVendorADI_ECI16A_AnnexB,
+	kVendorTI_4000C_AnnexB,
+	kVendorTI_AC5_AnnexB
+	} VendorFirmwareIDType;
+
+#define	kDslXmtToneSelectionStartTone		0
+#ifdef G992P1_ANNEX_B
+#define	kDslXmtToneSelectionEndTone			63
+#else
+#define	kDslXmtToneSelectionEndTone			31
+#endif
+#define	kDslXmtToneSelectionNumOfTones		(kDslXmtToneSelectionEndTone-kDslXmtToneSelectionStartTone+1)
+#define	kDslXmtToneSelectionNumOfBytes		((kDslXmtToneSelectionNumOfTones+7)/8)
+#define	kDslRcvToneSelectionStartTone		32
+#define	kDslRcvToneSelectionEndTone			255
+#define	kDslRcvToneSelectionNumOfTones		(kDslRcvToneSelectionEndTone-kDslRcvToneSelectionStartTone+1)
+#define	kDslRcvToneSelectionNumOfBytes		((kDslRcvToneSelectionNumOfTones+7)/8)
+
+#define	kDslT1p413RAckModeTryRAck1				0x01
+#define	kDslT1p413RAckModeTryRAck2				0x02
+#define	kDslT1p413RAckModeTrialMask				0x0F
+#define	kDslT1p413RAckModeSelected				0x10
+#define	kDslT1p413RAckModeTrialCount			10		/* when in trial mode */
+#define	kDslT1p413RAckModeSwitchCount			20		/* when mode is selected */
+
+#ifdef ADSL_MARGIN_TWEAK_TEST
+#define	kDslMarginTweakNumOfTones				256
+#endif
+
+typedef struct
+	{
+	Boolean	                        haveRemoteCapabilities;		
+	dslModulationType				selectedModulation;
+	dslModulationType				startupModulation;
+#if defined(G992P1_ANNEX_I) || defined(G992P5)
+	ushort							downstreamMinCarr, downstreamMaxCarr;
+#else
+	uchar							downstreamMinCarr, downstreamMaxCarr;
+#endif
+	uchar							upstreamMinCarr, upstreamMaxCarr;
+#if defined(DOUBLE_UP_STREAM)							
+    Boolean                         isDoubleUsEnabled;
+    short                           selectedPilotTone;
+#endif
+	dslDataPumpCapabilities			localCapabilities, remoteCapabilities;
+#ifdef G992P3
+	g992p3DataPumpCapabilities		localCarrierInfoG992p3AnnexA;
+	g992p3DataPumpCapabilities		remoteCarrierInfoG992p3AnnexA;
+	g992p3DataPumpCapabilities		selectedCarrierInfoG992p3AnnexA;
+	uchar							xmtG992p3State;
+#ifdef G992P5
+	g992p3DataPumpCapabilities		localCarrierInfoG992p5AnnexA;
+	g992p3DataPumpCapabilities		remoteCarrierInfoG992p5AnnexA;
+	g992p3DataPumpCapabilities		selectedCarrierInfoG992p5AnnexA;
+#endif  /* G992P5 */
+#endif  /* G992P3 */
+	uchar							handshakingDuplexMode;
+	Boolean							handshakingClientInitiation;
+	short							handshakingXmtPowerLevel;
+	uchar							handshakingXmtCarrierSet;
+	short							hwAgcQ4dB;	/* for loop attenuation calculation */
+	uchar							coVendorID;
+#ifdef	ADSL_IDENTIFY_VENDOR_FIRMWARE
+	uchar							coVendorFirmwareID;
+#endif
+	uchar							codingGainDecrement;	/* coding gain decrement in Q4dB for initial rate calculation */
+	uchar							xmtToneSelection[kDslXmtToneSelectionNumOfBytes];
+	uchar							rcvToneSelection[kDslRcvToneSelectionNumOfBytes];
+#ifdef G992_ANNEXC	
+	Boolean							isFbmMode;
+	Boolean							isFbmsOLMode;
+	long							xmtToRcvPathDelay;
+#endif	
+#if defined(T1P413) && defined(XMT_RACT2_FOR_ADI_COMPATIBILITY)
+	uchar							t1p413RAckModeUsed;
+	uchar							t1p413RAckModeCounter;
+#endif
+#ifdef G992P1_ANNEX_B
+	uchar							badSNR2RetrainCounter;
+#endif
+#ifdef ADSL_MARGIN_TWEAK_TEST
+	short							marginTweakExtraPowerQ4dB;
+	char							marginTweakTableQ4dB[kDslMarginTweakNumOfTones];
+#endif
+#ifdef G992P2_PROFILE	
+	G992p2ProfileVarsStruct*		profileVarsPtr;
+#endif
+#ifdef TDC_IOP_FIX_SEIMENS_TI
+	char					t1p413RetrainCounter;		/* 0: no retrain needed; 1: force to T1.413 mode and retrain after R-MSG1; 2: 2nd T1.413 session, go to showtime */
+#endif
+#ifdef ANSI_CACT12_PING_PONG
+    char t1p413SkipToneIndex; /* to alternate between CAct1 and CAct2 detection */
+#endif
+	} dslConnectionSetupStruct;
+
+#ifdef ADSL_FRAMER
+#include "MuxFramer.gh"
+#endif
+
+#ifdef ATM
+#include "SoftAtm.gh"
+#endif
+
+#ifdef DSL_PACKET
+#include "DslPacket.gh"
+#endif
+
+#ifdef G997_1_FRAMER
+#include "G997.gh"
+#ifdef G992P3
+#include "G992p3OvhMsg.gh"
+#endif
+#endif
+
+#ifdef ADSL_MIB
+#include "AdslMib.gh"
+#endif
+
+#ifndef HOST_ONLY
+#ifdef T1P413
+#include "T1p413Main.gh"
+#endif
+
+#ifdef G994P1
+#include "G994p1Main.gh"
+#endif
+
+#ifdef G992
+#include "G992Main.gh"
+#endif
+
+#include "SoftDslSampleBuffers.gh"
+#endif
+
+typedef struct __dslSlowVarsStruct
+	{
+	int								tmp;
+	}
+	 dslSlowVarsStruct;
+
+typedef struct __dslVarsStruct
+	{
+	bitMap							setup;
+	eyeHandlerType					eyeHandlerPtr;
+	logHandlerType					logHandlerPtr;
+	dslDriverCallbackType			driverCallback;
+
+	rcvHandlerType					rcvHandlerPtr;
+	xmtHandlerType					xmtHandlerPtr;
+
+#ifndef ADSLCORE_ONLY
+	dslCommandHandlerType			adslCoreCommandHandlerPtr;
+#endif
+	dslCommandHandlerType			dataPumpCommandHandlerPtr;
+
+	dslStatusHandlerType			internalStatusHandlerPtr;
+	dslStatusHandlerType			externalStatusHandlerPtr;
+#ifndef ADSLCORE_ONLY
+	dslStatusHandlerType			externalLinkLayerStatusHandlerPtr;
+#endif
+
+	dslDirectionType				direction;
+	dslConnectionSetupStruct		connectionSetup;
+
+#ifdef NEC_NSIF_WORKAROUND
+	uchar 					G994NsStatus;
+	uchar 					G994NsFailCounter;
+#endif
+
+	dslFrameHandlerType				rxIndicateHandlerPtr;
+	dslFrameHandlerType				txCompleteHandlerPtr;
+
+	linkLayerFunctions				LinkLayerFunctions;
+	dslSlowVarsStruct				*dslSlowVars;
+
+#ifdef DSL_FRAME_FUNCTIONS
+	dslFrameFunctions				DslFrameFunctions;
+#endif
+	ulong							refData;
+	ulong							execTime;
+	int								currRcvNSamps;
+
+#ifndef HOST_ONLY
+	DslSampleBuffersStruct			sampleBuffersVars;
+
+#ifdef G992P2_PROFILE
+	G992p2ProfileVarsStruct			G992p2ProfileVars;
+#endif
+			
+#ifdef ADSL_FRAMER
+	muxFramerVarsStruct				muxFramerVars;
+#endif
+#endif /* HOST_ONLY */
+
+#ifdef DSL_LINKLAYER
+	union
+		{
+#ifdef ATM
+		atmVarsStruct				atmVars;
+#endif
+#ifdef DSL_PACKET
+		dslPacketVarsStruct			dslPacketVars;
+#endif
+		} linkLayerVars;
+#endif
+
+#ifdef G997_1_FRAMER
+	g997VarsStruct					G997Vars;
+#ifdef G992P3
+	g992p3OvhMsgVarsStruct			G992p3OvhMsgVars;
+#endif
+#endif
+
+#ifdef ADSL_MIB
+	adslMibVarsStruct				adslMibVars;
+#endif
+
+#ifndef HOST_ONLY
+	union
+		{
+#ifdef T1P413
+ 		T1p413VarsStruct			T1p413Vars; 		
+#endif		
+#ifdef G994P1
+		G994p1VarsStruct			G994p1Vars;			
+#endif
+#ifdef G992
+		G992VarsStruct				G992Vars;
+#endif
+		} physicalLayerVars;
+	union
+		{
+#ifdef G992
+		G992ScratchVarsStruct		G992ScratchVars;
+#endif
+#if defined(ADSL_FRAMER) && defined(SHARE_MUX_FRAMER_VARS)
+        muxFramerSharedVarsStruct	muxFramerSharedVars;
+#endif
+		} scratchVars;
+#endif /* HOST_ONLY */
+
+	}
+	 dslVarsStruct;
+
+#ifndef GLOBAL_PTR_BIAS
+#define	gDslGlobalVarPtr			((struct __dslVarsStruct *)gDslVars)
+#define	gDslGlobalSlowVarPtr		(gDslGlobalVarPtr->dslSlowVars)
+#else
+#define	gDslGlobalVarPtr			((struct __dslVarsStruct *) (void*)((uchar*)(gDslVars) - GLOBAL_PTR_BIAS))
+#define	gDslGlobalSlowVarPtr		((struct __dslSlowVarsStruct *) (void*)((uchar*)(gDslGlobalVarPtr->dslSlowVars) - GLOBAL_PTR_BIAS))
+#endif
+
+#define	gDslSampleBuffersVars		(gDslGlobalVarPtr->sampleBuffersVars)
+
+#define	gDslMuxFramerVars			(gDslGlobalVarPtr->muxFramerVars)
+#define	gDslMuxFramerSharedVars		(gDslGlobalVarPtr->scratchVars.muxFramerSharedVars)
+#define	gDslLinkLayerVars			(gDslGlobalVarPtr->linkLayerVars)
+#define	gDslAtmVars					(gDslGlobalVarPtr->linkLayerVars.atmVars)
+#define	gDslPacketVars				(gDslGlobalVarPtr->linkLayerVars.dslPacketVars)
+#define	gG997Vars					(gDslGlobalVarPtr->G997Vars)
+
+#ifdef G992P3
+#define	gG992p3OvhMsgVars			(gDslGlobalVarPtr->G992p3OvhMsgVars)
+#endif
+
+#define	gAdslMibVars				(gDslGlobalVarPtr->adslMibVars)
+
+#define	gT1p413Vars					(gDslGlobalVarPtr->physicalLayerVars.T1p413Vars)
+#define	gG994p1Vars					(gDslGlobalVarPtr->physicalLayerVars.G994p1Vars)
+#define	gG992Vars					(gDslGlobalVarPtr->physicalLayerVars.G992Vars)
+#define gG992p2ProfileVars			(gDslGlobalVarPtr->G992p2ProfileVars)
+
+#define	gG992ScratchVars			(gDslGlobalVarPtr->scratchVars.G992ScratchVars)
+
+#ifndef gEyeHandlerPtr
+#define	gEyeHandlerPtr				(gDslGlobalVarPtr->eyeHandlerPtr)
+#endif
+
+#ifndef gLogHandlerPtr
+#define	gLogHandlerPtr				(gDslGlobalVarPtr->logHandlerPtr)
+#endif
+
+#ifdef VP_SIMULATOR
+#define	gDriverCallback(x)			(gDslGlobalVarPtr->driverCallback)(x)
+#else
+#define	gDriverCallback(x)
+#endif
+
+/*
+**
+**		Frame functions callouts
+**
+*/
+
+#define	gDslFrameFunc				(gDslGlobalVarPtr->DslFrameFunctions)
+
+#define	DslFrameBufferGetLength(gDslVars, fb) \
+	gDslFrameFunc.__DslFrameBufferGetLength(fb)
+
+#define DslFrameBufferGetAddress(gDslVars, fb) \
+	gDslFrameFunc.__DslFrameBufferGetAddress(fb)
+
+#define DslFrameBufferSetLength(gDslVars, fb, l) \
+	gDslFrameFunc.__DslFrameBufferSetLength(fb, l)
+
+#define DslFrameBufferSetAddress(gDslVars, fb, p) \
+	gDslFrameFunc.__DslFrameBufferSetAddress(fb, p)
+
+#define DslFrameInit(gDslVars, f) \
+	gDslFrameFunc.__DslFrameInit(f)
+
+#define DslFrameGetLength(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetLength(pFrame)
+
+#define DslFrameGetBufCnt(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetBufCnt(pFrame)
+
+#define DslFrameGetFirstBuffer(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetFirstBuffer(pFrame)
+
+#define DslFrameGetNextBuffer(gDslVars, pFrBuffer) \
+	gDslFrameFunc.__DslFrameGetNextBuffer(pFrBuffer)
+
+#define DslFrameSetNextBuffer(gDslVars, pFrBuf, pFrBufNext) \
+	gDslFrameFunc.__DslFrameSetNextBuffer(pFrBuf, pFrBufNext)
+
+#define DslFrameGetLastBuffer(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameGetLastBuffer(pFrame)
+
+#define DslFrameGetLinkFieldAddress(gDslVars, f) \
+	gDslFrameFunc.__DslFrameGetLinkFieldAddress(f)
+
+#define DslFrameGetFrameAddressFromLink(gDslVars, lnk) \
+	gDslFrameFunc.__DslFrameGetFrameAddressFromLink(lnk)
+
+
+#define DslFrameGetOobInfo(gDslVars, f, pOobInfo) \
+	gDslFrameFunc.__DslFrameGetOobInfo(f, pOobInfo)
+
+#define DslFrameSetOobInfo(gDslVars, f, pOobInfo) \
+	gDslFrameFunc.__DslFrameSetOobInfo(f, pOobInfo)
+
+
+#define DslFrameEnqueBufferAtBack(gDslVars, f, b) \
+	gDslFrameFunc.__DslFrameEnqueBufferAtBack(f, b)
+
+#define DslFrameEnqueFrameAtBack(gDslVars, fMain, f) \
+	gDslFrameFunc.__DslFrameEnqueFrameAtBack(fMain, f)
+
+#define DslFrameEnqueBufferAtFront(gDslVars, f, b) \
+	gDslFrameFunc.__DslFrameEnqueBufferAtFront(f, b)
+
+#define DslFrameEnqueFrameAtFront(gDslVars, fMain, f) \
+	gDslFrameFunc.__DslFrameEnqueFrameAtFront(fMain, f)
+
+#define DslFrameDequeBuffer(gDslVars, pFrame) \
+	gDslFrameFunc.__DslFrameDequeBuffer(pFrame)
+
+#define DslFrameAllocMemForFrames(gDslVars, frameNum) \
+	gDslFrameFunc.__DslFrameAllocMemForFrames(frameNum)
+
+#define DslFrameFreeMemForFrames(gDslVars, hMem) \
+	gDslFrameFunc.__DslFrameFreeMemForFrames(hMem)
+
+#define DslFrameAllocFrame(gDslVars, handle) \
+	gDslFrameFunc.__DslFrameAllocFrame(handle)
+
+#define DslFrameFreeFrame(gDslVars, handle, pFrame) \
+	gDslFrameFunc.__DslFrameFreeFrame(handle, pFrame)
+
+#define DslFrameAllocMemForBuffers(gDslVars, ppMemPool, bufNum, memSize) \
+	gDslFrameFunc.__DslFrameAllocMemForBuffers(ppMemPool, bufNum, memSize)
+
+#define DslFrameFreeMemForBuffers(gDslVars, hMem, memSize, pMemPool) \
+	gDslFrameFunc.__DslFrameFreeMemForBuffers(hMem, memSize, pMemPool)
+
+#define DslFrameAllocBuffer(gDslVars, handle, pMem, length) \
+	gDslFrameFunc.__DslFrameAllocBuffer(handle, pMem, length)
+
+#define DslFrameFreeBuffer(gDslVars, handle, pBuf) \
+	gDslFrameFunc.__DslFrameFreeBuffer(handle, pBuf)
+
+#define DslFrame2Id(gDslVars, handle, pFrame) \
+	gDslFrameFunc.__DslFrame2Id(handle, pFrame)
+
+#define DslFrameId2Frame(gDslVars, handle, frameId) \
+	gDslFrameFunc.__DslFrameId2Frame (handle, frameId)
+
+
+#endif	/* SoftDslGlobals */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftDsl.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,2920 @@
+/****************************************************************************
+ *
+ * SoftDsl.h 
+ *
+ *
+ * Description:
+ *	This file contains the exported interface for SoftDsl.c
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.275 $
+ *
+ * $Id: SoftDsl.h,v 1.275 2005/04/28 22:55:36 ilyas Exp $
+ *
+ * $Log: SoftDsl.h,v $
+ * Revision 1.275  2005/04/28 22:55:36  ilyas
+ * Cleaned up kDslG992RunAnnexaP3ModeInAnnexaP5, kG992EnableAnnexM and kDslAtuChangeTxFilterRequest definitions
+ *
+ * Revision 1.274  2005/04/27 20:57:32  yongbing
+ * Implement 32 frequency break points for TSSI, PR 30211
+ *
+ * Revision 1.273  2005/04/02 03:27:52  kdu
+ * PR30236: Define kDslEnableRoundUpDSLoopAttn, this is shared with kDslCentilliumCRCWorkAroundEnabled.
+ *
+ * Revision 1.272  2005/04/01 21:56:39  ilyas
+ * Added more test commands definitions
+ *
+ * Revision 1.271  2005/02/11 05:03:57  ilyas
+ * Added support for DslOs
+ *
+ * Revision 1.270  2005/02/11 03:33:22  lke
+ * Support 2X, 4X, and 8X spectrum in ANNEX_I DS
+ *
+ * Revision 1.269  2005/01/08 00:11:58  ilyas
+ * Added definition for AnnexL status
+ *
+ * Revision 1.268  2004/12/18 00:52:35  mprahlad
+ * Add Dig US Pwr cutback status
+ *
+ * Revision 1.267  2004/11/08 22:21:38  ytan
+ * init swap state after retrain
+ *
+ * Revision 1.266  2004/11/05 21:16:50  ilyas
+ * Added support for pwmSyncClock
+ *
+ * Revision 1.265  2004/10/28 20:05:17  gsyu
+ * Fixed compilation errors for simulation targets
+ *
+ * Revision 1.264  2004/10/23 00:16:35  nino
+ * Added kDslHardwareSetRcvAGC status to set absolute rcv agc gain.
+ *
+ * Revision 1.263  2004/10/22 21:21:06  ilyas
+ * Fixed bit definition overlap in demodCapabilities
+ *
+ * Revision 1.262  2004/10/20 00:43:20  gsyu
+ * Added constants to support new xmt sample buffer control scheme
+ *
+ * Revision 1.261  2004/10/12 01:09:28  nino
+ * Remove kDslHardwareEnablePwmSyncClk and kDslHardwareSetPwmSyncClkFreq
+ * status definitions. Add kDslEnablePwmSyncClk and kDslSetPwmSyncClkFreq
+ * command definitions.
+ *
+ * Revision 1.260  2004/10/11 20:21:26  nino
+ * Added kDslHardwareEnablePwmSyncClk and kDslHardwareSetPwmSynClkFreq hardware statuses.
+ *
+ * Revision 1.259  2004/10/07 19:17:29  nino
+ * Added kDslHardwareGetRcvAGC status.
+ *
+ * Revision 1.258  2004/10/02 00:17:14  nino
+ * Added kDslHardwareAGCSetPga2 and kDslSetPilotEyeDisplay status definitions.
+ *
+ * Revision 1.257  2004/08/27 01:00:30  mprahlad
+ *
+ * Keep kDslAtuChangeTxFilterRequest defined by default so ADSL1 only targets can
+ * build
+ *
+ * Revision 1.256  2004/08/20 19:00:34  ilyas
+ * Added power management code for 2+
+ *
+ * Revision 1.255  2004/08/17 23:18:25  kdu
+ * Merged interop changes for TDC lab from a023e9.
+ *
+ * Revision 1.254  2004/07/22 00:56:03  yongbing
+ * Add ADSL2 Annex B modulation definition
+ *
+ * Revision 1.253  2004/07/16 22:23:28  nino
+ * - Defined macros to extract subcarrier and supported set information
+ *   for tssi. Subcarrier and suported set indicator is packed into
+ *   dsSubcarrier index array.
+ *
+ * Revision 1.252  2004/07/01 00:11:22  nino
+ * Added preliminary code for debugDataHandler (inside of #if DEBUG_DATA_HANDLER).
+ *
+ * Revision 1.251  2004/06/24 03:08:39  ilyas
+ * Added GFC mapping control for ATM bonding
+ *
+ * Revision 1.250  2004/06/23 00:03:20  khp
+ * - shorten self test result register length to 1 (satisfied requirement
+ *   at DT, no known requirement anywhere else)
+ *
+ * Revision 1.249  2004/06/15 20:18:33  ilyas
+ * Made D uchar again for compatibility with older ADSl drivers that use this structure. ADSL driver will rely on G992p3 parameters for large D
+ *
+ * Revision 1.248  2004/06/12 00:26:03  gsyu
+ * Added constants for AnnexM
+ *
+ * Revision 1.247  2004/06/10 18:53:24  yjchen
+ * add large D support
+ *
+ * Revision 1.246  2004/06/04 01:55:00  linyin
+ * Add a constant for SRA enable/disable
+ *
+ * Revision 1.245  2004/05/19 23:22:23  linyin
+ * Support L2
+ *
+ * Revision 1.244  2004/05/15 03:04:58  ilyas
+ * Added L3 test definition
+ *
+ * Revision 1.243  2004/05/14 03:04:38  ilyas
+ * Fixed structure name typo
+ *
+ * Revision 1.242  2004/05/14 02:01:01  ilyas
+ * Fixed structure name typo
+ *
+ * Revision 1.241  2004/05/14 01:21:49  nino
+ * Added kDslSignalAttenuation, kDslAttainableNetDataRate kDslHLinScale constant definitions.
+ *
+ * Revision 1.240  2004/05/13 19:07:58  ilyas
+ * Added new statuses for ADSL2
+ *
+ * Revision 1.239  2004/05/01 01:09:51  ilyas
+ * Added power management command and statuses
+ *
+ * Revision 1.238  2004/04/23 22:50:38  ilyas
+ * Implemented double buffering to ensure G.997 HDLC frame (OvhMsg) is continuous
+ *
+ * Revision 1.237  2004/03/31 18:57:39  ilyas
+ * Added drop on data error capability control
+ *
+ * Revision 1.236  2004/03/30 03:11:30  ilyas
+ * Added #ifdef for CFE build
+ *
+ * Revision 1.235  2004/03/29 23:06:39  ilyas
+ * Added status for BG table update
+ *
+ * Revision 1.234  2004/03/17 02:49:49  ilyas
+ * Turn off ATM bit reversal for Alcatel DSLAM only
+ *
+ * Revision 1.233  2004/03/11 03:09:48  mprahlad
+ * Add test mode for afeloopback test
+ *
+ * Revision 1.232  2004/03/10 23:15:53  ilyas
+ * Added ETSI modem support
+ *
+ * Revision 1.231  2004/03/04 19:28:14  linyin
+ * Support adsl2plus
+ *
+ * Revision 1.230  2004/02/28 00:06:21  ilyas
+ * Added OLR message definitions for ADSL2+
+ *
+ * Revision 1.229  2004/02/13 03:21:15  mprahlad
+ * define kDslAturHwAgcMaxGain correctly for 6348
+ *
+ * Revision 1.228  2004/02/09 05:06:17  yongbing
+ * Add ADSL2 bit swap function
+ *
+ * Revision 1.227  2004/02/04 02:08:19  linyin
+ * remove the redefined kG992p5AnnexA
+ *
+ * Revision 1.226  2004/02/04 01:41:48  linyin
+ * Add some variables for G992P5
+ *
+ * Revision 1.225  2004/02/03 19:12:22  gsyu
+ * Added a dedicate structure and constants for G992P5
+ *
+ * Revision 1.224  2004/01/24 01:18:34  ytan
+ * add multi-section swapping flag
+ *
+ * Revision 1.223  2004/01/17 00:21:48  ilyas
+ * Added commands and statuses for OLR
+ *
+ * Revision 1.222  2004/01/13 19:12:37  gsyu
+ * Added more constants for Double upstream
+ *
+ * Revision 1.221  2003/12/23 21:19:04  mprahlad
+ * Define BCM6348_TEMP_MOVE_TO_LMEM to FAST_TEXT for 6348 targets - this is for
+ * ADSL2/AnnexA multimode builds - move a few functions to Lmem for now to avoid
+ * changes for swap on 6348.
+ *
+ * Revision 1.220  2003/12/19 21:21:53  ilyas
+ * Added dying gasp support for ADSL2
+ *
+ * Revision 1.219  2003/12/05 02:09:51  mprahlad
+ * Leave the AnalogEC defs in - saves ifdef-ing all uses of these defines.
+ * Include Bcm6345_To_Bcm6348.h - to be able to pick up macros for the
+ * transition
+ *
+ * Revision 1.218  2003/12/04 02:10:58  linyin
+ * Redefine some constants for supporting different pilot and TTR
+ *
+ * Revision 1.217  2003/12/03 02:24:39  gsyu
+ * Reverse previous check in for Double Upstream demo
+ *
+ * Revision 1.215  2003/11/20 00:58:47  yongbing
+ * Merge ADSL2 functionalities into Annex A branch
+ *
+ * Revision 1.214  2003/11/06 00:35:06  nino
+ * Added kDslWriteAfeRegCmd and kDslReadAfeRegCmd commands.
+ *
+ * Revision 1.213  2003/11/05 21:04:23  ilyas
+ * Added more codes for LOG data
+ *
+ * Revision 1.212  2003/10/22 00:51:52  yjchen
+ * define constant for quiet line noise
+ *
+ * Revision 1.211  2003/10/20 22:08:57  nino
+ * Added kDslSetRcvGainCmd and kDslBypassRcvHpfCmd debug commands.
+ *
+ * Revision 1.210  2003/10/18 00:04:59  yjchen
+ * define constants for G992P3 diagnostic mode channel response
+ *
+ * Revision 1.209  2003/10/17 22:41:29  yongbing
+ * Add INP message support
+ *
+ * Revision 1.208  2003/10/16 00:06:09  uid1249
+ * Moved G.994 definitions from G.994p1MainTypes.h
+ *
+ * Revision 1.207  2003/10/15 20:45:11  linyin
+ * Add some constants for support Revision 2
+ *
+ * Revision 1.206  2003/10/14 22:04:02  ilyas
+ * Added Nino's AFE statuses for 6348
+ *
+ * Revision 1.205  2003/10/10 18:49:26  gsyu
+ * Added test modes to workaround the clock domain crossing bug, PR18038
+ *
+ * Revision 1.204  2003/09/30 19:27:46  mprahlad
+ * ifdef AnalogEC definies with #ifndef BCM6348_SRC
+ *
+ * Revision 1.203  2003/09/26 19:36:34  linyin
+ * Add annexi constant and vars
+ *
+ * Revision 1.202  2003/09/25 20:16:13  yjchen
+ * remove featureNTR definition
+ *
+ * Revision 1.201  2003/09/08 20:29:51  ilyas
+ * Added test commands for chip regression tests
+ *
+ * Revision 1.200  2003/08/26 00:58:14  ilyas
+ * Added I432 reset command (for header compression)
+ * Fixed SoftDsl time (for I432 header compression)
+ *
+ * Revision 1.199  2003/08/26 00:37:29  ilyas
+ * #ifdef'ed DslFrameFunctions in dslCommand structure to save space
+ *
+ * Revision 1.198  2003/08/22 22:45:00  liang
+ * Change the NF field in G992CodingParams from uchar to ushort to support K=256 (dataRate=255*32kbps) in fast path.
+ *
+ * Revision 1.197  2003/08/21 21:19:05  ilyas
+ * Changed dataPumpCapabilities structure for G992P3
+ *
+ * Revision 1.196  2003/08/12 22:44:28  khp
+ * - for Haixiang: added kDslTestMarginTweak command and marginTweakSpec
+ *
+ * Revision 1.195  2003/07/24 17:28:16  ovandewi
+ * added Tx filter change request code
+ *
+ * Revision 1.194  2003/07/24 15:48:55  yongbing
+ * Reduce TSSI buffer size to avoid crash at the beginning of G.994.1. Need to find out why
+ *
+ * Revision 1.193  2003/07/19 07:11:47  nino
+ * Revert back to version 1.191.
+ *
+ * Revision 1.191  2003/07/17 21:25:25  yongbing
+ * Add support for READSL2 and TSSI
+ *
+ * Revision 1.190  2003/07/14 19:42:33  yjchen
+ * add constants for G992P3
+ *
+ * Revision 1.189  2003/07/10 23:07:11  liang
+ * Add demodCapability bit to minimize showtime ATUC xmt power through b&g table.
+ *
+ * Revision 1.188  2003/07/08 22:18:50  liang
+ * Added demodCapability bit for G.994.1 Annex A multimode operation.
+ *
+ * Revision 1.187  2003/07/07 23:24:43  ilyas
+ * Added G.dmt.bis definitions
+ *
+ * Revision 1.186  2003/06/25 02:44:02  liang
+ * Added demod capability bit kDslUE9000ADI918FECFixEnabled.
+ * Added back kDslHWEnableAnalogECUpdate & kDslHWEnableAnalogEC for backward compatibility (annex A).
+ *
+ * Revision 1.185  2003/06/18 01:39:19  ilyas
+ * Added AFE test commands. Add #defines for driver's builds
+ *
+ * Revision 1.184  2003/06/06 23:58:09  ilyas
+ * Added command and status for standalone AFE tests
+ *
+ * Revision 1.183  2003/05/29 21:09:32  nino
+ * - kDslHWEnableAnalogECUpdate define replaced with kDslHWSetDigitalEcUpdateMode
+ * - kDslHWEnableAnalogEC       define replaced with kDslHWDisableDigitalECUpdate
+ *
+ * Revision 1.182  2003/04/15 22:08:15  liang
+ * Changed one of the demodCapability bit name from last checkin.
+ *
+ * Revision 1.181  2003/04/13 19:25:54  liang
+ * Added three more demodCapability bits.
+ *
+ * Revision 1.180  2003/04/02 02:09:17  liang
+ * Added demodCapability bit for ADI low rate option fix disable.
+ *
+ * Revision 1.179  2003/03/18 18:22:06  yongbing
+ * Use 32 tap TEQ for Annex I
+ *
+ * Revision 1.178  2003/03/06 00:58:07  ilyas
+ * Added SetStausBuffer command
+ *
+ * Revision 1.177  2003/02/25 00:46:26  ilyas
+ * Added T1.413 EOC vendor ID
+ *
+ * Revision 1.176  2003/02/21 23:30:54  ilyas
+ * Added Xmtgain command framing mode status and T1413VendorId parameters
+ *
+ * Revision 1.175  2003/02/07 22:13:55  liang
+ * Add demodCapabilities bits for sub-sample alignment and higher T1.413 level (used internally only).
+ *
+ * Revision 1.174  2003/01/23 02:54:07  liang
+ * Added demod capability bit for bitswap enable.
+ *
+ * Revision 1.173  2002/12/13 18:36:33  yongbing
+ * Add support for G.992.2 Annex C
+ *
+ * Revision 1.172  2002/12/10 23:27:12  ilyas
+ * Extended dslException parameter structure to allow printout from DslDiags
+ *
+ * Revision 1.171  2002/12/06 02:10:19  liang
+ * Moved the T1.413 RAck1/RAck2 switching variables to connection setup structure.
+ * Added/Modified the training progress codes for T1.413 RAck1/RAck2 and upstream 2x IFFT disable.
+ *
+ * Revision 1.170  2002/11/11 00:20:05  liang
+ * Add demod capability constant for internally disabling upstream 2x IFFT in T1.413 mode.
+ *
+ * Revision 1.169  2002/11/06 03:46:19  liang
+ * Add training progress code for upstream 2x IFFT disable.
+ *
+ * Revision 1.168  2002/11/01 01:41:06  ilyas
+ * Added flags for Centillium 4103 workarround
+ *
+ * Revision 1.167  2002/10/26 01:26:11  gsyu
+ * Move SoftDslLineHandler from SDRAM to LMEM
+ *
+ * Revision 1.166  2002/10/20 18:56:20  khp
+ * - for linyin
+ *   - #ifdef NEC_NSIF_WORKAROUND:
+ *     - add macros to extract NSIF status and fail counter vars
+ *
+ * Revision 1.165  2002/10/14 05:24:35  liang
+ * Add training status code to request alternate xmt filter (for Samsung 6-port ADI918 DSLAMs) to meet KT 2km spec.
+ *
+ * Revision 1.164  2002/10/08 21:44:50  ilyas
+ * Fixed EOC stuffing byte to indicate "no synchronization" action
+ *
+ * Revision 1.163  2002/10/03 19:34:24  ilyas
+ * Added size for EOC serial number register
+ *
+ * Revision 1.162  2002/09/28 02:42:27  yongbing
+ * Add retrain in T1.413 with R-Ack1 tone
+ *
+ * Revision 1.161  2002/09/28 01:23:35  gsyu
+ * Reverse us2xifft change so that we can install new us2xifft on the tree
+ *
+ * Revision 1.160  2002/09/26 23:30:48  yongbing
+ * Add synch symbol detection in Showtime
+ *
+ * Revision 1.159  2002/09/20 23:47:52  khp
+ * - for gsyu: enable 2X IFFT for Annex A (XMT_FFT_SIZE_2X)
+ *
+ * Revision 1.158  2002/09/14 03:26:39  ilyas
+ * Changed far-end RDI reporting
+ *
+ * Revision 1.157  2002/09/13 21:10:54  ilyas
+ * Added reporting of remote modem LOS and RDI.
+ * Moved G992CodingParams definition to SoftDsl.h
+ *
+ * Revision 1.156  2002/09/12 21:07:19  ilyas
+ * Added HEC, OCD and LCD counters
+ *
+ * Revision 1.155  2002/09/09 21:31:30  linyin
+ * Add two constant to support long reach
+ *
+ * Revision 1.154  2002/09/07 01:31:51  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.153  2002/09/04 22:36:14  mprahlad
+ * defines for non standard info added
+ *
+ * Revision 1.152  2002/08/02 21:59:09  liang
+ * Enable G.992.2 carrierInfo in capabitilities when G.992.1 annex A is used for G.992.2.
+ *
+ * Revision 1.151  2002/07/29 20:01:03  ilyas
+ * Added command for Atm VC map table change
+ *
+ * Revision 1.150  2002/07/18 22:30:47  liang
+ * Add xmt power and power cutback related constants.
+ *
+ * Revision 1.149  2002/07/11 01:30:58  ilyas
+ * Changed status for ShowtimeMargin reporting
+ *
+ * Revision 1.148  2002/07/09 19:19:09  ilyas
+ * Added status parameters for ShowtimeSNRMargin info and command to filter
+ * out SNR margin data
+ *
+ * Revision 1.147  2002/06/27 21:50:24  liang
+ * Added test command related demodCapabilities bits.
+ *
+ * Revision 1.146  2002/06/26 21:29:00  liang
+ * Added dsl test cmd structure and showtime margin connection info status.
+ *
+ * Revision 1.145  2002/06/15 05:15:51  ilyas
+ * Added definitions for Ping, Dying Gasp and other test commands
+ *
+ * Revision 1.144  2002/05/30 19:55:15  ilyas
+ * Added status for ADSL PHY MIPS exception
+ * Changed conflicting definition for higher rates (S=1/2)
+ *
+ * Revision 1.143  2002/05/21 23:41:07  yongbing
+ * First check-in of Annex C S=1/2 codes
+ *
+ * Revision 1.142  2002/04/29 22:25:09  georgep
+ * Merge from branch annexC_demo - add status message constants
+ *
+ * Revision 1.141  2002/04/18 19:00:35  ilyas
+ * Added include file for builds in CommEngine environment
+ *
+ * Revision 1.140  2002/04/18 00:18:36  yongbing
+ * Add detailed timeout error messages
+ *
+ * Revision 1.139  2002/04/02 10:03:18  ilyas
+ * Merged BERT from AnnexA branch
+ *
+ * Revision 1.138  2002/03/26 01:42:29  ilyas
+ * Added timeout message constants for annex C
+ *
+ * Revision 1.137  2002/03/22 19:39:22  yongbing
+ * Modify for co-exist of G994P1 and T1P413
+ *
+ * Revision 1.136  2002/03/22 01:19:40  ilyas
+ * Add status message constants for total FEXT Bits, NEXT bits
+ *
+ * Revision 1.135  2002/03/10 22:32:24  liang
+ * Added report constants for LOS recovery and timing tone index.
+ *
+ * Revision 1.134  2002/03/07 22:06:32  georgep
+ * Replace ifdef G992P1 with G992P1_ANNEX_A for annex A variables
+ *
+ * Revision 1.133  2002/02/16 01:08:18  georgep
+ * Add log constant for showtime mse
+ *
+ * Revision 1.132  2002/02/08 04:36:27  ilyas
+ * Added commands for LOG file and fixed Idle mode pointer update
+ *
+ * Revision 1.131  2002/01/24 20:21:30  georgep
+ * Add logging defines, remove fast retrain defines
+ *
+ * Revision 1.130  2002/01/19 23:59:17  ilyas
+ * Added support for LOG and eye data to ADSL core target
+ *
+ * Revision 1.129  2002/01/16 23:43:54  liang
+ * Remove the carriage return character from last checkin.
+ *
+ * Revision 1.128  2002/01/15 22:27:13  ilyas
+ * Added command for ADSL loopback
+ *
+ * Revision 1.127  2002/01/10 07:18:22  ilyas
+ * Added status for printf (mainly for ADSL core debugging)
+ *
+ * Revision 1.126  2001/12/21 22:45:34  ilyas
+ * Added support for ADSL MIB data object
+ *
+ * Revision 1.125  2001/12/13 02:24:22  ilyas
+ * Added G997 (Clear EOC and G997 framer) support
+ *
+ * Revision 1.124  2001/11/30 05:56:31  liang
+ * Merged top of the branch AnnexBDevelopment onto top of the tree.
+ *
+ * Revision 1.123  2001/11/15 19:01:07  yongbing
+ * Modify only T1.413 part to the top of tree based on AnnexBDevelopment branch
+ *
+ * Revision 1.122  2001/10/19 00:12:07  ilyas
+ * Added support for frame oriented (no ATM) data link layer
+ *
+ * Revision 1.121  2001/10/09 22:35:13  ilyas
+ * Added more ATM statistics and OAM support
+ *
+ * Revision 1.105.2.20  2001/11/27 02:32:03  liang
+ * Combine vendor ID, serial #, and version number into SoftModemVersionNumber.c.
+ *
+ * Revision 1.105.2.19  2001/11/21 01:29:14  georgep
+ * Add a status message define for annexC
+ *
+ * Revision 1.105.2.18  2001/11/08 23:26:28  yongbing
+ * Add carrier selection function for Annex A and B
+ *
+ * Revision 1.105.2.17  2001/11/07 22:55:30  liang
+ * Report G992 rcv msg CRC error as what it is instead of time out.
+ *
+ * Revision 1.105.2.16  2001/11/05 19:56:21  liang
+ * Add DC offset info code.
+ *
+ * Revision 1.105.2.15  2001/10/16 00:47:16  yongbing
+ * Add return-to-T1p413 starting point if in error
+ *
+ * Revision 1.105.2.14  2001/10/15 23:14:01  yjchen
+ * remove ADSL_SINGLE_SYMBOL_BLOCK
+ *
+ * Revision 1.105.2.13  2001/10/12 18:07:16  yongbing
+ * Add support for T1.413
+ *
+ * Revision 1.105.2.12  2001/10/04 00:23:52  liang
+ * Add connection info constants for TEQ coef and PSD.
+ *
+ * Revision 1.105.2.11  2001/10/03 01:44:01  liang
+ * Merged with codes from main tree (tag SoftDsl_2_18).
+ *
+ * Revision 1.105.2.10  2001/09/28 22:10:04  liang
+ * Add G994 exchange message status reports.
+ *
+ * Revision 1.105.2.9  2001/09/26 18:08:21  georgep
+ * Send status error message in case features field is not setup properly
+ *
+ * Revision 1.105.2.8  2001/09/05 01:58:13  georgep
+ * Added status message for annexC measured delay
+ *
+ * Revision 1.105.2.7  2001/08/29 00:37:52  georgep
+ * Add log constants for annexC
+ *
+ * Revision 1.105.2.6  2001/08/18 00:01:34  georgep
+ * Add constants for annexC
+ *
+ * Revision 1.105.2.5  2001/08/08 17:33:28  yongbing
+ * Merge with tag SoftDsl_2_17
+ *
+ * Revision 1.120  2001/08/29 02:56:01  ilyas
+ * Added tests for flattening/unflatenning command and statuses (dual mode)
+ *
+ * Revision 1.119  2001/08/28 03:26:32  ilyas
+ * Added support for running host and adsl core parts separately ("dual" mode)
+ *
+ * Revision 1.118  2001/08/16 02:16:10  khp
+ * - mark functions with FAST_TEXT to reduce cycle counts for QPROC targets
+ *   (replaces use of LMEM_INSN)
+ *
+ * Revision 1.117  2001/06/18 20:06:35  ilyas
+ * Added forward declaration of dslCommandStruc to avoid gcc warnings
+ *
+ * Revision 1.116  2001/06/18 19:49:36  ilyas
+ * Changes to include support for HOST_ONLY mode
+ *
+ * Revision 1.115  2001/06/01 22:00:33  ilyas
+ * Changed ATM PHY interface to accomodate UTOPIA needs
+ *
+ * Revision 1.114  2001/05/16 06:22:24  liang
+ * Added status reports for xmt & rcv prefix enable position.
+ *
+ * Revision 1.113  2001/05/02 20:34:32  georgep
+ * Added log constants for snr1 calculation
+ *
+ * Revision 1.112  2001/04/25 01:20:11  ilyas
+ *
+ * Don't use DSL frame functions if ATM_LAYER is not defined
+ *
+ * Revision 1.111  2001/04/17 21:13:00  georgep
+ * Define status constant kDslHWSetDigitalEcUpdateShift
+ *
+ * Revision 1.110  2001/04/16 23:38:36  georgep
+ * Add HW AGC constants for ATUR
+ *
+ * Revision 1.109  2001/04/06 23:44:53  georgep
+ * Added status constant for setting up digitalEcGainShift
+ *
+ * Revision 1.108  2001/03/29 05:58:34  liang
+ * Replaced the Aware compatibility codes with automatic detection codes.
+ *
+ * Revision 1.107  2001/03/25 06:11:22  liang
+ * Combined separate loop attenuation status for ATUR & ATUC into one status.
+ * Replace separate hardware AGC info status for ATUR & ATUC into hardware AGC
+ * request status and hardware AGC obtained status.
+ * Use store AGC command to save hardware AGC value instead of returning value
+ * from status report.
+ *
+ * Revision 1.106  2001/03/24 00:43:22  liang
+ * Report more checksum results (NumOfCalls, txSignal, rxSignal & eyeData).
+ *
+ * Revision 1.105  2001/03/16 23:57:31  georgep
+ * Added more loop attenuation reporting status constants
+ *
+ * Revision 1.104  2001/03/15 00:22:07  liang
+ * Back to version 1.101.
+ *
+ * Revision 1.103  2001/03/15 00:03:44  yjchen
+ * use kDslATURHardwareAGCInfo for AltoE14 AGC as well
+ *
+ * Revision 1.102  2001/03/14 23:10:56  yjchen
+ * add defns for AltoE14 AGC
+ *
+ * Revision 1.101  2001/03/08 23:31:34  georgep
+ * Added R, S, D, coding parameters to dslDataPumpCapabilities
+ *
+ * Revision 1.100  2001/02/10 03:03:09  ilyas
+ * Added one more DslFrame function
+ *
+ * Revision 1.99  2001/02/09 01:55:27  ilyas
+ * Added status codes and macros to support printing of AAL packets
+ *
+ * Revision 1.98  2001/01/30 23:28:10  georgep
+ * Added kDslDspControlStatus for handling changes to dsp params
+ *
+ * Revision 1.97  2001/01/12 01:17:18  georgep
+ * Added bit in demodCapabilities for analog echo cancellor
+ *
+ * Revision 1.96  2001/01/04 05:51:03  ilyas
+ * Added more dslStatuses
+ *
+ * Revision 1.95  2000/12/21 05:46:07  ilyas
+ * Added name for struct _dslFrame
+ *
+ * Revision 1.94  2000/12/13 22:04:39  liang
+ * Add Reed-Solomon coding enable bit in demodCapabilities.
+ *
+ * Revision 1.93  2000/11/29 20:42:02  liang
+ * Add defines for SNR & max achivable rate status and DEC enable demodCapabilities bit.
+ *
+ * Revision 1.92  2000/09/22 21:55:13  ilyas
+ * Added support for DSL + Atm physical layer only (I.432) simulations
+ *
+ * Revision 1.91  2000/09/10 09:20:53  lkaplan
+ * Improve interface for sending Eoc messages
+ *
+ * Revision 1.90  2000/09/08 19:37:58  lkaplan
+ * Added code for handling EOC messages
+ *
+ * Revision 1.89  2000/09/07 23:02:27  georgep
+ * Add HarwareAGC Bit to demod Capabilities
+ *
+ * Revision 1.88  2000/09/01 00:57:34  georgep
+ * Added Hardware AGC status defines
+ *
+ * Revision 1.87  2000/08/31 19:04:26  liang
+ * Added external reference for stack size requirement test functions.
+ *
+ * Revision 1.86  2000/08/24 23:16:46  liang
+ * Increased sample block size for noBlock.
+ *
+ * Revision 1.85  2000/08/23 18:34:39  ilyas
+ * Added XxxVcConfigure function
+ *
+ * Revision 1.84  2000/08/05 00:25:04  georgep
+ * Redefine sampling freq constants
+ *
+ * Revision 1.83  2000/08/03 14:04:00  liang
+ * Add hardware time tracking clock error reset code.
+ *
+ * Revision 1.82  2000/07/23 20:52:52  ilyas
+ * Added xxxFrameBufSetAddress() function for ATM framer layers
+ * Rearranged linkLayer functions in one structure which is passed as a
+ * parameter to xxxLinkLayerInit() function to be set there
+ *
+ * Revision 1.81  2000/07/18 20:03:24  ilyas
+ * Changed DslFrame functions definitions to macros,
+ * Removed gDslVars from their parameter list
+ *
+ * Revision 1.80  2000/07/17 21:08:15  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.79  2000/06/21 20:38:44  georgep
+ * Added bit to demodCapabilities for HW_TIME_TRACKING
+ *
+ * Revision 1.78  2000/06/19 19:57:55  georgep
+ * Added constants for logging of HWResampler data
+ *
+ * Revision 1.77  2000/06/02 18:57:21  ilyas
+ * Added support for DSL buffers consisting of many ATM cells
+ *
+ * Revision 1.76  2000/05/27 02:19:28  liang
+ * G992MonitorParams structure is moved here, and Tx/Rx data handler type definitions changed.
+ *
+ * Revision 1.75  2000/05/15 18:17:21  liang
+ * Added statuses for sent and received frames
+ *
+ * Revision 1.74  2000/05/14 01:56:38  ilyas
+ * Added ATM cell printouts
+ *
+ * Revision 1.73  2000/05/09 23:00:26  ilyas
+ * Added ATM status messages, ATM timer, Tx frames flush on timeout
+ * Fixed a bug - adding flushed Tx frames to the list of free Rx frames
+ *
+ * Revision 1.72  2000/05/03 18:01:18  georgep
+ * Removed old function declarations for Eoc/Aoc
+ *
+ * Revision 1.71  2000/05/03 03:57:04  ilyas
+ * Added LOG file support for writing ATM data
+ *
+ * Revision 1.70  2000/05/02 00:04:36  liang
+ * Add showtime monitoring and message exchange info constants.
+ *
+ * Revision 1.69  2000/04/28 23:34:20  yongbing
+ * Add constants for reporting error events in performance monitoring
+ *
+ * Revision 1.68  2000/04/21 23:09:04  liang
+ * Added G992 time out training progress constant.
+ *
+ * Revision 1.67  2000/04/19 00:31:47  ilyas
+ * Added global SoftDsl functions for Vc, added OOB info functions
+ *
+ * Revision 1.66  2000/04/18 00:45:31  yongbing
+ * Add G.DMT new frame structure, define G992P1_NEWFRAME to enable, need ATM layer to work
+ *
+ * Revision 1.65  2000/04/15 01:48:34  georgep
+ * Added T1p413 status constants
+ *
+ * Revision 1.64  2000/04/13 08:36:22  yura
+ * Added SoftDslSetRefData, SoftDslGetRefData functions
+ *
+ * Revision 1.63  2000/04/13 05:42:35  georgep
+ * Added constant for T1p413
+ *
+ * Revision 1.62  2000/04/05 21:49:54  liang
+ * minor change.
+ *
+ * Revision 1.61  2000/04/04 04:16:06  liang
+ * Merged with SoftDsl_0_03 from old tree.
+ *
+ * Revision 1.65  2000/04/04 01:47:21  ilyas
+ * Implemented abstract dslFrame and dslFrameBuffer objects
+ *
+ * Revision 1.64  2000/04/01 08:12:10  yura
+ * Added preliminary revision of the SoftDsl driver architecture
+ *
+ * Revision 1.63  2000/04/01 02:55:33  georgep
+ * New defines for G992p2Profile Structure
+ *
+ * Revision 1.62  2000/04/01 00:50:36  yongbing
+ * Add initial version of new frame structure for full-rate
+ *
+ * Revision 1.61  2000/03/24 03:30:45  georgep
+ * Define new constant kDslUpstreamSamplingFreq
+ *
+ * Revision 1.60  2000/03/23 19:51:30  georgep
+ * Define new features bits for G992p1
+ *
+ * Revision 1.59  2000/03/18 01:28:41  georgep
+ * Changed connectionSetup to include G992p1 Capabilities
+ *
+ * Revision 1.58  2000/02/29 01:40:03  georgep
+ * Changed modulationtype defines to be the same as SPAR1 in G994p1
+ *
+ * Revision 1.57  1999/11/19 01:03:19  george
+ * Use Block Size 256 for single symbol Mode
+ *
+ * Revision 1.56  1999/11/18 02:37:43  george
+ * Porting to 16Bit
+ *
+ * Revision 1.55  1999/11/12 02:12:55  george
+ * Added status constant for reporting of profile channel matching calculation
+ *
+ * Revision 1.54  1999/11/11 19:19:42  george
+ * Porting to 16Bit Compiler
+ *
+ * Revision 1.53  1999/11/05 01:27:06  liang
+ * Add recovery-from-inpulse-noise progress report.
+ *
+ * Revision 1.52  1999/11/02 02:06:27  george
+ * Added SNRMargin training status value
+ *
+ * Revision 1.51  1999/10/27 23:02:03  wan
+ * Add G.994.1 setup in dslConnectionSetupStruct for setting up Initiation side
+ *
+ * Revision 1.50  1999/10/25 21:55:36  liang
+ * Renamed the constant for FEQ output error.
+ *
+ * Revision 1.49  1999/10/23 02:20:55  george
+ * Add debug data codes
+ *
+ * Revision 1.48  1999/10/19 23:59:06  liang
+ * Change line handler interface to work with nonsymmetric sampling freq.
+ *
+ * Revision 1.47  1999/10/09 01:38:04  george
+ * Define maxProfileNumber
+ *
+ * Revision 1.46  1999/10/07 23:30:51  wan
+ * Add G.994.1 Tone and Fast Retrain Recov detections in G.992p2 SHOWTIME and Fast Retrain
+ *
+ * Revision 1.45  1999/10/06 13:59:27  liang
+ * Escape to G994.1 should be done through status instead of command.
+ *
+ * Revision 1.44  1999/10/06 02:01:28  george
+ * Add kDslReturnToG994p1Cmd
+ *
+ * Revision 1.43  1999/09/30 19:29:58  george
+ * Add reporting constant for Fast Retrain
+ *
+ * Revision 1.42  1999/09/16 23:41:56  liang
+ * Added command for host forced retrain.
+ *
+ * Revision 1.41  1999/08/20 00:47:25  wan
+ * Add constants for Fast Retrain progress status
+ *
+ * Revision 1.40  1999/08/16 18:06:01  wan
+ * Add more reporting constants for Fast Retrain
+ *
+ * Revision 1.39  1999/08/12 00:18:10  wan
+ * Add several Fast Retrain Status constants
+ *
+ * Revision 1.38  1999/08/10 18:25:38  george
+ * Define constants used for Fast Retrain
+ *
+ * Revision 1.37  1999/07/31 01:47:43  george
+ * Add status constants for eoc/aoc
+ *
+ * Revision 1.36  1999/07/27 18:19:52  george
+ * declare aoc/eoc functions
+ *
+ * Revision 1.35  1999/07/19 22:44:47  george
+ * Add constants for G994p1 Message Exchange
+ *
+ * Revision 1.34  1999/07/16 02:03:03  liang
+ * Modified Dsl link layer command spec structure.
+ *
+ * Revision 1.33  1999/07/14 22:53:16  george
+ * Add Constants for G994p1
+ *
+ * Revision 1.32  1999/07/13 00:02:26  liang
+ * Added more feature bits.
+ *
+ * Revision 1.31  1999/07/09 01:58:14  wan
+ * Added more constants G.994.1 testing reports
+ *
+ * Revision 1.30  1999/07/07 23:51:04  liang
+ * Added rcv power and loop attenuation reports.
+ *
+ * Revision 1.29  1999/07/06 21:32:01  liang
+ * Added some aux. feature bits, and field performanceMargin was changed to noiseMargin in Capabilities.
+ *
+ * Revision 1.28  1999/07/03 01:40:17  liang
+ * Redefined dsl command parameter list and added connection setup struct.
+ *
+ * Revision 1.27  1999/07/02 00:41:18  liang
+ * Add bit and gain logging as well as rcv carrier range status.
+ *
+ * Revision 1.26  1999/06/25 21:37:10  wan
+ * Work in progress for G994.1.
+ *
+ * Revision 1.25  1999/06/16 00:54:36  liang
+ * Added Tx/Rx SHOWTIME active training progress codes.
+ *
+ * Revision 1.24  1999/06/11 21:59:37  wan
+ * Added G994.1 fail status constant.
+ *
+ * Revision 1.23  1999/06/11 21:29:01  liang
+ * Constants for C/R-Msgs was changed to C/R-Msg.
+ *
+ * Revision 1.22  1999/06/08 02:49:42  liang
+ * Added SNR data logging.
+ *
+ * Revision 1.21  1999/06/07 21:05:08  liang
+ * Added more training status values.
+ *
+ * Revision 1.20  1999/05/22 02:18:26  liang
+ * More constant defines.
+ *
+ * Revision 1.19  1999/05/14 22:49:35  liang
+ * Added more status codes and debug data codes.
+ *
+ * Revision 1.18  1999/04/12 22:41:39  liang
+ * Work in progress.
+ *
+ * Revision 1.17  1999/04/01 20:28:07  liang
+ * Added RReverb detect event status.
+ *
+ * Revision 1.16  1999/03/26 03:29:54  liang
+ * Add DSL debug data constants.
+ *
+ * Revision 1.15  1999/03/08 21:58:00  liang
+ * Added more constant definitions.
+ *
+ * Revision 1.14  1999/03/02 01:49:36  liang
+ * Added more connection info codes.
+ *
+ * Revision 1.13  1999/03/02 00:25:55  liang
+ * Added DSL tx and rx data handler type definitions.
+ *
+ * Revision 1.12  1999/02/27 01:16:55  liang
+ * Increase allowable static memory size to a VERY large number for now.
+ *
+ * Revision 1.11  1999/02/25 00:24:06  liang
+ * Increased symbol block size to 16.
+ *
+ * Revision 1.10  1999/02/23 22:03:26  liang
+ * Increased maximal static memory size allowed.
+ *
+ * Revision 1.9  1999/02/17 02:39:21  ilyas
+ * Changes for NDIS
+ *
+ * Revision 1.8  1999/02/11 22:44:30  ilyas
+ * More definitions for ATM
+ *
+ * Revision 1.7  1999/02/10 01:56:38  liang
+ * Added hooks for G994.1 and G992.2.
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	SoftDslHeader
+#define	SoftDslHeader
+
+/* for builds in Linux/VxWorks CommEngine environment */
+#if (defined(__KERNEL__) && !defined(LINUX_DRIVER)) || defined(VXWORKS) || defined(_WIN32_WCE) || defined(TARG_OS_RTEMS) || defined(_CFE_)
+#include "AdslCoreDefs.h"
+#else
+#include "Bcm6345_To_Bcm6348.h"		/* File for 45->48 changes */
+#endif
+
+#ifndef	SoftModemPh
+#include "SoftModem.h"
+#endif
+
+#ifdef DSL_OS
+#include "DslOs.h"
+#endif
+
+/*
+**
+**		Type definitions 
+**
+*/
+
+#if defined(ATM) || defined(DSL_PACKET)
+#define DSL_LINKLAYER
+#endif
+
+#if defined(ATM_LAYER) || defined(DSL_PACKET_LAYER) || defined(G997_1_FRAMER)
+#define DSL_FRAME_FUNCTIONS
+#endif
+
+#define FLD_OFFSET(type,fld)	((int)(void *)&(((type *)0)->fld))
+
+#include "Que.h"
+#include "SoftAtmVc.h"
+
+typedef struct _dslFrameBuffer
+	{
+	struct _dslFrameBuffer *next;	/* link to the next buffer in the frame */
+	void				   *pData;	/* pointer to data */
+	ulong				   length;	/* size (in bytes) of data */
+	} dslFrameBuffer;
+
+typedef struct _dslFrame
+	{
+	ulong			Reserved[3];
+
+	ulong			totalLength;	/* total amount of data in the packet */
+	int				bufCnt;			/* buffer counter */
+	struct _dslFrameBuffer *head;	/* first buffer in the chain */
+	struct _dslFrameBuffer *tail;	/* last buffer in the chain  */
+	} dslFrame;
+
+
+/* VC types and parameters */
+
+#define	kDslVcAtm		1
+
+typedef	struct
+	{
+	ulong	vcType;
+	union
+		{
+		atmVcParams	atmParams;
+		} params;
+	} dslVcParams;
+
+/*
+**	Assuming that dslVcParams.params is the first field in VC
+**	and RefData is the first field in dslVcParams.params
+*/
+
+#define	DslVcGetRefData(pVc)	(*(void **) (pVc))
+
+/* Frame OOB types */
+
+#define	kDslFrameAtm	1
+
+typedef	struct
+	{
+	ulong	frameType;		
+	union
+		{
+		atmOobPacketInfo	atmInfo;
+		} param;
+	} dslOobFrameInfo;
+
+
+typedef struct
+	{
+	ulong (SM_DECL *__DslFrameBufferGetLength) (dslFrameBuffer *fb);
+	void * (SM_DECL *__DslFrameBufferGetAddress) (dslFrameBuffer *fb);
+	void (SM_DECL *__DslFrameBufferSetLength) (dslFrameBuffer *fb, ulong l);
+	void (SM_DECL *__DslFrameBufferSetAddress) (dslFrameBuffer *fb, void *p);
+
+	void (SM_DECL *__DslFrameInit) (dslFrame *f);
+	ulong (SM_DECL *__DslFrameGetLength) (dslFrame *pFrame);
+	ulong (SM_DECL *__DslFrameGetBufCnt) (dslFrame *pFrame);
+	dslFrameBuffer * (SM_DECL *__DslFrameGetFirstBuffer) (dslFrame *pFrame);
+	dslFrameBuffer * (SM_DECL *__DslFrameGetNextBuffer) (dslFrameBuffer *pFrBuffer);
+	void  (SM_DECL *__DslFrameSetNextBuffer) (dslFrameBuffer *pFrBuf, dslFrameBuffer *pFrBufNext);
+	dslFrameBuffer * (SM_DECL *__DslFrameGetLastBuffer) (dslFrame *pFrame);
+	void * (SM_DECL *__DslFrameGetLinkFieldAddress) (dslFrame *f);
+	dslFrame * (SM_DECL *__DslFrameGetFrameAddressFromLink) (void *lnk);
+
+	Boolean (SM_DECL *__DslFrameGetOobInfo) (dslFrame *f, dslOobFrameInfo	*pOobInfo);
+	Boolean (SM_DECL *__DslFrameSetOobInfo) (dslFrame *f, dslOobFrameInfo	*pOobInfo);
+
+	void (SM_DECL *__DslFrameEnqueBufferAtBack) (dslFrame *f, dslFrameBuffer *b);
+	void (SM_DECL *__DslFrameEnqueFrameAtBack) (dslFrame *fMain, dslFrame *f);
+	void (SM_DECL *__DslFrameEnqueBufferAtFront) (dslFrame *f, dslFrameBuffer *b);
+	void (SM_DECL *__DslFrameEnqueFrameAtFront) (dslFrame *fMain, dslFrame *f);
+	dslFrameBuffer * (SM_DECL *__DslFrameDequeBuffer) (dslFrame *pFrame);
+
+	void * (SM_DECL *__DslFrameAllocMemForFrames) (ulong frameNum);
+	void (SM_DECL *__DslFrameFreeMemForFrames) (void *hMem);
+	dslFrame * (SM_DECL *__DslFrameAllocFrame) (void *handle);
+	void (SM_DECL *__DslFrameFreeFrame) (void *handle, dslFrame *pFrame);
+	void * (SM_DECL *__DslFrameAllocMemForBuffers) (void **ppMemPool, ulong bufNum, ulong memSize);
+	void (SM_DECL *__DslFrameFreeMemForBuffers) (void *hMem, ulong memSize, void *pMemPool);
+	dslFrameBuffer * (SM_DECL *__DslFrameAllocBuffer) (void *handle, void *pMem, ulong length);
+	void (SM_DECL *__DslFrameFreeBuffer) (void *handle, dslFrameBuffer *pBuf);
+
+	/* for LOG file support */
+
+	ulong (SM_DECL *__DslFrame2Id)(void *handle, dslFrame *pFrame);
+	void * (SM_DECL *__DslFrameId2Frame)(void *handle, ulong frameId);
+	} dslFrameFunctions;
+
+#define	 DslFrameDeclareFunctions( name_prefix )								\
+extern ulong SM_DECL name_prefix##BufferGetLength(dslFrameBuffer *fb);			\
+extern void * SM_DECL name_prefix##BufferGetAddress(dslFrameBuffer *fb);		\
+extern void SM_DECL name_prefix##BufferSetLength(dslFrameBuffer *fb, ulong l);	\
+extern void SM_DECL name_prefix##BufferSetAddress(dslFrameBuffer *fb, void *p); \
+																				\
+extern void SM_DECL name_prefix##Init(dslFrame *f);								\
+extern ulong SM_DECL name_prefix##GetLength (dslFrame *pFrame);					\
+extern ulong SM_DECL name_prefix##GetBufCnt(dslFrame *pFrame);					\
+extern dslFrameBuffer * SM_DECL name_prefix##GetFirstBuffer(dslFrame *pFrame);	\
+extern dslFrameBuffer * SM_DECL name_prefix##GetNextBuffer(dslFrameBuffer *pFrBuffer);	\
+extern void SM_DECL name_prefix##SetNextBuffer(dslFrameBuffer *pFrBuf, dslFrameBuffer *pFrBufNext);	\
+extern dslFrameBuffer * SM_DECL name_prefix##GetLastBuffer(dslFrame *pFrame);			\
+extern void * SM_DECL name_prefix##GetLinkFieldAddress(dslFrame *f);					\
+extern Boolean SM_DECL name_prefix##GetOobInfo(dslFrame *f, dslOobFrameInfo *pOobInfo);	\
+extern Boolean SM_DECL name_prefix##SetOobInfo(dslFrame *f, dslOobFrameInfo *pOobInfo);	\
+extern dslFrame* SM_DECL name_prefix##GetFrameAddressFromLink(void *lnk);				\
+extern void SM_DECL name_prefix##EnqueBufferAtBack(dslFrame *f, dslFrameBuffer *b);		\
+extern void SM_DECL name_prefix##EnqueFrameAtBack(dslFrame *fMain, dslFrame *f);		\
+extern void SM_DECL name_prefix##EnqueBufferAtFront(dslFrame *f, dslFrameBuffer *b);	\
+extern void SM_DECL name_prefix##EnqueFrameAtFront(dslFrame *fMain, dslFrame *f);		\
+extern dslFrameBuffer * SM_DECL name_prefix##DequeBuffer(dslFrame *pFrame);				\
+																						\
+extern void * SM_DECL name_prefix##AllocMemForFrames(ulong frameNum);					\
+extern void SM_DECL name_prefix##FreeMemForFrames(void *hMem);							\
+extern dslFrame * SM_DECL name_prefix##AllocFrame(void *handle);						\
+extern void SM_DECL name_prefix##FreeFrame(void *handle, dslFrame *pFrame);				\
+extern void * SM_DECL name_prefix##AllocMemForBuffers(void **ppMemPool, ulong bufNum, ulong memSize);	\
+extern void SM_DECL name_prefix##FreeMemForBuffers(void *hMem, ulong memSize, void *pMemPool);			\
+extern dslFrameBuffer * SM_DECL name_prefix##AllocBuffer(void *handle, void *pMem, ulong length);		\
+extern void SM_DECL name_prefix##FreeBuffer(void *handle, dslFrameBuffer *pBuf);		\
+extern ulong SM_DECL name_prefix##2Id(void *handle, dslFrame *pFrame);					\
+extern void * SM_DECL name_prefix##Id2Frame(void *handle, ulong frameId);
+
+
+#define	 DslFrameAssignFunctions( var, name_prefix )	do {			\
+	(var).__DslFrameBufferGetLength	= name_prefix##BufferGetLength;		\
+	(var).__DslFrameBufferGetAddress= name_prefix##BufferGetAddress;	\
+	(var).__DslFrameBufferSetLength	= name_prefix##BufferSetLength;		\
+	(var).__DslFrameBufferSetAddress= name_prefix##BufferSetAddress;	\
+																		\
+	(var).__DslFrameInit			= name_prefix##Init;				\
+	(var).__DslFrameGetLength		= name_prefix##GetLength;			\
+	(var).__DslFrameGetBufCnt		= name_prefix##GetBufCnt;			\
+	(var).__DslFrameGetFirstBuffer	= name_prefix##GetFirstBuffer;		\
+	(var).__DslFrameGetNextBuffer	= name_prefix##GetNextBuffer;		\
+	(var).__DslFrameSetNextBuffer	= name_prefix##SetNextBuffer;		\
+	(var).__DslFrameGetLastBuffer	= name_prefix##GetLastBuffer;		\
+	(var).__DslFrameGetLinkFieldAddress		= name_prefix##GetLinkFieldAddress;		\
+	(var).__DslFrameGetFrameAddressFromLink	= name_prefix##GetFrameAddressFromLink; \
+																		\
+	(var).__DslFrameGetOobInfo		= name_prefix##GetOobInfo;			\
+	(var).__DslFrameSetOobInfo		= name_prefix##SetOobInfo;			\
+																		\
+	(var).__DslFrameEnqueBufferAtBack	= name_prefix##EnqueBufferAtBack;	\
+	(var).__DslFrameEnqueFrameAtBack	= name_prefix##EnqueFrameAtBack;	\
+	(var).__DslFrameEnqueBufferAtFront= name_prefix##EnqueBufferAtFront;	\
+	(var).__DslFrameEnqueFrameAtFront	= name_prefix##EnqueFrameAtFront;	\
+	(var).__DslFrameDequeBuffer		= name_prefix##DequeBuffer;			\
+																		\
+	(var).__DslFrameAllocMemForFrames	= name_prefix##AllocMemForFrames;	\
+	(var).__DslFrameFreeMemForFrames	= name_prefix##FreeMemForFrames;	\
+	(var).__DslFrameAllocFrame			= name_prefix##AllocFrame;			\
+	(var).__DslFrameFreeFrame			= name_prefix##FreeFrame;			\
+	(var).__DslFrameAllocMemForBuffers= name_prefix##AllocMemForBuffers;	\
+	(var).__DslFrameFreeMemForBuffers = name_prefix##FreeMemForBuffers;	\
+	(var).__DslFrameAllocBuffer		= name_prefix##AllocBuffer;			\
+	(var).__DslFrameFreeBuffer		= name_prefix##FreeBuffer;			\
+																		\
+	(var).__DslFrame2Id				= name_prefix##2Id;					\
+	(var).__DslFrameId2Frame		= name_prefix##Id2Frame;			\
+} while (0)
+
+typedef	struct
+	{
+	Boolean		febe_I;
+	Boolean		fecc_I;
+	Boolean		los, rdi;
+	Boolean		ncd_I;
+	Boolean		hec_I;
+#ifdef G992P3 
+	Boolean		lpr;
+#endif
+
+#ifdef	G992P1_NEWFRAME
+
+	Boolean		febe_F;
+	Boolean		fecc_F;
+	Boolean		ncd_F;
+	Boolean		hec_F;
+	
+#endif
+	} G992MonitorParams;
+
+typedef struct
+	{
+	ushort	K;
+	uchar	S, R;
+	uchar   D;
+#ifdef G992P3 
+	uchar	T, SEQ;
+#endif
+	directionType	direction;
+
+#ifdef		G992P1_NEWFRAME
+
+	ushort	N;
+	ushort	NF;
+	uchar	RSF;
+
+	uchar	AS0BF, AS1BF, AS2BF, AS3BF, AEXAF;
+	ushort	AS0BI;
+	uchar	AS1BI, AS2BI, AS3BI, AEXAI;
+
+	uchar	LS0CF, LS1BF, LS2BF, LEXLF;
+	uchar	LS0CI, LS1BI, LS2BI, LEXLI;
+	
+	uchar	mergedModeEnabled;
+	
+#endif
+
+	} G992CodingParams;
+
+typedef struct
+	{
+	uchar	Nlp;
+	uchar	Nbc;
+	uchar	MSGlp;
+	ushort	MSGc;
+
+	ulong	L;
+	ushort	M;
+	ushort	T;
+	ushort	D;
+	ushort	R;
+	ushort	B;
+	} G992p3CodingParams;
+
+/* Power Management Message definitions (used in command and status) */
+
+typedef struct
+	{
+	long			msgType;
+	union
+		{
+		long		value;
+		struct
+			{
+			long	msgLen;
+			void	*msgData;
+			} msg;
+		} param;
+	} dslPwrMessage;
+
+/* Power Management commands and responses */
+
+#define	kPwrSimpleRequest							1
+#define	kPwrL2Request								2
+#define	kPwrL2TrimRequest							3
+
+#define	kPwrGrant									0x80
+#define	kPwrReject									0x81
+#define	kPwrL2Grant									0x82
+#define	kPwrL2Reject								0x83
+#define	kPwrL2TrimGrant								0x84
+#define	kPwrL2TrimReject							0x85
+#define	kPwrL2Grant2p								0x86
+
+#define	kPwrBusy									0x01
+#define	kPwrInvalid									0x02
+#define	kPwrNotDesired								0x03
+#define	kPwrInfeasibleParam							0x04
+
+/* Power Management reason codes */
+
+/* OLR definitions (used in command and status) */
+
+typedef struct
+	{
+	ushort	msgType;
+	ushort	nCarrs;
+	ushort	L[4];
+	uchar	B[4];
+	void	*carrParamPtr;
+	} dslOLRMessage;
+
+typedef struct
+	{
+	uchar	ind;
+	uchar	gain;
+	uchar	gb;
+	} dslOLRCarrParam;
+
+typedef struct
+	{
+	ushort	ind;
+	uchar	gain;
+	uchar	gb;
+	} dslOLRCarrParam2p;
+
+/* OLR messages */
+
+#define	kOLRRequestType1							1
+#define	kOLRRequestType2							2
+#define	kOLRRequestType3							3
+#define	kOLRRequestType4							4
+#define	kOLRRequestType5							5
+#define	kOLRRequestType6							6
+
+#define	kOLRDeferType1								0x81
+#define	kOLRRejectType2								0x82
+#define	kOLRRejectType3								0x83
+
+/* OLR reason codes */
+
+#define	kOLRBusy									1
+#define	kOLRInvalidParam							2
+#define	kOLRNotEnabled								3
+#define	kOLRNotSupported							4
+
+/* common EOC definitions  */
+#define	kG992EocStuffingByte						0x0C
+
+/* showtime monitor counters */
+#define	kG992ShowtimeRSCodewordsRcved				0	/* number of Reed-Solomon codewords received */
+#define kG992ShowtimeRSCodewordsRcvedOK				1	/* number of Reed-Solomon codewords received with all symdromes zero */
+#define	kG992ShowtimeRSCodewordsRcvedCorrectable	2	/* number of Reed-Solomon codewords received with correctable errors */
+#define	kG992ShowtimeRSCodewordsRcvedUncorrectable	3	/* number of Reed-Solomon codewords received with un-correctable errors */
+#define	kG992ShowtimeSuperFramesRcvd				4	/* number of super frames received */
+#define	kG992ShowtimeSuperFramesRcvdWrong			5	/* number of super frames received with CRC error */
+#define	kG992ShowtimeLastUncorrectableRSCount		6	/* last recorded value for kG992ShowtimeRSCodewordsRcvedUncorrectable */
+#define	kG992ShowtimeLastWrongSuperFrameCount		7	/* last recorded value for kG992ShowtimeSuperFramesRcvdWrong */
+#define	kG992ShowtimeNumOfShortResync				8	/* number of short interrupt recoveries by FEQ */
+
+#define	kG992ShowtimeNumOfFEBE						9	/* number of other side superframe errors */
+#define	kG992ShowtimeNumOfFECC						10	/* number of other side superframe FEC errors */
+#define	kG992ShowtimeNumOfFHEC						11	/* number of far-end ATM header CRC errors */
+#define	kG992ShowtimeNumOfFOCD						12	/* number of far-end OCD events */
+#define	kG992ShowtimeNumOfFLCD						13	/* number of far-end LCD events */
+#define	kG992ShowtimeNumOfHEC						14	/* number of ATM header CRC errors */
+#define	kG992ShowtimeNumOfOCD						15	/* number of OCD events */
+#define	kG992ShowtimeNumOfLCD						16	/* number of LCD events */
+
+#define	kG992ShowtimeNumOfMonitorCounters			(kG992ShowtimeNumOfLCD+1)	/* always last number + 1 */
+#define	kG992ShowtimeMonitorReportNumber			9
+
+#define	kG992ShowtimeLCDNumShift					1
+#define	kG992ShowtimeLCDFlag						1
+
+typedef	int		(SM_DECL *dslFrameHandlerType)	(void *gDslVars, void *pVc, ulong mid, dslFrame *);
+
+typedef	void*   (SM_DECL *dslHeaderHandlerType) (void *gDslVars, ulong hdr, uchar hdrHec);
+typedef	void*	(SM_DECL *dslTxFrameBufferHandlerType)	(void *gDslVars, int*,	void*);
+typedef	void*	(SM_DECL *dslRxFrameBufferHandlerType)	(void *gDslVars, int,	void*);
+
+typedef	void*	(SM_DECL *dslVcAllocateHandlerType)	(void *gDslVars, void *);
+typedef	void	(SM_DECL *dslVcFreeHandlerType)	(void *gDslVars, void *);
+typedef	Boolean	(SM_DECL *dslVcActivateHandlerType)	(void *gDslVars, void *);
+typedef	void	(SM_DECL *dslVcDeactivateHandlerType) (void *gDslVars, void *);
+typedef	Boolean	(SM_DECL *dslVcConfigureHandlerType) (void *gDslVars, void *pVc, ulong mid, void *);
+
+typedef	ulong	(SM_DECL *dslLinkVc2IdHandlerType) (void *gDslVars, void *);
+typedef	void*	(SM_DECL *dslLinkVcId2VcHandlerType) (void *gDslVars, ulong);
+typedef void*	(SM_DECL *dslGetFramePoolHandlerType) (void *gDslVars);
+
+typedef	void	(SM_DECL *dslLinkCloseHandlerType) (void *gDslVars);
+typedef	int		(SM_DECL *dslTxDataHandlerType)(void *gDslVars, int, int, uchar*, G992MonitorParams*);
+typedef	int		(SM_DECL *dslRxDataHandlerType)(void *gDslVars, int, uchar*, G992MonitorParams*);
+
+typedef	void	(SM_DECL *dslLinkStatusHandler) (void *gDslVars, ulong statusCode, ...);
+
+typedef Boolean (SM_DECL *dslPhyInitType) (
+	void						*gDslVars, 
+	bitMap						setupMap,
+	dslHeaderHandlerType		rxCellHeaderHandlerPtr,
+	dslRxFrameBufferHandlerType	rxFrameHandlerPtr,  
+	dslTxFrameBufferHandlerType txFrameHandlerPtr,
+	atmStatusHandler			statusHandlerPtr);
+
+struct _dslFramerBufDesc;
+
+typedef	Boolean (SM_DECL *dslFramerDataGetPtrHandlerType) (void *gDslVars, struct _dslFramerBufDesc *pBufDesc);
+typedef	void	(SM_DECL *dslFramerDataDoneHandlerType) (void *gDslVars, struct _dslFramerBufDesc *pBufDesc);
+
+typedef	void	(SM_DECL *dslDriverCallbackType) (void *gDslVars);
+
+#ifdef DSL_PACKET
+
+typedef	struct 
+	{
+	dslFramerDataGetPtrHandlerType	rxDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	rxDataDoneHandler;
+	dslFramerDataGetPtrHandlerType	txDataGetPtrHandler;
+	dslFramerDataDoneHandlerType	txDataDoneHandler;
+	} dslPacketPhyFunctions;
+
+typedef Boolean (SM_DECL *dslPacketPhyInitType) (
+	void						*gDslVars, 
+	bitMap						setupMap,
+	dslPacketPhyFunctions		dslPhyFunctions,
+	dslLinkStatusHandler		statusHandlerPtr);
+
+
+#endif /* DSL_PACKET */
+
+
+typedef	int			dslDirectionType;
+typedef	bitMap		dslModulationType;
+typedef	bitMap		dslLinkLayerType;
+
+/*
+**
+**		Log data codes 
+**
+*/
+
+#define	kDslEyeData					eyeData
+
+#define	kDslLogComplete				(inputSignalData - 1)
+#define	kDslLogInputData			inputSignalData
+#define	kDslLogInputData1			(inputSignalData + 1)
+#define	kDslLogInputData2			(inputSignalData + 2)
+#define	kDslLogInputData3			(inputSignalData + 3)
+
+/*
+**
+**		Status codes 
+**
+*/
+
+typedef long						dslStatusCode;
+#define	kFirstDslStatusCode			256
+#define	kDslError					(kFirstDslStatusCode + 0)
+#define	kAtmStatus					(kFirstDslStatusCode + 1)
+#define	kDslTrainingStatus			(kFirstDslStatusCode + 2)
+#define	kDslConnectInfoStatus		(kFirstDslStatusCode + 3)
+#define	kDslEscapeToG994p1Status	(kFirstDslStatusCode + 4)
+#define	kDslFrameStatus				(kFirstDslStatusCode + 5)
+#define kDslReceivedEocCommand		(kFirstDslStatusCode + 6)
+#define kDslSendEocCommandDone		(kFirstDslStatusCode + 7)
+#define kDslSendEocCommandFailed	(kFirstDslStatusCode + 8)
+#define kDslWriteRemoteRegisterDone	(kFirstDslStatusCode + 9)
+#define kDslReadRemoteRegisterDone	(kFirstDslStatusCode + 10)
+#define	kDslExternalError			(kFirstDslStatusCode + 11)
+#define kDslDspControlStatus		(kFirstDslStatusCode + 12)
+#define kDslATUHardwareAGCRequest	(kFirstDslStatusCode + 13)
+#define	kDslPacketStatus			(kFirstDslStatusCode + 14)
+#define	kDslG997Status				(kFirstDslStatusCode + 15)
+#define	kDslPrintfStatus			(kFirstDslStatusCode + 16)
+#define	kDslPrintfStatus1			(kFirstDslStatusCode + 17)
+#define	kDslExceptionStatus			(kFirstDslStatusCode + 18)
+#define	kDslPingResponse			(kFirstDslStatusCode + 19)
+#define	kDslShowtimeSNRMarginInfo	(kFirstDslStatusCode + 20)
+#define	kDslGetOemParameter			(kFirstDslStatusCode + 21)
+#define	kDslOemDataAddrStatus		(kFirstDslStatusCode + 22)
+#define	kDslDataAvailStatus			(kFirstDslStatusCode + 23)
+/* #define kDslAtuChangeTxFilterRequest (kFirstDslStatusCode + 24) */
+#define kDslTestPllPhaseResult      (kFirstDslStatusCode + 25)
+#ifdef BCM6348_SRC
+#define kDslHardwareAGCSetPga1      (kFirstDslStatusCode + 26)
+#define kDslHardwareAGCDecPga1      (kFirstDslStatusCode + 27)
+#define kDslHardwareAGCIncPga1      (kFirstDslStatusCode + 28)
+#define kDslHardwareAGCSetPga2Delta (kFirstDslStatusCode + 29)
+#endif
+#define	kDslOLRRequestStatus		(kFirstDslStatusCode + 30)
+#define	kDslOLRResponseStatus		(kFirstDslStatusCode + 31)
+#define	kDslOLRBitGainUpdateStatus	(kFirstDslStatusCode + 32)
+#define	kDslPwrMgrStatus		    (kFirstDslStatusCode + 33)
+#define	kDslEscapeToT1p413Status	(kFirstDslStatusCode + 34)
+#ifdef BCM6348_SRC
+#define kDslHardwareAGCSetPga2      (kFirstDslStatusCode + 35)
+#define kDslHardwareGetRcvAGC       (kFirstDslStatusCode + 36)
+#endif
+#define kDslUpdateXmtReadPtr        (kFirstDslStatusCode + 37)
+#define kDslHardwareSetRcvAGC       (kFirstDslStatusCode + 38)
+#ifdef BCM6348_SRC
+#define kDslSetDigUsPwrCutback      (kFirstDslStatusCode + 39)
+#endif
+
+#define	kClientSideInitiation		0
+#define	kClientSideRespond			1
+#define	kCentralSideInitiation		2
+#define	kCentralSideRespond			3
+
+/* OEM parameter ID definition */
+
+#define	kDslOemG994VendorId			1
+#define	kDslOemG994XmtNSInfo		2
+#define	kDslOemG994RcvNSInfo		3
+#define	kDslOemEocVendorId			4
+#define	kDslOemEocVersion			5
+#define	kDslOemEocSerNum			6
+#define	kDslOemT1413VendorId		7
+#define	kDslOemT1413EocVendorId		8
+
+typedef long	dslErrorCode;
+
+typedef long	atmStatusCode;
+typedef long	dslFramerStatusCode;
+
+typedef long	atmErrorCode;
+
+typedef long	dslTrainingStatusCode;
+
+#define kDslStartedG994p1					0
+#define kDslStartedT1p413HS					1
+
+/* reserved for G.994.1: 1 ~ 8 */
+
+#define	kDslG994p1MessageDet				100
+#define	kDslG994p1ToneDet					101
+#define	kDslG994p1RToneDet					102
+#define	kDslG994p1FlagDet					103
+#define	kDslG994p1GalfDet					104
+#define	kDslG994p1ErrorFrameDet				105
+#define	kDslG994p1BadFrameDet				106
+#define	kDslG994p1SilenceDet				107
+#define	kDslG994p1RcvTimeout				108
+#define	kDslG994p1XmtFinished				109
+#define	kDslG994p1ReturntoStartup			110
+#define	kDslG994p1InitiateCleardown			111
+#define	kDslG994p1StartupFinished			112
+#define	kDslG994p1RcvNonStandardInfo		113
+#define	kDslG994p1XmtNonStandardInfo		114
+
+#define	kG994p1MaxNonstdMessageLength		64
+
+#define kDslFinishedT1p413					1100
+#define kDslT1p413DetectedCTone				1101
+#define kDslT1p413DetectedCAct				1102
+#define kDslT1p413DetectedCReveille			1103
+#define kDslT1p413DetectedRActReq			1104
+#define kDslT1p413DetectedRQuiet1			1105
+#define kDslT1p413DetectedRAct				1106
+#define kDslT1p413TimeoutCReveille			1107
+#define	kDslT1p413ReturntoStartup			1108
+
+#define	kDslG994p1Timeout					8
+#define kDslFinishedG994p1					9
+#define kDslStartedG992p2Training			10
+#define	kDslG992p2DetectedPilotSymbol		11
+#define	kDslG992p2DetectedReverbSymbol		12
+#define	kDslG992p2TEQCalculationDone		13
+#define	kDslG992p2TrainingFEQ				14
+#define	kDslG992p2Phase3Started				15
+#define	kDslG992p2ReceivedRates1			16
+#define	kDslG992p2ReceivedMsg1				17
+#define	kDslG992p2Phase4Started				18
+#define	kDslG992p2ReceivedRatesRA			19
+#define	kDslG992p2ReceivedMsgRA				20
+#define	kDslG992p2ReceivedRates2			21
+#define	kDslG992p2ReceivedMsg2				22
+#define	kDslG992p2ReceivedBitGainTable		23
+#define	kDslG992p2TxShowtimeActive			24
+#define	kDslG992p2RxShowtimeActive			25
+#define	kDslG992p2TxAocMessage				26
+#define	kDslG992p2RxAocMessage				27
+#define	kDslG992p2TxEocMessage				28
+#define	kDslG992p2RxEocMessage				29
+#define kDslFinishedG992p2Training			30
+#define	kDslRecoveredFromImpulseNoise		31
+#define	kDslG992Timeout						32
+#define	kDslT1p413Isu1SglByteSymDetected	33	/* detected T1.413 Issue 1 single byte per symbol mode */
+#define	kDslG992RxPrefixOnInAFewSymbols		34
+#define	kDslG992TxPrefixOnInAFewSymbols		35
+#define	kDslAnnexCXmtCPilot1Starting		36
+#define	kDslXmtToRcvPathDelay				37
+#define kDslFeaturesUnsupported				38
+#define	kDslG992RcvMsgCrcError				39
+#define	kDslAnnexCDetectedStartHyperframe	40
+
+#define kDslG992AnnexCTimeoutCPilot1Detection	41
+#define kDslG992AnnexCTimeoutCReverb1Detection	42
+#define kDslG992AnnexCTimeoutECTraining			43
+#define kDslG992AnnexCTimeoutHyperframeDetector	44
+#define kDslG992AnnexCTimeoutSendRSegue2		45
+#define kDslG992AnnexCTimeoutDetectCSegue1		46
+#define kDslG992AnnexCAlignmentErrDetected		47
+#define kDslG992AnnexCTimeoutSendRSegueRA		48
+#define kDslG992AnnexCTimeoutSendRSegue4		49
+#define kDslG992AnnexCTimeoutCSegue2Detection	50
+#define kDslG992AnnexCTimeoutCSegue3Detection	51
+/* Progress report for fast retrain */
+
+#define	kG994p1EventToneDetected				54
+#define	kDslG992p2RcvVerifiedBitAndGain         55
+#define	kDslG992p2ProfileChannelResponseCalc    56
+#define kDslG992AnnexCTotalFEXTBits				57
+#define kDslG992AnnexCTotalNEXTBits				58
+#define kDslG992AnnexCTotalFEXTCarrs			59
+#define kDslG992AnnexCTotalNEXTCarrs			60
+
+#define	kDslG992p3ReceivedMsgFmt				61
+#define	kDslG992p3ReceivedMsgPcb				62
+
+#define	kDslG992p3AnnexLMode					63
+
+/* performance monitoring report */
+
+#define	kG992DataRcvDetectFastRSCorrection				70
+#define	kG992DataRcvDetectInterleaveRSCorrection		71
+#define	kG992DataRcvDetectFastCRCError					72
+#define	kG992DataRcvDetectInterleaveCRCError			73
+#define	kG992DataRcvDetectFastRSError					74
+#define	kG992DataRcvDetectInterleaveRSError				75
+#define	kG992DataRcvDetectLOS							76
+#define	kG992DecoderDetectRDI							77
+#define	kG992DataRcvDetectLOSRecovery					78
+#define	kG992AtmDetectHEC								79
+#define	kG992AtmDetectOCD								180
+#define	kG992AtmDetectCD								181
+#define	kG992DecoderDetectRemoteLOS						182
+#define	kG992DecoderDetectRemoteLOSRecovery				183
+#define	kG992DecoderDetectRemoteRDI						184
+#define	kG992DecoderDetectRemoteRDIRecovery				185
+#define	kG992RcvDetectSyncSymbolOffset					186
+#define	kG992Upstream2xIfftDisabled						187
+#if defined(G992P5)
+#define	kDslG992RunAnnexaP3ModeInAnnexaP5	   	        188	 /* run Annex C mode in Annex I compiled codes */
+#else
+#define	kDslG992RunAnnexCModeInAnnexI			        188	 /* run Annex C mode in Annex I compiled codes */
+#endif
+
+/* OLR PHY status */
+
+#define	kG992EventSynchSymbolDetected					189
+#define	kG992EventReverseSynchSymbolDetected			190
+#define	kG992EventL2CReverbSymbolDetected				191
+#define	kG992EventL2CSegueSymbolDetected				192
+
+/* ANNEX_M */
+#define kG992EnableAnnexM                               191
+
+#define kDslAtuChangeTxFilterRequest					192
+
+/* detailed error messages reports */
+
+#define	kDslG992XmtRReverbRAOver4000			80
+#define	kDslG992XmtRReverb5Over4000				81
+#define	kDslG992RcvCSegue2Failed				82
+#define	kDslG992RcvCSegueRAFailed				83
+#define	kDslG992RcvCSegue3Failed				84
+#define	kDslG992RcvShowtimeStartedTooLate		85
+#define	kDslG992XmtRReverb3Over4000				86
+#define	kDslG992RcvFailDetCSegue1InWindow		87
+#define	kDslG992RcvCPilot1Failed				88
+#define	kDslG992RcvCReverb1Failed				89
+#define	kG992ControlAllRateOptionsFailedErr		90
+#define	kG992ControlInvalidRateOptionErr		91
+#define	kDslG992XmtInvalidXmtDErr				92
+#define	kDslG992BitAndGainCalcFailed			93
+#define	kDslG992BitAndGainVerifyFailed			94
+
+#define	kDslT1p413RetrainToUseCorrectRAck		95
+#define	kDslUseAlternateTxFilter				96
+#define	kDslT1p413RetrainToUseCorrectIFFT		97
+
+typedef	long	dslConnectInfoStatusCode;
+#define	kG992p2XmtToneOrderingInfo			0
+#define	kG992p2RcvToneOrderingInfo			1
+#define	kG992p2XmtCodingParamsInfo			2
+#define	kG992p2RcvCodingParamsInfo			3
+#define	kG992p2TrainingRcvCarrEdgeInfo		4
+#define	kG992ShowtimeMonitoringStatus		5
+#define	kG992MessageExchangeRcvInfo			6
+#define	kG992MessageExchangeXmtInfo			7
+#define	kG994MessageExchangeRcvInfo			8
+#define	kG994MessageExchangeXmtInfo			9
+
+#define	kDslATURClockErrorInfo				10
+#define	kDslATURcvPowerInfo					11
+#define	kDslATUAvgLoopAttenuationInfo		12
+#define	kDslHWTimeTrackingResetClockError	13
+#define	kDslHWTimeTrackingClockTweak		14
+#define kDslATUHardwareAGCObtained			15
+#define	kDslTEQCoefInfo						16
+#define	kDslRcvCarrierSNRInfo				17
+#define	kDslMaxReceivableBitRateInfo		18
+#define kDslHWSetDigitalEcUpdateMode		19
+#define kDslHWEnableDigitalECUpdate			20
+#define kDslHWDisableDigitalECUpdate 		21
+#define kDslHWEnableDigitalEC				22
+#define kDslHWSetDigitalEcGainShift			23
+#define kDslHWSetDigitalEcUpdateShift		24
+#define	kDslRcvPsdInfo						25
+#define	kDslHWdcOffsetInfo					26
+#define	kG994SelectedG994p1CarrierIndex		27
+#define	kDslSelectedTimingTone				28
+
+#define	kDslHWEnableAnalogECUpdate			kDslHWSetDigitalEcUpdateMode	
+#define	kDslHWEnableAnalogEC				kDslHWDisableDigitalECUpdate
+
+#define	kG992AocMessageExchangeRcvInfo		29
+#define	kG992AocMessageExchangeXmtInfo		30
+#define	kG992AocBitswapTxStarted			31
+#define	kG992AocBitswapRxStarted			32
+#define	kG992AocBitswapTxCompleted			33
+#define	kG992AocBitswapRxCompleted			34
+#define kDslChannelResponseLog				35
+#define kDslChannelResponseLinear			36
+#define kDslChannelQuietLineNoise			37
+
+#define	kDslATUCXmtPowerCutbackInfo			40
+#define	kDslATURXmtPowerCutbackInfo			41
+#define	kDslATUCXmtPowerInfo				42
+#define	kDslATURXmtPowerInfo				43
+
+#define	kDslFramingModeInfo					50
+#define	kDslG992VendorID					51
+
+#ifdef BCM6348_SRC
+#define kDslHWSetRcvFir2OutputScale			52
+#endif
+
+#define kDslSignalAttenuation               53
+#define kDslAttainableNetDataRate           54
+#define kDslHLinScale                       55
+
+#define	kG992p3XmtCodingParamsInfo			60
+#define	kG992p3RcvCodingParamsInfo			61
+#define	kG992p3PwrStateInfo					62
+#define	kG992PilotToneInfo					63
+
+#define kDslSetPilotEyeDisplay              64
+
+#define kDslAturHwAgcResolutionMask			(0xFFFFFFF8)
+#define kDslAturHwAgcMinGain				((-12)<<4)
+#ifndef BCM6348_SRC
+#define kDslAturHwAgcMaxGain				(30<<4)
+#else
+#define kDslAturHwAgcMaxGain				(36<<4)
+#endif
+
+#define	kDslFrameStatusSend					1
+#define	kDslFrameStatusSendComplete			2
+#define	kDslFrameStatusRcv					3
+#define	kDslFrameStatusReturn				4
+
+typedef struct _dslFramerStatus
+	{
+	dslFramerStatusCode		code;
+	union
+		{
+		long				value;
+		dslErrorCode		error;
+		struct
+			{
+			long	length;
+			uchar	*framePtr;
+			} frame;
+		struct
+			{
+			long	nRxFrameTotal;
+			long	nRxFrameError;
+			long	nTxFrameTotal;
+			} statistic;
+		} param;
+	} dslFramerStatus;
+
+typedef	struct
+	{
+	dslStatusCode					code;
+	union
+		{
+		long						value;
+		dslErrorCode				error;
+		struct
+			{
+			atmStatusCode			code;
+			union
+				{
+				long				value;
+				dslErrorCode		error;
+				struct
+					{
+					long	vci;
+					long	mid;
+					long	aalType;
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	vcId;
+					long	vci;
+					long	aalType;
+					ulong   fwdPeakCellTime;
+					ulong   backPeakCellTime;
+					} vcInfo;
+				struct
+					{
+					long	cellHdr;
+					long	oamCmd;
+					} oamInfo;
+				struct 
+					{
+					void	*pVc;
+					char	*pHdr;
+					void	*cellHdr;
+					void	*cellData;
+					} cellInfo;
+				struct 
+					{
+					long	totalBits;
+					long	errBits;
+					} bertInfo;
+				} param;			
+			} atmStatus;
+#ifdef DSL_PACKET
+		dslFramerStatus		dslPacketStatus;
+#endif
+#ifdef G997_1_FRAMER
+		dslFramerStatus		g997Status;
+#endif
+		struct
+			{
+			dslTrainingStatusCode		code;
+			long						value;
+			} dslTrainingInfo;
+		struct
+			{
+			dslConnectInfoStatusCode	code;
+			long						value;
+			void						*buffPtr;
+			} dslConnectInfo;
+		struct
+			{
+			long						maxMarginCarrier;
+			long						maxSNRMargin;
+			long						minMarginCarrier;
+			long						minSNRMargin;
+			long						avgSNRMargin;
+			long						nCarriers;
+			void						*buffPtr;
+			} dslShowtimeSNRMarginInfo;
+		struct 
+			{
+			long						code;
+			long						vcId;
+			long						timeStamp;
+			} dslFrameInfo;
+#ifdef G997_1
+		struct
+			{
+			long	msgId;
+			long	msgType;
+			char	*dataPtr;
+			} dslClearEocMsg;
+#endif
+		struct
+			{
+			char	*fmt;
+			long	argNum;
+			void	*argPtr;
+			} dslPrintfMsg;
+		struct
+			{
+			ulong	nBits;
+			ulong	nBlocks;
+			ulong	nBitErrors;
+			ulong	nBlockErrors;
+
+			ulong	nAudioBits;
+			ulong	nAudioBlocks;
+			ulong	nAudioSyncErrors;
+			ulong	nAudioBlockErrors;
+			} testResults;
+		struct
+			{
+			ulong	code;
+			uchar	*valuePtr;
+			ulong	length;
+			} dslDataRegister;
+		struct
+			{
+			ulong	code;
+			char	*desc;
+			} dslExternalError;
+		struct
+			{
+			ulong	numberOfCalls;
+			ulong	txSignalChecksum;
+			ulong	rxSignalChecksum;
+			ulong	eyeDataChecksum;
+			} checksums;
+		struct
+			{
+			int		sp;
+			int		argc;
+			int		*argv;
+			int		*stackPtr;
+			int		stackLen;
+			} dslException;
+		struct
+			{
+			ulong	paramId;
+			void	*dataPtr;
+			ulong	dataLen;
+			} dslOemParameter;
+		struct
+			{
+			void	*dataPtr;
+			ulong	dataLen;
+			} dslDataAvail;
+		dslOLRMessage		dslOLRRequest;
+		dslPwrMessage		dslPwrMsg;
+		} param;
+	} dslStatusStruct;
+	
+typedef	void	(SM_DECL *dslStatusHandlerType)		(void *gDslVars, dslStatusStruct*);
+
+
+/*
+**
+**		Command codes 
+**
+*/
+
+typedef long						dslCommandCode;
+#define	kFirstDslCommandCode		256
+#define kDslIdleCmd					(kFirstDslCommandCode + 0)
+#define kDslIdleRcvCmd				(kFirstDslCommandCode + 1)
+#define kDslIdleXmtCmd				(kFirstDslCommandCode + 2)
+#define	kDslStartPhysicalLayerCmd	(kFirstDslCommandCode + 3)
+#define	kDslStartRetrainCmd			(kFirstDslCommandCode + 4)
+#define	kDslSetFrameFunctions		(kFirstDslCommandCode + 5)
+#define kDslSendEocCommand			(kFirstDslCommandCode + 6)
+#define kDslWriteRemoteRegister		(kFirstDslCommandCode + 7)
+#define kDslReadRemoteRegister		(kFirstDslCommandCode + 8)
+#define kDslWriteLocalRegister		(kFirstDslCommandCode + 9)
+#define kDslReadLocalRegister		(kFirstDslCommandCode + 10)
+#define	kDslStoreHardwareAGCCmd		(kFirstDslCommandCode + 11)
+#define kDslSetCommandHandlerCmd	(kFirstDslCommandCode + 12)
+#define kSetLinkLayerStatusHandlerCmd (kFirstDslCommandCode + 13)
+#define kDslSetG997Cmd				(kFirstDslCommandCode + 14)
+#define kDslLoopbackCmd				(kFirstDslCommandCode + 15)
+#define kDslDiagSetupCmd			(kFirstDslCommandCode + 16)
+#define kDslSetDriverCallbackCmd	(kFirstDslCommandCode + 17)
+#define kDslDiagStopLogCmd			(kFirstDslCommandCode + 18)
+#define kDslDiagStartBERT			(kFirstDslCommandCode + 19)
+#define kDslDiagStopBERT			(kFirstDslCommandCode + 20)
+#define kDslPingCmd					(kFirstDslCommandCode + 21)
+#define kDslDyingGaspCmd			(kFirstDslCommandCode + 22)
+#define kDslTestCmd					(kFirstDslCommandCode + 23)
+#define kDslFilterSNRMarginCmd		(kFirstDslCommandCode + 24)
+#define kDslAtmVcMapTableChanged	(kFirstDslCommandCode + 25)
+#define	kDslGetOemDataAddrCmd		(kFirstDslCommandCode + 26)
+#define kDslAtmReportHEC			(kFirstDslCommandCode + 27)
+#define kDslAtmReportCD				(kFirstDslCommandCode + 28)
+#define kDslSetXmtGainCmd			(kFirstDslCommandCode + 29)
+#define kDslSetStatusBufferCmd		(kFirstDslCommandCode + 30)
+#define kDslAfeTestCmd				(kFirstDslCommandCode + 31)
+#define kDslI432ResetCmd			(kFirstDslCommandCode + 32)
+#define kDslSetRcvGainCmd           (kFirstDslCommandCode + 33)
+#define kDslBypassRcvHpfCmd         (kFirstDslCommandCode + 34)
+#define kDslWriteAfeRegCmd          (kFirstDslCommandCode + 35)
+#define kDslReadAfeRegCmd           (kFirstDslCommandCode + 36)
+#define	kDslOLRRequestCmd			(kFirstDslCommandCode + 37)
+#define	kDslOLRResponseCmd			(kFirstDslCommandCode + 38)
+#define kDslI432SetScrambleCmd		(kFirstDslCommandCode + 39)
+#define	kDslPwrMgrCmd				(kFirstDslCommandCode + 40)
+#define kDslAtmGfcMappingCmd		(kFirstDslCommandCode + 41)
+
+#ifdef BCM6348_SRC
+#define kDslEnablePwmSyncClk        (kFirstDslCommandCode + 42)
+#define kDslSetPwmSyncClkFreq       (kFirstDslCommandCode + 43)
+#endif
+
+#define	kG994p1Duplex								1
+#define	kG994p1HalfDuplex  							2
+
+/* Eoc Messages from ATU-C to ATU-R */
+#define kDslEocHoldStateCmd						1
+#define kDslEocReturnToNormalCmd				2
+#define kDslEocPerformSelfTestCmd				3
+#define kDslEocRequestCorruptCRCCmd				4
+#define kDslEocRequestEndCorruptCRCCmd			5
+#define kDslEocNotifyCorruptCRCCmd				6
+#define kDslEocNotifyEndCorruptCRCCmd			7
+#define kDslEocRequestTestParametersUpdateCmd	8
+#define kDslEocGrantPowerDownCmd				9
+#define kDslEocRejectPowerDownCmd				10
+
+/* Eoc Messages  from ATU-R to ATU-C */
+#define kDslEocRequestPowerDownCmd				11
+#define kDslEocDyingGaspCmd						12
+
+/* Clear Eoc Messages  */
+#define kDslClearEocFirstCmd					100
+#define kDslClearEocSendFrame					100
+#define kDslClearEocSendComplete				101
+#define kDslClearEocRcvedFrame					102
+#define kDslClearEocSendComplete2				103
+
+#define kDslClearEocMsgLengthMask				0xFFFF
+#define kDslClearEocMsgNumMask					0xFF0000
+#define kDslClearEocMsgDataVolatileMask			0x1000000
+#define kDslClearEocMsgDataVolatile				kDslClearEocMsgDataVolatileMask
+#define kDslClearEocMsgExtraSendComplete		0x2000000
+
+/* ADSL Link Power States */
+#define kDslPowerFullOn						0
+#define kDslPowerLow						1
+#define kDslPowerIdle						3
+
+/* ATU-R Data Registers */
+#define kDslVendorIDRegister				1
+#define kDslRevisionNumberRegister			2
+#define kDslSerialNumberRegister			3
+#define kDslSelfTestResultsRegister			4
+#define kDslLineAttenuationRegister			5
+#define kDslSnrMarginRegister				6
+#define kDslAturConfigurationRegister		7
+#define kDslLinkStateRegister				8
+
+#define kDslVendorIDRegisterLength			8
+#define kDslRevisionNumberRegisterLength	32
+#define kDslSerialNumberRegisterLength		32
+#define kDslSelfTestResultsRegisterLength	1
+#define kDslLineAttenuationRegisterLength	1
+#define kDslSnrMarginRegisterLength			1
+#define kDslAturConfigurationRegisterLength	30
+#define kDslLinkStateRegisterLength			1
+
+/* Dsl Diags setup flags */
+#define kDslDiagEnableEyeData				1
+#define kDslDiagEnableLogData				2
+
+/* Dsl test commands */
+typedef	long								dslTestCmdType;
+#define	kDslTestBackToNormal				0
+#define kDslTestReverb						1
+#define kDslTestMedley						2
+#define kDslTestToneSelection				3
+#define	kDslTestNoAutoRetrain				4
+#define	kDslTestMarginTweak					5
+#define kDslTestEstimatePllPhase            6
+#define kDslTestReportPllPhaseStatus        7
+#define kDslTestAfeLoopback					8
+#define kDslTestL3							9
+#define kDslTestAdsl2DiagMode				10
+#define kDslTestRetL0						11
+
+/* Xmt gain default setting */
+#define	kDslXmtGainAuto						0x80000000
+
+/* Unit (AFE) test commands */
+#define	kDslAfeTestLoadImage				0
+#define	kDslAfeTestPatternSend				1
+#define	kDslAfeTestLoadImageOnly			2
+#define	kDslAfeTestPhyRun					3
+#define	kDslAfeTestLoadBuffer				4
+
+typedef struct
+	{
+#if defined(G992P1_ANNEX_I) || defined(G992P5) 
+	ushort 				downstreamMinCarr, downstreamMaxCarr;
+#else
+	uchar 				downstreamMinCarr, downstreamMaxCarr;
+#endif
+	uchar           	upstreamMinCarr, upstreamMaxCarr;
+	}carrierInfo;
+
+#if defined(G992P3) && !defined(BCM6348_SRC) 
+#define	FAST_TEXT_TYPE
+#else
+#define	FAST_TEXT_TYPE			FAST_TEXT
+#endif
+
+#if defined(BCM6348_SRC) 
+#define BCM6348_TEMP_MOVE_TO_LMEM 
+#else
+#define BCM6348_TEMP_MOVE_TO_LMEM
+#endif
+
+#ifdef	G992P3
+#define	PRINT_DEBUG_INFO
+#else
+#define	PRINT_DEBUG_INFO
+#endif
+
+#ifdef G992P3
+
+#define		kG992p3MaxSpectBoundsUpSize		16
+#define		kG992p3MaxSpectBoundsDownSize	16
+
+/* G.994 definitions */
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 1 ***/
+
+#define	kG994p1G992p3AnnexASpectrumBoundsUpstream	0x01
+#define	kG994p1G992p3AnnexASpectrumShapingUpstream	0x02
+#define	kG994p1G992p3AnnexASpectrumBoundsDownstream	0x04
+#define	kG994p1G992p3AnnexASpectrumShapingDownstream	0x08
+#define	kG994p1G992p3AnnexATxImageAboveNyquistFreq	0x10
+#define	kG994p1G992p3AnnexLReachExtended			0x20
+#define kG994p1G992p3AnnexMSubModePSDMasks          0x20
+
+#define	kG994p1G992p3AnnexLUpNarrowband				0x02
+#define	kG994p1G992p3AnnexLUpWideband				0x01
+#define	kG994p1G992p3AnnexLDownNonoverlap			0x01
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 2 ***/
+
+#define	kG994p1G992p3AnnexADownOverheadDataRate		0x01
+#define	kG994p1G992p3AnnexAUpOverheadDataRate		0x02
+#define	kG994p1G992p3AnnexAMaxNumberDownTPSTC		0x04
+#define	kG994p1G992p3AnnexAMaxNumberUpTPSTC			0x08
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 3,5,7,9 ***/
+
+#define	kG994p1G992p3AnnexADownSTM_TPS_TC			0x01
+#define	kG994p1G992p3AnnexAUpSTM_TPS_TC				0x02
+#define	kG994p1G992p3AnnexADownATM_TPS_TC			0x04
+#define	kG994p1G992p3AnnexAUpATM_TPS_TC				0x08
+#define	kG994p1G992p3AnnexADownPTM_TPS_TC			0x10
+#define	kG994p1G992p3AnnexAUpPTM_TPS_TC				0x20
+
+/*** Standard Info SPar2:  G.992.3 Annex A  Octet 4,6,8,10 ***/
+
+#define	kG994p1G992p3AnnexADownPMS_TC_Latency		0x01
+#define	kG994p1G992p3AnnexAUpPMS_TC_Latency			0x02
+
+/*** 
+ *   TSSI
+ *
+ *   TSSI information is specified in 2 parts: subcarrier index,
+ *   tssi value, and an indication of whether or no the tone specified
+ *   is part of the supported set.
+ *
+ *   The subcarrier index information is currently stored in the
+ *   dsSubcarrierIndex array defined below. The tssi value are stored
+ *   in the dsLog_tss array.
+ *
+ *   The subcarrier index information only occupies the lower 12 bits
+ *   of the available 16 bits (short type). Therefore, we will pack the
+ *   supported set information in bit 15.
+ */
+#define kG992DsSubCarrierIndexMask          (0x0fff)   /* AND mask to ectract ds subcarrier index */
+#define kG992DsSubCarrierSuppSetMask        (0x8000)   /* AND mask to extract supported set indication */
+
+#define G992GetDsSubCarrierIndex(arg)               ((arg)  & kG992DsSubCarrierIndexMask)
+#define G992GetDsSubCarrierSuppSetIndication(arg)   (((arg) & kG992DsSubCarrierSuppSetMask) >> 15)
+
+/* Caution: Do not change anything in this structure definition, including associated constant */
+/* This structure definition is used only by the driver and any change impose incompatibility issue in driver */
+/* The structure following this structure (g992p3PhyDataPumpCapabilities) can be changed in PHY application */
+
+typedef struct
+	{
+	Boolean				rcvNTREnabled, shortInitEnabled, diagnosticsModeEnabled;
+	
+	char				featureSpectrum, featureOverhead;
+	char				featureTPS_TC[4], featurePMS_TC[4];
+	
+	short				rcvNOMPSDus, rcvMAXNOMPSDus, rcvMAXNOMATPus;
+	short				usSubcarrierIndex[kG992p3MaxSpectBoundsUpSize],
+						usLog_tss[kG992p3MaxSpectBoundsUpSize];
+	short				numUsSubcarrier;
+	short				rcvNOMPSDds, rcvMAXNOMPSDds, rcvMAXNOMATPds;
+	short				dsSubcarrierIndex[kG992p3MaxSpectBoundsDownSize],
+						dsLog_tss[kG992p3MaxSpectBoundsDownSize];
+	short				numDsSubcarrier;
+	uchar				sizeIDFT, fillIFFT;
+	uchar				readsl2Upstream, readsl2Downstream;
+	uchar				minDownOverheadDataRate, minUpOverheadDataRate;
+	uchar				maxDownSTM_TPSTC, maxDownATM_TPSTC, maxDownPTM_TPSTC;
+	uchar				maxUpSTM_TPSTC, maxUpATM_TPSTC, maxUpPTM_TPSTC;
+
+	short				minDownSTM_TPS_TC[4], maxDownSTM_TPS_TC[4],
+						minRevDownSTM_TPS_TC[4], maxDelayDownSTM_TPS_TC[4];
+	uchar				maxErrorDownSTM_TPS_TC[4], minINPDownSTM_TPS_TC[4];
+	short				minUpSTM_TPS_TC[4], maxUpSTM_TPS_TC[4],
+						minRevUpSTM_TPS_TC[4], maxDelayUpSTM_TPS_TC[4];
+	uchar				maxErrorUpSTM_TPS_TC[4], minINPUpSTM_TPS_TC[4];
+
+	short				maxDownPMS_TC_Latency[4], maxUpPMS_TC_Latency[4];
+	short				maxDownR_PMS_TC_Latency[4], maxDownD_PMS_TC_Latency[4];
+	short				maxUpR_PMS_TC_Latency[4], maxUpD_PMS_TC_Latency[4];
+
+	short				minDownATM_TPS_TC[4], maxDownATM_TPS_TC[4],
+						minRevDownATM_TPS_TC[4], maxDelayDownATM_TPS_TC[4];
+	uchar				maxErrorDownATM_TPS_TC[4], minINPDownATM_TPS_TC[4];
+	short				minUpATM_TPS_TC[4], maxUpATM_TPS_TC[4],
+						minRevUpATM_TPS_TC[4], maxDelayUpATM_TPS_TC[4];
+	uchar				maxErrorUpATM_TPS_TC[4], minINPUpATM_TPS_TC[4];
+
+	short				minDownPTM_TPS_TC[4], maxDownPTM_TPS_TC[4],
+						minRevDownPTM_TPS_TC[4], maxDelayDownPTM_TPS_TC[4];
+	uchar				maxErrorDownPTM_TPS_TC[4], minINPDownPTM_TPS_TC[4];
+	short				minUpPTM_TPS_TC[4], maxUpPTM_TPS_TC[4],
+						minRevUpPTM_TPS_TC[4], maxDelayUpPTM_TPS_TC[4];
+	uchar				maxErrorUpPTM_TPS_TC[4], minINPUpPTM_TPS_TC[4];
+
+    ushort              subModePSDMasks;
+	} g992p3DataPumpCapabilities;
+
+#define		kG992p3p5MaxSpectBoundsUpSize		16
+#define		kG992p3p5MaxSpectBoundsDownSize		32
+
+typedef struct
+	{
+	Boolean				rcvNTREnabled, shortInitEnabled, diagnosticsModeEnabled;
+	
+	char				featureSpectrum, featureOverhead;
+	char				featureTPS_TC[4], featurePMS_TC[4];
+	
+	short				rcvNOMPSDus, rcvMAXNOMPSDus, rcvMAXNOMATPus;
+	short				usSubcarrierIndex[kG992p3p5MaxSpectBoundsUpSize],
+						usLog_tss[kG992p3p5MaxSpectBoundsUpSize];
+	short				numUsSubcarrier;
+	short				rcvNOMPSDds, rcvMAXNOMPSDds, rcvMAXNOMATPds;
+	short				dsSubcarrierIndex[kG992p3p5MaxSpectBoundsDownSize],
+						dsLog_tss[kG992p3p5MaxSpectBoundsDownSize];
+	short				numDsSubcarrier;
+	uchar				sizeIDFT, fillIFFT;
+	uchar				readsl2Upstream, readsl2Downstream;
+	uchar				minDownOverheadDataRate, minUpOverheadDataRate;
+	uchar				maxDownSTM_TPSTC, maxDownATM_TPSTC, maxDownPTM_TPSTC;
+	uchar				maxUpSTM_TPSTC, maxUpATM_TPSTC, maxUpPTM_TPSTC;
+
+	short				minDownSTM_TPS_TC[4], maxDownSTM_TPS_TC[4],
+						minRevDownSTM_TPS_TC[4], maxDelayDownSTM_TPS_TC[4];
+	uchar				maxErrorDownSTM_TPS_TC[4], minINPDownSTM_TPS_TC[4];
+	short				minUpSTM_TPS_TC[4], maxUpSTM_TPS_TC[4],
+						minRevUpSTM_TPS_TC[4], maxDelayUpSTM_TPS_TC[4];
+	uchar				maxErrorUpSTM_TPS_TC[4], minINPUpSTM_TPS_TC[4];
+
+	short				maxDownPMS_TC_Latency[4], maxUpPMS_TC_Latency[4];
+	short				maxDownR_PMS_TC_Latency[4], maxDownD_PMS_TC_Latency[4];
+	short				maxUpR_PMS_TC_Latency[4], maxUpD_PMS_TC_Latency[4];
+
+	short				minDownATM_TPS_TC[4], maxDownATM_TPS_TC[4],
+						minRevDownATM_TPS_TC[4], maxDelayDownATM_TPS_TC[4];
+	uchar				maxErrorDownATM_TPS_TC[4], minINPDownATM_TPS_TC[4];
+	short				minUpATM_TPS_TC[4], maxUpATM_TPS_TC[4],
+						minRevUpATM_TPS_TC[4], maxDelayUpATM_TPS_TC[4];
+	uchar				maxErrorUpATM_TPS_TC[4], minINPUpATM_TPS_TC[4];
+
+	short				minDownPTM_TPS_TC[4], maxDownPTM_TPS_TC[4],
+						minRevDownPTM_TPS_TC[4], maxDelayDownPTM_TPS_TC[4];
+	uchar				maxErrorDownPTM_TPS_TC[4], minINPDownPTM_TPS_TC[4];
+	short				minUpPTM_TPS_TC[4], maxUpPTM_TPS_TC[4],
+						minRevUpPTM_TPS_TC[4], maxDelayUpPTM_TPS_TC[4];
+	uchar				maxErrorUpPTM_TPS_TC[4], minINPUpPTM_TPS_TC[4];
+
+    ushort              subModePSDMasks;
+	} g992p3PhyDataPumpCapabilities;
+#endif
+
+typedef struct
+	{
+	dslModulationType	modulations;
+	bitMap				auxFeatures;
+	bitMap          	features;	
+	bitMap				demodCapabilities;
+	bitMap				demodCapabilities2;
+	ushort				noiseMargin;		/* Q4 dB */
+#ifdef G992_ATUC
+	short				xmtRSf, xmtRS, xmtS, xmtD;
+	short				rcvRSf, rcvRS, rcvS, rcvD;
+#endif	
+#ifdef G992P1_ANNEX_A	
+	bitMap          	subChannelInfo;
+	carrierInfo     	carrierInfoG992p1;
+#endif
+#ifdef G992P1_ANNEX_B	
+	bitMap          	subChannelInfoAnnexB;
+	carrierInfo     	carrierInfoG992p1AnnexB;
+#endif
+#ifdef G992_ANNEXC	
+	bitMap          	subChannelInfoAnnexC;
+	carrierInfo     	carrierInfoG992p1AnnexC;
+#endif
+#if defined(G992P1_ANNEX_I)
+	bitMap          	subChannelInfoAnnexI;
+	carrierInfo     	carrierInfoG992p1AnnexI;
+#endif
+#ifdef G992P5
+	bitMap          	subChannelInfop5;
+	carrierInfo     	carrierInfoG992p5;
+#endif
+#if defined(G992P2) || (defined(G992P1_ANNEX_A) && defined(G992P1_ANNEX_A_USED_FOR_G992P2))
+	carrierInfo     	carrierInfoG992p2;
+#endif
+	ushort           	maxDataRate;
+	uchar           	minDataRate;	     
+#ifdef G992P3
+	g992p3DataPumpCapabilities	*carrierInfoG992p3AnnexA;
+#endif
+#ifdef G992P5
+	g992p3DataPumpCapabilities	*carrierInfoG992p5AnnexA;
+#endif
+	} dslDataPumpCapabilities;
+		
+struct __dslCommandStruct;
+typedef	Boolean	(*dslCommandHandlerType)	(void *gDslVars, struct __dslCommandStruct*);
+typedef	struct __dslCommandStruct
+	{
+	dslCommandCode						command;
+	union
+		{
+		long							value;
+		Boolean							flag;
+		struct
+			{
+			dslTestCmdType				type;
+			union
+				{
+				struct
+					{
+					ulong				xmtStartTone, xmtNumOfTones;
+					ulong				rcvStartTone, rcvNumOfTones;
+					uchar				*xmtMap, *rcvMap;
+					} toneSelectSpec;
+				struct
+					{
+					long				extraPowerRequestQ4dB;
+					long				numOfCarriers;
+					char				*marginTweakTableQ4dB;
+					} marginTweakSpec;
+				} param;
+			} dslTestSpec;
+		struct
+			{
+			dslDirectionType			direction;			
+			dslDataPumpCapabilities		capabilities;
+			} dslModeSpec;
+		struct
+			{
+			bitMap						setup;			
+			ulong						eyeConstIndex1;
+			ulong						eyeConstIndex2;
+			ulong						logTime;
+			} dslDiagSpec;
+		struct
+			{
+			void						*pBuf;			
+			ulong						bufSize;
+			} dslStatusBufSpec;
+		struct
+			{
+			ulong						type;
+			void						*afeParamPtr;
+			ulong						afeParamSize;
+			void						*imagePtr;
+			ulong						imageSize;
+			} dslAfeTestSpec;
+		struct
+			{
+			dslLinkLayerType			type;
+			bitMap						setup;
+			union
+				{
+				struct
+					{
+					dataRateMap					rxDataRate;
+					dataRateMap					txDataRate;
+					long						rtDelayQ4ms;				
+					ulong						rxBufNum;
+					ulong						rxCellsInBuf;
+					ulong						rxPacketNum;
+					dslFrameHandlerType			rxIndicateHandlerPtr;
+					dslFrameHandlerType 		txCompleteHandlerPtr;
+					dslPhyInitType				atmPhyInitPtr;
+					} atmLinkSpec;
+				struct
+					{
+					dslHeaderHandlerType		rxHeaderHandlerPtr;
+					dslRxFrameBufferHandlerType	rxDataHandlerPtr;
+					dslTxFrameBufferHandlerType txHandlerPtr;
+					} atmPhyLinkSpec;
+#ifdef DSL_PACKET
+				struct
+					{
+					ulong						rxBufNum;
+					ulong						rxBufSize;
+					ulong						rxPacketNum;
+					dslFrameHandlerType			rxIndicateHandlerPtr;
+					dslFrameHandlerType 		txCompleteHandlerPtr;
+					dslPacketPhyInitType		dslPhyInitPtr;
+					} dslPacketLinkSpec;
+				dslPacketPhyFunctions			dslPacketPhyLinkSpec;
+#endif
+				struct
+					{
+					txDataHandlerType			txDataHandlerPtr;
+					rxDataHandlerType			rxDataHandlerPtr;
+					} nullLinkSpec;
+				} param;
+			} dslLinkLayerSpec;
+#ifdef G997_1
+#ifdef G997_1_FRAMER
+		struct
+			{
+			bitMap						setup;
+			ulong						rxBufNum;
+			ulong						rxBufSize;
+			ulong						rxPacketNum;
+			dslFrameHandlerType			rxIndicateHandlerPtr;
+			dslFrameHandlerType 		txCompleteHandlerPtr;
+			} dslG997Cmd;
+#endif
+		struct
+			{
+			long	msgId;
+			long	msgType;
+			char	*dataPtr;
+			} dslClearEocMsg;
+#endif
+		struct
+			{
+			ulong						code;
+			uchar						*valuePtr;
+			ulong						length;
+			} dslDataRegister;
+		union
+			{
+			dslStatusHandlerType		statusHandlerPtr;
+			dslCommandHandlerType		commandHandlerPtr;
+			eyeHandlerType				eyeHandlerPtr;
+			logHandlerType				logHandlerPtr;
+#if defined(DEBUG_DATA_HANDLER)
+            debugDataHandlerType        debugDataHandlerPtr;
+#endif
+			dslFrameHandlerType			rxIndicateHandlerPtr;
+			dslFrameHandlerType			txCompleteHandlerPtr;
+			dslDriverCallbackType		driverCallback;
+			} handlerSpec;
+#if !defined(CHIP_SRC) || defined(DSL_FRAME_FUNCTIONS)
+		dslFrameFunctions				DslFunctions;
+#endif
+		dslOLRMessage					dslOLRRequest;
+		dslPwrMessage					dslPwrMsg;
+		} param;
+	} dslCommandStruct;
+	
+
+
+
+typedef struct
+	{
+	dslCommandHandlerType			linkCommandHandlerPtr;
+	timerHandlerType				linkTimerHandlerPtr;
+	dslLinkCloseHandlerType			linkCloseHandlerPtr;
+
+	dslFrameHandlerType				linkSendHandlerPtr;
+	dslFrameHandlerType				linkReturnHandlerPtr;
+
+	dslVcAllocateHandlerType		linkVcAllocateHandlerPtr;
+	dslVcFreeHandlerType			linkVcFreeHandlerPtr;
+	dslVcActivateHandlerType		linkVcActivateHandlerPtr;
+	dslVcDeactivateHandlerType		linkVcDeactivateHandlerPtr;
+	dslVcConfigureHandlerType		linkVcConfigureHandlerPtr;
+
+	dslLinkVc2IdHandlerType			linkVc2IdHandlerPtr;
+	dslLinkVcId2VcHandlerType		linkVcId2VcHandlerPtr;
+	dslGetFramePoolHandlerType		linkGetFramePoolHandlerPtr;
+
+#ifndef ADSLCORE_ONLY
+	dslHeaderHandlerType			linkRxCellHeaderHandlerPtr;
+	dslRxFrameBufferHandlerType		linkRxCellDataHandlerPtr;
+	dslTxFrameBufferHandlerType		linkTxCellHandlerPtr;
+#endif
+
+	txDataHandlerType				linkTxDataHandlerPtr;
+	rxDataHandlerType				linkRxDataHandlerPtr;
+	} linkLayerFunctions;
+
+#ifndef ADSLCORE_ONLY
+
+#define	 LinkLayerAssignFunctions( var, name_prefix )	do {					\
+	(var).linkCommandHandlerPtr = name_prefix##CommandHandler;					\
+	(var).linkTimerHandlerPtr	= name_prefix##TimerHandler;					\
+	(var).linkCloseHandlerPtr	= name_prefix##CloseHandler;					\
+																				\
+	(var).linkSendHandlerPtr	= name_prefix##SendFrameHandler;				\
+	(var).linkReturnHandlerPtr	= name_prefix##ReturnFrameHandler;				\
+																				\
+	(var).linkVcAllocateHandlerPtr		= name_prefix##VcAllocateHandler;		\
+	(var).linkVcFreeHandlerPtr			= name_prefix##VcFreeHandler;			\
+	(var).linkVcActivateHandlerPtr		= name_prefix##VcActivateHandler;		\
+	(var).linkVcDeactivateHandlerPtr	= name_prefix##VcDeactivateHandler;		\
+	(var).linkVcConfigureHandlerPtr		= name_prefix##VcConfigureHandler;		\
+																				\
+	(var).linkVc2IdHandlerPtr			= name_prefix##Vc2IdHandler;			\
+	(var).linkVcId2VcHandlerPtr			= name_prefix##VcId2VcHandler;			\
+	(var).linkGetFramePoolHandlerPtr	= name_prefix##GetFramePoolHandler;		\
+																				\
+	(var).linkRxCellHeaderHandlerPtr	= name_prefix##RxCellHeaderHandler;		\
+	(var).linkRxCellDataHandlerPtr		= name_prefix##RxCellDataHandler;		\
+	(var).linkTxCellHandlerPtr			= name_prefix##TxCellHandler;			\
+																				\
+	(var).linkTxDataHandlerPtr	= name_prefix##TxDataHandler;					\
+	(var).linkRxDataHandlerPtr	= name_prefix##RxDataHandler;					\
+} while (0)
+
+#else
+
+#define	 LinkLayerAssignFunctions( var, name_prefix )	do {					\
+	(var).linkCommandHandlerPtr = name_prefix##CommandHandler;					\
+	(var).linkTimerHandlerPtr	= name_prefix##TimerHandler;					\
+	(var).linkCloseHandlerPtr	= name_prefix##CloseHandler;					\
+																				\
+	(var).linkSendHandlerPtr	= name_prefix##SendFrameHandler;				\
+	(var).linkReturnHandlerPtr	= name_prefix##ReturnFrameHandler;				\
+																				\
+	(var).linkVcAllocateHandlerPtr		= name_prefix##VcAllocateHandler;		\
+	(var).linkVcFreeHandlerPtr			= name_prefix##VcFreeHandler;			\
+	(var).linkVcActivateHandlerPtr		= name_prefix##VcActivateHandler;		\
+	(var).linkVcDeactivateHandlerPtr	= name_prefix##VcDeactivateHandler;		\
+	(var).linkVcConfigureHandlerPtr		= name_prefix##VcConfigureHandler;		\
+																				\
+	(var).linkVc2IdHandlerPtr			= name_prefix##Vc2IdHandler;			\
+	(var).linkVcId2VcHandlerPtr			= name_prefix##VcId2VcHandler;			\
+	(var).linkGetFramePoolHandlerPtr	= name_prefix##GetFramePoolHandler;		\
+																				\
+	(var).linkTxDataHandlerPtr	= name_prefix##TxDataHandler;					\
+	(var).linkRxDataHandlerPtr	= name_prefix##RxDataHandler;					\
+} while (0)
+
+#endif
+
+typedef struct
+	{
+	dslFrameHandlerType				rxIndicateHandlerPtr;
+	dslFrameHandlerType				txCompleteHandlerPtr;
+	dslStatusHandlerType			statusHandlerPtr;
+	} upperLayerFunctions;
+
+
+/*
+ * Debug data
+ */
+#define	kDslFirstDebugData					1000
+#define	kDslXmtPerSymTimeCompData			(kDslFirstDebugData + 0)
+#define	kDslRcvPerSymTimeCompData			(kDslFirstDebugData + 1)
+#define	kDslXmtAccTimeCompData				(kDslFirstDebugData + 2)
+#define	kDslRcvAccTimeCompData				(kDslFirstDebugData + 3)
+#define	kDslRcvPilotToneData				(kDslFirstDebugData + 4)
+#define	kDslTEQCoefData						(kDslFirstDebugData + 5)
+#define	kDslTEQInputData					(kDslFirstDebugData + 6)
+#define	kDslTEQOutputData					(kDslFirstDebugData + 7)
+#define	kDslRcvFFTInputData					(kDslFirstDebugData + 8)
+#define	kDslRcvFFTOutputData				(kDslFirstDebugData + 9)
+#define	kDslRcvCarrierSNRData				(kDslFirstDebugData + 10)
+#define	kDslXmtToneOrderingData				(kDslFirstDebugData + 11)
+#define	kDslRcvToneOrderingData				(kDslFirstDebugData + 12)
+#define	kDslXmtGainData						(kDslFirstDebugData + 13)
+#define	kDslRcvGainData						(kDslFirstDebugData + 14)
+#define	kDslMseData							(kDslFirstDebugData + 15)
+#define	kDslFEQOutErrData					(kDslFirstDebugData + 16)
+#define kDslFEQCoefData 					(kDslFirstDebugData + 17)
+#define kDslShowtimeMseData					(kDslFirstDebugData + 18)
+#define kDslTimeEstimationHWPhaseTweak		(kDslFirstDebugData + 24)
+#define	kDslSlicerInput						(kDslFirstDebugData + 40)
+#define	kDslXmtConstellations				(kDslFirstDebugData + 41)
+#define kDslSnr1ShiftData					(kDslFirstDebugData + 50)
+#define kDslSnr1InputData					(kDslFirstDebugData + 51)
+#define kDslSnr1ReverbAvgData				(kDslFirstDebugData + 52)
+#define kDslAnnexCFextSnrData				(kDslFirstDebugData + 53)
+#define kDslAnnexCNextSnrData				(kDslFirstDebugData + 54)
+#define	kG994p1OutputXmtSample				(kDslFirstDebugData + 100)
+#define	kG994p1OutputMicroBit				(kDslFirstDebugData + 101)
+#define	kG994p1OutputBit					(kDslFirstDebugData + 102)
+#define	kG994p1OutputTimer					(kDslFirstDebugData + 103)
+
+/****************************************************************************/
+/*	2.	Constant definitions.												*/
+/*																			*/
+/*	2.1	Defininitive constants												*/
+/****************************************************************************/
+
+/* dslDirectionType */
+
+#define	kATU_C		0
+#define	kATU_R		1
+
+/* ATM setup maps	*/
+
+#define	kAtmCallMgrEnabled			0x00000001		/* Bit 0  */
+#define	kAtmAAL1FecEnabledMask		0x00000006		/* Bit 1  */
+#define	kAtmAAL1HiDelayFecEnabled	0x00000002		/* Bit 2  */
+#define	kAtmAAL1LoDelayFecEnabled	0x00000004		/* Bit 3  */
+
+/* dslLinkLayerType */
+
+#define kNoDataLink			0
+#define kAtmLink			0x00000001
+#define kAtmPhyLink			0x00000002
+#define kDslPacketLink		0x00000003
+#define kDslPacketPhyLink	0x00000004
+
+/* dslModulationType */
+#define	kNoCommonModulation	0x00000000				
+#define	kG994p1				0x00000020				/* G.994.1 or G.hs */
+#define	kT1p413				0x00000040				/* T1.413 handshaking */
+#define	kG992p1AnnexA		0x00000001				/* G.992.1 or G.dmt Annex A */
+#define	kG992p1AnnexB		0x00000002				/* G.992.1 or G.dmt Annex B */
+#define	kG992p1AnnexC		0x00000004				/* G.992.1 or G.dmt Annex C */
+#define	kG992p2AnnexAB		0x00000008				/* G.992.2 or G.lite Annex A/B */
+#define	kG992p2AnnexC		0x00000010				/* G.992.2 or G.lite Annex C */
+#define	kG992p3AnnexA		0x00000100				/* G.992.3 or G.DMTbis Annex A */
+#define	kG992p3AnnexB		0x00000200				/* G.992.3 or G.DMTbis Annex A */
+#define	kG992p1AnnexI		0x00000400				/* G.992.1 Annex I */
+#define kG992p5AnnexA       0x00010000              /* G.992.5 Annex A */
+#define kG992p5AnnexB       0x00020000              /* G.992.5 Annex B */
+#define kG992p5AnnexI       0x00040000              /* G.992.5 Annex I */
+#define kG992p3AnnexM       0x00080000              /* G.992.3 Annex M */
+#define kG992p5AnnexM       0x01000000              /* G.992.5 Annex M */
+
+/* demodCapabilities bitmap */
+#define	kEchoCancellorEnabled					0x00000001
+#define	kSoftwareTimeErrorDetectionEnabled		0x00000002
+#define	kSoftwareTimeTrackingEnabled			0x00000004
+#define kDslTrellisEnabled			            0x00000008
+#define	kHardwareTimeTrackingEnabled			0x00000010
+#define kHardwareAGCEnabled						0x00000020
+#define kDigitalEchoCancellorEnabled			0x00000040
+#define kReedSolomonCodingEnabled				0x00000080
+#define kAnalogEchoCancellorEnabled				0x00000100
+#define	kT1p413Issue1SingleByteSymMode			0x00000200
+#define	kDslAturXmtPowerCutbackEnabled			0x00000400
+#ifdef G992_ANNEXC_LONG_REACH
+#define kDslAnnexCPilot48                       0x00000800
+#define kDslAnnexCReverb33_63                   0x00001000
+#endif
+#ifdef G992_ANNEXC
+#define kDslCentilliumCRCWorkAroundEnabled		0x00002000
+#else
+#define kDslEnableRoundUpDSLoopAttn		        0x00002000
+#endif
+#define	kDslBitSwapEnabled						0x00004000
+#define	kDslADILowRateOptionFixDisabled			0x00008000
+#define	kDslAnymediaGSPNCrcFixEnabled			0x00010000
+#define	kDslMultiModesPreferT1p413				0x00020000
+#define	kDslT1p413UseRAck1Only					0x00040000
+#define	kDslUE9000ADI918FECFixEnabled			0x00080000
+#define	kDslG994AnnexAMultimodeEnabled			0x00100000
+#define	kDslATUCXmtPowerMinimizeEnabled			0x00200000
+#define	kDropOnDataErrorsDisabled			    0x00400000
+#define	kDslSRAEnabled						    0x00800000
+
+#define	kDslT1p413HigherToneLevelNeeded			0x01000000
+#define	kDslT1p413SubsampleAlignmentEnabled		0x02000000
+#define	kDslT1p413DisableUpstream2xIfftMode		0x04000000
+
+/* test mode related demodCapabilities, for internal use only */
+#define	kDslTestDemodCapMask					0xF8000000
+#define	kDslSendReverbModeEnabled				0x10000000
+#define	kDslSendMedleyModeEnabled				0x20000000
+#define	kDslAutoRetrainDisabled					0x40000000
+#define kDslPllWorkaroundEnabled                0x80000000
+#define kDslAfeLoopbackModeEnabled              0x08000000
+
+/* demodCapabilities bitmap2 */
+
+#define kDslAnnexCProfile1	    			    0x00000001
+#define kDslAnnexCProfile2	    			    0x00000002
+#define kDslAnnexCProfile3	    			    0x00000004
+#define kDslAnnexCProfile4	    			    0x00000008
+#define kDslAnnexCProfile5	    			    0x00000010
+#define kDslAnnexCProfile6	    			    0x00000020
+#define kDslAnnexCPilot64			   	        0x00000040
+#define kDslAnnexCPilot48                       0x00000080
+#define kDslAnnexCPilot32			   	        0x00000100
+#define kDslAnnexCPilot16			   	        0x00000200
+#define kDslAnnexCA48B48			   		    0x00000400
+#define kDslAnnexCA24B24			    	    0x00000800
+#define kDslAnnexCReverb33_63                   0x00001000
+#define kDslAnnexCCReverb6_31	  		        0x00002000
+
+#define kDslAnnexIShapedSSVI                    0x00004000
+#define kDslAnnexIFlatSSVI                      0x00008000
+
+#define kDslAnnexIPilot64			   	        0x00010000
+#define kDslAnnexIA48B48			   		    0x00020000
+#define kDslAnnexIPilot128			   	        0x00040000
+#define kDslAnnexIPilot96			   	        0x00080000
+
+/* Features bitmap */
+#define	kG992p2RACK1   						    0x00000001
+#define	kG992p2RACK2							0x00000002
+#define	kG992p2DBM								0x00000004
+#define	kG992p2FastRetrain						0x00000008
+#define	kG992p2RS16								0x00000010
+#define	kG992p2ClearEOCOAM						0x00000020
+#define	kG992NTREnabled							0x00000040
+#define	kG992p2EraseAllStoredProfiles			0x00000080
+#define kG992p2FeaturesNPar2Mask                0x0000003B
+#define kG992p2FeaturesNPar2Shift                        0
+
+#define kG992p1RACK1                            0x00000100
+#define kG992p1RACK2                            0x00000200
+#define kG992p1STM                              0x00000800
+#define kG992p1ATM                              0x00001000
+#define	kG992p1ClearEOCOAM						0x00002000
+#define kG992p1FeaturesNPar2Mask                0x00003B00
+#define kG992p1FeaturesNPar2Shift                        8	
+#define kG992p1DualLatencyUpstream				0x00004000
+#define kG992p1DualLatencyDownstream			0x00008000
+#define kG992p1HigherBitRates					0x40000000
+
+#if defined(G992P1_ANNEX_I)
+#define kG992p1HigherBitRates1over3				0x80000000
+#define kG992p1AnnexIShapedSSVI                 0x00000001
+#define kG992p1AnnexIFlatSSVI                   0x00000002
+#define kG992p1AnnexIPilotFlag			   		0x00000008
+#define kG992p1AnnexIPilot64			   		0x00000001
+#define kG992p1AnnexIPilot128			   		0x00000004
+#define kG992p1AnnexIPilot96			   		0x00000008
+#define kG992p1AnnexIPilotA48B48                0x00000010
+#endif
+
+#define kG992p1AnnexBRACK1                      0x00010000
+#define kG992p1AnnexBRACK2                      0x00020000
+#define kG992p1AnnexBUpstreamTones1to32			0x00040000
+#define kG992p1AnnexBSTM                        0x00080000
+#define kG992p1AnnexBATM                        0x00100000
+#define	kG992p1AnnexBClearEOCOAM				0x00200000
+#define kG992p1AnnexBFeaturesNPar2Mask          0x003F0000
+#define kG992p1AnnexBFeaturesNPar2Shift                 16	
+
+#define kG992p1AnnexCRACK1                      0x01000000
+#define kG992p1AnnexCRACK2                      0x02000000
+#define kG992p1AnnexCDBM						0x04000000
+#define kG992p1AnnexCSTM                        0x08000000
+#define kG992p1AnnexCATM                        0x10000000
+#define	kG992p1AnnexCClearEOCOAM				0x20000000
+#define kG992p1AnnexCFeaturesNPar2Mask          0x3F000000
+#define kG992p1AnnexCFeaturesNPar2Shift                 24	
+
+#define kG992p1HigherBitRates1over3				0x80000000
+
+/* auxFeatures bitmap */
+#define	kG994p1PreferToExchangeCaps				0x00000001
+#define	kG994p1PreferToDecideMode				0x00000002
+#define	kG994p1PreferToMPMode				    0x00000004
+#define	kAfePwmSyncClockShift					3
+#define	kAfePwmSyncClockMask					(0xF << kAfePwmSyncClockShift)
+#define	AfePwmSyncClockEnabled(val)				(((val) & kAfePwmSyncClockMask) != 0)
+#define	AfePwmGetSyncClockFreq(val)				((((val) & kAfePwmSyncClockMask) >> kAfePwmSyncClockShift) - 1)
+#define	AfePwmSetSyncClockFreq(val,freq)		((val) |= ((((freq)+1) << kAfePwmSyncClockShift) & kAfePwmSyncClockMask))
+
+/* SubChannel Info bitMap for G992p1 */
+#define kSubChannelASODownstream                0x00000001
+#define kSubChannelAS1Downstream                0x00000002
+#define kSubChannelAS2Downstream                0x00000004
+#define kSubChannelAS3Downstream                0x00000008
+#define kSubChannelLSODownstream                0x00000010
+#define kSubChannelLS1Downstream                0x00000020
+#define kSubChannelLS2Downstream                0x00000040
+#define kSubChannelLS0Upstream                  0x00000080
+#define kSubChannelLS1Upstream                  0x00000100
+#define kSubChannelLS2Upstream                  0x00000200
+#define kSubChannelInfoOctet1Mask               0x0000001F
+#define kSubChannelInfoOctet2Mask               0x000003E0
+#define kSubChannelInfoOctet1Shift              		 0	
+#define kSubChannelInfoOctet2Shift              		 5	
+
+/****************************************************************************/
+/*	3.	Interface functions.												*/
+/*																			*/
+/****************************************************************************/
+
+#ifdef G992P1
+#if defined(G992P1_ANNEX_I2X) || defined(G992P5) 
+/* lke */
+#define	kDslSamplingFreq			4416000
+#define	kDslMaxFFTSize			 	1024	
+#define	kDslMaxFFTSizeShift			10
+#elif defined(G992P1_ANNEX_I4X)
+#define	kDslSamplingFreq			8832000
+#define	kDslMaxFFTSize			 	2048	
+#define	kDslMaxFFTSizeShift			11
+#elif defined(G992P1_ANNEX_I8X)
+#define	kDslSamplingFreq			17664000
+#define	kDslMaxFFTSize			 	4096	
+#define	kDslMaxFFTSizeShift			12
+#else
+#define	kDslSamplingFreq			2208000
+#define	kDslMaxFFTSize				512
+#define	kDslMaxFFTSizeShift			9
+#endif
+#else
+#define	kDslSamplingFreq			1104000
+#define	kDslMaxFFTSize				256
+#define	kDslMaxFFTSizeShift			8
+#endif
+
+#if defined(G992_ATUR_UPSTREAM_SAMPLING_FREQ_276KHZ)
+#define kDslATURUpstreamSamplingFreq    276000
+#define	kDslATURFFTSizeShiftUpstream	6
+#elif defined(G992_ATUR_UPSTREAM_SAMPLING_FREQ_552KHZ)
+#define kDslATURUpstreamSamplingFreq    552000
+#define	kDslATURFFTSizeShiftUpstream	7
+#else
+#define kDslATURUpstreamSamplingFreq    kDslSamplingFreq
+#define	kDslATURFFTSizeShiftUpstream	kDslMaxFFTSizeShift
+#endif 
+
+#if defined(G992_ATUC_UPSTREAM_SAMPLING_FREQ_276KHZ)
+#define kDslATUCUpstreamSamplingFreq    276000
+#define	kDslATUCFFTSizeShiftUpstream	6
+#elif defined(G992_ATUC_UPSTREAM_SAMPLING_FREQ_552KHZ)
+#define kDslATUCUpstreamSamplingFreq    552000
+#define	kDslATUCFFTSizeShiftUpstream	7
+#else
+#define kDslATUCUpstreamSamplingFreq    kDslSamplingFreq
+#define	kDslATUCFFTSizeShiftUpstream	kDslMaxFFTSizeShift
+#endif 
+
+#define	kDslMaxSamplesPerSymbol		(kDslMaxFFTSize+kDslMaxFFTSize/16)
+
+#if defined(G992P1_ANNEX_I) || defined(G992P5)
+#define kDslMaxTEQLength	        32
+#else
+#define kDslMaxTEQLength	        16
+#endif
+
+#define	kDslMaxSymbolBlockSize		1
+#define	kDslMaxSampleBlockSize		(kDslMaxSymbolBlockSize*kDslMaxSamplesPerSymbol)
+
+#ifdef G992_ANNEXC
+#define	kG992AnnexCXmtToRcvPathDelay	512   /* In samples at kDslSamplingFreq */
+#endif
+
+/*** For compatibility with existing test codes ***/
+#if !defined(TARG_OS_RTEMS)
+typedef dslStatusCode				modemStatusCode;
+typedef	dslStatusStruct				modemStatusStruct;
+typedef	dslStatusHandlerType		statusHandlerType;
+typedef dslCommandCode				modemCommandCode;
+typedef	dslCommandStruct			modemCommandStruct;
+typedef	dslCommandHandlerType		commandHandlerType;
+#endif
+
+extern void		SM_DECL SoftDslSetRefData	(void *gDslVars, ulong refData);
+extern ulong	SM_DECL SoftDslGetRefData	(void *gDslVars);
+extern int		SM_DECL SoftDslGetMemorySize(void);
+extern void		SM_DECL SoftDslInit			(void *gDslVars);
+extern void		SM_DECL SoftDslReset		(void *gDslVars);
+extern void		SM_DECL SoftDslLineHandler	(void *gDslVars, int rxNSamps, int txNSamps, short *rcvPtr, short *xmtPtr) FAST_TEXT;
+extern Boolean	SM_DECL SoftDslCommandHandler (void *gDslVars, dslCommandStruct *cmdPtr);
+
+/* swap Lmem functions */
+#if defined(bcm47xx) && defined(SWAP_LMEM)
+extern int SoftDslSwapLmem(void *gDslVars, int sectionN, int imageN);
+extern void init_SoftDslSwapLmem(void);
+#endif
+
+/* SoftDsl time functions	*/
+
+extern ulong	SM_DECL SoftDslGetTime(void *gDslVars);
+#define			__SoftDslGetTime(gv)		gDslGlobalVarPtr->execTime
+
+extern void		SM_DECL SoftDslTimer(void *gDslVars, ulong timeMs);
+
+/* SoftDsl IO functions	*/
+
+extern void		SM_DECL SoftDslClose (void *gDslVars);
+extern int		SM_DECL SoftDslSendFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+extern int		SM_DECL SoftDslReturnFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+
+/* SoftDsl connection functions	*/
+
+extern	void*	SM_DECL SoftDslVcAllocate(void *gDslVars, dslVcParams *pVcParams);
+extern	void	SM_DECL SoftDslVcFree(void *gDslVars, void *pVc);
+extern	Boolean SM_DECL SoftDslVcActivate(void *gDslVars, void *pVc);
+extern  void	SM_DECL SoftDslVcDeactivate(void *gDslVars, void *pVc);
+extern  Boolean SM_DECL SoftDslVcConfigure(void *gDslVars, void *pVc, ulong mid, dslVcParams *pVcParams);
+
+/* Special functions for LOG support */
+
+extern  ulong	SM_DECL SoftDslVc2Id(void *gDslVars, void *pVc);
+extern  void*	SM_DECL SoftDslVcId2Vc(void *gDslVars, ulong vcId);
+extern	void*	SM_DECL SoftDslGetFramePool(void *gDslVars);
+
+/* Functions for host mode execution */
+
+extern  void*   SM_DECL SoftDslRxCellHeaderHandler (void *gDslVars, ulong hdr, uchar hdrHec);
+extern	void*	SM_DECL SoftDslRxCellDataHandler (void *gDslVars, int,	void*);
+extern  void*	SM_DECL SoftDslTxCellHandler	(void *gDslVars, int*,	void*);
+extern  Boolean	SM_DECL SoftDslPhyCommandHandler (void *gDslVars, dslCommandStruct *cmdPtr);
+
+/* Functions getting OEM parameters including G994 non standard info management */
+
+extern	char*	SM_DECL SoftDslGetTrainingVendorIDString(void *gDslVars);
+extern	char*	SM_DECL SoftDslGetVendorIDString(void *gDslVars);
+extern	char*	SM_DECL SoftDslGetSerialNumberString(void *gDslVars);
+extern	char*	SM_DECL SoftDslGetRevString(void *gDslVars);
+extern	int		SM_DECL SoftDslRevStringSize(void *gDslVars);
+extern	int		SM_DECL SoftDslSerNumStringSize(void *gDslVars);
+							   
+extern  void*	SM_DECL SoftDslGetG994p1RcvNonStdInfo(void *gDslVars, ulong *pLen);
+extern  void*	SM_DECL SoftDslGetG994p1XmtNonStdInfo(void *gDslVars, ulong *pLen);
+
+#ifdef G997_1_FRAMER
+
+/* G997 functions */
+
+extern int		SM_DECL SoftDslG997SendFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+extern int		SM_DECL SoftDslG997ReturnFrame (void *gDslVars, void *pVc, ulong mid, dslFrame * pFrame);
+
+#endif
+
+#ifdef ADSL_MIB
+extern void	 *	SM_DECL	SoftDslMibGetData (void *gDslVars, int dataId, void *pAdslMibData);
+#endif
+
+#define	SoftDsl					SoftDslLineHandler
+#define	kSoftDslMaxMemorySize	(32768*16384)
+
+/*
+ * Internal functions
+ */
+
+extern  void	SoftDslStatusHandler	(void *gDslVars, dslStatusStruct *status) FAST_TEXT;
+extern  void	SoftDslInternalStatusHandler (void *gDslVars, dslStatusStruct *status);
+
+/*
+ *		DSL OS functions
+ */
+
+#ifdef DSL_OS
+
+#define	SoftDslIsBgAvailable(gDslVars)		(DSLOS_THREAD_INACTIVE == DslOsGetThreadState(&(gDslGlobalVarPtr->tcbDslBg)))
+#define	SoftDslGetBgThread(gDslVars)		\
+	((DSLOS_THREAD_INACTIVE != DslOsGetThreadState(&(gDslGlobalVarPtr->tcbDslBg))) ? &gDslGlobalVarPtr->tcbDslBg : NULL)
+#define	SoftDslBgStart(gDslVars, pFunc)		\
+	DslOsCreateThread(&gDslGlobalVarPtr->tcbDslBg, DSLOS_PRIO_HIGHEST - 10, pFunc, gDslVars,	\
+	WB_ADDR(gDslGlobalVarPtr->bgStack), sizeof(gDslGlobalVarPtr->bgStack))
+#define	SoftDslBgStop(gDslVars)				DslOsDeleteThread(&gDslGlobalVarPtr->tcbDslBg)
+
+#define	SoftDslEnterCritical()				DslOsEnterCritical()
+#define	SoftDslLeaveCritical(id)			DslOsLeaveCritical(id)
+
+#else
+
+#define	SoftDslIsBgAvailable(gDslVars)		1
+#define	SoftDslGetBgThread(gDslVars)		1
+#define	SoftDslBgStart(gDslVars, pFunc)		(*pFunc)(gDslVars)
+#define	SoftDslBgStop(gDslVars)
+
+#define	SoftDslEnterCritical()				0
+#define	SoftDslLeaveCritical(id)
+
+#endif
+
+/*
+ *		DSL frames and native frame functions
+ */
+
+DslFrameDeclareFunctions (DslFrameNative)
+
+/*
+ * These functions are for testing purpose, they are defined outside.
+ */
+#ifdef STACK_SIZE_REQUIREMENT_TEST
+extern	void		StackSizeTestInitializeStackBeforeEntry(void);
+extern	void		StackSizeTestCheckStackAfterExit(void);
+extern	void		StackSizeTestBackupStack(void);
+extern	void		StackSizeTestRestoreStack(void);
+#endif /* STACK_SIZE_REQUIREMENT_TEST */
+
+#ifdef NEC_NSIF_WORKAROUND
+#define	SoftDslGetG994NsStatus(gDslVars)		        (gDslGlobalVarPtr->G994NsStatus)
+#define	SoftDslGetG994NsFailCounter(gDslVars)		    (gDslGlobalVarPtr->G994NsFailCounter)
+#endif
+
+#endif	/* SoftDslHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModem.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModem.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModem.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,3128 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * SoftModem.h 
+ *
+ *
+ * Description:
+ *	This file contains the exported interface for SoftModem.c
+ *
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.16 $
+ *
+ * $Id: SoftModem.h,v 1.16 2004/04/14 21:16:51 ilyas Exp $
+ *
+ * $Log: SoftModem.h,v $
+ * Revision 1.16  2004/04/14 21:16:51  ilyas
+ * Merged with the latest changes in ADSL driver
+ *
+ * Revision 1.15  2004/04/13 00:56:10  ilyas
+ * Merged the latest ADSL driver changes for RTEMS
+ *
+ * Revision 1.14  2004/04/13 00:16:59  ilyas
+ * Merged the latest ADSL driver changes
+ *
+ * Revision 1.13  2003/02/22 05:07:11  ilyas
+ * Added VendorID for T1.413 mode
+ *
+ * Revision 1.12  2002/10/03 19:34:24  ilyas
+ * Added size for EOC serial number register
+ *
+ * Revision 1.11  2002/09/07 01:37:22  ilyas
+ * Added support for OEM parameters
+ *
+ * Revision 1.10  2001/12/13 02:25:34  ilyas
+ * Added definitions for G997
+ *
+ * Revision 1.9  2001/11/30 05:56:34  liang
+ * Merged top of the branch AnnexBDevelopment onto top of the tree.
+ *
+ * Revision 1.7.2.2  2001/11/27 02:32:05  liang
+ * Combine vendor ID, serial #, and version number into SoftModemVersionNumber.c.
+ *
+ * Revision 1.7.2.1  2001/10/03 01:44:10  liang
+ * Merged with codes from main tree (tag SoftDsl_2_18).
+ *
+ * Revision 1.8  2001/09/21 19:19:01  ilyas
+ * Minor fixes for VxWorks build
+ *
+ * Revision 1.7  2000/07/17 21:08:16  lkaplan
+ * removed global pointer
+ *
+ * Revision 1.6  2000/05/03 04:09:11  ilyas
+ * Added ID for ATM log data
+ *
+ * Revision 1.5  2000/04/01 01:07:44  liang
+ * Changed file names and some module names.
+ *
+ * Revision 1.4  2000/03/02 20:18:12  ilyas
+ * Added test status code for ATM VC finished
+ *
+ * Revision 1.3  1999/08/05 20:02:11  liang
+ * Merged with the softmodem top of the tree on 08/04/99.
+ *
+ * Revision 1.2  1999/01/27 22:19:08  liang
+ * Merge with SoftModem_3_1_02.
+ * Include SoftDsl.h conditionlly so that the test utilities from SoftModem
+ * can be used without major change. It can be merged easily to SoftModem.
+ *
+ * Revision 1.170  1998/12/22 00:52:52  liang
+ * Added auxFeatures bit kV8HoldANSamUntilDetCI. When it is set, ANSam won't be
+ * sent until CI is detected (normally ANSam will be sent after 200ms). This is
+ * useful in V34 half duplex fax mode.
+ *
+ * Revision 1.169  1998/12/19 04:46:52  mwg
+ * Added bits for fax/data calling tones
+ *
+ * Revision 1.168  1998/12/17 02:46:10  scott
+ * Removed overlay-related commands/statuses and added
+ * kSetTrainingDelayReductionCmd
+ *
+ * Revision 1.167  1998/12/12 03:17:42  scott
+ * Added overlay commands and statuses
+ *
+ * Revision 1.166  1998/12/02 05:34:23  mwg
+ * Fixed a problem with bong tone detection
+ *
+ * Revision 1.165  1998/11/26 00:22:44  yura
+ * Added two more log data types: modulatorInputData & modulatorOutputData
+ *
+ * Revision 1.164  1998/11/19 03:08:04  mwg
+ * Added kSetCallProgressParamsCmd
+ *
+ * Revision 1.163  1998/11/18 23:00:03  liang
+ * Added a separate command kLoopbackTestAutoRespEnableCmd to enable or disable
+ * the loopback test auto respond feature when the modem is already on-line.
+ *
+ * Revision 1.162  1998/11/13 20:50:21  scott
+ * SoftModemInternalStatusHandler is now SM_DECL as well
+ *
+ * Revision 1.161  1998/11/13 20:42:25  scott
+ * Added SM_DECL type to entrypoint functions
+ *
+ * Revision 1.160  1998/11/13 03:02:54  scott
+ * Added SoftModemTimer prototype.
+ * Also include V.8bis types if AT_COMMANDS_V8BIS is defined.
+ *
+ * Revision 1.159  1998/11/12 01:22:46  scott
+ * Increased number of AT registers to 46
+ *
+ * Revision 1.158  1998/11/05 22:35:18  yura
+ * Added two more S-registers
+ *
+ * Revision 1.157  1998/11/05 03:09:54  mwg
+ * Added kLapmRetryFailed to the list of LAPM errors
+ *
+ * Revision 1.156  1998/11/05 00:13:20  liang
+ * Add new connectionInfo status kLoopbackSelfTestNewErrs to report
+ * new bit errors whenever it happens.
+ *
+ * Revision 1.155  1998/11/04 07:11:33  mwg
+ * Moved declaration for SoftModemATPrintf() to SoftModem.h
+ *
+ * Revision 1.154  1998/10/29 07:24:49  mwg
+ * *** empty log message ***
+ *
+ * Revision 1.153  1998/10/15 02:09:37  luisgm
+ * added separate data rate mask for Flex to dataPumpCapabilities structure
+ *
+ * Revision 1.152  1998/10/14 00:12:15  scott
+ * Added kMnpOOBFrameCmd and command.frameSpec
+ *
+ * Revision 1.151  1998/10/09 02:19:22  luisgm
+ * added FlexV8bisStruct member to dataPumpCapabilities struc to store flex v8bis info, added define for kFlexSkipV8bis
+ *
+ * Revision 1.150  1998/10/06 19:36:33  mwg
+ * Limited 56K rates to 53K
+ *
+ * Revision 1.149  1998/10/03 03:43:38  ilyas
+ * Added status codes for Audio
+ *
+ * Revision 1.148  1998/10/01 02:03:17  mwg
+ * Added external pulse dialer option
+ *
+ * Revision 1.147  1998/09/30 01:44:26  mwg
+ * Added new functions SoftModemGetWriteBufferSize() & SoftModemGetReadBufferSize()
+ *
+ * Revision 1.146  1998/09/22 03:44:38  scott
+ * Added ALWAYS_LONG_ALIGN() macro
+ *
+ * Revision 1.145  1998/09/21 21:49:22  scott
+ * Added logDataCodes for mnpDecoder(Input/Output)Data
+ *
+ * Revision 1.144  1998/08/31 22:57:21  luisgm
+ * added constants for Flex data rates + kFlexEventTRN2AFinished
+ *
+ * Revision 1.143  1998/08/18 05:09:53  mwg
+ * Increased AT command buffer size to 128
+ *
+ * Revision 1.142  1998/08/18 03:45:54  ilyas
+ * Integrated Audio into V70 test
+ *
+ * Revision 1.141  1998/08/14 17:46:04  ilyas
+ * Integrated Audio and G729a
+ *
+ * Revision 1.140  1998/08/10 21:42:19  mwg
+ * Added space and mark parity
+ *
+ * Revision 1.139  1998/08/08 03:39:33  scott
+ * Moved the C6xDefs and PentiumDefs includes before the internal function
+ * prototypes (to permit their redefinitions)
+ *
+ * Revision 1.138  1998/08/07 20:37:27  yura
+ * Added new S-register for &T commands
+ *
+ * Revision 1.137  1998/08/01 05:22:09  mwg
+ * Implemented split memory model
+ *
+ * Revision 1.136  1998/07/22 02:12:22  liang
+ * Added self test mode for loopback test.
+ *
+ * Revision 1.135  1998/07/21 01:19:03  liang
+ * Changed loopback test command parameter interface to use regular modeSpec.
+ *
+ * Revision 1.134  1998/07/18 03:52:10  liang
+ * Added V54 loop 2 test for V22.
+ *
+ * Revision 1.133  1998/07/15 02:45:03  mwg
+ * Added new connection info code: kPCMSpectralShapingBits
+ *
+ * Revision 1.132  1998/07/15 00:18:48  liang
+ * Add special turn off command for V34 fax to handle different turn off procedures.
+ *
+ * Revision 1.131  1998/07/13 22:19:49  liang
+ * Add V8 CI detection status and ANSam disable aux feature.
+ *
+ * Revision 1.130  1998/07/08 17:09:13  scott
+ * Added USE_LONG_ALIGN; support for 6 and PentiumDefs.h files
+ *
+ * Revision 1.129  1998/07/03 23:28:13  mwg
+ * Added Fax Class 2 defines
+ *
+ * Revision 1.128  1998/07/03 23:17:33  mwg
+ * Insuread command/status structures are long aligned
+ *
+ * Revision 1.127  1998/06/23 16:48:01  mwg
+ * Fixed a longstanding problem typical for Win95 VxD: whenever new
+ * VxD is intalled the confuguration profile may not match the old one but
+ * since the crc is correct it is still being downloaded. To avoid the problem
+ * a crc for the version number was added to avoid confusion between profiles
+ * of different versions.
+ *
+ * Revision 1.126  1998/06/19 21:04:06  liang
+ * Add auxiliary feature bit kV90ServerNotDetSbarAfterJdbarFix.
+ *
+ * Revision 1.125  1998/06/11 22:48:14  liang
+ * Add kPCM28000bpsShift constant.
+ *
+ * Revision 1.124  1998/06/05 22:11:51  liang
+ * New V90 DIL works through data mode.
+ *
+ * Revision 1.123  1998/06/01 23:03:41  liang
+ * Add v90RcvdDilDiffData logging.
+ *
+ * Revision 1.122  1998/06/01 21:24:38  mwg
+ * Changed some of the names.
+ *
+ * Revision 1.121  1998/05/13 04:55:22  mwg
+ * Now passing the number of spectral shaping bits in aux features
+ *
+ * Revision 1.120  1998/05/13 02:53:13  liang
+ * Add field "value" to command param structure.
+ *
+ * Revision 1.119  1998/05/12 04:42:23  mwg
+ * Replaced some of the status messages
+ *
+ * Revision 1.118  1998/05/11 23:36:10  mwg
+ * Added 8000Hz symbol rate to the map
+ *
+ * Revision 1.117  1998/05/05 04:28:39  liang
+ * V90 works up to data mode first version.
+ *
+ * Revision 1.116  1998/04/21 09:36:45  mwg
+ * Fixed a few problems for 16Khz and added 32Khz.
+ *
+ * Revision 1.115  1998/04/17  22:33:54  liang
+ * Added V90 DIL for mu-law PCM.
+ *
+ * Revision 1.114  1998/04/15  22:36:39  mwg
+ * Added new parameters to kDialCmd to allow individual control of each
+ * DTMF group attenuation.
+ *
+ * Revision 1.113  1998/04/15 18:16:22  ilyas
+ * Integrated V.8bis and changed coding of LinkLayerType to bitMap
+ *
+ * Revision 1.112  1998/04/15 07:59:06  mwg
+ * Added new status codes for V.90
+ *
+ * Revision 1.111  1998/04/11 00:29:16  mwg
+ * Fixed the warnings which appeared when Irix builds were upgraded to
+ * gcc 2.8.1
+ *
+ * Revision 1.110  1998/04/11  00:25:01  ilyas
+ * More V.70 statuses
+ *
+ * Revision 1.109  1998/04/10 23:29:31  mwg
+ * Added new field to capabilities: dataRates56K
+ *
+ * Revision 1.108  1998/04/09 02:02:56  mwg
+ * Added status for Ja detection.
+ *
+ * Revision 1.107  1998/04/03 02:05:30  ilyas
+ * More V.70 commands added
+ *
+ * Revision 1.106  1998/04/02 06:15:39  mwg
+ * Added coding type (Mu-law/A-law) status reporting.
+ *
+ * Revision 1.105  1998/03/30 09:53:57  mwg
+ * Added definition for k56Flex modulation for future use.
+ *
+ * Revision 1.104  1998/03/27  17:56:09  ilyas
+ * Added definitions for V.70
+ *
+ * Revision 1.103  1998/03/26 23:29:04  liang
+ * Added first version of IMD estimation.
+ *
+ * Revision 1.102  1998/03/20  04:37:26  mwg
+ * Increased the size of the nominal variance to 32 bit.
+ *
+ * Revision 1.101  1998/03/06 01:22:04  yura
+ * Improved Win95 VxD segmentation handling
+ *
+ * Revision 1.100  1998/03/06  01:06:18  liang
+ * Add initial version of V90 phase 1 and 2.
+ *
+ * Revision 1.99  1998/03/05  23:42:22  mwg
+ * (hxl) Implemented enable/disable call waiting command.
+ *
+ * Revision 1.98  1998/02/26  06:13:06  mwg
+ * Increased the number of AT S-registers to account for newly introduced
+ * S9 and S10.
+ *
+ * Revision 1.97  1998/02/25  18:18:25  scott
+ * Added v42bisCycleCount for V42BIS_THROUGHPUT_CONTROL
+ *
+ * Revision 1.96  1998/02/24 05:31:20  mwg
+ * Added stuff required by international version of AT command processor.
+ *
+ * Revision 1.95  1998/02/17  01:14:10  scott
+ * Reenabled sys/types.h for Linux builds
+ *
+ * Revision 1.94  1998/02/16 22:32:23  scott
+ * Changed copyright notice
+ *
+ * Revision 1.93  1998/02/16 22:17:44  scott
+ * Turned off include of sys/types.h for normal builds
+ *
+ * Revision 1.92  1998/02/16 21:53:28  scott
+ * Exclude sys/types.h for another compiler
+ *
+ * Revision 1.91  1998/02/09 18:24:10  scott
+ * Fixed ComplexShort type to work around bugs in MS and GreenHill compilers
+ *
+ * Revision 1.90  1998/01/27 01:37:36  mwg
+ * Added new log identifier for pcm infidelity data.
+ *
+ * Revision 1.89  1998/01/22  19:49:32  liang
+ * Add auxFeature bit kFaxV34HDXAllowAsymCtrlChan.
+ *
+ * Revision 1.88  1998/01/21  02:32:01  liang
+ * Add more V34 half duplex training progress codes.
+ *
+ * Revision 1.87  1997/12/23  03:28:25  liang
+ * Add more half duplex V34 related constants.
+ *
+ * Revision 1.86  1997/12/18  19:38:50  scott
+ * Added agcData log type.
+ * Added kDisableFaxFastClearDown demod capability
+ *
+ * Revision 1.85  1997/12/18 06:02:45  mwg
+ * Added a function to reenable DC offset tracking.
+ *
+ * Revision 1.84  1997/12/17  22:46:30  mwg
+ * Minor modifications to X2 escape status reporting.
+ *
+ * Revision 1.83  1997/12/16  06:49:45  mwg
+ * Implemented proper data rate reporting for PCM modem.
+ *
+ * Revision 1.82  1997/12/13  06:11:08  mwg
+ * Added X2 interface hooks
+ *
+ * Revision 1.81  1997/12/02 06:21:33  mwg
+ * Implemented kSetATRegister command.
+ *
+ * Revision 1.80  1997/11/27  02:11:41  liang
+ * Add code for half duplex V34 control channel.
+ *
+ * Revision 1.79  1997/11/19  19:52:48  guy
+ * Added constant to define V.34 half duplex operation
+ *
+ * Revision 1.78  1997/10/24 05:15:53  scott
+ * Added AGC and phase hit recovery to demodCapabilities
+ *
+ * Revision 1.77  1997/10/01 02:47:50  liang
+ * Add PCM interface.
+ *
+ * Revision 1.76  1997/09/29  15:48:04  yura
+ * Added #pragma statement for W95 Vxd
+ *
+ * Revision 1.75  1997/09/18 20:32:39  scott
+ * Do not include VxD support files if GENERATE_DEPENDENCIES is defined.
+ *
+ * Revision 1.74  1997/09/18 12:40:55  yura
+ * Removed #ifdef statments to be more robust
+ *
+ * Revision 1.73  1997/09/17 17:32:41  scott
+ * Do not include sys/types.h for 6
+ *
+ * Revision 1.72  1997/08/08 00:53:48  mwg
+ * Added fields for LAP-M frames printout.
+ * Added fields in auxFeatures to pass preemphasis filter parameters
+ * to V.34 phase 3 when doing PTT testing.
+ *
+ * Revision 1.71  1997/08/06  03:41:45  yura
+ * Added a few includes and defines needed by Win 95 driver.
+ *
+ * Revision 1.70  1997/08/05  03:22:10  liang
+ * Add equalizer center tap adjustment calculation related constants.
+ *
+ * Revision 1.69  1997/07/29  02:44:19  mwg
+ * Added new field to dataPumpCapabilities structure. This field is not
+ * yet exposed to external interface and currently is only used to
+ * enable PTT testing.
+ * Added new commands: kStartDataModemPTTTestCmd & kStartDataModemLoopbackTestCmd
+ *
+ * Revision 1.68  1997/07/22  22:05:10  liang
+ * Change sample rate setup as a normal command.
+ *
+ * Revision 1.67  1997/07/21  23:23:30  liang
+ * Define SoftModemSetSampleRate as null when SAMPLE_RATE_CONVERSION is not defined.
+ *
+ * Revision 1.66  1997/07/21  22:38:36  liang
+ * Change sample rate converter structure so that sample rate can be changed
+ * on the fly (at very begining) to either 8KHz or 9600Hz.
+ *
+ * Revision 1.65  1997/07/21  20:22:01  mwg
+ * Added statusInfoData to the log identifiers.
+ *
+ * Revision 1.64  1997/07/16  20:40:07  scott
+ * Added multitone monitor fields
+ *
+ * Revision 1.63  1997/07/10 02:31:08  mwg
+ * 1. Added kRxFrameHDLCFlags detected status for the
+ *    framingInfo.
+ * 2. Added kLapmMNPFrameDetected status to lapmStatusCode.
+ * 3. Increased the number of AT registers to 35
+ * 4. Modified LinkLayerSpec structure in modemCommandStruc
+ *    to provide the initial values of rxDataRate &
+ *    txDataRate and RT delay for the cases when
+ *    link layer is started *after* the data connection
+ *    is established and the status snooper is unable
+ *    to determine the rates and RT delay.
+ * 5. Added a few extra *empty* constant definitions for
+ *    disabled features.
+ *
+ * Revision 1.62  1997/07/02  19:15:05  scott
+ * Added bits for Bel103 & Bel212 modulations.
+ *
+ * Revision 1.61  1997/07/02 05:15:16  mwg
+ * Added MNP code.
+ *
+ * Revision 1.60  1997/07/01  23:52:48  mwg
+ * Modified the record test setup to log and use all the commands.
+ *
+ * Revision 1.59  1997/06/25  19:11:26  mwg
+ * 1. Added new framingInfoCode values for Async framing error reporting;
+ * 2. Added a substructure to pass serial data format for kSetDTERate cmd;
+ *
+ * Revision 1.58  1997/05/28  02:05:08  liang
+ * Add PCM modem phase 2 codes.
+ *
+ * Revision 1.57  1997/05/12  21:55:08  liang
+ * Add call waiting tone detector module.
+ *
+ * Revision 1.56  1997/03/21  23:50:08  liang
+ * Added initial version of V8bis module to CVS tree.
+ *
+ * Revision 1.55  1997/03/19  18:35:05  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.54  1997/03/11  11:11:45  mwg
+ * Added code to report V42bis statistics.
+ *
+ * Revision 1.53  1997/03/04  06:21:08  mwg
+ * Added logging of most commands.
+ *
+ * Revision 1.52  1997/02/28  23:45:13  liang
+ * Added training progress status report kPhaseJitterDeactivated.
+ *
+ * Revision 1.51  1997/02/28  22:23:22  mwg
+ * Implemented the following features:
+ * - Cleardown for fax modulations V.27, V.29 V.17
+ * - Rockwell compatible bitmap report (needed by a customer)
+ *
+ * Revision 1.50  1997/02/28  03:05:31  mwg
+ * Added more logging data types.
+ *
+ * Revision 1.49  1997/02/27  05:28:58  mwg
+ * Added RxFrameOK report.
+ *
+ * Revision 1.48  1997/02/27  01:48:53  liang
+ * Add kV8MenuDataWord1 and kV8MenuDataWord2 connectionInfo status.
+ *
+ * Revision 1.47  1997/02/24  02:30:27  mwg
+ * Added new log  data: predictorErrData
+ *
+ * Revision 1.46  1997/02/22  03:00:22  liang
+ * Add echoCancelledSignalData.
+ *
+ * Revision 1.45  1997/02/21  01:26:42  liang
+ * Add six more bits for the Demodulator capabilities to deal with 2nd order
+ * time tracking & PLLs, as well as shorter NEEC & PFEEC, and front end HBF.
+ *
+ * Revision 1.44  1997/02/17  03:09:00  mwg
+ * Added LAPM statistics printout.
+ *
+ * Revision 1.43  1997/02/04  08:38:47  mwg
+ * Added dc cancelled samples printout.
+ *
+ * Revision 1.42  1997/01/29  21:40:28  mwg
+ * Changed the way timers work: now time is passed as Q4 ms instead of ticks.
+ * Completed the 8KHz front end implementation.
+ * Got rid of kSamplesPerSecond constant.
+ *
+ * Revision 1.41  1997/01/24  07:13:50  mwg
+ * Added new statuses for automoder.
+ *
+ * Revision 1.40  1997/01/23  02:03:08  mwg
+ * Replaced old sample rate conversion with the newer one.
+ * Still has to resolve the automoding issue.
+ *
+ * Revision 1.39  1997/01/21  00:55:04  mwg
+ * Added 8KHz front end functionality.
+ *
+ * Revision 1.38  1996/11/13  00:30:55  liang
+ * Add kAutoLoadReductionEnabled to demodCapabilities so that PFEEC, FEEC, IEEC
+ * can be disabled automatically, but for worst processor loading test they
+ * won't be disabled when this bit is not set.
+ *
+ * Revision 1.37  1996/11/07  23:07:18  mwg
+ * Rearranged global variables to allow V.17 short training.
+ *
+ * Revision 1.36  1996/09/17  23:55:05  liang
+ * Change kMaxDataBlockSize from 16 to 24 to handle high data rates.
+ *
+ * Revision 1.35  1996/09/05  19:43:39  liang
+ * Removed caller ID error status code kCallerIDUnknownMessageType, and
+ * added caller ID status codes kCallerIDUnknownMessage & kCallerIDWholeMessage.
+ * Changed the callerIDStatus report structure.
+ *
+ * Revision 1.34  1996/08/29  00:36:57  liang
+ * Added kLapmTxFrameStatus and kLapmRxFrameStatus.
+ *
+ * Revision 1.33  1996/08/27  22:56:01  liang
+ * Added kResetHardware status code.
+ *
+ * Revision 1.32  1996/08/23  23:35:35  liang
+ * Add kATDebugStatus and function SoftModemGetHybridDelay.
+ *
+ * Revision 1.31  1996/08/22  01:13:19  yg
+ * Added AT command processor.
+ *
+ * Revision 1.30  1996/08/12  21:46:47  mwg
+ * Added code to report capabilities.
+ *
+ * Revision 1.29  1996/08/10  01:59:59  mwg
+ * Added report of the sent rate sequence;
+ *
+ * Revision 1.28  1996/08/07  22:15:02  mwg
+ * Added new status reports:
+ * kRemoteFreqOffset
+ * kIEECDeactivated
+ * kPFEECDeactivated
+ *
+ * Revision 1.27  1996/06/27  05:15:48  mwg
+ * Added V.24 circuit status.
+ *
+ * Revision 1.26  1996/06/27  02:12:43  mwg
+ * Cleaned the code.
+ *
+ * Revision 1.25  1996/06/20  23:57:30  mwg
+ * Added new training progress status.
+ *
+ * Revision 1.24  1996/06/18  21:13:50  mwg
+ * Added trellis MSE data logging.
+ *
+ * Revision 1.23  1996/06/12  02:31:10  mwg
+ * Added new type: VeryLong
+ *
+ * Revision 1.22  1996/06/08  22:15:39  mwg
+ * Added new status report: kCleardownStarted
+ * Added new field for the features: kV34bisEnabled
+ *
+ * Revision 1.21  1996/05/31  00:29:11  liang
+ * Add feature bit kV34ExtraINFOPreamble.
+ *
+ * Revision 1.20  1996/05/30  23:28:31  mwg
+ * Replaced enums with #defines
+ *
+ * Revision 1.19  1996/05/25  00:38:27  mwg
+ * Added kProjectedDataRate training progress report.
+ *
+ * Revision 1.18  1996/05/24  23:27:15  mwg
+ * Added mode status codes.
+ *
+ * Revision 1.17  1996/05/10  05:39:59  liang
+ * Move the includes for DEBUG inside "ifndef SoftModemTypes" so that
+ * cap build won't break.
+ *
+ * Revision 1.16  1996/05/08  01:49:34  mwg
+ * Added capability to setup auxiliary data channel handlers.
+ *
+ * Revision 1.15  1996/05/07  22:51:08  liang
+ * Added group delay estimation and improved symbol rate selection process.
+ *
+ * Revision 1.14  1996/05/06  06:49:09  mwg
+ * Fixed linux problems.
+ *
+ * Revision 1.13  1996/05/02  08:40:16  mwg
+ * Merged in Chromatic bug fixes.
+ *
+ * Revision 1.12  1996/05/02  02:26:21  mwg
+ * Added code to implement dozing functionality for v.34.
+ *
+ * Revision 1.11  1996/05/01  22:43:13  mwg
+ * Added new command: kDozeCmd;
+ *
+ * Revision 1.10  1996/05/01  19:20:16  liang
+ * Add command codes kInitiateRetrainCmd and kInitiateRateRenegotiationCmd.
+ *
+ * Revision 1.9  1996/04/25  01:12:37  mwg
+ * Added new flag: rapid preliminary EC training.
+ *
+ * Revision 1.8  1996/04/20  02:26:22  mwg
+ * Added preliminary far-end echo support
+ *
+ * Revision 1.7  1996/04/15  23:26:16  mwg
+ * Changed flag definitions for v34 modem.
+ *
+ * Revision 1.6  1996/04/04  02:35:50  liang
+ * Change kCid from 0x0080 to 0x0004 (0x0080 is defined as kV32).
+ *
+ * Revision 1.5  1996/03/08  23:07:01  mwg
+ * Added name for the struct.
+ *
+ * Revision 1.4  1996/03/02  00:59:27  liang
+ * Added typedef for V34CodingParameters structure.
+ *
+ * Revision 1.3  1996/02/27  02:28:31  mwg
+ * Fixed a bug in kLapmLongADPEnabled definition.
+ *
+ * Revision 1.2  1996/02/19  23:50:59  liang
+ * Removed compressionSetup parameter from the link layer command structure.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.5  1996/01/15  23:26:04  liang
+ * Change the softmodem command structure name from SoftwareModemCommand
+ * to SoftwareModemCommandParameters.
+ *
+ *****************************************************************************/
+#ifndef	SoftModemPh
+#define	SoftModemPh
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.1	General types														*/
+/****************************************************************************/
+
+#ifndef SM_DECL
+#define SM_DECL
+#endif
+
+#ifdef __VxWORKS__
+#include <types/vxTypesOld.h>
+#endif
+
+#ifdef DEBUG
+/* We have to define __wchar_t for Linux	*/
+#if defined __linux__ && !defined _NO_WHCAR_DEF_
+typedef	long int __wchar_t;
+#endif
+#if !defined(__KERNEL__) && !defined(_CFE_)
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+#if defined(__linux__) || defined (__unix__) || defined (__unix) || (defined (__mips__) && !defined(_CFE_) && !defined(VXWORKS) && !defined(TARG_OS_RTEMS))/* enable if necessary, but not for dos-based builds */
+#include <linux/types.h>
+#endif
+
+
+#endif	/* DEBUG */
+
+#if defined(W95_DRIVER) 
+#pragma code_seg("_LTEXT", "LCODE")
+#pragma data_seg("_LDATA", "LCODE")
+#pragma const_seg("_LDATA", "LCODE")
+#pragma bss_seg("_LDATA", "LCODE")
+#pragma pack(1)
+#endif /* W95_DRIVER */
+
+#ifndef SoftModemTypes
+#include "SoftModemTypes.h"
+#endif	/* SoftModemTypes */
+
+
+typedef struct
+	{
+	schar x, y;
+	} ComplexByte;
+
+typedef struct
+	{
+	uchar numerator;
+	uchar denominator;
+	} Ratio;
+
+#ifdef PEGASUS
+typedef union
+	{
+	struct
+		{
+		short x, y;
+		};
+	
+	long foo;
+	} ComplexShort;
+#else
+typedef struct
+	{
+	short x, y;
+#ifdef GREENHILL
+    long a[0];
+#endif
+	} ComplexShort;
+#endif
+
+typedef struct
+	{
+	long x, y;
+	} ComplexLong;
+
+typedef struct
+	{
+	ushort 	x0, x1, x2;
+	short	x3;
+	} VeryLong;
+
+typedef union
+	{
+	struct
+		{
+		uchar number;
+		uchar defaultValue;			/* default value */			
+		uchar maxValue;			/* max allowed value */
+		uchar minValue;			/* should be greater then maxValue to make reg readonly */
+		} param;
+	long alignment;
+	} SRegisterDefinition;
+
+#define MacroPaste2(a,b) a##b
+#define MacroPaste(a,b) MacroPaste2(a,b)
+#define ALWAYS_LONG_ALIGN() long MacroPaste(ALIGNMENT,__LINE__);
+
+#ifdef USE_LONG_ALIGN
+#define LONG_ALIGN() ALWAYS_LONG_ALIGN()
+#else
+#define LONG_ALIGN()
+#endif
+
+typedef	ulong	bitMap;
+
+typedef	int	pace;
+#define kStop		0
+#define kVerySlow	1
+#define kSlow		2
+#define kMedium		3
+#define kFast		4
+
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.2	Modem specific types												*/
+/****************************************************************************/
+
+typedef	long directionType;
+#define kXmt	0
+#define kRcv	1
+#define kXmtRcv	2
+
+
+#define	originating		kXmt
+#define	answering		kRcv
+#define	kOrg			kXmt
+#define	kAns			kRcv
+#define	kOrgAns			kXmtRcv
+
+#define	ORIGINATING		originating
+#define	ANSWERING		answering
+
+typedef	int	pcmCodingType;
+#define	kMuLawPCM	0
+#define	kALawPCM	1
+
+#define	kMuLawPCMScaleShift		2
+#define	kALawPCMScaleShift		3
+
+/* link layer and framer share defines */
+typedef	bitMap	framerType;
+typedef	bitMap	linkLayerType;
+#define kNoFramer	0
+#define kSync		0x00000001
+#define kAsync		0x00000002
+#define kHDLC		0x00000004
+#define kLapm		0x00000008
+#define kMnp		0x00000010
+#define kV70		0x00000020
+#define kSAM		0x00000040
+
+	
+typedef	bitMap	modulationMap;
+typedef	bitMap	symbolRateMap;
+typedef	bitMap	dataRateMap;
+typedef	bitMap	featureMap;
+typedef	bitMap	breakType;
+
+typedef	bitMap	audioType;
+#define	kRawAudio		0
+#define	kAudioG729A		1
+#define	kAudioG729		2
+#define	kAudioG723		3
+
+
+#ifndef ADSL_MODEM
+typedef long	modemStatusCode;
+#endif
+	/* Information status Codes: 1-31		*/
+#define kSetSampleRate				1
+#define kModulationKnown			2
+#define kRxSymbolRate				3
+#define kTxSymbolRate				4
+#define kRxCarrierFreq				5
+#define kTxCarrierFreq				6
+#define kTxPreemphasisFilter		7
+#define kTxPowerAdjustment			8
+#define kRemoteTxPreemphasisFilter	9
+#define kRemoteTxPowerAdjustment	10
+#define kRxRateKnown				11
+#define kTxRateKnown				12
+#define kRxDataModeActive			13
+#define kTxDataModeActive			14
+#define kTxSignalCompleted			15
+#define kDTMFSignalDetected			16
+#define kModemSignalDetected		17
+#define kCallProgressSignalDetected	18
+#define kCustomSignalDetected		19
+#define kFaxPreambleDetected		20
+#define kV24CircuitStatusChange		21
+#define kHookStateChange			22
+#define kCallWaitingToneDetected	23
+#define kMultiToneSignalDetected	24
+#define kPulseShuntStateChange		25
+#define kRingFrequency              26
+
+
+	/* Warning status Codes:		32-64	*/
+#define kError						32
+#define kV34Exception				33
+#define kClearDownLocal				34
+#define kClearDownRemote			35
+#define kCarrierPresent				36
+#define kCarrierLost				37
+#define kRetrainingLocal			38
+#define kRetrainingRemote			39
+#define kRateRenegotiationLocal		40
+#define kRateRenegotiationRemote	41
+#define kFallbackStarted			42
+#define kFallForwardStarted			43
+#define kCleardownStarted			44
+#define kIllegalCommand				45
+	
+	/* Auxiliary status Codes:	64-..	*/	
+#define kTrainingProgress			64
+#define kConnectionInfo				65
+#define kDialerStatus				66
+#define kFramingInfo				67
+#define kBreakReceived				68
+#define kLapmStatus					69
+#define kLapmParameter				70
+#define kV42bisStatus				71
+#define kCallerIDStatus				72
+#define kIOStatus					73
+#define kCapabilitiesStatus			74
+#define kSpeakerStatus				75
+#define kATProfileChanged			76
+#define kATDebugStatus				77
+#define	kResetHardware				78
+#define	kV8bisStatus				79
+#define kMnpStatus					80
+#define kMnpParameter				81
+#define kV70Status					82
+#define kV70Parameter				83
+#define kFaxClass2Status			84
+#define kAudioStatus				85
+#define kAudioParameter				86
+#define kOverlayStatus				87
+#define kCallerIDCircuitStatus		88
+#define kV80Status					89
+#define kV80Parameter				90
+#define kLocalCountryChanged		91
+#define kDTERateChanged				92
+#define kATResponse					93
+#define kFramerConfigured			94
+#define kA8RStatus					95
+#define kA8TStatus					96
+#define	kVersionStatus				97
+
+	/* Testing status codes:	128-...	*/
+	/* These statuses are generated by modem test suit	*/
+#define kTestFinished				128
+#define kConnectivityTestFinished	129
+#define kTestCheckSum				130
+#define kLogFileControl				131
+#define kTestAtmVcFinished			132
+#define kTestClearEocFinished		133
+#define kTestG997Finished			134
+
+typedef long	modemErrorCode;
+#define kNoError				0
+#define kErrorTimerExpired		1
+#define kErrorNoSReceived		2
+#define kErrorNoSbarReceived	3
+
+
+typedef long	dialerStatusCode;
+#define kDialCompleted				0
+#define kNoDialToneDetected			1
+#define kBongToneDetected			2
+#define kNoBongToneDetected			3
+#define kErrorIllegalDialModifier	5
+#define kDialStarted				6
+#define kExternalPulseDialDigit		7
+
+
+typedef long	framingInfoCode;
+#define kRxFrameOK					0
+#define kRxFrameTooLong				1
+#define kRxFrameCRCError			2
+#define kTxFrameUnderrun			3
+#define kRxFrameOverrun				4
+#define kRxFrameAborted				5
+#define kRxFrameParityError			6
+#define kRxFrameFormatError			7
+#define	kRxFrameHDLCFlagsDetected	8
+
+
+typedef long	IOStatusCode;
+#define kRxDataReady		0
+#define kRxBufferOverflow	1
+#define kTxSpaceAvailable	2
+#define kTxBufferEmpty		3
+
+typedef long	capabilitiesStatusCode;
+#define kSymbolRates				0
+#define kDataRates					1
+#define kFeatures					2
+#define kDemodCapabilities			3
+#define kRateThresholdAdjustment	4
+#define kXmtLevel					5
+#define kHybridDelay				6
+#define kAuxFeatures				7
+
+
+typedef long	A8TStatusCode;
+#define kA8TFinished				0
+
+typedef long	callerIDStatusCode;
+#define kCallerIDError					0
+#define kCallerIDChannelSeizureReceived	1
+#define kCallerIDMarkSignalReceived		2
+#define kCallerIDTime					3
+#define kCallerIDTelnum					4
+#define kCallerIDName					5
+#define kCallerIDEnd					6
+#define kCallerIDUnknownMessage			7
+#define kCallerIDWholeMessage			8
+
+
+typedef long	callerIDErrorCode;
+#define kCallerIDNoError			0
+#define kCallerIDMarkSignalError	1
+#define kCallerIDTooManyMarkBits	2
+#define kCallerIDMessageTooLong		3
+#define kCallerIDChecksumError		4
+
+
+typedef long	connectionInfoCode;
+#define kRTDelay			1
+#define kRxSignalLevel		2
+#define kTimingOffset		3
+#define kFreqOffset			4
+#define kPhaseJitter		5
+#define kSNR				6
+#define kNearEchoLevel		7
+#define kSER				8
+#define kNearEndDelay		9
+#define kFarEchoLevel		10
+#define kL1L2SNRDifference	11
+#define	kDCOffset			12
+#define	kTotalRxPower		13
+#define	kRemoteFreqOffset	14
+/* obsolete	#define	kV8MenuDataWord1	15 */
+/* obsolete	#define	kV8MenuDataWord2	16 */
+#define	kPCMP2AnalogDetSNR	17
+#define	kPCMP2DigitalDetSNR	18
+#define	kPCMP2RBSDetSNR		19
+#define	kEqCenterTapOffset	20
+#define	kPCMPadValue		21
+#define	kPCMRBSMap			22
+#define	kPCMCodingType		23
+#define	kPCMSpectralShapingBits			24
+#define	kLoopbackSelfTestResult			25
+#define	kEyeQuality						26
+#define	kLoopbackSelfTestNewErrs		27
+#define kV34EqlLengthStatus 28
+#define kV34EqlOffsetStatus 29
+#define	kV8CallMenuData		30
+#define	kV8JointMenuData	31
+#define kPCMClientIeecLengthStatus 32
+#define kPCMClientIeecOffsetStatus 33
+#define	kSeamlessRateChange	34
+
+typedef long	trainingProgressCode;
+#define kPeriodicalSignalDetected		0
+#define kPhaseReversalDetected			1
+#define kSignalStartDetected			2
+#define kSignalEndDetected				3
+#define kSSignalDetected				4
+#define kSbarSignalDetected				5
+#define kJ4SignalDetected				6
+#define kJ16SignalDetected				7
+#define kJprimeSignalDetected			8
+#define kMPSignalDetected				9
+#define kMPprimeSignalDetected			10
+#define kMPSignalSent					11
+#define kMPprimeSignalSent				12
+#define kRateSignalDetected				13
+#define kESignalDetected				14
+#define kRateSignalSent					15
+
+#define	kAutomodingTryModulation		16
+#define	kAutomodingCompleted			17
+#define	kRCFaxBitMapStatus				18
+	
+#define kV8CIDetected					19
+#define kV8ANSToneDetected				20
+#define kV8ANSamDetected				21
+#define kV8CMDetected					22
+#define kV8JMDetected					23
+#define kV8CJDetected					24
+#define kV8Finished						25
+	
+#define kV34Phase2Started				26
+#define kV34Phase2INFOSequenceDetected	27
+#define kV34Phase2NearEndEchoDetected	28
+#define kV34Phase2L1Receiving			29
+#define kV34Phase2L2Receiving			30
+#define kV34Phase2Finished				31
+#define kV34Phase3Started				32
+#define kV34Phase3Finished				33
+#define kV34Phase4Started				34
+#define kV34Phase4Finished				35
+#define kV34DecoderParameters			36
+#define kV34EncoderParameters			37
+
+#define kMaxLocalRxDataRate				38
+#define kMaxLocalTxDataRate				39
+#define kMaxRemoteRxDataRate			40
+#define kMaxRemoteTxDataRate			41
+#define kProjectedDataRate				42
+#define kFEECDeactivated				43
+#define kIEECDeactivated				44
+#define kPFEECDeactivated				45
+#define kPhaseJitterDeactivated			46
+
+#define	kPCMP2DetectedDigitalConnection	47
+#define	kPCMP2DetectedRBS				48
+#define	kX2DetectedPhase1Escape			49
+
+#define kStarted1200BpsTraining			50
+#define kStarted2400BpsTraining			51
+#define kUnscrambledOneDetected			52
+#define kScrambled1200BpsOneDetected	53
+#define kScrambled2400BpsOneDetected	54
+#define kV22BisS1Detected				55
+#define	kV22InitiateLoop2Test			56
+#define	kV22RespondLoop2Test			57
+#define	kV22Loop2TestAlt01Detected		58
+
+#define	kDataModemLoop1TestStarted		59
+#define	kDataModemLoop1TestFinished		60
+#define	kDataModemLoop2TestStarted		61
+#define	kDataModemLoop2TestFinished		62
+#define	kDataModemLoop3TestStarted		63
+#define	kDataModemLoop3TestFinished		64
+#define	kDataModemSelfLoopTestEnabled	65
+
+#define kPCMPhase3Started				70
+#define kPCMPhase3Finished				71
+#define kPCMPhase4Started				72
+#define kPCMPhase4Finished				73
+
+#define	kV90JaSignalDetected			74		
+#define	kV90JdSignalDetected			75		
+#define	kV90JdPrimeSignalDetected		76		
+#define	kV90RSignalDetected				77		
+#define	kV90RBarSignalDetected			78	
+#define	kV90CPSignalDetected			79	
+
+#define	kV90CPtSignalSent				80
+#define	kV90CPSignalSent				81
+#define	kV90CPprimeSignalSent			82
+
+
+#define	kV34SeamlessRateChangeRequestSent		83
+#define	kV34SeamlessRateChangeUpdateSent		84
+#define	kV34SeamlessRateChangeRequestReceived	85
+#define	kV34SeamlessRateChangeUpdateReceived	86
+#define	kV34SeamlessRateChangeUpdateTimeout		87
+
+#define kV90JaSignalAcknowledged				88
+
+#define	kV34HCtrlChanPPhDetected		100
+#define	kV34HCtrlChanMPhDetected		101
+#define	kV34HCtrlChanRatesKnown			102
+#define	kV34HDXCtrlChanBinary1Detected	103
+#define	kV34HDXPhase3Started			104
+#define	kV34HDXPhase3Finished			105
+#define	kV34HDXPrimChanBinary1Detected	106
+#define kFlexEventTRN2AFinished         107
+
+#define kV32RanginigStarted				108
+#define kV32RangingStarted				108
+#define kV32RanginigFinished			109
+#define kV32RangingFinished				109
+
+
+typedef long	lapmStatusCode;
+#define kLapmDisconnected			0	/* LAPM disconnected */
+#define kLapmConnected				1	/* LAPM is connected */
+#define kLapmV42ODPDetected			2	/* LAPM ODP is detected	*/
+#define kLapmV42ADPDetected			3	/* LAPM V.42 ADP is detected	*/
+#define kLapmUnknownADPDetected		4	/* LAPM Unsupported ADP is detected	*/
+#define kLapmTimeout				5	/* LAPM Timeout		*/
+#define	kLapmMNPFrameDetected		6	/* LAPM detected MNP frame	*/
+#define kLapmDPDetectionTimedOut	7	/* LAPM Unsupported ADP is detected	*/
+#define kLapmError					8	/* LAPM Error	*/
+#define kLapmTestResult				9	/* LAPM loopback test result */
+#define	kLapmTxFrameStatus			10
+#define	kLapmRxFrameStatus			11
+#define	kLapmTxStatistics			12
+#define	kLapmRxStatistics			13
+
+typedef long	lapmTakedownReason;
+#define kLapmRemoteDisconnect	0
+#define kLapmLocalDisconnect	1
+#define kLapmCannotConnect		2
+#define kLapmProtocolError		3
+#define kLapmCompressionError	4
+#define kLapmInactivityTimer	5
+#define kLapmRetryFailed		6
+
+
+typedef long	lapmParameterCode;
+#define kLapmXmtK			0
+#define kLapmRcvK			1
+#define kLapmXmtN401		2
+#define kLapmRcvN401		3
+#define kLapmTESTSupport	4
+#define kLapmSREJSupport	5
+#define kLapmCompDir		6
+#define kLapmCompDictSize	7
+#define kLapmCompStringSize	8
+
+
+typedef long	lapmErrorCode;
+#define kLapmNoError		0
+#define kLapmBufferOverflow	1
+#define kLapmFrameTooLong	2
+#define kLapmBadFrame		3
+#define kLapmUnknownEvent	4
+/* 6 is reserved for kLapmRetryFailed defined above */
+
+
+typedef long	lapmTestResultCode;
+#define kLapmTestPassed				0
+#define kLapmTestRequestIgnored		1
+#define kLapmTestAlreadyInProgress	2
+#define kLapmTestNotSupported		3
+#define kLapmTestFailed				4
+
+
+typedef long	v42bisStatusCode;
+#define kV42bisEncoderTransparentMode	0	/* V.42bis encoder transparent mode active */
+#define kV42bisEncoderCompressedMode	1	/* V.42bis encoder compressed mode active */
+#define kV42bisDecoderTransparentMode	2	/* V.42bis decoder transparent mode active */
+#define kV42bisDecoderCompressedMode	3	/* V.42bis decoder compressed mode active */
+#define kV42bisError					4	/* V.42bis error */
+#define	kV42bisEncoderStatistics		5
+#define	kV42bisDecoderStatistics		6
+
+
+typedef long	v42bisErrorCode;
+#define kV42bisUndefinedEscSequence	0	/* V.42bis undefined escape sequence		*/
+#define kV42bisCodewordSizeOverflow	1	/* V.42bis codeword size overflow			*/
+#define kV42bisUndefinedCodeword	2	/* V.42bis undefined codeword				*/
+
+typedef long	mnpStatusCode;
+#define kMnpDisconnected			0	/* Mnp disconnected */
+#define kMnpConnected				1	/* Mnp is connected */
+#define kMnpFallback				2	/* Mnp is falling back to buffer mode */
+#define kMnpError					3	/* Mnp Error	*/
+#define	kMnpTimeout					4	/* Mnp Timeout */
+#define	kMnpInvalidLT				5	/* Invalid LT received */
+#define	kMnpRetransmitFrame			6
+#define	kMnpNack					7
+#define	kMnpTxFrameStatus			8
+#define	kMnpRxFrameStatus			9
+#define	kMnpTxStatistics			10
+#define	kMnpRxStatistics			11
+
+typedef long	mnpTakedownReason;
+#define kMnpRemoteDisconnect		0
+#define kMnpLocalDisconnect			1
+#define kMnpCannotConnect			2
+#define kMnpProtocolError			3
+#define kMnpCompressionError		4
+#define kMnpInactivityTimer			5
+#define kMnpRetryFailed				6
+
+
+typedef long	mnpParameterCode;
+#define kMnpProtocolLevel			0
+#define kMnpServiceClass			1
+#define kMnpOptimizationSupport		2
+#define kMnpCompressionSupport		3
+#define kMnpN401					4
+#define kMnpK						5
+
+
+typedef long	mnpErrorCode;
+#define kMnpNoError					0			
+#define kMnpBufferOverflow			1
+#define kMnpFrameTooLong			2
+#define kMnpBadFrame				3
+#define kMnpUnknownEvent			4
+
+
+typedef long	v70StatusCode;
+#define kV70Disconnected			0	/* V70 disconnected */
+#define kV70Connected				1	/* V70 is connected */
+#define kV70Error					2	/* V70 Error	*/
+#define	kV70Timeout					3	/* V70 Timeout */
+#define kV70ChannelDown             4	/* V70 channel released */
+#define kV70ChannelUp               5	/* V70 channel established */
+#define kV70AudioChannelDown        6	/* V70 audio channel released */
+#define kV70AudioChannelUp          7	/* V70 audio channel established */
+#define kV70DataChannelDown         8	/* V70 data channel released */
+#define kV70DataChannelUp           9	/* V70 data channel established */
+#define kV70OOBChannelDown          10	/* V70 out-of-band channel released */
+#define kV70OOBChannelUp            11  /* V70 out-of-band channel established */
+#define	kV70TxFrameStatus			12
+#define	kV70RxFrameStatus			13
+#define	kV70TxStatistics			14
+#define	kV70RxStatistics			15
+#define	kV70StateTransition			16
+
+typedef long	v70TakedownReason;
+#define kV70RemoteDisconnect		0
+#define kV70LocalDisconnect			1
+#define kV70CannotConnect			2
+#define kV70ProtocolError			3
+#define kV70CompressionError		4
+#define kV70InactivityTimer			5
+#define kV70RetryFailed				6
+
+
+typedef long	v70ParameterCode;
+#define kV70SuspendResume	        0
+#define kV70CrcLength	            1
+#define kV70NumberOfDLCs	        2
+#define kV70uIH	                    3
+
+#define kV70LapmXmtK				10
+#define kV70LapmRcvK				11
+#define kV70LapmXmtN401				12
+#define kV70LapmRcvN401				13
+#define kV70LapmTESTSupport			14
+#define kV70LapmSREJSupport			15
+#define kV70LapmCompDir				16
+#define kV70LapmCompDictSize		17
+#define kV70LapmCompStringSize		18
+
+#define kV70AudioHeader	            20   /* if audio header is present in audio frames */
+#define kV70BlockingFactor	        21   /* audio blocking factor (default 1)  */
+#define kV70SilenceSuppression      22   /* audio silence suppression */
+
+
+
+typedef long	v70ErrorCode;
+#define kV70NoError					0			
+#define kV70BadFrame				1			
+
+typedef long	audioStatusCode;
+#define kAudioFramesLost			0	 /* One or more audio frames were lost */
+#define kAudioTxBufferOverflow		1
+#define kAudioRxBufferOverflow		2
+#define kAudioRxBufferUnderflow		3
+
+
+typedef long	v80StatusCode;
+#define kV80Disconnected			0	/* V80 disconnected */
+#define kV80Connected				1	/* V80 is connected */
+#define kV80Error					2	/* V80 Error	*/
+#define kV80InBandStatus			3	/* V80 in-band SAM status */
+#define	kV80TxFrameStatus			12
+#define	kV80RxFrameStatus			13
+#define	kV80TxStatistics			14
+#define	kV80RxStatistics			15
+
+typedef long	v80TakedownReason;
+#define kV80RemoteDisconnect		0
+#define kV80LocalDisconnect			1
+
+typedef long	v80ErrorCode;
+#define kV80NoError					0			
+#define kV80BadFrame				1			
+
+typedef long	overlayStatusCode;
+#define kOverlayBegin				0	/* DSP has halted */
+#define kOverlayEnd					1	/* DSP has received entire overlay */
+#define kOverlayElapsedTime			2	/* time elapsed(as viewed by datapump) during overlay */
+#define kOverlayRecordingData		3	/* ms of data that we are recording */
+#define kOverlayReplayingData		4	/* ms of data that we have replayed so far */
+#define kOverlayReplayDone			5	/* playback is done */
+
+/* types for kOverlayRecording/ReplayingData */
+#define kOverlayTxData				0
+#define kOverlayRxData				1
+
+/*
+ * Rockwell faxmodem compatible bitmap (kRCFaxBitMapStatus)
+ */
+#define	kRCFaxFCD	0x01
+#define	kRCFaxP2	0x02
+#define	kRCFaxPN	0x04
+#define	kRCFaxDCD	0x08
+#define	kRCFaxTX	0x10
+#define	kRCFaxCTS	0x20
+
+
+#ifndef ADSL_MODEM
+typedef long	modemCommandCode;
+#endif
+	/* Basic Action commands		00-63		*/
+#define kIdleCmd						0
+#define kStartFaxModemCmd				1
+#define kStartDataModemCmd				2
+#define kStartCallProgressMonitorCmd	3
+#define kSendTonesCmd					4
+#define kStartCallerIDRcvCmd			5
+#define kSetLinkLayerCmd				6
+#define kSetFramerCmd					7
+#define kTestLinkLayerCmd				8
+#define kIdleRcvCmd						9
+#define kIdleXmtCmd						10
+#define kSetStatusHandlerCmd			11
+#define kSetEyeHandlerCmd				12
+#define kSetLogHandlerCmd				13
+#define kSendBreakCmd					14
+#define kSendTestCmd					15
+#define kDisconnectLinkCmd				16
+#define kSetXmtGainCmd					17
+#define kStartADSICmd					18
+#define kSetHybridDelayCmd				19
+#define kCleardownCmd					20
+#define kInitiateRetrainCmd				21
+#define kInitiateRateRenegotiationCmd	22
+#define	kDialToneIndicator				23
+#define kSetRxDataHandler				24	/* not used yet */
+#define kSetTxDataHandler				25	/* not used yet */
+#define kSetAuxRxDataHandler			26
+#define kSetAuxTxDataHandler			27
+#define kRingIndicatorCmd				28
+#define kDTERateIndicatorCmd			29
+#define	kStartV8bisCmd					30
+#define kSendMultiTonesCmd				31
+#define kSetMultiToneParamsCmd			32
+#define kSetModemSampleRateCmd			33
+#define kStartDataModemPTTTestCmd		34
+#define kStartDataModemLoopbackTestCmd	35
+#define kRingFrequencyCmd				36
+#define kSetCallWaitingDetectorStateCmd	37
+#define kV34HDXTurnOffCurrentModeCmd	38
+#define	kSetAudioCmd					39
+#define	kLoopbackTestAutoRespEnableCmd	40
+#define kSetCallProgressParamsCmd		41
+#define kSetTrainingDelayReductionCmd	42
+#define	kSetFaxECMPageBufferPtrCmd		43
+#define kSetLineCurrentStateCmd			44
+#define	kSetFramerParameterCmd			45
+#define kStartDozeCmd                   46
+#define kEndDozeCmd                     47
+#define kStartRingFrequencyDetectorCmd  48
+#define	kSetBufferingDelayAdjustmentCmd	49
+
+	/* Composite action commands	64-127		*/
+#define kDialCmd						64
+#define kSendCallingToneCmd				65
+#define kV24CircuitChangeCmd			66
+#define	kStartATModeCmd					67
+#define	kStopATModeCmd					68
+#define	kSetATRegister					69
+#define	kSetATRegisterLimits			70
+#define	kSetATIResponse					71
+#define	kEnableATDebugMode				72
+#define	kSetWhiteListEntry				73
+#define	kSetBlackListEntry				74
+
+#define kV70Setup					    75      /* additional V70 configuration */
+#define kEstablishChannel			    76      /* Establish new link layer channel (V70) */
+#define kReleaseChannel					77      /* Release link layer channel (V70) */
+#define kWaitChannelEstablished			78      /* Wait for establishment of the new link layer channel (V70) */
+
+/* unused	79 */
+#define kMnpOOBFrameCmd					80
+#define kV80InBandCmd					81		/* V80 In-band commands */
+#define kSetV250IdString				82
+#define	kSetInternationalTablesCmd		83
+#define	kConfigureCountryCmd			84
+#define	kConigureCountryCmd				84
+#define	kV8ControlCmd					85
+#define kV8bisSendMessage				86
+#define	kSetHWIdCmd						87
+#define	kSetCodecIdCmd					88
+#define	kOverCurrentDetected			89
+
+
+
+typedef long v8ControlType;
+#define kEnableDTEControl				1
+#define kSetV8ControlTimeout			2
+#define kSetCIValue						3
+#define kSetCMValue						4
+#define kSetJMValue						5
+#define kSendCJ							6
+#define kSetCallFunctionCategory		7
+
+typedef long v250IdStringCode;
+#define kGMIString						1
+#define kGMMString						2
+#define kGMRString						3
+#define kGSNString						4
+#define kGOIString						5
+
+typedef long	kCallProgressParameterCode;
+#define	kModemSignalPowerThreshold		1
+#define	kDialtonePowerThreshold			2
+#define	kRingBackPowerThreshold			3
+#define	kBusyPowerThreshold				4
+#define	kReorderPowerThreshold			5
+#define	k2ndDTnPowerThreshold			6
+#define	kMinDialtoneTime				7
+#define	kDialtoneFreqRange				8
+#define	kRingBackFreqRange				9
+#define	kBusyFreqRange					10
+#define	kReorderFreqRange				11
+#define	k2ndDTnFreqRange				12
+
+
+typedef	long	framerParameterCode;
+#define	kSetHDLCLeadingFlags		0
+#define	kHDLCResetFlagDetection		1
+#define	kSyncFramerSetup			2
+#define	kHDLCSendCRC				3
+#define kHDLCSendFlags				4
+#define	kHDLCSendAborts				5
+
+
+typedef	long logDataCode;
+#define eyeData				0
+#define mseData				1
+#define rxData				2
+#define txData				3
+#define neecData			4
+#define eqlData				5
+#define ieecData			6
+#define feecData			7
+#define eqlPllData			8
+#define feecPllData			9
+#define timingData			10
+#define pjPhaseErrData		11
+#define pjEstimateData		12
+#define pjEstDiffData		13
+#define pjCoefData			14
+#define inputSignalData		15
+#define outputSignalData	16
+#define agcGainData			17
+#define automoderData		18
+#define v8CMData			19
+#define v8JMData			20
+#define inputAfterNeecData	21
+#define eqlErrData			22
+#define dpskMicrobitsData	23
+#define v34P2LSamplesData	24
+#define phaseSplittedLData	25
+#define fftedLData			26
+#define channelSNRData		27
+#define noiseEstimateData	28
+#define signalEstimateData	29
+#define v34INFOData			30
+#define v34ChanProbData		31
+#define v34P2OutputData		32
+#define v8ANSamDetectData	33
+#define pFeecData			34
+#define channelDelayData	35
+#define timingOffsetData	36
+#define trellisMSEData		37
+#define interpolatedSignalData		38
+#define dcCancelledSignalData		39
+#define echoCancelledSignalData		40
+#define predictorErrData			41
+#define commandInfoData				42
+#define unusedInfoData				43
+#define atCommandInfoData			44
+#define atResponseInfoData			45
+#define hwTerminalTxData			46
+#define hwTerminalRxData			47
+#define statusInfoData				48
+#define	channelResponseData			49
+#define	channelImpulseRespData		50
+#define	x2PcmP1DetectorInData		51
+#define	x2PcmP1DetectorOutData		52
+#define eqlRealData					53
+#define ieecRealData				54
+#define neecOutputData				55
+#define precodedEqlOutputData		56
+#define eqlRealErrData				57
+#define idealEqlOutputData			58
+#define agcData						59
+#define pcmInfidelityData			60
+#define v42bisCycleCount			61
+#define pcmImdOffsetCoefData		62
+#define pcmImdOffsetData			63
+#define	v90RcvdDilLongData			64
+#define	v90RcvdDilShortData			65
+#define	v90DilProducedData			66
+#define	pcmEncoderKbitsData			67
+#define	pcmEncoderMbitsData			68
+#define	pcmEncoderSbitsData			69
+#define	pcmDecoderKbitsData			70
+#define	pcmDecoderMbitsData			71
+#define	pcmDecoderSbitsData			72
+#define	v90CPorCPtData				73
+#define	mnpDecoderInputData			74
+#define	mnpDecoderOutputData		75
+#define	v42bisEncoderInputData		76
+#define	v42bisDecoderInputData		77
+#define	modulatorInputData			78
+#define	modulatorOutputData			79
+#define encodedStatusData			80
+#define blockFramerTxData			81
+#define blockFramerRxData			82
+#define framerTxData				83
+#define framerRxData				84
+#define	dpskBasebandData			85
+#define	dpskBasebandLPFedData		86
+#define	dpskRealData				87
+#define bandEdgeCorrectedSignalData	88
+#define atmLogData					89
+#define clearEocLogData				90
+#define g997LogData					91
+
+
+#define	kLogDataDelimiter	0xFEFEFEFE
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.3	Handlers															*/
+/****************************************************************************/
+
+typedef	void	(SM_DECL *rcvHandlerType)			(void *gDslVars, int, short*);
+typedef	void	(SM_DECL *xmtHandlerType)			(void *gDslVars, int, short*);
+typedef	int		(SM_DECL *xmtHandlerWithRtnValType)	(void *gDslVars, int, short*);
+typedef	void	(SM_DECL *timerHandlerType)			(void *gDslVars, long);
+typedef	int		(SM_DECL *interpolatorHandlerType)	(void *gDslVars, int, short*, short*);
+typedef	void	(SM_DECL *controlHandlerType)		(void *gDslVars, int);
+
+typedef	int		(SM_DECL *txDataHandlerType)	(void *gDslVars, int,	uchar*);
+typedef	int		(SM_DECL *rxDataHandlerType)	(void *gDslVars, int,	uchar*);
+
+typedef	bitMap	(SM_DECL *signalDetectorType)	(void *gDslVars, int, long, long*);
+
+
+typedef	void	(SM_DECL *hookHandlerType)		(void *gDslVars, Boolean);
+
+typedef	short*	(SM_DECL *sampBuffPtrType)		(void *gDslVars, int);
+
+typedef	void	(SM_DECL *eyeHandlerType)		(void *gDslVars, int, ComplexShort*);
+typedef	void	(SM_DECL *logHandlerType)		(void *gDslVars, logDataCode, ...);
+
+typedef	void	(SM_DECL *voidFuncType)			(void *gDslVars);
+
+typedef	int		(SM_DECL *txAudioHandlerType)	(void *gDslVars, int,	short*);
+typedef	int		(SM_DECL *rxAudioHandlerType)	(void *gDslVars, int,	short*);
+
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.4	Structures															*/
+/****************************************************************************/
+
+/*
+ * AT command processor definitions
+ */
+#define kATRegistersNumber				56
+#define	kFirstConfigurationRegister		500
+#define	kLastConfigurationRegister		515
+#define	kFirstInternationalRegister		516
+#define	kLastInternationalRegister		595
+
+
+
+#define kATMaxDialStringSize	128
+typedef struct
+	{
+	struct 
+		{
+		uchar loadNumber;								/* Which profile to load upon powerup/reset */
+		uchar countryCode;								/* T.35 Country Code */
+		uchar profile[2][kATRegistersNumber];
+		uchar dialString[4][kATMaxDialStringSize + 1];
+		} config;
+	ulong versionCode;
+	ulong crcCheckSum;
+	} NVRAMConfiguration;
+
+/* Structure to hold international settings */
+typedef	struct
+	{
+	char						*name;
+	int							countryCode;
+	const SRegisterDefinition	*userRegisters;
+	const ulong					*configRegisters;
+	} CountryDescriptor;
+
+/*
+ * V.34 coding parameters structure
+ */
+
+typedef struct
+	{
+	/* DO NOT CHANGE THE ORDER OF FIELDS IN THIS STRUCTURE!
+	 * (Some assembly code depends on it!)  If you
+ 	 * must add fields, please do so at the bottom.
+	 */
+
+	int					symbolRateIndex,
+						dataRateIndex,
+						userSNRAdjustment;
+	Boolean				auxChannel, 
+						expConstellation, 
+						precoding,
+						nonlinearCoding; 
+	schar	J,			/* number of data frames in superframe				*/
+			P,			/* number of mapping frames in a data frame			*/
+			r,			/* number of high mapping frames in a data frame	*/
+			b,			/* number of data bits in a mapping frame			*/
+			W,			/* number of aux bits in a data frame				*/
+			K,			/* number of S bits in a mapping frame				*/
+			q, 			/* number of Q bits in a 2D symbol					*/
+			M;			/* number of rings in shell mapping					*/
+	long	nominalVariance;	/* the signal variance which gives 1e-2 BLER Q10 */
+	int		bitsPerDataFrame;
+	short	quantRoundOff,
+			quantMask;
+	uchar	nTrellisStates, 
+			log2NTrellisStates; 
+	short	gain1xmt,
+			gain2xmt,
+			gain1rcv,
+			gain2rcv;
+	ushort	bitInversionPattern;
+	} V34CodingParams;
+
+typedef	long				v8bisStatusCode;
+typedef	bitMap				v8bisConnectionSetup;
+#if defined(V8BIS) || defined(AT_COMMANDS_V8BIS)
+#include "V8bisMainTypes.h"
+#endif
+
+#define kMaxMultiTones				4	/* MultiTone: search for up to this many tones at once */
+
+#ifndef ADSL_MODEM
+typedef	struct
+	{
+	modemStatusCode		code;
+	union
+		{
+		long						value;
+		long						freq;
+		modemErrorCode				error;
+		modulationMap				modulation;
+		modulationMap				modemSignal;
+		dataRateMap					dataRate;
+		long						dtmfSignal;
+		bitMap						callProgressSignal;
+		bitMap						customSignal;
+		void						*ptr;
+		struct
+			{
+			long				detected;
+			long				numTones;
+			long				tones[kMaxMultiTones];
+			} multiToneInfo;
+		struct
+			{
+			v8bisStatusCode		code;
+			long				value;
+			} v8bisStatus;
+		struct
+			{
+			trainingProgressCode	code;	
+			long					value;			
+			} trainingInfo;
+		struct
+			{
+			long					code;	
+			long					value;			
+			} v24Circuit;
+		struct
+			{
+			trainingProgressCode	code;	
+			void*					ptr;			
+			} advancedTrainingInfo;
+		struct
+			{
+			capabilitiesStatusCode	code;	
+			long					value;			
+			} capabilitiesStatusInfo;
+		struct
+			{
+			connectionInfoCode		code;
+			long					value;			
+			} connectionInfo;
+		struct
+			{
+			connectionInfoCode		code;
+			int						length;
+			uchar					*ptr;
+			} advancedConnectionInfo;
+		struct
+			{
+			dialerStatusCode		code;
+			long					value;
+			long					makeTime;			
+			long					breakTime;			
+			} dialerStatus;
+		struct
+			{
+			long					enabled;
+			long					volume;			
+			} speakerStatus;
+		framingInfoCode				framingInfo;
+		IOStatusCode				ioStatus;
+		struct
+			{
+			lapmStatusCode			code;
+			union
+				{
+				long				value;
+				lapmTakedownReason	reason;
+				lapmErrorCode		error;
+				lapmTestResultCode	testResult;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				} param;			
+			} lapmStatus;
+		struct
+			{
+			lapmParameterCode		code;
+			long					value;
+			} lapmParameter;
+		struct
+			{
+			v42bisStatusCode		code;
+			union
+				{
+				long				value;
+				v42bisErrorCode		error;
+				struct
+					{
+					long	nBytesIn;
+					long	nBytesOut;
+					} statistic;
+				} param;			
+			} v42bisStatus;
+		struct
+			{
+			mnpStatusCode			code;
+			union
+				{
+				long				value;
+				mnpTakedownReason	reason;
+				mnpErrorCode		error;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					ulong	nSize;
+					uchar  *Buffer;
+					} fallback;
+				struct
+					{
+					char	*header;
+					void	*frame;
+					} frame;
+				struct
+					{
+					long	nack;
+					long	rFrameNo;
+					} timeout;
+				struct
+					{
+					long	frameNo;
+					long	framesPending;
+					} retrFrame;
+				} param;			
+			} mnpStatus;
+		struct
+			{
+			mnpParameterCode		code;
+			long					value;
+			} mnpParameter;
+		struct
+			{
+			v70StatusCode			code;
+			union
+				{
+				long				value;
+				v70TakedownReason	reason;
+				v70ErrorCode		error;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	nack;
+					long	rFrameNo;
+					} timeout;
+				struct
+					{
+					long	frameNo;
+					long	framesPending;
+					} retrFrame;
+				struct 	
+					{
+					long	ChannelId;
+					long	DLCI;
+					ulong	LcNum;
+					v70TakedownReason	reason;
+					} channelInfo;			
+				struct 	
+					{
+					long	ChannelId;
+					long	stateOld;
+					long	stateNew;
+					} stateInfo;			
+				} param;
+			ulong	v70Time;
+			} v70Status;
+		struct
+			{
+			audioStatusCode			code;
+			union
+				{
+				long		value;
+				struct
+					{
+					long	nReq;
+					long	nAvail;
+					} buffer;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				} param;
+			} audioStatus;
+		struct
+			{
+			v80StatusCode			code;
+			union
+				{
+				long				value;
+				v80TakedownReason	reason;
+				v80ErrorCode		error;
+				struct
+					{
+					long	nFrames;
+					long	nFrameErrors;
+					} statistic;
+				struct
+					{
+					long	length;
+					uchar	*framePtr;
+					} frame;
+				struct
+					{
+					long	code;
+					long	value;
+					} inBand;
+				} param;
+			ulong	v80Time;
+			} v80Status;
+		struct
+			{
+			v70ParameterCode		code;
+			long					value;
+			} v70Parameter;
+		struct
+			{
+			breakType			type;
+			long				length;
+			} breakStatus;
+		struct
+			{
+			callerIDStatusCode			code;
+			union
+				{
+				long				value;
+				struct
+					{
+					callerIDErrorCode	code;
+					long				value;	
+					} callerIDError;
+				struct
+					{
+					long			length;
+					char*			ptr;	
+					} message;
+				} param;			
+			} callerIDStatus;
+		struct
+			{
+			ulong		signal;
+			uchar		*msg1;
+			long		msg1Length;	
+			uchar		*msg2;
+			long		msg2Length;	
+			} A8RStatus;
+		struct
+			{
+			overlayStatusCode		code;
+			long					value;
+			long					value2;
+			} overlayStatus;
+		struct
+			{
+			ulong	nBits;
+			ulong	nBlocks;
+			ulong	nBitErrors;
+			ulong	nBlockErrors;
+
+			ulong	nAudioBits;
+			ulong	nAudioBlocks;
+			ulong	nAudioSyncErrors;
+			ulong	nAudioBlockErrors;
+			} testResults;
+		ulong					checksum;
+		struct
+			{
+			ulong	sizeM;
+			uchar	*filename;
+			} logFileControlStatus;
+		struct
+			{
+			long	direction;
+			long	module;
+			long	message;
+			long	data;
+			}
+		faxClass2Status;
+		
+		} param;
+	} modemStatusStruct;
+	
+typedef	void	(SM_DECL *statusHandlerType)	(void *gDslVars, modemStatusStruct*);
+#endif	/* ADSL_MODEM */
+
+/****************************************************************************/
+/*	1.	Type definitions.													*/
+/*																			*/
+/*	1.5	Command structure													*/
+/****************************************************************************/
+
+typedef struct
+	{
+    Boolean remoteModemIsFlex;
+    uchar   countryCode;
+    ushort  manufacturerId;
+    uchar   licenseeId;
+    uchar   productCapabilities;
+    Boolean digitalModeFlag;
+    Boolean prototypeFlag;
+    uchar   version;
+	}
+FlexV8bisStruct;
+
+typedef struct
+	{
+	symbolRateMap	symbolRates;
+	dataRateMap		dataRates;
+	dataRateMap		dataRates56k;
+	dataRateMap     dataRatesFlex;
+	featureMap		features;
+	bitMap			auxFeatures;
+	bitMap			demodCapabilities;
+	long			rateThresholdAdjustment;	/* dB Q4	*/
+    FlexV8bisStruct flexRemoteV8bisInfo;
+	}	dataPumpCapabilities;
+
+#ifndef ADSL_MODEM
+typedef	struct	SoftwareModemCommandParameters
+	{
+	modemCommandCode		command;
+	union
+		{
+		long				xmtGain;
+		ulong				hybridDelayQ4ms;
+		long				modemSampleRate;
+		long				timeInMs;
+		long				state;
+		long				freq;
+		NVRAMConfiguration	*nvramConfigurationPtr;
+		long				enabled;
+		long				value;
+		uchar				*phoneNumber;
+		uchar				*faxECMPageBufferPtr;
+		CountryDescriptor	*countryDescriptorTable;
+		struct
+			{
+			dataRateMap			dteRate;
+			bitMap				format;
+			} dteRateSpec;
+		struct
+			{
+			v8ControlType		code;
+			long				value;
+			uchar				*buffer;
+			} v8ControlSpec;
+		struct
+			{
+			directionType			direction;
+			v8bisConnectionSetup	setup;
+			void					*capPtr;
+			voidFuncType			confirmMsFunc;
+			voidFuncType			genMsFunc;
+			xmtHandlerWithRtnValType	ogmFunc;
+			} v8bisSpec;
+		struct
+			{
+			directionType	direction;
+			} ADSISpec;
+		struct
+			{
+			directionType			direction;
+			modulationMap			modulations;
+			dataPumpCapabilities	capabilities;
+			} modeSpec;
+		struct
+			{
+			long			time, 
+							freq1, 
+							freq2, 
+							freq3, 
+							freq4,
+							mag1, 
+							mag2,
+							mag3,
+							mag4;
+			} toneSpec;
+		struct
+			{
+			long		signal;
+			uchar		*msg1;
+			long		msg1Length;	
+			uchar		*msg2;
+			long		msg2Length;	
+			long		sig_en;
+			long		msg_en;
+			long		supp_delay;
+			}
+			v8bisMessageSpec;
+		struct
+			{
+			linkLayerType		type;
+			bitMap				setup;
+			dataRateMap			rxDataRate;
+			dataRateMap			txDataRate;
+			long				rtDelayQ4ms;				
+			rxDataHandlerType	rxDataHandlerPtr;
+			txDataHandlerType	txDataHandlerPtr;
+			} linkLayerSpec;
+		struct
+			{
+			framerType			type;
+			bitMap				setup;
+			directionType		direction;
+			long				fill[2]; /* need to match linkLayerSpec */
+			rxDataHandlerType	rxDataHandlerPtr;
+			txDataHandlerType	txDataHandlerPtr;
+			} framerSpec;
+		struct
+			{
+			framerParameterCode	code;
+			long				value;
+			} framerParameterSpec;
+		struct
+			{
+			bitMap				callProgressDetectorSetup;
+			signalDetectorType	callProgressDetectorPtr;	/* if nil, use defaults			*/
+			signalDetectorType	customDetectorPtr;			/* if nil, no custom detector	*/
+			} callProgressMonitorSpec;
+		struct
+			{
+			ulong			maxTones;					/* maximum number of simultaneous tones to detect */
+			ulong			allowableVariance;			/* maximum cumulative variance in the eight interpolated frequencies */
+			ulong			totalPowerThreshold;		/* ignore complete block if power less than this */
+			ulong			powerShiftThreshold;		/* ignore a bin if its power is less than (totalPowerValue >> powerShiftThreshold) */
+			ulong			toneMatchThresholdHz;		/* tones within +/- this many Hz of original tone are considered the same tone */
+			ulong			binSeparation;				/* ignore tones with a spacing of less than this */
+			ulong			outsideFreqDeviation;		/* an individual value in the interpolated array can be up to this many Hz outside of the expected angle range */
+			} multiToneSpec;
+		struct
+			{
+			uchar				*dialString;	/* nil limited string for DTMF dialing sequence	*/
+			long				pulseBreakTime, 
+								pulseMakeTime, 
+								pulseInterDigitTime,
+								toneDigitTime, 
+								toneInterDigitTime, 
+								toneLoGroupMag,
+								toneHiGroupMag,
+								flashTime, 
+								pauseTime,
+								signalWaitTimeout,	
+								blindDialingTimeout; 	
+			bitMap				dialerSetup;
+			bitMap				callProgressDetectorSetup;
+			signalDetectorType	callProgressDetectorPtr;	/* if nil, use defaults			*/	
+			signalDetectorType	customDetectorPtr;			/* if nil, no custom detector	*/
+			hookHandlerType		hookHandlerPtr;				/* nil if DTMF dialing specified*/
+			} dialSpec;
+		struct
+			{
+			long			timeOn, 
+							timeOff, 
+							freq;
+			} callingToneSpec;
+		union
+			{
+			statusHandlerType	statusHandlerPtr;
+			eyeHandlerType		eyeHandlerPtr;
+			logHandlerType		logHandlerPtr;
+			rxDataHandlerType	rxDataHandlerPtr;
+			txDataHandlerType	txDataHandlerPtr;
+			} handlerSpec;
+		struct
+			{
+			breakType			type;
+			long				length;
+			} breakSpec;
+		struct
+			{
+			long				length;
+			uchar				*dataPtr;
+			} lapmTestSpec;
+		struct
+			{
+			bitMap				setupLapm;
+			rxDataHandlerType	rxAudioHandlerPtr;
+			txDataHandlerType	txAudioHandlerPtr;
+            } v70SetupSpec;
+		struct
+			{
+			ulong				ChannelId;
+			ulong				LogChannelNum;
+			ulong				PortNum;
+            } EstChannelSpec;
+		struct
+			{
+			ulong				ChannelId;
+            } WaitChannelSpec;
+		struct
+			{
+			ulong				ChannelId;
+			ulong				LogChannelNum;
+			ulong				PortNum;
+			ulong				DLCI;
+            } RelChannelSpec;
+		struct
+			{
+			audioType			type;
+			bitMap				setup;
+			dataRateMap			rxAudioRate;
+			dataRateMap			txAudioRate;
+			rxAudioHandlerType	rxAudioHandlerPtr;
+			txAudioHandlerType	txAudioHandlerPtr;
+			} audioSpec;
+		struct
+			{
+			long					code;	
+			long					value;			
+			} v24Circuit;
+		struct
+			{
+			ulong					code;	
+			ulong					value;			
+			ulong					minValue;
+			ulong					maxValue;
+			} atRegister;
+		struct
+			{
+			long					code;	
+			uchar					*response;
+			} atiSpec;
+		struct
+			{
+			long					length;
+			uchar					*framePtr;
+			} frameSpec;
+		struct
+			{
+			long					code;
+			union
+				{
+				long				value;
+				struct
+					{
+					long			loFreq1;
+					long			hiFreq1;
+					long			loFreq2;
+					long			hiFreq2;
+					} freqRange;
+				} params;
+			} callProgressParamSpec;
+		struct
+			{
+			v250IdStringCode	v250IdCode;
+			uchar				*v250IdString;
+			} v250IdSpec;
+
+		} param;
+	} modemCommandStruct;
+	
+typedef	Boolean	(*commandHandlerType)	(modemCommandStruct*);
+#endif /* ADSL_MODEM */
+
+
+
+/****************************************************************************/
+/*	2.	Constant definitions.												*/
+/*																			*/
+/*	2.1	Definitive constants												*/
+/****************************************************************************/
+
+#define kMaxSampleBlockSize			48
+#define kMaxDataBlockSize			48
+
+#define	kMaxDialStringLength		127
+#define	kCallProgressSampleRate		7200
+
+#define	kMaxCallerIDMessageLength	80
+
+/****************************************************************************/
+/*	2.	Constant definitions.												*/
+/*																			*/
+/*	2.2	Bit maps														*/
+/****************************************************************************/
+
+/* modulationMap */
+
+#define	kIdle					0x00000000
+#define	kV25					0x00000001
+#define	kV8						0x00000002
+#define	kCid					0x00000004
+#define	kV8bis					0x00000008
+#define	kV21					0x00000010
+#define	kV22					0x00000020
+#define	kV23					0x00000040
+#define	kV32					0x00000080
+#define	kV34					0x00000100
+#define	kX2						0x00000200
+#define	kV90					0x00000400
+#define	k56Flex					0x00000800
+#define	kV27					0x00001000
+#define	kV29					0x00002000
+#define	kV17					0x00004000
+#define	kV34HDX					0x00008000
+#define	kV34HDXC				0x00010000
+#define	kBell103				0x00100000
+#define	kBell212				0x00200000
+#define	kDataCallingTone		0x01000000
+#define	kFaxCallingTone			0x02000000
+
+#define	kV22FastNZConnect	    0x04000000
+#define kV22FastNNZConnect      0x08000000
+#define kV22FastConnect         (kV22FastNZConnect|kV22FastNNZConnect)
+#define kV22bisFastConnect      0x10000000
+
+
+#define	kDataModulations	(kV25 | kV8 | kV21 | kV22FastConnect | kV22bisFastConnect | kV22 | kV23 | kV32 | kV34 | kBell103 | kBell212)
+#define	kDataOnlyModulations (kV21 | kV22 | kV23 | kV32 | kBell103 | kBell212)
+#define	kPCMModulations		(kV90 | kX2 | k56Flex)
+
+#define	kFaxModulations		(kV25 | kV21 | kV27 | kV29 | kV17)
+#define	kFaxOnlyModulations	(kV27 | kV29 | kV17)
+#define	kFaxModulationShift		12
+
+/* symbolRateMap	*/
+
+#define	k1200Hz			0x00000001
+#define	k1600Hz			0x00000002
+#define	k2400Hz			0x00000004
+#define	k2743Hz			0x00000008
+#define	k2800Hz			0x00000010
+#define	k3000Hz			0x00000020
+#define	k3200Hz			0x00000040
+#define	k3429Hz			0x00000080
+#define	k8000Hz			0x00000100
+
+#define	kAllSymbolRates	(	k1200Hz | k1600Hz | k2400Hz | k2743Hz | \
+							k2800Hz | k3000Hz | k3429Hz | k8000Hz )
+
+/* dataRateMap	*/
+
+#define	k75bps			0x00000002
+#define	k300bps			0x00000004
+#define	k600bps			0x00000008
+#define	k1200bps		0x00000010
+#define	k2400bps		0x00000020
+#define	k4800bps		0x00000040
+#define	k7200bps		0x00000080
+#define	k9600bps		0x00000100
+#define	k12000bps		0x00000200
+#define	k14400bps		0x00000400
+#define	k16800bps		0x00000800
+#define	k19200bps		0x00001000
+#define	k21600bps		0x00002000
+#define	k24000bps		0x00004000
+#define	k26400bps		0x00008000
+#define	k28800bps		0x00010000
+#define	k31200bps		0x00020000
+#define	k33600bps		0x00040000
+#define	k36000bps		0x00080000
+#define	k38400bps		0x00100000
+#define	k57600bps		0x00200000
+#define	k115200bps		0x00400000
+#define	k230400bps		0x00800000
+#define	k460800bps		0x01000000
+#define	k921600bps		0x02000000
+/*
+ * kPCMRate is used to identify that the reported rate is
+ * PCM modulation rate, and is only used for PCM modulation while
+ * reporting rate !!!!
+ */
+#define	kPCMRate		0x40000000
+#define kPCMFlexRate    0x80000000
+#define	kAllDataRates   0x0FFFFFFF
+
+/* rates specific for X2  and V.90 */
+#define	kPCM25333bps	0x00000001
+#define	kPCM26666bps	0x00000002
+#define	kPCM28000bps	0x00000004
+#define	kPCM29333bps	0x00000008
+#define	kPCM30666bps	0x00000010
+#define	kPCM32000bps	0x00000020
+#define	kPCM33333bps	0x00000040
+#define	kPCM34666bps	0x00000080
+#define	kPCM36000bps	0x00000100
+#define	kPCM37333bps	0x00000200
+#define	kPCM38666bps	0x00000400
+#define	kPCM40000bps	0x00000800
+#define	kPCM41333bps	0x00001000
+#define	kPCM42666bps	0x00002000
+#define	kPCM44000bps	0x00004000
+#define	kPCM45333bps	0x00008000
+#define	kPCM46666bps	0x00010000
+#define	kPCM48000bps	0x00020000
+#define	kPCM49333bps	0x00040000
+#define	kPCM50666bps	0x00080000
+#define	kPCM52000bps	0x00100000
+#define	kPCM53333bps	0x00200000
+#define	kPCM54666bps	0x00400000
+#define	kPCM56000bps	0x00800000
+#define	kPCM57333bps	0x01000000
+
+#define	kV90ServerToClientDataRates	\
+						(	kPCM28000bps | kPCM29333bps | kPCM30666bps | \
+							kPCM32000bps | kPCM33333bps | kPCM34666bps | \
+							kPCM36000bps | kPCM37333bps | kPCM38666bps | \
+							kPCM40000bps | kPCM41333bps | kPCM42666bps | \
+							kPCM44000bps | kPCM45333bps | kPCM46666bps | \
+							kPCM48000bps | kPCM49333bps | kPCM50666bps | \
+							kPCM52000bps | kPCM53333bps | kPCM54666bps | \
+							kPCM56000bps | kPCM57333bps )
+
+#define	kV90ClientToServerDataRates	\
+						(	k4800bps  | k7200bps  | k9600bps  | k12000bps | \
+							k14400bps | k16800bps | k19200bps | k21600bps | \
+							k24000bps | k26400bps | k28800bps | k31200bps | \
+							k33600bps )	
+
+
+
+#define	kX2ServerToClientDataRates	\
+						(	kPCM25333bps | kPCM26666bps | kPCM28000bps | \
+							kPCM29333bps | kPCM30666bps | kPCM32000bps | \
+							kPCM33333bps | \
+							kPCM34666bps | kPCM36000bps | kPCM37333bps | \
+							kPCM38666bps | kPCM40000bps | kPCM41333bps | \
+							kPCM42666bps | kPCM44000bps | kPCM45333bps | \
+							kPCM46666bps | kPCM48000bps | kPCM49333bps | \
+							kPCM50666bps | kPCM52000bps | kPCM53333bps | \
+							kPCM54666bps | kPCM56000bps | kPCM57333bps )
+#define	kX2ClientToServerDataRates	\
+						(	k4800bps | k7200bps | k9600bps | k12000bps | k14400bps | \
+								k16800bps | k19200bps | k21600bps | k24000bps | k26400bps | k28800bps | \
+								k31200bps )
+
+  /*
+  Rates specific for Flex
+  */
+#define kPCMFlex32000bps  0x00000001
+#define kPCMFlex34000bps  0x00000002
+#define kPCMFlex36000bps  0x00000004
+#define kPCMFlex38000bps  0x00000008
+#define kPCMFlex40000bps  0x00000010
+#define kPCMFlex42000bps  0x00000020
+#define kPCMFlex44000bps  0x00000040
+#define kPCMFlex46000bps  0x00000080
+#define kPCMFlex48000bps  0x00000100
+#define kPCMFlex50000bps  0x00000200
+#define kPCMFlex52000bps  0x00000400
+#define kPCMFlex54000bps  0x00000800
+#define kPCMFlex56000bps  0x00001000
+#define kPCMFlex58000bps  0x00002000
+#define kPCMFlex60000bps  0x00004000
+
+#define	kFlexServerToClientDataRates \
+                        (   kPCMFlex32000bps | kPCMFlex34000bps | kPCMFlex36000bps | kPCMFlex38000bps | \
+							kPCMFlex40000bps | kPCMFlex42000bps | kPCMFlex44000bps | kPCMFlex46000bps | \
+							kPCMFlex48000bps | kPCMFlex50000bps | kPCMFlex52000bps | kPCMFlex52000bps | \
+							kPCMFlex54000bps | kPCMFlex56000bps | kPCMFlex58000bps | kPCMFlex60000bps )
+
+#define	kFlexClientToServerDataRates	\
+						(	k4800bps  | k7200bps  | k9600bps  | k12000bps | \
+							k14400bps | k16800bps | k19200bps | k21600bps | \
+							k24000bps | k26400bps | k28800bps | k31200bps )
+
+
+#define	k2400BitShift	5
+#define	k4800BitShift	6
+
+#define	kPCM28000bpsShift	2
+
+#define	kV21Rates			k300bps
+#define	kV22Rates			k1200bps
+#define	kV22bisRates		(k1200bps | k2400bps)
+#define	kV23Rates			(k75bps | k1200bps)
+#define	kCidRates			(k1200bps)
+#define	kV32Rates			(k4800bps | k9600bps)
+#define	kV32bisRates		(kV32Rates | k7200bps | k12000bps | k14400bps)
+#define	kV32terboRates		(kV32bisRates | k16800bps | k19200bps)	
+#define	kV34Rates			(	k2400bps | k4800bps | k7200bps | k9600bps | k12000bps | k14400bps | \
+								k16800bps | k19200bps | k21600bps | k24000bps | k26400bps | k28800bps | \
+								k31200bps | k33600bps )	
+
+#define	kV27Rates			(k2400bps | k4800bps)
+#define	kV29Rates			(k4800bps | k7200bps | k9600bps)
+#define	kBell103Rates       k300bps
+#define	kBell212Rates       k1200bps
+
+
+/* Demodulator capabilities	*/
+#define	kNeecEnabled					0x00000001
+#define	kPFeecEnabled					0x00000002
+#define	kIeecEnabled					0x00000004
+#define	kFeecEnabled					0x00000008
+
+#define	kRapidEqualizerTraining			0x00000010
+#define	kRapidPECTraining				0x00000020
+#define	kRapidECTraining				0x00000040
+#define	kAutoLoadReductionEnabled		0x00000080
+
+#define	kTimingTrackingEnabled			0x00000100
+#define	kPhaseLockedLoopEnabled			0x00000200
+#define	kFeecPhaseLockedLoopEnabled		0x00000400
+#define	kPhaseJitterTrackingEnabled		0x00000800
+
+#define	kClockErrorTrackingEnabled		0x00001000
+#define	kFreqOffsetTrackingEnabled		0x00002000
+#define	kFeecFreqOffsetTrackingEnabled	0x00004000
+
+#define	kShorterNeecEnabled				0x00008000
+#define	kShorterPFeecEnabled			0x00010000
+#define	kFrondEndHPFilterEnabled		0x00020000
+#define kGainControlEnabled				0x00040000
+#define kPhaseHitControlEnabled			0x00080000
+#define	kBandEdgeCorrectorEnabled		0x00100000
+#define kDisableFaxFastClearDown		0x00200000
+
+#define kImdOffsetCompensationEnabled	0x00400000
+
+#define kV34ShortEqlLengthExtShift  23
+#define kV34ShortEqlLengthExtMask      (0x3<<kV34ShortEqlLengthExtShift)
+#define kV34EqlLengthReductionEnabled  (1<<(kV34ShortEqlLengthExtShift+2))
+#define kPCMIeecLengthReductionEnabled (1<<(kV34ShortEqlLengthExtShift+3))
+
+/* featureMap	*/
+
+#define	kAllFeatures				0xFFFFFFFF
+
+#define	kAutomodingEnabled			0x00000001	/* bit 1	*/
+#define	kAutomodingDisabled			0x00000000	/* bit 1	*/
+
+#define	kV8SendCIEnabled			0x00000002	/* bit 2	*/
+#define	kV8SendCIDisabled			0x00000000	/* bit 2	*/
+
+#define	kV34CMEModem				0x00000004	/* bit 3	*/
+#define	kV34NotCMEModem				0x00000000	/* bit 3	*/
+
+#define	kV34ExtraINFOPreamble		0x00000008	/* bit 4	*/
+
+#define	kRetrainingEnabled			0x00000010
+#define	kRateRenegotiationEnabled	0x00000020
+#define	kTrellisCodingEnabled		0x00000040
+
+/* Fax specific features	*/
+#define	kFaxShortTraining			0x00000080
+#define	kFaxEchoSuppressionEnabled	0x00000100
+
+/* V.22/V.22bis specific features	*/
+#define	kV22GuardTone1800HzEnabled	0x00000200
+#define	kV22GuardTone550HzEnabled	0x00000400
+
+
+/* V.34 specific features	*/
+
+#define	kV34bisEnabled				0x00000800
+
+#define	kV34PowerReductionAllowed	0x00001000
+#define	kAuxChannelEnabled			0x00002000
+#define	kAuxChannelDisabled			0x00000000
+#define	kV34TrellisEncoderTypeMask	0x0000C000
+#define	kV34TrellisEncoderTypeShift	14
+
+#define	kTRN16						0x00010000
+#define	kAssymDataRatesEnabled		0x00020000
+#define	kNonLinearCodingEnabled		0x00040000
+#define	kConstShapingEnabled		0x00080000
+#define	kPrecodingEnabled			0x00100000
+
+#define	kV34LoFcAt2400HzEnabled		0x00200000
+#define	kV34HiFcAt2400HzEnabled		0x00400000
+#define	kV34LoFcAt2743HzEnabled		0x00800000
+#define	kV34HiFcAt2743HzEnabled		0x01000000
+#define	kV34LoFcAt2800HzEnabled		0x02000000
+#define	kV34HiFcAt2800HzEnabled		0x04000000
+#define	kV34LoFcAt3000HzEnabled		0x08000000
+#define	kV34HiFcAt3000HzEnabled		0x10000000
+#define	kV34LoFcAt3200HzEnabled		0x20000000
+#define	kV34HiFcAt3200HzEnabled		0x40000000
+#define	kV34LoFcAt3429HzEnabled		0x80000000
+#define	kV34HiFcAt3429HzEnabled		0x80000000
+
+/* auxiliary features definintions map */
+
+#define	kLoopbackTestFinish				0x00000000
+#define	kLoopbackTestV54Loop1			0x00000001
+#define	kLoopbackTestV54Loop2			0x00000002
+#define	kLoopbackTestV54Loop3			0x00000003
+#define	kLoopbackTestTypeMask			0x00000003
+#define	kLoopbackTestAutoRespondEnabled	0x00000004
+#define	kLoopbackSelfTest				0x00000008
+
+#define	kPreempFilterMask			0x000000F0
+#define	kPreempFilterShift			4
+
+#define	kPcmCodingTypeMuLaw			0x00000100
+#define	kPcmServerToServerEnabled	0x00000200
+#define	kPcmIsServerModem			0x00000400
+#define	kPcmAnalogModemAvailable	0x00000800
+#define	kPcmDigitalModemAvailable	0x00001000
+#define	kPcmDceOnDigitalNetwork		0x00002000
+#define	kPcmDModemPwrCalAtCodecOut	0x00004000
+#define	kPcm3429UpstreamAvailable	0x00008000
+
+#define	kPcmSpectralShapingBitsMask		0x00070000
+#define	kPcmSpectralShapingBitsShift	16
+#define	kV90ServerNotDetSbarAfterJdbarFix	0x00080000
+
+#define kAutomoderPassive			0x00400000
+
+#define	kV8HoldANSamUntilDetCI		0x00800000
+#define	kFaxSendFromOrgSide			0x01000000
+#define	kFaxV34HDX2400bpsCtrlChan	0x02000000
+#define	kFaxV34HDXAllowAsymCtrlChan	0x04000000
+#define	kV8ANSamStageDisabled		0x08000000
+
+#define kFlexSkipV8bis              0x10000000
+#define kV34ControlChannelEnabled   0x20000000
+#define kV34SeamlessRateChangeEnabled 0x40000000
+
+#define	kPTTTest					0x80000000
+
+/* call progress detection Map	*/
+
+#define	kDialTone				0x00000001
+#define	kRingBack				0x00000002
+#define	kBusy					0x00000004
+#define	kReorder				0x00000008
+#define	k2ndDTn					0x00000010
+#define	kBongTone				0x00000020
+
+/* Break type bit settings	*/
+#define	kExpedited		0x0001
+#define	kDestructive	0x0002
+
+/* async Framer setup map		*/
+
+#define	kNDataBitsMask	0x03
+#define	k5DataBits		0x00
+#define	k6DataBits		0x01
+#define	k7DataBits		0x02
+#define	k8DataBits		0x03
+
+#define	kNDataBitsShift		0
+#define	kNDataBitsOffset	5
+
+#define	kParityTypeMask	0x1C
+#define	kNoParity		0x00
+#define	kOddParity		0x04
+#define	kEvenParity		0x08
+#define	kMarkParity		0x0C
+#define	kSpaceParity	0x10
+
+#define	kNStopBitsMask	0x60
+#define	k1StopBits		0x00
+#define	k2StopBits		0x20
+
+#define	kNStopBitsShift		5
+#define	kNStopBitsOffset	1
+
+/* Sync Framer setup map		*/
+
+#define kUnderrunCharMask			0xff
+#define kRepeatLastCharOnUnderrun	0x100
+
+/* HDLC sync framer setup maps	*/
+#define	kNFlagsBeforeFramesMask		0x3F
+#define	kNFlagsBeforeFramesShift	0
+
+#define	kNFlagsBetweenFramesMask	0x3F
+#define	kNFlagsBetweenFramesShift	6
+
+#define	k32BitCRC					0x1000
+#define	kFlagSharingEnabled			0x2000
+
+#define kNFlagsBeforeReportMask		0x03	/* no. of *extra* flags reqd before frame */
+#define kNFlagsBeforeReportShift	14
+
+#define	kTxDeferredCRC				0x10000
+#define	kRxDeferredCRC				0x20000
+#define	kTxIdleMarks				0x40000
+#define kNoCRC						0x80000
+
+/* SAM framer setup maps	*/
+
+#define	kSAMTransparentIdleTypeMask		0x00000003
+#define	kSAMTransparentIdleTypeShift	0
+#define	kSAMFramedIdleTypeMask			0x00000004
+#define	kSAMFramedIdleTypeShift			2
+#define	kSAMFramedOverrunActionMask		0x00000010
+#define	kSAMFramedOverrunActionShift	4
+#define	kSAMHalfDuplexModeMask			0x00000020
+#define	kSAMHalfDuplexModeShift			5
+#define	kSAMCRCTypeMask					0x000000C0
+#define	kSAMCRCTypeShift				6
+#define	kSAMNRZIEnabledMask				0x00000100
+#define	kSAMNRZIEnabledShift			8
+#define	kSAMSyn1Mask					0x00FF0000
+#define	kSAMSyn1Shift					16
+#define	kSAMSyn2Mask					0xFF000000
+#define	kSAMSyn2Shift					24
+
+/* <trans_idle> */
+#define	kSAM8bitSYNHuntDisabled		0
+#define	kSAM8bitSYNHuntEnabled		((ulong)1 << kSAMTransparentIdleTypeShift)
+#define	kSAM16bitSYNHuntEnabled		((ulong)2 << kSAMTransparentIdleTypeShift)
+
+/* <framed_idle> */
+#define	kSAMSendFlagsOnIdle			0
+#define	kSAMSendMarksOnIdle			((ulong)1 << kSAMFramedIdleTypeShift)
+
+/* <framed_un_ov> */
+#define	kSAMAbortOnUnderrun			0
+#define	kSAMFlagsOnUnderrun			((ulong)1 << kSAMFramedOverrunActionShift)
+
+/* <hd_auto> */
+#define	kSAMHalfDuplexNoAuto		0
+#define	kSAMHalfDuplexAuto			((ulong)1 << kSAMHalfDuplexModeShift)
+
+
+/* <crc_type> */
+#define	kSAMNoCRC					0
+#define	kSAM16bitCRC				((ulong)1 << kSAMCRCTypeShift) 
+#define	kSAM32bitCRC				((ulong)2 << kSAMCRCTypeShift) 
+				
+/* <nrzi_en> */
+#define	kSAMNRZIDisabled			0
+#define	kSAMNRZIEnabled				((ulong)1 << kSAMNRZIEnabledShift)
+
+
+/* LAPM setup maps	*/
+#define	kLapmDirection				0x00000001		/* Bit 0  */
+#define	kLapmSREJEnabled			0x00000002		/* Bit 1  */
+#define	kLapmDetectionEnabled		0x00000004		/* Bit 2  */
+#define	kLapmLongADPEnabled			0x00000008		/* Bit 3  */
+
+#define	kLapmCompressionEnabledMask	0x00000030
+#define	kLapmTxCompressionEnabled	0x00000010		/* Bit 4  */
+#define	kLapmRxCompressionEnabled	0x00000020		/* Bit 5  */
+#define	kLapmCompressionEnabledShift		4
+
+#define	kLapmRetryLimitMask			0x000000C0		/* Bits 6,7  */
+
+#define	kLapmNoRetryLimit			0x00000000
+#define	kLapm4Retries				0x00000040
+#define	kLapm8Retries				0x00000080
+#define	kLapm20Retries				0x000000C0
+
+#define	kLapmWindowSizeMask			0x00001F00		/* Bits 8-12  */
+#define	kLapmWindowSizeShift		8
+
+#define	kLapmWindowSize8			0x00000800
+#define	kLapmWindowSize15			0x00000F00
+
+
+#define	kLapmInfoFieldSizeMask		0x0000E000		/* Bits 13-15  */
+#define	kLapmInfoField8Bytes		0x00000000
+#define	kLapmInfoField16Bytes		0x00002000
+#define	kLapmInfoField32Bytes		0x00004000
+#define	kLapmInfoField64Bytes		0x00006000
+#define	kLapmInfoField128Bytes		0x00008000
+#define	kLapmInfoField192Bytes		0x0000A000
+#define	kLapmInfoField256Bytes		0x0000C000
+#define	kLapmInfoField512Bytes		0x0000E000
+#define	kLapmInfoFieldSizeShift		13
+
+#define	kLapmT400Mask				0x00030000		/* Bits 16-17	*/
+#define	kLapmAutoT400				0x00000000
+#define	kLapm750msT400				0x00010000
+#define	kLapm3secT400				0x00020000
+#define	kLapm30secT400				0x00030000
+
+#define	kLapmT401Mask				0x000C0000		/* Bits 18-19	*/
+#define	kLapmAutoT401				0x00000000
+#define	kLapm750msT401				0x00040000
+#define	kLapm3secT401				0x00080000
+#define	kLapm6secT401				0x000C0000
+
+#define	kLapmT403Mask				0x00300000		/* Bits 20-21	*/
+#define	kLapmAutoT403				0x00000000
+#define	kLapm750msT403				0x00100000
+#define	kLapm2secT403				0x00200000
+#define	kLapm4secT403				0x00300000
+
+
+
+#define	kLapmDictSizeMask			0x00C00000		/* Bits 22-23  */
+#define	kLapmDictSize512			0x00000000
+#define	kLapmDictSize1024			0x00400000
+#define	kLapmDictSize2048			0x00800000
+#define	kLapmDictSize4096			0x00C00000
+
+#define	kLapmStringSizeMask			0xFF000000		/* Bits 24-31  */
+#define	kLapmStringSizeShift		24
+
+/* MNP setup maps	*/
+
+#define	kMnpMinPLevel				0x00000001		/* Bit 0: 1 - Minimal, 0 - Standard */
+#define	kMnpStdPLevel				0x00000000		/* Bit 0: 1 - Minimal, 0 - Standard */
+
+#define	kMnpOptimizationEnabled		0x00000002		/* Bit 1  */
+#define	kMnpOptimizationDisabled	0x00000000		/* Bit 1  */
+
+#define	kMnpCompressionEnabled		0x00000004		/* Bit 2  */
+#define	kMnpCompressionDisabled		0x00000000		/* Bit 2  */
+
+#define	kMnpClassMask				0x00000018
+#define	kMnpClassShift						 3
+#define	kMnpClass1					0x00000008
+#define	kMnpClass2					0x00000010
+#define	kMnpClass3					0x00000018		/* Bits 3,4 */
+
+#define kMnpMaxRetryMask		    0x00000060		/* Bits 5,6 */
+#define kMnpMaxRetryShift					 5
+#define	kMnpNoRetryLimit			0x00000000
+#define	kMnp4Retries				0x00000020
+#define	kMnp8Retries				0x00000040
+#define	kMnp20Retries				0x00000060
+
+#define	kMnpInfoFieldSizeMask		0x00000380		/* Bits 7-9  */
+#define	kMnpInfoFieldSizeShift				 7
+#define	kMnpInfoField8Bytes			0x00000000
+#define	kMnpInfoField16Bytes		0x00000080
+#define	kMnpInfoField32Bytes		0x00000100
+#define	kMnpInfoField64Bytes		0x00000180
+#define	kMnpInfoField128Bytes		0x00000200
+#define	kMnpInfoField192Bytes		0x00000280
+#define	kMnpInfoField256Bytes		0x00000300
+#define	kMnpInfoField260Bytes		0x00000380
+
+#define	kMnpT400Mask				0x00003000		/* Bits 12,13 */
+#define	kMnpT400Shift						12
+#define	kMnpAutoT400				0x00000000
+#define	kMnp750msT400				0x00001000
+#define	kMnp3secT400				0x00002000
+#define	kMnp6secT400				0x00003000
+
+#define	kMnpT401Mask				0x0000C000		/* Bits 14,15 */
+#define	kMnpT401Shift						14
+#define	kMnpAutoT401				0x00000000
+#define	kMnp750msT401				0x00004000
+#define	kMnp3secT401				0x00008000
+#define	kMnp6secT401				0x0000C000
+
+#define	kMnpT403Mask				0x00030000		/* Bits 16,17 */
+#define	kMnpT403Shift						16
+#define	kMnpAutoT403				0x00000000
+#define	kMnp60secT403				0x00010000
+#define	kMnp600secT403				0x00020000
+#define	kMnp3600secT403				0x00030000
+
+#define kMnpFallbackTypeMask		0x000C0000		/* Bits 18,19 */
+#define kMnpFallbackTypeShift				18
+#define kMnpNoFallback				0x00000000
+#define kMnpFallbackTime			0x00040000
+#define kMnpFallback200				0x00080000
+#define kMnpFallbackChar			0x000C0000
+
+#define	kMnpWindowSizeMask			0x00300000		/* Bits 20,21  */
+#define	kMnpWindowSizeShift					20
+#define	kMnp1Frame 					0x00000000
+#define	kMnp4Frames 				0x00100000
+#define	kMnp8Frames 				0x00200000
+#define	kMnp16Frames 				0x00300000
+
+#define	kMnpDirection				0x00800000		/* Bit 22  */
+
+#define kMnpFallbackCharMask		0xFF000000		/* Bit 24-31  */
+#define kMnpFallbackCharShift				24
+
+/* kV34HDXTurnOffCurrentModeCmd state parameter values */
+
+#define	kV34HDXTurnOffAsClearDown				0
+#define	kV34HDXTurnOffFromControlSource			1
+#define	kV34HDXTurnOffFromControlDestination	2
+#define	kV34HDXTurnOffFromPrimarySource			3
+#define	kV34HDXTurnOffFromPrimaryDestination	4
+
+/* V70 setup maps */
+
+#define	kV70Direction				0x00000001		/* Bit 0  */
+#define	kV70uIHEnabled			    0x00000002		/* Bit 1  */
+#define	kV70AudioHeaderEnabled	    0x00000004		/* Bit 2  */
+#define kV70SilenceSupprEnabled     0x00000008		/* Bit 3  */
+
+#define	kV70SuspendResumeShift      4 
+#define	kV70SuspendResumeMask	    (3 << kV70SuspendResumeShift)
+#define	kV70SuspendResumeDisabled   0x00000000		/* Bit 4,5  */
+#define	kV70SuspendResumeWAddr      0x00000010		/* Bit 4  */
+#define	kV70SuspendResumeWoAddr     0x00000020		/* Bit 5  */
+
+#define	kV70CrcLengthShift          6 
+#define	kV70CrcLengthMask	        (3 << kV70CrcLengthShift)
+#define	kV70CrcLength16             0x00000000		/* Bit 6,7  */
+#define	kV70CrcLength8              0x00000040		/* Bit 6  */
+#define	kV70CrcLength32             0x00000080		/* Bit 7  */
+
+#define	kV70BlockingFactorShift     8 
+#define	kV70BlockingFactorMask	    (3 << kV70BlockingFactorShift)
+#define	kV70BlockingFactor1         0x00000000		/* Bit 8,9  */
+#define	kV70BlockingFactor2         0x00000100		/* Bit 8  */
+#define	kV70BlockingFactor3			0x00000200		/* Bit 9  */
+#define	kV70BlockingFactor4			0x00000300		/* Bit 8,9  */
+
+#define kV70InitChannelsShift		10
+#define kV70InitChannelsMask		(1 << kV70InitChannelsShift)
+#define	kV70InitNoChannels			0x00000000		/* Bit 10,11  */
+#define	kV70InitDataChannel			0x00000400		/* Bit 10,11  */
+#define	kV70InitAudioChannel		0x00000800		/* Bit 10,11  */
+#define	kV70InitBothChannels		0x00000C00		/* Bit 10,11  */
+
+#define kV70OOBEnabled				0x00001000		/* Bit 12 */
+
+/* V80 setup maps */
+
+#define	kV80Direction				0x00000001		/* Bit 0  */
+
+#define	kV80ModeShift				1 
+#define	kV80ModeMask				(3 << kV80ModeShift)
+#define	kV80SyncMode				(0 << kV80ModeShift)
+#define	kV80TunnellingMode			(1 << kV80ModeShift)
+#define	kV80SamMode					(2 << kV80ModeShift)
+#define	kV80SamTransparentMode		(2 << kV80ModeShift)
+#define	kV80SamFramedMode			(3 << kV80ModeShift)
+
+#define	kV80TransIdleShift			3 
+#define	kV80TransIdleMask			(3 << kV80TransIdleShift)
+#define	kV80TransIdleNoHunt			(0 << kV80TransIdleShift)
+#define	kV80TransIdleHunt8			(1 << kV80TransIdleShift)
+#define	kV80TransIdleHunt16			(2 << kV80TransIdleShift)
+
+#define	kV80FrameIdleShift			5 
+#define	kV80FrameIdleMask			(1 << kV80FrameIdleShift)
+#define	kV80FrameIdleFlags			(0 << kV80FrameIdleShift)
+#define	kV80FrameIdleMarks			(1 << kV80FrameIdleShift)
+
+#define	kV80FrameUnOvShift			6 
+#define	kV80FrameUnOvMask			(1 << kV80FrameUnOvShift)
+#define	kV80FrameUnOvAbort			(0 << kV80FrameUnOvShift)
+#define	kV80FrameUnOvFlag			(1 << kV80FrameUnOvShift)
+ 
+#define	kV80HdAutoShift				7 
+#define	kV80HdAutoMask				(1 << kV80HdAutoShift)
+#define	kV80HdAutoNormal			(0 << kV80HdAutoShift)
+#define	kV80HdAutoExtended			(1 << kV80HdAutoShift)
+
+#define	kV80CrcTypeShift			8 
+#define	kV80CrcTypeMask				(3 << kV80CrcTypeShift)
+#define	kV80NoCrc					(0 << kV80CrcTypeShift)
+#define	kV80Crc16					(1 << kV80CrcTypeShift)
+#define	kV80Crc32					(2 << kV80CrcTypeShift)
+
+#define	kV80NrziShift				10
+#define	kV80NrziMask				(1 << kV80NrziShift)
+#define	kV80NrziDisabled			(0 << kV80NrziShift)
+#define	kV80NrziEnabled				(1 << kV80NrziShift)
+
+#define kV80Syn1Mask				0x00FF0000		/* Bit 16-23  */
+#define kV80Syn1Shift				16
+#define kV80Syn2Mask				0xFF000000		/* Bit 24-31  */
+#define kV80Syn2Shift				24
+
+/* kStartCallProgressMonitorCmd setup masks */
+
+#define	kDTMFDetectorDebouncerEnabled			0x0001
+#define	kModemSignalDetectorDebouncerEnabled	0x0002
+#define	kCallProgressDetectorDebouncerEnabled	0x0004
+#define	kCustomSignalDebouncerEnabled			0x0008
+#define	kFaxCallingToneSuppressionEnabled		0x0010
+#define	kDataCallingToneSuppressionEnabled		0x0020
+#define	kCISuppressionEnabled					0x0040
+#define	kAnsSuppressionEnabled					0x0080
+
+/* kDialCmd setup masks (dialerSetup bit fields) */
+
+#define	kDTMFDialingEnabled						0x0001
+#define	kPulseDialingEnabled					0x0002
+#define	kModeSwitchEnabled						0x0004
+#define	kBlindDialingEnabled					0x0008
+#define	kPulseDialingMethodMask					0x0030
+#define	kDialModifierTranslationMask			0x00C0
+#define	kFlashWhilePulseDialingEnabled			0x0100
+
+/* Pulse dialing method */
+#define	kPulseDialingNPulsesPerDigit			0x0000
+#define	kPulseDialingNplusOnePulsesPerDigit		0x0010
+#define	kPulseDialingTenMinusNPulsesPerDigit	0x0020
+
+/* Dial modifier translation */
+#define	kTreatWasPause							0x0040	/* Tread 'W' modifier as pause */
+#define	kTreatCommaAsWaitForDialtone			0x0080
+
+#ifdef TI_C6X
+#include "C6xDefs.h"
+#endif
+#ifdef PENTIUM_MMX
+#include "PentiumDefs.h"
+#endif
+
+
+#if defined(DSP16K) && !defined(SoftModemGlobals)
+/* ensure that code generator does not use r5 */
+register int *softmodem_h_should_not_be_included_after_softmodem_gh asm("r5");
+#endif
+
+/****************************************************************************/
+/*	3.	Interface functions.												*/
+/*																			*/
+/****************************************************************************/
+
+#ifdef ADSL_MODEM
+
+#ifndef SoftDslHeader
+#include "SoftDsl.h"
+#endif
+extern	char*	SM_DECL SoftModemGetRevString(void);
+extern	char*	SM_DECL SoftModemGetProductName(void);
+extern	char*	SM_DECL	SoftModemGetBuildDate(void);
+extern	char*	SM_DECL SoftModemGetFullManufacturerName(void);
+extern	char*	SM_DECL SoftModemGetShortManufacturerName(void);
+extern	int		SM_DECL SoftModemRevStringSize(void);
+extern	char*	SM_DECL SoftModemGetVendorIDString(void);
+extern	char*	SM_DECL SoftModemGetT1413VendorIDString(void);
+extern	char*	SM_DECL SoftModemGetSerialNumberString(void);
+extern	int		SM_DECL SoftModemSerNumStringSize(void);
+#define	SoftDslGetProductName			SoftModemGetProductName
+#define	SoftDslGetBuildDate				SoftModemGetBuildDate
+#define	SoftDslGetFullManufacturerName	SoftModemGetFullManufacturerName
+#define	SoftDslGetShortManufacturerName	SoftModemGetShortManufacturerName
+
+#else /* !ADSL_MODEM */
+
+extern void		SM_DECL SoftModemSetMemoryPtr	(void	*varsPtr);
+extern void*	SM_DECL SoftModemGetMemoryPtr	(void);
+extern void		SM_DECL SoftModemSetRefData		(void	*varsPtr);
+extern void*	SM_DECL SoftModemGetRefData		(void);
+extern int		SM_DECL SoftModemGetMemorySize	(void);
+extern void		SM_DECL SoftModemInit			(void);
+extern void		SM_DECL SoftModemReset			(void);
+extern void		SM_DECL SoftModemLineHandler	(int sampleCount, short *srcPtr, short *dstPtr);
+extern void		SM_DECL SoftModemTimer			(long timeQ24ms);
+extern Boolean	SM_DECL SoftModemCommandHandler	(modemCommandStruct *cmdPtr);
+extern int		SM_DECL SoftModemGetExternalMemorySize(void);
+extern void		SM_DECL SoftModemSetExternalMemoryPtr(void	*varsPtr);
+
+extern void		SM_DECL SoftModemSetPcmCoding	(pcmCodingType pcmCoding);
+extern void		SM_DECL SoftModemPcmLineHandler	(int sampleCount, uchar *srcPtr, uchar *dstPtr);
+
+/* SoftModem IO functions	*/
+extern int		SM_DECL SoftModemWrite(int nBytes, uchar* srcPtr);
+extern int		SM_DECL SoftModemRead(int nBytes, uchar* dstPtr);
+extern int		SM_DECL SoftModemWriteFrame(int nBytes, uchar* srcPtr);
+extern int		SM_DECL SoftModemReadFrame(int maxFrameSize, uchar* dstPtr);
+extern int		SM_DECL SoftModemCountWritePending(void);
+extern int		SM_DECL SoftModemCountReadPending(void);
+extern int		SM_DECL SoftModemWriteSpaceAvailable(void);
+extern void		SM_DECL SoftModemWriteFlush(void);
+extern void		SM_DECL SoftModemReadFlush(void);
+extern int		SM_DECL SoftModemGetWriteBufferSize(void);
+extern int		SM_DECL SoftModemGetReadBufferSize(void);
+
+#ifdef AUDIO
+extern int		SM_DECL SoftModemAudioHandler(int sampleCount, short *srcPtr, short *dstPtr);
+extern int		SM_DECL SoftModemAudioRxDataHandler(int nBytes, uchar* srcPtr);
+extern int		SM_DECL SoftModemAudioTxDataHandler(int nBytes, uchar* dstPtr);
+#endif
+
+
+#define	SoftModemSetGlobalPtr	SoftModemSetMemoryPtr
+#define	SoftModem				SoftModemLineHandler
+#ifndef LINKLAYER_V42BIS_LARGE_DICTIONARY
+#define	kSoftModemMaxMemorySize	(65536)
+#else
+#define	kSoftModemMaxMemorySize	(65536 + 8192)
+#endif
+
+/*
+ * Internal functions
+ */
+extern	long	SM_DECL SoftModemGetDCOffset(void);
+extern	void	SM_DECL SoftModemDisableDCOffsetTracking(void);
+extern	void	SM_DECL SoftModemEnableDCOffsetTracking(void);
+extern	long	SM_DECL SoftModemGetRcvPower(void);
+extern	ulong	SM_DECL SoftModemGetHybridDelay(void);
+extern  void	SM_DECL SoftModemStatusHandler	(modemStatusStruct *status);
+extern Boolean	SM_DECL SoftModemInternalCommandHandler	(modemCommandStruct *cmdPtr);
+extern  void	SM_DECL	SoftModemInternalStatusHandler	(modemStatusStruct *status);
+extern	void	SM_DECL SoftModemSetControllerOnlyMode(commandHandlerType externalDataPumpCommandHandlerPtr);
+extern	char*	SM_DECL SoftModemGetRevString(void);
+extern	char*	SM_DECL SoftModemGetProductName(void);
+extern	char*	SM_DECL	SoftModemGetBuildDate(void);
+extern	char*	SM_DECL SoftModemGetFullManufacturerName(void);
+extern	char*	SM_DECL SoftModemGetShortManufacturerName(void);
+extern	int		SM_DECL SoftModemRevStringSize(void);
+extern	char*	SM_DECL SoftModemGetVendorIDString(void);
+extern	char*	SM_DECL SoftModemGetSerialNumberString(void);
+extern  void	SM_DECL SoftModemAuxTxDataHandler(int nBytes, uchar *dataPtr);
+extern	void	SM_DECL SoftModemAuxRxDataHandler(int nBytes, uchar *dataPtr);
+extern  void	SM_DECL SoftModemTxDataHandler(int nBytes, uchar *dataPtr);
+extern	void	SM_DECL SoftModemRxDataHandler(int nBytes, uchar *dataPtr);
+extern	void	SM_DECL SoftModemATPrintf(uchar *format, void *arg1, void *arg2, void *arg3);
+
+#define	SoftModemSetInputSaturationLimit(limit)		(gSystemVars.inputSignalLimit = limit)	
+#define	SoftModemResetInputSaturationLimit()		(gSystemVars.inputSignalLimit = 0)
+
+#endif	/* !ADSL_MODEM */
+
+#endif	/* SoftModemPh */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModemTypes.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModemTypes.h
--- linux-2.6.8.1/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModemTypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/char/adsl/impl1/softdsl/SoftModemTypes.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,292 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * SoftModemTypes.h 
+ *
+ *
+ * Description:
+ *	This file contains some of the type declarations for SoftModem
+ *
+ * Copyright (c) 1993-1997 AltoCom, Inc. All rights reserved.
+ * Authors: Mark Gonikberg, Haixiang Liang.
+ *
+ * $Revision: 1.9 $
+ *
+ * $Id: SoftModemTypes.h,v 1.9 2004/04/13 00:16:59 ilyas Exp $
+ *
+ * $Log: SoftModemTypes.h,v $
+ * Revision 1.9  2004/04/13 00:16:59  ilyas
+ * Merged the latest ADSL driver changes
+ *
+ * Revision 1.8  2004/01/24 01:35:33  ytan
+ * add multi-section lmem swap
+ *
+ * Revision 1.7  2001/09/21 19:19:01  ilyas
+ * Minor fixes for VxWorks build
+ *
+ * Revision 1.6  2001/08/16 02:16:39  khp
+ * - added definitions for SLOW_DATA and FAST_TEXT, defined to nothing
+ *   except when bcm47xx && USE_SLOW_DATA or USE_FAST_TEXT.  Any function
+ *   that needs to run fast should be marked with FAST_TEXT.  Any data that
+ *   is not referenced often should be marked with SLOW_DATA.
+ *
+ * Revision 1.5  2001/03/30 00:49:59  liang
+ * Changed warning output message.
+ *
+ * Revision 1.4  2000/06/21 22:24:40  yongbing
+ * Modify WARN micro to limit the number of same warnings printed
+ *
+ * Revision 1.3  1999/08/05 20:02:13  liang
+ * Merged with the softmodem top of the tree on 08/04/99.
+ *
+ * Revision 1.2  1999/01/27 22:14:29  liang
+ * Merge with SoftModem_3_1_02.
+ *
+ * Revision 1.19  1998/11/17 04:02:39  yura
+ * Fixed WARN and ASSERT redefinition warning for WinNT targets
+ *
+ * Revision 1.18  1998/08/26 19:20:43  scott
+ * Commented out EXCLUDE_CYGWIN32_TYPES define
+ *
+ * Revision 1.17  1998/08/13 19:03:06  scott
+ * Added BitField definition and INT_IS_LONG
+ *
+ * Revision 1.16  1998/08/08 03:39:55  scott
+ * The DEBUG_PTR_ENABLED macro can be used to enable only the DEBUG_PTR macros
+ *
+ * Revision 1.15  1998/07/28 22:21:31  mwg
+ * Fixed problems with NULL & nil being defined incorrectly
+ *
+ * Revision 1.14  1998/07/08 17:09:17  scott
+ * Define ASSERT and WARN only if not already defined
+ *
+ * Revision 1.13  1998/07/02 20:46:34  scott
+ * Added workaround for building certain builds with older SunOS
+ *
+ * Revision 1.12  1998/02/09 18:24:49  scott
+ * Defined "Private" as nothing for GreenHill (to prevent erroneous section
+ * allocations for data)
+ *
+ * Revision 1.11  1997/08/29 21:39:24  scott
+ * Added check for LONG_IS_INT define (for TI C6X support)
+ *
+ * Revision 1.10  1997/05/29 19:50:23  mwg
+ * Added code to avoid type redefintions under SunOS.
+ *
+ * Revision 1.9  1997/03/19 18:35:08  mwg
+ * Changed copyright notice.
+ *
+ * Revision 1.8  1997/02/11  00:05:53  mwg
+ * Minor adjustments for Pentium optimization.
+ *
+ * Revision 1.7  1997/01/11  01:30:47  mwg
+ * Added new macro WARN -- the same as ASSERT but without exit.
+ *
+ * Revision 1.6  1996/08/22  20:07:39  liang
+ * When ASSERT fires, only print out information, don't exit.
+ *
+ * Revision 1.5  1996/05/06  06:49:10  mwg
+ * Fixed linux problems.
+ *
+ * Revision 1.4  1996/05/02  08:40:16  mwg
+ * Merged in Chromatic bug fixes.
+ *
+ * Revision 1.3  1996/04/01  20:59:53  mwg
+ * Added macros to setup and use debug pointer.
+ *
+ * Revision 1.2  1996/02/27  01:50:04  mwg
+ * Added ASSERT() macro.
+ *
+ * Revision 1.1.1.1  1996/02/14  02:35:13  mwg
+ * Redesigned the project directory structure. Merged V.34 into the project.
+ *
+ * Revision 1.2  1995/12/03  06:59:31  mwg
+ * Fixed all gcc varnings. We are now running under Linux on a PC!
+ *
+ *****************************************************************************/
+#ifndef	SoftModemTypesh
+#define	SoftModemTypesh
+
+#ifdef LONG_SHORTS
+#define	short	long
+#define	ushort	unsigned long
+#endif
+
+typedef signed char			schar;
+typedef unsigned char		uchar;
+
+#if 0 /* This is not currently required */
+#if defined(_CYGWIN32) && defined(DEBUG)
+#define EXCLUDE_CYGWIN32_TYPES
+#endif
+#endif
+
+#if !defined(_SYS_TYPES_H) || !defined(TARG_OS_RTEMS)
+#if defined(_CFE_)
+ typedef unsigned int		uint;
+ typedef unsigned long		ulong;
+ typedef unsigned short		ushort;
+#elif defined(TARG_OS_RTEMS)
+#if defined(HOST_ARCH_LINUX)
+ typedef unsigned int		uint;
+#endif
+ typedef unsigned long		ulong;
+#if defined(HOST_ARCH_LINUX)
+ typedef unsigned short		ushort;
+#endif
+#elif defined(EXCLUDE_CYGWIN32_TYPES) || (!defined _NO_TYPE_DEFS_ && !defined _SYS_TYPES_H && !defined __SYS_TYPES_H__ && !defined _SYS_BSD_TYPES_H && !defined _LINUX_TYPES_H) || defined(__sparc__)
+#ifndef EXCLUDE_CYGWIN32_TYPES
+ typedef unsigned int		uint;
+#endif
+#ifndef _LINUX_TYPES_H
+ typedef unsigned long		ulong;
+#endif
+#if !defined(ushort) && !defined(EXCLUDE_CYGWIN32_TYPES) && !defined(__INCvxTypesOldh)
+ typedef unsigned short		ushort;
+#endif
+#endif
+#else
+typedef unsigned long		ulong;
+#endif
+
+#if defined(GREENHILL) || defined(GNUTX39) /* GH allocates private data to incorrect section */
+#define Private
+#else
+#define Private             static
+#endif
+
+#define Public
+
+#ifdef NULL
+#undef NULL
+#endif
+#ifdef nil
+#undef nil
+#endif
+
+#define NULL 0
+#define nil 0
+
+#define false 0
+#define true 1
+typedef unsigned char Boolean;
+typedef unsigned int BitField; /* this must occur BEFORE long_is_int/int_is_long defs */
+
+#ifdef LONG_IS_INT
+#define long int
+#define ulong uint
+#endif
+
+#ifdef INT_IS_LONG
+#define int long
+#define uint ulong
+#endif
+
+#define POSTULATE(postulate)											\
+   do																	\
+	   {																\
+	   typedef struct													\
+		   {															\
+		   char	NegativeSizeIfPostulateFalse[((int)(postulate))*2 - 1];	\
+		   } PostulateCheckStruct;										\
+	   }																\
+   while (0)
+
+#if defined(DEBUG) && !defined(__KERNEL__)
+#ifndef WARN
+#define	kDSLNumberWarnTimes	10
+#define WARN(assertion) \
+	{ static int	warnSeveralTimes=0;	\
+	  if ((!(assertion))&(warnSeveralTimes<kDSLNumberWarnTimes)) \
+		{ \
+		fprintf(stderr, "Warning, failed: %s\n", #assertion); \
+		fprintf(stderr, "%s:%d\n", __FILE__, __LINE__); \
+		warnSeveralTimes++;	\
+		} \
+	}
+#endif
+#ifndef ASSERT
+#define ASSERT(assertion) \
+	{ if (!(assertion)) \
+		{ \
+		fprintf(stderr, "Assertion failed: %s\n", #assertion); \
+		fprintf(stderr, "%s:%d\n", __FILE__, __LINE__); \
+		exit(1); \
+		} \
+	}
+#endif
+#else
+
+#undef WARN
+#define	WARN(a)
+
+#undef ASSERT
+#define	ASSERT(a)
+
+#endif
+
+/*
+ * memory allocation macros
+ */
+
+#if defined(bcm47xx) && defined(USE_SLOW_DATA)
+#define SLOW_DATA __attribute__ ((section(".slow_data")))
+#else
+#define SLOW_DATA
+#endif
+
+#if defined(bcm47xx) && defined(USE_FAST_TEXT)
+#define FAST_TEXT __attribute__ ((section(".fast_text")))
+#else
+#define FAST_TEXT
+#endif
+
+#if defined(bcm47xx) && defined(SWAP_LMEM)
+#define SWAP_TEXT1_1 __attribute__ ((section(".swap_text1_1")))
+#define SWAP_TEXT1_2 __attribute__ ((section(".swap_text1_2")))
+#define SWAP_TEXT2_1 __attribute__ ((section(".swap_text2_1")))
+#define SWAP_TEXT2_2 __attribute__ ((section(".swap_text2_2")))
+#define SWAP_TEXT3_1 __attribute__ ((section(".swap_text3_1")))
+#define SWAP_TEXT3_2 __attribute__ ((section(".swap_text3_2")))
+#else
+#define SWAP_TEXT1_1 FAST_TEXT
+#define SWAP_TEXT1_2 FAST_TEXT
+#define SWAP_TEXT2_1 FAST_TEXT
+#define SWAP_TEXT2_2 FAST_TEXT
+#define SWAP_TEXT3_1 FAST_TEXT
+#define SWAP_TEXT3_2 FAST_TEXT
+#endif
+
+/*
+ * Debug stuff
+ */
+#if defined(DEBUG) || defined(DEBUG_PTR_ENABLED)
+#define	DECLARE_DEBUG_PTR(type)		static	type	*gv;
+#define	SETUP_DEBUG_PTR()			gv = &globalVar
+#else
+#define	DECLARE_DEBUG_PTR(type)
+#define	SETUP_DEBUG_PTR()
+#endif
+/*
+ * Obsolete stuff
+ */
+#ifdef DEBUG
+#define	HereIsTheGlobalVarPointerMacro		SETUP_DEBUG_PTR();
+#else
+#define	HereIsTheGlobalVarPointerMacro
+#endif
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6338_common.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6338_common.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6338_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6338_common.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,207 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE: 6338_common.h                                             */
+/*   DATE:    05/10/04                                                 */
+/*   PURPOSE: Define addresses of major hardware components of         */
+/*            BCM6338                                                  */
+/*                                                                     */
+/***********************************************************************/
+#ifndef __BCM6338_MAP_COMMON_H
+#define __BCM6338_MAP_COMMON_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#define PERF_BASE     0xfffe0000    /* chip control registers */
+#define BB_BASE       0xfffe0100    /* bus bridge registers */
+#define TIMR_BASE     0xfffe0200    /* timer registers */
+#define UART_BASE     0xfffe0300    /* uart registers */
+#define GPIO_BASE     0xfffe0400    /* gpio registers */
+#define SPI_BASE      0xfffe0c00    /* SPI master controller registers */
+
+#define ADSL_BASE     0xfffe1000	/* ADSL core control registers */
+#define ATM_BASE      0xfffe2000	/* ATM SAR control registers */
+#define EMAC_DMA_BASE 0xfffe2400    /* EMAC DMA control registers */
+#define USB_DMA_BASE  0xfffe2400    /* USB DMA control registers */
+#define EMAC1_BASE    0xfffe2800    /* EMAC1 control registers */
+#define USB_CTL_BASE  0xfffe3000    /* USB control registers */
+#define SDRAM_BASE    0xfffe3100    /* SDRAM control registers */
+
+
+/*
+#####################################################################
+# System PLL Control Register
+#####################################################################
+*/
+
+#define SOFT_RESET	0x00000001
+
+/*
+#####################################################################
+# SDRAM Control Registers
+#####################################################################
+*/
+#define SDR_INIT_CTL        0x00
+    /* Control Bits */
+#define SDR_PFEN1           (1<<16)
+#define SDR_PFEN0           (1<<15)
+#define SDR_EMPRS           (1<<14)
+#define SDR_2_BANKS         (1<<13)
+#define SDR_1_BANK          (0<<13)
+#define SDR_CS1_EN          (1<<12)
+#define SDR_PEND            (1<<11)
+#define SDR_32_BIT          (1<<10)
+#define SDR_POWER_DOWN      (1<<9)
+#define SDR_SELF_REFRESH    (1<<8)
+#define SDR_11_COLS         (3<<6)
+#define SDR_10_COLS         (2<<6)
+#define SDR_9_COLS          (1<<6)
+#define SDR_8_COLS          (0<<6)
+#define SDR_13_ROWS         (2<<4)
+#define SDR_12_ROWS         (1<<4)
+#define SDR_11_ROWS         (0<<4)
+#define SDR_MASTER_EN       (1<<3)
+#define SDR_MRS_CMD         (1<<2)
+#define SDR_PRE_CMD         (1<<1)
+#define SDR_CBR_CMD         (1<<0)
+
+#define SDR_CFG_REG         0x04
+    /* Control Bits */
+#define SDR_FULL_PG         0
+#define SDR_BURST8          1
+#define SDR_BURST4          2
+#define SDR_BURST2          3
+#define SDR_FAST_MEM        (1<<2)
+#define SDR_SLOW_MEM        (0<<2)
+
+#define SDR_REF_CTL         0x0C
+    /* Control Bits */
+#define SDR_REF_EN          (1<<15)
+
+#define SDR_PRIOR
+    /* Control Bits */
+#define SDR_EN_PRIOR        (1<<31)
+
+
+/*
+#####################################################################
+# MPI Control Registers
+#####################################################################
+*/
+#define CS0BASE         0x00
+#define CS0CNTL         0x04
+
+/*
+# CSxBASE settings
+#   Size in low 4 bits
+#   Base Address for match in upper 24 bits
+*/
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+
+/* CSxCNTL settings */
+#define EBI_ENABLE          0x00000001  /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e  /* .. mask for wait states */
+#define ZEROWT              0x00000000  /* ..  0 WS */
+#define ONEWT               0x00000002  /* ..  1 WS */
+#define TWOWT               0x00000004  /* ..  2 WS */
+#define THREEWT             0x00000006  /* ..  3 WS */
+#define FOURWT              0x00000008  /* ..  4 WS */
+#define FIVEWT              0x0000000a  /* ..  5 WS */
+#define SIXWT               0x0000000c  /* ..  6 WS */
+#define SEVENWT             0x0000000e  /* ..  7 WS */
+#define EBI_WORD_WIDE       0x00000010  /* .. 16-bit peripheral, else 8 */
+#define EBI_POLARITY        0x00000040  /* .. set to invert chip select polarity */
+#define EBI_TS_TA_MODE      0x00000080  /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100  /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200  /* .. enable fifo */
+#define EBI_RE              0x00000400  /* .. Reverse Endian */
+
+/*
+#####################################################################
+# UART Control Registers
+#####################################################################
+*/
+#define UART0CONTROL     0x01
+#define UART0CONFIG      0x02
+#define UART0RXTIMEOUT   0x03
+#define UART0BAUD        0x04
+#define UART0FIFOCFG     0x0a
+#define UART0INTMASK     0x10
+#define UART0INTSTAT     0x12
+#define UART0DATA        0x17
+
+#define BRGEN            0x80   /* Control register bit defs */
+#define TXEN             0x40
+#define RXEN             0x20
+#define LOOPBK           0x10
+#define TXPARITYEN       0x08
+#define TXPARITYEVEN     0x04
+#define RXPARITYEN       0x02
+#define RXPARITYEVEN     0x01
+
+#define XMITBREAK        0x40   /* Config register */
+#define BITS5SYM         0x00
+#define BITS6SYM         0x10
+#define BITS7SYM         0x20
+#define BITS8SYM         0x30
+#define ONESTOP          0x07
+#define TWOSTOP          0x0f
+
+#define RSTTXFIFOS       0x80   /* Rx Timeout register */
+#define RSTRXFIFOS       0x40
+
+#define TX4              0x40   /* FIFO config register */
+#define RX4              0x04
+
+#define DELTAIP          0x0001 /* Interrupt Status and Mask registers */
+#define TXUNDERR         0x0002
+#define TXOVFERR         0x0004
+#define TXFIFOTHOLD      0x0008
+#define TXREADLATCH      0x0010
+#define TXFIFOEMT        0x0020
+#define RXUNDERR         0x0040
+#define RXOVFERR         0x0080
+#define RXTIMEOUT        0x0100
+#define RXFIFOFULL       0x0200
+#define RXFIFOTHOLD      0x0400
+#define RXFIFONE         0x0800
+#define RXFRAMERR        0x1000
+#define RXPARERR         0x2000
+#define RXBRK            0x4000
+          
+#if __cplusplus
+}
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6338_map.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6338_map.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6338_map.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6338_map.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,885 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  6338_map.h                                               */
+/*   DATE:    05/10/04                                                 */
+/*   PURPOSE: Define addresses of major hardware components of         */
+/*            BCM6338                                                  */
+/*                                                                     */
+/***********************************************************************/
+#ifndef __BCM6338_MAP_H
+#define __BCM6338_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+#include "6338_common.h"
+#include "6338_intr.h"
+
+/* macro to convert logical data addresses to physical */
+/* DMA hardware must see physical address */
+#define LtoP( x )       ( (uint32)x & 0x1fffffff )
+#define PtoL( x )       ( LtoP(x) | 0xa0000000 )
+
+/*
+** Interrupt Controller
+*/
+typedef struct PerfControl {
+  uint32        RevID;          /* (00) */
+  uint16        testControl;    /* (04) */
+  uint16        blkEnables;     /* (06) */
+
+#define ADSL_CLK_EN     0x0001
+#define MPI_CLK_EN      0x0002
+#define DRAM_CLK_EN     0x0004
+#define EMAC_CLK_EN     0x0010
+#define USBS_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+#define SPI_CLK_EN      0x0200
+
+  uint32        pll_control;    /* (08) */
+#define CHIP_SOFT_RESET 0x00000001
+
+  uint32        IrqMask;        /* (0c) */
+  uint32        IrqStatus;      /* (10) */
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+/*
+** Bus Bridge Registers
+*/
+typedef struct BusBridge {
+  uint16    status;
+#define BB_BUSY     0x8000      /* posted operation in progress */
+#define BB_RD_PND   0x4000      /* read pending */
+#define BB_RD_CMPLT 0x2000      /* read complete */
+#define BB_ERROR    0x1000      /* posted write error */
+#define BB_TEA      0x0800      /* transfer aborted */
+  uint16    abortTimeoutCnt;    /* abort timeout value */
+
+  byte      writePostEnable;
+#define BB_POST_TIMR_EN 0x08        /* post writes to timer regs */
+#define BB_POST_GPIO_EN 0x04        /* post writes to gpio regs */
+#define BB_POST_INTC_EN 0x02        /* post writes to interrupt controller regs */
+#define BB_POST_UART_EN 0x01        /* post writes to uart regs */
+  byte      unused1[5];
+  uint16    postAddr;       /* posted read address (lower half) */
+  byte      unused2[3];
+  byte      postData;       /* posted read data */
+} BusBridge;
+
+/* register offsets (needed for EBI master access) */
+#define BB_STATUS       0
+#define BB_ABORT_TO_CNT     2
+#define BB_WR_POST_EN       4
+#define BB_RD_POST_ADDR     10
+#define BB_RD_POST_DATA     12
+
+#define BRIDGE *bridge ((volatile BusBridge * const) BB_BASE)
+
+/*
+** Timer
+*/
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+/*
+** UART
+*/
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+/*
+** Gpio Controller
+*/
+
+typedef struct GpioControl {
+  uint32        unused0;
+  uint32        GPIODir;      /* bits 7:0 */
+  uint32        unused1;      /* bits 36:32 */
+  uint32        GPIOio;
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        vRegConfig;
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+/*
+** Spi Controller
+*/
+
+typedef struct SpiControl {
+  uint16        spiCmd;                 /* (0x0): SPI command */
+#define SPI_CMD_NOOP                    0
+#define SPI_CMD_SOFT_RESET              1
+#define SPI_CMD_HARD_RESET              2
+#define SPI_CMD_START_IMMEDIATE         3
+
+#define SPI_CMD_COMMAND_SHIFT           0
+#define SPI_CMD_DEVICE_ID_SHIFT         4
+#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT  8
+#define SPI_CMD_ONE_BYTE_SHIFT          11
+#define SPI_CMD_ONE_WIRE_SHIFT          12
+#define SPI_DEV_ID_0                    0
+#define SPI_DEV_ID_1                    1
+#define SPI_DEV_ID_2                    2
+#define SPI_DEV_ID_3                    3
+
+  byte          spiIntStatus;           /* (0x2): SPI interrupt status */
+  byte          spiMaskIntStatus;       /* (0x3): SPI masked interrupt status */
+
+  byte          spiIntMask;             /* (0x4): SPI interrupt mask */
+#define SPI_INTR_CMD_DONE               0x01
+#define SPI_INTR_RX_OVERFLOW            0x02
+#define SPI_INTR_INTR_TX_UNDERFLOW      0x04
+#define SPI_INTR_TX_OVERFLOW            0x08
+#define SPI_INTR_RX_UNDERFLOW           0x10
+#define SPI_INTR_CLEAR_ALL              0x1f
+
+  byte          spiStatus;              /* (0x5): SPI status */
+#define SPI_RX_EMPTY                    0x02
+#define SPI_CMD_BUSY                    0x04
+#define SPI_SERIAL_BUSY                 0x08
+
+  byte          spiClkCfg;              /* (0x6): SPI clock configuration */
+#define SPI_CLK_0_391MHZ                1
+#define SPI_CLK_0_781MHZ                2 /* default */
+#define SPI_CLK_1_563MHZ                3
+#define SPI_CLK_3_125MHZ                4
+#define SPI_CLK_6_250MHZ                5
+#define SPI_CLK_12_50MHZ                6
+#define SPI_CLK_MASK                    0x07
+#define SPI_SSOFFTIME_MASK              0x38
+#define SPI_SSOFFTIME_SHIFT             3
+#define SPI_BYTE_SWAP                   0x80
+
+  byte          spiFillByte;            /* (0x7): SPI fill byte */
+
+  byte          unused0; 
+  byte          spiMsgTail;             /* (0x9): msgtail */
+  byte          unused1; 
+  byte          spiRxTail;              /* (0xB): rxtail */
+
+  uint32        unused2[13];            /* (0x0c - 0x3c) reserved */
+
+  byte          spiMsgCtl;              /* (0x40) control byte */
+#define FULL_DUPLEX_RW                  0
+#define HALF_DUPLEX_W                   1
+#define HALF_DUPLEX_R                   2
+#define SPI_MSG_TYPE_SHIFT              6
+#define SPI_BYTE_CNT_SHIFT              0
+  byte          spiMsgData[63];         /* (0x41 - 0x7f) msg data */
+  byte          spiRxDataFifo[64];      /* (0x80 - 0xbf) rx data */
+  byte          unused3[64];            /* (0xc0 - 0xff) reserved */
+} SpiControl;
+
+#define SPI ((volatile SpiControl * const) SPI_BASE)
+
+#define IUDMA_MAX_CHANNELS      16
+
+/*
+** DMA Channel Configuration (1 .. 16)
+*/
+typedef struct DmaChannelCfg {
+  uint32        cfg;                    /* (00) assorted configuration */
+#define         DMA_BURST_HALT  0x00000004  /* idle after finish current memory burst */
+#define         DMA_PKT_HALT    0x00000002  /* idle after an EOP flag is detected */
+#define         DMA_ENABLE  0x00000001      /* set to enable channel */
+  uint32        intStat;                /* (04) interrupts control and status */
+  uint32        intMask;                /* (08) interrupts mask */
+#define         DMA_BUFF_DONE   0x00000001  /* buffer done */
+#define         DMA_DONE        0x00000002  /* packet xfer complete */
+#define         DMA_NO_DESC     0x00000004  /* no valid descriptors */
+  uint32        maxBurst;               /* (0C) max burst length permitted */
+} DmaChannelCfg;
+
+/*
+** DMA State RAM (1 .. 16)
+*/
+typedef struct DmaStateRam {
+  uint32        baseDescPtr;            /* (00) descriptor ring start address */
+  uint32        state_data;             /* (04) state/bytes done/ring offset */
+  uint32        desc_len_status;        /* (08) buffer descriptor status and len */
+  uint32        desc_base_bufptr;       /* (0C) buffer descrpitor current processing */
+} DmaStateRam;
+
+/*
+** DMA Registers
+*/
+typedef struct DmaRegs {
+#define DMA_MASTER_EN           0x00000001
+#define DMA_FLOWC_CH1_EN        0x00000002
+#define DMA_FLOWC_CH3_EN        0x00000004
+#define DMA_NUM_CHS_MASK        0x0f000000
+#define DMA_NUM_CHS_SHIFT       24
+#define DMA_FLOWCTL_MASK        0x30000000
+#define DMA_FLOWCTL_CH1         0x10000000
+#define DMA_FLOWCTL_CH3         0x20000000
+#define DMA_FLOWCTL_SHIFT       28
+    uint32 controller_cfg;              /* (00) controller configuration */
+
+    // Flow control Ch1
+    uint32 flowctl_ch1_thresh_lo;       /* (04) EMAC1 RX DMA channel */
+    uint32 flowctl_ch1_thresh_hi;       /* (08) EMAC1 RX DMA channel */
+    uint32 flowctl_ch1_alloc;           /* (0C) EMAC1 RX DMA channel */
+#define DMA_BUF_ALLOC_FORCE     0x80000000
+
+    // Flow control Ch3
+    uint32 flowctl_ch3_thresh_lo;       /* (10) EMAC2 RX DMA channel */
+    uint32 flowctl_ch3_thresh_hi;       /* (14) EMAC2 RX DMA channel */
+    uint32 flowctl_ch3_alloc;           /* (18) EMAC2 RX DMA channel */
+
+    // Unused words
+    uint32 resv[57];
+
+    // Per channel registers/state ram
+    DmaChannelCfg chcfg[IUDMA_MAX_CHANNELS]; /* (100) Channel configuration */
+    union {
+        DmaStateRam     s[IUDMA_MAX_CHANNELS];
+        uint32          u32[4 * IUDMA_MAX_CHANNELS];
+    } stram;                                /* (200) state ram */
+} DmaRegs;
+
+/*
+** DMA Buffer 
+*/
+typedef struct DmaDesc {
+  uint16        length;                 /* in bytes of data in buffer */
+#define          DMA_DESC_USEFPM    0x8000
+#define          DMA_DESC_MULTICAST 0x4000
+#define          DMA_DESC_BUFLENGTH 0x0fff
+  uint16        status;                 /* buffer status */
+#define          DMA_OWN        0x8000  /* cleared by DMA, set by SW */
+#define          DMA_EOP        0x4000  /* last buffer in packet */
+#define          DMA_SOP        0x2000  /* first buffer in packet */
+#define          DMA_WRAP       0x1000  /* */
+#define          DMA_APPEND_CRC 0x0100
+
+/* EMAC Descriptor Status definitions */
+#define          EMAC_MISS      0x0080  /* framed address recognition failed (promiscuous) */
+#define          EMAC_BRDCAST   0x0040  /* DA is Broadcast */
+#define          EMAC_MULT      0x0020  /* DA is multicast */
+#define          EMAC_LG        0x0010  /* frame length > RX_LENGTH register value */
+#define          EMAC_NO        0x0008  /* Non-Octet aligned */
+#define          EMAC_RXER      0x0004  /* RX_ERR on MII while RX_DV assereted */
+#define          EMAC_CRC_ERROR 0x0002  /* CRC error */
+#define          EMAC_OV        0x0001  /* Overflow */
+
+/* HDLC Descriptor Status definitions */
+#define          DMA_HDLC_TX_ABORT      0x0100
+#define          DMA_HDLC_RX_OVERRUN    0x4000
+#define          DMA_HDLC_RX_TOO_LONG   0x2000
+#define          DMA_HDLC_RX_CRC_OK     0x1000
+#define          DMA_HDLC_RX_ABORT      0x0100
+
+  uint32        address;                /* address of data */
+} DmaDesc;
+
+/*
+** Sdram Controller
+*/
+typedef struct SdramControllerRegs {
+  uint16        unused1;
+  uint16        initControl;    /* 02 */
+#define SD_POWER_DOWN           0x200   /* put sdram into power down */
+#define SD_SELF_REFRESH         0x100   /* enable self refresh mode */
+#define SD_SOFT_RESET           0x080   /* soft reset all sdram controller regs */
+#define SD_EDO_SELECT           0x040   /* select EDO mode */
+#define SD_EDO_WAIT_STATE       0x020   /* add an EDO wait state */
+#define SD_8MEG                 0x010   /* map sdram to 8 megs */
+#define SD_MASTER_ENABLE        0x008   /* enable accesses to external sdram */
+#define SD_MRS                  0x004   /* generate a mode register select cycle */
+#define SD_PRECHARGE            0x002   /* generate a precharge cycle */
+#define SD_CBR                  0x001   /* generate a refresh cycle */
+  uint8         unused2[3];
+  uint8         config;         /* 07 */
+#define SD_FAST_MEM             0x04    /* 1=CAS latency of 2, 0 = CAS latency of 3 */
+#define SD_BURST_LEN            0x03    /* set burst length */
+#define SD_BURST_FULL_PAGE      0x00    /* .. full page */
+#define SD_BURST_8              0x01    /* .. 8 words */
+#define SD_BURST_4              0x02    /* .. 4 words */
+#define SD_BURST_2              0x03    /* .. 2 words */
+  uint16        unused3;
+  uint16        refreshControl; /* 0a */
+#define SD_REFRESH_ENABLE       0x8000  /* refresh enable */
+#define SD_REFRESH_PERIOD       0x00ff  /* refresh period (16 x n x clock_period) */
+
+  uint32        memoryBase;     /* 0c */
+#define SD_MEMBASE_MASK         0xffffe000      /* base address mask */
+#define SD_MEMSIZE_8MEG         0x00000001      /* memory is 8 meg */
+#define SD_MEMSIZE_2MEG         0x00000001      /* memory is 2 meg */
+
+} SdramControllerRegs;
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[1];                  /* size chip select configuration */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+/*
+** EMAC transmit MIB counters
+*/
+typedef struct EmacTxMib {
+  uint32        tx_good_octets;         /* (200) good byte count */
+  uint32        tx_good_pkts;           /* (204) good pkt count */
+  uint32        tx_octets;              /* (208) good and bad byte count */
+  uint32        tx_pkts;                /* (20c) good and bad pkt count */
+  uint32        tx_broadcasts_pkts;     /* (210) good broadcast packets */
+  uint32        tx_multicasts_pkts;     /* (214) good mulitcast packets */
+  uint32        tx_len_64;              /* (218) RMON tx pkt size buckets */
+  uint32        tx_len_65_to_127;       /* (21c) */
+  uint32        tx_len_128_to_255;      /* (220) */
+  uint32        tx_len_256_to_511;      /* (224) */
+  uint32        tx_len_512_to_1023;     /* (228) */
+  uint32        tx_len_1024_to_max;     /* (22c) */
+  uint32        tx_jabber_pkts;         /* (230) > 1518 with bad crc */
+  uint32        tx_oversize_pkts;       /* (234) > 1518 with good crc */
+  uint32        tx_fragment_pkts;       /* (238) < 63   with bad crc */
+  uint32        tx_underruns;           /* (23c) fifo underrun */
+  uint32        tx_total_cols;          /* (240) total collisions in all tx pkts */
+  uint32        tx_single_cols;         /* (244) tx pkts with single collisions */
+  uint32        tx_multiple_cols;       /* (248) tx pkts with multiple collisions */
+  uint32        tx_excessive_cols;      /* (24c) tx pkts with excessive cols */
+  uint32        tx_late_cols;           /* (250) tx pkts with late cols */
+  uint32        tx_defered;             /* (254) tx pkts deferred */
+  uint32        tx_carrier_lost;        /* (258) tx pkts with CRS lost */
+  uint32        tx_pause_pkts;          /* (25c) tx pause pkts sent */
+#define NumEmacTxMibVars        24
+} EmacTxMib;
+
+/*
+** EMAC receive MIB counters
+*/
+typedef struct EmacRxMib {
+  uint32        rx_good_octets;         /* (280) good byte count */
+  uint32        rx_good_pkts;           /* (284) good pkt count */
+  uint32        rx_octets;              /* (288) good and bad byte count */
+  uint32        rx_pkts;                /* (28c) good and bad pkt count */
+  uint32        rx_broadcasts_pkts;     /* (290) good broadcast packets */
+  uint32        rx_multicasts_pkts;     /* (294) good mulitcast packets */
+  uint32        rx_len_64;              /* (298) RMON rx pkt size buckets */
+  uint32        rx_len_65_to_127;       /* (29c) */
+  uint32        rx_len_128_to_255;      /* (2a0) */
+  uint32        rx_len_256_to_511;      /* (2a4) */
+  uint32        rx_len_512_to_1023;     /* (2a8) */
+  uint32        rx_len_1024_to_max;     /* (2ac) */
+  uint32        rx_jabber_pkts;         /* (2b0) > 1518 with bad crc */
+  uint32        rx_oversize_pkts;       /* (2b4) > 1518 with good crc */
+  uint32        rx_fragment_pkts;       /* (2b8) < 63   with bad crc */
+  uint32        rx_missed_pkts;         /* (2bc) missed packets */
+  uint32        rx_crc_align_errs;      /* (2c0) both or either */
+  uint32        rx_undersize;           /* (2c4) < 63   with good crc */
+  uint32        rx_crc_errs;            /* (2c8) crc errors (only) */
+  uint32        rx_align_errs;          /* (2cc) alignment errors (only) */
+  uint32        rx_symbol_errs;         /* (2d0) pkts with RXERR assertions (symbol errs) */
+  uint32        rx_pause_pkts;          /* (2d4) MAC control, PAUSE */
+  uint32        rx_nonpause_pkts;       /* (2d8) MAC control, not PAUSE */
+#define NumEmacRxMibVars        23
+} EmacRxMib;
+
+typedef struct EmacRegisters {
+  uint32        rxControl;              /* (00) receive control */
+#define          EMAC_PM_REJ    0x80    /*      - reject DA match in PMx regs */
+#define          EMAC_UNIFLOW   0x40    /*      - accept cam match fc */
+#define          EMAC_FC_EN     0x20    /*      - enable flow control */
+#define          EMAC_LOOPBACK  0x10    /*      - loopback */
+#define          EMAC_PROM      0x08    /*      - promiscuous */
+#define          EMAC_RDT       0x04    /*      - ignore transmissions */
+#define          EMAC_ALL_MCAST 0x02    /*      - ignore transmissions */
+#define          EMAC_NO_BCAST  0x01    /*      - ignore transmissions */
+
+
+  uint32        rxMaxLength;            /* (04) receive max length */
+  uint32        txMaxLength;            /* (08) transmit max length */
+  uint32        unused1[1];
+  uint32        mdioFreq;               /* (10) mdio frequency */
+#define          EMAC_MII_PRE_EN 0x00000080 /* prepend preamble sequence */
+#define          EMAC_MDIO_PRE   0x00000080 /*      - enable MDIO preamble */
+#define          EMAC_MDC_FREQ   0x0000007f /*      - mdio frequency */
+
+  uint32        mdioData;               /* (14) mdio data */
+#define          MDIO_WR        0x50020000 /*   - write framing */
+#define          MDIO_RD        0x60020000 /*   - read framing */
+#define          MDIO_PMD_SHIFT  23
+#define          MDIO_REG_SHIFT  18
+
+  uint32        intMask;                /* (18) int mask */
+  uint32        intStatus;              /* (1c) int status */
+#define          EMAC_FLOW_INT  0x04    /*      - flow control event */
+#define          EMAC_MIB_INT   0x02    /*      - mib event */
+#define          EMAC_MDIO_INT  0x01    /*      - mdio event */
+
+  uint32        unused2[3];
+  uint32        config;                 /* (2c) config */
+#define          EMAC_ENABLE    0x001   /*      - enable emac */
+#define          EMAC_DISABLE   0x002   /*      - disable emac */
+#define          EMAC_SOFT_RST  0x004   /*      - soft reset */
+#define          EMAC_SOFT_RESET 0x004  /*      - emac soft reset */
+#define          EMAC_EXT_PHY   0x008   /*      - external PHY select */
+
+  uint32        txControl;              /* (30) transmit control */
+#define          EMAC_FD        0x001   /*      - full duplex */
+#define          EMAC_FLOWMODE  0x002   /*      - flow mode */
+#define          EMAC_NOBKOFF   0x004   /*      - no backoff in  */
+#define          EMAC_SMALLSLT  0x008   /*      - small slot time */
+
+  uint32        txThreshold;            /* (34) transmit threshold */
+  uint32        mibControl;             /* (38) mib control */
+#define          EMAC_NO_CLEAR  0x001   /* don't clear on read */
+
+  uint32        unused3[7];
+
+  uint32        pm0DataLo;              /* (58) perfect match 0 data lo */
+  uint32        pm0DataHi;              /* (5C) perfect match 0 data hi (15:0) */
+  uint32        pm1DataLo;              /* (60) perfect match 1 data lo */
+  uint32        pm1DataHi;              /* (64) perfect match 1 data hi (15:0) */
+  uint32        pm2DataLo;              /* (68) perfect match 2 data lo */
+  uint32        pm2DataHi;              /* (6C) perfect match 2 data hi (15:0) */
+  uint32        pm3DataLo;              /* (70) perfect match 3 data lo */
+  uint32        pm3DataHi;              /* (74) perfect match 3 data hi (15:0) */
+#define          EMAC_CAM_V   0x10000  /*      - cam index */
+#define          EMAC_CAM_VALID 0x00010000
+
+  uint32        unused4[98];            /* (78-1fc) */
+
+  EmacTxMib     tx_mib;                 /* (200) emac tx mib */
+  uint32        unused5[8];             /* (260-27c) */
+
+  EmacRxMib     rx_mib;                 /* (280) rx mib */
+
+} EmacRegisters;
+
+/* register offsets for subrouting access */
+#define EMAC_RX_CONTROL         0x00
+#define EMAC_RX_MAX_LENGTH      0x04
+#define EMAC_TX_MAC_LENGTH      0x08
+#define EMAC_MDIO_FREQ          0x10
+#define EMAC_MDIO_DATA          0x14
+#define EMAC_INT_MASK           0x18
+#define EMAC_INT_STATUS         0x1C
+#define EMAC_CAM_DATA_LO        0x20
+#define EMAC_CAM_DATA_HI        0x24
+#define EMAC_CAM_CONTROL        0x28
+#define EMAC_CONTROL            0x2C
+#define EMAC_TX_CONTROL         0x30
+#define EMAC_TX_THRESHOLD       0x34
+#define EMAC_MIB_CONTROL        0x38
+
+
+#define EMAC1 ((volatile EmacRegisters * const) EMAC1_BASE)
+
+/*
+** USB Registers
+*/
+typedef struct UsbRegisters {
+    byte inttf_setting;
+    byte current_config;
+    uint16 status_frameNum;
+#define USB_LINK        0x2000 
+#define USB_BUS_RESET   0x1000 
+#define USB_SUSPENDED   0x0800 
+    byte unused1;
+    byte endpt_prnt;
+    byte endpt_dirn;
+    byte endpt_status;
+#define USB_ENDPOINT_0  0x01
+#define USB_ENDPOINT_1  0x02
+#define USB_ENDPOINT_2  0x04
+#define USB_ENDPOINT_3  0x08
+#define USB_ENDPOINT_4  0x10
+#define USB_ENDPOINT_5  0x20
+#define USB_ENDPOINT_6  0x40
+#define USB_ENDPOINT_7  0x80
+    uint32 unused2;
+    byte conf_mem_ctl;
+#define USB_CONF_MEM_RD     0x80
+#define USB_CONF_MEM_RDY    0x40
+    byte unused2a;
+    byte conf_mem_read_address;
+    byte conf_mem_write_address;
+
+    byte unused3;
+    byte dev_req_bytesel;
+    uint16 ext_dev_data;
+
+    byte unused4;
+    byte clr_fifo;
+    byte endpt_stall_reset;  // use same endpoint #'s from above
+    byte usb_cntl;
+#define USB_FORCE_ERR       0x20
+#define USB_SOFT_RESET      0x10
+#define USB_RESUME          0x08
+#define USB_COMMAND_ERR     0x04
+#define USB_COMMAND_OVER    0x02
+    byte irq_addr;
+    byte iso_out_in_addr;
+    byte blk_out_in_addr;
+    byte cntl_addr;
+    uint32 unusedx[2];
+    uint32 tx_ram_write_port;
+    uint32 fifo_status;  // (see bcm6338 data sheet for definition)
+
+    uint32 irq_status;
+    uint32 irq_mask;
+#define USB_NEW_CONFIG              0x00000001   
+#define USB_SETUP_COMMAND_RECV      0x00000002 // non-standard setup cmd rcvd
+#define USB_OUT_FIFO_OV             0x00000004   
+#define USB_RESET_RECV              0x00000008   
+#define USB_SUSPEND_RECV            0x00000010   
+#define USB_FIFO_REWIND             0x00000020   
+#define USB_RX_BULK_FIFO_DATA_AVAIL 0x00000040   
+#define USB_RX_ISO_FIFO_DATA_AVAIL  0x00000080   
+#define USB_LINK_CHANGE             0x00010000   
+    uint32 endpt_cntl;
+#define USB_R_WK_EN                 0x0100   
+#define USB_TX_EOP                  0x0200   
+#define USB_TX_CNTL_DMA_EN          0x0400
+#define USB_TX_BULK_DMA_EN          0x0800
+#define USB_TX_ISO_DMA_EN           0x1000
+#define USB_RX_CNTL_DMA_EN          0x2000
+#define USB_RX_BULK_DMA_EN          0x4800
+#define USB_RX_ISO_DMA_EN           0x8000
+    uint32 rx_status_read_port;
+    uint32 confmem_read_port;
+    uint32 confmem_write_port;
+    uint32 fifo_ovf_count;
+    uint32 fifo_rewind_cnt;
+    uint32 terminal_count;
+} UsbRegisters;
+
+#define USB ((volatile UsbRegisters * const) USB_CTL_BASE)
+
+/*
+** ADSL core Registers
+*/
+
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+
+typedef struct AdslRegisters {
+    uint32 core_control;
+#define ADSL_RESET		0x01
+   
+    uint32 core_status;
+#define ADSL_HOST_MSG	0x01
+
+    uint32 PAD;
+    uint32 bist_status;
+    uint32 PAD[4];
+    uint32 int_status_i; /* 0x20 */
+    uint32 int_mask_i;
+    uint32 int_status_f;
+    uint32 int_mask_f;
+#define ADSL_INT_HOST_MSG		0x00000020
+#define ADSL_INT_DESC_ERR		0x00000400
+#define ADSL_INT_DATA_ERR		0x00000800
+#define ADSL_INT_DESC_PROTO_ERR	0x00001000
+#define ADSL_INT_RCV_DESC_UF	0x00002000
+#define ADSL_INT_RCV_FIFO_OF	0x00004000
+#define ADSL_INT_XMT_FIFO_UF	0x00008000
+#define ADSL_INT_RCV			0x00010000
+#define ADSL_INT_XMT			0x01000000
+
+    uint32 PAD[116];
+
+	uint32	xmtcontrol_intr; /* 0x200 */
+#define ADSL_DMA_XMT_EN			0x00000001
+#define ADSL_DMA_XMT_LE			0x00000004
+	uint32	xmtaddr_intr;
+#define ADSL_DMA_ADDR_MASK		0xFFFFF000
+	uint32	xmtptr_intr;
+#define ADSL_DMA_LAST_DESC_MASK	0x00000FFF
+	uint32	xmtstatus_intr;
+#define ADSL_DMA_CURR_DESC_MASK	0x00000FFF
+#define ADSL_DMA_XMT_STATE_MASK	0x0000F000
+#define ADSL_DMA_XMT_STATE_DIS	0x00000000
+#define ADSL_DMA_XMT_STATE_ACT	0x00001000
+#define ADSL_DMA_XMT_STATE_IDLE	0x00002000
+#define ADSL_DMA_XMT_STATE_STOP	0x00003000
+
+#define ADSL_DMA_XMT_ERR_MASK	0x000F0000
+#define ADSL_DMA_XMT_ERR_NONE	0x00000000
+#define ADSL_DMA_XMT_ERR_DPE	0x00010000
+#define ADSL_DMA_XMT_ERR_FIFO	0x00020000
+#define ADSL_DMA_XMT_ERR_DTE	0x00030000
+#define ADSL_DMA_XMT_ERR_DRE	0x00040000
+
+	uint32	rcvcontrol_intr;
+#define ADSL_DMA_RCV_EN			0x00000001
+#define ADSL_DMA_RCV_FO			0x000000FE
+	uint32	rcvaddr_intr;
+	uint32	rcvptr_intr;
+	uint32	rcvstatus_intr;
+#define ADSL_DMA_RCV_STATE_MASK	0x0000F000
+#define ADSL_DMA_RCV_STATE_DIS	0x00000000
+#define ADSL_DMA_RCV_STATE_ACT	0x00001000
+#define ADSL_DMA_RCV_STATE_IDLE	0x00002000
+#define ADSL_DMA_RCV_STATE_STOP	0x00003000
+
+#define ADSL_DMA_RCV_ERR_MASK	0x000F0000
+#define ADSL_DMA_RCV_ERR_NONE	0x00000000
+#define ADSL_DMA_RCV_ERR_DPE	0x00010000
+#define ADSL_DMA_RCV_ERR_FIFO	0x00020000
+#define ADSL_DMA_RCV_ERR_DTE	0x00030000
+#define ADSL_DMA_RCV_ERR_DRE	0x00040000
+
+	uint32	xmtcontrol_fast;
+	uint32	xmtaddr_fast;
+	uint32	xmtptr_fast;
+	uint32	xmtstatus_fast;
+	uint32	rcvcontrol_fast;
+	uint32	rcvaddr_fast;
+	uint32	rcvptr_fast;
+	uint32	rcvstatus_fast;
+	uint32	PAD[48];
+
+	uint32	host_message; /* 0x300 */
+	uint32	PAD[805];
+    uint32 core_reset;
+    uint32 core_error;
+    uint32 core_revision;
+
+#define	ADSL_CORE_REV			0x0000000F
+#define	ADSL_CORE_TYPE			0x0000FFF0
+} AdslRegisters;
+
+#define ADSL ((volatile AdslRegisters * const) ADSL_BASE)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6345_common.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6345_common.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6345_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6345_common.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,275 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE: 6345_common.h                                             */
+/*   DATE:    96/12/19                                                 */
+/*   PURPOSE: Define addresses of major hardware components of         */
+/*            BCM6345                                                  */
+/*                                                                     */
+/***********************************************************************/
+#ifndef __BCM6345_MAP_COMMON_H
+#define __BCM6345_MAP_COMMON_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+/* matches isb_decoder.v */
+#define INTC_BASE     0xfffe0000    /* interrupts controller registers */
+#define BB_BASE       0xfffe0100    /* bus bridge registers */
+#define TIMR_BASE     0xfffe0200    /* timer registers */
+#define UART_BASE     0xfffe0300    /* uart registers */
+#define GPIO_BASE     0xfffe0400    /* gpio registers */
+#define EMAC_BASE     0xfffe1800    /* EMAC control registers */
+#define EBIC_BASE     0xfffe2000    /* EBI control registers */
+#define PCMCIA_BASE   0xfffe2028    /* PCMCIA control registers */
+#define USB_BASE      0xfffe2100    /* USB controll registers */
+#define SDRAM_BASE    0xfffe2300    /* SDRAM control registers */
+#define DMA_BASE      0xfffe2800    /* DMA control registers */
+
+/* DMA channel assignments */
+#define EMAC_RX_CHAN            1
+#define EMAC_TX_CHAN            2
+#define EBI_RX_CHAN             5
+#define EBI_TX_CHAN             6
+#define RESERVED_RX_CHAN        9
+#define RESERVED_TX_CHAN        10
+#define USB_BULK_RX_CHAN        13
+#define USB_BULK_TX_CHAN        14
+#define USB_ISO_RX_CHAN         15
+#define USB_ISO_TX_CHAN         16
+#define USB_CNTL_RX_CHAN        17
+#define USB_CNTL_TX_CHAN        18
+
+/*
+#-----------------------------------------------------------------------*
+#                                                                       *
+#************************************************************************
+*/
+#define SDR_INIT_CTL        0x00
+    /* Control Bits */
+#define SDR_9BIT_COL        (1<<11)
+#define SDR_32BIT           (1<<10)
+#define SDR_PWR_DN          (1<<9)
+#define SDR_SELF_REF        (1<<8)
+#define SDR_SOFT_RST        (1<<7)
+#define SDR_64x32           (3<<4)
+#define SDR_128MEG          (2<<4)
+#define SDR_64MEG           (1<<4)
+#define SDR_16MEG           (0<<4)
+#define SDR_ENABLE          (1<<3)
+#define SDR_MRS_CMD         (1<<2)
+#define SDR_PRE_CMD         (1<<1)
+#define SDR_CBR_CMD         (1<<0)
+
+#define SDR_CFG_REG         0x04
+    /* Control Bits */
+#define SDR_FULL_PG         0x00
+#define SDR_BURST8          0x01
+#define SDR_BURST4          0x02
+#define SDR_BURST2          0x03
+#define SDR_FAST_MEM        (1<<2)
+#define SDR_SLOW_MEM        0x00
+
+#define SDR_REF_CTL         0x08
+    /* Control Bits */
+#define SDR_REF_EN          (1<<15)
+
+#define SDR_MEM_BASE        0x0c
+    /*  Control Bits */
+#define DRAM2MBSPC          0x00000000
+#define DRAM8MBSPC          0x00000001
+#define DRAM16MBSPC         0x00000002
+#define DRAM32MBSPC         0x00000003
+#define DRAM64MBSPC         0x00000004
+
+#define DRAM2MEG            0x00000000  /*  See SDRAM config */
+#define DRAM8MEG            0x00000001  /*  See SDRAM config */
+#define DRAM16MEG           0x00000002  /*  See SDRAM config */
+#define DRAM32MEG           0x00000003  /*  See SDRAM config */
+#define DRAM64MEG           0x00000004  /*  See SDRAM config */
+
+/*
+#-----------------------------------------------------------------------*
+#                                                                       *
+#************************************************************************
+*/
+#define CS0BASE         0x00
+#define CS0CNTL         0x04
+#define CS1BASE         0x08
+#define CS1CNTL         0x0c
+#define CS2BASE         0x10
+#define CS2CNTL         0x14
+#define CS3BASE         0x18
+#define CS3CNTL         0x1c
+#define CS4BASE         0x20
+#define CS4CNTL         0x24
+#define CS5BASE         0x28
+#define CS5CNTL         0x2c
+#define CS6BASE         0x30
+#define CS6CNTL         0x34
+#define CS7BASE         0x38
+#define CS7CNTL         0x3c
+#define EBICONFIG       0x40
+
+/*
+# CSxBASE settings
+#   Size in low 4 bits
+#   Base Address for match in upper 24 bits
+*/
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+
+/* CSxCNTL settings */
+#define EBI_ENABLE          0x00000001  /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e  /* .. mask for wait states */
+#define ZEROWT              0x00000000  /* ..  0 WS */
+#define ONEWT               0x00000002  /* ..  1 WS */
+#define TWOWT               0x00000004  /* ..  2 WS */
+#define THREEWT             0x00000006  /* ..  3 WS */
+#define FOURWT              0x00000008  /* ..  4 WS */
+#define FIVEWT              0x0000000a  /* ..  5 WS */
+#define SIXWT               0x0000000c  /* ..  6 WS */
+#define SEVENWT             0x0000000e  /* ..  7 WS */
+#define EBI_WORD_WIDE       0x00000010  /* .. 16-bit peripheral, else 8 */
+#define EBI_POLARITY        0x00000040  /* .. set to invert chip select polarity */
+#define EBI_TS_TA_MODE      0x00000080  /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100  /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200  /* .. enable fifo */
+#define EBI_RE              0x00000400  /* .. Reverse Endian */
+
+/* EBICONFIG settings */
+#define EBI_MASTER_ENABLE   0x80000000  /* allow external masters */
+#define EBI_EXT_MAST_PRIO   0x40000000  /* maximize ext master priority */
+#define EBI_CTRL_ENABLE     0x20000000
+#define EBI_TA_ENABLE       0x10000000
+
+#define BRGEN            0x80   /* Control register bit defs */
+#define TXEN             0x40
+#define RXEN             0x20
+#define LOOPBK           0x10
+#define TXPARITYEN       0x08
+#define TXPARITYEVEN     0x04
+#define RXPARITYEN       0x02
+#define RXPARITYEVEN     0x01
+#define XMITBREAK        0x40
+#define BITS5SYM         0x00
+#define BITS6SYM         0x10
+#define BITS7SYM         0x20
+#define BITS8SYM         0x30
+#define BAUD115200       0x0a
+#define ONESTOP          0x07
+#define TWOSTOP          0x0f
+#define TX4              0x40
+#define RX4              0x04
+#define RSTTXFIFOS       0x80
+#define RSTRXFIFOS       0x40
+#define DELTAIP          0x0001
+#define TXUNDERR         0x0002
+#define TXOVFERR         0x0004
+#define TXFIFOTHOLD      0x0008
+#define TXREADLATCH      0x0010
+#define TXFIFOEMT        0x0020
+#define RXUNDERR         0x0040
+#define RXOVFERR         0x0080
+#define RXTIMEOUT        0x0100
+#define RXFIFOFULL       0x0200
+#define RXFIFOTHOLD      0x0400
+#define RXFIFONE         0x0800
+#define RXFRAMERR        0x1000
+#define RXPARERR         0x2000
+#define RXBRK            0x4000
+          
+#define RXIRQS           0x7fc0
+#define TXIRQS           0x003e
+
+#define CPU_CLK_EN       0x0001
+#define UART_CLK_EN      0x0008
+
+#define BLKEN            06
+
+#define FMSEL_MASK      0xf0000000      // 31:28
+#define FMSEL_SHFT      28
+#define FM_HI_GEAR      0x08000000      // 27
+#define FMCLKSEL        0x04000000      // 26
+#define FMDIV_MASK      0x03000000      // 25:24
+#define FMDIV_SHFT      24
+#define FBDIV_MASK      0x00f00000      // 23:20
+#define FBDIV_SHFT      20
+#define FB_SEL          0x00010000      // 16
+#define FU2SEL_MASK     0x0000f000      // 15:12
+#define FU2SEL_SHFT     12
+#define FU1SEL_MASK     0x00000f00      // 11:8
+#define FU1SEL_SHFT     8
+#define FU1PRS_MASK     0x000000e0      // 7:5
+#define FU1PRS_SHFT     5
+#define FU1POS_MASK     0x00000018      // 4:3
+#define FU1POS_SHFT     3
+#define SOFT_RESET	0x00000001
+
+#define FMSEL            0x08
+
+#define UART0CONTROL     0x01
+#define UART0CONFIG      0x02
+#define UART0RXTIMEOUT   0x03
+#define UART0BAUD        0x04
+#define UART0FIFOCFG     0x0a
+#define UART0INTMASK     0x10
+#define UART0INTSTAT     0x12
+#define UART0DATA        0x17
+
+#define GPIOTBUSSEL      0x03
+#define GPIODIR          0x06
+#define GPIOLED          0x09
+#define GPIOIO           0x0a
+#define GPIOUARTCTL      0x0c
+
+/*Defines below show which bit enables which UART signals */
+#define RI1_EN          0x0001
+#define CTS1_EN         0x0002
+#define DCD1_EN         0x0004
+#define DSR1_EN         0x0008
+#define DTR1_EN         0x0010
+#define RTS1_EN         0x0020
+#define DO1_EN          0x0040
+#define DI1_EN          0x0080
+#define RI0_EN          0x0100
+#define CTS0_EN         0x0200
+#define DCD0_EN         0x0400
+#define DSR0_EN         0x0800
+#define DTR0_EN         0x1000
+#define RTS0_EN         0x2000
+
+#if __cplusplus
+}
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6345_map.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6345_map.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6345_map.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6345_map.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,939 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  6345_map.h                                               */
+/*   DATE:    96/12/19                                                 */
+/*   PURPOSE: Define addresses of major hardware components of         */
+/*            BCM6345                                                  */
+/*                                                                     */
+/***********************************************************************/
+#ifndef __BCM6345_MAP_H
+#define __BCM6345_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+#include "6345_common.h"
+#include "6345_intr.h"
+
+/* macro to convert logical data addresses to physical */
+/* DMA hardware must see physical address */
+#define LtoP( x )       ( (uint32)x & 0x1fffffff )
+#define PtoL( x )       ( LtoP(x) | 0xa0000000 )
+
+/*
+** Interrupt Controller
+*/
+typedef struct IntControl {
+  uint32        RevID;          /* (00) */
+  uint16        testControl;    /* (04) */
+  uint16        blkEnables;     /* (06) */
+
+#define USB_CLK_EN      0x0100
+#define EMAC_CLK_EN     0x0080
+#define ADSL_CLK_EN     0x0010
+#define UART_CLK_EN     0x0008
+#define EBI_CLK_EN      0x0004
+#define BUS_CLK_EN      0x0002
+#define CPU_CLK_EN      0x0001
+
+  uint32        pll_control;    /* (08) */
+#define FMSEL_MASK      0xf0000000      // 31:28
+#define FMSEL_SHFT      28
+#define FM_HI_GEAR      0x08000000      // 27
+#define FMCLKSEL        0x04000000      // 26
+#define FMDIV_MASK      0x03000000      // 25:24
+#define FMDIV_SHFT      24
+#define FBDIV_MASK      0x00f00000      // 23:20
+#define FBDIV_SHFT      20
+#define FB_SEL          0x00010000      // 16
+#define FU2SEL_MASK     0x0000f000      // 15:12
+#define FU2SEL_SHFT     12
+#define FU1SEL_MASK     0x00000f00      // 11:8
+#define FU1SEL_SHFT     8
+#define FU1PRS_MASK     0x000000e0      // 7:5
+#define FU1PRS_SHFT     5
+#define FU1POS_MASK     0x00000018      // 4:3
+#define FU1POS_SHFT     3
+#define SOFT_RESET	0x00000001
+
+  uint32        IrqMask;        /* (0c) */
+  uint32        IrqStatus;              /* (10) */
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  4
+#define EI_CLEAR_SHFT   8
+#define EI_MASK_SHFT    12
+#define EI_INSENS_SHFT  16
+#define EI_LEVEL_SHFT   20
+} IntControl;
+
+#define PERF ((volatile IntControl * const) INTC_BASE)
+
+/*
+** Bus Bridge Registers
+*/
+typedef struct BusBridge {
+  uint16    status;
+#define BB_BUSY     0x8000      /* posted operation in progress */
+#define BB_RD_PND   0x4000      /* read pending */
+#define BB_RD_CMPLT 0x2000      /* read complete */
+#define BB_ERROR    0x1000      /* posted write error */
+#define BB_TEA      0x0800      /* transfer aborted */
+  uint16    abortTimeoutCnt;    /* abort timeout value */
+
+  byte      writePostEnable;
+#define BB_POST_TIMR_EN 0x08        /* post writes to timer regs */
+#define BB_POST_GPIO_EN 0x04        /* post writes to gpio regs */
+#define BB_POST_INTC_EN 0x02        /* post writes to interrupt controller regs */
+#define BB_POST_UART_EN 0x01        /* post writes to uart regs */
+  byte      unused1[5];
+  uint16    postAddr;       /* posted read address (lower half) */
+  byte      unused2[3];
+  byte      postData;       /* posted read data */
+} BusBridge;
+
+/* register offsets (needed for EBI master access) */
+#define BB_STATUS       0
+#define BB_ABORT_TO_CNT     2
+#define BB_WR_POST_EN       4
+#define BB_RD_POST_ADDR     10
+#define BB_RD_POST_DATA     12
+
+#define BRIDGE *bridge ((volatile BusBridge * const) BB_BASE)
+
+/*
+** Timer
+*/
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+/*
+** UART
+*/
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+/*
+** Gpio Controller
+*/
+typedef struct GpioControl {
+  uint16        unused0;
+  byte          unused1;
+  byte          TBusSel;
+
+  /* High in bit location enables output */
+  uint16        unused2;
+  uint16        GPIODir;
+  byte          unused3;
+  byte          Leds;           //Only bits [3:0]
+  uint16        GPIOio;
+
+  /* Defines below show which bit enables which UART signals */
+  uint32        UartCtl;
+#define RI1_EN          0x0001
+#define CTS1_EN         0x0002
+#define DCD1_EN         0x0004
+#define DSR1_EN         0x0008
+#define DTR1_EN         0x0010
+#define RTS1_EN         0x0020
+#define DO1_EN          0x0040
+#define DI1_EN          0x0080
+#define RI0_EN          0x0100
+#define CTS0_EN         0x0200
+#define DCD0_EN         0x0400
+#define DSR0_EN         0x0800
+#define DTR0_EN         0x1000
+#define RTS0_EN         0x2000
+
+  /*********************************************************************
+   * Multiple Use Muxed GPIO
+   * -----------------------
+   *
+   * ------
+   * GPIO_A
+   * ------
+   *
+   * GPIO[0] -> RI1             I       Controlled by UartCtl[0] ELSE 0
+   * GPIO[0] -> DMATC_i         I       Always
+   * GPIO[0] -> DMATC_o         O       Controlled by dma_enable_n|dma_drive_n
+   * GPIO[0] -> ebi_bsize[0]    I       Always
+   *
+   * GPIO[1] -> CTS1            I       Controlled by UartCtl[1] ELSE 0
+   * GPIO[1] -> DMAACK1 (18)    O       Controlled by dma_enable_n
+   * GPIO[1] -> ebi_bg_b        O       Controlled by ebi_master_n
+   *
+   * GPIO[2] -> DCD1            I       Controlled by UartCtl[2] ELSE 0
+   * GPIO[2] -> ebi_bsize[1]    I       Always
+   *
+   * GPIO[3] -> DSR1            I       Controlled by UartCtl[3] ELSE 0
+   * GPIO[3] -> INT2            I       Always
+   * GPIO[3] -> ebi_bsize[2]    I       Always
+   *
+   * GPIO[4] -> DTR1            O       Controlled by UartCtl[4]&GpioDir[4]
+   * GPIO[4] -> INT3            I       Always
+   * GPIO[4] -> ebi_burst       I       Always
+   *
+   * GPIO[5] -> RTS1            O       Controlled by UartCtl[5]&GpioDir[5]
+   * GPIO[5] -> DMAACK0 (17)    O       Controlled by dma_enable_n
+   * GPIO[5] -> ebi_tsize       I       Always
+   *
+   * GPIO[6] -> sDout1          O       Controlled by UartCtl[6]&GpioDir[6]
+   * GPIO[6] -> DMARQ1 (18)     I       Always
+   * GPIO[6] -> ebi_bb_i        I       Always
+   * GPIO[6] -> ebi_bb_o        O       Controlled by ebi_master_n|ebi_bb_oen
+   *
+   * GPIO[7] -> sDin1           I       Controlled by UartCtl[7] ELSE 0
+   * GPIO[7] -> ebi_br_b        I       Always
+   * GPIO[7] -> DMARQ0 (17)     I       Always
+   *
+   * ------
+   * GPIO_B
+   * ------
+   *
+   * GPIO[8] -> RI0             I       Controlled by UartCtl[8] ELSE 0
+   * GPIO[8] -> ebi_cs_b[6]     O       Controlled by ebi_cs_en[6]
+   *
+   * GPIO[9] -> CTS0            I       Controlled by UartCtl[9] ELSE 0
+   *
+   * GPIO[a] -> DCD0            I       Controlled by UartCtl[a] ELSE 0
+   * GPIO[a] -> ebi_cs_b[7]     O       Controlled by ebi_cs_en[7]
+   *
+   * GPIO[b] -> DSR0            I       Controlled by UartCtl[b] ELSE 0
+   * GPIO[b] -> ebi_int_cs_b    I       Always
+   *
+   * GPIO[c] -> DTR0            O       Controlled by UartCtl[c]&GpioDir[c]
+   *
+   * GPIO[d] -> RTS0            O       Controlled by UartCtl[d]&&GpioDir[d]
+   *
+   * GPIO[e] -> INT0            I       Always
+   *
+   * GPIO[f] -> INT1            I       Always
+   *
+   * sDout0 -> (bist_en[15]) ? pll_clk48:sDout0_int
+   *
+   *********************************************************************/
+
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+/*
+** DMA Channel (1 .. 20)
+*/
+typedef struct DmaChannel {
+  uint32        cfg;                    /* (00) assorted configuration */
+#define          DMA_FLOWC_EN   0x00000010      /* flow control enable */
+#define          DMA_WRAP_EN    0x00000008      /* use DMA_WRAP bit */
+#define          DMA_CHAINING   0x00000004      /* chaining mode */
+#define          DMA_STALL      0x00000002      
+#define          DMA_ENABLE     0x00000001      /* set to enable channel */
+  uint32        maxBurst;               /* (04) max burst length permitted */
+                                        /*      non-chaining / chaining */
+  uint32        startAddr;              /* (08) source addr  / ring start address */
+  uint32        length;                 /* (0c) xfer len     / ring len */
+#define          DMA_KICKOFF    0x80000000      /* start non-chaining xfer */
+
+  uint32        bufStat;                /* (10) buffer status for non-chaining */
+  uint32        intStat;                /* (14) interrupts control and status */
+  uint32        intMask;                /* (18) interrupts mask */
+#define         DMA_BUFF_DONE   0x00000001      /* buffer done */
+#define         DMA_DONE        0x00000002      /* packet xfer complete */
+#define         DMA_NO_DESC     0x00000004      /* no valid descriptors */
+
+// DMA HW bits are clugy in this version of chip (mask/status shifted)
+#define         DMA_BUFF_DONE_MASK  0x00000004      /* buffer done */
+#define         DMA_DONE_MASK       0x00000001      /* packet xfer complete */
+#define         DMA_NO_DESC_MASK    0x00000002      /* no valid descriptors */
+
+  uint32        fcThreshold;            /* (1c) flow control threshold */
+  uint32        numAlloc;               /* */
+  uint32        unused[7];              /* (20-3c) pad to next descriptor */
+} DmaChannel;
+/* register offsets, useful for ebi master access */
+#define DMA_CFG                 0
+#define DMA_MAX_BURST           4
+#define DMA_START_ADDR          8
+#define DMA_LENGTH              12
+#define DMA_BUF_STAT            16
+#define DMA_INT_STAT            20
+#define DMA_FC_THRESHOLD        24
+#define DMA_NUM_ALLOC           28
+
+
+/* paste in your program ...
+DmaChannel *dmaChannels  = (DmaChannel *)DMA_BASE;
+DmaChannel *dma1 = dmaChannels[1];
+*/
+
+
+/*
+** DMA Buffer 
+*/
+typedef struct DmaDesc {
+  uint16        length;                 /* in bytes of data in buffer */
+  uint16        status;                 /* buffer status */
+#define          DMA_OWN        0x8000  /* cleared by DMA, set by SW */
+#define          DMA_EOP        0x0800  /* last buffer in packet */
+#define          DMA_SOP        0x0400  /* first buffer in packet */
+#define          DMA_WRAP       0x0200  /* */
+#define          DMA_APPEND_CRC 0x0100  /* .. for emac tx */
+#define          DATA_FLAG      0x0100  /* .. for secmod rx */
+#define          AUTH_FAIL_FLAG 0x0100  /* .. for secmod tx */
+
+/* EMAC Descriptor Status definitions */
+#define          EMAC_UNDERRUN  0x4000   /* Tx underrun, dg-mod ???) */
+#define          EMAC_MISS      0x0080  /* framed address recognition failed (promiscuous) */
+#define          EMAC_BRDCAST   0x0040  /* DA is Broadcast */
+#define          EMAC_MULT      0x0020  /* DA is multicast */
+#define          EMAC_LG        0x0010  /* frame length > RX_LENGTH register value */
+#define          EMAC_NO        0x0008  /* Non-Octet aligned */
+#define          EMAC_RXER      0x0004  /* RX_ERR on MII while RX_DV assereted */
+#define          EMAC_CRC_ERROR 0x0002  /* CRC error */
+#define          EMAC_OV        0x0001  /* Overflow */
+
+/* HDLC Descriptor Status definitions */
+#define          DMA_HDLC_TX_ABORT      0x0100
+#define          DMA_HDLC_RX_OVERRUN    0x4000
+#define          DMA_HDLC_RX_TOO_LONG   0x2000
+#define          DMA_HDLC_RX_CRC_OK     0x1000
+#define          DMA_HDLC_RX_ABORT      0x0100
+
+  uint32        address;                        /* address of data */
+} DmaDesc;
+
+/*
+** Sdram Controller
+*/
+typedef struct SdramControllerRegs {
+  uint16        unused1;
+  uint16        initControl;    /* 02 */
+#define SD_POWER_DOWN           0x200   /* put sdram into power down */
+#define SD_SELF_REFRESH         0x100   /* enable self refresh mode */
+#define SD_SOFT_RESET           0x080   /* soft reset all sdram controller regs */
+#define SD_EDO_SELECT           0x040   /* select EDO mode */
+#define SD_EDO_WAIT_STATE       0x020   /* add an EDO wait state */
+#define SD_8MEG                 0x010   /* map sdram to 8 megs */
+#define SD_MASTER_ENABLE        0x008   /* enable accesses to external sdram */
+#define SD_MRS                  0x004   /* generate a mode register select cycle */
+#define SD_PRECHARGE            0x002   /* generate a precharge cycle */
+#define SD_CBR                  0x001   /* generate a refresh cycle */
+  uint8         unused2[3];
+  uint8         config;         /* 07 */
+#define SD_FAST_MEM             0x04    /* 1=CAS latency of 2, 0 = CAS latency of 3 */
+#define SD_BURST_LEN            0x03    /* set burst length */
+#define SD_BURST_FULL_PAGE      0x00    /* .. full page */
+#define SD_BURST_8              0x01    /* .. 8 words */
+#define SD_BURST_4              0x02    /* .. 4 words */
+#define SD_BURST_2              0x03    /* .. 2 words */
+  uint16        unused3;
+  uint16        refreshControl; /* 0a */
+#define SD_REFRESH_ENABLE       0x8000  /* refresh enable */
+#define SD_REFRESH_PERIOD       0x00ff  /* refresh period (16 x n x clock_period) */
+
+  uint32        memoryBase;     /* 0c */
+#define SD_MEMBASE_MASK         0xffffe000      /* base address mask */
+#define SD_MEMSIZE_8MEG         0x00000001      /* memory is 8 meg */
+#define SD_MEMSIZE_2MEG         0x00000001      /* memory is 2 meg */
+
+} SdramControllerRegs;
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct EbiRegisters {
+  EbiChipSelect cs[5];                  /* size chip select configuration */
+  uint32        reserved[6];
+  uint32        ebi_config;             /* configuration */
+#define EBI_MASTER_ENABLE       0x80000000  /* allow external masters */
+#define EBI_EXT_MAST_PRIO       0x40000000  /* maximize ext master priority */
+#define EBI_CTRL_ENABLE         0x20000000
+#define EBI_TA_ENABLE           0x10000000
+  uint32        dma_control;
+#define EBI_TX_INV_IRQ_EN       0x00080000
+#define EBI_RX_INV_IRQ_EN       0x00040000
+#define EBI_TX_PKT_DN_IRQ_EN    0x00020000
+#define EBI_RX_PKT_DN_IRQ_EN    0x00010000
+#define EBI_TX_INV_CLR          0x00001000
+#define EBI_RX_INV_CLR          0x00000800
+#define EBI_CHAINING            0x00000400
+#define EBI_EXT_MODE            0x00000200
+#define EBI_HALF_WORD           0x00000100
+#define EBI_TX_PKT_DN_CLR       0x00000080
+#define EBI_RX_PKT_DN_CLR       0x00000040
+#define EBI_TX_BUF_DN_CLR       0x00000020
+#define EBI_RX_BUF_DN_CLR       0x00000010
+#define EBI_TX_BUF_DN_IRQ_EN    0x00000008
+#define EBI_RX_BUF_DN_IRQ_EN    0x00000004
+#define EBI_TX_EN               0x00000002
+#define EBI_RX_EN               0x00000001
+  uint32        dma_rx_start_addr;
+  uint32        dma_rx_buf_size;
+  uint32        dma_tx_start_addr;
+  uint32        dma_tx_buf_size;
+  uint32        dma_status;
+#define EBI_TX_INV_DESC         0x00000020
+#define EBI_RX_INV_DESC         0x00000010
+#define EBI_TX_PKT_DN           0x00000008
+#define EBI_RX_PKT_DN           0x00000004
+#define EBI_TX_BUF_DN           0x00000002
+#define EBI_RX_BUF_DN           0x00000001
+} EbiRegisters;
+
+#define EBIC ((volatile EbiRegisters * const) EBIC_BASE)
+
+typedef struct PcmciaRegisters {
+  /*Each of base has 24 bits of base address followed by size select field*/
+  uint32 mem_base;
+  uint32 mem_cntrl; 
+  uint32 attr_base;
+  uint32 attr_cntrl;
+  uint32 io_base;
+  uint32 io_cntrl;
+#define PCMCIA_CS_ENABLE 0x00000001
+#define PCMCIA_CS_FIFO_ENABLE 0x00000200
+#define PCMCIA_DSTSIZE_16 0x00000010 // 0 -8bit, 1- 16bit
+#define PCMCIA_RENDIAN  0x00000400 
+  /* Skip ECR and EBI-DMA registers */
+  uint32 other1[7];
+
+  byte mem_waitcnt4; // Only bits [5:0]
+  byte mem_waitcnt3; // Only bits [4:0]
+  byte mem_waitcnt2; // Only bits [4:0]
+  byte mem_waitcnt1; // Only bits [4:0]
+
+  byte attr_waitcnt4; // Only bits [5:0]
+  byte attr_waitcnt3; // Only bits [4:0]
+  byte attr_waitcnt2; // Only bits [4:0]
+  byte attr_waitcnt1; // Only bits [4:0]
+
+  byte io_waitcnt4; // Only bits [5:0]
+  byte io_waitcnt3; // Only bits [4:0]
+  byte io_waitcnt2; // Only bits [4:0]
+  byte io_waitcnt1; // Only bits [4:0]
+
+} PcmciaRegisters;
+
+#define PCMCIA ((volatile PcmciaRegisters * const) PCMCIA_BASE)
+
+/*
+** EMAC transmit MIB counters
+*/
+typedef struct EmacTxMib {
+  uint32        tx_good_octets;         /* (200) good byte count */
+  uint32        tx_good_pkts;           /* (204) good pkt count */
+  uint32        tx_octets;              /* (208) good and bad byte count */
+  uint32        tx_pkts;                /* (20c) good and bad pkt count */
+  uint32        tx_broadcasts_pkts;     /* (210) good broadcast packets */
+  uint32        tx_multicasts_pkts;     /* (214) good mulitcast packets */
+  uint32        tx_len_64;              /* (218) RMON tx pkt size buckets */
+  uint32        tx_len_65_to_127;       /* (21c) */
+  uint32        tx_len_128_to_255;      /* (220) */
+  uint32        tx_len_256_to_511;      /* (224) */
+  uint32        tx_len_512_to_1023;     /* (228) */
+  uint32        tx_len_1024_to_max;     /* (22c) */
+  uint32        tx_jabber_pkts;         /* (230) > 1518 with bad crc */
+  uint32        tx_oversize_pkts;       /* (234) > 1518 with good crc */
+  uint32        tx_fragment_pkts;       /* (238) < 63   with bad crc */
+  uint32        tx_underruns;           /* (23c) fifo underrun */
+  uint32        tx_total_cols;          /* (240) total collisions in all tx pkts */
+  uint32        tx_single_cols;         /* (244) tx pkts with single collisions */
+  uint32        tx_multiple_cols;       /* (248) tx pkts with multiple collisions */
+  uint32        tx_excessive_cols;      /* (24c) tx pkts with excessive cols */
+  uint32        tx_late_cols;           /* (250) tx pkts with late cols */
+  uint32        tx_defered;             /* (254) tx pkts deferred */
+  uint32        tx_carrier_lost;        /* (258) tx pkts with CRS lost */
+  uint32        tx_pause_pkts;          /* (25c) tx pause pkts sent */
+#define NumEmacTxMibVars        24
+} EmacTxMib;
+
+/*
+** EMAC receive MIB counters
+*/
+typedef struct EmacRxMib {
+  uint32        rx_good_octets;         /* (280) good byte count */
+  uint32        rx_good_pkts;           /* (284) good pkt count */
+  uint32        rx_octets;              /* (288) good and bad byte count */
+  uint32        rx_pkts;                /* (28c) good and bad pkt count */
+  uint32        rx_broadcasts_pkts;     /* (290) good broadcast packets */
+  uint32        rx_multicasts_pkts;     /* (294) good mulitcast packets */
+  uint32        rx_len_64;              /* (298) RMON rx pkt size buckets */
+  uint32        rx_len_65_to_127;       /* (29c) */
+  uint32        rx_len_128_to_255;      /* (2a0) */
+  uint32        rx_len_256_to_511;      /* (2a4) */
+  uint32        rx_len_512_to_1023;     /* (2a8) */
+  uint32        rx_len_1024_to_max;     /* (2ac) */
+  uint32        rx_jabber_pkts;         /* (2b0) > 1518 with bad crc */
+  uint32        rx_oversize_pkts;       /* (2b4) > 1518 with good crc */
+  uint32        rx_fragment_pkts;       /* (2b8) < 63   with bad crc */
+  uint32        rx_missed_pkts;         /* (2bc) missed packets */
+  uint32        rx_crc_align_errs;      /* (2c0) both or either */
+  uint32        rx_undersize;           /* (2c4) < 63   with good crc */
+  uint32        rx_crc_errs;            /* (2c8) crc errors (only) */
+  uint32        rx_align_errs;          /* (2cc) alignment errors (only) */
+  uint32        rx_symbol_errs;         /* (2d0) pkts with RXERR assertions (symbol errs) */
+  uint32        rx_pause_pkts;          /* (2d4) MAC control, PAUSE */
+  uint32        rx_nonpause_pkts;       /* (2d8) MAC control, not PAUSE */
+#define NumEmacRxMibVars        23
+} EmacRxMib;
+
+typedef struct EmacRegisters {
+  uint32        rxControl;              /* (00) receive control */
+#define          EMAC_PM_REJ    0x80    /*      - reject DA match in PMx regs */
+#define          EMAC_UNIFLOW   0x40    /*      - accept cam match fc */
+#define          EMAC_FC_EN     0x20    /*      - enable flow control */
+#define          EMAC_LOOPBACK  0x10    /*      - loopback */
+#define          EMAC_PROM      0x08    /*      - promiscuous */
+#define          EMAC_RDT       0x04    /*      - ignore transmissions */
+#define          EMAC_ALL_MCAST 0x02    /*      - ignore transmissions */
+#define          EMAC_NO_BCAST  0x01    /*      - ignore transmissions */
+
+
+  uint32        rxMaxLength;            /* (04) receive max length */
+  uint32        txMaxLength;            /* (08) transmit max length */
+  uint32        unused1[1];
+  uint32        mdioFreq;               /* (10) mdio frequency */
+#define          EMAC_MII_PRE_EN 0x0100 /* prepend preamble sequence */
+#define          EMAC_MDIO_PRE   0x100  /*      - enable MDIO preamble */
+#define          EMAC_MDC_FREQ   0x0ff  /*      - mdio frequency */
+
+  uint32        mdioData;               /* (14) mdio data */
+#define          MDIO_WR        0x50020000 /*   - write framing */
+#define          MDIO_RD        0x60020000 /*   - read framing */
+#define          MDIO_PMD_SHIFT  23
+#define          MDIO_REG_SHIFT  18
+
+  uint32        intMask;                /* (18) int mask */
+  uint32        intStatus;              /* (1c) int status */
+#define          EMAC_FLOW_INT  0x04    /*      - flow control event */
+#define          EMAC_MIB_INT   0x02    /*      - mib event */
+#define          EMAC_MDIO_INT  0x01    /*      - mdio event */
+
+  uint32        unused2[3];
+  uint32        config;                 /* (2c) config */
+#define          EMAC_ENABLE    0x001   /*      - enable emac */
+#define          EMAC_DISABLE   0x002   /*      - disable emac */
+#define          EMAC_SOFT_RST  0x004   /*      - soft reset */
+#define          EMAC_SOFT_RESET 0x004  /*      - emac soft reset */
+#define          EMAC_EXT_PHY   0x008   /*      - external PHY select */
+
+  uint32        txControl;              /* (30) transmit control */
+#define          EMAC_FD        0x001   /*      - full duplex */
+#define          EMAC_FLOWMODE  0x002   /*      - flow mode */
+#define          EMAC_NOBKOFF   0x004   /*      - no backoff in  */
+#define          EMAC_SMALLSLT  0x008   /*      - small slot time */
+
+  uint32        txThreshold;            /* (34) transmit threshold */
+  uint32        mibControl;             /* (38) mib control */
+#define          EMAC_NO_CLEAR  0x001   /* don't clear on read */
+
+  uint32        unused3[7];
+
+  uint32        pm0DataLo;              /* (58) perfect match 0 data lo */
+  uint32        pm0DataHi;              /* (5C) perfect match 0 data hi (15:0) */
+  uint32        pm1DataLo;              /* (60) perfect match 1 data lo */
+  uint32        pm1DataHi;              /* (64) perfect match 1 data hi (15:0) */
+  uint32        pm2DataLo;              /* (68) perfect match 2 data lo */
+  uint32        pm2DataHi;              /* (6C) perfect match 2 data hi (15:0) */
+  uint32        pm3DataLo;              /* (70) perfect match 3 data lo */
+  uint32        pm3DataHi;              /* (74) perfect match 3 data hi (15:0) */
+#define          EMAC_CAM_V   0x10000  /*      - cam index */
+#define          EMAC_CAM_VALID 0x00010000
+
+  uint32        unused4[98];            /* (78-1fc) */
+
+  EmacTxMib     tx_mib;                 /* (200) emac tx mib */
+  uint32        unused5[8];             /* (260-27c) */
+
+  EmacRxMib     rx_mib;                 /* (280) rx mib */
+
+} EmacRegisters;
+
+/* register offsets for subrouting access */
+#define EMAC_RX_CONTROL         0x00
+#define EMAC_RX_MAX_LENGTH      0x04
+#define EMAC_TX_MAC_LENGTH      0x08
+#define EMAC_MDIO_FREQ          0x10
+#define EMAC_MDIO_DATA          0x14
+#define EMAC_INT_MASK           0x18
+#define EMAC_INT_STATUS         0x1C
+#define EMAC_CAM_DATA_LO        0x20
+#define EMAC_CAM_DATA_HI        0x24
+#define EMAC_CAM_CONTROL        0x28
+#define EMAC_CONTROL            0x2C
+#define EMAC_TX_CONTROL         0x30
+#define EMAC_TX_THRESHOLD       0x34
+#define EMAC_MIB_CONTROL        0x38
+
+
+#define EMAC ((volatile EmacRegisters * const) EMAC_BASE)
+
+/*
+** USB Registers
+*/
+typedef struct UsbRegisters {
+    byte inttf_setting;
+    byte current_config;
+    uint16 status_frameNum;
+#define USB_BUS_RESET   0x1000 
+#define USB_SUSPENDED   0x0800 
+    byte unused1;
+    byte endpt_prnt;
+    byte endpt_dirn;
+    byte endpt_status;
+#define USB_ENDPOINT_0  0x01
+#define USB_ENDPOINT_1  0x02
+#define USB_ENDPOINT_2  0x04
+#define USB_ENDPOINT_3  0x08
+#define USB_ENDPOINT_4  0x10
+#define USB_ENDPOINT_5  0x20
+#define USB_ENDPOINT_6  0x40
+#define USB_ENDPOINT_7  0x80
+    uint32 unused2;
+    byte conf_mem_ctl;
+#define USB_CONF_MEM_RD     0x80
+#define USB_CONF_MEM_RDY    0x40
+    byte unused2a;
+    byte conf_mem_read_address;
+    byte conf_mem_write_address;
+
+    byte unused3;
+    byte dev_req_bytesel;
+    uint16 ext_dev_data;
+
+    byte unused4;
+    byte clr_fifo;
+    byte endpt_stall_reset;  // use same endpoint #'s from above
+    byte usb_cntl;
+#define USB_FORCE_ERR       0x20
+#define USB_SOFT_RESET      0x10
+#define USB_RESUME          0x08
+#define USB_COMMAND_ERR     0x04
+#define USB_COMMAND_OVER    0x02
+    byte irq_addr;
+    byte iso_out_in_addr;
+    byte blk_out_in_addr;
+    byte cntl_addr;
+    uint32 mux_cntl;
+#define USB_TX_DMA_OPER          0x00000000   
+#define USB_TX_CNTL_FIFO_OPER    0x00000004   
+#define USB_TX_BULK_FIFO_OPER    0x00000008   
+#define USB_TX_ISO_FIFO_OPER     0x0000000c   
+#define USB_TX_IRQ_OPER          0x00000010   
+#define USB_RX_DMA_OPER          0x00000000   
+#define USB_RX_CNTL_FIFO_OPER    0x00000001   
+#define USB_RX_BULK_FIFO_OPER    0x00000002   
+#define USB_RX_ISO_FIFO_OPER     0x00000003   
+    uint32 rx_ram_read_port;
+    uint32 tx_ram_write_port;
+    uint32 fifo_status;
+#define USB_CTRLI_FIFO_FULL         0x00000001
+#define USB_CTRLI_FIFO_EMPTY        0x00000002
+#define USB_CTRLO_FIFO_FULL         0x00000100
+#define USB_CTRLO_FIFO_EMPTY        0x00000200
+    uint32 irq_status;
+    uint32 irq_mask;
+#define USB_NEW_CONFIG              0x01   
+#define USB_SETUP_COMMAND_RECV      0x02    // non-standard setup command received
+#define USB_OUT_FIFO_OV             0x04   
+#define USB_RESET_RECV              0x08   
+#define USB_SUSPEND_RECV            0x10   
+#define USB_FIFO_REWIND             0x20   
+#define USB_RX_BULK_FIFO_DATA_AVAIL 0x40   
+#define USB_RX_ISO_FIFO_DATA_AVAIL  0x80   
+    uint32 endpt_cntl;
+#define USB_R_WK_EN                 0x0100   
+#define USB_TX_EOP                  0x0200   
+#define USB_TX_CNTL_DMA_EN          0x0400
+#define USB_TX_BULK_DMA_EN          0x0800
+#define USB_TX_ISO_DMA_EN           0x1000
+#define USB_RX_CNTL_DMA_EN          0x2000
+#define USB_RX_BULK_DMA_EN          0x4800
+#define USB_RX_ISO_DMA_EN           0x8000
+    uint32 rx_status_read_port;
+    uint32 confmem_read_port;
+    uint32 confmem_write_port;
+    uint32 fifo_ovf_count;
+    uint32 fifo_rewind_cnt;
+} UsbRegisters;
+
+#define USB ((volatile UsbRegisters * const) USB_BASE)
+
+/*
+** ADSL core Registers
+*/
+
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+
+typedef struct AdslRegisters {
+    uint32 core_control;
+#define ADSL_RESET		0x01
+   
+    uint32 core_status;
+#define ADSL_HOST_MSG	0x01
+
+    uint32 PAD;
+    uint32 bist_status;
+    uint32 PAD[4];
+    uint32 int_status_i; /* 0x20 */
+    uint32 int_mask_i;
+    uint32 int_status_f;
+    uint32 int_mask_f;
+#define ADSL_INT_HOST_MSG		0x00000020
+#define ADSL_INT_DESC_ERR		0x00000400
+#define ADSL_INT_DATA_ERR		0x00000800
+#define ADSL_INT_DESC_PROTO_ERR	0x00001000
+#define ADSL_INT_RCV_DESC_UF	0x00002000
+#define ADSL_INT_RCV_FIFO_OF	0x00004000
+#define ADSL_INT_XMT_FIFO_UF	0x00008000
+#define ADSL_INT_RCV			0x00010000
+#define ADSL_INT_XMT			0x01000000
+
+    uint32 PAD[116];
+
+	uint32	xmtcontrol_intr; /* 0x200 */
+#define ADSL_DMA_XMT_EN			0x00000001
+#define ADSL_DMA_XMT_LE			0x00000004
+	uint32	xmtaddr_intr;
+#define ADSL_DMA_ADDR_MASK		0xFFFFF000
+	uint32	xmtptr_intr;
+#define ADSL_DMA_LAST_DESC_MASK	0x00000FFF
+	uint32	xmtstatus_intr;
+#define ADSL_DMA_CURR_DESC_MASK	0x00000FFF
+#define ADSL_DMA_XMT_STATE_MASK	0x0000F000
+#define ADSL_DMA_XMT_STATE_DIS	0x00000000
+#define ADSL_DMA_XMT_STATE_ACT	0x00001000
+#define ADSL_DMA_XMT_STATE_IDLE	0x00002000
+#define ADSL_DMA_XMT_STATE_STOP	0x00003000
+
+#define ADSL_DMA_XMT_ERR_MASK	0x000F0000
+#define ADSL_DMA_XMT_ERR_NONE	0x00000000
+#define ADSL_DMA_XMT_ERR_DPE	0x00010000
+#define ADSL_DMA_XMT_ERR_FIFO	0x00020000
+#define ADSL_DMA_XMT_ERR_DTE	0x00030000
+#define ADSL_DMA_XMT_ERR_DRE	0x00040000
+
+	uint32	rcvcontrol_intr;
+#define ADSL_DMA_RCV_EN			0x00000001
+#define ADSL_DMA_RCV_FO			0x000000FE
+	uint32	rcvaddr_intr;
+	uint32	rcvptr_intr;
+	uint32	rcvstatus_intr;
+#define ADSL_DMA_RCV_STATE_MASK	0x0000F000
+#define ADSL_DMA_RCV_STATE_DIS	0x00000000
+#define ADSL_DMA_RCV_STATE_ACT	0x00001000
+#define ADSL_DMA_RCV_STATE_IDLE	0x00002000
+#define ADSL_DMA_RCV_STATE_STOP	0x00003000
+
+#define ADSL_DMA_RCV_ERR_MASK	0x000F0000
+#define ADSL_DMA_RCV_ERR_NONE	0x00000000
+#define ADSL_DMA_RCV_ERR_DPE	0x00010000
+#define ADSL_DMA_RCV_ERR_FIFO	0x00020000
+#define ADSL_DMA_RCV_ERR_DTE	0x00030000
+#define ADSL_DMA_RCV_ERR_DRE	0x00040000
+
+	uint32	xmtcontrol_fast;
+	uint32	xmtaddr_fast;
+	uint32	xmtptr_fast;
+	uint32	xmtstatus_fast;
+	uint32	rcvcontrol_fast;
+	uint32	rcvaddr_fast;
+	uint32	rcvptr_fast;
+	uint32	rcvstatus_fast;
+	uint32	PAD[48];
+
+	uint32	host_message; /* 0x300 */
+	uint32	PAD[805];
+    uint32 core_reset;
+    uint32 core_error;
+    uint32 core_revision;
+
+#define	ADSL_CORE_REV			0x0000000F
+#define	ADSL_CORE_TYPE			0x0000FFF0
+} AdslRegisters;
+
+#define ADSL ((volatile AdslRegisters * const) ADSL_BASE)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6348_common.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6348_common.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6348_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6348_common.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,225 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE: 6348_common.h                                             */
+/*   DATE:    04/12/19                                                 */
+/*   PURPOSE: Define addresses of major hardware components of         */
+/*            BCM6348                                                  */
+/*                                                                     */
+/***********************************************************************/
+#ifndef __BCM6348_MAP_COMMON_H
+#define __BCM6348_MAP_COMMON_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#define PERF_BASE     0xfffe0000    /* chip control registers */
+#define BB_BASE       0xfffe0100    /* bus bridge registers */
+#define TIMR_BASE     0xfffe0200    /* timer registers */
+#define UART_BASE     0xfffe0300    /* uart registers */
+#define GPIO_BASE     0xfffe0400    /* gpio registers */
+#define SPI_BASE      0xfffe0c00    /* SPI master controller registers */
+
+#define USB_CTL_BASE  0xfffe1000    /* USB control registers */
+#define USB_DMA_BASE  0xfffe1400    /* USB DMA control registers */
+#define USB_HOST_BASE 0xfffe1b00    /* USB host registers */
+
+#define MPI_BASE      0xfffe2000    /* MPI control registers */
+#define SDRAM_BASE    0xfffe2300    /* SDRAM control registers */
+
+#define ADSL_BASE     0xfffe3000	/* ADSL core control registers */
+#define ATM_BASE      0xfffe4000	/* ATM SAR control registers */
+#define UBUS_BASE     0xfffe5000	/* UBUS status registers */
+#define EMAC1_BASE    0xfffe6000    /* EMAC1 control registers */
+#define EMAC2_BASE    0xfffe6800    /* EMAC2 control registers */
+#define EMAC_DMA_BASE 0xfffe7000    /* EMAC DMA control registers */
+
+/*
+#####################################################################
+# System PLL Control Register
+#####################################################################
+*/
+#define SYSPLLCFG       0x08
+
+#define M_MPI_MASK      0x00000018      // 4:3
+#define M_MPI_SHFT      3
+#define M_MPI_50MHZ     0
+#define M_MPI_40MHZ     1
+#define M_MPI_33MHZ     2
+#define M_MPI_25MHZ     3
+
+#define M_UTO_MASK      0x00000002      // 1:1
+#define M_UTO_SHFT      1
+
+#define SOFT_RESET	0x00000001
+
+#define PLL_STRAP_VALUE  0x34
+
+/*
+#####################################################################
+# SDRAM Control Registers
+#####################################################################
+*/
+#define SDR_INIT_CTL        0x00
+    /* Control Bits */
+#define SDR_PFEN1           (1<<16)
+#define SDR_PFEN0           (1<<15)
+#define SDR_EMPRS           (1<<14)
+#define SDR_2_BANKS         (1<<13)
+#define SDR_1_BANK          (0<<13)
+#define SDR_CS1_EN          (1<<12)
+#define SDR_PEND            (1<<11)
+#define SDR_32_BIT          (1<<10)
+#define SDR_POWER_DOWN      (1<<9)
+#define SDR_SELF_REFRESH    (1<<8)
+#define SDR_11_COLS         (3<<6)
+#define SDR_10_COLS         (2<<6)
+#define SDR_9_COLS          (1<<6)
+#define SDR_8_COLS          (0<<6)
+#define SDR_13_ROWS         (2<<4)
+#define SDR_12_ROWS         (1<<4)
+#define SDR_11_ROWS         (0<<4)
+#define SDR_MASTER_EN       (1<<3)
+#define SDR_MRS_CMD         (1<<2)
+#define SDR_PRE_CMD         (1<<1)
+#define SDR_CBR_CMD         (1<<0)
+
+#define SDR_CFG_REG         0x04
+    /* Control Bits */
+#define SDR_FULL_PG         0
+#define SDR_BURST8          1
+#define SDR_BURST4          2
+#define SDR_BURST2          3
+#define SDR_FAST_MEM        (1<<2)
+#define SDR_SLOW_MEM        (0<<2)
+
+#define SDR_REF_CTL         0x0C
+    /* Control Bits */
+#define SDR_REF_EN          (1<<15)
+
+#define SDR_PRIOR
+    /* Control Bits */
+#define SDR_EN_PRIOR        (1<<31)
+
+
+/*
+#####################################################################
+# MPI Control Registers
+#####################################################################
+*/
+#define CS0BASE         0x00
+#define CS0CNTL         0x04
+
+/*
+# CSxBASE settings
+#   Size in low 4 bits
+#   Base Address for match in upper 24 bits
+*/
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+
+/* CSxCNTL settings */
+#define EBI_ENABLE          0x00000001  /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e  /* .. mask for wait states */
+#define ZEROWT              0x00000000  /* ..  0 WS */
+#define ONEWT               0x00000002  /* ..  1 WS */
+#define TWOWT               0x00000004  /* ..  2 WS */
+#define THREEWT             0x00000006  /* ..  3 WS */
+#define FOURWT              0x00000008  /* ..  4 WS */
+#define FIVEWT              0x0000000a  /* ..  5 WS */
+#define SIXWT               0x0000000c  /* ..  6 WS */
+#define SEVENWT             0x0000000e  /* ..  7 WS */
+#define EBI_WORD_WIDE       0x00000010  /* .. 16-bit peripheral, else 8 */
+#define EBI_POLARITY        0x00000040  /* .. set to invert chip select polarity */
+#define EBI_TS_TA_MODE      0x00000080  /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100  /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200  /* .. enable fifo */
+#define EBI_RE              0x00000400  /* .. Reverse Endian */
+
+/*
+#####################################################################
+# UART Control Registers
+#####################################################################
+*/
+#define UART0CONTROL     0x01
+#define UART0CONFIG      0x02
+#define UART0RXTIMEOUT   0x03
+#define UART0BAUD        0x04
+#define UART0FIFOCFG     0x0a
+#define UART0INTMASK     0x10
+#define UART0INTSTAT     0x12
+#define UART0DATA        0x17
+
+#define BRGEN            0x80   /* Control register bit defs */
+#define TXEN             0x40
+#define RXEN             0x20
+#define LOOPBK           0x10
+#define TXPARITYEN       0x08
+#define TXPARITYEVEN     0x04
+#define RXPARITYEN       0x02
+#define RXPARITYEVEN     0x01
+
+#define XMITBREAK        0x40   /* Config register */
+#define BITS5SYM         0x00
+#define BITS6SYM         0x10
+#define BITS7SYM         0x20
+#define BITS8SYM         0x30
+#define ONESTOP          0x07
+#define TWOSTOP          0x0f
+
+#define RSTTXFIFOS       0x80   /* Rx Timeout register */
+#define RSTRXFIFOS       0x40
+
+#define TX4              0x40   /* FIFO config register */
+#define RX4              0x04
+
+#define DELTAIP          0x0001 /* Interrupt Status and Mask registers */
+#define TXUNDERR         0x0002
+#define TXOVFERR         0x0004
+#define TXFIFOTHOLD      0x0008
+#define TXREADLATCH      0x0010
+#define TXFIFOEMT        0x0020
+#define RXUNDERR         0x0040
+#define RXOVFERR         0x0080
+#define RXTIMEOUT        0x0100
+#define RXFIFOFULL       0x0200
+#define RXFIFOTHOLD      0x0400
+#define RXFIFONE         0x0800
+#define RXFRAMERR        0x1000
+#define RXPARERR         0x2000
+#define RXBRK            0x4000
+          
+#if __cplusplus
+}
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6348_map.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6348_map.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/6348_map.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/6348_map.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,1095 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  6348_map.h                                               */
+/*   DATE:    11/06/03                                                 */
+/*   PURPOSE: Define addresses of major hardware components of         */
+/*            BCM6348                                                  */
+/*                                                                     */
+/***********************************************************************/
+#ifndef __BCM6348_MAP_H
+#define __BCM6348_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+#include "6348_common.h"
+#include "6348_intr.h"
+
+/* macro to convert logical data addresses to physical */
+/* DMA hardware must see physical address */
+#define LtoP( x )       ( (uint32)x & 0x1fffffff )
+#define PtoL( x )       ( LtoP(x) | 0xa0000000 )
+
+/*
+** Interrupt Controller
+*/
+typedef struct PerfControl {
+  uint32        RevID;          /* (00) */
+  uint16        testControl;    /* (04) */
+  uint16        blkEnables;     /* (06) */
+
+#define ADSL_CLK_EN     0x0001
+#define MPI_CLK_EN      0x0002
+#define DRAM_CLK_EN     0x0004
+#define M2M_CLK_EN      0x0008
+#define EMAC_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+#define USBS_CLK_EN     0x0040
+#define USBH_CLK_EN     0x0100
+#define SPI_CLK_EN      0x0200
+
+  uint32        pll_control;    /* (08) */
+#define CHIP_SOFT_RESET 0x00000001
+#define MPI_CLK_50MHZ   0x00000000
+#define MPI_CLK_40MHZ   0x00000008
+#define MPI_CLK_33MHZ   0x00000010
+#define MPI_CLK_25MHZ   0x00000018
+#define MPI_CLK_MASK    0x00000018
+
+  uint32        IrqMask;        /* (0c) */
+  uint32        IrqStatus;      /* (10) */
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+  uint32        unused2[2];     /* (2c) */
+  uint32        PllStrap;       /* (34) */
+#define PLL_N1_SHFT         20
+#define PLL_N1_MASK         (7<<PLL_N1_SHFT)
+#define PLL_N2_SHFT         15
+#define PLL_N2_MASK         (0x1f<<PLL_N2_SHFT)
+#define PLL_M1_REF_SHFT     12
+#define PLL_M1_REF_MASK     (7<<PLL_M1_REF_SHFT)
+#define PLL_M2_REF_SHFT     9
+#define PLL_M2_REF_MASK     (7<<PLL_M2_REF_SHFT)
+#define PLL_M1_CPU_SHFT     6
+#define PLL_M1_CPU_MASK     (7<<PLL_M1_CPU_SHFT)
+#define PLL_M1_BUS_SHFT     3
+#define PLL_M1_BUS_MASK     (7<<PLL_M1_BUS_SHFT)
+#define PLL_M2_BUS_SHFT     0
+#define PLL_M2_BUS_MASK     (7<<PLL_M2_BUS_SHFT)
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+/*
+** Bus Bridge Registers
+*/
+typedef struct BusBridge {
+  uint16    status;
+#define BB_BUSY     0x8000      /* posted operation in progress */
+#define BB_RD_PND   0x4000      /* read pending */
+#define BB_RD_CMPLT 0x2000      /* read complete */
+#define BB_ERROR    0x1000      /* posted write error */
+#define BB_TEA      0x0800      /* transfer aborted */
+  uint16    abortTimeoutCnt;    /* abort timeout value */
+
+  byte      writePostEnable;
+#define BB_POST_TIMR_EN 0x08        /* post writes to timer regs */
+#define BB_POST_GPIO_EN 0x04        /* post writes to gpio regs */
+#define BB_POST_INTC_EN 0x02        /* post writes to interrupt controller regs */
+#define BB_POST_UART_EN 0x01        /* post writes to uart regs */
+  byte      unused1[5];
+  uint16    postAddr;       /* posted read address (lower half) */
+  byte      unused2[3];
+  byte      postData;       /* posted read data */
+} BusBridge;
+
+/* register offsets (needed for EBI master access) */
+#define BB_STATUS       0
+#define BB_ABORT_TO_CNT     2
+#define BB_WR_POST_EN       4
+#define BB_RD_POST_ADDR     10
+#define BB_RD_POST_DATA     12
+
+#define BRIDGE *bridge ((volatile BusBridge * const) BB_BASE)
+
+/*
+** Timer
+*/
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+/*
+** UART
+*/
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+/*
+** Gpio Controller
+*/
+
+typedef struct GpioControl {
+  uint32        GPIODir_high; /* bits 36:32 */
+  uint32        GPIODir;      /* bits 31:00 */
+  uint32        GPIOio_high;  /* bits 36:32 */
+  uint32        GPIOio;       /* bits 31:00 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        GPIOMode;
+#define         GROUP4_DIAG             0x00090000
+#define         GROUP4_UTOPIA           0x00080000
+#define         GROUP4_LEGACY_LED       0x00030000
+#define         GROUP4_MII_SNOOP        0x00020000
+#define         GROUP4_EXT_EPHY         0x00010000
+#define         GROUP3_DIAG             0x00009000
+#define         GROUP3_UTOPIA           0x00008000
+#define         GROUP3_EXT_MII          0x00007000
+#define         GROUP2_DIAG             0x00000900
+#define         GROUP2_PCI              0x00000500
+#define         GROUP1_DIAG             0x00000090
+#define         GROUP1_UTOPIA           0x00000080
+#define         GROUP1_SPI_UART         0x00000060
+#define         GROUP1_SPI_MASTER       0x00000060
+#define         GROUP1_MII_PCCARD       0x00000040
+#define         GROUP1_MII_SNOOP        0x00000020
+#define         GROUP1_EXT_EPHY         0x00000010
+#define         GROUP0_DIAG             0x00000009
+#define         GROUP0_EXT_MII          0x00000007
+
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_TOTAL_BITS_MASK        0x3f
+#define GPIO_NUM_MAX_BITS_MASK          0x1f
+#define GPIO_NUM_TO_MASK(X)             ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) < 32) ? (1 << ((X) & GPIO_NUM_MAX_BITS_MASK)) : (0) )
+
+/* Number to mask conversion macro used for GPIODir_high and GPIOio_high */
+#define GPIO_NUM_MAX_BITS_MASK_HIGH     0x07
+#define GPIO_NUM_TO_MASK_HIGH(X)        ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) >= 32) ? (1 << ((X-32) & GPIO_NUM_MAX_BITS_MASK_HIGH)) : (0) )
+
+
+/*
+** Spi Controller
+*/
+
+typedef struct SpiControl {
+  uint16        spiCmd;                 /* (0x0): SPI command */
+#define SPI_CMD_NOOP                    0
+#define SPI_CMD_SOFT_RESET              1
+#define SPI_CMD_HARD_RESET              2
+#define SPI_CMD_START_IMMEDIATE         3
+
+#define SPI_CMD_COMMAND_SHIFT           0
+#define SPI_CMD_DEVICE_ID_SHIFT         4
+#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT  8
+#define SPI_CMD_ONE_BYTE_SHIFT          11
+#define SPI_CMD_ONE_WIRE_SHIFT          12
+#define SPI_DEV_ID_0                    0
+#define SPI_DEV_ID_1                    1
+#define SPI_DEV_ID_2                    2
+#define SPI_DEV_ID_3                    3
+
+  byte          spiIntStatus;           /* (0x2): SPI interrupt status */
+  byte          spiMaskIntStatus;       /* (0x3): SPI masked interrupt status */
+
+  byte          spiIntMask;             /* (0x4): SPI interrupt mask */
+#define SPI_INTR_CMD_DONE               0x01
+#define SPI_INTR_RX_OVERFLOW            0x02
+#define SPI_INTR_INTR_TX_UNDERFLOW      0x04
+#define SPI_INTR_TX_OVERFLOW            0x08
+#define SPI_INTR_RX_UNDERFLOW           0x10
+#define SPI_INTR_CLEAR_ALL              0x1f
+
+  byte          spiStatus;              /* (0x5): SPI status */
+#define SPI_RX_EMPTY                    0x02
+#define SPI_CMD_BUSY                    0x04
+#define SPI_SERIAL_BUSY                 0x08
+
+  byte          spiClkCfg;              /* (0x6): SPI clock configuration */
+#define SPI_CLK_0_391MHZ                1
+#define SPI_CLK_0_781MHZ                2 /* default */
+#define SPI_CLK_1_563MHZ                3
+#define SPI_CLK_3_125MHZ                4
+#define SPI_CLK_6_250MHZ                5
+#define SPI_CLK_12_50MHZ                6
+#define SPI_CLK_MASK                    0x07
+#define SPI_SSOFFTIME_MASK              0x38
+#define SPI_SSOFFTIME_SHIFT             3
+#define SPI_BYTE_SWAP                   0x80
+
+  byte          spiFillByte;            /* (0x7): SPI fill byte */
+
+  byte          unused0; 
+  byte          spiMsgTail;             /* (0x9): msgtail */
+  byte          unused1; 
+  byte          spiRxTail;              /* (0xB): rxtail */
+
+  uint32        unused2[13];            /* (0x0c - 0x3c) reserved */
+
+  byte          spiMsgCtl;              /* (0x40) control byte */
+#define FULL_DUPLEX_RW                  0
+#define HALF_DUPLEX_W                   1
+#define HALF_DUPLEX_R                   2
+#define SPI_MSG_TYPE_SHIFT              6
+#define SPI_BYTE_CNT_SHIFT              0
+  byte          spiMsgData[63];         /* (0x41 - 0x7f) msg data */
+  byte          spiRxDataFifo[64];      /* (0x80 - 0xbf) rx data */
+  byte          unused3[64];            /* (0xc0 - 0xff) reserved */
+} SpiControl;
+
+#define SPI ((volatile SpiControl * const) SPI_BASE)
+
+#define IUDMA_MAX_CHANNELS      16
+
+/*
+** DMA Channel Configuration (1 .. 16)
+*/
+typedef struct DmaChannelCfg {
+  uint32        cfg;                    /* (00) assorted configuration */
+#define         DMA_BURST_HALT  0x00000004  /* idle after finish current memory burst */
+#define         DMA_PKT_HALT    0x00000002  /* idle after an EOP flag is detected */
+#define         DMA_ENABLE  0x00000001      /* set to enable channel */
+  uint32        intStat;                /* (04) interrupts control and status */
+  uint32        intMask;                /* (08) interrupts mask */
+#define         DMA_BUFF_DONE   0x00000001  /* buffer done */
+#define         DMA_DONE        0x00000002  /* packet xfer complete */
+#define         DMA_NO_DESC     0x00000004  /* no valid descriptors */
+  uint32        maxBurst;               /* (0C) max burst length permitted */
+} DmaChannelCfg;
+
+/*
+** DMA State RAM (1 .. 16)
+*/
+typedef struct DmaStateRam {
+  uint32        baseDescPtr;            /* (00) descriptor ring start address */
+  uint32        state_data;             /* (04) state/bytes done/ring offset */
+  uint32        desc_len_status;        /* (08) buffer descriptor status and len */
+  uint32        desc_base_bufptr;       /* (0C) buffer descrpitor current processing */
+} DmaStateRam;
+
+/*
+** DMA Registers
+*/
+typedef struct DmaRegs {
+#define DMA_MASTER_EN           0x00000001
+#define DMA_FLOWC_CH1_EN        0x00000002
+#define DMA_FLOWC_CH3_EN        0x00000004
+#define DMA_NUM_CHS_MASK        0x0f000000
+#define DMA_NUM_CHS_SHIFT       24
+#define DMA_FLOWCTL_MASK        0x30000000
+#define DMA_FLOWCTL_CH1         0x10000000
+#define DMA_FLOWCTL_CH3         0x20000000
+#define DMA_FLOWCTL_SHIFT       28
+    uint32 controller_cfg;              /* (00) controller configuration */
+
+    // Flow control Ch1
+    uint32 flowctl_ch1_thresh_lo;       /* (04) EMAC1 RX DMA channel */
+    uint32 flowctl_ch1_thresh_hi;       /* (08) EMAC1 RX DMA channel */
+    uint32 flowctl_ch1_alloc;           /* (0C) EMAC1 RX DMA channel */
+#define DMA_BUF_ALLOC_FORCE     0x80000000
+
+    // Flow control Ch3
+    uint32 flowctl_ch3_thresh_lo;       /* (10) EMAC2 RX DMA channel */
+    uint32 flowctl_ch3_thresh_hi;       /* (14) EMAC2 RX DMA channel */
+    uint32 flowctl_ch3_alloc;           /* (18) EMAC2 RX DMA channel */
+
+    // Unused words
+    uint32 resv[57];
+
+    // Per channel registers/state ram
+    DmaChannelCfg chcfg[IUDMA_MAX_CHANNELS]; /* (100) Channel configuration */
+    union {
+        DmaStateRam     s[IUDMA_MAX_CHANNELS];
+        uint32          u32[4 * IUDMA_MAX_CHANNELS];
+    } stram;                                /* (200) state ram */
+} DmaRegs;
+
+/*
+** DMA Buffer 
+*/
+typedef struct DmaDesc {
+  uint16        length;                 /* in bytes of data in buffer */
+#define          DMA_DESC_USEFPM    0x8000
+#define          DMA_DESC_MULTICAST 0x4000
+#define          DMA_DESC_BUFLENGTH 0x0fff
+  uint16        status;                 /* buffer status */
+#define          DMA_OWN        0x8000  /* cleared by DMA, set by SW */
+#define          DMA_EOP        0x4000  /* last buffer in packet */
+#define          DMA_SOP        0x2000  /* first buffer in packet */
+#define          DMA_WRAP       0x1000  /* */
+#define          DMA_APPEND_CRC 0x0100
+
+/* EMAC Descriptor Status definitions */
+#define          EMAC_MISS      0x0080  /* framed address recognition failed (promiscuous) */
+#define          EMAC_BRDCAST   0x0040  /* DA is Broadcast */
+#define          EMAC_MULT      0x0020  /* DA is multicast */
+#define          EMAC_LG        0x0010  /* frame length > RX_LENGTH register value */
+#define          EMAC_NO        0x0008  /* Non-Octet aligned */
+#define          EMAC_RXER      0x0004  /* RX_ERR on MII while RX_DV assereted */
+#define          EMAC_CRC_ERROR 0x0002  /* CRC error */
+#define          EMAC_OV        0x0001  /* Overflow */
+
+/* HDLC Descriptor Status definitions */
+#define          DMA_HDLC_TX_ABORT      0x0100
+#define          DMA_HDLC_RX_OVERRUN    0x4000
+#define          DMA_HDLC_RX_TOO_LONG   0x2000
+#define          DMA_HDLC_RX_CRC_OK     0x1000
+#define          DMA_HDLC_RX_ABORT      0x0100
+
+  uint32        address;                /* address of data */
+} DmaDesc;
+
+/*
+** Sdram Controller
+*/
+typedef struct SdramControllerRegs {
+  uint16        unused1;
+  uint16        initControl;    /* 02 */
+#define SD_POWER_DOWN           0x200   /* put sdram into power down */
+#define SD_SELF_REFRESH         0x100   /* enable self refresh mode */
+#define SD_SOFT_RESET           0x080   /* soft reset all sdram controller regs */
+#define SD_EDO_SELECT           0x040   /* select EDO mode */
+#define SD_EDO_WAIT_STATE       0x020   /* add an EDO wait state */
+#define SD_8MEG                 0x010   /* map sdram to 8 megs */
+#define SD_MASTER_ENABLE        0x008   /* enable accesses to external sdram */
+#define SD_MRS                  0x004   /* generate a mode register select cycle */
+#define SD_PRECHARGE            0x002   /* generate a precharge cycle */
+#define SD_CBR                  0x001   /* generate a refresh cycle */
+  uint8         unused2[3];
+  uint8         config;         /* 07 */
+#define SD_FAST_MEM             0x04    /* 1=CAS latency of 2, 0 = CAS latency of 3 */
+#define SD_BURST_LEN            0x03    /* set burst length */
+#define SD_BURST_FULL_PAGE      0x00    /* .. full page */
+#define SD_BURST_8              0x01    /* .. 8 words */
+#define SD_BURST_4              0x02    /* .. 4 words */
+#define SD_BURST_2              0x03    /* .. 2 words */
+  uint16        unused3;
+  uint16        refreshControl; /* 0a */
+#define SD_REFRESH_ENABLE       0x8000  /* refresh enable */
+#define SD_REFRESH_PERIOD       0x00ff  /* refresh period (16 x n x clock_period) */
+
+  uint32        memoryBase;     /* 0c */
+#define SD_MEMBASE_MASK         0xffffe000      /* base address mask */
+#define SD_MEMSIZE_8MEG         0x00000001      /* memory is 8 meg */
+#define SD_MEMSIZE_2MEG         0x00000001      /* memory is 2 meg */
+
+} SdramControllerRegs;
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[7];                  /* size chip select configuration */
+#define EBI_CS0_BASE            0
+#define EBI_CS1_BASE            1
+#define EBI_CS2_BASE            2
+#define EBI_CS3_BASE            3
+#define PCMCIA_COMMON_BASE      4
+#define PCMCIA_ATTRIBUTE_BASE   5
+#define PCMCIA_IO_BASE          6
+  uint32        unused0[2];             /* reserved */
+  uint32        ebi_control;            /* ebi control */
+  uint32        unused1[4];             /* reserved */
+#define EBI_ACCESS_TIMEOUT      0x000007FF
+  uint32        pcmcia_cntl1;           /* pcmcia control 1 */
+#define PCCARD_CARD_RESET       0x00040000
+#define CARDBUS_ENABLE          0x00008000
+#define PCMCIA_ENABLE           0x00004000
+#define PCMCIA_GPIO_ENABLE      0x00002000
+#define CARDBUS_IDSEL           0x00001F00
+#define VS2_OEN                 0x00000080
+#define VS1_OEN                 0x00000040
+#define VS2_OUT                 0x00000020
+#define VS1_OUT                 0x00000010
+#define VS2_IN                  0x00000008
+#define VS1_IN                  0x00000004
+#define CD2_IN                  0x00000002
+#define CD1_IN                  0x00000001
+#define VS_MASK                 0x0000000C
+#define CD_MASK                 0x00000003
+  uint32        unused2;                /* reserved */
+  uint32        pcmcia_cntl2;           /* pcmcia control 2 */
+#define PCMCIA_BYTESWAP_DIS     0x00000002
+#define PCMCIA_HALFWORD_EN      0x00000001
+  uint32        unused3[40];            /* reserved */
+
+  uint32        sp0range;               /* PCI to internal system bus address space */
+#define ADDR_SPACE_MASK         0xFFFF0000
+  uint32        sp0remap;
+  uint32        sp0cfg;
+  uint32        sp1range;
+  uint32        sp1remap;
+  uint32        sp1cfg;
+
+  uint32        EndianCfg;
+
+  uint32        l2pcfgctl;              /* internal system bus to PCI IO/Cfg control */
+#define DIR_CFG_SEL             0x80000000 /* change from PCI I/O access to PCI config access */
+#define DIR_CFG_USEREG          0x40000000 /* use this register info for PCI configuration access */
+#define DEVICE_NUMBER           0x00007C00 /* device number for the PCI configuration access */
+#define FUNC_NUMBER             0x00000300 /* function number for the PCI configuration access */
+#define REG_NUMBER              0x000000FC /* register number for the PCI configuration access */
+#define CONFIG_TYPE             0x00000003 /* configuration type for the PCI configuration access */
+
+  uint32        l2pmrange1;             /* internal system bus to PCI memory space */
+#define PCI_SIZE_64K            0xFFFF0000
+#define PCI_SIZE_128K           0xFFFE0000
+#define PCI_SIZE_256K           0xFFFC0000
+#define PCI_SIZE_512K           0xFFF80000
+#define PCI_SIZE_1M             0xFFF00000
+#define PCI_SIZE_2M             0xFFE00000
+#define PCI_SIZE_4M             0xFFC00000
+#define PCI_SIZE_8M             0xFF800000
+#define PCI_SIZE_16M            0xFF000000
+  uint32        l2pmbase1;              /* kseg0 or kseg1 address & 0x1FFFFFFF */
+  uint32        l2pmremap1;
+#define CARDBUS_MEM             0x00000004
+#define MEM_WINDOW_EN           0x00000001
+  uint32        l2pmrange2;
+  uint32        l2pmbase2;
+  uint32        l2pmremap2;
+  uint32        l2piorange;             /* internal system bus to PCI I/O space */
+  uint32        l2piobase;
+  uint32        l2pioremap;
+
+  uint32        pcimodesel;
+#define PCI2_INT_BUS_RD_PREFECH 0x000000F0
+#define PCI_BAR2_NOSWAP         0x00000002 /* BAR at offset 0x20 */
+#define PCI_BAR1_NOSWAP         0x00000001 /* BAR at affset 0x1c */
+
+  uint32        pciintstat;             /* PCI interrupt mask/status */
+#define MAILBOX1_SENT           0x08
+#define MAILBOX0_SENT           0x04
+#define MAILBOX1_MSG_RCV        0x02
+#define MAILBOX0_MSG_RCV        0x01
+  uint32        locbuscntrl;            /* internal system bus control */
+#define DIR_U2P_NOSWAP          0x00000002
+#define EN_PCI_GPIO             0x00000001
+  uint32        locintstat;             /* internal system bus interrupt mask/status */
+#define CSERR                   0x0200
+#define SERR                    0x0100
+#define EXT_PCI_INT             0x0080
+#define DIR_FAILED              0x0040
+#define DIR_COMPLETE            0x0020
+#define PCI_CFG                 0x0010
+  uint32        unused4[7];
+
+  uint32        mailbox0;
+  uint32        mailbox1;
+
+  uint32        pcicfgcntrl;            /* internal system bus PCI configuration control */
+#define PCI_CFG_REG_WRITE_EN    0x00000080
+#define PCI_CFG_ADDR            0x0000003C
+  uint32        pcicfgdata;             /* internal system bus PCI configuration data */
+
+  uint32        locch2ctl;              /* PCI to interrnal system bus DMA (downstream) local control */
+#define MPI_DMA_HALT            0x00000008  /* idle after finish current memory burst */
+#define MPI_DMA_PKT_HALT        0x00000004  /* idle after an EOP flag is detected */
+#define MPI_DMA_STALL           0x00000002  /* idle after an EOP flag is detected */
+#define MPI_DMA_ENABLE          0x00000001  /* set to enable channel */
+  uint32        locch2intStat;
+#define MPI_DMA_NO_DESC         0x00000004  /* no valid descriptors */
+#define MPI_DMA_DONE            0x00000002  /* packet xfer complete */
+#define MPI_DMA_BUFF_DONE       0x00000001  /* buffer done */
+  uint32        locch2intMask;
+  uint32        unused5;
+  uint32        locch2descaddr;
+  uint32        locch2status1;
+#define LOCAL_DESC_STATE        0xE0000000
+#define PCI_DESC_STATE          0x1C000000
+#define BYTE_DONE               0x03FFC000
+#define RING_ADDR               0x00003FFF
+  uint32        locch2status2;
+#define BUFPTR_OFFSET           0x1FFF0000
+#define PCI_MASTER_STATE        0x000000C0
+#define LOC_MASTER_STATE        0x00000038
+#define CONTROL_STATE           0x00000007
+  uint32        unused6;
+
+  uint32        locch1Ctl;              /*internal system bus to PCI DMA (upstream) local control */
+#define DMA_U2P_LE              0x00000200  /* local bus is little endian */
+#define DMA_U2P_NOSWAP          0x00000100  /* lccal bus is little endian but no data swapped */
+  uint32        locch1intstat;
+  uint32        locch1intmask;
+  uint32        unused7;
+  uint32        locch1descaddr;
+  uint32        locch1status1;
+  uint32        locch1status2;
+  uint32        unused8;
+
+  uint32        pcich1ctl;              /* internal system bus to PCI DMA PCI control */
+  uint32        pcich1intstat;
+  uint32        pcich1intmask;
+  uint32        pcich1descaddr;
+  uint32        pcich1status1;
+  uint32        pcich1status2;
+
+  uint32        pcich2Ctl;              /* PCI to internal system bus DMA PCI control */
+  uint32        pcich2intstat;
+  uint32        pcich2intmask;
+  uint32        pcich2descaddr;
+  uint32        pcich2status1;
+  uint32        pcich2status2;
+
+  uint32        perm_id;                /* permanent device and vendor id */
+  uint32        perm_rev;               /* permanent revision id */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+/* PCI configuration address space start offset 0x40 */
+#define BRCM_PCI_CONFIG_TIMER               0x40
+#define BRCM_PCI_CONFIG_TIMER_RETRY_MASK    0x0000FF00
+#define BRCM_PCI_CONFIG_TIMER_TRDY_MASK     0x000000FF
+
+/*
+** EMAC transmit MIB counters
+*/
+typedef struct EmacTxMib {
+  uint32        tx_good_octets;         /* (200) good byte count */
+  uint32        tx_good_pkts;           /* (204) good pkt count */
+  uint32        tx_octets;              /* (208) good and bad byte count */
+  uint32        tx_pkts;                /* (20c) good and bad pkt count */
+  uint32        tx_broadcasts_pkts;     /* (210) good broadcast packets */
+  uint32        tx_multicasts_pkts;     /* (214) good mulitcast packets */
+  uint32        tx_len_64;              /* (218) RMON tx pkt size buckets */
+  uint32        tx_len_65_to_127;       /* (21c) */
+  uint32        tx_len_128_to_255;      /* (220) */
+  uint32        tx_len_256_to_511;      /* (224) */
+  uint32        tx_len_512_to_1023;     /* (228) */
+  uint32        tx_len_1024_to_max;     /* (22c) */
+  uint32        tx_jabber_pkts;         /* (230) > 1518 with bad crc */
+  uint32        tx_oversize_pkts;       /* (234) > 1518 with good crc */
+  uint32        tx_fragment_pkts;       /* (238) < 63   with bad crc */
+  uint32        tx_underruns;           /* (23c) fifo underrun */
+  uint32        tx_total_cols;          /* (240) total collisions in all tx pkts */
+  uint32        tx_single_cols;         /* (244) tx pkts with single collisions */
+  uint32        tx_multiple_cols;       /* (248) tx pkts with multiple collisions */
+  uint32        tx_excessive_cols;      /* (24c) tx pkts with excessive cols */
+  uint32        tx_late_cols;           /* (250) tx pkts with late cols */
+  uint32        tx_defered;             /* (254) tx pkts deferred */
+  uint32        tx_carrier_lost;        /* (258) tx pkts with CRS lost */
+  uint32        tx_pause_pkts;          /* (25c) tx pause pkts sent */
+#define NumEmacTxMibVars        24
+} EmacTxMib;
+
+/*
+** EMAC receive MIB counters
+*/
+typedef struct EmacRxMib {
+  uint32        rx_good_octets;         /* (280) good byte count */
+  uint32        rx_good_pkts;           /* (284) good pkt count */
+  uint32        rx_octets;              /* (288) good and bad byte count */
+  uint32        rx_pkts;                /* (28c) good and bad pkt count */
+  uint32        rx_broadcasts_pkts;     /* (290) good broadcast packets */
+  uint32        rx_multicasts_pkts;     /* (294) good mulitcast packets */
+  uint32        rx_len_64;              /* (298) RMON rx pkt size buckets */
+  uint32        rx_len_65_to_127;       /* (29c) */
+  uint32        rx_len_128_to_255;      /* (2a0) */
+  uint32        rx_len_256_to_511;      /* (2a4) */
+  uint32        rx_len_512_to_1023;     /* (2a8) */
+  uint32        rx_len_1024_to_max;     /* (2ac) */
+  uint32        rx_jabber_pkts;         /* (2b0) > 1518 with bad crc */
+  uint32        rx_oversize_pkts;       /* (2b4) > 1518 with good crc */
+  uint32        rx_fragment_pkts;       /* (2b8) < 63   with bad crc */
+  uint32        rx_missed_pkts;         /* (2bc) missed packets */
+  uint32        rx_crc_align_errs;      /* (2c0) both or either */
+  uint32        rx_undersize;           /* (2c4) < 63   with good crc */
+  uint32        rx_crc_errs;            /* (2c8) crc errors (only) */
+  uint32        rx_align_errs;          /* (2cc) alignment errors (only) */
+  uint32        rx_symbol_errs;         /* (2d0) pkts with RXERR assertions (symbol errs) */
+  uint32        rx_pause_pkts;          /* (2d4) MAC control, PAUSE */
+  uint32        rx_nonpause_pkts;       /* (2d8) MAC control, not PAUSE */
+#define NumEmacRxMibVars        23
+} EmacRxMib;
+
+typedef struct EmacRegisters {
+  uint32        rxControl;              /* (00) receive control */
+#define          EMAC_PM_REJ    0x80    /*      - reject DA match in PMx regs */
+#define          EMAC_UNIFLOW   0x40    /*      - accept cam match fc */
+#define          EMAC_FC_EN     0x20    /*      - enable flow control */
+#define          EMAC_LOOPBACK  0x10    /*      - loopback */
+#define          EMAC_PROM      0x08    /*      - promiscuous */
+#define          EMAC_RDT       0x04    /*      - ignore transmissions */
+#define          EMAC_ALL_MCAST 0x02    /*      - ignore transmissions */
+#define          EMAC_NO_BCAST  0x01    /*      - ignore transmissions */
+
+
+  uint32        rxMaxLength;            /* (04) receive max length */
+  uint32        txMaxLength;            /* (08) transmit max length */
+  uint32        unused1[1];
+  uint32        mdioFreq;               /* (10) mdio frequency */
+#define          EMAC_MII_PRE_EN 0x00000080 /* prepend preamble sequence */
+#define          EMAC_MDIO_PRE   0x00000080 /*      - enable MDIO preamble */
+#define          EMAC_MDC_FREQ   0x0000007f /*      - mdio frequency */
+
+  uint32        mdioData;               /* (14) mdio data */
+#define          MDIO_WR        0x50020000 /*   - write framing */
+#define          MDIO_RD        0x60020000 /*   - read framing */
+#define          MDIO_PMD_SHIFT  23
+#define          MDIO_REG_SHIFT  18
+
+  uint32        intMask;                /* (18) int mask */
+  uint32        intStatus;              /* (1c) int status */
+#define          EMAC_FLOW_INT  0x04    /*      - flow control event */
+#define          EMAC_MIB_INT   0x02    /*      - mib event */
+#define          EMAC_MDIO_INT  0x01    /*      - mdio event */
+
+  uint32        unused2[3];
+  uint32        config;                 /* (2c) config */
+#define          EMAC_ENABLE    0x001   /*      - enable emac */
+#define          EMAC_DISABLE   0x002   /*      - disable emac */
+#define          EMAC_SOFT_RST  0x004   /*      - soft reset */
+#define          EMAC_SOFT_RESET 0x004  /*      - emac soft reset */
+#define          EMAC_EXT_PHY   0x008   /*      - external PHY select */
+
+  uint32        txControl;              /* (30) transmit control */
+#define          EMAC_FD        0x001   /*      - full duplex */
+#define          EMAC_FLOWMODE  0x002   /*      - flow mode */
+#define          EMAC_NOBKOFF   0x004   /*      - no backoff in  */
+#define          EMAC_SMALLSLT  0x008   /*      - small slot time */
+
+  uint32        txThreshold;            /* (34) transmit threshold */
+  uint32        mibControl;             /* (38) mib control */
+#define          EMAC_NO_CLEAR  0x001   /* don't clear on read */
+
+  uint32        unused3[7];
+
+  uint32        pm0DataLo;              /* (58) perfect match 0 data lo */
+  uint32        pm0DataHi;              /* (5C) perfect match 0 data hi (15:0) */
+  uint32        pm1DataLo;              /* (60) perfect match 1 data lo */
+  uint32        pm1DataHi;              /* (64) perfect match 1 data hi (15:0) */
+  uint32        pm2DataLo;              /* (68) perfect match 2 data lo */
+  uint32        pm2DataHi;              /* (6C) perfect match 2 data hi (15:0) */
+  uint32        pm3DataLo;              /* (70) perfect match 3 data lo */
+  uint32        pm3DataHi;              /* (74) perfect match 3 data hi (15:0) */
+#define          EMAC_CAM_V   0x10000  /*      - cam index */
+#define          EMAC_CAM_VALID 0x00010000
+
+  uint32        unused4[98];            /* (78-1fc) */
+
+  EmacTxMib     tx_mib;                 /* (200) emac tx mib */
+  uint32        unused5[8];             /* (260-27c) */
+
+  EmacRxMib     rx_mib;                 /* (280) rx mib */
+
+} EmacRegisters;
+
+/* register offsets for subrouting access */
+#define EMAC_RX_CONTROL         0x00
+#define EMAC_RX_MAX_LENGTH      0x04
+#define EMAC_TX_MAC_LENGTH      0x08
+#define EMAC_MDIO_FREQ          0x10
+#define EMAC_MDIO_DATA          0x14
+#define EMAC_INT_MASK           0x18
+#define EMAC_INT_STATUS         0x1C
+#define EMAC_CAM_DATA_LO        0x20
+#define EMAC_CAM_DATA_HI        0x24
+#define EMAC_CAM_CONTROL        0x28
+#define EMAC_CONTROL            0x2C
+#define EMAC_TX_CONTROL         0x30
+#define EMAC_TX_THRESHOLD       0x34
+#define EMAC_MIB_CONTROL        0x38
+
+
+#define EMAC1 ((volatile EmacRegisters * const) EMAC1_BASE)
+#define EMAC2 ((volatile EmacRegisters * const) EMAC2_BASE)
+
+/*
+** USB Registers
+*/
+typedef struct UsbRegisters {
+    byte inttf_setting;
+    byte current_config;
+    uint16 status_frameNum;
+#define USB_LINK        0x2000 
+#define USB_BUS_RESET   0x1000 
+#define USB_SUSPENDED   0x0800 
+    byte unused1;
+    byte endpt_prnt;
+    byte endpt_dirn;
+    byte endpt_status;
+#define USB_ENDPOINT_0  0x01
+#define USB_ENDPOINT_1  0x02
+#define USB_ENDPOINT_2  0x04
+#define USB_ENDPOINT_3  0x08
+#define USB_ENDPOINT_4  0x10
+#define USB_ENDPOINT_5  0x20
+#define USB_ENDPOINT_6  0x40
+#define USB_ENDPOINT_7  0x80
+    uint32 unused2;
+    byte conf_mem_ctl;
+#define USB_CONF_MEM_RD     0x80
+#define USB_CONF_MEM_RDY    0x40
+    byte unused2a;
+    byte conf_mem_read_address;
+    byte conf_mem_write_address;
+
+    byte unused3;
+    byte dev_req_bytesel;
+    uint16 ext_dev_data;
+
+    byte unused4;
+    byte clr_fifo;
+    byte endpt_stall_reset;  // use same endpoint #'s from above
+    byte usb_cntl;
+#define USB_FORCE_ERR       0x20
+#define USB_SOFT_RESET      0x10
+#define USB_RESUME          0x08
+#define USB_COMMAND_ERR     0x04
+#define USB_COMMAND_OVER    0x02
+    byte irq_addr;
+    byte iso_out_in_addr;
+    byte blk_out_in_addr;
+    byte cntl_addr;
+    uint32 unusedx[2];
+    uint32 tx_ram_write_port;
+    uint32 fifo_status;  // (see bcm6348 data sheet for definition)
+
+    uint32 irq_status;
+    uint32 irq_mask;
+#define USB_NEW_CONFIG              0x00000001   
+#define USB_SETUP_COMMAND_RECV      0x00000002 // non-standard setup cmd rcvd
+#define USB_OUT_FIFO_OV             0x00000004   
+#define USB_RESET_RECV              0x00000008   
+#define USB_SUSPEND_RECV            0x00000010   
+#define USB_FIFO_REWIND             0x00000020   
+#define USB_RX_BULK_FIFO_DATA_AVAIL 0x00000040   
+#define USB_RX_ISO_FIFO_DATA_AVAIL  0x00000080   
+#define USB_LINK_CHANGE             0x00010000   
+    uint32 endpt_cntl;
+#define USB_R_WK_EN                 0x0100   
+#define USB_TX_EOP                  0x0200   
+#define USB_TX_CNTL_DMA_EN          0x0400
+#define USB_TX_BULK_DMA_EN          0x0800
+#define USB_TX_ISO_DMA_EN           0x1000
+#define USB_RX_CNTL_DMA_EN          0x2000
+#define USB_RX_BULK_DMA_EN          0x4800
+#define USB_RX_ISO_DMA_EN           0x8000
+    uint32 rx_status_read_port;
+    uint32 confmem_read_port;
+    uint32 confmem_write_port;
+    uint32 fifo_ovf_count;
+    uint32 fifo_rewind_cnt;
+    uint32 terminal_count;
+} UsbRegisters;
+
+#define USB ((volatile UsbRegisters * const) USB_CTL_BASE)
+
+/*
+** ADSL core Registers
+*/
+
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+
+typedef struct AdslRegisters {
+    uint32 core_control;
+#define ADSL_RESET		0x01
+   
+    uint32 core_status;
+#define ADSL_HOST_MSG	0x01
+
+    uint32 PAD;
+    uint32 bist_status;
+    uint32 PAD[4];
+    uint32 int_status_i; /* 0x20 */
+    uint32 int_mask_i;
+    uint32 int_status_f;
+    uint32 int_mask_f;
+#define ADSL_INT_HOST_MSG		0x00000020
+#define ADSL_INT_DESC_ERR		0x00000400
+#define ADSL_INT_DATA_ERR		0x00000800
+#define ADSL_INT_DESC_PROTO_ERR	0x00001000
+#define ADSL_INT_RCV_DESC_UF	0x00002000
+#define ADSL_INT_RCV_FIFO_OF	0x00004000
+#define ADSL_INT_XMT_FIFO_UF	0x00008000
+#define ADSL_INT_RCV			0x00010000
+#define ADSL_INT_XMT			0x01000000
+
+    uint32 PAD[116];
+
+	uint32	xmtcontrol_intr; /* 0x200 */
+#define ADSL_DMA_XMT_EN			0x00000001
+#define ADSL_DMA_XMT_LE			0x00000004
+	uint32	xmtaddr_intr;
+#define ADSL_DMA_ADDR_MASK		0xFFFFF000
+	uint32	xmtptr_intr;
+#define ADSL_DMA_LAST_DESC_MASK	0x00000FFF
+	uint32	xmtstatus_intr;
+#define ADSL_DMA_CURR_DESC_MASK	0x00000FFF
+#define ADSL_DMA_XMT_STATE_MASK	0x0000F000
+#define ADSL_DMA_XMT_STATE_DIS	0x00000000
+#define ADSL_DMA_XMT_STATE_ACT	0x00001000
+#define ADSL_DMA_XMT_STATE_IDLE	0x00002000
+#define ADSL_DMA_XMT_STATE_STOP	0x00003000
+
+#define ADSL_DMA_XMT_ERR_MASK	0x000F0000
+#define ADSL_DMA_XMT_ERR_NONE	0x00000000
+#define ADSL_DMA_XMT_ERR_DPE	0x00010000
+#define ADSL_DMA_XMT_ERR_FIFO	0x00020000
+#define ADSL_DMA_XMT_ERR_DTE	0x00030000
+#define ADSL_DMA_XMT_ERR_DRE	0x00040000
+
+	uint32	rcvcontrol_intr;
+#define ADSL_DMA_RCV_EN			0x00000001
+#define ADSL_DMA_RCV_FO			0x000000FE
+	uint32	rcvaddr_intr;
+	uint32	rcvptr_intr;
+	uint32	rcvstatus_intr;
+#define ADSL_DMA_RCV_STATE_MASK	0x0000F000
+#define ADSL_DMA_RCV_STATE_DIS	0x00000000
+#define ADSL_DMA_RCV_STATE_ACT	0x00001000
+#define ADSL_DMA_RCV_STATE_IDLE	0x00002000
+#define ADSL_DMA_RCV_STATE_STOP	0x00003000
+
+#define ADSL_DMA_RCV_ERR_MASK	0x000F0000
+#define ADSL_DMA_RCV_ERR_NONE	0x00000000
+#define ADSL_DMA_RCV_ERR_DPE	0x00010000
+#define ADSL_DMA_RCV_ERR_FIFO	0x00020000
+#define ADSL_DMA_RCV_ERR_DTE	0x00030000
+#define ADSL_DMA_RCV_ERR_DRE	0x00040000
+
+	uint32	xmtcontrol_fast;
+	uint32	xmtaddr_fast;
+	uint32	xmtptr_fast;
+	uint32	xmtstatus_fast;
+	uint32	rcvcontrol_fast;
+	uint32	rcvaddr_fast;
+	uint32	rcvptr_fast;
+	uint32	rcvstatus_fast;
+	uint32	PAD[48];
+
+	uint32	host_message; /* 0x300 */
+	uint32	PAD[805];
+    uint32 core_reset;
+    uint32 core_error;
+    uint32 core_revision;
+
+#define	ADSL_CORE_REV			0x0000000F
+#define	ADSL_CORE_TYPE			0x0000FFF0
+} AdslRegisters;
+
+#define ADSL ((volatile AdslRegisters * const) ADSL_BASE)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/AdslMibDef.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/AdslMibDef.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/AdslMibDef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/AdslMibDef.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,712 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/****************************************************************************
+ *
+ * AdslMibOid.h 
+ *
+ * Description:
+ *	SNMP object identifiers for ADSL MIB and other related MIBs
+ *
+ * Copyright (c) 1993-1998 AltoCom, Inc. All rights reserved.
+ * Authors: Ilya Stomakhin
+ *
+ * $Revision: 1.17 $
+ *
+ * $Id: AdslMibDef.h,v 1.17 2004/07/27 19:24:40 ilyas Exp $
+ *
+ * $Log: AdslMibDef.h,v $
+ * Revision 1.17  2004/07/27 19:24:40  ilyas
+ * Added AnnexM configuration option
+ *
+ * Revision 1.16  2004/06/04 18:56:01  ilyas
+ * Added counter for ADSL2 framing and performance
+ *
+ * Revision 1.15  2004/05/25 16:15:04  ilyas
+ * Added ADSL2 framing status
+ *
+ * Revision 1.14  2004/03/31 19:09:48  ilyas
+ * Added ADSL2+ modulation control
+ *
+ * Revision 1.13  2004/03/03 20:14:05  ilyas
+ * Merged changes for ADSL2+ from ADSL driver
+ *
+ * Revision 1.12  2003/10/17 21:02:12  ilyas
+ * Added more data for ADSL2
+ *
+ * Revision 1.11  2003/10/14 00:55:27  ilyas
+ * Added UAS, LOSS, SES error seconds counters.
+ * Support for 512 tones (AnnexI)
+ *
+ * Revision 1.10  2003/09/29 18:39:51  ilyas
+ * Added new definitions for AnnexI
+ *
+ * Revision 1.9  2003/07/18 19:14:34  ilyas
+ * Merged with ADSL driver
+ *
+ * Revision 1.8  2003/07/08 18:34:16  ilyas
+ * Added fields to adsl configuration structure
+ *
+ * Revision 1.7  2003/03/25 00:07:00  ilyas
+ * Added "long" BERT supprt
+ *
+ * Revision 1.6  2003/02/27 07:10:52  ilyas
+ * Added more configuration and status parameters (for EFNT)
+ *
+ * Revision 1.5  2003/01/23 20:29:37  ilyas
+ * Added structure for ADSL PHY configuration command
+ *
+ * Revision 1.4  2002/11/13 21:32:49  ilyas
+ * Added adjustK support for Centillium non-standard framing mode
+ *
+ * Revision 1.3  2002/10/31 01:35:50  ilyas
+ * Fixed size of K for S=1/2
+ *
+ * Revision 1.2  2002/10/05 03:28:31  ilyas
+ * Added extra definitions for Linux and VxWorks drivers.
+ * Added definitions for SelfTest support
+ *
+ * Revision 1.1  2002/07/20 00:51:41  ilyas
+ * Merged witchanges made for VxWorks/Linux driver.
+ *
+ * Revision 1.1  2001/12/21 22:39:30  ilyas
+ * Added support for ADSL MIB data objects (RFC2662)
+ *
+ *
+ *****************************************************************************/
+
+#ifndef	AdslMibDefHeader
+#define	AdslMibDefHeader
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* 
+**
+**		ADSL configuration parameters 
+**
+*/
+
+#define kAdslCfgModMask						(0x00000007 | 0x0000F000)
+#define kAdslCfgModAny						0x00000000
+
+#define kAdslCfgModGdmtOnly					0x00000001
+#define kAdslCfgModGliteOnly				0x00000002
+#define kAdslCfgModT1413Only				0x00000004
+#define kAdslCfgModAnnexIOnly				0x00000004
+#define kAdslCfgModAdsl2Only				0x00001000
+#define kAdslCfgModAdsl2pOnly				0x00002000
+
+#define kAdslCfgBitmapMask					0x00000018
+#define kAdslCfgDBM							0x00000000
+#define kAdslCfgFBM							0x00000008
+#define kAdslCfgFBMSoL						0x00000010
+
+#define kAdslCfgLinePairMask				0x00000020
+#define kAdslCfgLineInnerPair				0x00000000
+#define kAdslCfgLineOuterPair				0x00000020
+
+#define kAdslCfgCentilliumCRCWorkAroundMask			0x00000040
+#define kAdslCfgCentilliumCRCWorkAroundDisabled		0x00000000
+#define kAdslCfgCentilliumCRCWorkAroundEnabled		0x00000040
+
+#define kAdslCfgExtraData					0x00000080
+#define kAdslCfgTrellisMask					(0x00000100 | kAdslCfgExtraData)
+#define kAdslCfgTrellisOn					(0x00000100 | kAdslCfgExtraData)
+#define kAdslCfgTrellisOff					(0 | kAdslCfgExtraData)
+#define kAdslCfgExtraMask					0xFFFFFF80
+
+#define kAdslCfgLOSMonitoringMask			0x00000200
+#define kAdslCfgLOSMonitoringOff			0x00000200
+#define kAdslCfgLOSMonitoringOn				0x00000000
+
+#define kAdslCfgMarginMonitoringMask		0x00000400
+#define kAdslCfgMarginMonitoringOn			0x00000400
+#define kAdslCfgMarginMonitoringOff			0x00000000
+
+#define kAdslCfgDemodCapMask				0x00000800
+#define kAdslCfgDemodCapOn					0x00000800
+#define kAdslCfgDemodCapOff					0x00000000
+
+/* Flags 0x00001000 - 0x00008000 are reserved for modulation (see above) */
+
+/* Upstream mode flags 0x00010000 - 0x00030000 */
+
+#define kAdslCfgUpstreamModeMask			0x00030000
+#define kAdslCfgUpstreamMax					0x00000000
+#define kAdslCfgUpstreamSingle				0x00010000
+#define kAdslCfgUpstreamDouble				0x00020000
+#define kAdslCfgUpstreamTriple				0x00030000
+
+#define kAdslCfgNoSpectrumOverlap			0x00040000
+
+/* Pwm sync clock configuration */
+
+#define kAdslCfgPwmSyncClockMask			0x00080000
+#define kAdslCfgPwmSyncClockOn				0x00080000
+#define kAdslCfgPwmSyncClockOff				0x00000000
+
+#define kAdslCfgDefaultTrainingMargin		-1
+#define kAdslCfgDefaultShowtimeMargin		-1
+#define kAdslCfgDefaultLOMTimeThld			-1
+
+/* ADSL2 parameters */
+
+#define kAdsl2CfgReachExOn					0x00000001
+#define kAdsl2CfgAnnexMEnabled				0x00000002
+
+typedef struct _adslCfgProfile {
+	long		adslAnnexCParam;
+	long		adslAnnexAParam;
+	long		adslTrainingMarginQ4;
+	long		adslShowtimeMarginQ4;
+	long		adslLOMTimeThldSec;
+	long		adslDemodCapMask;
+	long		adslDemodCapValue;
+	long		adsl2Param;
+	long		adslPwmSyncClockFreq;
+} adslCfgProfile;
+
+/* 
+**
+**		ADSL PHY configuration
+**
+*/
+
+typedef struct _adslPhyCfg {
+	long		demodCapMask;
+	long		demodCap;
+} adslPhyCfg;
+
+/* 
+**
+**		ADSL version info parameters 
+**
+*/
+
+#define	kAdslVersionStringSize				32
+
+#define	kAdslTypeUnknown					0
+#define	kAdslTypeAnnexA						1
+#define	kAdslTypeAnnexB						2
+#define	kAdslTypeAnnexC						3
+#define	kAdslTypeSADSL						4
+
+typedef struct _adslVersionInfo {
+	unsigned short	phyType;
+	unsigned short	phyMjVerNum;
+	unsigned short	phyMnVerNum;
+	char			phyVerStr[kAdslVersionStringSize];
+	unsigned short	drvMjVerNum;
+	unsigned short	drvMnVerNum;
+	char			drvVerStr[kAdslVersionStringSize];
+} adslVersionInfo;
+
+/* 
+**
+**		ADSL self-test parameters 
+**
+*/
+
+#define kAdslSelfTestLMEM					0x00000001
+#define kAdslSelfTestSDRAM					0x00000002
+#define kAdslSelfTestAFE					0x00000004
+#define kAdslSelfTestQproc					0x00000008
+#define kAdslSelfTestRS						0x00000010
+#define kAdslSelfTestHostDma				0x00000020
+
+#define kAdslSelfTestAll					((kAdslSelfTestHostDma - 1) | kAdslSelfTestHostDma)
+
+#define kAdslSelfTestInProgress				0x40000000
+#define kAdslSelfTestCompleted				0x80000000
+
+/* MIB OID's for ADSL objects */
+
+#define kOidMaxObjLen						80
+
+#define kOidAdsl							94
+#define kOidAdslInterleave					124
+#define kOidAdslFast						125
+#define kOidAtm								37
+#define kOidAdslPrivate						255
+#define kOidAdslPrivatePartial				254
+
+#define kAdslMibAnnexAToneNum				256
+#define kAdslMibToneNum						kAdslMibAnnexAToneNum
+#define kAdslMibMaxToneNum					kAdslMibAnnexAToneNum*2*2
+
+#define kOidAdslPrivSNR						1
+#define kOidAdslPrivBitAlloc				2
+#define kOidAdslPrivGain					3
+#define kOidAdslPrivShowtimeMargin			4
+#define kOidAdslPrivChanCharLin				5
+#define kOidAdslPrivChanCharLog				6
+#define kOidAdslPrivQuietLineNoise			7
+#define kOidAdslPrivExtraInfo				255
+
+#define kOidAdslLine						1
+#define kOidAdslMibObjects					1
+
+#define kOidAdslLineTable					1
+#define kOidAdslLineEntry					1
+#define kOidAdslLineCoding					1
+#define kOidAdslLineType					2
+#define kOidAdslLineSpecific			    3
+#define kOidAdslLineConfProfile				4
+#define kOidAdslLineAlarmConfProfile		5
+
+#define kOidAdslAtucPhysTable				2
+#define kOidAdslAturPhysTable				3
+#define kOidAdslPhysEntry					1
+#define kOidAdslPhysInvSerialNumber     	1
+#define kOidAdslPhysInvVendorID             2
+#define kOidAdslPhysInvVersionNumber    	3
+#define kOidAdslPhysCurrSnrMgn          	4
+#define kOidAdslPhysCurrAtn             	5
+#define kOidAdslPhysCurrStatus          	6
+#define kOidAdslPhysCurrOutputPwr       	7
+#define kOidAdslPhysCurrAttainableRate  	8
+
+#define kOidAdslAtucChanTable				4
+#define kOidAdslAturChanTable				5
+#define kOidAdslChanEntry					1
+#define kOidAdslChanInterleaveDelay			1
+#define kOidAdslChanCurrTxRate				2
+#define kOidAdslChanPrevTxRate          	3
+#define kOidAdslChanCrcBlockLength      	4
+
+#define kOidAdslAtucPerfDataTable			6
+#define kOidAdslAturPerfDataTable			7
+#define kOidAdslPerfDataEntry				1
+#define kOidAdslPerfLofs                 	1
+#define kOidAdslPerfLoss                 	2
+#define kOidAdslPerfLprs                 	3
+#define kOidAdslPerfESs                  	4
+#define kOidAdslPerfValidIntervals          5
+#define kOidAdslPerfInvalidIntervals     	6
+#define kOidAdslPerfCurr15MinTimeElapsed 	7
+#define kOidAdslPerfCurr15MinLofs        	8
+#define kOidAdslPerfCurr15MinLoss        	9
+#define kOidAdslPerfCurr15MinLprs        	10
+#define kOidAdslPerfCurr15MinESs         	11
+#define kOidAdslPerfCurr1DayTimeElapsed     12
+#define kOidAdslPerfCurr1DayLofs         	13
+#define kOidAdslPerfCurr1DayLoss         	14
+#define kOidAdslPerfCurr1DayLprs         	15
+#define kOidAdslPerfCurr1DayESs          	16
+#define kOidAdslPerfPrev1DayMoniSecs     	17
+#define kOidAdslPerfPrev1DayLofs         	18
+#define kOidAdslPerfPrev1DayLoss            19
+#define kOidAdslPerfPrev1DayLprs         	20
+#define kOidAdslPerfPrev1DayESs          	21
+
+#define kOidAdslAtucPerfIntervalTable		8
+#define kOidAdslAturPerfIntervalTable		9
+#define kOidAdslPerfIntervalEntry			1
+#define kOidAdslIntervalNumber				1
+#define kOidAdslIntervalLofs				2
+#define kOidAdslIntervalLoss				3
+#define kOidAdslIntervalLprs				4
+#define kOidAdslIntervalESs					5
+#define kOidAdslIntervalValidData			6
+
+#define kOidAdslAtucChanPerfTable					10
+#define kOidAdslAturChanPerfTable					11
+#define kOidAdslChanPerfEntry						1
+#define kOidAdslChanReceivedBlks                 	1
+#define kOidAdslChanTransmittedBlks              	2
+#define kOidAdslChanCorrectedBlks                	3
+#define kOidAdslChanUncorrectBlks                	4
+#define kOidAdslChanPerfValidIntervals           	5
+#define kOidAdslChanPerfInvalidIntervals         	6
+#define kOidAdslChanPerfCurr15MinTimeElapsed     	7
+#define kOidAdslChanPerfCurr15MinReceivedBlks    	8
+#define kOidAdslChanPerfCurr15MinTransmittedBlks 	9
+#define kOidAdslChanPerfCurr15MinCorrectedBlks   	10
+#define kOidAdslChanPerfCurr15MinUncorrectBlks   	11
+#define kOidAdslChanPerfCurr1DayTimeElapsed      	12
+#define kOidAdslChanPerfCurr1DayReceivedBlks     	13
+#define kOidAdslChanPerfCurr1DayTransmittedBlks  	14
+#define kOidAdslChanPerfCurr1DayCorrectedBlks    	15
+#define kOidAdslChanPerfCurr1DayUncorrectBlks    	16
+#define kOidAdslChanPerfPrev1DayMoniSecs         	17
+#define kOidAdslChanPerfPrev1DayReceivedBlks     	18
+#define kOidAdslChanPerfPrev1DayTransmittedBlks  	19
+#define kOidAdslChanPerfPrev1DayCorrectedBlks    	20
+#define kOidAdslChanPerfPrev1DayUncorrectBlks    	21
+
+#define kOidAdslAtucChanIntervalTable				12
+#define kOidAdslAturChanIntervalTable				13
+#define kOidAdslChanIntervalEntry					1
+#define kOidAdslChanIntervalNumber					1
+#define kOidAdslChanIntervalReceivedBlks        	2
+#define kOidAdslChanIntervalTransmittedBlks     	3
+#define kOidAdslChanIntervalCorrectedBlks       	4
+#define kOidAdslChanIntervalUncorrectBlks       	5
+#define kOidAdslChanIntervalValidData           	6
+
+#define kOidAtmMibObjects		1
+#define kOidAtmTcTable			4
+#define kOidAtmTcEntry			1
+#define kOidAtmOcdEvents		1
+#define kOidAtmAlarmState		2
+
+/* Adsl Channel coding */
+
+#define	kAdslRcvDir			0
+#define	kAdslXmtDir			1
+
+#define	kAdslRcvActive		(1 << kAdslRcvDir)
+#define	kAdslXmtActive		(1 << kAdslXmtDir)
+
+#define	kAdslIntlChannel	0
+#define	kAdslFastChannel	1
+
+#define	kAdslTrellisOff		0
+#define	kAdslTrellisOn		1
+
+/* AnnexC modulation and bitmap types for the field (adslConnection.modType) */
+
+#define kAdslModMask		0x7
+
+#define	kAdslModGdmt		0
+#define	kAdslModT1413		1
+#define	kAdslModGlite		2
+#define kAdslModAnnexI		3
+#define kAdslModAdsl2		4
+#define kAdslModAdsl2p		5
+#define kAdslModReAdsl2		6
+
+#define kAdslBitmapShift	3
+#define kAdslBitmapMask		kAdslCfgBitmapMask
+#define kAdslDBM		    (0 << kAdslBitmapShift)
+#define kAdslFBM		    (1 << kAdslBitmapShift)
+#define kAdslFBMSoL			(2 << kAdslBitmapShift)
+
+#define kAdslUpstreamModeShift		5
+#define kAdslUpstreamModeMask		(3 << kAdslUpstreamModeShift)
+#define kAdslUpstreamModeSingle		(0 << kAdslUpstreamModeShift)
+#define kAdslUpstreamModeDouble		(1 << kAdslUpstreamModeShift)
+#define kAdslUpstreamModeTriple		(2 << kAdslUpstreamModeShift)
+
+/* AdslLineCodingType definitions */
+
+#define kAdslLineCodingOther		1
+#define kAdslLineCodingDMT			2
+#define kAdslLineCodingCAP			3
+#define kAdslLineCodingQAM			4
+
+/* AdslLineType definitions */
+
+#define kAdslLineTypeNoChannel		1
+#define kAdslLineTypeFastOnly		2
+#define kAdslLineTypeIntlOnly		3
+#define kAdslLineTypeFastOrIntl		4
+#define kAdslLineTypeFastAndIntl	5
+
+typedef struct _adslLineEntry {
+	unsigned char	adslLineCoding;
+	unsigned char	adslLineType;
+} adslLineEntry;
+
+
+/* AdslPhys status definitions */
+
+#define kAdslPhysStatusNoDefect		(1 << 0)
+#define kAdslPhysStatusLOF			(1 << 1)	/* lossOfFraming (not receiving valid frame) */
+#define kAdslPhysStatusLOS			(1 << 2)	/* lossOfSignal (not receiving signal) */
+#define kAdslPhysStatusLPR			(1 << 3)	/* lossOfPower */
+#define kAdslPhysStatusLOSQ			(1 << 4)	/* lossOfSignalQuality */
+#define kAdslPhysStatusLOM			(1 << 5)	/* lossOfMargin */
+
+typedef struct _adslPhysEntry {
+	long		adslCurrSnrMgn;
+	long		adslCurrAtn;
+	long		adslCurrStatus;
+	long		adslCurrOutputPwr;
+	long		adslCurrAttainableRate;
+} adslPhysEntry;
+
+#define kAdslPhysVendorIdLen		8
+#define kAdslPhysSerialNumLen		32
+#define kAdslPhysVersionNumLen		32
+
+typedef struct _adslFullPhysEntry {
+	char		adslSerialNumber[kAdslPhysSerialNumLen];
+	char		adslVendorID[kAdslPhysVendorIdLen];
+	char		adslVersionNumber[kAdslPhysVersionNumLen];
+	long		adslCurrSnrMgn;
+	long		adslCurrAtn;
+	long		adslCurrStatus;
+	long		adslCurrOutputPwr;
+	long		adslCurrAttainableRate;
+} adslFullPhysEntry;
+
+/* Adsl channel entry definitions */
+
+typedef struct _adslChanEntry {
+    unsigned long		adslChanIntlDelay;
+	unsigned long		adslChanCurrTxRate;
+	unsigned long		adslChanPrevTxRate;
+	unsigned long		adslChanCrcBlockLength;
+} adslChanEntry;
+
+/* Adsl performance data definitions */
+
+typedef struct _adslPerfCounters {
+	unsigned long		adslLofs;
+	unsigned long		adslLoss;
+	unsigned long		adslLols;	/* Loss of Link failures (ATUC only) */
+	unsigned long		adslLprs;
+	unsigned long		adslESs;	/* Count of Errored Seconds */
+	unsigned long		adslInits;	/* Count of Line initialization attempts (ATUC only) */
+	unsigned long		adslUAS;	/* Count of Unavailable Seconds */
+	unsigned long		adslSES;	/* Count of Severely Errored Seconds */
+	unsigned long		adslLOSS;	/* Count of LOS seconds */
+	unsigned long		adslFECs;	/* Count of FEC seconds  */
+} adslPerfCounters;
+
+typedef struct _adslPerfDataEntry {
+	adslPerfCounters	perfTotal;
+	unsigned long				adslPerfValidIntervals;
+	unsigned long				adslPerfInvalidIntervals;
+	adslPerfCounters	perfCurr15Min;
+	unsigned long				adslPerfCurr15MinTimeElapsed;
+	adslPerfCounters	perfCurr1Day;
+	unsigned long				adslPerfCurr1DayTimeElapsed;
+	adslPerfCounters	perfPrev1Day;
+	unsigned long				adslAturPerfPrev1DayMoniSecs;
+} adslPerfDataEntry;
+
+#define kAdslMibPerfIntervals		4
+
+/* Adsl channel performance data definitions */
+
+typedef struct _adslChanCounters {
+	unsigned long		adslChanReceivedBlks;
+	unsigned long		adslChanTransmittedBlks;
+	unsigned long		adslChanCorrectedBlks;
+	unsigned long		adslChanUncorrectBlks;
+} adslChanCounters;
+
+typedef struct _adslChanPerfDataEntry {
+	adslChanCounters	perfTotal;
+	unsigned long				adslChanPerfValidIntervals;
+	unsigned long				adslChanPerfInvalidIntervals;
+	adslChanCounters	perfCurr15Min;
+	unsigned long				adslPerfCurr15MinTimeElapsed;
+	adslChanCounters	perfCurr1Day;
+	unsigned long				adslPerfCurr1DayTimeElapsed;
+	adslChanCounters	perfPrev1Day;
+	unsigned long				adslAturPerfPrev1DayMoniSecs;
+} adslChanPerfDataEntry;
+
+#define kAdslMibChanPerfIntervals	4
+
+/* Adsl trap threshold definitions */
+
+#define	kAdslEventLinkChange		0x001
+#define	kAdslEventRateChange		0x002
+#define	kAdslEventLofThresh			0x004
+#define	kAdslEventLosThresh			0x008
+#define	kAdslEventLprThresh			0x010
+#define	kAdslEventESThresh			0x020
+#define	kAdslEventFastUpThresh		0x040
+#define	kAdslEventIntlUpThresh		0x080
+#define	kAdslEventFastDownThresh	0x100
+#define	kAdslEventIntlDwonThresh	0x200
+
+typedef struct _adslThreshCounters {
+	unsigned long		adslThreshLofs;
+	unsigned long		adslThreshLoss;
+	unsigned long		adslThreshLols;	/* Loss of Link failures (ATUC only) */
+	unsigned long		adslThreshLprs;
+	unsigned long		adslThreshESs;
+	unsigned long		adslThreshFastRateUp;
+	unsigned long		adslThreshIntlRateUp;
+	unsigned long		adslThreshFastRateDown;
+	unsigned long		adslThreshIntlRateDown;
+} adslThreshCounters;
+
+
+/* Atm PHY performance data definitions */
+
+#define	kAtmPhyStateNoAlarm			1
+#define	kAtmPhyStateLcdFailure		2
+
+typedef struct _atmPhyDataEntrty {
+	unsigned long		atmInterfaceOCDEvents;
+	unsigned long		atmInterfaceTCAlarmState;
+} atmPhyDataEntrty;
+
+typedef struct _adslBertResults {
+	unsigned long		bertTotalBits;
+	unsigned long		bertErrBits;
+} adslBertResults;
+
+typedef struct {
+	unsigned long		cntHi;
+	unsigned long		cntLo;
+} cnt64;
+
+typedef struct _adslBertStatusEx {
+	unsigned long		bertSecTotal;
+	unsigned long		bertSecElapsed;
+	unsigned long		bertSecCur;
+	cnt64				bertTotalBits;
+	cnt64				bertErrBits;
+} adslBertStatusEx;
+
+typedef struct _adslDataConnectionInfo {
+	unsigned short		K;
+	unsigned char		S, R, D;
+} adslDataConnectionInfo;
+
+typedef struct _adslConnectionInfo {
+	unsigned char			chType;				/* fast or interleaved */
+	unsigned char			modType;			/* modulation type: G.DMT or T1.413 */
+	unsigned char			trellisCoding;		/* off(0) or on(1) */
+	adslDataConnectionInfo	rcvInfo;
+	adslDataConnectionInfo	xmtInfo;
+} adslConnectionInfo;
+
+typedef struct _adsl2DataConnectionInfo {
+	unsigned char		Nlp;
+	unsigned char		Nbc;
+	unsigned char		MSGlp;
+	unsigned short		MSGc;
+
+	unsigned long		L;
+	unsigned short		M;
+	unsigned short		T;
+	unsigned short		D;
+	unsigned short		R;
+	unsigned short		B;
+} adsl2DataConnectionInfo;
+
+typedef struct _adsl2ConnectionInfo {
+	long					adsl2Mode;
+	long					rcvRate;
+	long					xmtRate;
+	unsigned char			pwrState;			/* Lx state: x = 0..3 */
+	adsl2DataConnectionInfo	rcv2Info;
+	adsl2DataConnectionInfo	xmt2Info;
+} adsl2ConnectionInfo;
+
+typedef struct _adslConnectionDataStat {
+	unsigned long			cntRS;	
+	unsigned long			cntRSCor;	
+	unsigned long			cntRSUncor;	
+	unsigned long			cntSF;	
+	unsigned long			cntSFErr;	
+} adslConnectionDataStat;
+
+typedef struct _adslConnectionStat {
+	adslConnectionDataStat	rcvStat;
+	adslConnectionDataStat	xmtStat;
+} adslConnectionStat;
+
+typedef struct _atmConnectionDataStat {
+	unsigned long			cntHEC;
+	unsigned long			cntOCD;
+	unsigned long			cntLCD;
+	unsigned long			cntES;
+	unsigned long			cntCellTotal;
+	unsigned long			cntCellData;
+	unsigned long			cntCellDrop;
+	unsigned long			cntBitErrs;
+} atmConnectionDataStat;
+
+typedef struct _atmConnectionStat {
+	atmConnectionDataStat	rcvStat;
+	atmConnectionDataStat	xmtStat;
+} atmConnectionStat;
+
+#define	kAdslFramingModeMask			0x0F
+#define	kAtmFramingModeMask				0xF0
+#define	kAtmHeaderCompression			0x80
+
+/* ADSL2 data */
+
+typedef struct _adslDiagModeData {
+	long					loopAttn;
+	long					signalAttn;
+	long					snrMargin;
+	long					attnDataRate;
+	long					actXmtPower;
+	long					hlinScaleFactor;
+} adslDiagModeData;
+
+/* AdslMibGetObjectValue return codes */
+
+#define	kAdslMibStatusSuccess			0
+#define	kAdslMibStatusFailure			-1
+#define	kAdslMibStatusNoObject			-2
+#define	kAdslMibStatusObjectInvalid		-3
+#define	kAdslMibStatusBufferTooSmall	-4
+#define	kAdslMibStatusLastError			-4
+
+/* Adsl training codes */
+
+#define	kAdslTrainingIdle				0
+#define	kAdslTrainingG994				1
+#define	kAdslTrainingG992Started		2
+#define	kAdslTrainingG992ChanAnalysis	3
+#define	kAdslTrainingG992Exchange		4
+#define	kAdslTrainingConnected			5
+
+/* Global info structure */
+
+typedef struct _adslMibInfo {
+	adslLineEntry			adslLine;
+	adslPhysEntry			adslPhys;
+	adslChanEntry			adslChanIntl;
+	adslChanEntry			adslChanFast;
+	adslPerfDataEntry		adslPerfData;
+	adslPerfCounters		adslPerfIntervals[kAdslMibPerfIntervals];
+	adslChanPerfDataEntry	adslChanIntlPerfData;
+	adslChanPerfDataEntry	adslChanFastPerfData;
+	adslChanCounters		adslChanIntlPerfIntervals[kAdslMibChanPerfIntervals];
+	adslChanCounters		adslChanFastPerfIntervals[kAdslMibChanPerfIntervals];
+
+	adslThreshCounters		adslAlarm;
+
+	atmPhyDataEntrty		adslChanIntlAtmPhyData;
+	atmPhyDataEntrty		adslChanFastAtmPhyData;
+
+	adslBertResults			adslBertRes;
+
+	adslConnectionInfo		adslConnection;
+	adslConnectionStat		adslStat;
+	unsigned char			adslTrainingState;
+	atmConnectionStat		atmStat;
+
+	adslFullPhysEntry		adslAtucPhys;
+	unsigned char			adslRxNonStdFramingAdjustK;
+	unsigned char			adslFramingMode;
+	adslBertStatusEx		adslBertStatus;
+	long					afeRxPgaGainQ1;
+
+	adslDiagModeData		adslDiag;
+	adsl2ConnectionInfo		adsl2Info;
+	adslPerfCounters		adslTxPerfTotal;
+} adslMibInfo;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	/* AdslMibDefHeader */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/DiagDef.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/DiagDef.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/DiagDef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/DiagDef.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,209 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+
+/*******************************************************************
+ * DiagDef.h
+ *
+ *	Description:
+ *		Diag definitions
+ *
+ * $Revision: 1.22 $
+ *
+ * $Id: DiagDef.h,v 1.22 2004/10/16 23:43:19 ilyas Exp $
+ *
+ * $Log: DiagDef.h,v $
+ * Revision 1.22  2004/10/16 23:43:19  ilyas
+ * Added playback resume command
+ *
+ * Revision 1.21  2004/10/16 23:24:08  ilyas
+ * Improved FileRead command support for LOG file playback (RecordTest on the board)
+ *
+ * Revision 1.20  2004/04/28 16:52:32  ilyas
+ * Added GDB frame processing
+ *
+ * Revision 1.19  2004/03/10 22:26:53  ilyas
+ * Added command-line parameter for IP port number.
+ * Added proxy remote termination
+ *
+ * Revision 1.18  2004/01/24 23:41:37  ilyas
+ * Added DIAG_DEBUG_CMD_LOG_SAMPLES debug command
+ *
+ * Revision 1.17  2003/11/19 02:25:45  ilyas
+ * Added definitions for LOG frame retransmission, time, ADSL2 plots
+ *
+ * Revision 1.16  2003/11/14 18:46:05  ilyas
+ * Added G992p3 debug commands
+ *
+ * Revision 1.15  2003/10/02 19:50:41  ilyas
+ * Added support for buffering data for AnnexI and statistical counters
+ *
+ * Revision 1.14  2003/09/03 19:45:11  ilyas
+ * To refuse connection with older protocol versions
+ *
+ * Revision 1.13  2003/08/30 00:12:39  ilyas
+ * Added support for running chip test regressions via DslDiags
+ *
+ * Revision 1.12  2003/08/12 00:19:28  ilyas
+ * Improved image downloading protocol.
+ * Added DEBUG command support
+ *
+ * Revision 1.11  2003/04/11 00:37:24  ilyas
+ * Added DiagProtoFrame definition
+ *
+ * Revision 1.10  2003/03/25 00:10:07  ilyas
+ * Added command for "long" BERT test
+ *
+ * Revision 1.9  2003/01/30 03:29:32  ilyas
+ * Added PHY_CFG support and fixed printing showtime counters
+ *
+ * Revision 1.8  2002/12/16 20:56:38  ilyas
+ * Added support for binary statuses
+ *
+ * Revision 1.7  2002/12/06 20:19:13  ilyas
+ * Added support for binary statuses and scrambled status strings
+ *
+ * Revision 1.6  2002/11/05 00:18:27  ilyas
+ * Added configuration dialog box for Eye tone selection.
+ * Added Centillium CRC workaround to AnnexC config dialog
+ * Bit allocation update on bit swap messages
+ *
+ * Revision 1.5  2002/07/30 23:23:43  ilyas
+ * Implemented DIAG configuration command for AnnexA and AnnexC
+ *
+ * Revision 1.4  2002/07/30 22:47:15  ilyas
+ * Added DIAG command for configuration
+ *
+ * Revision 1.3  2002/07/15 23:52:51  ilyas
+ * iAdded switch RJ11 pair command
+ *
+ * Revision 1.2  2002/04/25 17:55:51  ilyas
+ * Added mibGet command
+ *
+ * Revision 1.1  2002/04/02 22:56:39  ilyas
+ * Support DIAG connection at any time; BERT commands
+ *
+ *
+ ******************************************************************/
+
+#define	LOG_PROTO_ID				"*L"
+
+#define	DIAG_PARTY_ID_MASK			0x01
+#define	LOG_PARTY_CLIENT			0x01
+#define	LOG_PARTY_SERVER			0x00
+
+#define	DIAG_DATA_MASK				0x0E
+#define	DIAG_DATA_LOG				0x02
+#define	DIAG_DATA_EYE				0x04
+#define	DIAG_DATA_LOG_TIME			0x08
+
+#define	DIAG_DATA_EX				0x80
+#define	DIAG_PARTY_ID_MASK_EX		(DIAG_DATA_EX | DIAG_PARTY_ID_MASK)
+#define	LOG_PARTY_SERVER_EX			(DIAG_DATA_EX | LOG_PARTY_SERVER)
+
+#define	DIAG_ACK_FRAME_ACK_MASK		0x000000FF
+#define	DIAG_ACK_FRAME_RCV_SHIFT	8
+#define	DIAG_ACK_FRAME_RCV_MASK		0x0000FF00
+#define	DIAG_ACK_FRAME_RCV_PRESENT	0x00010000
+#define	DIAG_ACK_TIMEOUT			-1
+#define	DIAG_ACK_LEN_INDICATION		-1
+
+#define	LOG_CMD_GDB					236
+#define	LOG_CMD_PROXY				237
+#define	LOG_CMD_RETR				238
+#define	LOG_CMD_DEBUG				239
+#define	LOG_CMD_BERT_EX				240
+#define	LOG_CMD_CFG_PHY				241
+#define	LOG_CMD_RESET				242
+#define	LOG_CMD_SCRAMBLED_STRING	243
+#define	LOG_CMD_EYE_CFG				244
+#define	LOG_CMD_CONFIG_A			245
+#define	LOG_CMD_CONFIG_C			246
+#define	LOG_CMD_SWITCH_RJ11_PAIR	247
+#define	LOG_CMD_MIB_GET				248
+#define	LOG_CMD_LOG_STOP			249
+#define	LOG_CMD_PING_REQ			250
+#define	LOG_CMD_PING_RSP			251
+#define	LOG_CMD_DISCONNECT			252
+#define	LOG_CMD_STRING_DATA			253
+#define	LOG_CMD_TEST_DATA			254
+#define	LOG_CMD_CONNECT				255
+
+typedef struct _LogProtoHeader {
+	unsigned char	logProtoId[2];
+	unsigned char	logPartyId;
+	unsigned char	logCommmand;
+} LogProtoHeader;
+
+#define	LOG_FILE_PORT			5100
+#define	LOG_MAX_BUF_SIZE		1400
+#define	LOG_MAX_DATA_SIZE		(LOG_MAX_BUF_SIZE - sizeof(LogProtoHeader))
+
+typedef struct {
+	LogProtoHeader	diagHdr;
+	unsigned char	diagData[LOG_MAX_DATA_SIZE];
+} DiagProtoFrame;
+
+#define	DIAG_PROXY_TERMINATE				1
+
+#define	DIAG_DEBUG_CMD_READ_MEM				1
+#define	DIAG_DEBUG_CMD_SET_MEM				2
+#define	DIAG_DEBUG_CMD_RESET_CONNECTION		3
+#define	DIAG_DEBUG_CMD_RESET_PHY			4
+#define	DIAG_DEBUG_CMD_RESET_CHIP			5
+#define	DIAG_DEBUG_CMD_EXEC_FUNC			6
+#define	DIAG_DEBUG_CMD_EXEC_ADSL_FUNC		7
+#define	DIAG_DEBUG_CMD_WRITE_FILE			8
+#define	DIAG_DEBUG_CMD_G992P3_DEBUG			9
+#define	DIAG_DEBUG_CMD_G992P3_DIAG_MODE		10
+#define	DIAG_DEBUG_CMD_CLEAR_TIME			11
+#define	DIAG_DEBUG_CMD_PRINT_TIME			12
+#define	DIAG_DEBUG_CMD_LOG_SAMPLES			13
+
+#define	DIAG_DEBUG_CMD_PLAYBACK_STOP		14
+#define	DIAG_DEBUG_CMD_PLAYBACK_RESUME		15
+
+#define	DIAG_DEBUG_CMD_PRINT_STAT			21
+#define	DIAG_DEBUG_CMD_CLEAR_STAT			22
+
+typedef struct {
+	unsigned short	cmd;
+	unsigned short	cmdId;
+	unsigned long	param1;
+	unsigned long	param2;
+	unsigned char	diagData[1];
+} DiagDebugData;
+
+#define	DIAG_TEST_CMD_LOAD					101
+#define	DIAG_TEST_CMD_READ					102
+#define	DIAG_TEST_CMD_WRITE					103
+#define	DIAG_TEST_CMD_APPEND				104
+#define	DIAG_TEST_CMD_TEST_COMPLETE			105
+
+#define	DIAG_TEST_FILENAME_LEN				64
+
+typedef struct {
+	unsigned short	cmd;
+	unsigned short	cmdId;
+	unsigned long	offset;
+	unsigned long	len;
+	unsigned long	bufPtr;
+	char			fileName[DIAG_TEST_FILENAME_LEN];
+} DiagTestData;
+
+typedef struct {
+	unsigned long	frStart;
+	unsigned long	frNum;
+} DiagLogRetrData;
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/adsldrv.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/adsldrv.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/adsldrv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/adsldrv.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,203 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***************************************************************************
+ * File Name  : AdslDrv.h
+ *
+ * Description: This file contains the definitions and structures for the
+ *              Linux IOCTL interface that used between the user mode ADSL
+ *              API library and the kernel ADSL API driver.
+ *
+ * Updates    : 11/02/2001  lkaplan.  Created.
+ ***************************************************************************/
+
+#if !defined(_ADSLDRV_H_)
+#define _ADSLDRV_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* Incldes. */
+#include <bcmadsl.h>
+
+/* Defines. */
+#define DSL_IFNAME               "dsl0"
+#define ADSLDRV_MAJOR            208 /* arbitrary unused value */
+
+#define ADSLIOCTL_CHECK \
+    _IOR(ADSLDRV_MAJOR, 0, ADSLDRV_STATUS_ONLY)
+#define ADSLIOCTL_INITIALIZE \
+    _IOWR(ADSLDRV_MAJOR, 1, ADSLDRV_INITIALIZE)
+#define ADSLIOCTL_UNINITIALIZE \
+    _IOR(ADSLDRV_MAJOR, 2, ADSLDRV_STATUS_ONLY)
+#define ADSLIOCTL_CONNECTION_START \
+    _IOWR(ADSLDRV_MAJOR, 3, ADSLDRV_STATUS_ONLY)
+#define ADSLIOCTL_CONNECTION_STOP \
+    _IOR(ADSLDRV_MAJOR, 4, ADSLDRV_STATUS_ONLY)
+#define ADSLIOCTL_GET_PHY_ADDR \
+    _IOR(ADSLDRV_MAJOR, 5, ADSLDRV_PHY_ADDR)
+#define ADSLIOCTL_SET_PHY_ADDR \
+    _IOWR(ADSLDRV_MAJOR, 6, ADSLDRV_PHY_ADDR)
+#define ADSLIOCTL_MAP_ATM_PORT_IDS \
+    _IOWR(ADSLDRV_MAJOR, 7, ADSLDRV_MAP_ATM_PORT)
+#define ADSLIOCTL_GET_CONNECTION_INFO \
+    _IOR(ADSLDRV_MAJOR, 8, ADSLDRV_CONNECTION_INFO)
+#define ADSLIOCTL_DIAG_COMMAND \
+    _IOR(ADSLDRV_MAJOR, 9, ADSLDRV_DIAG)
+#define ADSLIOCTL_GET_OBJ_VALUE \
+    _IOR(ADSLDRV_MAJOR, 10, ADSLDRV_GET_OBJ)
+#define ADSLIOCTL_START_BERT \
+    _IOR(ADSLDRV_MAJOR, 11, ADSLDRV_BERT)
+#define ADSLIOCTL_STOP_BERT \
+    _IOR(ADSLDRV_MAJOR, 12, ADSLDRV_STATUS_ONLY)
+#define ADSLIOCTL_CONFIGURE \
+    _IOR(ADSLDRV_MAJOR, 13, ADSLDRV_CONFIGURE)
+#define ADSLIOCTL_TEST \
+    _IOR(ADSLDRV_MAJOR, 14, ADSLDRV_TEST)
+#define ADSLIOCTL_GET_CONSTEL_POINTS \
+    _IOR(ADSLDRV_MAJOR, 15, ADSLDRV_GET_CONSTEL_POINTS)
+#define ADSLIOCTL_GET_VERSION \
+    _IOR(ADSLDRV_MAJOR, 16, ADSLDRV_GET_VERSION)
+#define ADSLIOCTL_SET_SDRAM_BASE \
+    _IOR(ADSLDRV_MAJOR, 17, ADSLDRV_SET_SDRAM_BASE)
+#define ADSLIOCTL_RESET_STAT_COUNTERS \
+    _IOR(ADSLDRV_MAJOR, 18, ADSLDRV_STATUS_ONLY)
+#define ADSLIOCTL_SET_OEM_PARAM \
+    _IOR(ADSLDRV_MAJOR, 19, ADSLDRV_SET_OEM_PARAM)
+#define ADSLIOCTL_START_BERT_EX \
+    _IOR(ADSLDRV_MAJOR, 20, ADSLDRV_BERT_EX)
+#define ADSLIOCTL_STOP_BERT_EX \
+    _IOR(ADSLDRV_MAJOR, 21, ADSLDRV_STATUS_ONLY)
+
+#define MAX_ADSLDRV_IOCTL_COMMANDS   22
+
+/* Typedefs. */
+typedef struct
+{
+    BCMADSL_STATUS bvStatus;
+} ADSLDRV_STATUS_ONLY, *PADSLDRV_STATUS_ONLY;
+
+typedef struct
+{
+    ADSL_FN_NOTIFY_CB	pFnNotifyCb;
+    UINT32				ulParm;
+	adslCfgProfile		*pAdslCfg;
+    BCMADSL_STATUS		bvStatus;
+} ADSLDRV_INITIALIZE, *PADSLDRV_INITIALIZE;
+
+typedef struct
+{
+    ADSL_CHANNEL_ADDR ChannelAddr;
+    BCMADSL_STATUS bvStatus;
+} ADSLDRV_PHY_ADDR, *PADSLDRV_PHY_ADDR;
+
+typedef struct
+{
+	UINT16 usAtmFastPortId;
+	UINT16 usAtmInterleavedPortId;
+    BCMADSL_STATUS bvStatus;
+} ADSLDRV_MAP_ATM_PORT, *PADSLDRV_MAP_ATM_PORT;
+
+typedef struct
+{
+    ADSL_CONNECTION_INFO ConnectionInfo;
+    BCMADSL_STATUS bvStatus;
+} ADSLDRV_CONNECTION_INFO, *PADSLDRV_CONNECTION_INFO;
+
+typedef struct
+{
+    int				diagCmd;
+    int				diagMap;
+    int				logTime;
+	int				srvIpAddr;
+	int				gwIpAddr;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_DIAG, *PADSLDRV_DIAG;
+
+typedef struct
+{
+	char			*objId;
+	int				objIdLen;
+	char			*dataBuf;
+	long			dataBufLen;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_GET_OBJ, *PADSLDRV_GET_OBJ;
+
+typedef struct
+{
+	unsigned long	totalBits;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_BERT, *PADSLDRV_BERT;
+
+typedef struct
+{
+	unsigned long	totalSec;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_BERT_EX, *PADSLDRV_BERT_EX;
+
+typedef struct
+{
+	adslCfgProfile		*pAdslCfg;
+    BCMADSL_STATUS		bvStatus;
+} ADSLDRV_CONFIGURE, *PADSLDRV_CONFIGURE;
+
+typedef struct
+{
+	unsigned long	testCmd;
+	unsigned long	xmtStartTone;
+	unsigned long	xmtNumTones;
+	unsigned long	rcvStartTone;
+	unsigned long	rcvNumTones;
+    char			*xmtToneMap;
+    char			*rcvToneMap;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_TEST, *PADSLDRV_TEST;
+
+typedef struct
+{
+	int				toneId;
+	ADSL_CONSTELLATION_POINT	*pointBuf;
+	int				numPoints;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_GET_CONSTEL_POINTS, *PADSLDRV_GET_CONSTEL_POINTS;
+
+typedef struct
+{
+	adslVersionInfo		*pAdslVer;
+    BCMADSL_STATUS		bvStatus;
+} ADSLDRV_GET_VERSION, *PADSLDRV_GET_VERSION;
+
+typedef struct
+{
+	unsigned long	sdramBaseAddr;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_SET_SDRAM_BASE, *PADSLDRV_SET_SDRAM_BASE;
+
+
+typedef struct
+{
+	int				paramId;
+	void			*buf;
+	int				len;
+    BCMADSL_STATUS	bvStatus;
+} ADSLDRV_SET_OEM_PARAM, *PADSLDRV_SET_OEM_PARAM;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // _ADSLDRV_H_
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/atmapidrv.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/atmapidrv.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/atmapidrv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/atmapidrv.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,212 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+/***************************************************************************
+ * File Name  : AtmApiDrv.h
+ *
+ * Description: This file contains the definitions and structures for the
+ *              Linux IOCTL interface that used between the user mode ATM
+ *              API library and the kernel ATM API driver.
+ *
+ * Updates    : 09/15/2000  lat.  Created.
+ ***************************************************************************/
+
+#if !defined(_ATMAPIDRV_H_)
+#define _ATMAPIDRV_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* Incldes. */
+#include <bcmatmapi.h>
+
+/* Defines. */
+#define ATMDRV_MAJOR            205 /* arbitrary unused value */
+
+#define ATMIOCTL_INITIALIZE \
+    _IOWR(ATMDRV_MAJOR, 0, ATMDRV_INITIALIZE)
+#define ATMIOCTL_UNINITIALIZE \
+    _IOR(ATMDRV_MAJOR, 1, ATMDRV_STATUS_ONLY)
+#define ATMIOCTL_GET_INTERFACE_ID \
+    _IOWR(ATMDRV_MAJOR, 2, ATMDRV_INTERFACE_ID)
+#define ATMIOCTL_GET_TRAFFIC_DESCR_TABLE_SIZE \
+    _IOR(ATMDRV_MAJOR, 3, ATMDRV_TRAFFIC_DESCR_TABLE_SIZE)
+#define ATMIOCTL_GET_TRAFFIC_DESCR_TABLE \
+    _IOWR(ATMDRV_MAJOR, 4, ATMDRV_TRAFFIC_DESCR_TABLE)
+#define ATMIOCTL_SET_TRAFFIC_DESCR_TABLE \
+    _IOWR(ATMDRV_MAJOR, 5, ATMDRV_TRAFFIC_DESCR_TABLE)
+#define ATMIOCTL_GET_INTERFACE_CFG \
+    _IOWR(ATMDRV_MAJOR, 6, ATMDRV_INTERFACE_CFG)
+#define ATMIOCTL_SET_INTERFACE_CFG \
+    _IOWR(ATMDRV_MAJOR, 7, ATMDRV_INTERFACE_CFG)
+#define ATMIOCTL_GET_VCC_CFG \
+    _IOWR(ATMDRV_MAJOR, 8, ATMDRV_VCC_CFG)
+#define ATMIOCTL_SET_VCC_CFG \
+    _IOWR(ATMDRV_MAJOR, 9, ATMDRV_VCC_CFG)
+#define ATMIOCTL_GET_VCC_ADDRS \
+    _IOWR(ATMDRV_MAJOR, 10, ATMDRV_VCC_ADDRS)
+#define ATMIOCTL_GET_INTERFACE_STATISTICS \
+    _IOWR(ATMDRV_MAJOR, 11, ATMDRV_INTERFACE_STATISTICS)
+#define ATMIOCTL_GET_VCC_STATISTICS \
+    _IOWR(ATMDRV_MAJOR, 12, ATMDRV_VCC_STATISTICS)
+#define ATMIOCTL_SET_INTERFACE_LINK_INFO \
+    _IOWR(ATMDRV_MAJOR, 13, ATMDRV_INTERFACE_LINK_INFO)
+#define ATMIOCTL_TEST \
+    _IOWR(ATMDRV_MAJOR, 14, ATMDRV_TEST)
+#define ATMIOCTL_OAM_LOOPBACK_TEST \
+    _IOWR(ATMDRV_MAJOR, 15, ATMDRV_OAM_LOOPBACK)
+
+
+#define MAX_ATMDRV_IOCTL_COMMANDS   16
+
+/* Typedefs. */
+typedef struct
+{
+    BCMATM_STATUS baStatus;
+} ATMDRV_STATUS_ONLY, *PATMDRV_STATUS_ONLY;
+
+typedef struct
+{   PATM_INITIALIZATION_PARMS pInit;
+    BCMATM_STATUS baStatus;
+} ATMDRV_INITIALIZE, *PATMDRV_INITIALIZE;
+
+typedef struct
+{
+    UINT8 ucPhyPort;
+    UINT8 ucReserved[3];
+    UINT32 ulInterfaceId;
+    BCMATM_STATUS baStatus;
+} ATMDRV_INTERFACE_ID, *PATMDRV_INTERFACE_ID;
+
+typedef struct
+{
+    UINT32 ulTrafficDescrTableSize;
+    BCMATM_STATUS baStatus;
+} ATMDRV_TRAFFIC_DESCR_TABLE_SIZE, *PATMDRV_TRAFFIC_DESCR_TABLE_SIZE;
+
+typedef struct
+{
+    PATM_TRAFFIC_DESCR_PARM_ENTRY pTrafficDescrTable;
+    UINT32 ulTrafficDescrTableSize;
+    BCMATM_STATUS baStatus;
+} ATMDRV_TRAFFIC_DESCR_TABLE, *PATMDRV_TRAFFIC_DESCR_TABLE;
+
+typedef struct
+{
+    UINT32 ulInterfaceId;
+    PATM_INTERFACE_CFG pInterfaceCfg;
+    BCMATM_STATUS baStatus;
+} ATMDRV_INTERFACE_CFG, *PATMDRV_INTERFACE_CFG;
+
+typedef struct
+{
+    ATM_VCC_ADDR VccAddr;
+    PATM_VCC_CFG pVccCfg;
+    BCMATM_STATUS baStatus;
+} ATMDRV_VCC_CFG, *PATMDRV_VCC_CFG;
+
+typedef struct
+{
+    UINT32 ulInterfaceId;
+    PATM_VCC_ADDR pVccAddrs;
+    UINT32 ulNumVccs;
+    UINT32 ulNumReturned;
+    BCMATM_STATUS baStatus;
+} ATMDRV_VCC_ADDRS, *PATMDRV_VCC_ADDRS;
+
+typedef struct
+{
+    UINT32 ulInterfaceId;
+    PATM_INTERFACE_STATS pStatistics;
+    UINT32 ulReset;
+    BCMATM_STATUS baStatus;
+} ATMDRV_INTERFACE_STATISTICS, *PATMDRV_INTERFACE_STATISTICS;
+
+typedef struct
+{
+    ATM_VCC_ADDR VccAddr;
+    PATM_VCC_STATS pVccStatistics;
+    UINT32 ulReset;
+    BCMATM_STATUS baStatus;
+} ATMDRV_VCC_STATISTICS, *PATMDRV_VCC_STATISTICS;
+
+typedef struct
+{
+    UINT32 ulInterfaceId;
+    ATM_INTERFACE_LINK_INFO InterfaceCfg;
+    BCMATM_STATUS baStatus;
+} ATMDRV_INTERFACE_LINK_INFO, *PATMDRV_INTERFACE_LINK_INFO;
+
+typedef struct
+{
+    ATM_VCC_ADDR VccAddr;
+    UINT32 ulNumToSend;
+    BCMATM_STATUS baStatus;
+} ATMDRV_TEST, *PATMDRV_TEST;
+
+typedef struct
+{
+    ATM_VCC_ADDR VccAddr;
+    UINT32 type;
+    BCMATM_STATUS baStatus;
+} ATMDRV_OAM_LOOPBACK, *PATMDRV_OAM_LOOPBACK;
+
+#define OAM_TYPE_FUNCTION_BYTE_OFFSET       0
+#define OAM_LB_INDICATION_BYTE_OFFSET       1
+#define OAM_LB_CORRELATION_TAG_BYTE_OFFSET  2
+#define OAM_LB_LOCATION_ID_BYTE_OFFSET      6
+#define OAM_LB_SRC_ID_BYTE_OFFSET           22
+#define OAM_LB_UNUSED_BYTE_OFFSET           38
+#define OAM_RDI_UNUSED_BYTE_OFFSET          1
+#define OAM_LB_CRC_BYTE_OFFSET              46
+#define OAM_RDI_CRC_BYTE_OFFSET             46
+#define OAM_LB_CORRELATION_TAG_LEN          4
+#define OAM_LB_LOCATION_ID_LEN              16
+#define OAM_LB_SRC_ID_LEN                   16
+#define OAM_LB_UNUSED_BYTE_LEN              8
+#define OAM_RDI_UNUSED_BYTE_LEN             45
+#define OAM_LB_CRC_BYTE_LEN                 2
+#define OAM_RDI_CRC_BYTE_LEN                2
+#define OAM_FAULT_MANAGEMENT_LB             0x18
+#define OAM_FAULT_MANAGEMENT_RDI            0x11
+#define OAM_FAULT_MANAGEMENT_LB_REQUEST     1
+#define OAM_FAULT_MANAGEMENT_LB_RESPOND     0
+#define OAM_FAULT_MANAGEMENT_CORRELATION_VAL  0xbcbcbcbc
+#define OAM_FAULT_MANAGEMENT_SRC_ID_3       0xffffffff
+#define OAM_FAULT_MANAGEMENT_SRC_ID_2       0xffffffff
+#define OAM_FAULT_MANAGEMENT_SRC_ID_1       0xffffffff
+#define OAM_FAULT_MANAGEMENT_SRC_ID_0       0xffffffff
+#define OAM_FAULT_MANAGEMENT_LOCATION_ID_3  0xffffffff
+#define OAM_FAULT_MANAGEMENT_LOCATION_ID_2  0xffffffff    
+#define OAM_FAULT_MANAGEMENT_LOCATION_ID_1  0xffffffff
+#define OAM_FAULT_MANAGEMENT_LOCATION_ID_0  0xffffffff
+#define OAM_LB_UNUSED_BYTE_DEFAULT          0x6a
+#define OAM_LB_SEGMENT_TYPE                 0
+#define OAM_LB_END_TO_END_TYPE              1
+#define OAM_F4_LB_SEGMENT_TYPE              2
+#define OAM_F4_LB_END_TO_END_TYPE           3
+#define RM_PROT_ID_OFFSET                   0
+#define RM_MESSAGE_TYPE_OFFSET              1
+#define RM_PROTOCOL_ID                      1
+#define RM_TYPE_DEFAULT                     0x20 /* forward/source_generated/congested */
+#define RM_UNUSED_BYTES_OFFSET              2
+#define RM_UNUSED_BYTES_LEN                 46
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // _ATMAPIDRV_H_
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/atmdiag.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/atmdiag.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/atmdiag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/atmdiag.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,764 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+
+#ifndef __ATMDIAG_H__
+#define __ATMDIAG_H__
+
+//#define BRCM_6348
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define ATM_DIAG_FAIL                       -1
+#define ATM_DIAG_PASS                       0
+#define ATM_REGADDR                         0xFFFE4000
+#define ATM_REGSIZE                         0x800
+#define ATM_TX_VPI_VCI_CAM_OFFSET           0x500
+#define ATM_RX_VPI_VCI_CAM_OFFSET           0x600
+#define ATM_TRAFFIC_SHAPER_OFFSET           0x700
+#define ATM_TX_STATUS_OFFSET                0x40c
+#define ATM_RX_STATUS_OFFSET                0x41c
+#define ATM_RX_AAL_STATUS_OFFSET            0x428
+#define ATM_MIP_COUNTERS_OFFSET             0x440
+#define ATM_UTOPIA_SETTING_OFFSET           0x42c
+#define ATM_ADSL_PHY_PORT_SETTING           0x15c
+#define UT_MAX_TDT_ENTRIES                  2
+#define UT_MAX_MGMT_ENTRIES                 4
+#define UT_LINE_RATE                (146200000)  /* 344811 cells/sec, CIT = 29ns */
+#define UT_CELL_RATE                (53 * 8)
+#define UT_MIN_PCR_SCR              310          /* ~128Kbps */
+#define UT_MAX_PCR_SCR              344811       /* ~146.2Kpbs */
+#define UT_MIN_MBS                  2
+#define UT_MAX_MBS                  200000
+  //#ifdef BRCM_6348  currently, the driver only support 8 VCCS
+  //#define UT_MAX_VCCS                         16
+  //#else
+#define UT_MAX_VCCS                         8
+  //#endif
+#define UT_MAX_PHY_PORTS                    2
+#define UT_BASE_PORT_NUMBER                 1
+#define UT_MIN_QUEUE                        1
+#define UT_MAX_QUEUE                        UT_MAX_VCCS
+#define UT_MULTI_QUEUE                      1
+#define UT_SINGLE_QUEUE                     0
+#define UT_MIN_PRIORITY                     1
+#define UT_MAX_PRIORITY                     4    /* priority ranging from 1-4 */
+#define UT_BUFFER_SIZE                      20
+#define UT_MGMT_IDX                         6
+#define UT_ENABLED                          1
+#define UT_DISABLED                         0
+#define UT_MAX_TD_INDEX                     UT_MAX_VCCS
+#define UT_SSTED_TRAILER_SIZE               8
+#define UT_DIALED_DIGITS                    2
+#define UT_FREE_CELL_Q_SIZE                 800
+#define UT_FREE_PKT_Q_SIZE                  800
+#define UT_FREE_PKT_Q_BUF_SIZE              1600
+#define UT_RX_PKT_Q_SIZE                    800
+#define UT_RX_CELL_Q_SIZE                   800
+#define UT_AAL5_MAX_SDU_LENGTH              65535
+#define UT_TX_FIFO_PRIORITY                 4
+#define UT_MIN_DATA_LEN                     48
+#define UT_MAX_DATA_LEN                     1500
+#define UT_BASE_VPI_NUMBER                  0
+#define UT_MAX_VPI_NUMBER                   256
+#define UT_BASE_VCI_NUMBER                  32
+#define UT_MAX_VCI_NUMBER                   65536
+#define UT_UTOPIA_MODE                      1
+#define UT_ADSL_MODE                        0
+#define UT_UTOPIA_ADSL_MODE                 0x11   /* utopia port 0, adsl port 1 */
+#define UT_TOGGLE_DISPLAY_MODE              1
+#define UT_TOGGLE_CAPTURE_MODE              0
+#define UT_TOGGLE_VERIFICATION_MODE         2
+#define UT_TOGGLE_MODE_ON                   1
+#define UT_TOGGLE_MODE_OFF                  0
+#define UT_DUMP_TX_VPI_VCI_TABLE            1
+#define UT_DUMP_RX_VPI_VCI_TABLE            2
+#define UT_DISPLAY_STATS                    1
+#define UT_CLEAR_STATS                      2
+#define UT_TRAFFIC_DESCRIPTOR_DISPLAY       1
+#define UT_TRAFFIC_DESCRIPTOR_MODIFY        2
+#define UT_PORT_UTOPIA_SETTING              1
+#define UT_GLOBAL_UTOPIA_SETTING            2
+#define UT_DISPLAY_CAPTURED                 0
+#define UT_ERASE_CAPTURED                   1
+#define UT_CAPTURED_ERROR_STATS             2
+#define UT_PATTERN_INCREMENT                1
+#define UT_PATTERN_FIX                      0
+#define UT_MODIFY_OPERATION                 1
+#define UT_DISPLAY_OPERATION                0
+#define DIAG_ATM_MODULE       "bcmatmtest"
+#define DIAG_ATM_PROC         "/proc/atmtest"
+
+/* command is made up of 2_bytes_command|2_bytes_index */
+/* index is ranging from 0-7 for 8 VCs */
+#define UT_PROC_CMD_ADD_VC                  1
+#define UT_PROC_CMD_DELETE_VC               2
+#define UT_PROC_CMD_START_SEND_VC           3
+#define UT_PROC_CMD_SEND_MULTI_VC           4
+#define UT_PROC_CMD_STOP_SEND_VC            5
+#define UT_PROC_CMD_CAPTURE                 6
+#define UT_PROC_CMD_TOGGLE                  7
+#define UT_PROC_CMD_GET_STATS               8
+#define UT_PROC_CMD_CLEAR_STATS             9
+#define UT_PROC_CMD_SEND_MULTI_PRIORITY     10
+#define UT_PROC_CMD_MODIFY_TRAFFIC_SHAPER   11
+#define UT_PROC_CMD_START_SEND_ALL_VC       12
+#define UT_PROC_CMD_ADSL_LOOPBACK           13
+#define UT_PROC_CMD_SEND_MANAGEMENT         14
+#define UT_PROC_CMD_ADD_MPVC                15
+#define UT_PROC_CMD_DELETE_MPVC             16
+#define UT_PROC_CMD_START_SEND_MPVC         17
+#define UT_PROC_CMD_UTOPIA_SET              18
+
+#define UT_OAM_LB_END_TO_END                10  /* was 1 */
+#define UT_OAM_LB_SEGMENT                   11  /* was 2 */
+#define UT_OAM_RDI_END_TO_END               3
+#define UT_OAM_RDI_SEGMENT                  4
+#define UT_VPC_RM_TYPE                      5
+#define UT_VCC_RM_TYPE                      6
+#define UT_OAM_CRC10_SOFTWARE               0
+#define UT_OAM_CRC10_HARDWARE               1
+#define UT_TOGGLE_DISPLAY                   0
+#define UT_TOGGLE_CAPTURE                   1
+#define UT_TOGGLE_VERIFY                    2
+
+#define AP_REG_OFFSET_END                   0x7ff
+#define AP_INDIRECT_RAM_ADDRESS_REG      ATM_PROCESSOR_BASE + 0x7c0
+#define AP_INDIRECT_RAM_REG              ATM_PROCESSOR_BASE + 0x7c4
+#define AP_IRQ_MASK                      AP_INTR_REGS_BASE+0x4
+#define AP_IRQ_STATUS                    AP_INTR_REGS_BASE
+#define AP_ROUTE_OAM_TO_RCQ              0
+#define AP_ROUTE_OAM_TO_MCF              1
+#define AP_IR_ASSERT                     1
+#define AP_IR_DEASSERT                   0
+#define AP_RX_STATUS_ERR_MASK            0x32ecc /* mask out idleCell, vc & unused */
+#define AP_RX_AAL_STATUS_ERR_MASK        0x3008  /* only look at rx router stats, discard */
+
+typedef struct utVccCfg {
+  UINT8 ulAalType;
+  UINT8 ulAtmVccCpcsAcceptCorruptedPdus;
+}UT_VCC_CFG, *pUT_VCC_CFG;
+
+typedef struct utTrafficDescrParmEntry {
+  UINT32 ulTrafficDescrIndex;
+  UINT32 ulTrafficDescrType;
+  UINT32 ulTrafficDescrParm1;
+  UINT32 ulTrafficDescrParm2;
+  UINT32 ulTrafficDescrParm3;
+  UINT32 ulTrafficDescrParm4;
+  UINT32 ulTrafficDescrParm5;
+  UINT32 ulTrafficDescrRowStatus;
+  UINT32 ulServiceCategory;
+}UT_TRAFFIC_DESCR_PARM_ENTRY,*pUT_TRAFFIC_DESCR_PARM_ENTRY;
+
+typedef struct utMultiSendInfo {
+  UINT32 len;
+  UINT8  pattern;
+  UINT8  dataByte;
+  UINT32 numSent;
+  UINT32 rate;
+  UINT8  circuitType;
+  UINT32 cellsPerPdu; 
+  UINT32 delay;
+  UINT32 txCount;
+}UT_MULTISEND_INFO, *pUT_MULTISEND_INFO;
+
+typedef struct utUserSendInfo {
+  UINT32 len;
+  UINT8  incremental;
+  UINT8  dataByte;
+  UINT32 rate;
+  UINT32 aalType;
+  UINT32 delay;
+  UINT32 txCount;   /* number of cells/pkt user want to send */
+  UINT8  multiQPriority;
+  UINT8  basePriority;
+  UINT8  numOfQueues;
+}UT_USER_SEND_INFO, *pUT_USER_SEND_INFO;
+
+typedef struct utVccAddrInfo {
+  ATM_VCC_ADDR vccAddr;
+  UINT8 priority;  /* priority of the queue of this VCC */
+  UINT8 numOfQueues;
+}UT_VCC_ADDR_INFO, *pUT_VCC_ADDR_INFO;
+
+typedef struct utVccListInfo {
+  UINT32 handle;
+  UINT32 managementHandle;
+}UT_VCC_LIST_INFO, *pUT_VCC_LIST_INFO;
+
+typedef struct atmCaptureHdr {
+  UINT8 valid;
+  UINT8 vpi;
+  UINT16 vci;
+  UINT8 circuitType;
+  UINT8 cid;
+  UINT8 uuData8;
+  UINT8 uuData5;
+  UINT8 ucFlags;
+  UINT32 dataLen;
+  UINT8 *dataPtr;
+  UINT8 interface;
+} ATM_CAPTURE_HDR, *pATM_CAPTURE_HDR;
+
+typedef struct atmTxBufferHdr {
+  ATM_VCC_DATA_PARMS dataParms;
+  struct atmTxBufferHdr *next;
+} ATM_TX_BUFFER_HDR, *pATM_TX_BUFFER_HDR;
+
+typedef struct tx_buffer_list{
+  pATM_TX_BUFFER_HDR headPtr;
+  pATM_TX_BUFFER_HDR tailPtr;
+  UINT32 len;
+  UINT32 seqNumber;
+  UINT32 lastSent;
+  UINT32 sentInterval;
+  UINT32 cellsPerPdu;
+} ATM_TX_BUFFER_LIST, *pATM_TX_BUFFER_LIST;
+
+typedef struct atmTestError {
+  UINT32 total;
+  UINT32 data_err;
+  UINT32 data_length;
+  UINT32 sequence_err;
+  UINT32 aalCrcError;
+  UINT32 aalCpcsLen0;
+  UINT32 aalLenError;
+  UINT32 aalSduLenError;
+  UINT32 gfc;
+  UINT32 crc;
+  UINT32 pti;
+  UINT32 pmi_2sml;
+  UINT32 pmi_2big;
+  UINT32 vcam_mme;
+  UINT32 pne;
+  UINT32 came_1;
+  UINT32 came_0;
+  UINT32 dc_1;
+  UINT32 dc_0;
+  UINT32 ec_1;
+  UINT32 ec_0;
+  UINT32 aal5_drop_cell;
+  UINT32 routerDiscard_1;
+  UINT32 routerDiscard_0;
+  UINT32 camLkup;
+  UINT32 idle;
+  UINT32 hec;
+} ATM_TEST_ERROR, *pATM_TEST_ERROR;
+
+typedef struct atmMibStats {
+  UINT32 tx_aal5_0;
+  UINT32 tx_aal5_1;
+  UINT32 tx_aal0_0;
+  UINT32 tx_aal0_1;
+  UINT32 rx_aal5_0;
+  UINT32 rx_aal5_1;
+  UINT32 rx_aal0_0;
+  UINT32 rx_aal0_1;
+} ATM_MIB_STATS, *pATM_MIB_STATS;
+
+/* These are from TX status register; they are collected every 1 second interval */
+typedef struct atmTxStats {
+  UINT32 fifoFull;              /*  fifoFull_port0 */
+  UINT32 aal2bigErr;      
+  UINT32 aal5LenErr;  
+  UINT32 aal5MaxLenErr;
+  UINT32 droppedCellErr;        /* tx aal or tx atm dropped cell port 0 */
+  UINT32 aal5PortNotEnableErr;  /* pne_err_port0 */
+  UINT32 fifoFullErr;           /* ff_err_port0 */
+  UINT32 aal5CountErr;
+} ATM_TX_STATS, *pATM_TX_STATS;
+
+/* these are from RX ATM and RX AAL status registers */
+typedef struct atmRxStats {
+  UINT32 gfcErr;
+  UINT32 crcErr;
+  UINT32 ptiErr;
+  UINT32 vcamMmErr;          /* vcam_mme VCAM multiple match error */
+  UINT32 camLookupErr;       /* came_port0 */
+  UINT32 portNotEnableErr;   /* pne_err */
+  UINT32 discardErr;         /* dc_port0 */
+  UINT32 errCellErr;         /* ec_port0 */
+  UINT32 routerDrop;         /* rxRouterStat_port0 */
+  UINT32 aalDrop;            /* aal5d */
+#ifdef BRCM_6348
+  UINT32 overflowErr;
+  UINT32 uto2small;
+  UINT32 uto2big;
+#endif
+} ATM_RX_STATS, *pATM_RX_STATS;
+
+typedef struct atmStats
+{
+  ATM_MIB_STATS mibStats;
+  ATM_TX_STATS txStats;
+  ATM_RX_STATS rxStats;
+}ATM_STATS, *pATM_STATS;
+
+typedef struct atm_test_tx_info {
+  UINT32 index;
+  UINT32 len;
+  UINT32 lineTxInterval; 
+  UINT32 count;
+  UINT8  incremental;
+  UINT8  dataByte;
+  UINT8  aalType;
+  UINT8  numOfQueues;
+  UINT8  basePriority;
+  UINT32 handle;
+  UINT32 rate;
+  UINT32 sending;
+  UINT8  managementType; /* f4, f5, rm */
+  UINT8  interleaveManagement;
+  UINT16 managementVpi;
+  UINT16 managementVci;
+  UINT16 managementCrc;
+  UINT32 managementInterface;
+} ATM_TEST_TX_INFO, *pATM_TEST_TX_INFO;
+
+typedef struct atm_test_info {
+  ATM_TEST_TX_INFO atmTestTxInfo[UT_MAX_VCCS+1]; /* one extra for f4 since it doesn't
+                                                    have a vcc created, index is last one */
+  UT_TRAFFIC_DESCR_PARM_ENTRY ms_Tdt[UT_MAX_TD_INDEX];
+  UT_VCC_CFG ms_VccCfgs[UT_MAX_VCCS];
+  UT_VCC_ADDR_INFO ms_VccAddrs[UT_MAX_VCCS];
+  UINT32 commandStatus; /* command-2 bytes, status 2 bytes */
+  ATM_TEST_ERROR m_ucTestError[UT_MAX_VCCS+1];
+  ATM_STATS atmStats;
+  UINT8 displayData;  /* current mode: 0=disable, 1=enable */
+  UINT8 captureData;  /* current mode: 0=disable, 1=enable */
+  UINT8 verifyData;  /* current mode: 0=disable, 1=enable */
+  UINT32 pduSent[UT_MAX_VCCS+1]; /* one extra for f4 */
+  UINT32 pduReceived[UT_MAX_VCCS+1];
+  UINT32 multiPriority;
+} ATM_TEST_INFO, *pATM_TEST_INFO;
+
+typedef struct atm_verfication_info {
+  int seqNumber;
+  UINT8 incremental;
+  UINT8 dataByte;
+  int len;
+} ATM_VERIFICATION_INFO, *pATM_VERIFICATION_INFO;
+
+typedef struct atm_data_struct {
+  PATM_VCC_DATA_PARMS data;
+  ATM_VCC_ADDR vccAddr;
+} ATM_DATA_STRUCT, *PATM_DATA_STRUCT;
+
+typedef struct atmDiagCb {
+  ATM_TRAFFIC_DESCR_PARM_ENTRY ms_Tdt[UT_MAX_TD_INDEX];
+  ATM_VCC_CFG ms_VccCfgs[UT_MAX_VCCS];
+  UT_VCC_ADDR_INFO ms_VccAddrs[UT_MAX_VCCS];
+  UINT32 ms_multiPriority[UT_MAX_VCCS];
+  ATM_TX_BUFFER_LIST mTxHdrQ[UT_MAX_VCCS+1]; /* tx Q; an extra one for f4 cells */
+  UT_VCC_LIST_INFO m_ulVccList[UT_MAX_VCCS+1]; /* tx Q; an extra one for f4 cells */
+  UINT32 managementHandle_port0;
+  UINT32 managementHandle_port1;
+  UINT32 rxTaskId;  
+  UINT32 txTaskId;
+  UINT32 statsTaskId;
+  UINT32 rxTaskSem;  /* protect Rx Q */
+  UINT32 txTaskSem;  /* protect Tx Q */
+  UINT32 rxQMuSem;   /* rx task semphore */
+  UINT32 txQMuSem;   /* tx task semphore */
+  UINT32 txTaskExit; /* clean up purpose */
+  UINT32 rxTaskExit; /* clean up purpose */
+  ATM_DATA_STRUCT m_pDpHead; /* rx Q */
+  ATM_DATA_STRUCT m_pDpTail; /* rx Q */
+  UINT8 displayData;  /* 1 to display rx data on screen; default is 0 */
+  UINT8 captureData;
+  UINT8 verifyData;
+  ATM_CAPTURE_HDR m_ulData[UT_BUFFER_SIZE]; 
+  int m_ulBufferPosition;
+  UINT32 m_ulCurSeqNumber;
+  ATM_TEST_ERROR m_ucTestError[UT_MAX_VCCS+1];
+  ATM_STATS m_atmStats;
+  ATM_VERIFICATION_INFO dataVerficationInfo[UT_MAX_VCCS]; 
+  UINT8 txStop; 
+} ATM_DIAG_CB, *pATM_DIAG_CB;
+
+/* 0xfffe15c */
+typedef union phyLastDescConfig { 
+  struct {
+    UINT32 unused:22;
+    UINT32 rxCfg:2;
+    UINT32 unused1:2;
+    UINT32 txCfg:2;
+    UINT32 numRxDesc:2;
+    UINT32 numTxDesc:2;
+  }bit;
+  UINT32 reg;
+} PHY_LAST_DESC_CONFIG, *pPHY_LAST_DESC_CONFIG;
+
+/* 0xfffe4500-0xfffe45ff */
+typedef union txAtmVpiVciTable { 
+  struct {
+    UINT32 unused:6;
+    UINT32 swFlags:1;
+    UINT32 crcEnable:1;
+    UINT32 vpi: 8;
+    UINT32 vci:16;
+  }bit;
+  UINT32 entry;
+} TX_ATM_VPI_VCI_TABLE, *pTX_ATM_VPI_VCI_TABLE;
+
+/* 0xfffe4600-0xfffe46ff */
+typedef union RxAtmVpiVciTable {
+  struct {
+    UINT32 unused:6;
+    UINT32 valid:1;
+    UINT32 vpi:8;
+    UINT32 vci:16;
+    UINT32 port:1;
+  } camSide;  /* even; */
+  struct {
+    UINT32 unused:21;
+    UINT32 userDataIR:1; /* assert IR for user data immediate response */
+    UINT32 oamIR:1; /* assert IR for OAM immediate response */
+    UINT32 rmIR:1;  /* assert IR for RM immediate response */
+    UINT32 vcId:3;  /* VCID */
+    UINT32 userDataCrcEnable:1;
+    UINT32 oamRouteCode:1;  /* 0=route to rx cell q; 1= route to rx mips cell fifo */
+    UINT32 udrc:1;  /* User Data Routing Code */
+    UINT32 circuitType:2; 
+  } ramSide; /* odd; */
+  UINT32 entry;
+} RX_ATM_VPI_VCI_TABLE, *pRX_ATM_VPI_VCI_TABLE;
+
+/* 6345; 0xfffe4300- 0xfffe43ff */
+typedef union atmIntrRegs {
+  struct {
+    UINT32 unused:20; 
+    UINT32 vcamMm:1;   /* RX VCAM multiple match */
+    UINT32 rxRtDc:1;   /* Rx Router discard cell due to full rx buffer */
+    UINT32 rpqIr:1;    /* Receive Packet Queue got a packet tagged with immediate response */
+    UINT32 rcqIr:1;    /* Receive Cell Queue got a cell tagged with immediate response */
+    UINT32 rpqWd:1;    /* RX Pkt Q watchdog- no pkt rxed for the duration defined in RCQ wd timer */
+    UINT32 rcqWd:1;    /* RX Cell Q watchdog */
+    UINT32 mibHf:1;    /* one or more of the MIB coutners is half full */
+    UINT32 fpqAe:1;    /* Free Packet Queue almost empty- has fewer buffers than FPQ watermark */
+    UINT32 rpqAf:1;    /* Rx Packet Queue has exceeded RPQ watermark */
+    UINT32 fcqAe:1;    /* Free Cell Queue almost Empty */
+    UINT32 rcqAf:1;    /* Rx Cell Q almost full */
+    UINT32 txs:1;      /* Tx SDRAM Interrupt- one of the TX SDRAM sub-channels intr is set */
+  }statusMaskBit;      /* status & interrupt mask */
+#ifdef BRCM_6348
+  struct {
+    UINT32 unused1:8;
+    UINT32 sdqMask:8;  /* TX SDRAM watchdog timer interrupt */
+    UINT32 unused:4;
+    UINT32 irqMask:12; 
+  }irqMaskBit;
+  struct {
+    UINT32 unused:28;   
+    UINT32 sdWd:4;     /* TX SDRAM Watchdog */
+  }txSdramValue;
+#else /* 6345 */
+  struct {
+    UINT32 unused:16;   
+    UINT32 irqMask:16; 
+  }irqMaskBit;
+#endif /* BRCM_6348 */
+  struct {
+    UINT32 fcqAeWm:16;  /* Free Cell Q almost empty watermark */
+    UINT32 rcqAfWm:16;  /* Rx Cell Q almost full watermark */
+  }rxCellQBit;
+  struct {
+    UINT32 fpqAeWm:16;  /* Free Packet Q almost empty watermark */
+    UINT32 rpqAfWm:16;  /* Rx Paket Q almost full watermark */
+  }rxPktQBit;
+  struct {
+    UINT32 pktWdTo:16;  /* Watchdog timeout value in 50 uSec increments */
+    UINT32 cellWdTo:16; /* Watchdog timeout value in 50 uSec increments */
+  }rxWdTimer;
+} ATM_INTR_REGS, *pATM_INTR_REGS;
+
+/* 0xfffe4700-0xfffe47ff */
+typedef union atmShaperCtrlReg {
+#ifdef BRCM_6348
+  struct {
+    UINT32 unused:7;
+    UINT32 rst:1;      /* reset shaper */
+    UINT32 pcr:12;     /* peak cell rate */
+    UINT32 mpEn:1;     /* Multi-priority enabled */
+    UINT32 priority:2; /* source scheduling sub-priority */
+    UINT32 mcrEnable:1;/* Minimum Cell Rate Enabled */
+    UINT32 alg:2;      /* source shaping algorithm */
+    UINT32 pid:1;      /* Source destination Port ID */
+    UINT32 vcid:4;     /* source VC ID */
+    UINT32 enable:1;   /* source shaper enable */
+  }bit;
+#else /* 6345 */
+  struct {
+    UINT32 unused:9;
+    UINT32 rst:1;      /* reset shaper */
+    UINT32 pcr:12;     /* peak cell rate */
+    UINT32 mpEn:1;     /* Multi-priority enabled */
+    UINT32 priority:2; /* source scheduling sub-priority */
+    UINT32 alg:2;      /* source shaping algorithm */
+    UINT32 pid:1;      /* Source destination Port ID */
+    UINT32 vcid:3;     /* source VC ID */
+    UINT32 enable:1;   /* source shaper enable */
+  }bit;
+#endif /* BRCM_6348 */
+  UINT32 entry;
+} ATM_SHAPER_CTRL_REG, *pATM_SHAPER_CTRL_REG;
+
+typedef union atmShaperVbrReg {
+  struct {
+    UINT32 unused:1;
+    UINT32 bt:19;
+    UINT32 scr:12;
+  }bit;
+  UINT32 entry;
+} ATM_SHAPER_VBR_REG, *pATM_SHAPER_VBR_REG;
+
+#ifdef BRCM_6348
+typedef union atmShaperMcrReg {
+  struct {
+    UINT32 unused:20;
+    UINT32 mcr:12;
+  }bit;
+  UINT32 entry;
+} ATM_SHAPER_MCR_REG, *pATM_SHAPER_MCR_REG;
+#endif /* BRCM_6348 */
+
+typedef union atmCellHdr {
+  struct {
+    UINT32 gfc:4;  
+    UINT32 msb_vpi:4;  
+    UINT32 vpi:4;  
+    UINT32 msb_vci:4;  
+    UINT32 vci:8;
+    UINT32 lsb_vci:4;  
+    UINT32 pt:3;  
+    UINT32 clp:1;  
+  }bit;
+  UINT32 word1;
+} ATM_CELL_HDR, *pATM_CELL_HDR;
+#define ATM_RX_AAL_STATUS_ERROR_MASK_PORT0 0x108
+
+/* 0xfffe4428 */
+typedef union atmRxAalStatusReg {
+  struct {
+    UINT32 unused:22;  
+    UINT32 rxRouterStat_port1:1; /* RX cells dropped due to full cell buffer; */
+    UINT32 rxRouterStat_port0:1; /* bit 8=port 0 fifo rx drop cell */
+    UINT32 aal0ccnt_port1:1;     /* aal0 cell count has been incremented; bit 4=port0 */
+    UINT32 aal0ccnt_port0:1;     /* aal0 cell count has been incremented; bit 4=port0 */
+    UINT32 aal5ccnt_port1:1;     /* aal5 cell count has been incremented; bit 4=port0 */
+    UINT32 aal5ccnt_port0:1;     /* aal5 cell count has been incremented; bit 4=port0 */
+    UINT32 aal5d:1;        /* aal5 dropped cells */
+    UINT32 aal5p:1;        /* aal5 pdu received */
+    UINT32 aalxp:1;        /* non aal5 received */
+    UINT32 aal5c:1;        /* aal5 received cells */
+  }bit;
+  UINT32 reg;
+} ATM_RX_AAL_STATUS_REG, *pATM_RX_AAL_STATUS_REG;
+/*  0xfffe441c */
+#define ATM_RX_STATUS_ERROR_MASK_PORT0 0x32354
+typedef union atmRxStatusReg {
+  struct {
+    UINT32 unused:14;  
+    UINT32 gfc_err:1;  /* non zero gfc detected */
+    UINT32 crc_err:1;  /* CRC-10 error detected on OAM/RM cells */
+#ifdef BRCM_6348
+    UINT32 rx_flow_err:1;  /* Receive cell dropped by RXATM layer 'cause RX cell FIFO full */
+#else /* 6345 */
+    UINT32 unused1:1;  
+#endif
+    UINT32 idle_err:1; /* Idle cell detected */
+    UINT32 pti_err:1;  /* PTI Error detected (i.e. PT=binary 111) */
+#ifdef BRCM_6348
+    UINT32 unused2:1;  
+    UINT32 uto2small:1;/* Too small of a cell from RX Utopia */
+    UINT32 uto2big:1;  /* Too big of a cell from RX Utopia */
+#else /* BRCM_6345 */
+    UINT32 unused2:3;  
+#endif
+    UINT32 vcam_mme:1; /* VCAM multiple match error */
+    UINT32 pne_err:1;  /* port not enable error */
+    UINT32 came_port1:1;     /* PER port cam lookup error; bit6=port 0  */
+    UINT32 came_port0:1;     /* PER port cam lookup error; bit6=port 0  */
+    UINT32 dc_port1:1;       /* per port dropped cell; bit 4= port 0 */  
+    UINT32 dc_port0:1;       /* per port dropped cell; bit 4= port 0 */  
+    UINT32 ec_port1:1;       /* per port erred cell; bit 2=port 0 */
+    UINT32 ec_port0:1;       /* per port erred cell; bit 2=port 0 */
+    UINT32 vc_port1:1;       /* per port valid cell; bit 0=port 0 */
+    UINT32 vc_port0:1;       /* per port valid cell; bit 0=port 0 */
+  }bit;
+  UINT32 reg;
+} ATM_RX_STATUS_REG, *pATM_RX_STATUS_REG;
+
+#define ATM_TX_STATUS_ERROR_MASK_PORT0  0x41e80c54
+typedef union atmTxStatusReg {
+  struct {
+    UINT32 fifoFull_port1:1; /* per port FIFO Full Status (1=full) */
+    UINT32 fifoFull_port0:1; /* per port FIFO Full Status (1=full) */
+    UINT32 unused:1;  
+    UINT32 aal0_port1:1; /* aal0_port1 tx */
+    UINT32 aal0_port0:1; /* aal0_port0 tx */
+    UINT32 aal5_port1:1; /* aal5_port1 tx */
+    UINT32 aal5_port0:1; /* aal5_port0 tx */
+    UINT32 aal2big:1;  /* aal too big cell input */
+    UINT32 aal5liErr:1;/* aal5 length indicator error */
+    UINT32 aal5mlErr:1;/* aal5 max length error */
+    UINT32 aal5ctErr:1;/* aal5 count error */
+    UINT32 unused1:1;  
+    UINT32 aal5d:1;    /* aal5 drop cell */
+    UINT32 aal5p:1;    /* aal5 pdu passed */
+    UINT32 aalxc:1;    /* non aal5 cell passed */
+    UINT32 aal5c:1;    /* aal cell passed */
+    UINT32 dropCell_port1:1; /* tx aal or tx atm dropped cell */
+    UINT32 dropReq_port1:1;  /* one of the port dropped request */
+    UINT32 scheCell_port1:1; /* per port scheduled cell */
+    UINT32 sit_port1:1;      /* per port schedule interval timer count event */
+    UINT32 dropCell_port0:1; /* tx aal or tx atm dropped cell */
+    UINT32 dropReq_port0:1;  /* one of the port dropped request */
+    UINT32 scheCell_port0:1; /* per port scheduled cell */
+    UINT32 sit_port0:1;      /* per port schedule interval timer count event */
+    UINT32 pne_err_port1:1;  /* port not enable error */
+    UINT32 pne_err_port0:1;  /* port not enable error */
+    UINT32 ff_err_port1:1;   /* fifo full error */
+    UINT32 ff_err_port0:1;   /* fifo full error */
+    UINT32 dc_port1:1;       /* per port dropped cell */
+    UINT32 dc_port0:1;       /* per port dropped cell */
+    UINT32 pc_port1:1;       /* per port processed cell */
+    UINT32 pc_port0:1;       /* per port processed cell */
+  }bit;
+  UINT32 reg;
+} ATM_TX_STATUS_REG, *pATM_TX_STATUS_REG;
+
+
+typedef union atmTxHdrReg {
+  struct {
+    UINT32 unused1:14;
+    UINT32 aal5SwTrailer:1; /* software trailer enable */
+    UINT32 schedCrst_1:1;  /* scheuler reset */
+    UINT32 schedCrst_0:1;  
+    UINT32 unused:1; 
+    UINT32 haltShpt_1:1;   /* halt shaper, used for dynamic configuration of shaper */
+    UINT32 haltShpt_0:1;
+    UINT32 altGFC:4;       /* alternate GFC value */
+    UINT32 altGFCen_1:1;
+    UINT32 altGFCen_0:1;   /* alternate GFC mode enable */
+    UINT32 fRst_1:1;
+    UINT32 fRst_0:1;
+    UINT32 oamCrcEn_1:1;
+    UINT32 oamCrcEn_0:1;
+    UINT32 txEn_1:1;
+    UINT32 txEn_0:1;
+  }bit;
+  UINT32 reg;
+} ATM_TX_HDR_CFG_REG, *pATM_TX_HDR_CFG_REG;
+
+typedef union rxAalError {
+  struct {
+    UINT8 crc:1;             /* aal5 CRC error */
+    UINT8 cpcsLen0:1;        /* aal5 cpcsLen error */
+    UINT8 length:1;          /* aal5 len error */
+    UINT8 maxSduExceed:1;    /* max sdu exceed error */
+    UINT8 unused:4;
+  }bit;
+  UINT8 entry;
+} RX_AAL_ERROR;
+
+typedef union rxAtmError {
+  struct {
+    UINT8 pne:1;             /* port not enable error */
+    UINT8 hec:1;             /* HEC error */
+    UINT8 pti:1;             /* pti error */
+    UINT8 idle:1;            /* idle rx */
+    UINT8 camLkup:1;         /* cam look up error */
+    UINT8 unused:1;          
+    UINT8 oamCrc:1;          /* oam crc */
+    UINT8 gfc:1;             /* gfc error */
+  }bit;
+  UINT8 entry;
+} RX_ATM_ERROR;
+
+/* 0xfffe442c */
+typedef union atmUtopiaCfg {
+  struct {
+    UINT32 unused:26;
+    UINT32 rxLevel2:1;   /* when set=level 2, when 0=level 1 */
+    UINT32 rxEn:1;       /* enable RX Utopia Operation */
+    UINT32 unused1:2;
+    UINT32 txLevel2:1;   /* when set=level 2, when 0=level 1 */
+    UINT32 txEn:1;       /* enable TX Utopia Operation */
+  }bit;
+  UINT32 entry;
+} ATM_UTOPIA_CFG, *pATM_UTOPIA_CFG;
+
+typedef union portSchedulerCfg {
+  struct {
+    UINT32 cit:16;
+    UINT32 unused:12;
+    UINT32 mode:2;
+    UINT32 arb:1;
+    UINT32 en:1;
+  }bit;
+  UINT32 entry;
+} ATM_PORT_SCHEDULER_CFG, *pATM_PORT_SCHEDULER_CFG;
+
+/* memory map operation definition */
+typedef struct atm_regs {
+    int kmem_fd;
+    char *mmap_addr;
+    unsigned long addr;
+    unsigned int size;
+    unsigned int offset;
+} atm_regs;
+
+int getVccNextIndex(void);
+void removeVccIndex(int index);
+int isVpiVciExisted(UINT32 interface, UINT16 vpi, UINT16 vci);
+void atmDiagInit(void);
+BCMATM_STATUS bcmAtmDiagInit(void);
+BCMATM_STATUS bcmAtmDiagUnInit(void);
+BCMATM_STATUS bcmAtmAddVccCommand(pUT_VCC_ADDR_INFO pVccAddrs, pUT_VCC_CFG pVccCfg,
+                                  pUT_TRAFFIC_DESCR_PARM_ENTRY pTd);
+BCMATM_STATUS bcmAtmSendVccCommand(pATM_TEST_TX_INFO pAtmInfo);
+BCMATM_STATUS bcmAtmCaptureCommand(int mode);
+BCMATM_STATUS bcmAtmSendManagementCommand(pATM_TEST_TX_INFO pAtmInfo);
+BCMATM_STATUS bcmAtmDeleteVccCommand(pUT_VCC_ADDR_INFO pVccAddrs);
+BCMATM_STATUS bcmAtmSendAllVccsCommand(pATM_TEST_TX_INFO pAtmInfo);
+BCMATM_STATUS bcmAtmSendMultiPriorityCommand(pATM_TEST_TX_INFO pAtmInfo);
+BCMATM_STATUS bcmAtmSendLoopbackCommand(UINT8 mode);
+BCMATM_STATUS bcmAtmAddMPVccCommand(pUT_VCC_ADDR_INFO pVccAddrs, pUT_VCC_CFG pVccCfg,
+                                    pUT_TRAFFIC_DESCR_PARM_ENTRY pTd);
+BCMATM_STATUS bcmAtmDeleteMPVccCommand(pUT_VCC_ADDR_INFO pVccAddrs);
+BCMATM_STATUS bcmAtmSendMPVccCommand(pATM_TEST_TX_INFO pAtmInfo);
+BCMATM_STATUS bcmAtmSendMultiPriorityCommand(pATM_TEST_TX_INFO pAtmInfo);
+BCMATM_STATUS bcmAtmModifyTDCommand(pUT_TRAFFIC_DESCR_PARM_ENTRY pTD, UINT32 index);
+int bcmAtmGetStatsCommand(int reset);
+int bcmAtmToggleVerifyCommand(void);
+int bcmAtmToggleCaptureCommand(void);
+int bcmAtmToggleDisplayCommand(void);
+int bcmAtmStopTxCommand(void);
+int isVpiVciExisted(UINT32 interface, UINT16 vpi, UINT16 vci);
+int bcmDiag_unmapregs(atm_regs *mapregs);
+atm_regs *bcmDiag_mapregs(unsigned long addr, int size);
+int bcmDiagGetVerificationStats(int vcc,char *pResult);
+void bcmDiagClearSARstats(void);
+void bcmDiagReadSARstats(int parm);
+int bcmDiagGetSARStats(char *pResult);
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/atmosservices.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/atmosservices.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/atmosservices.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/atmosservices.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,98 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+//**************************************************************************
+// File Name  : BcmAtmApi.h
+//
+// Description: This file contains the definitions, structures and function
+//              prototypes for the Broadcom Asynchronous Transfer Mode (ATM)
+//              Application Program Interface (API).
+//
+// Updates    : 09/15/2000  lat.  Created.
+//**************************************************************************
+
+#if !defined(_ATMOSSERVICES_H_)
+#define _ATMOSSERVICES_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+//**************************************************************************
+// Constant Definitions
+//**************************************************************************
+#define RTN_SUCCESS                 0
+#define RTN_ERROR                   1
+#define USE_CURRENT_THREAD_PRIORITY 0
+
+//**************************************************************************
+// Type Definitions
+//**************************************************************************
+typedef void (*FN_GENERIC) (void *);
+typedef struct AtmOsFuncs
+{
+    FN_GENERIC pfnAlloc;
+    FN_GENERIC pfnFree;
+    FN_GENERIC pfnDelay;
+    FN_GENERIC pfnCreateSem;
+    FN_GENERIC pfnRequestSem;
+    FN_GENERIC pfnReleaseSem;
+    FN_GENERIC pfnDeleteSem;
+    FN_GENERIC pfnDisableInts;
+    FN_GENERIC pfnEnableInts;
+    FN_GENERIC pfnInvalidateCache;
+    FN_GENERIC pfnFlushCache;
+    FN_GENERIC pfnGetTopMemAddr;
+    FN_GENERIC pfnBlinkLed;
+    FN_GENERIC pfnGetSystemTick;
+    FN_GENERIC pfnStartTimer;
+    FN_GENERIC pfnPrintf;
+} ATM_OS_FUNCS, *PATM_OS_FUNCS;
+
+//**************************************************************************
+// Function Prototypes
+//**************************************************************************
+
+UINT32 AtmOsInitialize( PATM_OS_FUNCS pFuncs );
+char *AtmOsAlloc( UINT32 ulSize );
+void AtmOsFree( char *pBuf );
+UINT32 AtmOsCreateThread( char *pszName, void *pFnEntry, UINT32 ulFnParm,
+    UINT32 ulPriority, UINT32 ulStackSize, UINT32 *pulThreadId );
+UINT32 AtmOsCreateSem( UINT32 ulInitialState );
+UINT32 AtmOsRequestSem( UINT32 ulSem, UINT32 ulTimeoutMs );
+void AtmOsReleaseSem( UINT32 ulSem );
+void AtmOsDeleteSem( UINT32 ulSem );
+UINT32 AtmOsDisableInts( void );
+void AtmOsEnableInts( UINT32 ulLevel );
+void AtmOsDelay( UINT32 ulTimeoutMs );
+UINT32 AtmOsTickGet( void );
+UINT32 AtmOsTickCheck( UINT32 ulWaitTime, UINT32 ulMsToWait );
+void AtmOsInvalidateCache( void *pBuf, UINT32 ulLength );
+void AtmOsFlushCache( void *pBuf, UINT32 ulLength );
+char *AtmOsTopMemAddr( void );
+void AtmOsBlinkLed( void );
+UINT32 AtmOsInitDeferredHandler( void *pFnEntry, UINT32 ulFnParm,
+    UINT32 ulTimeout );
+void AtmOsScheduleDeferred( UINT32 ulHandle );
+void AtmOsUninitDeferredHandler( UINT32 ulHandle );
+UINT32 AtmOsStartTimer( void *pFnEntry, UINT32 ulFnParm, UINT32 ulTimeout );
+void AtmOsPrintf( char *, ... );
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // _ATMOSSERVICES_H_
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcm_common.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcm_common.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcm_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcm_common.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2004 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+
+#ifndef __BCM_COMMON_H
+#define __BCM_COMMON_H
+
+#if defined(CONFIG_BCM96338)
+#include <6338_common.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_common.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_common.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,5)      /* starting from 2.4.5 */
+#define skb_dataref(x)   (&skb_shinfo(x)->dataref)
+#else
+#define skb_dataref(x)   skb_datarefp(x)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,19) /* starting from 2.4.19 */
+#define VIRT_TO_PHY(a)  (((unsigned long)(a)) & 0x1fffffff)
+#else
+#define VIRT_TO_PHY     virt_to_phys
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define __save_and_cli  save_and_cli
+#define __restore_flags restore_flags
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcm_map.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcm_map.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcm_map.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcm_map.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2004 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+
+#ifndef __BCM_MAP_H
+#define __BCM_MAP_H
+
+#if defined(CONFIG_BCM96338)
+#include <6338_map.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_map.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_map.h>
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmadsl.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmadsl.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmadsl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmadsl.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,199 @@
+/*
+<:copyright-broadcom 
+ 
+ Copyright (c) 2002 Broadcom Corporation 
+ All Rights Reserved 
+ No portions of this material may be reproduced in any form without the 
+ written permission of: 
+          Broadcom Corporation 
+          16215 Alton Parkway 
+          Irvine, California 92619 
+ All information contained in this document is Broadcom Corporation 
+ company private, proprietary, and trade secret. 
+ 
+:>
+*/
+//**************************************************************************
+// File Name  : Adsl.h
+//
+// Description: This file contains the definitions, structures and function
+//              prototypes for ADSL PHY interface
+//
+//**************************************************************************
+#if !defined(_BCMADSL_H_)
+#define _BCMADSL_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* Incldes. */
+#include "AdslMibDef.h"
+
+//**************************************************************************
+// Type Definitions
+//**************************************************************************
+
+// Return status values
+typedef enum BcmAdslStatus
+{
+    BCMADSL_STATUS_SUCCESS = 0,
+    BCMADSL_STATUS_ERROR
+} BCMADSL_STATUS;
+
+// Return status values
+typedef enum AdslLinkState
+{
+    BCM_ADSL_LINK_UP = 0,
+    BCM_ADSL_LINK_DOWN,
+	BCM_ADSL_TRAINING_G992_EXCHANGE,
+	BCM_ADSL_TRAINING_G992_CHANNEL_ANALYSIS,
+	BCM_ADSL_TRAINING_G992_STARTED,
+	BCM_ADSL_TRAINING_G994,
+	BCM_ADSL_G994_NONSTDINFO_RECEIVED,
+    BCM_ADSL_BERT_COMPLETE,
+	BCM_ADSL_ATM_IDLE,
+    BCM_ADSL_EVENT,
+    BCM_ADSL_G997_FRAME_RECEIVED,
+    BCM_ADSL_G997_FRAME_SENT
+} ADSL_LINK_STATE;
+
+#ifndef DISABLE_ADSL_OLD_DEF
+#define	ADSL_LINK_UP		BCM_ADSL_LINK_UP
+#define	ADSL_LINK_DOWN		BCM_ADSL_LINK_DOWN
+#endif
+
+/* ADSL test modes */
+typedef enum AdslTestMode
+{
+    ADSL_TEST_NORMAL = 0,
+    ADSL_TEST_REVERB,
+    ADSL_TEST_MEDLEY,
+    ADSL_TEST_SELECT_TONES,
+    ADSL_TEST_NO_AUTO_RETRAIN,
+	ADSL_TEST_MARGIN_TWEAK,
+	ADSL_TEST_ESTIMATE_PLL_PHASE,
+	ADSL_TEST_REPORT_PLL_PHASE_STATUS,
+	ADSL_TEST_AFELOOPBACK,
+    ADSL_TEST_L3,
+    ADSL_TEST_DIAGMODE,
+    ADSL_TEST_L0
+} ADSL_TEST_MODE;
+
+// ADSL_CHANNEL_ADDR Contains ADSL Utopia PHY addresses
+typedef struct AdslChannelAddr
+{
+    UINT16 usFastChannelAddr;
+    UINT16 usInterleavedChannelAddr;
+} ADSL_CHANNEL_ADDR, *PADSL_CHANNEL_ADDR;
+
+// ADSL_CONNECTION_INFO Contains ADSL Connection Info
+typedef struct AdslConnectionInfo
+{
+	ADSL_LINK_STATE LinkState; 
+    UINT32 ulFastUpStreamRate;
+    UINT32 ulFastDnStreamRate;
+    UINT32 ulInterleavedUpStreamRate;
+    UINT32 ulInterleavedDnStreamRate;
+} ADSL_CONNECTION_INFO, *PADSL_CONNECTION_INFO;
+
+/* OEM parameter definition */
+#define ADSL_OEM_G994_VENDOR_ID       1    /* Vendor ID used during G.994 handshake */
+#define ADSL_OEM_G994_XMT_NS_INFO     2    /* G.994 non-standard info field to send */
+#define ADSL_OEM_G994_RCV_NS_INFO     3    /* G.994 received non-standard */
+#define ADSL_OEM_EOC_VENDOR_ID        4    /* EOC reg. 0 */
+#define ADSL_OEM_EOC_VERSION          5    /* EOC reg. 1 */
+#define ADSL_OEM_EOC_SERIAL_NUMBER    6    /* EOC reg. 2 */
+#define ADSL_OEM_T1413_VENDOR_ID      7    /* Vendor ID used during T1.413 handshake */
+#define ADSL_OEM_T1413_EOC_VENDOR_ID  8    /* EOC reg. 0 (vendor ID) in T1.413 mode */
+
+/* XMT gain definitions */
+#define ADSL_XMT_GAIN_AUTO			  0x80000000
+
+typedef struct
+{
+    int				diagCmd;
+    int				diagMap;
+    int				logTime;
+	int				srvIpAddr;
+	int				gwIpAddr;
+} ADSL_DIAG, *PADSL_DIAG;
+
+typedef struct
+{
+    short			x;
+    short			y;
+} ADSL_CONSTELLATION_POINT, *PADSL_CONSTELLATION_POINT;
+
+#define ADSL_CONSTEL_DATA_ID		0
+#define ADSL_CONSTEL_PILOT_ID		1
+
+#define ADSL_MIB_INFO	adslMibInfo
+typedef	ADSL_MIB_INFO   *PADSL_MIB_INFO;
+
+typedef void (*ADSL_FN_NOTIFY_CB) (ADSL_LINK_STATE AdslLinkState, UINT32 ulParm); 
+
+//**************************************************************************
+// Function Prototypes
+//**************************************************************************
+
+BCMADSL_STATUS BcmAdsl_Check(void);
+BCMADSL_STATUS BcmAdsl_Initialize(ADSL_FN_NOTIFY_CB pFnNotifyCb, UINT32 ulParm, adslCfgProfile *pAdslCfg);
+#ifdef LINUX
+BCMADSL_STATUS BcmAdsl_MapAtmPortIDs(UINT16 usAtmFastPortId, UINT16 usAtmInterleavedPortId);
+#endif
+BCMADSL_STATUS BcmAdsl_Uninitialize(void);
+BCMADSL_STATUS BcmAdsl_ConnectionStart(void);
+BCMADSL_STATUS BcmAdsl_ConnectionStop(void);
+BCMADSL_STATUS BcmAdsl_GetPhyAddresses(PADSL_CHANNEL_ADDR pChannelAddr);
+BCMADSL_STATUS BcmAdsl_SetPhyAddresses(PADSL_CHANNEL_ADDR pChannelAddr);
+BCMADSL_STATUS BcmAdsl_GetConnectionInfo(PADSL_CONNECTION_INFO pConnectionInfo);
+BCMADSL_STATUS BcmAdsl_DiagCommand(PADSL_DIAG pAdslDiag);
+int BcmAdsl_GetObjectValue(char *objId, int objIdLen, char *dataBuf, long *dataBufLen);
+BCMADSL_STATUS BcmAdsl_StartBERT(unsigned long totalBits);
+BCMADSL_STATUS BcmAdsl_StopBERT(void);
+BCMADSL_STATUS BcmAdsl_BertStartEx(unsigned long bertSec);
+BCMADSL_STATUS BcmAdsl_BertStopEx(void);
+BCMADSL_STATUS BcmAdsl_CheckPowerLoss(void);
+BCMADSL_STATUS BcmAdsl_SendDyingGasp(int powerCtl);
+BCMADSL_STATUS BcmAdsl_Configure(adslCfgProfile *pAdslCfg);
+BCMADSL_STATUS BcmAdsl_GetVersion(adslVersionInfo *pAdslVer);
+BCMADSL_STATUS BcmAdsl_SetSDRAMBaseAddr(void *pAddr);
+BCMADSL_STATUS BcmAdsl_SetVcEntry (int gfc, int port, int vpi, int vci);
+BCMADSL_STATUS BcmAdsl_SetVcEntryEx (int gfc, int port, int vpi, int vci, int pti_clp);
+
+BCMADSL_STATUS BcmAdsl_ResetStatCounters(void);
+BCMADSL_STATUS BcmAdsl_SetAtmLoopbackMode(void);
+BCMADSL_STATUS BcmAdsl_SetTestMode(ADSL_TEST_MODE testMode);
+BCMADSL_STATUS BcmAdsl_SelectTones(
+	int		xmtStartTone, 
+	int		xmtNumTones, 
+	int		rcvStartTone,
+	int		rcvNumTones, 
+	char	*xmtToneMap,
+	char	*rcvToneMap
+	);
+BCMADSL_STATUS BcmAdsl_SetDiagMode(int diagMode);
+
+int BcmAdsl_GetConstellationPoints (int toneId, ADSL_CONSTELLATION_POINT *pointBuf, int numPoints);
+
+int BcmAdsl_GetOemParameter (int paramId, void *buf, int len);
+int BcmAdsl_SetOemParameter (int paramId, void *buf, int len);
+int BcmAdsl_SetXmtGain(int gain);
+
+UINT32	BcmAdsl_GetSelfTestMode(void);
+void	BcmAdsl_SetSelfTestMode(UINT32 stMode);
+UINT32	BcmAdsl_GetSelfTestResults(void);
+
+BCMADSL_STATUS BcmAdsl_G997SendData(void *buf, int len);
+void *BcmAdsl_G997FrameGet(int *pLen);
+void *BcmAdsl_G997FrameGetNext(int *pLen);
+void  BcmAdsl_G997FrameFinished(void);
+void BcmAdsl_DyingGaspHandler(void *context);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // _BCMADSL_H_
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmatmapi.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmatmapi.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmatmapi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmatmapi.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,699 @@
+/*
+<:copyright-broadcom
+
+ Copyright (c) 2002 Broadcom Corporation
+ All Rights Reserved
+ No portions of this material may be reproduced in any form without the
+ written permission of:
+          Broadcom Corporation
+          16215 Alton Parkway
+          Irvine, California 92619
+ All information contained in this document is Broadcom Corporation
+ company private, proprietary, and trade secret.
+
+:>
+*/
+//**************************************************************************
+// File Name  : BcmAtmApi.h
+//
+// Description: This file contains the definitions, structures and function
+//              prototypes for the Broadcom Asynchronous Transfer Mode (ATM)
+//              Application Program Interface (API).
+//
+// Updates    : 09/15/2000  lat.  Created.
+//**************************************************************************
+
+#if !defined(_BCMATMAPI_H_)
+#define _BCMATMAPI_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+//**************************************************************************
+// Constant Definitions
+//**************************************************************************
+
+// ATM physical port constants.
+#define PHY_NUM_PORTS                       4
+#define PHY_0                               0
+#define PHY_1                               1
+#define PHY_2                               2 // [BCM635x Only]
+#define PHY_3                               3 // [BCM635x Only]
+
+// Used for backwards compatibility.
+#define PHY_UTOPIA0                         0
+#define PHY_UTOPIA1                         1
+#define PHY_UTOPIA2                         2
+#define PHY_UTOPIA3_TC_LOOPBACK             3
+
+// Values for ATM_PORT_CFG ucPortType.
+#define PT_DISABLED                         0
+#define PT_UTOPIA                           1
+#define PT_LOOPBACK                         2
+#define PT_TC                               3 // [BCM635x Only]
+#define PT_ADSL_INTERLEAVED                 4 // [BCM6345 Only]
+#define PT_ADSL_FAST                        5 // [BCM6345 Only]
+
+// Wildcard definitions.
+#define ALL_INTERFACES                      0xffffffff
+#define ANY_PRIORITY                        0xff
+
+// Values for ATM_TRAFFIC_DESCR_PARM_ENTRY ulTrafficDescrType.
+#define TDT_ATM_NO_TRAFFIC_DESCRIPTOR       1
+#define TDT_ATM_NO_CLP_NO_SCR               2
+#define TDT_ATM_CLP_NO_TAGGING_NO_SCR       3
+#define TDT_ATM_CLP_TAGGING_NO_SCR          4
+#define TDT_ATM_NO_CLP_SCR                  5
+#define TDT_ATM_CLP_NO_TAGGING_SCR          6 // [BCM635x Only]
+#define TDT_ATM_CLP_TAGGING_SCR             7 // [BCM635x Only]
+#define TDT_ATM_CLP_NO_TAGGING_MCR          8 // [BCM6348 Only]
+#define TDT_ATM_CLP_TRANSPARENT_NO_SCR      9
+#define TDT_ATM_CLP_TRANSPARENT_SCR         10
+#define TDT_ATM_NO_CLP_TAGGING_NO_SCR       11
+#define TDT_ATM_NO_CLP_NO_SCR_CDVT          12
+#define TDT_ATM_NO_CLP_SCR_CDVT             13
+#define TDT_ATM_CLP_NO_TAGGING_SCR_CDVT     14 // [BCM635x Only]
+#define TDT_ATM_CLP_TAGGING_SCR_CDVT        15 // [BCM635x Only]
+
+// Values for ATM_TRAFFIC_DESCR_PARM_ENTRY ulTrafficDescrRowStatus.
+#define TDRS_ACTIVE                         1
+#define TDRS_NOT_IN_SERVICE                 2
+
+// Values for ATM_TRAFFIC_DESCR_PARM_ENTRY ulServiceCategory.
+#define SC_OTHER                            1
+#define SC_CBR                              2
+#define SC_RT_VBR                           3
+#define SC_NRT_VBR                          4
+#define SC_UBR                              6
+
+// Values for ATM_INTERFACE_CFG ulIfAdminStatus and ATM_VCC_CFG
+// ulAtmVclAdminStatus.
+#define ADMSTS_UP                           1
+#define ADMSTS_DOWN                         2
+#define ADMSTS_TESTING                      3
+
+// Values for ATM_INTERFACE_CFG ulIfOperStatus and ATM_VCC_CFG
+// ulAtmVclOperStatus.
+#define OPRSTS_UP                           1
+#define OPRSTS_DOWN                         2
+#define OPRSTS_UNKNOWN                      3
+
+// Values for ATM_INTERFACE_LINK_INFO ulLinkState.
+#define LINK_UP                             1
+#define LINK_DOWN                           2
+
+// Values for ulAalType.
+#define AAL_2                               0 // [BCM635x Only]
+#define AAL_TRANSPARENT                     1
+#define AAL_0_PACKET                        2
+#define AAL_0_CELL_CRC                      3
+#define AAL_5                               7
+
+// Values for ATM_VCC_CFG ulAtmVccEncapsType.
+#define ET_VC_MULTIPLEX_ROUTED_PROTOCOL     1
+#define ET_VC_MULTIPLEX_BRG_PROTOCOL_8023   2
+#define ET_VC_MULTIPLEX_BRG_PROTOCOL_8025   3
+#define ET_VC_MULTIPLEX_BRG_PROTOCOL_8026   4
+#define ET_VC_MULTIPLEX_LAN_EMULATION_8023  5
+#define ET_VC_MULTIPLEX_LAN_EMULATION_8025  6
+#define ET_LLC_ENCAPSULATION                7
+#define ET_MULTI_PROTOCOL_FRAME_RELAY_SSCS  8
+#define ET_OTHER                            9
+#define ET_UNKNOWN                          10
+
+// [BCM635x Only] Values for ATM_AAL2_VCC_CFG ucAal2CpsOptimisation.
+#define OPT_SNG_PKT_PER_PDU_NO_OVERLAP      1
+#define OPT_MULT_PKTS_PER_PDU_OVERLAP       2
+
+// [BCM635x Only] Values for ATM_INTERFACE_STATS ulTcAlarmState.
+#define TCALM_NO_ALARM                      1
+#define TCALM_LCD_FAILURE                   2
+
+// Values for ATM_NOTIFY_PARMS ulNotificationType.
+#define ATM_NOTIFY_INTERFACE_CHANGE         1
+
+// Values for AN_INTF_CHANGE_PARMS ulInterfaceState.
+#define ATM_INTERFACE_UP                    1
+#define ATM_INTERFACE_DOWN                  2
+
+// Values for AN_VCC_CHANGE_PARMS ulInterfaceState.
+#define ATM_VCC_UP                          1
+#define ATM_VCC_DOWN                        2
+
+// Values for ATM_VCC_ATTACH_PARMS ulFlags.
+#define AVAP_ALLOW_OAM_F5_SEGMENT_CELLS     0x0001
+#define AVAP_ALLOW_OAM_F5_END_TO_END_CELLS  0x0002
+#define AVAP_ALLOW_RM_CELLS                 0x0004
+#define AVAP_ALLOW_OAM_F4_SEGMENT_CELLS     0x0008
+#define AVAP_ALLOW_OAM_F4_END_TO_END_CELLS  0x0010
+#define AVAP_ALLOW_CELLS_WITH_ERRORS        0x0020
+#define AVAP_ADD_AAL0_CRC10                 0x0040
+#define AVAP_DSP                            0x8000 // [BCM635x Only]
+
+// [BCM635x Only] Values for ATM_VCC_AAL2_CHANNEL_ID_PARMS ucVoiceRouting.
+#define VOICE_ROUTE_MIPS                    0
+#define VOICE_ROUTE_DSP                     2
+
+// [BCM635x Only] Values for ATM_VCC_AAL2_CHANNEL_ID_PARMS ucFlags.
+#define CID_USE_FRAME_MODE                  0x01
+
+// Values for ATM_VCC_DATA_PARMS ucCircuitType.
+#define CT_AAL0_PACKET                      0x02
+#define CT_AAL0_CELL_CRC                    0x03
+#define CT_OAM_F5_SEGMENT                   0x04
+#define CT_OAM_F5_END_TO_END                0x05
+#define CT_RM                               0x06
+#define CT_AAL5                             0x07
+#define CT_HDLC_PACKET                      0x08 // [BCM6348 Only]
+#define CT_ANY_AAL2_MASK                    0x08 // [BCM635x Only]
+#define CT_AAL2_ALARM                       0x08 // [BCM635x Only]
+#define CT_AAL2_TYPE_3                      0x09 // [BCM635x Only]
+#define CT_AAL2_TYPE_1                      0x0A // [BCM635x Only]
+#define CT_AAL2_FRAME                       0x0B // [BCM635x Only]
+#define CT_TRANSPARENT                      0x10
+#define CT_OAM_F4_ANY                       0x20
+
+// OAM F4 VCI values.
+#define VCI_OAM_F4_SEGMENT                  3
+#define VCI_OAM_F4_END_TO_END               4
+#define VCI_RM                              6
+
+// Values for ATM_VCC_DATA_PARMS ucFlags.
+#define ATMDATA_CI                          0x04
+#define ATMDATA_CLP                         0x08
+
+// [BCM635x Only] DSP specific values.
+#define DSP_VCID                            31
+
+// ATM cell layer interface name
+#define ATM_CELL_LAYER_IFNAME               "atm0"
+
+// AAL5 CPCS layer interface name
+#define AAL5_CPCS_LAYER_IFNAME              "cpcs0"
+
+//**************************************************************************
+// Type Definitions
+//**************************************************************************
+
+// Return status values
+typedef enum BcmAtmStatus
+{
+    STS_SUCCESS = 0,
+    STS_ERROR,
+    STS_STATE_ERROR,
+    STS_PARAMETER_ERROR,
+    STS_ALLOC_ERROR,
+    STS_RESOURCE_ERROR,
+    STS_IN_USE,
+    STS_VCC_DOWN,
+    STS_INTERFACE_DOWN,
+    STS_LINK_DOWN,
+    STS_NOT_FOUND,
+    STS_NOT_SUPPORTED,
+    STS_VCAM_MULT_MATCH_ERROR,
+    STS_CCAM_MULT_MATCH_ERROR,
+    STS_PKTERR_INVALID_VPI_VCI,
+    STS_PKTERR_PORT_NOT_ENABLED,
+    STS_PKTERR_HEC_ERROR,
+    STS_PKTERR_PTI_ERROR,
+    STS_PKTERR_RECEIVED_IDLE_CELL,
+    STS_PKTERR_CIRCUIT_TYPE_ERROR,
+    STS_PKTERR_OAM_RM_CRC_ERROR,
+    STS_PKTERR_GFC_ERROR,
+    STS_PKTERR_AAL5_AAL0_CRC_ERROR,
+    STS_PKTERR_AAL5_AAL0_SHORT_PKT_ERROR,
+    STS_PKTERR_AAL5_AAL0_LENGTH_ERROR,
+    STS_PKTERR_AAL5_AAL0_BIG_PKT_ERROR,
+    STS_PKTERR_AAL5_AAL0_SAR_TIMEOUT_ERROR,
+    STS_PKTERR_AAL2F_HEC_ERROR,
+    STS_PKTERR_AAL2F_SEQ_NUM_ERROR,
+    STS_PKTERR_AAL2F_PARITY_ERROR,
+    STS_PKTERR_AAL2F_CRC_ERROR,
+    STS_PKTERR_AAL2F_CAM_ERROR,
+    STS_PKTERR_AAL2F_BIG_PKT_ERROR,
+    STS_PKTERR_AAL2F_RAS_TIMEOUT_ERROR,
+    STS_PKTERR_AAL2F_SHORT_PKT_ERROR,
+    STS_PKTERR_AAL2F_LENGTH_MISMATCH_ERROR,
+    STS_PKTERR_AAL2V_HEC_ERROR,
+    STS_PKTERR_AAL2V_SEQ_NUM_ERROR,
+    STS_PKTERR_AAL2V_PARITY_ERROR,
+    STS_PKTERR_AAL2V_CRC_ERROR,
+    STS_PKTERR_AAL2V_CAM_ERROR,
+    STS_PKTERR_AAL2V_OSF_MISMATCH_ERROR,
+    STS_PKTERR_AAL2V_OSF_ERROR,
+    STS_PKTERR_AAL2V_HEC_OVERLAP_ERROR,
+    STS_PKTERR_AAL2V_BIG_PKT_ERROR,
+    STS_PKTERR_AAL2V_RAS_ERROR,
+    STS_PKTERR_AAL2V_UUI_ERROR
+} BCMATM_STATUS;
+
+
+// ATM_VCC_ADDR identifies a Virtual Channel Connection (VCC).
+typedef struct AtmVccAddr
+{
+    UINT32 ulInterfaceId;
+    UINT16 usVpi;
+    UINT16 usVci;
+} ATM_VCC_ADDR, *PATM_VCC_ADDR;
+
+
+// ATM_PORT_CFG contains ATM physical port configuration parameters.
+typedef struct AtmPortCfg
+{
+    UINT32 ulInterfaceId;
+    UINT8 ucPortType;
+    UINT8 ucPortAddr;
+    UINT8 ucReserved[2];
+} ATM_PORT_CFG, *PATM_PORT_CFG;
+
+
+// ATM_INITIALIZATION_PARMS contains ATM API module initialization parameters.
+#define ID_ATM_INITIALIZATION_PARMS         2
+typedef struct AtmInitialization
+{
+    UINT32 ulStructureId;
+    UINT32 ulThreadPriority;
+    UINT16 usFreeCellQSize;
+    UINT16 usFreePktQSize;
+    UINT16 usFreePktQBufferSize;
+    UINT16 usFreePktQBufferOffset; // offset into buffer to start receiving data
+    UINT16 usReceiveCellQSize;
+    UINT16 usReceivePktQSize;
+    UINT8  ucTransmitFifoPriority; // [BCM635x Only]
+    UINT8  ucReserved;
+    UINT16 usAal5CpcsMaxSduLength;
+    UINT16 usAal2SscsMaxSsarSduLength; // [BCM635x Only]
+    ATM_PORT_CFG PortCfg[PHY_NUM_PORTS];
+} ATM_INITIALIZATION_PARMS, *PATM_INITIALIZATION_PARMS;
+
+
+// ATM_TRAFFIC_DESCR_PARM_ENTRY contains the fields needed to create a Traffic
+// Descriptor Table parameter entry.
+#define ID_ATM_TRAFFIC_DESCR_PARM_ENTRY     1
+typedef struct AtmTrafficDescrParmEntry
+{
+    UINT32 ulStructureId;
+    UINT32 ulTrafficDescrIndex;
+    UINT32 ulTrafficDescrType;
+    UINT32 ulTrafficDescrParm1;
+    UINT32 ulTrafficDescrParm2;
+    UINT32 ulTrafficDescrParm3;
+    UINT32 ulTrafficDescrParm4;
+    UINT32 ulTrafficDescrParm5;
+    UINT32 ulTrafficDescrRowStatus;
+    UINT32 ulServiceCategory;
+    UINT32 ulTrafficFrameDiscard;
+} ATM_TRAFFIC_DESCR_PARM_ENTRY, *PATM_TRAFFIC_DESCR_PARM_ENTRY;
+
+
+// ATM_INTERFACE_CFG contains configuration fields for an ATM interface.
+#define ID_ATM_INTERFACE_CFG                3
+typedef struct AtmInterfaceCfg
+{
+    UINT32 ulStructureId;
+    UINT32 ulAtmInterfaceMaxVccs;
+    UINT32 ulAtmInterfaceConfVccs;
+    UINT32 ulAtmInterfaceMaxActiveVpiBits;
+    UINT32 ulAtmInterfaceMaxActiveVciBits;
+    UINT32 ulAtmInterfaceCurrentMaxVpiBits;
+    UINT32 ulAtmInterfaceCurrentMaxVciBits;
+    UINT32 ulIfAdminStatus;
+    UINT32 ulIfOperStatus;                  // read-only
+    UINT32 ulSendNullCells;
+    UINT32 ulTcScramble;
+    UINT32 ulPortType;                      // read-only
+    UINT32 ulIfLastChange;
+} ATM_INTERFACE_CFG, *PATM_INTERFACE_CFG;
+
+
+// ATM_VCC_TRANSMIT_QUEUE_PARMS contains fields for configuring an transmit
+// queue.
+#define ID_ATM_VCC_TRANSMIT_QUEUE_PARMS     1
+typedef struct AtmVccTransmitQueueParms
+{
+    UINT32 ulStructureId;
+    UINT32 ulSize;
+    UINT32 ulPriority;
+    UINT32 ulReserved;
+} ATM_VCC_TRANSMIT_QUEUE_PARMS, *PATM_VCC_TRANSMIT_QUEUE_PARMS;
+
+
+// ATM_AAL5_VCC_CFG contains configuration fields for an ATM AAL5 Virtual
+// Channel Connection (VCC).
+typedef struct AtmAal5VccCfg
+{
+    UINT32 ulAtmVccEncapsType;
+    UINT32 ulAtmVccCpcsAcceptCorruptedPdus;
+} ATM_AAL5_VCC_CFG, *PATM_AAL5_VCC_CFG;
+
+
+// [BCM635x Only] ATM_AAL2_VCC_CFG contains configuration fields for an ATM
+// AAL2 Virtual Channel Connection (VCC).
+typedef struct AtmAal2VccCfg
+{
+    UINT8 ucAal2CpsMaxMultiplexedChannels;
+    UINT8 ucAal2CpsMaxSduLength;
+    UINT8 ucAal2CpsCidLowerLimit;
+    UINT8 ucAal2CpsCidUpperLimit;
+    UINT8 ucAal2CpsOptimisation;
+    UINT8 ucReserved[3];
+} ATM_AAL2_VCC_CFG, *PATM_AAL2_VCC_CFG;
+
+
+// ATM_AAL0_VCC_CFG contains configuration fields for an ATM AAL0 Virtual
+// Channel Connection (VCC).
+typedef struct AtmAal0VccCfg
+{
+    UINT8 ucReserved;
+    // Reserved for future use.
+} ATM_AAL0_VCC_CFG, *PATM_AAL0_VCC_CFG;
+
+
+// ATM_VCC_CFG contains configuration fields for an ATM Virtual Channel
+// Connection (VCC).
+#define ID_ATM_VCC_CFG                      2
+#define TX_Q_PARM_SIZE                      8
+typedef struct AtmVccCfg
+{
+    UINT32 ulStructureId;
+    UINT32 ulAalType;
+    UINT32 ulAtmVclAdminStatus;
+    UINT32 ulAtmVclOperStatus;
+    UINT32 ulAtmVclLastChange;
+    UINT32 ulAtmVclReceiveTrafficDescrIndex;
+    UINT32 ulAtmVclTransmitTrafficDescrIndex;
+    UINT32 ulTransmitQParmsSize;
+    ATM_VCC_TRANSMIT_QUEUE_PARMS TransmitQParms[TX_Q_PARM_SIZE];
+    union
+    {
+        ATM_AAL5_VCC_CFG Aal5Cfg;
+        ATM_AAL2_VCC_CFG Aal2Cfg; // [BCM635x Only]
+        ATM_AAL0_VCC_CFG Aal0Cfg;
+    } u;
+} ATM_VCC_CFG, *PATM_VCC_CFG;
+
+
+// ATM_INTF_ATM_STATS contains statistics for the ATM layer of an interface.
+typedef struct AtmIntfAtmStats
+{
+    UINT32 ulIfInOctets;
+    UINT32 ulIfOutOctets;
+    UINT32 ulIfInErrors;
+    UINT32 ulIfInUnknownProtos;
+    UINT32 ulIfOutErrors;
+
+    // The following fields are added together to calculate ulIfInErrors.
+    UINT32 ulIfInHecErrors;
+
+    // The following fields are added together to calculate ulIfInUnknownProtos.
+    UINT32 ulIfInInvalidVpiVciErrors;
+    UINT32 ulIfInPortNotEnabledErrors;
+    UINT32 ulIfInPtiErrors;
+    UINT32 ulIfInIdleCells;
+    UINT32 ulIfInCircuitTypeErrors;
+    UINT32 ulIfInOamRmCrcErrors;
+    UINT32 ulIfInGfcErrors;
+} ATM_INTF_ATM_STATS, *PATM_INTF_ATM_STATS;
+
+
+// [BCM635x Only] ATM_INTF_ATM_STATS contains statistics for the TC layer.
+typedef struct AtmIntfTcStats
+{
+    UINT32 ulTcInDataCells;
+    UINT32 ulTcInTotalCells;
+    UINT32 ulTcInHecErrors;
+    UINT32 ulTcInOcdEvents;
+    UINT32 ulTcAlarmState;
+} ATM_INTF_TC_STATS, *PATM_INTF_TC_STATS;
+
+
+// ATM_INTF_AAL5_AAL0_STATS contains statistics for all AAL5/AAL0 VCCs on an
+// ATM interface.
+typedef struct AtmIntfAal5Aal0Stats
+{
+    UINT32 ulIfInOctets;
+    UINT32 ulIfOutOctets;
+    UINT32 ulIfInUcastPkts;
+    UINT32 ulIfOutUcastPkts;
+    UINT32 ulIfInErrors;
+    UINT32 ulIfOutErrors;
+    UINT32 ulIfInDiscards;
+    UINT32 ulIfOutDiscards;
+} ATM_INTF_AAL5_AAL0_STATS, *PATM_INTF_AAL5_AAL0_STATS;
+
+
+// [BCM635x Only] ATM_INTF_AAL2_STATS contains statistics for all AAL2 VCCs
+// on an ATM interface.
+typedef struct AtmIntfAal2Stats
+{
+    UINT32 ulIfInOctets;
+    UINT32 ulIfOutOctets;
+    UINT32 ulIfInUcastPkts;
+    UINT32 ulIfOutUcastPkts;
+    UINT32 ulIfInErrors;
+    UINT32 ulIfOutErrors;
+    UINT32 ulIfInDiscards;
+    UINT32 ulIfOutDiscards;
+} ATM_INTF_AAL2_STATS, *PATM_INTF_AAL2_STATS;
+
+
+// ATM_INTERFACE_STATS contains statistics for an ATM interface.
+#define ID_ATM_INTERFACE_STATS              1
+typedef struct AtmInterfaceStats
+{
+    UINT32 ulStructureId;
+    ATM_INTF_ATM_STATS       AtmIntfStats;
+    ATM_INTF_TC_STATS        TcIntfStats;   // [BCM635x Only]
+    ATM_INTF_AAL5_AAL0_STATS Aal5IntfStats;
+    ATM_INTF_AAL2_STATS      Aal2IntfStats; // [BCM635x Only]
+    ATM_INTF_AAL5_AAL0_STATS Aal0IntfStats;
+} ATM_INTERFACE_STATS, *PATM_INTERFACE_STATS;
+
+
+// ATM_VCC_AAL5_STATS contains statistics for an AAL5 VCC.
+typedef struct AtmVccAal5Stats
+{
+    UINT32 ulAal5VccCrcErrors;
+    UINT32 ulAal5VccSarTimeOuts;
+    UINT32 ulAal5VccOverSizedSdus;
+    UINT32 ulAal5VccShortPacketErrors;
+    UINT32 ulAal5VccLengthErrors;
+} ATM_VCC_AAL5_STATS, *PATM_VCC_AAL5_STATS;
+
+
+// [BCM635x Only] ATM_VCC_AAL2_STATS contains statistics for an AAL2 VCC.
+typedef struct AtmVccAal2Stats
+{
+    UINT32 ulAal2CpsInPkts;
+    UINT32 ulAal2CpsOutPkts;
+    UINT32 ulAal2CpsParityErrors;
+    UINT32 ulAal2CpsSeqNumErrors;
+    UINT32 ulAal2CpsOsfMismatchErrors;
+    UINT32 ulAal2CpsOsfErrors;
+    UINT32 ulAal2CpsHecOverlapErrors;
+    UINT32 ulAal2CpsHecErrors;
+    UINT32 ulAal2CpsOversizedSduErrors;
+    UINT32 ulAal2CpsReassemblyErrors;
+    UINT32 ulAal2CpsUuiErrors;
+    UINT32 ulAal2CpsCidErrors;
+    UINT32 ulAal2SscsOversizedSssarSduErrors;
+    UINT32 ulAal2SscsSssarRasTimerExipiryErrors;
+    UINT32 ulAal2SscsUndersizedSstedPduErrors;
+    UINT32 ulAal2SscsSstedPduLengthMismatchErrors;
+    UINT32 ulAal2SscsSstedCrcMismatchErrors;
+} ATM_VCC_AAL2_STATS, *PATM_VCC_AAL2_STATS;
+
+
+// ATM_VCC_AAL0PKT_STATS contains statistics for an AAL0 Packet VCC.
+typedef struct AtmVccAal0PktStats
+{
+    UINT32 ulAal0VccSarTimeOuts;
+    UINT32 ulAal0VccOverSizedSdus;
+} ATM_VCC_AAL0PKT_STATS, *PATM_VCC_AAL0PKT_STATS;
+
+
+// ATM_VCC_AAL0CELL_STATS contains statistics for an AAL0 Cell with CRC VCC.
+typedef struct AtmVccAal0CellStats
+{
+    UINT32 ulAal0VccCrcErrors;
+} ATM_VCC_AAL0CELL_STATS, *PATM_VCC_AAL0CELL_STATS;
+
+
+// ATM_VCC_STATS contains statistics for a VCC.
+#define ID_ATM_VCC_STATS                    1
+typedef struct AtmVccStatistics
+{
+    UINT32 ulStructureId;
+    UINT32 ulAalType;
+    union
+    {
+        ATM_VCC_AAL5_STATS AtmVccAal5Stats;
+        ATM_VCC_AAL2_STATS AtmVccAal2Stats; // [BCM635x Only]
+        ATM_VCC_AAL0PKT_STATS AtmVccAal0PktStats;
+        ATM_VCC_AAL0CELL_STATS AtmVccAal0CellStats;
+    } u;
+} ATM_VCC_STATS, *PATM_VCC_STATS;
+
+
+// ATM_INTERFACE_LINK_INFO contains fields for the physical link that the
+// ATM interface is using.
+#define ID_ATM_INTERFACE_LINK_INFO          1
+typedef struct AtmInterfaceLinkInfo
+{
+    UINT32 ulStructureId;
+    UINT32 ulLinkState;
+    UINT32 ulLineRate;
+    UINT32 ulReserved[2];
+} ATM_INTERFACE_LINK_INFO, *PATM_INTERFACE_LINK_INFO;
+
+
+// AN_INTF_CHANGE_PARMS contains notification fields that passed to an
+// application callback function when the ATM interface goes up or down.
+#define ID_AN_INTF_CHANGE_PARMS             1
+typedef struct AnIntfChangeParms
+{
+    UINT32 ulInterfaceId;
+    UINT32 ulInterfaceState;
+    UINT32 ulInterfaceLineRate;
+} AN_INTF_CHANGE_PARMS, *PAN_INTF_CHANGE_PARMS;
+
+
+// ATM_NOTIFY_PARMS contains notification fields that passed to an application
+// callback function when an ATM notification event occurs.
+typedef struct AtmNotifyParms
+{
+    UINT32 ulNotifyType;
+    union
+    {
+        AN_INTF_CHANGE_PARMS IntfChangeParms;
+
+        // Other fields and structures that are specific
+        // to the type of notification are declared here.
+    } u;
+} ATM_NOTIFY_PARMS, *PATM_NOTIFY_PARMS;
+
+typedef void (*FN_NOTIFY_CB) (PATM_NOTIFY_PARMS pNotifyParms);
+
+
+// ATM_VCC_ATTACH_PARMS contains fields for attaching to a VCC.  It is used
+// by all BcmAtm_Attach... functions.
+struct AtmVccDataParms;
+typedef void (*FN_RECEIVE_CB) (UINT32 ulHandle, PATM_VCC_ADDR pVccAddr,
+    struct AtmVccDataParms *pDataParms, UINT32 ulParmReceiveData);
+
+#define ID_ATM_VCC_ATTACH_PARMS             1
+typedef struct AtmAttachParms
+{
+    UINT32 ulStructureId;
+    UINT32 ulFlags;
+    FN_RECEIVE_CB pFnReceiveDataCb;
+    UINT32 ulParmReceiveData;
+    ATM_VCC_TRANSMIT_QUEUE_PARMS *pTransmitQParms;
+    UINT32 ulTransmitQParmsSize;
+    UINT32 ulHandle;
+    UINT32 ulReserved;
+} ATM_VCC_ATTACH_PARMS, *PATM_VCC_ATTACH_PARMS;
+
+
+// [BCM635x Only] ATM_VCC_AAL2_CHANNEL_ID_PARMS contains fields for
+// configuring an transmit queue.
+#define ID_ATM_VCC_AAL2_CHANNEL_ID_PARMS    1
+typedef struct AtmVccAal2ChannelIdParms
+{
+    UINT32 ulStructureId;
+    UINT8 ucChannelId;
+    UINT8 ucVoiceRouting;
+    UINT8 ucFlags;
+    UINT8 ucReserved[5];
+} ATM_VCC_AAL2_CHANNEL_ID_PARMS, *PATM_VCC_AAL2_CHANNEL_ID_PARMS;
+
+
+// ATM_BUFFER contains fields for passing data to, and receive data from, the
+// ATM API.
+typedef struct AtmBuffer
+{
+    struct AtmBuffer *pNextAtmBuf;
+    UINT8 *pDataBuf;
+    UINT32 ulDataLen;
+    UINT16 usDataOffset;
+    UINT16 usReserved;
+    UINT32 ulReserved;
+} ATM_BUFFER, *PATM_BUFFER;
+
+
+// ATM_VCC_DATA_PARMS contains fields for sending or receiving data on a VCC.
+// It is used by all BcmAtm_Send... and receive functions.
+typedef void (*FN_FREE_DATA_PARMS) (struct AtmVccDataParms *pDataParms);
+
+#define ID_ATM_VCC_DATA_PARMS               2
+typedef struct AtmVccDataParms
+{
+    UINT32 ulStructureId;
+    UINT8 ucCircuitType;
+    UINT8 ucAal2ChannelId; // [BCM635x Only]
+    UINT8 ucUuData8;
+    UINT8 ucUuData5;
+    UINT8 ucFlags;
+    UINT8 ucSendPriority;
+    UINT8 ucReserved[2];
+    BCMATM_STATUS baReceiveStatus;
+    PATM_BUFFER pAtmBuffer;
+    FN_FREE_DATA_PARMS pFnFreeDataParms;
+    UINT32 ulParmFreeDataParms;
+    struct AtmVccDataParms *pApplicationLink;
+    UINT32 ulApplicationDefined[2];
+} ATM_VCC_DATA_PARMS, *PATM_VCC_DATA_PARMS;
+
+
+//**************************************************************************
+// Function Prototypes
+//**************************************************************************
+
+BCMATM_STATUS BcmAtm_Initialize( PATM_INITIALIZATION_PARMS pInitValues );
+BCMATM_STATUS BcmAtm_Uninitialize( void );
+BCMATM_STATUS BcmAtm_GetInterfaceId( UINT8 ucPhyPort, UINT32 *pulInterfaceId );
+BCMATM_STATUS BcmAtm_GetTrafficDescrTableSize(UINT32 *pulTrafficDescrTableSize);
+BCMATM_STATUS BcmAtm_GetTrafficDescrTable( PATM_TRAFFIC_DESCR_PARM_ENTRY
+    pTrafficDescTable, UINT32 ulTrafficDescrTableSize );
+BCMATM_STATUS BcmAtm_SetTrafficDescrTable( PATM_TRAFFIC_DESCR_PARM_ENTRY
+    pTrafficDescTable, UINT32  ulTrafficDescrTableSize );
+BCMATM_STATUS BcmAtm_GetInterfaceCfg( UINT32 ulInterfaceId, PATM_INTERFACE_CFG
+    pInterfaceCfg );
+BCMATM_STATUS BcmAtm_SetInterfaceCfg( UINT32 ulInterfaceId, PATM_INTERFACE_CFG
+    pInterfaceCfg );
+BCMATM_STATUS BcmAtm_GetVccCfg( PATM_VCC_ADDR pVccAddr, PATM_VCC_CFG pVccCfg );
+BCMATM_STATUS BcmAtm_SetVccCfg( PATM_VCC_ADDR pVccAddr, PATM_VCC_CFG pVccCfg );
+BCMATM_STATUS BcmAtm_GetVccAddrs( UINT32 ulInterfaceId, PATM_VCC_ADDR pVccAddrs,
+    UINT32 ulNumVccs, UINT32 *pulNumReturned );
+BCMATM_STATUS BcmAtm_GetInterfaceStatistics( UINT32 ulInterfaceId,
+    PATM_INTERFACE_STATS pStatistics, UINT32 ulReset );
+BCMATM_STATUS BcmAtm_GetVccStatistics( PATM_VCC_ADDR pVccAddr, PATM_VCC_STATS
+    pVccStatistics, UINT32 ulReset );
+BCMATM_STATUS BcmAtm_SetInterfaceLinkInfo( UINT32 ulInterfaceId,
+    PATM_INTERFACE_LINK_INFO pInterfaceCfg );
+BCMATM_STATUS BcmAtm_SetNotifyCallback( FN_NOTIFY_CB pFnNotifyCb );
+BCMATM_STATUS BcmAtm_ResetNotifyCallback( FN_NOTIFY_CB pFnNotifyCb );
+BCMATM_STATUS BcmAtm_AttachVcc( PATM_VCC_ADDR pVccAddr, PATM_VCC_ATTACH_PARMS
+    pAttachParms );
+BCMATM_STATUS BcmAtm_AttachMgmtCells( UINT32 ulInterfaceId,
+    PATM_VCC_ATTACH_PARMS pAttachParms );
+BCMATM_STATUS BcmAtm_AttachTransparent( UINT32 ulInterfaceId,
+    PATM_VCC_ATTACH_PARMS pAttachParms );
+BCMATM_STATUS BcmAtm_Detach( UINT32 ulHandle );
+BCMATM_STATUS BcmAtm_SetAal2ChannelIds( UINT32 ulHandle,
+    PATM_VCC_AAL2_CHANNEL_ID_PARMS pChannelIdParms, UINT32
+    ulNumChannelIdParms ); // [BCM635x Only]
+BCMATM_STATUS BcmAtm_SendVccData( UINT32 ulHandle,
+    PATM_VCC_DATA_PARMS pDataParms );
+BCMATM_STATUS BcmAtm_SendMgmtData( UINT32 ulHandle, PATM_VCC_ADDR pVccAddr,
+    PATM_VCC_DATA_PARMS pDataParms );
+BCMATM_STATUS BcmAtm_SendTransparentData( UINT32 ulHandle, UINT32 ulInterfaceId,
+    PATM_VCC_DATA_PARMS pDataParms );
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // _BCMATMAPI_H_
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmnet.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmnet.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmnet.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmnet.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+<:copyright-gpl
+ Copyright 2002 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  bcmnet.h                                                 */
+/*   DATE:    05/16/02                                                 */
+/*   PURPOSE: network interface ioctl definition                       */
+/*                                                                     */
+/***********************************************************************/
+#ifndef _IF_NET_H_
+#define _IF_NET_H_
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#define LINKSTATE_DOWN      0
+#define LINKSTATE_UP        1
+
+/*---------------------------------------------------------------------*/
+/* Ethernet Switch Type                                                */
+/*---------------------------------------------------------------------*/
+#define ESW_TYPE_UNDEFINED                  0
+#define ESW_TYPE_BCM5325M                   1
+#define ESW_TYPE_BCM5325E                   2
+#define ESW_TYPE_BCM5325F                   3
+
+/*
+ * Ioctl definitions.
+ */
+/* reserved SIOCDEVPRIVATE */
+enum {
+    SIOCGLINKSTATE = SIOCDEVPRIVATE + 1,
+    SIOCSCLEARMIBCNTR,
+    SIOCGIFTRANSSTART,
+    SIOCMIBINFO,
+    SIOCSDUPLEX,	/* 0: auto 1: full 2: half */
+    SIOCSSPEED,		/* 0: auto 1: 100mbps 2: 10mbps */
+    SIOCCIFSTATS,
+    SIOCGENABLEVLAN,
+    SIOCGDISABLEVLAN,
+    SIOCGQUERYNUMVLANPORTS,
+    SIOCGSWITCHTYPE,
+    SIOCGQUERYNUMPORTS,
+    SIOCLAST
+};
+
+#define SPEED_10MBIT        10000000
+#define SPEED_100MBIT       100000000
+
+typedef struct IoctlMibInfo
+{
+    unsigned long ulIfLastChange;
+    unsigned long ulIfSpeed;
+} IOCTL_MIB_INFO, *PIOCTL_MIB_INFO;
+
+
+#if __cplusplus
+}
+#endif
+
+#endif /* _IF_NET_H_ */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmos.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmos.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/bcmos.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/bcmos.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,98 @@
+/***************************************************************************
+*    Copyright 2000  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16251 Laguna Canyon Road
+*             Irvine, California  92618
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: bcmos.h
+*    Creation Date: 8 June 2000 (v0.00)
+*    VSS Info:
+*        $Revision: 16 $
+*        $Date: 5/03/01 5:03p $
+*
+****************************************************************************
+*    Description:
+*
+*      Broadcom Generic Operating System Functions.
+*
+****************************************************************************/
+
+#ifndef _BCMOS_H
+#define _BCMOS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __KERNEL__
+#include <cxcEnv.h>
+#include <bosSleep.h>
+#include <bosTask.h>
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <bcmtypes.h>
+
+#define malloc(arg) kmalloc(arg, GFP_KERNEL)
+#define free(arg) kfree(arg)
+
+#define BCMOS_ASSERT(expr) \
+if ((expr)? 0:1)                                                     \
+{                                                                    \
+   printk(" ASSERT !!! File %s, line %u \n", __FILE__, __LINE__);    \
+   bosSleep( 10 );                                                 \
+   cli();   /* Disable interrupts */                                 \
+   while(1){ ; }                                                     \
+}
+
+#define CXC_ASSERT BCMOS_ASSERT		// For compatibility with CX's endpoint
+
+/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
+/*  Special BOS definitions   */
+/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
+#define DSL_NO_RESETSUPPORT
+
+
+#define  bosSocketHtoNL( num )   ((UINT32)( num ))
+#define  bosSocketHtoNS( num )   ((UINT16)( num ))
+#define  bosSocketNtoHL( num )   ((UINT32)( num ))
+#define  bosSocketNtoHS( num )   ((UINT16)( num ))
+#define  bosSocketNtoHS( num )   ((UINT16)( num ))
+#define  bosSocketNtoHU16  bosSocketNtoHS
+
+
+#else /* LINUX */
+
+#include <cxcEnv.h>
+#include <assert.h>
+#include <string.h>
+#include <malloc.h>
+
+#define BCMOS_TASKNAME( nameVar, nameStr ) char nameVar[] = nameStr
+
+#define TEN_MSEC           10
+#define TWENTY_MSEC        20
+#define ONE_HUNDRED_MSEC   100
+#define FIVE_HUNDRED_MSEC  500
+#define ONE_SECOND         1000
+#define TWO_SECONDS        2000
+
+#define BCMOS_ASSERT( expr) assert( expr )
+
+#endif
+
+#ifdef __cplusplus
+    }
+#endif
+
+
+#endif  /* _BCMOS_H  */
+
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/cxcEnv.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/cxcEnv.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/cxcEnv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/cxcEnv.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,79 @@
+/***************************************************************************
+*    Copyright 2000  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16251 Laguna Canyon Road
+*             Irvine, California  92618
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: cxcEnv.h
+*    Creation Date:
+*    VSS Info:
+*        $Revision: 43 $
+*        $Date: 12/03/02 5:50p $
+*
+****************************************************************************
+*    Description:
+*
+*     This file is used in CableX to provide system-wide types and definitions. Howewever.
+*     since iit tries to include various C run-time library dcefintions (eh stdio.h, it is not
+*     appropriate for use "as is" in a Linux kernel environment. So the CableX endpoint source 
+*     does not need to change, we use this file to recursively include bcmtypes.h
+*
+*    NOTE:  This file is based upon LDX's hausenv.h, but has been renamed to
+*           avoid project dependencies, and allow for CablexChange customizations.
+*
+****************************************************************************/
+
+#ifndef CXC_ENV_H
+#define CXC_ENV_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* --------------------------------------------------------------------------
+** Just include definitions from bcmtypes.h
+*/
+#include <bcmtypes.h>
+
+#undef EPT_TEST
+
+#if !defined( HAUS_SINT16_DEFINED )
+#define HAUS_SINT16_DEFINED
+typedef signed short    SINT16;     /* SINT16 is platform independant */
+#endif
+
+
+#if !defined( HAUS_SINT32_DEFINED )
+#define HAUS_SINT32_DEFINED
+typedef signed long   SINT32;
+#endif
+
+#define SUCCESS   0
+#define FAILURE   1
+
+
+// GNU definition imported from cxc_compiler.h
+#define CXC_INLINE __inline__	  
+
+// Endian-ness imported from cxc_cpu.h
+#define CXC_CPU_BIG_ENDIAN     1
+#define CXC_CPU_LITTLE_ENDIAN  0
+
+#if defined(__KERNEL__)
+#define CXC_OS_LINUX 1
+#define PSOS 0
+#define VXWORKS 0
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif   /* CXC_ENV_H */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/cxcLog.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/cxcLog.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/cxcLog.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/cxcLog.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,34 @@
+/***************************************************************************
+*    Copyright 2000  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16251 Laguna Canyon Road
+*             Irvine, California  92618
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: log.h
+*    Creation Date: 17 September 2001 (v0.00)
+*    VSS Info:
+*        $Revision: 3 $
+*        $Date: 11/13/02 3:42p $
+*
+****************************************************************************
+*    Description:
+*
+*        This filename is preserved in order to minimize the changes
+*        in the endpoint code, which is shared with the Cablex endpoint.
+*        cxcLog.h simply includes log.h, which contains the log macros.
+*
+****************************************************************************/
+
+#ifndef CXC_LOG_H
+#define CXC_LOG_H
+
+#include <log.h>
+
+#endif  /* CXC_LOG_H  */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/endpointdrv.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/endpointdrv.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/endpointdrv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/endpointdrv.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,243 @@
+/***************************************************************************
+ * Broadcom Corp. Confidential
+ * Copyright 2001 Broadcom Corp. All Rights Reserved.
+ *
+ * THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED
+ * SOFTWARE LICENSE AGREEMENT BETWEEN THE USER AND BROADCOM.
+ * YOU HAVE NO RIGHT TO USE OR EXPLOIT THIS MATERIAL EXCEPT
+ * SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
+ *
+ ***************************************************************************
+ * File Name  : EndpointDrv.h
+ *
+ * Description: This file contains the definitions and structures for the
+ *              Linux IOCTL interface that used between the user mode Endpoint
+ *              API library and the kernel Endpoint API driver.
+ *
+ * Updates    : 04/04/2002  YD.  Created.
+ ***************************************************************************/
+
+#if !defined(_ENDPOINTDRV_H_)
+#define _ENDPOINTDRV_H_
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/* Includes. */
+#include <bcmtypes.h>
+#include <vrgEndpt.h>
+#include <endptvoicestats.h>
+
+/* Maximum size for the event data passed with the event callback */
+#define MAX_EVENTDATA_SIZE    256
+
+typedef enum ENDPOINTIOCTL_INDEX
+{
+   ENDPTIO_INIT_INDEX = 0,
+   ENDPTIO_DEINIT_INDEX,
+   ENDPTIO_CREATE_INDEX,
+   ENDPTIO_CAPABILITIES_INDEX,
+   ENDPTIO_SIGNAL_INDEX,
+   ENDPTIO_CREATE_CONNECTION_INDEX,
+   ENDPTIO_MODIFY_CONNECTION_INDEX,
+   ENDPTIO_DELETE_CONNECTION_INDEX,
+   ENDPTIO_PACKET_INDEX,
+   ENDPTIO_GET_PACKET_INDEX,
+   ENDPTIO_GET_EVENT_INDEX,
+   ENDPTIO_GET_CODECMAP_INDEX,
+   ENDPTIO_VOICESTAT_INDEX,
+   ENDPTIO_ISINITIALIZED_INDEX,
+   ENDPTIO_CONSOLE_CMD_INDEX,
+   ENDPTIO_TEST_INDEX,
+   ENDPTIO_ENDPOINTCOUNT_INDEX,
+   ENDPTIO_MAX_INDEX
+} ENDPOINTIOCTL_INDEX;
+
+
+/* Defines. */
+#define ENDPOINTDRV_MAJOR            209 /* arbitrary unused value */
+
+#define ENDPOINTIOCTL_ENDPT_INIT \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_INIT_INDEX, ENDPOINTDRV_INIT_PARAM)
+
+#define ENDPOINTIOCTL_ENDPT_DEINIT \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_DEINIT_INDEX, ENDPOINTDRV_INIT_PARAM)
+
+#define ENDPOINTIOCTL_ENDPT_CREATE \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_CREATE_INDEX, ENDPOINTDRV_CREATE_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_CAPABILITIES \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_CAPABILITIES_INDEX, ENDPOINTDRV_CAP_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_SIGNAL \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_SIGNAL_INDEX, ENDPOINTDRV_SIGNAL_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_CREATE_CONNECTION \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_CREATE_CONNECTION_INDEX, ENDPOINTDRV_CONNECTION_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_MODIFY_CONNECTION \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_MODIFY_CONNECTION_INDEX, ENDPOINTDRV_CONNECTION_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_DELETE_CONNECTION \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_DELETE_CONNECTION_INDEX, ENDPOINTDRV_DELCONNECTION_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_PACKET \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_PACKET_INDEX, ENDPOINTDRV_PACKET_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_GET_PACKET \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_GET_PACKET_INDEX, ENDPOINTDRV_PACKET_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_GET_EVENT \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_GET_EVENT_INDEX, ENDPOINTDRV_EVENT_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_GET_CODECMAP \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_GET_CODECMAP_INDEX, ENDPOINTDRV_CODECMAP_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_VOICESTAT \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_VOICESTAT_INDEX, ENDPOINTDRV_VOICESTAT_PARM)
+
+#define ENDPOINTIOCTL_ISINITIALIZED \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_ISINITIALIZED_INDEX, ENDPOINTDRV_ISINITIALIZED_PARM)
+
+#define ENDPOINTIOCTL_ENDPT_CONSOLE_CMD \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_CONSOLE_CMD_INDEX, ENDPOINTDRV_CONSOLE_CMD_PARM)
+
+#define ENDPOINTIOCTL_TEST \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_TEST_INDEX, ENDPOINTDRV_TESTPARM)
+
+#define ENDPOINTIOCTL_ENDPOINTCOUNT \
+    _IOWR(ENDPOINTDRV_MAJOR, ENDPTIO_ENDPOINTCOUNT_INDEX, ENDPOINTDRV_ENDPOINTCOUNT_PARM)
+
+#define MAX_ENDPOINTDRV_IOCTL_COMMANDS   ENDPTIO_MAX_INDEX
+
+
+typedef struct
+{
+   UINT32      size;    /* Size of the structure (including the size field) */
+   VRG_COUNTRY country;
+   EPSTATUS    epStatus;
+} ENDPOINTDRV_INIT_PARAM, *PENDPOINTDRV_INIT_PARAM;
+
+typedef struct
+{
+   UINT32   size;       /* Size of the structure (including the size field) */
+   UINT32   physId;
+   UINT32   lineId;
+   VRG_ENDPT_STATE* endptState;
+   EPSTATUS epStatus;
+} ENDPOINTDRV_CREATE_PARM, *PENDPOINTDRV_CREATE_PARM;
+
+typedef struct
+{
+   UINT32   size;       /* Size of the structure (including the size field) */
+   EPZCAP*  capabilities;
+   ENDPT_STATE* state;
+   EPSTATUS epStatus;
+} ENDPOINTDRV_CAP_PARM, *PENDPOINTDRV_CAP_PARM;
+
+typedef struct
+{
+   UINT32      size;    /* Size of the structure (including the size field) */
+   ENDPT_STATE* state;
+   UINT32      cnxId;
+   EPSIG       signal;
+   UINT32      value;      // Reserve an array, can be a pointer
+   EPSTATUS    epStatus;
+   int         duration;
+   int         period;
+   int         repetition;
+} ENDPOINTDRV_SIGNAL_PARM, *PENDPOINTDRV_SIGNAL_PARM;
+
+typedef struct
+{
+   UINT32      size;    /* Size of the structure (including the size field) */
+   ENDPT_STATE* state;
+   int         cnxId;
+   EPZCNXPARAM*   cnxParam;
+   EPSTATUS    epStatus;
+} ENDPOINTDRV_CONNECTION_PARM, *PENDPOINTDRV_CONNECTION_PARM;
+
+typedef struct
+{
+   UINT32         size; /* Size of the structure (including the size field) */
+   ENDPT_STATE*   state;
+   int            cnxId;
+   EPSTATUS       epStatus;
+} ENDPOINTDRV_DELCONNECTION_PARM, *PENDPOINTDRV_DELCONNECTION_PARM;
+
+typedef struct
+{
+   UINT32   size;       /* Size of the structure (including the size field) */
+   ENDPT_STATE*   state;
+   int      cnxId;
+   EPPACKET*      epPacket;
+   int      length;
+   UINT32   bufDesc;
+   EPSTATUS epStatus;
+} ENDPOINTDRV_PACKET_PARM, *PENDPOINTDRV_PACKET_PARM;
+
+typedef struct
+{
+   UINT32   size;       /* Size of the structure (including the size field) */
+   int      lineId;
+   int      cnxId;
+   int      length;
+   EPEVT    event;
+   UINT8    eventData[MAX_EVENTDATA_SIZE];
+} ENDPOINTDRV_EVENT_PARM, *PENDPOINTDRV_EVENT_PARM;
+
+typedef struct
+{
+   UINT32         size; /* Size of the structure (including the size field) */
+   int            isInitialized;
+} ENDPOINTDRV_ISINITIALIZED_PARM, *PENDPOINTDRV_ISINITIALIZED_PARM;
+
+typedef struct
+{
+   UINT32         size; /* Size of the structure (including the size field) */
+   UINT32         testParm1;
+   UINT32         testParm2;
+   EPZCNXPARAM*   testParm3;
+   EPSTATUS       epStatus;
+} ENDPOINTDRV_TESTPARM, *PENDPOINTDRV_TESTPARM;
+
+typedef struct ENDPOINTDRV_PACKET
+{
+   UINT32   size;       /* Size of the structure (including the size field) */
+   int      cnxId;
+   int      length;
+   EPMEDIATYPE mediaType;
+   UINT8    data[1024];
+} ENDPOINTDRV_PACKET;
+
+typedef struct ENDPOINTDRV_VOICESTAT_PARM
+{
+   int lineId;
+   ENDPT_VOICE_STATS* stats;
+   EPSTATUS epStatus;
+} ENDPOINTDRV_VOICESTAT_PARM, *PENDPOINTDRV_VOICESTAT_PARM;
+
+typedef struct ENDPOINTDRV_CONSOLE_CMD_PARM
+{
+   UINT32   size;       /* Size of the structure (including the size field) */
+   int lineId;
+   int cnxId;
+   int cmd;
+   ENDPT_STATE*   state;
+   EPSTATUS epStatus;
+} ENDPOINTDRV_CONSOLE_CMD_PARM, *PENDPOINTDRV_CONSOLE_CMD_PARM;
+
+
+typedef struct
+{
+   UINT32         size; /* Size of the structure (including the size field) */
+   int            endpointNum;
+} ENDPOINTDRV_ENDPOINTCOUNT_PARM, *PENDPOINTDRV_ENDPOINTCOUNT_PARM;
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // _ENDPOINTDRV_H_
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/endptvoicestats.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/endptvoicestats.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/endptvoicestats.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/endptvoicestats.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,106 @@
+/***************************************************************************
+ * Broadcom Corp. Confidential
+ * Copyright 2001 Broadcom Corp. All Rights Reserved.
+ *
+ * THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED
+ * SOFTWARE LICENSE AGREEMENT BETWEEN THE USER AND BROADCOM.
+ * YOU HAVE NO RIGHT TO USE OR EXPLOIT THIS MATERIAL EXCEPT
+ * SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
+ *
+ ***************************************************************************
+ * File Name  : endptvoicestats.h
+ *
+ * Description: This file contains the definitions of the voice statistics
+ *              structures. This file should be used in user space when
+ *              working with the voice statistics structure.
+ *
+ *              The files hpnet.h and hppve.h
+ *              should not be included in user space because of a conflict
+ *              in the definitions supplied by hausenv.h (in the endpoint/vocm/
+ *              ldxIntf/dspinc directory) and the definitions supplied by bcmtypes.h
+ *              (in the /sgibcm_2_4_17/linux/include/asm-mips/bcm96345 directory).
+ *
+ * Updates    :
+ ***************************************************************************/
+
+#if !defined(ENDPTSTATS_H)
+#define ENDPTSTATS_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+typedef struct
+{
+#ifdef ENDPT_6345
+   UINT16    peakHoldingTime;    /* Peak Holding Time since last statistic */
+
+   /* Total number of superpackets arriving on the egress path */
+   UINT16    packetCount;        /* # of packets received */
+
+   /* addTail and reorder are successful additions to the JB */
+   /* addTail is typically 1..N times the packetCount if superpackets are enabled */
+   UINT16    addTailCount;       /* # of frames added to tail of JB - normal case */
+   UINT16    reorderCount;       /* # of frames reordered */
+
+   /* overrun, duplicate, outOfRange, tooLate, jitterMax excess are packets that have been discarded */
+   UINT16    overrunCount;       /* Decoder overrun count */
+   UINT16    duplicateCount;     /* # of duplicate frames deleted */
+   UINT16    outOfRangeCount;    /* # of frames with timestamps too far from current TS to be handled */
+   UINT16    tooLateCount;       /* Packet arrived too late (it's redundant mate already played) */
+
+   /* cantDecode are packets that can't be played out due to algorithm not available */
+   UINT16    cantDecodeCount;    /* Can't decode packet - decoder not in load or pkt hdr bad */
+
+   /* The following are internal to the AJC module - they do not represent physical packets */
+   UINT16    ajcUnderrunCount;   /* Adaptive Jitter Control: jitter buffer underruns */
+   UINT16    ajcDeleteCount;     /* Adaptive Jitter Control: # of packet deletes done to reduce holding time */
+   UINT16    ajcRepeatCount;     /* Adaptive Jitter Control: # of packet repeats done to either increase holding time
+                                    or due to late frame or lost frames. */
+   UINT16    ajcResyncCount;     /* Number of times ajb resynced (went through buildout state) */
+   UINT16    ajcPhaseJitterCount;     /* Number of times ajb inserted a phase discontinuity
+                                    (possibly in silence or during CNG or due to a repeat/delete). */
+   /* 14 entries.  Make sure this is even (!) */
+#else
+  UINT16    peakHoldingTime;         /* Peak Holding Time since last statistic */
+  UINT16    minimumHoldingTime;      /* Long-term tracker of min. Hold Time */
+  UINT16    targetHoldingTime;       /* Target holding Time */
+  UINT16    inactiveFrameCount;      /* Inactive Frame Count */
+  UINT16    activeFrameCount;        /* Active Frame Count */
+  UINT16    hsxDecoderOverrunCount;  /* Decoder overrun count */
+  UINT16    hsxDecoderUnderrunCount; /* Decoder underrun count */
+  UINT16    lostFrameCount;          /* Lost frames resulting in frame repeat */
+#endif
+} ENDPT_VOICE_DECODERSTATS;
+
+/* Encoder Statistics */
+typedef struct
+{
+#ifdef ENDPT_6345
+   UINT16   inactiveFrameCount;     /* Inactive Frame Count of Suppressed Frames*/
+   UINT16   activeFrameCount;       /* Active Frame Count - actually sent ingress */
+   UINT16   sidFrameCount;          /* SID Frame Count */
+   UINT16   toneRelayCount;         /* # of tone packets from PTE relayed ingress */
+#else
+  UINT16    hsxEncoderOverrunCount;  /* Encoder overrun count */
+#endif
+} ENDPT_VOICE_ENCODERSTATS;
+
+
+typedef struct
+{
+   ENDPT_VOICE_DECODERSTATS   decoder;
+   ENDPT_VOICE_ENCODERSTATS   encoder;
+} ENDPT_VOICE_PVE_STATS;
+
+typedef struct
+{
+   ENDPT_VOICE_PVE_STATS hsxPVEstats;         /* statistics for PVE encoder and decoder */
+
+} ENDPT_VOICE_STATS;
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* ENDPTSTATS_H */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/log.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/log.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/log.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/log.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,104 @@
+/***************************************************************************
+*    Copyright 2000  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16251 Laguna Canyon Road
+*             Irvine, California  92618
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: log.h
+*    Creation Date: 4 July 2000 (v0.00)
+*    VSS Info:
+*        $Revision: 23 $
+*        $Date: 9/14/01 4:54p $
+*
+****************************************************************************
+*    Description:
+*
+*     This header file contains the needed macros and function prototypes
+*     for logging on the terminal.
+*
+****************************************************************************/
+
+#ifndef LOG_H
+#define LOG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LOG_DBG
+
+#if (! (defined(__KERNEL__) || defined (LINUX)) )
+
+extern void Log( char const *format,...);
+extern void LogMsg( char *string );
+extern void LogDirectSerial( char const *format,...);
+
+#define PANIC(m)  Log(m)
+#define LOG(fmt)	Log fmt
+#define LOGERROR(fmt)	Log fmt
+#define LOG1(fmt)	Log fmt              /* Level 1 logging  */
+#define LOG2(fmt)	                     /* Level 2 logging  */
+#define LOGMSG(buf)	LogMsg buf
+
+/***********************************
+** Error logging                   *
+***********************************/
+#elif defined(__KERNEL__)
+
+#define LOG(fmt) printk fmt   ;  printk("\n");
+#define LOG_RAW(fmt)    printk fmt  ;  printk("\n");
+#define PANIC(fmt)      printk("!!! PANIC !!! \n");   printk fmt  ;  printk("\n");
+#define LOGERROR(fmt)	printk("!!! ERROR !!! \n");   printk fmt  ;  printk("\n");
+
+#elif defined(LINUX)
+
+#include <stdio.h>
+
+#ifdef LOG_DBG
+
+#include <time.h>
+
+#define LOG(fmt)                    \
+{                                   \
+   struct tm *tm_ptr;               \
+   time_t curtime;                  \
+   time( &curtime );                \
+   tm_ptr = gmtime( &curtime );     \
+   printf("%02d:%02d:%02d ",        \
+            tm_ptr->tm_hour,        \
+            tm_ptr->tm_min,         \
+            tm_ptr->tm_sec);        \
+   printf fmt;                      \
+   printf("\n");                    \
+}
+#else
+#define LOG(fmt) printf fmt   ;  printf("\n");
+#endif /* LOG_DBG */
+
+#define PANIC(fmt)      printk("!!! PANIC !!! \n");   printk fmt  ;  printk("\n");
+#define LOGERROR(fmt)                     \
+{                                         \
+   printf("ERROR !!! File %s (line %u): ", __FILE__, __LINE__);\
+   printf fmt;                            \
+   printf("\n");                          \
+}
+
+#else
+#error Unknown OS
+#endif
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif /* LOG_H */
+
+
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/mtacfg.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/mtacfg.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/mtacfg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/mtacfg.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,72 @@
+/***************************************************************************
+*    Copyright 2000  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16251 Laguna Canyon Road
+*             Irvine, California  92618
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: mtacfg.h
+*    Creation Date: 4 July 2000 (v0.00)
+*    VSS Info:
+*        $Revision: 23 $
+*        $Date: 9/14/01 4:54p $
+*
+****************************************************************************
+*    Description:
+*
+*     This header file contains all the different build options that
+*     are required by CablexChange components.
+*
+****************************************************************************/
+
+#ifndef _MTACFG_H
+#define _MTACFG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <cfg/endptCfg.h>
+#include <cfg/vocmCfg.h>
+#include <cfg/casCfg.h>
+
+#define MTA_VERSION_INFO   "1.0"
+
+#if ( defined(IP_MGCP) || defined(IP_H323) || defined(IP_SIP) || defined(IP_MEGACO) )
+#define VOIP
+#endif
+
+#ifndef VOIP
+#define ENDPOINT_NULL_SHIM
+#endif
+
+
+/***************************************************************
+** Task Priority options
+****************************************************************/
+
+#define RTP_TASK_PRIORITY        BCMOS_TASK_PRTY_8  /* task priority for rtp */
+#define HGCP_TASK_PRIORITY       BCMOS_TASK_PRTY_8  /* task priority for HGCP */
+#define RTCP_TASK_PRIORITY       BCMOS_TASK_PRTY_13 /* task priority for rtcp */
+
+
+/* Additional DSL specific definitions not provided by Cable Cfg files */
+
+/* For backward compatibility with older code */
+#define MAX_ENDPT   VOCM_CFG_MAX_ENDPT
+#define MAX_CNX   VOCM_CFG_MAX_CNX
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif /* MTACFG_H */
+
+
+
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/profdrv.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/profdrv.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/profdrv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/profdrv.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,151 @@
+/***************************************************************************
+*    Copyright 2004  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16215 Alton Parkway
+*             P.O. Box 57013
+*             Irvine, California 92619-7013
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: profdrv.h
+*
+****************************************************************************
+*    Description:
+*
+*      This file contains the profiler device driver
+*
+****************************************************************************/
+#ifndef PROFDRV_DEVICE_DRIVER__H__INCLUDED
+#define PROFDRV_DEVICE_DRIVER__H__INCLUDED
+
+#include <linux/ioctl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PROFILER_NAME_MAX_LENGTH                32
+#define PROFILER_MAX_RECSEQ                     2048
+
+#define PROFILER_CPU_UTIL_VALID_START        0x01
+#define PROFILER_CPU_UTIL_VALID_STOP         0x02
+
+#define PROFILER_SOURCE_USER              0x00
+#define PROFILER_SOURCE_KERNEL               0x01
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define profdrv_read_32bit_cp0_register(source)                \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+    ".set\tpush\n\t"                    \
+    ".set\treorder\n\t"                 \
+        "mfc0\t%0,"STR(source)"\n\t"                            \
+    ".set\tpop"                     \
+        : "=r" (__res));                                        \
+        __res;})
+
+/*
+    Structure used to pass profiling information data at the user/kernel interface.
+*/
+typedef struct
+{
+    char name[PROFILER_NAME_MAX_LENGTH];
+
+} PROFILER_IOCTL_DATA;
+
+/*
+    This structure is used to keep track of the CPU utilization during the profiling period.
+*/
+typedef struct
+{
+    unsigned tick_uptime_start;
+    unsigned tick_idle_start;
+    unsigned tick_user_start;
+    unsigned tick_kernel_start;
+    unsigned tick_uptime_stop;
+    unsigned tick_idle_stop;
+    unsigned tick_user_stop;
+    unsigned tick_kernel_stop;
+   unsigned char valid_data;
+
+} PROFILER_CPU_UTILIZATION;
+
+/*
+   A generic structure to pass information about the profiler status.
+*/
+typedef struct
+{
+   unsigned status;
+   unsigned cpu_jiffies_start;
+   unsigned cpu_jiffies_stop;
+   unsigned cpu_jiffies_factor;
+   unsigned cpu_clock;
+
+} PROFILER_STATUS;
+
+/*
+    The ioctl action index.
+*/
+typedef enum
+{
+   PROFILER_IOCTL_GET_DATA_DUMP_INDEX,
+   PROFILER_IOCTL_GET_RECSEQ_DATA_DUMP_INDEX,
+   PROFILER_IOCTL_SET_DATA_CLEAN_INDEX,
+   PROFILER_IOCTL_SET_PROF_OPS_INDEX,
+   PROFILER_IOCTL_REGISTER_CALL_INDEX,
+   PROFILER_IOCTL_DEREGISTER_CALL_INDEX,
+   PROFILER_IOCTL_START_CALL_INDEX,
+   PROFILER_IOCTL_STOP_CALL_INDEX,
+   PROFILER_IOCTL_PROFILER_STATUS_INDEX,
+   PROFILER_IOCTL_SET_CPU_UTIL_INDEX,
+   PROFILER_IOCTL_GET_CPU_UTIL_INDEX,
+   PROFILER_IOCTL_GET_RECSEQ_DI_INDEX
+
+} PROFILER_IOCTL_INDEX;
+
+/*
+    Assigning a device driver major number for the sake of making this application work
+*/
+#define PROFDRV_DEVICE_DRIVER_MAJOR     224
+
+#define PROFILER_IOCTL_GET_DATA_DUMP \
+    _IOR( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_GET_DATA_DUMP_INDEX, unsigned )
+#define PROFILER_IOCTL_GET_RECSEQ_DATA_DUMP \
+    _IOR( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_GET_RECSEQ_DATA_DUMP_INDEX, unsigned )
+#define PROFILER_IOCTL_SET_DATA_CLEAN \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_SET_DATA_CLEAN_INDEX, unsigned )
+#define PROFILER_IOCTL_SET_PROF_OPS \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_SET_PROF_OPS_INDEX, unsigned )
+#define PROFILER_IOCTL_REGISTER_CALL \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_REGISTER_CALL_INDEX, PROFILER_IOCTL_DATA )
+#define PROFILER_IOCTL_DEREGISTER_CALL \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_DEREGISTER_CALL_INDEX, PROFILER_IOCTL_DATA )
+#define PROFILER_IOCTL_START_CALL \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_START_CALL_INDEX, PROFILER_IOCTL_DATA )
+#define PROFILER_IOCTL_STOP_CALL \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_STOP_CALL_INDEX, PROFILER_IOCTL_DATA )
+#define PROFILER_IOCTL_PROFILER_STATUS_DATA \
+    _IOR( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_PROFILER_STATUS_INDEX, PROFILER_STATUS )
+#define PROFILER_IOCTL_SET_CPU_UTIL \
+    _IOW( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_SET_CPU_UTIL_INDEX, PROFILER_CPU_UTILIZATION )
+#define PROFILER_IOCTL_GET_CPU_UTIL \
+    _IOR( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_GET_CPU_UTIL_INDEX, PROFILER_CPU_UTILIZATION )
+#define PROFILER_IOCTL_GET_RECSEQ_DATA_INDEX \
+    _IOR( PROFDRV_DEVICE_DRIVER_MAJOR, PROFILER_IOCTL_GET_RECSEQ_DI_INDEX, unsigned )
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PROFDRV_DEVICE_DRIVER__H__INCLUDED */
diff -urN linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/profiler.h linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/profiler.h
--- linux-2.6.8.1/bcmdrivers/broadcom/include/bcm963xx/profiler.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/broadcom/include/bcm963xx/profiler.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,114 @@
+/***************************************************************************
+*    Copyright 2004  Broadcom Corporation
+*    All Rights Reserved
+*    No portions of this material may be reproduced in any form without the
+*    written permission of:
+*             Broadcom Corporation
+*             16215 Alton Parkway
+*             P.O. Box 57013
+*             Irvine, California 92619-7013
+*    All information contained in this document is Broadcom Corporation
+*    company private, proprietary, and trade secret.
+*
+****************************************************************************
+*
+*    Filename: profiler.h
+*
+****************************************************************************
+*    Description:
+*
+*      This file contains the API definition for usage of the profiler tool
+*
+****************************************************************************/
+#ifndef PROFILER__H__INCLUDED
+#define PROFILER__H__INCLUDED
+
+#include "profdrv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PROFILER_MAX_MONITORED_PROFILE          32
+#define PROFILER_CPU_UTILIZATION_MIN            0.000001
+#define PROFILER_MISC_STRING_LENGTH             256
+#define PROFILER_CPU_TICK_FACTOR				2.0
+#define PROFILER_S2MS_FACTOR					1000.0
+
+#define PROFILER_FLAG_RESOURCE_FREE             0x00
+#define PROFILER_FLAG_RESOURCE_ALLOCATED        0x01
+#define PROFILER_FLAG_RESOURCE_ERROR            0x02
+#define PROFILER_FLAG_RESOURCE_COLLECT_PENDING  0x04
+
+/*
+    This structure defines the data collected by the profiler.
+*/
+typedef struct
+{
+	unsigned char source;					/* User or Kernel */
+    unsigned char flag;                     /* Generic flag */
+    char name[PROFILER_NAME_MAX_LENGTH];    /* Name of the function monitored */
+    unsigned int now_cycle;                 /* The current cycle count saved */
+    unsigned int min_cycle;                 /* The minimum number of cycles calculated for this function */
+    unsigned int max_cycle;                 /* The maximum number of cycles calculated for this function */
+    unsigned int avg_cycle;                 /* The average numnber of cycles calculated for this function */
+    unsigned int count;                     /* The number of time this function has been profiled */
+
+} PROFILER_COLLECTED_DATA; 
+
+
+/*
+    This structure defines the recorded sequence data collected by the profiler.
+*/
+typedef struct PROFILER_RECSEQ_DATA
+{
+   unsigned int   id;
+   unsigned long  startTime;
+   unsigned long  endTime;
+} PROFILER_RECSEQ_DATA;
+
+
+void kernel_profiler_register( char *pName, unsigned char src );
+void kernel_profiler_deregister( char *pName, unsigned char src );
+void kernel_profiler_start( char *pName, unsigned char src );
+void kernel_profiler_stop( char *pName, unsigned char src );
+void kernel_profiler_recseq_start( unsigned int id );
+void kernel_profiler_recseq_stop( unsigned int id );
+
+void kernel_profiler_reinit_collected( void );
+void kernel_profiler_dump( void );
+void kernel_profiler_recseq_dump( void );
+void kernel_profiler_start_collect( void );
+void kernel_profiler_stop_collect( void );
+
+
+void profiler_init( void );
+void profiler_get_status( PROFILER_STATUS *pStatus );
+PROFILER_COLLECTED_DATA *profiler_get_data_dump( void );
+PROFILER_RECSEQ_DATA* profiler_get_recseq_data_dump( void );
+void profiler_get_cpu_util( PROFILER_CPU_UTILIZATION *pData );
+void profiler_set_cpu_util( PROFILER_CPU_UTILIZATION *pData );
+unsigned int profiler_get_recseq_data_index( void );
+
+/* 
+    This is the generic API that should be used by clients to access the profiler
+*/
+#define PROFILER_REGISTER( name ) ( kernel_profiler_register( (name), PROFILER_SOURCE_KERNEL ) )
+#define PROFILER_DEREGISTER( name ) ( kernel_profiler_deregister( (name), PROFILER_SOURCE_KERNEL ) )
+#define PROFILER_START( name ) ( kernel_profiler_start( (name), PROFILER_SOURCE_KERNEL ) )
+#define PROFILER_STOP( name ) ( kernel_profiler_stop( (name), PROFILER_SOURCE_KERNEL ) )
+#define PROFILER_RECSEQ_START( source ) ( kernel_profiler_recseq_start( (source) ) )
+#define PROFILER_RECSEQ_STOP( source ) ( kernel_profiler_recseq_stop( (source)) )
+
+#define PROFILER_REINIT_COLLECTED() ( kernel_profiler_reinit_collected() )
+#define PROFILER_DUMP() ( kernel_profiler_dump() )
+#define PROFILER_RECSEQ_DUMP() ( kernel_profiler_recseq_dump() )
+#define PROFILER_START_COLLECT() ( kernel_profiler_start_collect() )
+#define PROFILER_STOP_COLLECT() ( kernel_profiler_stop_collect() )
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PROFILER__H__INCLUDED */
diff -urN linux-2.6.8.1/bcmdrivers/opensource/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/Makefile
--- linux-2.6.8.1/bcmdrivers/opensource/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,26 @@
+# File: modules/drivers/Makefile
+#
+# Makefile for the GPLed Linux kernel modules.
+#
+BRCM_BOARD:=bcm963xx
+BRCM_CHIP:=6348
+LN_NAME=bcm9$(BRCM_CHIP)
+LN_DRIVER_DIRS =
+
+-include $(KERNEL_DIR)/.config
+
+ifneq ($(CONFIG_BCM_BOARD),)
+  LN_DRIVER_DIRS +=ln -sn impl$(CONFIG_BCM_BOARD_IMPL) char/board/$(BRCM_BOARD)/$(LN_NAME);
+endif
+
+ifneq ($(CONFIG_BCM_SERIAL),)
+  LN_DRIVER_DIRS +=ln -sn impl$(CONFIG_BCM_SERIAL_IMPL) char/serial/$(LN_NAME);
+endif
+
+obj-$(CONFIG_BCM_BOARD) += char/board/$(BRCM_BOARD)/$(LN_NAME)/
+obj-$(CONFIG_BCM_SERIAL) += char/serial/$(LN_NAME)/
+
+
+symlinks:
+	find . -lname "*" -name "$(LN_NAME)" -print -exec rm -f "{}" ";"	
+	$(CONFIG_SHELL) -c "$(LN_DRIVER_DIRS)"
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/Makefile
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,17 @@
+# Makefile for the bcm963xx board drivers
+#
+
+
+obj-y := board.o cfiflash.o bcm63xx_flash.o bcm63xx_led.o
+
+EXTRA_CFLAGS += -I. -I$(INC_BRCMBOARDPARMS_PATH)/$(BRCM_BOARD) -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+
+ifeq ($(strip $(WIRELESS)),1)
+	EXTRA_CFLAGS += -DWIRELESS
+endif
+
+-include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_flash.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_flash.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_flash.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,775 @@
+/*
+<:copyright-gpl
+ Copyright 2002 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+/*
+ ***************************************************************************
+ * File Name  : bcm63xx_flash.c
+ *
+ * Description: This file contains the flash device driver APIs for bcm63xx board. 
+ *
+ * Created on :  8/10/2002  seanl:  use cfiflash.c, cfliflash.h (AMD specific)
+ *
+ ***************************************************************************/
+
+
+/* Includes. */
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#define  BCMTAG_EXE_USE
+#include <bcmTag.h>
+#include "cfiflash.h"
+#include "boardparms.h"
+
+//#define DEBUG_FLASH
+
+static FLASH_ADDR_INFO fInfo;
+static int flashInitialized = 0;
+
+void *retriedKmalloc(size_t size)
+{
+	void *pBuf;
+    int tryCount = 0;
+
+    // try 1000 times before quit
+    while (((pBuf = kmalloc(size, GFP_KERNEL)) == NULL) && (tryCount++ < 1000))
+    {
+		current->state   = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ/10);
+	}
+    if (tryCount >= 1000)
+        pBuf = NULL;
+    else
+	    memset(pBuf, 0, size);
+
+    return pBuf;
+}
+
+void retriedKfree(void *pBuf)
+{
+	kfree(pBuf);
+}
+
+/***************************************************************************
+// Function Name: getCrc32
+// Description  : caculate the CRC 32 of the given data.
+// Parameters   : pdata - array of data.
+//                size - number of input data bytes.
+//                crc - either CRC32_INIT_VALUE or previous return value.
+// Returns      : crc.
+****************************************************************************/
+UINT32 getCrc32(byte *pdata, UINT32 size, UINT32 crc) 
+{
+    while (size-- > 0)
+        crc = (crc >> 8) ^ Crc32_table[(crc ^ *pdata++) & 0xff];
+
+    return crc;
+}
+
+// get the nvram start addr
+//
+unsigned long get_nvram_start_addr(void)
+{
+    return ((unsigned long) 
+        (flash_get_memptr(fInfo.flash_nvram_start_blk) + fInfo.flash_nvram_blk_offset));
+}
+
+// get the scratch_pad start addr
+//
+unsigned long get_scratch_pad_start_addr(void)
+{
+    return ((unsigned long) 
+        (flash_get_memptr(fInfo.flash_scratch_pad_start_blk) + fInfo.flash_scratch_pad_blk_offset));
+}
+
+
+
+/*  *********************************************************************
+    *  kerSysImageTagGet()
+    *   Get the image tag
+    *  Input parameters:
+    *      none
+    *  Return value:
+    *      point to tag -- Found
+    *      NULL -- failed
+    ********************************************************************* */
+PFILE_TAG kerSysImageTagGet(void)
+{
+    int i;
+    int totalBlks = flash_get_numsectors();
+    UINT32 crc;
+    unsigned char *sectAddr;
+    PFILE_TAG pTag;
+
+#if defined(DEBUG_FLASH)
+    printk("totalblks in tagGet=%d\n", totalBlks);
+#endif
+
+    // start from 2nd blk, assume 1st one is always CFE
+    for (i = 1; i < totalBlks; i++)
+    {
+        sectAddr =  flash_get_memptr((byte) i);
+        crc = CRC32_INIT_VALUE;
+        crc = getCrc32(sectAddr, (UINT32)TAG_LEN-TOKEN_LEN, crc);      
+        pTag = (PFILE_TAG) sectAddr;
+
+#if defined(DEBUG_FLASH)
+        printk("Check Tag crc on blk [%d]\n", i);
+#endif
+
+        if (crc == (UINT32)(*(UINT32*)(pTag->tagValidationToken)))
+            return pTag;
+    }
+
+    return (PFILE_TAG) NULL;
+}
+
+// Initialize the flash and fill out the fInfo structure
+void kerSysFlashInit( void )
+{
+    int i = 0;
+    int totalBlks = 0;
+    int totalSize = 0;
+    int startAddr = 0;
+    int usedBlkSize = 0;
+    NVRAM_DATA nvramData;
+    UINT32 crc = CRC32_INIT_VALUE, savedCrc;
+    PFILE_TAG pTag = NULL;
+    unsigned long kernelEndAddr = 0;
+    unsigned long spAddr = 0;
+
+    if (flashInitialized)
+        return;
+
+    flashInitialized = 1;
+    flash_init();
+
+    totalBlks = flash_get_numsectors();
+    totalSize = flash_get_total_size();
+
+    printk("Total Flash size: %dK with %d sectors\n", totalSize/1024, totalBlks);
+
+    /* nvram is always at the end of flash */
+    fInfo.flash_nvram_length = FLASH45_LENGTH_NVRAM;
+    fInfo.flash_nvram_start_blk = 0;  /* always the first block */
+    fInfo.flash_nvram_number_blk = 1; /*always fits in the first block */
+    fInfo.flash_nvram_blk_offset = NVRAM_DATA_OFFSET;
+ 
+    // check nvram CRC
+    memcpy((char *)&nvramData, (char *)get_nvram_start_addr(), sizeof(NVRAM_DATA));
+    savedCrc = nvramData.ulCheckSum;
+    nvramData.ulCheckSum = 0;
+    crc = getCrc32((char *)&nvramData, (UINT32) sizeof(NVRAM_DATA), crc);   
+
+    BpSetBoardId( nvramData.szBoardId );
+
+    fInfo.flash_persistent_length = NVRAM_PSI_DEFAULT;
+    if (savedCrc != crc)
+    {
+        printk("***Board is not initialized****: Using the default PSI size: %d\n",
+            fInfo.flash_persistent_length);
+    }
+    else
+    {
+        unsigned long ulPsiSize;
+        if( BpGetPsiSize( &ulPsiSize ) == BP_SUCCESS )
+            fInfo.flash_persistent_length = ulPsiSize;
+        else
+        {
+            printk("***Board id is not set****: Using the default PSI size: %d\n",
+                fInfo.flash_persistent_length);
+        }
+    }
+
+    fInfo.flash_persistent_length *= ONEK;
+    startAddr = totalSize - fInfo.flash_persistent_length;
+    fInfo.flash_persistent_start_blk = flash_get_blk(startAddr+FLASH_BASE_ADDR_REG);
+    fInfo.flash_persistent_number_blk = totalBlks - fInfo.flash_persistent_start_blk;
+    // save abs SP address (Scratch Pad). it is before PSI 
+    spAddr = startAddr - SP_MAX_LEN ;
+    // find out the offset in the start_blk
+    usedBlkSize = 0;
+    for (i = fInfo.flash_persistent_start_blk; 
+        i < (fInfo.flash_persistent_start_blk + fInfo.flash_persistent_number_blk); i++)
+    {
+        usedBlkSize += flash_get_sector_size((byte) i);
+    }
+    fInfo.flash_persistent_blk_offset =  usedBlkSize - fInfo.flash_persistent_length;
+
+    // get the info for sp
+    if (!(pTag = kerSysImageTagGet()))
+    {
+        printk("Failed to read image tag from flash\n");
+        return;
+    }
+    kernelEndAddr = (unsigned long) simple_strtoul(pTag->kernelAddress, NULL, 10) + \
+        (unsigned long) simple_strtoul(pTag->kernelLen, NULL, 10);
+
+    // make suer sp does not share kernel block
+    fInfo.flash_scratch_pad_start_blk = flash_get_blk(spAddr+FLASH_BASE_ADDR_REG);
+    if (fInfo.flash_scratch_pad_start_blk != flash_get_blk(kernelEndAddr))
+    {
+        fInfo.flash_scratch_pad_length = SP_MAX_LEN;
+        if (fInfo.flash_persistent_start_blk == fInfo.flash_scratch_pad_start_blk)  // share blk
+        {
+#if 1 /* do not used scratch pad unless it's in its own sector */
+            printk("Scratch pad is not used for this flash part.\n");  
+            fInfo.flash_scratch_pad_length = 0;     // no sp
+#else /* allow scratch pad to share a sector with another section such as PSI */
+            fInfo.flash_scratch_pad_number_blk = 1;
+            fInfo.flash_scratch_pad_blk_offset = fInfo.flash_persistent_blk_offset - fInfo.flash_scratch_pad_length;
+#endif
+        }
+        else // on different blk
+        {
+            fInfo.flash_scratch_pad_number_blk = fInfo.flash_persistent_start_blk\
+                - fInfo.flash_scratch_pad_start_blk;
+            // find out the offset in the start_blk
+            usedBlkSize = 0;
+            for (i = fInfo.flash_scratch_pad_start_blk; 
+                i < (fInfo.flash_scratch_pad_start_blk + fInfo.flash_scratch_pad_number_blk); i++)
+                usedBlkSize += flash_get_sector_size((byte) i);
+                fInfo.flash_scratch_pad_blk_offset =  usedBlkSize - fInfo.flash_scratch_pad_length;
+        }
+    }
+    else
+    {
+        printk("No flash for scratch pad!\n");  
+        fInfo.flash_scratch_pad_length = 0;     // no sp
+    }
+
+#if defined(DEBUG_FLASH)
+    printk("fInfo.flash_scratch_pad_start_blk = %d\n", fInfo.flash_scratch_pad_start_blk);
+    printk("fInfo.flash_scratch_pad_number_blk = %d\n", fInfo.flash_scratch_pad_number_blk);
+    printk("fInfo.flash_scratch_pad_length = 0x%x\n", fInfo.flash_scratch_pad_length);
+    printk("fInfo.flash_scratch_pad_blk_offset = 0x%x\n", (unsigned int)fInfo.flash_scratch_pad_blk_offset);
+
+    printk("fInfo.flash_nvram_start_blk = %d\n", fInfo.flash_nvram_start_blk);
+    printk("fInfo.flash_nvram_blk_offset = 0x%x\n", (unsigned int)fInfo.flash_nvram_blk_offset);
+    printk("fInfo.flash_nvram_number_blk = %d\n", fInfo.flash_nvram_number_blk);
+
+    printk("psi startAddr = %x\n", startAddr+FLASH_BASE_ADDR_REG);
+    printk("fInfo.flash_persistent_start_blk = %d\n", fInfo.flash_persistent_start_blk);
+    printk("fInfo.flash_persistent_blk_offset = 0x%x\n", (unsigned int)fInfo.flash_persistent_blk_offset);
+    printk("fInfo.flash_persistent_number_blk = %d\n", fInfo.flash_persistent_number_blk);
+#endif
+
+}
+
+
+
+/***********************************************************************
+ * Function Name: kerSysFlashAddrInfoGet
+ * Description  : Fills in a structure with information about the NVRAM
+ *                and persistent storage sections of flash memory.  
+ *                Fro physmap.c to mount the fs vol.
+ * Returns      : None.
+ ***********************************************************************/
+void kerSysFlashAddrInfoGet(PFLASH_ADDR_INFO pflash_addr_info)
+{
+    pflash_addr_info->flash_nvram_blk_offset = fInfo.flash_nvram_blk_offset;
+    pflash_addr_info->flash_nvram_length = fInfo.flash_nvram_length;
+    pflash_addr_info->flash_nvram_number_blk = fInfo.flash_nvram_number_blk;
+    pflash_addr_info->flash_nvram_start_blk = fInfo.flash_nvram_start_blk;
+    pflash_addr_info->flash_persistent_blk_offset = fInfo.flash_persistent_blk_offset;
+    pflash_addr_info->flash_persistent_length = fInfo.flash_persistent_length;
+    pflash_addr_info->flash_persistent_number_blk = fInfo.flash_persistent_number_blk;
+    pflash_addr_info->flash_persistent_start_blk = fInfo.flash_persistent_start_blk;
+}
+
+
+// get shared blks into *** pTempBuf *** which has to be released bye the caller!
+// return: if pTempBuf != NULL, poits to the data with the dataSize of the buffer
+// !NULL -- ok
+// NULL  -- fail
+static char *getSharedBlks(int start_blk, int end_blk)
+{
+    int i = 0;
+    int usedBlkSize = 0;
+    int sect_size = 0;
+    char *pTempBuf = NULL;
+    char *pBuf = NULL;
+
+    for (i = start_blk; i < end_blk; i++)
+        usedBlkSize += flash_get_sector_size((byte) i);
+
+#if defined(DEBUG_FLASH)
+    printk("usedBlkSize = %d\n", usedBlkSize);
+#endif
+
+    if ((pTempBuf = (char *) retriedKmalloc(usedBlkSize)) == NULL)
+    {
+        printk("failed to allocate memory with size: %d\n", usedBlkSize);
+        return pTempBuf;
+    }
+    
+    pBuf = pTempBuf;
+    for (i = start_blk; i < end_blk; i++)
+    {
+        sect_size = flash_get_sector_size((byte) i);
+
+#if defined(DEBUG_FLASH)
+        printk("i = %d, sect_size = %d, end_blk = %d\n", i, sect_size, end_blk);
+#endif
+        flash_read_buf((byte)i, 0, pBuf, sect_size);
+        pBuf += sect_size;
+    }
+    
+    return pTempBuf;
+}
+
+
+
+// Set the pTempBuf to flash from start_blk to end_blk
+// return:
+// 0 -- ok
+// -1 -- fail
+static int setSharedBlks(int start_blk, int end_blk, char *pTempBuf)
+{
+    int i = 0;
+    int sect_size = 0;
+    int sts = 0;
+    char *pBuf = pTempBuf;
+
+    for (i = start_blk; i < end_blk; i++)
+    {
+        sect_size = flash_get_sector_size((byte) i);
+        flash_sector_erase_int(i);
+        if (flash_write_buf(i, 0, pBuf, sect_size) != sect_size)
+        {
+            printk("Error writing flash sector %d.", i);
+            sts = -1;
+            break;
+        }
+        pBuf += sect_size;
+    }
+
+    return sts;
+}
+
+
+
+/*******************************************************************************
+ * NVRAM functions
+ *******************************************************************************/
+
+// get nvram data
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysNvRamGet(char *string, int strLen, int offset)
+{
+    char *pBuf = NULL;
+
+    if (!flashInitialized)
+        kerSysFlashInit();
+
+    if (strLen > FLASH45_LENGTH_NVRAM)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_nvram_start_blk,
+        (fInfo.flash_nvram_start_blk + fInfo.flash_nvram_number_blk))) == NULL)
+        return -1;
+
+    // get string off the memory buffer
+    memcpy(string, (pBuf + fInfo.flash_nvram_blk_offset + offset), strLen);
+
+    retriedKfree(pBuf);
+
+    return 0;
+}
+
+
+// set nvram 
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysNvRamSet(char *string, int strLen, int offset)
+{
+    int sts = 0;
+    char *pBuf = NULL;
+
+    if (strLen > FLASH45_LENGTH_NVRAM)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_nvram_start_blk,
+        (fInfo.flash_nvram_start_blk + fInfo.flash_nvram_number_blk))) == NULL)
+        return -1;
+
+    // set string to the memory buffer
+    memcpy((pBuf + fInfo.flash_nvram_blk_offset + offset), string, strLen);
+
+    if (setSharedBlks(fInfo.flash_nvram_start_blk, 
+        (fInfo.flash_nvram_number_blk + fInfo.flash_nvram_start_blk), pBuf) != 0)
+        sts = -1;
+    
+    retriedKfree(pBuf);
+
+    return sts;
+}
+
+
+/***********************************************************************
+ * Function Name: kerSysEraseNvRam
+ * Description  : Erase the NVRAM storage section of flash memory.
+ * Returns      : 1 -- ok, 0 -- fail
+ ***********************************************************************/
+int kerSysEraseNvRam(void)
+{
+    int sts = 1;
+    char *tempStorage = retriedKmalloc(FLASH45_LENGTH_NVRAM);
+    
+    // just write the whole buf with '0xff' to the flash
+    if (!tempStorage)
+        sts = 0;
+    else
+    {
+        memset(tempStorage, 0xff, FLASH45_LENGTH_NVRAM);
+        if (kerSysNvRamSet(tempStorage, FLASH45_LENGTH_NVRAM, 0) != 0)
+            sts = 0;
+        retriedKfree(tempStorage);
+    }
+
+    return sts;
+}
+
+
+/*******************************************************************************
+ * PSI functions
+ *******************************************************************************/
+// get psi data
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysPersistentGet(char *string, int strLen, int offset)
+{
+    char *pBuf = NULL;
+
+    if (strLen > fInfo.flash_persistent_length)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_persistent_start_blk,
+        (fInfo.flash_persistent_start_blk + fInfo.flash_persistent_number_blk))) == NULL)
+        return -1;
+
+    // get string off the memory buffer
+    memcpy(string, (pBuf + fInfo.flash_persistent_blk_offset + offset), strLen);
+
+    retriedKfree(pBuf);
+
+    return 0;
+}
+
+
+// set psi 
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysPersistentSet(char *string, int strLen, int offset)
+{
+    int sts = 0;
+    char *pBuf = NULL;
+
+    if (strLen > fInfo.flash_persistent_length)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_persistent_start_blk,
+        (fInfo.flash_persistent_start_blk + fInfo.flash_persistent_number_blk))) == NULL)
+        return -1;
+
+    // set string to the memory buffer
+    memcpy((pBuf + fInfo.flash_persistent_blk_offset + offset), string, strLen);
+
+    if (setSharedBlks(fInfo.flash_persistent_start_blk, 
+        (fInfo.flash_persistent_number_blk + fInfo.flash_persistent_start_blk), pBuf) != 0)
+        sts = -1;
+    
+    retriedKfree(pBuf);
+
+    return sts;
+}
+
+
+// flash bcm image 
+// return: 
+// 0 - ok
+// !0 - the sector number fail to be flashed (should not be 0)
+int kerSysBcmImageSet( int flash_start_addr, char *string, int size)
+{
+    int sts;
+    int sect_size;
+    int blk_start;
+    int i;
+    char *pTempBuf = NULL;
+    int whole_image = 0;
+
+    blk_start = flash_get_blk(flash_start_addr);
+    if( blk_start < 0 )
+        return( -1 );
+
+    if (flash_start_addr == FLASH_BASE && size > FLASH45_LENGTH_BOOT_ROM)
+        whole_image = 1;
+
+   /* write image to flash memory */
+    do 
+    {
+        sect_size = flash_get_sector_size(blk_start);
+// NOTE: for memory problem in multiple PVC configuration, temporary get rid of kmalloc this 64K for now.
+//        if ((pTempBuf = (char *)retriedKmalloc(sect_size)) == NULL)
+//        {
+//            printk("Failed to allocate memory with size: %d.  Reset the router...\n", sect_size);
+//            kerSysMipsSoftReset();     // reset the board right away.
+//        }
+        // for whole image, no check on psi
+        if (!whole_image && blk_start == fInfo.flash_persistent_start_blk)  // share the blk with psi
+        {
+            if (size > (sect_size - fInfo.flash_persistent_length))
+            {
+                printk("Image is too big\n");
+                break;          // image is too big. Can not overwrite to nvram
+            }
+            if ((pTempBuf = (char *)retriedKmalloc(sect_size)) == NULL)
+            {
+               printk("Failed to allocate memory with size: %d.  Reset the router...\n", sect_size);
+               kerSysMipsSoftReset();     // reset the board right away.
+            }
+            flash_read_buf((byte)blk_start, 0, pTempBuf, sect_size);
+            if (copy_from_user((void *)pTempBuf,(void *)string, size) != 0)
+                break;  // failed ?
+            flash_sector_erase_int(blk_start);     // erase blk before flash
+            if (flash_write_buf(blk_start, 0, pTempBuf, sect_size) == sect_size) 
+                size = 0;   // break out and say all is ok
+            retriedKfree(pTempBuf);
+            break;
+        }
+        
+        flash_sector_erase_int(blk_start);     // erase blk before flash
+
+        if (sect_size > size) 
+        {
+            if (size & 1) 
+                size++;
+            sect_size = size;
+        }
+        
+        if ((i = flash_write_buf(blk_start, 0, string, sect_size)) != sect_size) {
+            break;
+        }
+        blk_start++;
+        string += sect_size;
+        size -= sect_size; 
+    } while (size > 0);
+
+    if (whole_image)  
+    {
+        // If flashing a whole image, erase to end of flash.
+        int total_blks = flash_get_numsectors();
+        while( blk_start < total_blks )
+        {
+            flash_sector_erase_int(blk_start);
+            blk_start++;
+        }
+    }
+    if (pTempBuf)
+        retriedKfree(pTempBuf);
+
+    if( size == 0 ) 
+        sts = 0;  // ok
+    else  
+        sts = blk_start;    // failed to flash this sector
+
+    return sts;
+}
+
+/*******************************************************************************
+ * SP functions
+ *******************************************************************************/
+// get sp data.  NOTE: memcpy work here -- not using copy_from/to_user
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysScratchPadGet(char *tokenId, char *tokBuf, int bufLen)
+{
+    PSP_HEADER pHead = NULL;
+    PSP_TOKEN pToken = NULL;
+    char *pBuf = NULL;
+    char *pShareBuf = NULL;
+    char *startPtr = NULL;
+    char *endPtr = NULL;
+    char *spEndPtr = NULL;
+    int sts = -1;
+
+    if (fInfo.flash_scratch_pad_length == 0)
+        return sts;
+
+    if (bufLen >= (fInfo.flash_scratch_pad_length - sizeof(SP_HEADER) - sizeof(SP_TOKEN))) 
+    {
+        printk("Exceed scratch pad space by %d\n", bufLen  - fInfo.flash_scratch_pad_length \
+            - sizeof(SP_HEADER) - sizeof(SP_TOKEN));
+        return sts;
+    }
+
+    if ((pShareBuf = getSharedBlks(fInfo.flash_scratch_pad_start_blk,
+        (fInfo.flash_scratch_pad_start_blk + fInfo.flash_scratch_pad_number_blk))) == NULL)
+        return sts;
+
+    // pBuf points to SP buf
+    pBuf = pShareBuf + fInfo.flash_scratch_pad_blk_offset;  
+
+    pHead = (PSP_HEADER) pBuf;
+    if (memcmp(pHead->SPMagicNum, MAGIC_NUMBER, MAGIC_NUM_LEN) != 0) 
+    {
+        printk("Scrap pad is not initialized.\n");
+        return sts;
+    }
+
+    // search up to SPUsedLen for the token
+    startPtr = pBuf + sizeof(SP_HEADER);
+    endPtr = pBuf + pHead->SPUsedLen;
+    spEndPtr = pBuf + SP_MAX_LEN;
+    while (startPtr < endPtr && startPtr < spEndPtr)
+    {
+        pToken = (PSP_TOKEN) startPtr;
+        if (strncmp(pToken->tokenName, tokenId, TOKEN_NAME_LEN) == 0)
+        {
+            memcpy(tokBuf, startPtr + sizeof(SP_TOKEN), bufLen);
+            sts = 0;
+            break;
+        }
+        // get next token
+        startPtr += sizeof(SP_TOKEN) + pToken->tokenLen;
+    }
+
+    retriedKfree(pShareBuf);
+
+    return sts;
+}
+
+
+// set sp.  NOTE: memcpy work here -- not using copy_from/to_user
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysScratchPadSet(char *tokenId, char *tokBuf, int bufLen)
+{
+    PSP_TOKEN pToken = NULL;
+    PSP_HEADER pHead = NULL;
+    char *pShareBuf = NULL;
+    char *pBuf = NULL;
+    SP_HEADER SPHead;
+    SP_TOKEN SPToken;
+    char *curPtr;
+    int sts = -1;
+
+    if (fInfo.flash_scratch_pad_length == 0)
+        return sts;
+
+    if (bufLen >= (fInfo.flash_scratch_pad_length - sizeof(SP_HEADER) - sizeof(SP_TOKEN))) 
+    {
+        printk("Exceed scratch pad space by %d\n", bufLen  - fInfo.flash_scratch_pad_length \
+            - sizeof(SP_HEADER) - sizeof(SP_TOKEN));
+        return sts;
+    }
+
+    if ((pShareBuf = getSharedBlks(fInfo.flash_scratch_pad_start_blk,
+        (fInfo.flash_scratch_pad_start_blk + fInfo.flash_scratch_pad_number_blk))) == NULL)
+        return sts;
+
+    // pBuf points to SP buf
+    pBuf = pShareBuf + fInfo.flash_scratch_pad_blk_offset;  
+    pHead = (PSP_HEADER) pBuf;
+
+    // form header info.  SPUsedLen later on...
+    memset((char *)&SPHead, 0, sizeof(SP_HEADER));
+    memcpy(SPHead.SPMagicNum, MAGIC_NUMBER, MAGIC_NUM_LEN);
+    SPHead.SPVersion = SP_VERSION;
+
+    // form token info.
+    memset((char*)&SPToken, 0, sizeof(SP_TOKEN));
+    strncpy(SPToken.tokenName, tokenId, TOKEN_NAME_LEN - 1);
+    SPToken.tokenLen = bufLen;
+    if (memcmp(pHead->SPMagicNum, MAGIC_NUMBER, MAGIC_NUM_LEN) != 0) 
+    {
+        // new sp, so just flash the token
+        printk("No Scrap pad found.  Initialize scratch pad...\n");
+        SPHead.SPUsedLen = sizeof(SP_HEADER) + sizeof(SP_TOKEN) + bufLen;
+        memcpy(pBuf, (char *)&SPHead, sizeof(SP_HEADER));
+        curPtr = pBuf + sizeof(SP_HEADER);
+        memcpy(curPtr, (char *)&SPToken, sizeof(SP_TOKEN));
+        curPtr += sizeof(SP_TOKEN);
+        memcpy(curPtr, tokBuf, bufLen);
+    }
+    else  
+    {
+        // need search for the token, if exist with same size overwrite it. if sizes differ, 
+        // move over the later token data over and put the new one at the end
+        char *endPtr = pBuf + pHead->SPUsedLen;
+        char *spEndPtr = pBuf + SP_MAX_LEN;
+        curPtr = pBuf + sizeof(SP_HEADER);
+        while (curPtr < endPtr && curPtr < spEndPtr)
+        {
+            pToken = (PSP_TOKEN) curPtr;
+            if (strncmp(pToken->tokenName, tokenId, TOKEN_NAME_LEN) == 0)
+            {
+                if (pToken->tokenLen == bufLen) // overwirte it
+                {
+                    memcpy((curPtr+sizeof(SP_TOKEN)), tokBuf, bufLen);
+                    break;
+                }
+                else // move later data over and put the new token at the end
+                {
+                    memcpy((curPtr+sizeof(SP_TOKEN)), tokBuf, bufLen);  // ~~~
+                    break;
+                }
+            }
+            else // not same token ~~~
+            {
+            }
+            // get next token
+            curPtr += sizeof(SP_TOKEN) + pToken->tokenLen;
+        } // end while
+        SPHead.SPUsedLen = sizeof(SP_HEADER) + sizeof(SP_TOKEN) + bufLen; // ~~~
+        if (SPHead.SPUsedLen > SP_MAX_LEN)
+        {
+            printk("No more Scratch pad space left! Over limit by %d bytes\n", SPHead.SPUsedLen - SP_MAX_LEN);
+            return sts;
+        }
+
+    } // else if not new sp
+
+    sts = setSharedBlks(fInfo.flash_scratch_pad_start_blk, 
+        (fInfo.flash_scratch_pad_number_blk + fInfo.flash_scratch_pad_start_blk), pShareBuf);
+    
+    retriedKfree(pShareBuf);
+
+    return sts;
+
+    
+}
+
+int kerSysFlashSizeGet(void)
+{
+   return flash_get_total_size();
+}
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_led.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_led.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/bcm63xx_led.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,582 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***************************************************************************
+ * File Name  : bcm63xx_led.c
+ *
+ * Description: 
+ *
+ *    This file contains bcm963xx board led control API functions. 
+ *
+ *    To use it, do the following
+ *
+ *    1). define in the board.c the following led mappping (this is for 6345GW board):
+ *        const LED_MAP_PAIR cLedMapping45GW[] =
+ *        {   // led name     Initial state       physical pin (ledMask)
+ *            {kLedUsb,       kLedStateOff,       GPIO_LED_PIN_7}, 
+ *            {kLedAdsl,      kLedStateOff,       GPIO_LED_PIN_8},
+ *            {kLedPPP,       kLedStateOff,       GPIO_LED_PIN_9},    // PPP and WanData share PIN_9
+ *            {kLedWanData,   kLedStateOff,       GPIO_LED_PIN_9},
+ *            {kLedWireless,  kLedStateOff,       GPIO_LED_PIN_10},
+ *            {kLedEnd,       kLedStateOff,       0              } // NOTE: kLedEnd has to be at the end.
+ *
+ *    2). };To initialize led API and initial state of the leds, call the following function with the mapping 
+ *        pointer from the above struct
+ *
+ *        boardLedInit((PLED_MAP_PAIR) &cLedMapping45R);
+ *
+ *    3). Sample call for kernel mode:
+ *
+ *        kerSysLedCtrl(kLedAdsl, kLedStateBlinkOnce);        // kLedxxx defines in board.h
+ *
+ *    4). Sample call for user mode
+ *
+ *        sysLedCtrl(kLedAdsl, kLedStateBlinkOnce);           // kLedxxx defines in board_api.h
+ *
+ *
+ * Created on :  10/28/2002  seanl
+ *
+ ***************************************************************************/
+
+/* Includes. */
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <asm/uaccess.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+
+#define k100ms              (HZ / 10)     // ~100 ms
+#define kFastBlinkCount     0             // ~100ms
+#define kSlowBlinkCount     5             // ~600ms
+
+#define MAX_VIRT_LEDS       12
+
+// uncomment // for debug led
+//#define DEBUG_LED
+
+// global variables:
+struct timer_list gLedTimer;
+int gTimerOn = FALSE;
+int gLedCount = 0;
+
+typedef struct ledinfo
+{
+    unsigned short ledMask;         // mask for led: ie. giop 10 = 0x0400
+    unsigned short ledActiveLow;    // GPIO bit reset to turn on LED
+    unsigned short ledMaskFail;     // mask for led: ie. giop 10 = 0x0400
+    unsigned short ledActiveLowFail;// GPIO bit reset to turn on LED
+    BOARD_LED_STATE ledState;       // current led state
+    BOARD_LED_STATE savedLedState;  // used in blink once for restore to the orignal ledState
+    int blinkCountDown;             // if == 0, do blink (toggle).  Is assgined value and dec by 1 at each timer.
+} LED_INFO, *PLED_INFO;
+
+static PLED_INFO gLed = NULL;
+static PLED_INFO gpVirtLeds[MAX_VIRT_LEDS];
+static HANDLE_LED_FUNC gLedHwFunc[MAX_VIRT_LEDS];
+static HANDLE_LED_FUNC gLedHwFailFunc[MAX_VIRT_LEDS];
+
+#if 0 /* BROKEN */
+#if defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+static int gLedOffInBridgeMode = 1;
+#elif defined(CONFIG_BCM96345)
+static int gLedOffInBridgeMode = 0;
+#endif
+#endif
+
+void ledTimerExpire(void);
+int initLedInfo( PLED_MAP_PAIR pCurMap, PLED_INFO pCurLed );
+
+//**************************************************************************************
+// LED operations
+//**************************************************************************************
+
+// turn led on and set the ledState
+void ledOn(PLED_INFO pLed)
+{
+    if( pLed->ledMask )
+    {
+        GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLow )
+            GPIO->GPIOio  &= ~pLed->ledMask;    // turn on the led
+        else
+            GPIO->GPIOio  |= pLed->ledMask;     // turn on the led
+        pLed->ledState = pLed->savedLedState = kLedStateOn;
+    }
+}
+
+
+// turn led off and set the ledState
+void ledOff(PLED_INFO pLed)
+{
+    if( pLed->ledMask )
+    {
+        GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLow )
+            GPIO->GPIOio  |= pLed->ledMask;     // turn off the led
+        else
+            GPIO->GPIOio  &= ~pLed->ledMask;    // turn off the led
+        pLed->ledState = pLed->savedLedState = kLedStateOff;
+    }
+}
+
+// turn led on and set the ledState
+void ledOnFail(PLED_INFO pLed)
+{
+    if( pLed->ledMaskFail )
+    {
+        GPIO->GPIODir |= pLed->ledMaskFail;     // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLowFail )
+            GPIO->GPIOio  &= ~pLed->ledMaskFail;// turn on the led
+        else
+            GPIO->GPIOio  |= pLed->ledMaskFail; // turn on the led
+        pLed->ledState = pLed->savedLedState = kLedStateFail;
+    }
+}
+
+
+// turn led off and set the ledState
+void ledOffFail(PLED_INFO pLed)
+{
+    if( pLed->ledMaskFail )
+    {
+        GPIO->GPIODir |= pLed->ledMaskFail;     // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLowFail )
+            GPIO->GPIOio  |= pLed->ledMaskFail; // turn off the led
+        else
+            GPIO->GPIOio  &= ~pLed->ledMaskFail;// turn off the led
+        pLed->ledState = pLed->savedLedState = kLedStateOff;
+    }
+}
+
+
+// toggle the led and return the current ledState
+BOARD_LED_STATE ledToggle(PLED_INFO pLed)
+{
+    GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+    if (GPIO->GPIOio & pLed->ledMask)
+    {
+        GPIO->GPIOio &= ~(pLed->ledMask);
+        return( (pLed->ledActiveLow) ? kLedStateOn : kLedStateOff );
+    }
+    else
+    {
+        GPIO->GPIOio |= pLed->ledMask;
+        return( (pLed->ledActiveLow) ? kLedStateOff : kLedStateOn );
+    }
+}   
+
+
+// led timer.  Will return if timer is already on
+void ledTimerStart(void)
+{
+    if (gTimerOn)
+        return;
+
+#if defined(DEBUG_LED)
+    printk("led: add_timer\n");
+#endif
+
+    init_timer(&gLedTimer);
+    gLedTimer.function = (void*)ledTimerExpire;
+    gLedTimer.expires = jiffies + k100ms;        // timer expires in ~100ms
+    add_timer (&gLedTimer);
+    gTimerOn = TRUE;
+} 
+
+
+// led timer expire kicks in about ~100ms and perform the led operation according to the ledState and
+// restart the timer according to ledState
+void ledTimerExpire(void)
+{
+    int i;
+    PLED_INFO pCurLed;
+
+    gTimerOn = FALSE;
+
+    for (i = 0, pCurLed = gLed; i < gLedCount; i++, pCurLed++)
+    {
+#if defined(DEBUG_LED)
+        printk("led[%d]: Mask=0x%04x, State = %d, blcd=%d\n", i, pCurLed->ledMask, pCurLed->ledState, pCurLed->blinkCountDown);
+#endif
+        switch (pCurLed->ledState)
+        {
+            case kLedStateOn:
+            case kLedStateOff:
+            case kLedStateFail:
+                pCurLed->blinkCountDown = 0;            // reset the blink count down
+                break;
+
+            case kLedStateBlinkOnce:
+                ledToggle(pCurLed);
+                pCurLed->blinkCountDown = 0;                      // reset to 0
+                pCurLed->ledState = pCurLed->savedLedState;
+                if (pCurLed->ledState == kLedStateSlowBlinkContinues || 
+                    pCurLed->ledState == kLedStateFastBlinkContinues)
+                    ledTimerStart();                  // start timer if in blinkContinues stats
+                break;
+
+            case kLedStateSlowBlinkContinues:
+                if (pCurLed->blinkCountDown-- == 0)
+                {
+                    pCurLed->blinkCountDown = kSlowBlinkCount;
+                    ledToggle(pCurLed);
+                }
+                ledTimerStart();
+                break;
+
+            case kLedStateFastBlinkContinues:
+                if (pCurLed->blinkCountDown-- == 0)
+                {
+                    pCurLed->blinkCountDown = kFastBlinkCount;
+                    ledToggle(pCurLed);
+                }
+                ledTimerStart();
+                break;
+
+            default:
+                printk("Invalid state = %d\n", pCurLed->ledState);
+        }
+    }
+}
+
+// initialize the gLedCount and allocate and fill gLed struct
+void __init boardLedInit(PLED_MAP_PAIR cLedMapping)
+{
+    PLED_MAP_PAIR p1, p2;
+    PLED_INFO pCurLed;
+    int needTimer = FALSE;
+    int alreadyUsed = 0;
+
+#if defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+    /* Set blink rate for BCM6348/BCM6338 hardware LEDs. */
+    GPIO->LEDCtrl &= ~LED_INTERVAL_SET_MASK;
+    GPIO->LEDCtrl |= LED_INTERVAL_SET_80MS;
+#endif
+
+    memset( gpVirtLeds, 0x00, sizeof(gpVirtLeds) );
+    memset( gLedHwFunc, 0x00, sizeof(gLedHwFunc) );
+    memset( gLedHwFailFunc, 0x00, sizeof(gLedHwFailFunc) );
+
+    gLedCount = 0;
+
+    // Check for multiple LED names and multiple LED GPIO pins that share the
+    // same physical board LED.
+    for( p1 = cLedMapping; p1->ledName != kLedEnd; p1++ )
+    {
+        alreadyUsed = 0;
+        for( p2 = cLedMapping; p2 != p1; p2++ )
+        {
+            if( (p1->ledMask && p1->ledMask == p2->ledMask) ||
+                (p1->ledMaskFail && p1->ledMaskFail == p2->ledMaskFail) )
+            {
+                alreadyUsed = 1;
+                break;
+            }
+        }
+
+        if( alreadyUsed == 0  )
+            gLedCount++;
+    }
+
+    gLed = (PLED_INFO) kmalloc((gLedCount * sizeof(LED_INFO)), GFP_KERNEL);
+    if( gLed == NULL )
+    {
+        printk( "LED memory allocation error.\n" );
+        return;
+    }
+
+    memset( gLed, 0x00, gLedCount * sizeof(LED_INFO) );
+
+    // initial the gLed with unique ledMask and initial state. If more than 1 ledNames share the physical led 
+    // (ledMask) the first defined led's ledInitState will be used.
+    pCurLed = gLed;
+    for( p1 = cLedMapping; p1->ledName != kLedEnd; p1++ )
+    {
+        if( (int) p1->ledName > MAX_VIRT_LEDS )
+            continue;
+
+        alreadyUsed = 0;
+        for( p2 = cLedMapping; p2 != p1; p2++ )
+        {
+            if( (p1->ledMask && p1->ledMask == p2->ledMask) ||
+                (p1->ledMaskFail && p1->ledMaskFail == p2->ledMaskFail) )
+            {
+                alreadyUsed = 1;
+                break;
+            }
+        }
+
+        if( alreadyUsed == 0 )
+        {
+            // Initialize the board LED for the first time.
+            needTimer = initLedInfo( p1, pCurLed );
+            gpVirtLeds[(int) p1->ledName] = pCurLed;
+            pCurLed++;
+        }
+        else
+        {
+            PLED_INFO pLed;
+            for( pLed = gLed; pLed != pCurLed; pLed++ )
+            {
+                // Find the LED_INFO structure that has already been initialized.
+                if((pLed->ledMask && pLed->ledMask == p1->ledMask) ||
+                   (pLed->ledMaskFail && pLed->ledMaskFail==p1->ledMaskFail))
+                {
+                    // The board LED has already been initialized but possibly
+                    // not completely initialized.
+                    if( p1->ledMask )
+                    {
+                        pLed->ledMask = p1->ledMask;
+                        pLed->ledActiveLow = p1->ledActiveLow;
+                    }
+                    if( p1->ledMaskFail )
+                    {
+                        pLed->ledMaskFail = p1->ledMaskFail;
+                        pLed->ledActiveLowFail = p1->ledActiveLowFail;
+                    }
+                    gpVirtLeds[(int) p1->ledName] = pLed;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (needTimer)
+        ledTimerStart();
+
+#if defined(DEBUG_LED)
+    int i;
+    for (i=0; i < gLedCount; i++)
+        printk("initLed: led[%d]: mask=0x%04x, state=%d\n", i,(gLed+i)->ledMask, (gLed+i)->ledState);
+#endif
+
+}
+
+// Initialize a structure that contains information about a physical board LED
+// control.  The board LED may contain more than one GPIO pin to control a
+// normal condition (green) or a failure condition (red).
+int initLedInfo( PLED_MAP_PAIR pCurMap, PLED_INFO pCurLed )
+{
+    int needTimer = FALSE;
+    pCurLed->ledState = pCurLed->savedLedState = pCurMap->ledInitState;
+    pCurLed->ledMask = pCurMap->ledMask;
+    pCurLed->ledActiveLow = pCurMap->ledActiveLow;
+    pCurLed->ledMaskFail = pCurMap->ledMaskFail;
+    pCurLed->ledActiveLowFail = pCurMap->ledActiveLowFail;
+
+    switch (pCurLed->ledState)
+    {
+        case kLedStateOn:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOn(pCurLed);
+            break;
+        case kLedStateOff:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOff(pCurLed);
+            break;
+        case kLedStateFail:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOnFail(pCurLed);
+            break;
+        case kLedStateBlinkOnce:
+            pCurLed->blinkCountDown = 1;
+            needTimer = TRUE;
+            break;
+        case kLedStateSlowBlinkContinues:
+            pCurLed->blinkCountDown = kSlowBlinkCount;
+            needTimer = TRUE;
+            break;
+        case kLedStateFastBlinkContinues:
+            pCurLed->blinkCountDown = kFastBlinkCount;
+            needTimer = TRUE;
+            break;
+        default:
+            printk("Invalid state = %d\n", pCurLed->ledState);
+    }
+
+    return( needTimer );
+}
+
+#if 0 /* BROKEN */
+// Determines if there is at least one interface in bridge mode.  Bridge mode
+// is determined by the cfm convention of naming bridge interfaces nas17
+// through nas24.
+static int isBridgedProtocol(void)
+{
+    extern int dev_get(const char *name);
+    const int firstBridgeId = 17;
+    const int lastBridgeId = 24;
+    int i;
+    int ret = FALSE;
+    char name[16];
+
+    for( i = firstBridgeId; i <= lastBridgeId; i++ )
+    {
+        sprintf( name, "nas%d", i );
+
+        if( dev_get(name) )
+        {
+            ret = TRUE;
+            break;
+        }
+    }
+
+    return(ret);
+}
+#endif
+
+// led ctrl.  Maps the ledName to the corresponding ledInfoPtr and perform the led operation
+void boardLedCtrl(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState)
+{
+    PLED_INFO ledInfoPtr;
+
+    // do the mapping from virtual to physical led
+    if( (int) ledName < MAX_VIRT_LEDS )
+        ledInfoPtr = gpVirtLeds[(int) ledName];
+    else
+        ledInfoPtr = NULL;
+
+    if (ledInfoPtr == NULL)
+        return;
+
+    if( ledState != kLedStateFail && gLedHwFunc[(int) ledName] )
+    {
+        (*gLedHwFunc[(int) ledName]) (ledName, ledState);
+        ledOffFail(ledInfoPtr);
+        return;
+    }
+    else
+        if( ledState == kLedStateFail && gLedHwFailFunc[(int) ledName] )
+        {
+            (*gLedHwFailFunc[(int) ledName]) (ledName, ledState);
+            ledOff(ledInfoPtr);
+            return;
+        }
+
+#if 0 /* BROKEN */
+    // Do not blink the WAN Data LED if at least one interface is in bridge mode.
+    if(gLedOffInBridgeMode == 1 && (ledName == kLedWanData || ledName == kLedPPP))
+    {
+        static int BridgedProtocol = -1;
+
+        if( BridgedProtocol == -1 )
+            BridgedProtocol = isBridgedProtocol();
+
+        if( BridgedProtocol == TRUE )
+            return;
+    }
+#endif
+
+    // If the state is kLedStateFail and there is not a failure LED defined
+    // in the board parameters, change the state to kLedStateFastBlinkContinues.
+    if( ledState == kLedStateFail && ledInfoPtr->ledMaskFail == 0 )
+        ledState = kLedStateFastBlinkContinues;
+
+    switch (ledState)
+    {
+        case kLedStateOn:
+            // First, turn off the complimentary (failure) LED GPIO.
+            if( ledInfoPtr->ledMaskFail )
+                ledOffFail(ledInfoPtr);
+            else
+                if( gLedHwFailFunc[(int) ledName] )
+                    (*gLedHwFailFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn on the specified LED GPIO.
+            ledOn(ledInfoPtr);
+            break;
+
+        case kLedStateOff: 
+            // First, turn off the complimentary (failure) LED GPIO.
+            if( ledInfoPtr->ledMaskFail )
+                ledOffFail(ledInfoPtr);
+            else
+                if( gLedHwFailFunc[(int) ledName] )
+                    (*gLedHwFailFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn off the specified LED GPIO.
+            ledOff(ledInfoPtr);
+            break;
+
+        case kLedStateFail:
+            // First, turn off the complimentary (normal) LED GPIO.
+            if( ledInfoPtr->ledMask )
+                ledOff(ledInfoPtr);
+            else
+                if( gLedHwFunc[(int) ledName] )
+                    (*gLedHwFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn on (red) the specified LED GPIO.
+            ledOnFail(ledInfoPtr);
+            break;
+
+        case kLedStateBlinkOnce:
+            // skip blinkOnce if it is already in Slow/Fast blink continues state
+            if (ledInfoPtr->savedLedState == kLedStateSlowBlinkContinues ||
+                ledInfoPtr->savedLedState == kLedStateFastBlinkContinues)
+                ;
+            else
+            {
+                if (ledInfoPtr->blinkCountDown == 0)  // skip the call if it is 1
+                {
+                    ledToggle(ledInfoPtr);
+                    ledInfoPtr->blinkCountDown = 1;  // it will be reset to 0 when timer expires
+                    ledInfoPtr->ledState = kLedStateBlinkOnce;
+                    ledTimerStart();
+                }
+            }
+            break;
+
+        case kLedStateSlowBlinkContinues:
+            ledInfoPtr->blinkCountDown = kSlowBlinkCount;
+            ledInfoPtr->ledState = kLedStateSlowBlinkContinues;
+            ledInfoPtr->savedLedState = kLedStateSlowBlinkContinues;
+            ledTimerStart();
+            break;
+
+        case kLedStateFastBlinkContinues:
+            ledInfoPtr->blinkCountDown = kFastBlinkCount;
+            ledInfoPtr->ledState = kLedStateFastBlinkContinues;
+            ledInfoPtr->savedLedState = kLedStateFastBlinkContinues;
+            ledTimerStart();
+            break;
+
+        default:
+            printk("Invalid led state\n");
+    }
+}
+
+// This function is called for an LED that is controlled by hardware.
+void kerSysLedRegisterHwHandler( BOARD_LED_NAME ledName,
+    HANDLE_LED_FUNC ledHwFunc, int ledFailType )
+{
+    if( (int) ledName < MAX_VIRT_LEDS )
+    {
+        if( ledFailType == 1 )
+            gLedHwFailFunc[(int) ledName] = ledHwFunc;
+        else
+            gLedHwFunc[(int) ledName] = ledHwFunc;
+    }
+}
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/board.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/board.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/board.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/board.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,1570 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***************************************************************************
+ * File Name  : board.c
+ *
+ * Description: This file contains Linux character device driver entry 
+ *              for the board related ioctl calls: flash, get free kernel
+ *              page and dump kernel memory, etc.
+ *
+ * Created on :  2/20/2002  seanl:  use cfiflash.c, cfliflash.h (AMD specific)
+ *
+ ***************************************************************************/
+
+
+/* Includes. */
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/if.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#include <bcmTag.h>
+#include "boardparms.h"
+#include "cfiflash.h"
+#include "bcm_intr.h"
+#include "board.h"
+#include "bcm_map_part.h"
+
+/* Typedefs. */
+#if defined (NON_CONSECUTIVE_MAC)
+// used to be the last octet. Now changed to the first 5 bits of the the forth octet
+// to reduced the duplicated MAC addresses.
+#define CHANGED_OCTET   3
+#define SHIFT_BITS      3
+#else
+#define CHANGED_OCTET   1
+#define SHIFT_BITS      0
+#endif
+
+#if defined (WIRELESS)
+#define SES_BTN_PRESSED 0x00000001
+#define SES_EVENTS      SES_BTN_PRESSED /*OR all values if any*/
+#define SES_LED_OFF     0
+#define SES_LED_ON      1
+#define SES_LED_BLINK   2
+#endif
+
+typedef struct
+{
+    unsigned long ulId;
+    char chInUse;
+    char chReserved[3];
+} MAC_ADDR_INFO, *PMAC_ADDR_INFO;
+
+typedef struct
+{
+    unsigned long ulSdramSize;
+    unsigned long ulPsiSize;
+    unsigned long ulNumMacAddrs;
+    unsigned long ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    MAC_ADDR_INFO MacAddrs[1];
+} NVRAM_INFO, *PNVRAM_INFO;
+
+typedef struct
+{
+    unsigned long eventmask;    
+} BOARD_IOC, *PBOARD_IOC;
+
+
+/*Dyinggasp callback*/
+typedef void (*cb_dgasp_t)(void *arg);
+typedef struct _CB_DGASP__LIST
+{
+    struct list_head list;
+    char name[IFNAMSIZ];
+    cb_dgasp_t cb_dgasp_fn;
+    void *context;
+}CB_DGASP_LIST , *PCB_DGASP_LIST;
+
+
+static LED_MAP_PAIR LedMapping[] =
+{   // led name     Initial state       physical pin (ledMask)
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0}, 
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0}, 
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},     
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0} // NOTE: kLedEnd has to be at the end.
+};
+
+/* Externs. */
+extern struct file fastcall *fget_light(unsigned int fd, int *fput_needed);
+extern unsigned int nr_free_pages (void);
+extern const char *get_system_type(void);
+extern void kerSysFlashInit(void);
+extern unsigned long get_nvram_start_addr(void);
+extern unsigned long get_scratch_pad_start_addr(void);
+extern unsigned long getMemorySize(void);
+extern void __init boardLedInit(PLED_MAP_PAIR);
+extern void boardLedCtrl(BOARD_LED_NAME, BOARD_LED_STATE);
+extern void kerSysLedRegisterHandler( BOARD_LED_NAME ledName,
+    HANDLE_LED_FUNC ledHwFunc, int ledFailType );
+
+/* Prototypes. */
+void __init InitNvramInfo( void );
+static int board_open( struct inode *inode, struct file *filp );
+static int board_ioctl( struct inode *inode, struct file *flip, unsigned int command, unsigned long arg );
+static ssize_t board_read(struct file *filp,  char __user *buffer, size_t count, loff_t *ppos); 
+static unsigned int board_poll(struct file *filp, struct poll_table_struct *wait);
+static int board_release(struct inode *inode, struct file *filp);                        
+
+static BOARD_IOC* borad_ioc_alloc(void);
+static void borad_ioc_free(BOARD_IOC* board_ioc);
+
+/* DyingGasp function prototype */
+static void __init kerSysDyingGaspMapIntr(void);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+static irqreturn_t kerSysDyingGaspIsr(int irq, void * dev_id, struct pt_regs * regs);
+#else
+static unsigned int kerSysDyingGaspIsr(void);
+#endif
+static void __init kerSysInitDyingGaspHandler( void );
+static void __exit kerSysDeinitDyingGaspHandler( void );
+/* -DyingGasp function prototype - */
+
+
+#if defined (WIRELESS)
+static irqreturn_t sesBtn_isr(int irq, void *dev_id, struct pt_regs *ptregs);
+static void __init sesBtn_mapGpio(void);
+static void __init sesBtn_mapIntr(int context);
+static unsigned int sesBtn_poll(struct file *file, struct poll_table_struct *wait);
+static ssize_t sesBtn_read(struct file *file,  char __user *buffer, size_t count, loff_t *ppos);
+static void __init sesLed_mapGpio(void);
+static void sesLed_ctrl(int action);
+static void __init ses_board_init(void);
+static void __exit ses_board_deinit(void);
+#endif
+
+static PNVRAM_INFO g_pNvramInfo = NULL;
+static int g_ledInitialized = 0;
+static wait_queue_head_t g_board_wait_queue;
+static CB_DGASP_LIST *g_cb_dgasp_list_head = NULL;
+
+static int g_wakeup_monitor = 0;
+static struct file *g_monitor_file = NULL;
+static struct task_struct *g_monitor_task = NULL;
+static unsigned int (*g_orig_fop_poll)
+    (struct file *, struct poll_table_struct *) = NULL;
+
+static struct file_operations board_fops =
+{
+  open:       board_open,
+  ioctl:      board_ioctl,
+  poll:       board_poll,
+  read:       board_read,
+  release:    board_release,
+};
+
+uint32 board_major = 0;
+
+#if defined (WIRELESS)
+static unsigned short sesBtn_irq = BP_NOT_DEFINED;
+static unsigned short sesBtn_gpio = BP_NOT_DEFINED;
+static unsigned short sesLed_gpio = BP_NOT_DEFINED;
+#endif
+
+#if defined(MODULE)
+int init_module(void)
+{
+    return( brcm_board_init() );              
+}
+
+void cleanup_module(void)
+{
+    if (MOD_IN_USE)
+        printk("brcm flash: cleanup_module failed because module is in use\n");
+    else
+        brcm_board_cleanup();
+}
+#endif //MODULE 
+
+
+
+static int __init brcm_board_init( void )
+{
+    typedef int (*BP_LED_FUNC) (unsigned short *);
+    static struct BpLedInformation
+    {
+        BOARD_LED_NAME ledName;
+        BP_LED_FUNC bpFunc;
+        BP_LED_FUNC bpFuncFail;
+    } bpLedInfo[] =
+    {{kLedAdsl, BpGetAdslLedGpio, BpGetAdslFailLedGpio},
+     {kLedWireless, BpGetWirelessLedGpio, NULL},
+     {kLedUsb, BpGetUsbLedGpio, NULL},
+     {kLedHpna, BpGetHpnaLedGpio, NULL},
+     {kLedWanData, BpGetWanDataLedGpio, NULL},
+     {kLedPPP, BpGetPppLedGpio, BpGetPppFailLedGpio},
+     {kLedVoip, BpGetVoipLedGpio, NULL},
+     {kLedSes, BpGetWirelessSesLedGpio, NULL},     
+     {kLedEnd, NULL, NULL}
+    };
+
+    int ret;
+        
+    ret = register_chrdev(BOARD_DRV_MAJOR, "bcrmboard", &board_fops );
+    if (ret < 0)
+        printk( "brcm_board_init(major %d): fail to register device.\n",BOARD_DRV_MAJOR);
+    else 
+    {
+        PLED_MAP_PAIR pLedMap = LedMapping;
+        unsigned short gpio;
+        struct BpLedInformation *pInfo;
+
+        printk("brcmboard: brcm_board_init entry\n");
+        board_major = BOARD_DRV_MAJOR;
+        InitNvramInfo();
+
+        for( pInfo = bpLedInfo; pInfo->ledName != kLedEnd; pInfo++ )
+        {
+            if( pInfo->bpFunc && (*pInfo->bpFunc) (&gpio) == BP_SUCCESS )
+            {
+                pLedMap->ledName = pInfo->ledName;
+                pLedMap->ledMask = GPIO_NUM_TO_MASK(gpio);
+                pLedMap->ledActiveLow = (gpio & BP_ACTIVE_LOW) ? 1 : 0;
+            }
+            if( pInfo->bpFuncFail && (*pInfo->bpFuncFail) (&gpio) == BP_SUCCESS )
+            {
+                pLedMap->ledName = pInfo->ledName;
+                pLedMap->ledMaskFail = GPIO_NUM_TO_MASK(gpio);
+                pLedMap->ledActiveLowFail = (gpio & BP_ACTIVE_LOW) ? 1 : 0;
+            }
+            if( pLedMap->ledName != kLedEnd )
+                pLedMap++;
+        }
+        
+        init_waitqueue_head(&g_board_wait_queue);
+#if defined (WIRELESS)
+        ses_board_init();
+#endif        
+        kerSysInitDyingGaspHandler();
+        kerSysDyingGaspMapIntr();
+
+        boardLedInit(LedMapping);
+        g_ledInitialized = 1;
+    }
+
+    return ret;
+} 
+
+void __init InitNvramInfo( void )
+{
+    PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+    unsigned long ulNumMacAddrs = pNvramData->ulNumMacAddrs;
+
+    if( ulNumMacAddrs > 0 && ulNumMacAddrs <= NVRAM_MAC_COUNT_MAX )
+    {
+        unsigned long ulNvramInfoSize =
+            sizeof(NVRAM_INFO) + ((sizeof(MAC_ADDR_INFO) - 1) * ulNumMacAddrs);
+
+        g_pNvramInfo = (PNVRAM_INFO) kmalloc( ulNvramInfoSize, GFP_KERNEL );
+
+        if( g_pNvramInfo )
+        {
+            unsigned long ulPsiSize;
+            if( BpGetPsiSize( &ulPsiSize ) != BP_SUCCESS )
+                ulPsiSize = NVRAM_PSI_DEFAULT;
+            memset( g_pNvramInfo, 0x00, ulNvramInfoSize );
+            g_pNvramInfo->ulPsiSize = ulPsiSize * 1024;
+            g_pNvramInfo->ulNumMacAddrs = pNvramData->ulNumMacAddrs;
+            memcpy( g_pNvramInfo->ucaBaseMacAddr, pNvramData->ucaBaseMacAddr,
+                NVRAM_MAC_ADDRESS_LEN );
+            g_pNvramInfo->ulSdramSize = getMemorySize();
+        }
+        else
+            printk("ERROR - Could not allocate memory for NVRAM data\n");
+    }
+    else
+        printk("ERROR - Invalid number of MAC addresses (%ld) is configured.\n",
+            ulNumMacAddrs);
+}
+
+void __exit brcm_board_cleanup( void )
+{
+    printk("brcm_board_cleanup()\n");
+	
+    if (board_major != -1) 
+    {
+#if defined (WIRELESS)    	
+    	ses_board_deinit();
+#endif    	
+        kerSysDeinitDyingGaspHandler();
+        unregister_chrdev(board_major, "board_ioctl");
+    }
+} 
+
+static BOARD_IOC* borad_ioc_alloc(void)
+{
+    BOARD_IOC *board_ioc =NULL;
+    board_ioc = (BOARD_IOC*) kmalloc( sizeof(BOARD_IOC) , GFP_KERNEL );
+    if(board_ioc)
+    {
+        memset(board_ioc, 0, sizeof(BOARD_IOC));
+    }
+    return board_ioc;
+}
+
+static void borad_ioc_free(BOARD_IOC* board_ioc)
+{
+    if(board_ioc)
+    {
+        kfree(board_ioc);
+    }	
+}
+
+
+static int board_open( struct inode *inode, struct file *filp )
+{
+    filp->private_data = borad_ioc_alloc();
+
+    if (filp->private_data == NULL)
+        return -ENOMEM;
+            
+    return( 0 );
+} 
+
+static int board_release(struct inode *inode, struct file *filp)
+{
+    BOARD_IOC *board_ioc = filp->private_data;
+    
+    wait_event_interruptible(g_board_wait_queue, 1);    
+    borad_ioc_free(board_ioc);
+
+    return( 0 );
+} 
+
+
+static unsigned int board_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+#if defined (WIRELESS)        	
+    BOARD_IOC *board_ioc = filp->private_data;    	
+#endif
+    	
+    poll_wait(filp, &g_board_wait_queue, wait);
+#if defined (WIRELESS)        	
+    if(board_ioc->eventmask & SES_EVENTS){
+        mask |= sesBtn_poll(filp, wait);
+    }			
+#endif    
+
+    return mask;
+}
+
+
+static ssize_t board_read(struct file *filp,  char __user *buffer, size_t count, loff_t *ppos)
+{
+#if defined (WIRELESS)    
+    BOARD_IOC *board_ioc = filp->private_data;
+    if(board_ioc->eventmask & SES_EVENTS){
+    	return sesBtn_read(filp, buffer, count, ppos);
+    }
+#endif    
+    return 0;
+}
+
+//**************************************************************************************
+// Utitlities for dump memory, free kernel pages, mips soft reset, etc.
+//**************************************************************************************
+
+/***********************************************************************
+ * Function Name: dumpaddr
+ * Description  : Display a hex dump of the specified address.
+ ***********************************************************************/
+void dumpaddr( unsigned char *pAddr, int nLen )
+{
+    static char szHexChars[] = "0123456789abcdef";
+    char szLine[80];
+    char *p = szLine;
+    unsigned char ch, *q;
+    int i, j;
+    unsigned long ul;
+
+    while( nLen > 0 )
+    {
+        sprintf( szLine, "%8.8lx: ", (unsigned long) pAddr );
+        p = szLine + strlen(szLine);
+
+        for(i = 0; i < 16 && nLen > 0; i += sizeof(long), nLen -= sizeof(long))
+        {
+            ul = *(unsigned long *) &pAddr[i];
+            q = (unsigned char *) &ul;
+            for( j = 0; j < sizeof(long); j++ )
+            {
+                *p++ = szHexChars[q[j] >> 4];
+                *p++ = szHexChars[q[j] & 0x0f];
+                *p++ = ' ';
+            }
+        }
+
+        for( j = 0; j < 16 - i; j++ )
+            *p++ = ' ', *p++ = ' ', *p++ = ' ';
+
+        *p++ = ' ', *p++ = ' ', *p++ = ' ';
+
+        for( j = 0; j < i; j++ )
+        {
+            ch = pAddr[j];
+            *p++ = (ch > ' ' && ch < '~') ? ch : '.';
+        }
+
+        *p++ = '\0';
+        printk( "%s\r\n", szLine );
+
+        pAddr += i;
+    }
+    printk( "\r\n" );
+} /* dumpaddr */
+
+
+void kerSysMipsSoftReset(void)
+{
+#if defined(CONFIG_BCM96348)
+    if (PERF->RevID == 0x634800A1) {
+        typedef void (*FNPTR) (void);
+        FNPTR bootaddr = (FNPTR) FLASH_BASE;
+        int i;
+
+        /* Disable interrupts. */
+        cli();
+
+        /* Reset all blocks. */
+        PERF->BlockSoftReset &= ~BSR_ALL_BLOCKS;
+        for( i = 0; i < 1000000; i++ )
+            ;
+        PERF->BlockSoftReset |= BSR_ALL_BLOCKS;
+        /* Jump to the power on address. */
+        (*bootaddr) ();
+    }
+    else
+        PERF->pll_control |= SOFT_RESET;    // soft reset mips
+#else
+    PERF->pll_control |= SOFT_RESET;    // soft reset mips
+#endif
+}
+
+
+int kerSysGetMacAddress( unsigned char *pucaMacAddr, unsigned long ulId )
+{
+    int nRet = 0;
+    PMAC_ADDR_INFO pMai = NULL;
+    PMAC_ADDR_INFO pMaiFreeNoId = NULL;
+    PMAC_ADDR_INFO pMaiFreeId = NULL;
+    unsigned long i = 0, ulIdxNoId = 0, ulIdxId = 0, shiftedIdx = 0;
+
+    for( i = 0, pMai = g_pNvramInfo->MacAddrs; i < g_pNvramInfo->ulNumMacAddrs;
+        i++, pMai++ )
+    {
+        if( ulId == pMai->ulId || ulId == MAC_ADDRESS_ANY )
+        {
+            /* This MAC address has been used by the caller in the past. */
+            memcpy( pucaMacAddr, g_pNvramInfo->ucaBaseMacAddr,
+                NVRAM_MAC_ADDRESS_LEN );
+            shiftedIdx = i;
+            pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] += (shiftedIdx << SHIFT_BITS);
+            pMai->chInUse = 1;
+            pMaiFreeNoId = pMaiFreeId = NULL;
+            break;
+        }
+        else
+            if( pMai->chInUse == 0 )
+            {
+                if( pMai->ulId == 0 && pMaiFreeNoId == NULL )
+                {
+                    /* This is an available MAC address that has never been
+                     * used.
+                     */
+                    pMaiFreeNoId = pMai;
+                    ulIdxNoId = i;
+                }
+                else
+                    if( pMai->ulId != 0 && pMaiFreeId == NULL )
+                    {
+                        /* This is an available MAC address that has been used
+                         * before.  Use addresses that have never been used
+                         * first, before using this one.
+                         */
+                        pMaiFreeId = pMai;
+                        ulIdxId = i;
+                    }
+            }
+    }
+
+    if( pMaiFreeNoId || pMaiFreeId )
+    {
+        /* An available MAC address was found. */
+        memcpy(pucaMacAddr, g_pNvramInfo->ucaBaseMacAddr,NVRAM_MAC_ADDRESS_LEN);
+        if( pMaiFreeNoId )
+        {
+            shiftedIdx = ulIdxNoId;
+            pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] += (shiftedIdx << SHIFT_BITS);
+            pMaiFreeNoId->ulId = ulId;
+            pMaiFreeNoId->chInUse = 1;
+        }
+        else
+        {
+            shiftedIdx = ulIdxId;
+            pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] += (shiftedIdx << SHIFT_BITS);
+            pMaiFreeId->ulId = ulId;
+            pMaiFreeId->chInUse = 1;
+        }
+    }
+    else
+        if( i == g_pNvramInfo->ulNumMacAddrs )
+            nRet = -EADDRNOTAVAIL;
+
+    return( nRet );
+} /* kerSysGetMacAddr */
+
+int kerSysReleaseMacAddress( unsigned char *pucaMacAddr )
+{
+    int nRet = -EINVAL;
+    unsigned long ulIdx = 0;
+    int idx = (pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] -
+        g_pNvramInfo->ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET]);
+
+    // if overflow 255 (negitive), add 256 to have the correct index
+    if (idx < 0)
+        idx += 256;
+    ulIdx = (unsigned long) (idx >> SHIFT_BITS);
+
+    if( ulIdx < g_pNvramInfo->ulNumMacAddrs )
+    {
+        PMAC_ADDR_INFO pMai = &g_pNvramInfo->MacAddrs[ulIdx];
+        if( pMai->chInUse == 1 )
+        {
+            pMai->chInUse = 0;
+            nRet = 0;
+        }
+    }
+
+    return( nRet );
+} /* kerSysReleaseMacAddr */
+
+int kerSysGetSdramSize( void )
+{
+    return( (int) g_pNvramInfo->ulSdramSize );
+} /* kerSysGetSdramSize */
+
+
+void kerSysLedCtrl(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState)
+{
+    if (g_ledInitialized)
+      boardLedCtrl(ledName, ledState);
+}
+
+unsigned int kerSysMonitorPollHook( struct file *f, struct poll_table_struct *t)
+{
+    int mask = (*g_orig_fop_poll) (f, t);
+
+    if( g_wakeup_monitor == 1 && g_monitor_file == f )
+    {
+        /* If g_wakeup_monitor is non-0, the user mode application needs to
+         * return from a blocking select function.  Return POLLPRI which will
+         * cause the select to return with the exception descriptor set.
+         */
+        mask |= POLLPRI;
+        g_wakeup_monitor = 0;
+    }
+
+    return( mask );
+}
+
+/* Put the user mode application that monitors link state on a run queue. */
+void kerSysWakeupMonitorTask( void )
+{
+    g_wakeup_monitor = 1;
+    if( g_monitor_task )
+        wake_up_process( g_monitor_task );
+}
+
+//********************************************************************************************
+// misc. ioctl calls come to here. (flash, led, reset, kernel memory access, etc.)
+//********************************************************************************************
+static int board_ioctl( struct inode *inode, struct file *flip,
+                        unsigned int command, unsigned long arg )
+{
+    int ret = 0;
+    BOARD_IOCTL_PARMS ctrlParms;
+    unsigned char ucaMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    int allowedSize;
+
+    switch (command) 
+    {
+        case BOARD_IOCTL_FLASH_INIT:
+            // not used for now.  kerSysBcmImageInit();
+            break;
+
+
+        case BOARD_IOCTL_FLASH_WRITE:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0)
+            {
+                NVRAM_DATA SaveNvramData;
+                PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+
+                switch (ctrlParms.action)
+                {
+                    case SCRATCH_PAD:
+                        ret = kerSysScratchPadSet(ctrlParms.string, ctrlParms.buf, ctrlParms.offset);
+                        break;
+
+                    case PERSISTENT:
+                        ret = kerSysPersistentSet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+                
+                    case NVRAM:
+                        ret = kerSysNvRamSet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+
+                    case BCM_IMAGE_CFE:
+                        if( ctrlParms.strLen <= 0 || ctrlParms.strLen > FLASH45_LENGTH_BOOT_ROM )
+                        {
+                            printk("Illegal CFE size [%d]. Size allowed: [%d]\n",
+                                ctrlParms.strLen, FLASH45_LENGTH_BOOT_ROM);
+                            ret = -1;
+                            break;
+                        }
+
+                        // save NVRAM data into a local structure
+                        memcpy( &SaveNvramData, pNvramData, sizeof(NVRAM_DATA) );
+
+                        // set memory type field
+                        BpGetSdramSize( (unsigned long *) &ctrlParms.string[SDRAM_TYPE_ADDRESS_OFFSET] );
+
+                        ret = kerSysBcmImageSet(ctrlParms.offset, ctrlParms.string, ctrlParms.strLen);
+
+                        // if nvram is not valid, restore the current nvram settings
+                        if( BpSetBoardId( pNvramData->szBoardId ) != BP_SUCCESS &&
+                            *(unsigned long *) pNvramData == NVRAM_DATA_ID )
+                        {
+                            kerSysNvRamSet((char *) &SaveNvramData, sizeof(SaveNvramData), 0);
+                        }
+                        break;
+                        
+                    case BCM_IMAGE_FS:
+                        allowedSize = (int) flash_get_total_size() - \
+                            FLASH_RESERVED_AT_END - TAG_LEN - FLASH45_LENGTH_BOOT_ROM;
+                        if( ctrlParms.strLen <= 0 || ctrlParms.strLen > allowedSize)
+                        {
+                            printk("Illegal root file system size [%d]. Size allowed: [%d]\n",
+                                ctrlParms.strLen,  allowedSize);
+                            ret = -1;
+                            break;
+                        }
+                        ret = kerSysBcmImageSet(ctrlParms.offset, ctrlParms.string, ctrlParms.strLen);
+                        kerSysMipsSoftReset();
+                        break;
+
+                    case BCM_IMAGE_KERNEL:  // not used for now.
+                        break;
+                    case BCM_IMAGE_WHOLE:
+                        if(ctrlParms.strLen <= 0)
+                        {
+                            printk("Illegal flash image size [%d].\n", ctrlParms.strLen);
+                            ret = -1;
+                            break;
+                        }
+
+                        // save NVRAM data into a local structure
+                        memcpy( &SaveNvramData, pNvramData, sizeof(NVRAM_DATA) );
+
+                        ret = kerSysBcmImageSet(ctrlParms.offset, ctrlParms.string, ctrlParms.strLen);
+
+                        // if nvram is not valid, restore the current nvram settings
+                        if( BpSetBoardId( pNvramData->szBoardId ) != BP_SUCCESS &&
+                            *(unsigned long *) pNvramData == NVRAM_DATA_ID )
+                        {
+                            kerSysNvRamSet((char *) &SaveNvramData, sizeof(SaveNvramData), 0);
+                        }
+
+                        kerSysMipsSoftReset();
+                        break;
+
+                    default:
+                        ret = -EINVAL;
+                        printk("flash_ioctl_command: invalid command %d\n", ctrlParms.action);
+                        break;
+                }
+                ctrlParms.result = ret;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_FLASH_READ:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                switch (ctrlParms.action)
+                {
+                    case SCRATCH_PAD:
+                        ret = kerSysScratchPadGet(ctrlParms.string, ctrlParms.buf, ctrlParms.offset);
+                        break;
+
+                    case PERSISTENT:
+                        ret = kerSysPersistentGet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+
+                    case NVRAM:
+                        ret = kerSysNvRamGet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+
+                    case FLASH_SIZE:
+                        ret = kerSysFlashSizeGet();
+                        break;
+
+                    default:
+                        ret = -EINVAL;
+                        printk("Not supported.  invalid command %d\n", ctrlParms.action);
+                        break;
+                }
+                ctrlParms.result = ret;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_GET_NR_PAGES:
+            ctrlParms.result = nr_free_pages() + get_page_cache_size();
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_DUMP_ADDR:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                dumpaddr( (unsigned char *) ctrlParms.string, ctrlParms.strLen );
+                ctrlParms.result = 0;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_SET_MEMORY:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                unsigned long  *pul = (unsigned long *)  ctrlParms.string;
+                unsigned short *pus = (unsigned short *) ctrlParms.string;
+                unsigned char  *puc = (unsigned char *)  ctrlParms.string;
+                switch( ctrlParms.strLen )
+                {
+                    case 4:
+                        *pul = (unsigned long) ctrlParms.offset;
+                        break;
+                    case 2:
+                        *pus = (unsigned short) ctrlParms.offset;
+                        break;
+                    case 1:
+                        *puc = (unsigned char) ctrlParms.offset;
+                        break;
+                }
+                dumpaddr( (unsigned char *) ctrlParms.string, sizeof(long) );
+                ctrlParms.result = 0;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+      
+        case BOARD_IOCTL_MIPS_SOFT_RESET:
+            kerSysMipsSoftReset();
+            break;
+
+        case BOARD_IOCTL_LED_CTRL:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+	            kerSysLedCtrl((BOARD_LED_NAME)ctrlParms.strLen, (BOARD_LED_STATE)ctrlParms.offset);
+	            ret = 0;
+	        }
+            break;
+
+        case BOARD_IOCTL_GET_ID:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg,
+                sizeof(ctrlParms)) == 0) 
+            {
+                if( ctrlParms.string )
+                {
+                    char *p = (char *) get_system_type();
+                    if( strlen(p) + 1 < ctrlParms.strLen )
+                        ctrlParms.strLen = strlen(p) + 1;
+                    __copy_to_user(ctrlParms.string, p, ctrlParms.strLen);
+                }
+
+                ctrlParms.result = 0;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+            }
+            break;
+
+        case BOARD_IOCTL_GET_MAC_ADDRESS:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                ctrlParms.result = kerSysGetMacAddress( ucaMacAddr,
+                    ctrlParms.offset );
+
+                if( ctrlParms.result == 0 )
+                {
+                    __copy_to_user(ctrlParms.string, ucaMacAddr,
+                        sizeof(ucaMacAddr));
+                }
+
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_RELEASE_MAC_ADDRESS:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                if (copy_from_user((void*)ucaMacAddr, (void*)ctrlParms.string, \
+                     NVRAM_MAC_ADDRESS_LEN) == 0) 
+                {
+                    ctrlParms.result = kerSysReleaseMacAddress( ucaMacAddr );
+                }
+                else
+                {
+                    ctrlParms.result = -EACCES;
+                }
+
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_GET_PSI_SIZE:
+            ctrlParms.result = (int) g_pNvramInfo->ulPsiSize;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_GET_SDRAM_SIZE:
+            ctrlParms.result = (int) g_pNvramInfo->ulSdramSize;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_GET_BASE_MAC_ADDRESS:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                __copy_to_user(ctrlParms.string, g_pNvramInfo->ucaBaseMacAddr, NVRAM_MAC_ADDRESS_LEN);
+                ctrlParms.result = 0;
+
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_GET_CHIP_ID:
+            ctrlParms.result = (int) (PERF->RevID & 0xFFFF0000) >> 16;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_GET_NUM_ENET: {
+            ETHERNET_MAC_INFO EnetInfos[BP_MAX_ENET_MACS];
+            int i, numeth = 0;
+            if (BpGetEthernetMacInfo(EnetInfos, BP_MAX_ENET_MACS) == BP_SUCCESS) {
+            for( i = 0; i < BP_MAX_ENET_MACS; i++) {
+                if (EnetInfos[i].ucPhyType != BP_ENET_NO_PHY) {
+                numeth++;
+                }
+            }
+            ctrlParms.result = numeth;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,	 sizeof(BOARD_IOCTL_PARMS));   
+            ret = 0;
+            }
+	        else {
+	            ret = -EFAULT;
+	        }
+	        break;
+            }
+
+        case BOARD_IOCTL_GET_CFE_VER:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                char *vertag =  (char *)(FLASH_BASE + CFE_VERSION_OFFSET);
+                if (ctrlParms.strLen < CFE_VERSION_SIZE) {
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                    ret = -EFAULT;
+                }
+                else if (strncmp(vertag, "cfe-v", 5)) { // no tag info in flash
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                    ret = 0;
+                }
+                else {
+                    ctrlParms.result = 1;
+                    __copy_to_user(ctrlParms.string, vertag+CFE_VERSION_MARK_SIZE, CFE_VERSION_SIZE);
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                    ret = 0;
+                }
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;
+
+        case BOARD_IOCTL_GET_ENET_CFG:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                ETHERNET_MAC_INFO EnetInfos[BP_MAX_ENET_MACS];
+                if (BpGetEthernetMacInfo(EnetInfos, BP_MAX_ENET_MACS) == BP_SUCCESS) {
+                    if (ctrlParms.strLen == sizeof(EnetInfos)) {
+                        __copy_to_user(ctrlParms.string, EnetInfos, sizeof(EnetInfos));
+                        ctrlParms.result = 0;
+                        __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                        ret = 0;
+                    } else
+	                    ret = -EFAULT;
+                }
+	            else {
+	                ret = -EFAULT;
+	            }
+	            break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+
+#if defined (WIRELESS)
+        case BOARD_IOCTL_GET_WLAN_ANT_INUSE:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                unsigned short antInUse = 0;
+                if (BpGetWirelessAntInUse(&antInUse) == BP_SUCCESS) {
+                    if (ctrlParms.strLen == sizeof(antInUse)) {
+                        __copy_to_user(ctrlParms.string, &antInUse, sizeof(antInUse));
+                        ctrlParms.result = 0;
+                        __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                        ret = 0;
+                    } else
+	                    ret = -EFAULT;
+                }
+	        else {
+	           ret = -EFAULT;
+	        }
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+#endif            
+        case BOARD_IOCTL_SET_TRIGGER_EVENT:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {            	
+            	BOARD_IOC *board_ioc = (BOARD_IOC *)flip->private_data;            	
+                ctrlParms.result = -EFAULT;
+                ret = -EFAULT;
+                if (ctrlParms.strLen == sizeof(unsigned long)) {                 	                    
+                    board_ioc->eventmask |= *((int*)ctrlParms.string);                    
+#if defined (WIRELESS)                    
+                    if((board_ioc->eventmask & SES_EVENTS)) {
+                        if(sesBtn_irq != BP_NOT_DEFINED) {
+                            BcmHalInterruptEnable(sesBtn_irq);
+                            ctrlParms.result = 0;
+                            ret = 0;
+                        }                                                
+                    } 
+#endif                                                
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));                        
+                }
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;                        
+
+        case BOARD_IOCTL_GET_TRIGGER_EVENT:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+            	BOARD_IOC *board_ioc = (BOARD_IOC *)flip->private_data;
+                if (ctrlParms.strLen == sizeof(unsigned long)) {
+                    __copy_to_user(ctrlParms.string, &board_ioc->eventmask, sizeof(unsigned long));
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                    ret = 0;
+                } else
+	            ret = -EFAULT;
+
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;                
+            
+        case BOARD_IOCTL_UNSET_TRIGGER_EVENT:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                if (ctrlParms.strLen == sizeof(unsigned long)) {
+                    BOARD_IOC *board_ioc = (BOARD_IOC *)flip->private_data;                	
+                    board_ioc->eventmask &= (~(*((int*)ctrlParms.string)));                  
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                    ret = 0;
+                } else
+	            ret = -EFAULT;
+
+	        break;
+            } 
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+#if defined (WIRELESS)
+        case BOARD_IOCTL_SET_SES_LED:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                if (ctrlParms.strLen == sizeof(int)) {
+                    sesLed_ctrl(*(int*)ctrlParms.string);
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                    ret = 0;
+                } else
+	            ret = -EFAULT;
+
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+#endif                                                            
+
+        case BOARD_IOCTL_SET_MONITOR_FD:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                int fput_needed = 0;
+
+                g_monitor_file = fget_light( ctrlParms.offset, &fput_needed );
+                if( g_monitor_file ) {
+                    /* Hook this file descriptor's poll function in order to set
+                     * the exception descriptor when there is a change in link
+                     * state.
+                     */
+                    g_monitor_task = current;
+                    g_orig_fop_poll = g_monitor_file->f_op->poll;
+                    g_monitor_file->f_op->poll = kerSysMonitorPollHook;
+                }
+            }
+            break;
+
+        case BOARD_IOCTL_WAKEUP_MONITOR_TASK:
+            kerSysWakeupMonitorTask();
+            break;
+
+        default:
+            ret = -EINVAL;
+            ctrlParms.result = 0;
+            printk("board_ioctl: invalid command %x, cmd %d .\n",command,_IOC_NR(command));
+            break;
+
+  } /* switch */
+
+  return (ret);
+
+} /* board_ioctl */
+
+/***************************************************************************
+ * SES Button ISR/GPIO/LED functions.
+ ***************************************************************************/
+#if defined (WIRELESS) 
+static irqreturn_t sesBtn_isr(int irq, void *dev_id, struct pt_regs *ptregs)
+{   
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96345_) || defined(CONFIG_BCM96345)
+    unsigned short gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned short *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96348_) || defined (CONFIG_BCM96348)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+
+    if( (sesBtn_gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(sesBtn_gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+#endif 
+    		
+    if (!(*gpio_reg & gpio_mask)){
+        wake_up_interruptible(&g_board_wait_queue);
+        return IRQ_RETVAL(1);
+    } else {
+        return IRQ_RETVAL(0);    	
+    }
+}
+
+static void __init sesBtn_mapGpio()
+{	
+    if( BpGetWirelessSesBtnGpio(&sesBtn_gpio) == BP_SUCCESS )
+    {
+        printk("SES: Button GPIO 0x%x is enabled\n", sesBtn_gpio);    
+    }
+}
+
+static void __init sesBtn_mapIntr(int context)
+{    	
+    if( BpGetWirelessSesExtIntr(&sesBtn_irq) == BP_SUCCESS )
+    {
+    	printk("SES: Button Interrupt 0x%x is enabled\n", sesBtn_irq);
+    }
+    else
+    	return;
+    	    
+    sesBtn_irq += INTERRUPT_ID_EXTERNAL_0;	
+    		
+    if (BcmHalMapInterrupt((FN_HANDLER)sesBtn_isr, context, sesBtn_irq)) {
+    	printk("SES: Interrupt mapping failed\n");
+    }    
+    BcmHalInterruptEnable(sesBtn_irq);
+}
+
+
+static unsigned int sesBtn_poll(struct file *file, struct poll_table_struct *wait)
+{
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96345_) || defined(CONFIG_BCM96345)
+    unsigned short gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned short *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96348_) || defined (CONFIG_BCM96348)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+
+    if( (sesBtn_gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(sesBtn_gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+#endif 
+    		
+    if (!(*gpio_reg & gpio_mask)){
+	return POLLIN;
+    }	
+    return 0;
+}
+
+static ssize_t sesBtn_read(struct file *file,  char __user *buffer, size_t count, loff_t *ppos)
+{
+    volatile unsigned int event=0;
+    ssize_t ret=0;	
+
+#if defined(_BCM96338_) || defined (CONFIG_BCM96338)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96345_) || defined (CONFIG_BCM96345)
+    unsigned short gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned short *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96348_) || defined (CONFIG_BCM96348)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+    
+    if( (sesBtn_gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(sesBtn_gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+#endif 
+
+    if(*gpio_reg & gpio_mask){
+	BcmHalInterruptEnable(sesBtn_irq);		
+	return ret;
+    }	
+    event = SES_EVENTS;
+    __copy_to_user((char*)buffer, (char*)&event, sizeof(event));	
+    BcmHalInterruptEnable(sesBtn_irq);	
+    count -= sizeof(event);
+    buffer += sizeof(event);
+    ret += sizeof(event);	
+    return ret;	
+}
+
+static void __init sesLed_mapGpio()
+{	
+    if( BpGetWirelessSesBtnGpio(&sesLed_gpio) == BP_SUCCESS )
+    {
+        printk("SES: LED GPIO 0x%x is enabled\n", sesBtn_gpio);    
+    }
+}
+
+static void sesLed_ctrl(int action)
+{
+
+    //char status = ((action >> 8) & 0xff); /* extract status */
+    //char event = ((action >> 16) & 0xff); /* extract event */        
+    //char blinktype = ((action >> 24) & 0xff); /* extract blink type for SES_LED_BLINK  */
+    
+    BOARD_LED_STATE led;
+    
+    if(sesLed_gpio == BP_NOT_DEFINED)
+        return;
+    	
+    action &= 0xff; /* extract led */
+
+    //printk("blinktype=%d, event=%d, status=%d\n",(int)blinktype, (int)event, (int)status);
+            	
+    switch (action) 
+    {
+        case SES_LED_ON:
+            //printk("SES: led on\n");
+            led = kLedStateOn;                                          
+            break;
+        case SES_LED_BLINK:
+            //printk("SES: led blink\n");
+            led = kLedStateSlowBlinkContinues;           		
+            break;
+        case SES_LED_OFF:
+            default:
+            //printk("SES: led off\n");
+            led = kLedStateOff;  						
+    }	
+    
+    kerSysLedCtrl(kLedSes, led);
+}
+
+static void __init ses_board_init()
+{
+    sesBtn_mapGpio();
+    sesBtn_mapIntr(0);
+    sesLed_mapGpio();
+}
+static void __exit ses_board_deinit()
+{
+    if(sesBtn_irq)
+        BcmHalInterruptDisable(sesBtn_irq);
+}
+#endif
+
+/***************************************************************************
+ * Dying gasp ISR and functions.
+ ***************************************************************************/
+#define KERSYS_DBG	printk
+
+#if defined(CONFIG_BCM96345)
+#define	CYCLE_PER_US	70
+#elif defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+/* The BCM6348 cycles per microsecond is really variable since the BCM6348
+ * MIPS speed can vary depending on the PLL settings.  However, an appoximate
+ * value of 120 will still work OK for the test being done.
+ */
+#define	CYCLE_PER_US	120
+#endif
+#define	DG_GLITCH_TO	(100*CYCLE_PER_US)
+ 
+static void __init kerSysDyingGaspMapIntr()
+{
+    unsigned long ulIntr;
+    	
+#if defined(CONFIG_BCM96348) || defined(_BCM96348_) || defined(CONFIG_BCM96338) || defined(_BCM96338_)
+    if( BpGetAdslDyingGaspExtIntr( &ulIntr ) == BP_SUCCESS ) {
+		BcmHalMapInterrupt((FN_HANDLER)kerSysDyingGaspIsr, 0, INTERRUPT_ID_DG);
+		BcmHalInterruptEnable( INTERRUPT_ID_DG );
+    }
+#elif defined(CONFIG_BCM96345) || defined(_BCM96345_)
+    if( BpGetAdslDyingGaspExtIntr( &ulIntr ) == BP_SUCCESS ) {
+        ulIntr += INTERRUPT_ID_EXTERNAL_0;
+        BcmHalMapInterrupt((FN_HANDLER)kerSysDyingGaspIsr, 0, ulIntr);
+        BcmHalInterruptEnable( ulIntr );
+    }
+#endif
+
+} 
+
+void kerSysSetWdTimer(ulong timeUs)
+{
+	TIMER->WatchDogDefCount = timeUs * (FPERIPH/1000000);
+	TIMER->WatchDogCtl = 0xFF00;
+	TIMER->WatchDogCtl = 0x00FF;
+}
+
+ulong kerSysGetCycleCount(void)
+{
+    ulong cnt; 
+#ifdef _WIN32_WCE
+    cnt = 0;
+#else
+    __asm volatile("mfc0 %0, $9":"=d"(cnt));
+#endif
+    return(cnt); 
+}
+
+static Bool kerSysDyingGaspCheckPowerLoss(void)
+{
+    ulong clk0;
+    ulong ulIntr;
+
+    ulIntr = 0;
+    clk0 = kerSysGetCycleCount();
+
+    UART->Data = 'D';
+    UART->Data = '%';
+    UART->Data = 'G';
+
+#if defined(CONFIG_BCM96345)
+    BpGetAdslDyingGaspExtIntr( &ulIntr );
+
+    do {
+        ulong clk1;
+        
+        clk1 = kerSysGetCycleCount();		/* time cleared */
+	/* wait a little to get new reading */
+        while ((kerSysGetCycleCount()-clk1) < CYCLE_PER_US*2)
+            ;
+    } while ((0 == (PERF->ExtIrqCfg & (1 << (ulIntr + EI_STATUS_SHFT)))) && ((kerSysGetCycleCount() - clk0) < DG_GLITCH_TO));
+
+    if (PERF->ExtIrqCfg & (1 << (ulIntr + EI_STATUS_SHFT))) {	/* power glitch */
+        BcmHalInterruptEnable( ulIntr + INTERRUPT_ID_EXTERNAL_0);
+        KERSYS_DBG(" - Power glitch detected. Duration: %ld us\n", (kerSysGetCycleCount() - clk0)/CYCLE_PER_US);
+        return 0;
+    }
+#elif (defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)) && !defined(VXWORKS)
+    do {
+        ulong clk1;
+        
+        clk1 = kerSysGetCycleCount();		/* time cleared */
+	/* wait a little to get new reading */
+        while ((kerSysGetCycleCount()-clk1) < CYCLE_PER_US*2)
+            ;
+     } while ((PERF->IrqStatus & (1 << (INTERRUPT_ID_DG - INTERNAL_ISR_TABLE_OFFSET))) && ((kerSysGetCycleCount() - clk0) < DG_GLITCH_TO));
+
+    if (!(PERF->IrqStatus & (1 << (INTERRUPT_ID_DG - INTERNAL_ISR_TABLE_OFFSET)))) {
+        BcmHalInterruptEnable( INTERRUPT_ID_DG );
+        KERSYS_DBG(" - Power glitch detected. Duration: %ld us\n", (kerSysGetCycleCount() - clk0)/CYCLE_PER_US);
+        return 0;
+    }
+#endif
+    return 1;
+}
+
+static void kerSysDyingGaspShutdown( void )
+{
+    kerSysSetWdTimer(1000000);
+#if defined(CONFIG_BCM96345)
+    PERF->blkEnables &= ~(EMAC_CLK_EN | USB_CLK_EN | CPU_CLK_EN);
+#elif defined(CONFIG_BCM96348)
+    PERF->blkEnables &= ~(EMAC_CLK_EN | USBS_CLK_EN | USBH_CLK_EN | SAR_CLK_EN);
+#endif
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+static irqreturn_t kerSysDyingGaspIsr(int irq, void * dev_id, struct pt_regs * regs)
+#else
+static unsigned int kerSysDyingGaspIsr(void)
+#endif
+{	
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp, *dsl = NULL;	
+
+    if (kerSysDyingGaspCheckPowerLoss()) {        
+
+        /* first to turn off everything other than dsl */        
+        list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+            tmp = list_entry(pos, CB_DGASP_LIST, list);
+    	    if(strncmp(tmp->name, "dsl", 3)) {
+    	        (tmp->cb_dgasp_fn)(tmp->context); 
+    	    }else {
+    		dsl = tmp;    		    	
+    	    }       
+        }  
+        
+        /* now send dgasp */
+        if(dsl)
+            (dsl->cb_dgasp_fn)(dsl->context); 
+
+        /* reset and shutdown system */
+        kerSysDyingGaspShutdown();
+    }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+return( IRQ_HANDLED );
+#else
+    return( 1 );
+#endif
+}
+
+static void __init kerSysInitDyingGaspHandler( void )
+{
+    CB_DGASP_LIST *new_node;
+
+    if( g_cb_dgasp_list_head != NULL) {
+        printk("Error: kerSysInitDyingGaspHandler: list head is not null\n");
+        return;	
+    }
+    new_node= (CB_DGASP_LIST *)kmalloc(sizeof(CB_DGASP_LIST), GFP_KERNEL);
+    memset(new_node, 0x00, sizeof(CB_DGASP_LIST));
+    INIT_LIST_HEAD(&new_node->list);    
+    g_cb_dgasp_list_head = new_node; 
+		
+} /* kerSysInitDyingGaspHandler */
+
+static void __exit kerSysDeinitDyingGaspHandler( void )
+{
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp; 
+     	
+    if(g_cb_dgasp_list_head == NULL)
+        return;
+        
+    list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+    	tmp = list_entry(pos, CB_DGASP_LIST, list);
+        list_del(pos);
+	kfree(tmp);
+    }       
+
+    kfree(g_cb_dgasp_list_head);	
+    g_cb_dgasp_list_head = NULL;
+    
+} /* kerSysDeinitDyingGaspHandler */
+
+void kerSysRegisterDyingGaspHandler(char *devname, void *cbfn, void *context)
+{
+    CB_DGASP_LIST *new_node;
+
+    if( g_cb_dgasp_list_head == NULL) {
+        printk("Error: kerSysRegisterDyingGaspHandler: list head is null\n");	
+        return;    
+    }
+    
+    if( devname == NULL || cbfn == NULL ) {
+        printk("Error: kerSysRegisterDyingGaspHandler: register info not enough (%s,%x,%x)\n", devname, (unsigned int)cbfn, (unsigned int)context);	    	
+        return;
+    }
+       
+    new_node= (CB_DGASP_LIST *)kmalloc(sizeof(CB_DGASP_LIST), GFP_KERNEL);
+    memset(new_node, 0x00, sizeof(CB_DGASP_LIST));    
+    INIT_LIST_HEAD(&new_node->list);
+    strncpy(new_node->name, devname, IFNAMSIZ);
+    new_node->cb_dgasp_fn = (cb_dgasp_t)cbfn;
+    new_node->context = context;
+    list_add(&new_node->list, &g_cb_dgasp_list_head->list);
+    
+    printk("dgasp: kerSysRegisterDyingGaspHandler: %s registered \n", devname);
+        	
+} /* kerSysRegisterDyingGaspHandler */
+
+void kerSysDeregisterDyingGaspHandler(char *devname)
+{
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp;    
+    
+    if(g_cb_dgasp_list_head == NULL) {
+        printk("Error: kerSysDeregisterDyingGaspHandler: list head is null\n");
+        return;	
+    }
+
+    if(devname == NULL) {
+        printk("Error: kerSysDeregisterDyingGaspHandler: devname is null\n");
+        return;	
+    }
+    
+    printk("kerSysDeregisterDyingGaspHandler: %s is deregistering\n", devname);
+
+    list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+    	tmp = list_entry(pos, CB_DGASP_LIST, list);
+    	if(!strcmp(tmp->name, devname)) {
+            list_del(pos);
+	    kfree(tmp);
+	    printk("kerSysDeregisterDyingGaspHandler: %s is deregistered\n", devname);
+	    return;
+	}
+    }	
+    printk("kerSysDeregisterDyingGaspHandler: %s not (de)registered\n", devname);
+	
+} /* kerSysDeregisterDyingGaspHandler */
+
+/***************************************************************************
+ * MACRO to call driver initialization and cleanup functions.
+ ***************************************************************************/
+module_init( brcm_board_init );
+module_exit( brcm_board_cleanup );
+
+EXPORT_SYMBOL(kerSysNvRamGet);
+EXPORT_SYMBOL(dumpaddr);
+EXPORT_SYMBOL(kerSysGetMacAddress);
+EXPORT_SYMBOL(kerSysReleaseMacAddress);
+EXPORT_SYMBOL(kerSysGetSdramSize);
+EXPORT_SYMBOL(kerSysLedCtrl);
+EXPORT_SYMBOL(kerSysLedRegisterHwHandler);
+EXPORT_SYMBOL(BpGetBoardIds);
+EXPORT_SYMBOL(BpGetSdramSize);
+EXPORT_SYMBOL(BpGetPsiSize);
+EXPORT_SYMBOL(BpGetEthernetMacInfo);
+EXPORT_SYMBOL(BpGetRj11InnerOuterPairGpios);
+EXPORT_SYMBOL(BpGetPressAndHoldResetGpio);
+EXPORT_SYMBOL(BpGetVoipResetGpio);
+EXPORT_SYMBOL(BpGetVoipIntrGpio);
+EXPORT_SYMBOL(BpGetPcmciaResetGpio);
+EXPORT_SYMBOL(BpGetRtsCtsUartGpios);
+EXPORT_SYMBOL(BpGetAdslLedGpio);
+EXPORT_SYMBOL(BpGetAdslFailLedGpio);
+EXPORT_SYMBOL(BpGetWirelessLedGpio);
+EXPORT_SYMBOL(BpGetUsbLedGpio);
+EXPORT_SYMBOL(BpGetHpnaLedGpio);
+EXPORT_SYMBOL(BpGetWanDataLedGpio);
+EXPORT_SYMBOL(BpGetPppLedGpio);
+EXPORT_SYMBOL(BpGetPppFailLedGpio);
+EXPORT_SYMBOL(BpGetVoipLedGpio);
+EXPORT_SYMBOL(BpGetWirelessExtIntr);
+EXPORT_SYMBOL(BpGetAdslDyingGaspExtIntr);
+EXPORT_SYMBOL(BpGetVoipExtIntr);
+EXPORT_SYMBOL(BpGetHpnaExtIntr);
+EXPORT_SYMBOL(BpGetHpnaChipSelect);
+EXPORT_SYMBOL(BpGetVoipChipSelect);
+EXPORT_SYMBOL(BpGetWirelessSesBtnGpio);
+EXPORT_SYMBOL(BpGetWirelessSesExtIntr);
+EXPORT_SYMBOL(BpGetWirelessSesLedGpio);
+EXPORT_SYMBOL(kerSysRegisterDyingGaspHandler);
+EXPORT_SYMBOL(kerSysDeregisterDyingGaspHandler);
+EXPORT_SYMBOL(kerSysGetCycleCount);
+EXPORT_SYMBOL(kerSysSetWdTimer);
+EXPORT_SYMBOL(kerSysWakeupMonitorTask);
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,692 @@
+/************************************************************************/
+/*                                                                      */
+/*  AMD CFI Enabled Flash Memory Drivers                                */
+/*  File name: CFIFLASH.C                                               */
+/*  Revision:  1.0  5/07/98                                             */
+/*                                                                      */
+/* Copyright (c) 1998 ADVANCED MICRO DEVICES, INC. All Rights Reserved. */
+/* This software is unpublished and contains the trade secrets and      */
+/* confidential proprietary information of AMD. Unless otherwise        */
+/* provided in the Software Agreement associated herewith, it is        */
+/* licensed in confidence "AS IS" and is not to be reproduced in whole  */
+/* or part by any means except for backup. Use, duplication, or         */
+/* disclosure by the Government is subject to the restrictions in       */
+/* paragraph (b) (3) (B) of the Rights in Technical Data and Computer   */
+/* Software clause in DFAR 52.227-7013 (a) (Oct 1988).                  */
+/* Software owned by                                                    */
+/* Advanced Micro Devices, Inc.,                                        */
+/* One AMD Place,                                                       */
+/* P.O. Box 3453                                                        */
+/* Sunnyvale, CA 94088-3453.                                            */
+/************************************************************************/
+/*  This software constitutes a basic shell of source code for          */
+/*  programming all AMD Flash components. AMD                           */
+/*  will not be responsible for misuse or illegal use of this           */
+/*  software for devices not supported herein. AMD is providing         */
+/*  this source code "AS IS" and will not be responsible for            */
+/*  issues arising from incorrect user implementation of the            */
+/*  source code herein. It is the user's responsibility to              */
+/*  properly design-in this source code.                                */
+/*                                                                      */ 
+/************************************************************************/                        
+#ifdef _CFE_                                                
+#include "lib_types.h"
+#include "lib_printf.h"
+#include "lib_string.h"
+#include "cfe_timer.h"
+#define printk  printf
+#else       // linux
+#include <linux/param.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#endif
+
+#include "cfiflash.h"
+
+static int flash_wait(WORD sector, int offset, UINT16 data);
+static UINT16 flash_get_device_id(void);
+static int flash_get_cfi(struct cfi_query *query, UINT16 *cfi_struct, int flashFamily);
+static int flash_write(WORD sector, int offset, byte *buf, int nbytes);
+static void flash_command(int command, WORD sector, int offset, UINT16 data);
+
+/*********************************************************************/
+/* 'meminfo' should be a pointer, but most C compilers will not      */
+/* allocate static storage for a pointer without calling             */
+/* non-portable functions such as 'new'.  We also want to avoid      */
+/* the overhead of passing this pointer for every driver call.       */
+/* Systems with limited heap space will need to do this.             */
+/*********************************************************************/
+struct flashinfo meminfo; /* Flash information structure */
+static int flashFamily = FLASH_UNDEFINED;
+static int totalSize = 0;
+static struct cfi_query query;
+
+static UINT16 cfi_data_struct_29W160[] = {
+    0x0020, 0x0049, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0x0051, 0x0052, 0x0059, 0x0002, 0x0000, 0x0040, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0027, 0x0036, 0x0000, 0x0000, 0x0004,
+    0x0000, 0x000a, 0x0000, 0x0004, 0x0000, 0x0003, 0x0000, 0x0015,
+    0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0000, 0x0000, 0x0040,
+    0x0000, 0x0001, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0080,
+    0x0000, 0x001e, 0x0000, 0x0000, 0x0001, 0xffff, 0xffff, 0xffff,
+    0x0050, 0x0052, 0x0049, 0x0031, 0x0030, 0x0000, 0x0002, 0x0001,
+    0x0001, 0x0004, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0x0002,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0x0888, 0x252b, 0x8c84, 0x7dbc, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
+};
+
+
+/*********************************************************************/
+/* Init_flash is used to build a sector table from the information   */
+/* provided through the CFI query.  This information is translated   */
+/* from erase_block information to base:offset information for each  */
+/* individual sector. This information is then stored in the meminfo */
+/* structure, and used throughout the driver to access sector        */
+/* information.                                                      */
+/*                                                                   */
+/* This is more efficient than deriving the sector base:offset       */
+/* information every time the memory map switches (since on the      */
+/* development platform can only map 64k at a time).  If the entire  */
+/* flash memory array can be mapped in, then the addition static     */
+/* allocation for the meminfo structure can be eliminated, but the   */
+/* drivers will have to be re-written.                               */
+/*                                                                   */
+/* The meminfo struct occupies 653 bytes of heap space, depending    */
+/* on the value of the define MAXSECTORS.  Adjust to suit            */
+/* application                                                       */ 
+/*********************************************************************/
+byte flash_init(void)
+{
+    int i=0, j=0, count=0;
+    int basecount=0L;
+    UINT16 device_id;
+    int flipCFIGeometry = FALSE;
+
+    /* First, assume
+    * a single 8k sector for sector 0.  This is to allow
+    * the system to perform memory mapping to the device,
+    * even though the actual physical layout is unknown.
+    * Once mapped in, the CFI query will produce all
+    * relevant information.
+    */
+    meminfo.addr = 0L;
+    meminfo.areg = 0;
+    meminfo.nsect = 1;
+    meminfo.bank1start = 0;
+    meminfo.bank2start = 0;
+    
+    meminfo.sec[0].size = 8192;
+    meminfo.sec[0].base = 0x00000;
+    meminfo.sec[0].bank = 1;
+        
+    flash_command(FLASH_RESET, 0, 0, 0);
+
+    device_id = flash_get_device_id();
+
+    switch (device_id) {
+        case ID_I28F160C3B:
+        case ID_I28F320C3B:
+        case ID_I28F160C3T:
+        case ID_I28F320C3T:
+            flashFamily = FLASH_INTEL;
+            break;
+        case ID_AM29DL800B:
+        case ID_AM29LV800B:
+        case ID_AM29LV400B:   
+        case ID_AM29LV160B:
+        case ID_AM29LV320B:
+        case ID_MX29LV320AB:
+        case ID_AM29LV320MB:
+        case ID_AM29DL800T:
+        case ID_AM29LV800T:
+        case ID_AM29LV160T:
+        case ID_AM29LV320T:
+        case ID_MX29LV320AT:
+        case ID_AM29LV320MT:
+            flashFamily = FLASH_AMD;
+            break;
+        case ID_SST39VF1601:
+		case ID_SST39VF3201:
+            flashFamily = FLASH_SST;
+            break;
+        default:
+            printk("Flash memory not supported!  Device id = %x\n", device_id);
+            return -1;           
+    }
+
+    if (flash_get_cfi(&query, 0, flashFamily) == -1) {
+        switch(device_id) {
+        case ID_AM29LV160T:
+        case ID_AM29LV160B:
+            flash_get_cfi(&query, cfi_data_struct_29W160, flashFamily);
+            break;
+        default:
+            printk("CFI data structure not found. Device id = %x\n", device_id);
+            return -1;           
+        }
+    }
+
+    // need to determine if it top or bottom boot here
+    switch (device_id)
+    {
+        case ID_AM29DL800B:
+        case ID_AM29LV800B:
+        case ID_AM29LV400B:   
+        case ID_AM29LV160B:
+        case ID_AM29LV320B:
+        case ID_MX29LV320AB:
+        case ID_AM29LV320MB:
+        case ID_I28F160C3B:
+        case ID_I28F320C3B:
+        case ID_I28F160C3T:
+        case ID_I28F320C3T:
+		case ID_SST39VF1601:
+		case ID_SST39VF3201:
+            flipCFIGeometry = FALSE;
+            break;
+        case ID_AM29DL800T:
+        case ID_AM29LV800T:
+        case ID_AM29LV160T:
+        case ID_AM29LV320T:
+        case ID_MX29LV320AT:
+        case ID_AM29LV320MT:
+            flipCFIGeometry = TRUE;
+            break;
+        default:
+            printk("Flash memory not supported!  Device id = %x\n", device_id);
+            return -1;           
+    }
+
+    count=0;basecount=0L;
+
+    if (!flipCFIGeometry)
+    {
+       for (i=0; i<query.num_erase_blocks; i++) {
+            for(j=0; j<query.erase_block[i].num_sectors; j++) {
+                meminfo.sec[count].size = (int) query.erase_block[i].sector_size;
+                meminfo.sec[count].base = (int) basecount;
+                basecount += (int) query.erase_block[i].sector_size;
+                count++;
+            }
+        }
+    }
+    else
+    {
+        for (i = (query.num_erase_blocks - 1); i >= 0; i--) {
+            for(j=0; j<query.erase_block[i].num_sectors; j++) {
+                meminfo.sec[count].size = (int) query.erase_block[i].sector_size;
+                meminfo.sec[count].base = (int) basecount;
+                basecount += (int) query.erase_block[i].sector_size;
+				count++;
+            }
+        }
+    }
+
+    meminfo.nsect = count;
+    totalSize = meminfo.sec[count-1].base + meminfo.sec[count-1].size;
+    return (0);
+}
+
+/*********************************************************************/
+/* Flash_sector_erase_int() is identical to flash_sector_erase(),    */
+/* except it will wait until the erase is completed before returning */
+/* control to the calling function.  This can be used in cases which */
+/* require the program to hold until a sector is erased, without     */
+/* adding the wait check external to this function.                  */
+/*********************************************************************/
+byte flash_sector_erase_int(WORD sector)
+{
+    int i;
+
+    for( i = 0; i < 3; i++ ) {
+        flash_command(FLASH_SERASE, sector, 0, 0);
+        if (flash_wait(sector, 0, 0xffff) == STATUS_READY)
+            break;
+    }
+
+    return(1);
+}
+
+/*********************************************************************/
+/* flash_read_buf() reads buffer of data from the specified          */
+/* offset from the sector parameter.                                 */
+/*********************************************************************/
+int flash_read_buf(WORD sector, int offset,
+                        byte *buffer, int numbytes)
+{
+    byte *fwp;
+
+    fwp = (byte *)flash_get_memptr(sector);
+
+	while (numbytes) {
+		*buffer++ = *(fwp + offset);
+		numbytes--;
+		fwp++;
+    }
+
+    return (1);
+}
+
+/*********************************************************************/
+/* flash_write_buf() utilizes                                        */
+/* the unlock bypass mode of the flash device.  This can remove      */
+/* significant overhead from the bulk programming operation, and     */
+/* when programming bulk data a sizeable performance increase can be */
+/* observed.                                                         */
+/*********************************************************************/
+int flash_write_buf(WORD sector, int offset, byte *buffer, int numbytes)
+{
+    int ret = -1;
+    int i;
+    unsigned char *p = flash_get_memptr(sector) + offset;
+
+    /* After writing the flash block, compare the contents to the source
+     * buffer.  Try to write the sector successfully up to three times.
+     */
+    for( i = 0; i < 3; i++ ) {
+        ret = flash_write(sector, offset, buffer, numbytes);
+        if( !memcmp( p, buffer, numbytes ) )
+            break;
+        /* Erase and try again */
+        flash_sector_erase_int(sector);
+        ret = -1;
+    }
+
+    if( ret == -1 )
+        printk( "Flash write error.  Verify failed\n" );
+
+    return( ret );
+}
+
+/*********************************************************************/
+/* Usefull funtion to return the number of sectors in the device.    */
+/* Can be used for functions which need to loop among all the        */
+/* sectors, or wish to know the number of the last sector.           */
+/*********************************************************************/
+int flash_get_numsectors(void)
+{
+    return meminfo.nsect;
+}
+
+/*********************************************************************/
+/* flash_get_sector_size() is provided for cases in which the size   */
+/* of a sector is required by a host application.  The sector size   */
+/* (in bytes) is returned in the data location pointed to by the     */
+/* 'size' parameter.                                                 */
+/*********************************************************************/
+int flash_get_sector_size(WORD sector)
+{
+    return meminfo.sec[sector].size;
+}
+
+/*********************************************************************/
+/* The purpose of flash_get_memptr() is to return a memory pointer   */
+/* which points to the beginning of memory space allocated for the   */
+/* flash.  All function pointers are then referenced from this       */
+/* pointer. 							     */
+/*                                                                   */
+/* Different systems will implement this in different ways:          */
+/* possibilities include:                                            */
+/*  - A direct memory pointer                                        */
+/*  - A pointer to a memory map                                      */
+/*  - A pointer to a hardware port from which the linear             */
+/*    address is translated                                          */
+/*  - Output of an MMU function / service                            */
+/*                                                                   */
+/* Also note that this function expects the pointer to a specific    */
+/* sector of the device.  This can be provided by dereferencing      */
+/* the pointer from a translated offset of the sector from a         */
+/* global base pointer (e.g. flashptr = base_pointer + sector_offset)*/
+/*                                                                   */
+/* Important: Many AMD flash devices need both bank and or sector    */
+/* address bits to be correctly set (bank address bits are A18-A16,  */
+/* and sector address bits are A18-A12, or A12-A15).  Flash parts    */
+/* which do not need these bits will ignore them, so it is safe to   */
+/* assume that every part will require these bits to be set.         */
+/*********************************************************************/
+unsigned char *flash_get_memptr(WORD sector)
+{
+	unsigned char *memptr = (unsigned char*)(FLASH_BASE_ADDR_REG + meminfo.sec[sector].base);
+
+	return (memptr);
+}
+
+/*********************************************************************/
+/* The purpose of flash_get_blk() is to return a the block number    */
+/* for a given memory address.                                       */
+/*********************************************************************/
+int flash_get_blk(int addr)
+{
+    int blk_start, i;
+    int last_blk = flash_get_numsectors();
+    int relative_addr = addr - (int) FLASH_BASE_ADDR_REG;
+
+    for(blk_start=0, i=0; i < relative_addr && blk_start < last_blk; blk_start++)
+        i += flash_get_sector_size(blk_start);
+
+    if( i > relative_addr )
+    {
+        blk_start--;        // last blk, dec by 1
+    }
+    else
+        if( blk_start == last_blk )
+        {
+            printk("Address is too big.\n");
+            blk_start = -1;
+        }
+
+    return( blk_start );
+}
+
+/************************************************************************/
+/* The purpose of flash_get_total_size() is to return the total size of */
+/* the flash                                                            */
+/************************************************************************/
+int flash_get_total_size()
+{
+    return totalSize;
+}
+
+/*********************************************************************/
+/* Flash_command() is the main driver function.  It performs         */
+/* every possible command available to AMD B revision                */
+/* flash parts. Note that this command is not used directly, but     */
+/* rather called through the API wrapper functions provided below.   */
+/*********************************************************************/
+static void flash_command(int command, WORD sector, int offset, UINT16 data)
+{
+    volatile UINT16 *flashptr;
+    volatile UINT16 *flashbase;
+
+    flashptr = (UINT16 *) flash_get_memptr(sector);
+    flashbase = (UINT16 *) flash_get_memptr(0);
+    
+    switch (flashFamily) {
+    case FLASH_UNDEFINED:
+        /* These commands should work for AMD, Intel and SST flashes */
+        switch (command) {
+        case FLASH_RESET:
+            flashptr[0] = 0xF0;
+            flashptr[0] = 0xFF;
+            break;
+        case FLASH_READ_ID:
+			flashptr[0x5555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AAA] = 0x55;       /* unlock 2 */
+            flashptr[0x5555] = 0x90;
+            break;
+        default:
+            break;
+        }
+        break;
+    case FLASH_AMD:
+        switch (command) {
+        case FLASH_RESET:
+            flashptr[0] = 0xF0;
+            break;
+        case FLASH_READ_ID:
+            flashptr[0x555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AA] = 0x55;       /* unlock 2 */
+            flashptr[0x555] = 0x90;
+            break;
+        case FLASH_CFIQUERY:
+            flashptr[0x55] = 0x98;
+            break;
+        case FLASH_UB:
+            flashptr[0x555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AA] = 0x55;       /* unlock 2 */
+            flashptr[0x555] = 0x20;
+            break;
+        case FLASH_PROG:
+            flashptr[0] = 0xA0;
+            flashptr[offset/2] = data;
+            break;
+        case FLASH_UBRESET:
+            flashptr[0] = 0x90;
+            flashptr[0] = 0x00;
+            break;
+        case FLASH_SERASE:
+            flashptr[0x555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AA] = 0x55;       /* unlock 2 */
+            flashptr[0x555] = 0x80;
+            flashptr[0x555] = 0xAA;
+            flashptr[0x2AA] = 0x55;
+            flashptr[0] = 0x30;
+            break;
+        default:
+            break;
+        }
+        break;
+    case FLASH_INTEL:
+        switch (command) {
+        case FLASH_RESET:
+            flashptr[0] = 0xFF;
+            break;
+        case FLASH_READ_ID:
+            flashptr[0] = 0x90;
+            break;
+        case FLASH_CFIQUERY:
+            flashptr[0] = 0x98;
+            break;
+        case FLASH_PROG:
+            flashptr[0] = 0x40;
+            flashptr[offset/2] = data;
+            break;
+        case FLASH_SERASE:
+            flashptr[0] = 0x60;
+            flashptr[0] = 0xD0;
+            flashptr[0] = 0x20;
+            flashptr[0] = 0xD0;
+            break;
+        default:
+            break;
+        }
+        break;
+    case FLASH_SST:
+        switch (command) {
+        case FLASH_RESET:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0xf0;
+            break;
+        case FLASH_READ_ID:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0x90;
+            break;
+        case FLASH_CFIQUERY:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0x98;
+            break;
+        case FLASH_UB:
+            break;
+        case FLASH_PROG:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0xa0;
+            flashptr[offset/2] = data;
+            break;
+        case FLASH_UBRESET:
+            break;
+        case FLASH_SERASE:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0x80;
+            flashbase[0x5555] = 0xAA;
+            flashbase[0x2AAA] = 0x55;
+            flashptr[0] = 0x30;
+            break;
+        default:
+            break;
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+/*********************************************************************/
+/* flash_write extends the functionality of flash_program() by       */
+/* providing an faster way to program multiple data words, without   */
+/* needing the function overhead of looping algorithms which         */
+/* program word by word.  This function utilizes fast pointers       */
+/* to quickly loop through bulk data.                                */
+/*********************************************************************/
+static int flash_write(WORD sector, int offset, byte *buf, int nbytes)
+{
+    UINT16 *src;
+    src = (UINT16 *)buf;
+
+    if ((nbytes | offset) & 1) {
+        return -1;
+    }
+
+    flash_command(FLASH_UB, 0, 0, 0);
+    while (nbytes > 0) {
+        flash_command(FLASH_PROG, sector, offset, *src);
+        if (flash_wait(sector, offset, *src) != STATUS_READY)
+            break;
+        offset +=2;
+        nbytes -=2;
+        src++;
+    }
+    flash_command(FLASH_UBRESET, 0, 0, 0);
+    
+    return (byte*)src - buf;
+}
+
+/*********************************************************************/
+/* flash_wait utilizes the DQ6, DQ5, and DQ2 polling algorithms      */
+/* described in the flash data book.  It can quickly ascertain the   */
+/* operational status of the flash device, and return an             */
+/* appropriate status code (defined in flash.h)                      */
+/*********************************************************************/
+static int flash_wait(WORD sector, int offset, UINT16 data)
+{
+    volatile UINT16 *flashptr; /* flash window */
+    UINT16 d1;
+
+    flashptr = (UINT16 *) flash_get_memptr(sector);
+
+    if (flashFamily == FLASH_AMD || flashFamily == FLASH_SST) {
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+        do {
+            d1 = flashptr[offset/2];
+            if (d1 == data)
+                return STATUS_READY;
+        } while (!(d1 & 0x20));
+
+        d1 = flashptr[offset/2];
+
+        if (d1 != data) {
+            flash_command(FLASH_RESET, 0, 0, 0);
+            return STATUS_TIMEOUT;
+        }
+#else
+        do {
+            d1 = *flashptr;    /* read data */
+            d1 ^= *flashptr;   /* read it again and see what toggled */
+            if (d1 == 0)       /* no toggles, nothing's happening */
+                return STATUS_READY;
+        } while (!(d1 & 0x20));
+
+        d1 = *flashptr;        /* read data */
+        d1 ^= *flashptr;   /* read it again and see what toggled */
+
+        if (d1 != 0) {
+            flash_command(FLASH_RESET, 0, 0, 0);
+            return STATUS_TIMEOUT;
+        }
+#endif
+    } else if (flashFamily == FLASH_INTEL) {
+        flashptr[0] = 0x70;
+        /* Wait for completion */
+        while(!(*flashptr & 0x80));
+        if (*flashptr & 0x30) {
+            flashptr[0] = 0x50;
+            flash_command(FLASH_RESET, 0, 0, 0);
+            return STATUS_TIMEOUT;
+        }
+        flashptr[0] = 0x50;
+        flash_command(FLASH_RESET, 0, 0, 0);
+    }
+    
+    return STATUS_READY;
+}
+
+/*********************************************************************/
+/* flash_get_device_id() will perform an autoselect sequence on the  */
+/* flash device, and return the device id of the component.          */
+/* This function automatically resets to read mode.                  */
+/*********************************************************************/
+static UINT16 flash_get_device_id()
+{
+    volatile UINT16 *fwp; /* flash window */
+    UINT16 answer;
+    
+    fwp = (UINT16 *)flash_get_memptr(0);
+    
+    flash_command(FLASH_READ_ID, 0, 0, 0);
+    answer = *(fwp + 1);
+    if (answer == ID_AM29LV320M) {
+        answer = *(fwp + 0xe);
+        answer = *(fwp + 0xf);
+    }
+    
+    flash_command(FLASH_RESET, 0, 0, 0);
+    return( (UINT16) answer );
+}
+
+/*********************************************************************/
+/* flash_get_cfi() is the main CFI workhorse function.  Due to it's  */
+/* complexity and size it need only be called once upon              */
+/* initializing the flash system.  Once it is called, all operations */
+/* are performed by looking at the meminfo structure.                */
+/* All possible care was made to make this algorithm as efficient as */
+/* possible.  90% of all operations are memory reads, and all        */
+/* calculations are done using bit-shifts when possible              */
+/*********************************************************************/
+static int flash_get_cfi(struct cfi_query *query, UINT16 *cfi_struct, int flashFamily)
+{
+    volatile UINT16 *fwp; /* flash window */
+    int i=0;
+
+    flash_command(FLASH_CFIQUERY, 0, 0, 0);
+    
+    if (cfi_struct == 0)
+        fwp = (UINT16 *)flash_get_memptr(0);
+    else
+        fwp = cfi_struct;
+    
+    /* Initial house-cleaning */
+    for(i=0; i < 8; i++) {
+        query->erase_block[i].sector_size = 0;
+        query->erase_block[i].num_sectors = 0;
+    }
+    
+    /* If not 'QRY', then we dont have a CFI enabled device in the socket */
+    if( fwp[0x10] != 'Q' &&
+        fwp[0x11] != 'R' &&
+        fwp[0x12] != 'Y') {
+        flash_command(FLASH_RESET, 0, 0, 0);
+        return(-1);
+    }
+    
+	query->num_erase_blocks = fwp[0x2C];
+	if(flashFamily == FLASH_SST)
+		query->num_erase_blocks = 1;
+	
+    for(i=0; i < query->num_erase_blocks; i++) {
+			query->erase_block[i].num_sectors = fwp[(0x2D+(4*i))] + (fwp[0x2E + (4*i)] << 8);
+			query->erase_block[i].num_sectors++;
+			query->erase_block[i].sector_size = 256 * (256 * fwp[(0x30+(4*i))] + fwp[(0x2F+(4*i))]);
+    }
+    
+    flash_command(FLASH_RESET, 0, 0, 0);
+    return(1);
+}
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.h
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/bcm96348/cfiflash.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,150 @@
+/************************************************************************/
+/*                                                                      */
+/*  AMD CFI Enabled Flash Memory Drivers                                */
+/*  File name: CFIFLASH.H                                               */
+/*  Revision:  1.0  5/07/98                                             */
+/*                                                                      */
+/* Copyright (c) 1998 ADVANCED MICRO DEVICES, INC. All Rights Reserved. */
+/* This software is unpublished and contains the trade secrets and      */
+/* confidential proprietary information of AMD. Unless otherwise        */
+/* provided in the Software Agreement associated herewith, it is        */
+/* licensed in confidence "AS IS" and is not to be reproduced in whole  */
+/* or part by any means except for backup. Use, duplication, or         */
+/* disclosure by the Government is subject to the restrictions in       */
+/* paragraph (b) (3) (B) of the Rights in Technical Data and Computer   */
+/* Software clause in DFAR 52.227-7013 (a) (Oct 1988).                  */
+/* Software owned by                                                    */
+/* Advanced Micro Devices, Inc.,                                        */
+/* One AMD Place,                                                       */
+/* P.O. Box 3453                                                        */
+/* Sunnyvale, CA 94088-3453.                                            */
+/************************************************************************/
+/*  This software constitutes a basic shell of source code for          */
+/*  programming all AMD Flash components. AMD                           */
+/*  will not be responsible for misuse or illegal use of this           */
+/*  software for devices not supported herein. AMD is providing         */
+/*  this source code "AS IS" and will not be responsible for            */
+/*  issues arising from incorrect user implementation of the            */
+/*  source code herein. It is the user's responsibility to              */
+/*  properly design-in this source code.                                */
+/*                                                                      */ 
+/************************************************************************/
+#ifndef _CFIFLASH_H
+#define _CFIFLASH_H
+
+#if defined __cplusplus
+extern "C" {
+#endif
+
+/* include board/CPU specific definitions */
+#include "bcmtypes.h"
+#include "board.h"
+
+#define FLASH_BASE_ADDR_REG FLASH_BASE
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#define MAXSECTORS  1024      /* maximum number of sectors supported */
+
+/* A structure for identifying a flash part.  There is one for each
+ * of the flash part definitions.  We need to keep track of the
+ * sector organization, the address register used, and the size
+ * of the sectors.
+ */
+struct flashinfo {
+	 char *name;         /* "Am29DL800T", etc. */
+	 unsigned long addr; /* physical address, once translated */
+	 int areg;           /* Can be set to zero for all parts */
+	 int nsect;          /* # of sectors -- 19 in LV, 22 in DL */
+	 int bank1start;     /* first sector # in bank 1 */
+	 int bank2start;     /* first sector # in bank 2, if DL part */
+ struct {
+	long size;           /* # of bytes in this sector */
+	long base;           /* offset from beginning of device */
+	int bank;            /* 1 or 2 for DL; 1 for LV */
+	 } sec[MAXSECTORS];  /* per-sector info */
+};
+
+/*
+ * This structure holds all CFI query information as defined
+ * in the JEDEC standard. All information up to 
+ * primary_extended_query is standard among all manufactures
+ * with CFI enabled devices.
+ */
+
+struct cfi_query {
+	int num_erase_blocks;		/* Number of sector defs. */
+	struct {
+	  unsigned long sector_size;	/* byte size of sector */
+	  int num_sectors;		/* Num sectors of this size */
+	} erase_block[8];		/* Max of 256, but 8 is good */
+};
+
+/* Standard Boolean declarations */
+#define TRUE 				1
+#define FALSE 				0
+
+/* Define different type of flash */
+#define FLASH_UNDEFINED 0
+#define FLASH_AMD       1
+#define FLASH_INTEL     2
+#define FLASH_SST       3
+
+/* Command codes for the flash_command routine */
+#define FLASH_RESET     0       /* reset to read mode */
+#define FLASH_READ_ID   1       /* read device ID */
+#define FLASH_CFIQUERY  2       /* CFI query */
+#define FLASH_UB        3       /* go into unlock bypass mode */
+#define FLASH_PROG      4       /* program a word */
+#define FLASH_UBRESET   5       /* reset to read mode from unlock bypass mode */
+#define FLASH_SERASE    6       /* sector erase */
+
+/* Return codes from flash_status */
+#define STATUS_READY    0       /* ready for action */
+#define STATUS_TIMEOUT  1       /* operation timed out */
+
+/* A list of AMD compatible device ID's - add others as needed */
+#define ID_AM29DL800T   0x224A
+#define ID_AM29DL800B   0x22CB
+#define ID_AM29LV800T   0x22DA
+#define ID_AM29LV800B   0x225B
+#define ID_AM29LV400B   0x22BA
+
+#define ID_AM29LV160B   0x2249
+#define ID_AM29LV160T   0x22C4
+
+#define ID_AM29LV320T   0x22F6
+#define ID_MX29LV320AT  0x22A7
+#define ID_AM29LV320B   0x22F9
+#define ID_MX29LV320AB  0x22A8
+
+#define ID_AM29LV320M   0x227E
+#define ID_AM29LV320MB  0x2200
+#define ID_AM29LV320MT  0x2201
+
+#define ID_SST39VF1601  0x234B
+#define ID_SST39VF3201  0x235B
+
+/* A list of Intel compatible device ID's - add others as needed */
+#define ID_I28F160C3T   0x88C2
+#define ID_I28F160C3B   0x88C3
+#define ID_I28F320C3T   0x88C4
+#define ID_I28F320C3B   0x88C5
+
+extern byte flash_init(void);
+extern int flash_write_buf(WORD sector, int offset, byte *buffer, int numbytes);
+extern int flash_read_buf(WORD sector, int offset, byte *buffer, int numbytes);
+extern byte flash_sector_erase_int(WORD sector);
+extern int flash_get_numsectors(void);
+extern int flash_get_sector_size(WORD sector);
+extern int flash_get_total_size(void);
+extern unsigned char *flash_get_memptr(WORD sector);
+extern int flash_get_blk(int addr);
+
+#if defined __cplusplus
+}
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/Makefile
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,17 @@
+# Makefile for the bcm963xx board drivers
+#
+
+
+obj-y := board.o cfiflash.o bcm63xx_flash.o bcm63xx_led.o
+
+EXTRA_CFLAGS += -I. -I$(INC_BRCMBOARDPARMS_PATH)/$(BRCM_BOARD) -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+
+ifeq ($(strip $(WIRELESS)),1)
+	EXTRA_CFLAGS += -DWIRELESS
+endif
+
+-include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_flash.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_flash.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_flash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_flash.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,775 @@
+/*
+<:copyright-gpl
+ Copyright 2002 Broadcom Corp. All Rights Reserved.
+
+ This program is free software; you can distribute it and/or modify it
+ under the terms of the GNU General Public License (Version 2) as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ for more details.
+
+ You should have received a copy of the GNU General Public License along
+ with this program; if not, write to the Free Software Foundation, Inc.,
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+:>
+*/
+/*
+ ***************************************************************************
+ * File Name  : bcm63xx_flash.c
+ *
+ * Description: This file contains the flash device driver APIs for bcm63xx board. 
+ *
+ * Created on :  8/10/2002  seanl:  use cfiflash.c, cfliflash.h (AMD specific)
+ *
+ ***************************************************************************/
+
+
+/* Includes. */
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <asm/uaccess.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#define  BCMTAG_EXE_USE
+#include <bcmTag.h>
+#include "cfiflash.h"
+#include "boardparms.h"
+
+//#define DEBUG_FLASH
+
+static FLASH_ADDR_INFO fInfo;
+static int flashInitialized = 0;
+
+void *retriedKmalloc(size_t size)
+{
+	void *pBuf;
+    int tryCount = 0;
+
+    // try 1000 times before quit
+    while (((pBuf = kmalloc(size, GFP_KERNEL)) == NULL) && (tryCount++ < 1000))
+    {
+		current->state   = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ/10);
+	}
+    if (tryCount >= 1000)
+        pBuf = NULL;
+    else
+	    memset(pBuf, 0, size);
+
+    return pBuf;
+}
+
+void retriedKfree(void *pBuf)
+{
+	kfree(pBuf);
+}
+
+/***************************************************************************
+// Function Name: getCrc32
+// Description  : caculate the CRC 32 of the given data.
+// Parameters   : pdata - array of data.
+//                size - number of input data bytes.
+//                crc - either CRC32_INIT_VALUE or previous return value.
+// Returns      : crc.
+****************************************************************************/
+UINT32 getCrc32(byte *pdata, UINT32 size, UINT32 crc) 
+{
+    while (size-- > 0)
+        crc = (crc >> 8) ^ Crc32_table[(crc ^ *pdata++) & 0xff];
+
+    return crc;
+}
+
+// get the nvram start addr
+//
+unsigned long get_nvram_start_addr(void)
+{
+    return ((unsigned long) 
+        (flash_get_memptr(fInfo.flash_nvram_start_blk) + fInfo.flash_nvram_blk_offset));
+}
+
+// get the scratch_pad start addr
+//
+unsigned long get_scratch_pad_start_addr(void)
+{
+    return ((unsigned long) 
+        (flash_get_memptr(fInfo.flash_scratch_pad_start_blk) + fInfo.flash_scratch_pad_blk_offset));
+}
+
+
+
+/*  *********************************************************************
+    *  kerSysImageTagGet()
+    *   Get the image tag
+    *  Input parameters:
+    *      none
+    *  Return value:
+    *      point to tag -- Found
+    *      NULL -- failed
+    ********************************************************************* */
+PFILE_TAG kerSysImageTagGet(void)
+{
+    int i;
+    int totalBlks = flash_get_numsectors();
+    UINT32 crc;
+    unsigned char *sectAddr;
+    PFILE_TAG pTag;
+
+#if defined(DEBUG_FLASH)
+    printk("totalblks in tagGet=%d\n", totalBlks);
+#endif
+
+    // start from 2nd blk, assume 1st one is always CFE
+    for (i = 1; i < totalBlks; i++)
+    {
+        sectAddr =  flash_get_memptr((byte) i);
+        crc = CRC32_INIT_VALUE;
+        crc = getCrc32(sectAddr, (UINT32)TAG_LEN-TOKEN_LEN, crc);      
+        pTag = (PFILE_TAG) sectAddr;
+
+#if defined(DEBUG_FLASH)
+        printk("Check Tag crc on blk [%d]\n", i);
+#endif
+
+        if (crc == (UINT32)(*(UINT32*)(pTag->tagValidationToken)))
+            return pTag;
+    }
+
+    return (PFILE_TAG) NULL;
+}
+
+// Initialize the flash and fill out the fInfo structure
+void kerSysFlashInit( void )
+{
+    int i = 0;
+    int totalBlks = 0;
+    int totalSize = 0;
+    int startAddr = 0;
+    int usedBlkSize = 0;
+    NVRAM_DATA nvramData;
+    UINT32 crc = CRC32_INIT_VALUE, savedCrc;
+    PFILE_TAG pTag = NULL;
+    unsigned long kernelEndAddr = 0;
+    unsigned long spAddr = 0;
+
+    if (flashInitialized)
+        return;
+
+    flashInitialized = 1;
+    flash_init();
+
+    totalBlks = flash_get_numsectors();
+    totalSize = flash_get_total_size();
+
+    printk("Total Flash size: %dK with %d sectors\n", totalSize/1024, totalBlks);
+
+    /* nvram is always at the end of flash */
+    fInfo.flash_nvram_length = FLASH45_LENGTH_NVRAM;
+    fInfo.flash_nvram_start_blk = 0;  /* always the first block */
+    fInfo.flash_nvram_number_blk = 1; /*always fits in the first block */
+    fInfo.flash_nvram_blk_offset = NVRAM_DATA_OFFSET;
+ 
+    // check nvram CRC
+    memcpy((char *)&nvramData, (char *)get_nvram_start_addr(), sizeof(NVRAM_DATA));
+    savedCrc = nvramData.ulCheckSum;
+    nvramData.ulCheckSum = 0;
+    crc = getCrc32((char *)&nvramData, (UINT32) sizeof(NVRAM_DATA), crc);   
+
+    BpSetBoardId( nvramData.szBoardId );
+
+    fInfo.flash_persistent_length = NVRAM_PSI_DEFAULT;
+    if (savedCrc != crc)
+    {
+        printk("***Board is not initialized****: Using the default PSI size: %d\n",
+            fInfo.flash_persistent_length);
+    }
+    else
+    {
+        unsigned long ulPsiSize;
+        if( BpGetPsiSize( &ulPsiSize ) == BP_SUCCESS )
+            fInfo.flash_persistent_length = ulPsiSize;
+        else
+        {
+            printk("***Board id is not set****: Using the default PSI size: %d\n",
+                fInfo.flash_persistent_length);
+        }
+    }
+
+    fInfo.flash_persistent_length *= ONEK;
+    startAddr = totalSize - fInfo.flash_persistent_length;
+    fInfo.flash_persistent_start_blk = flash_get_blk(startAddr+FLASH_BASE_ADDR_REG);
+    fInfo.flash_persistent_number_blk = totalBlks - fInfo.flash_persistent_start_blk;
+    // save abs SP address (Scratch Pad). it is before PSI 
+    spAddr = startAddr - SP_MAX_LEN ;
+    // find out the offset in the start_blk
+    usedBlkSize = 0;
+    for (i = fInfo.flash_persistent_start_blk; 
+        i < (fInfo.flash_persistent_start_blk + fInfo.flash_persistent_number_blk); i++)
+    {
+        usedBlkSize += flash_get_sector_size((byte) i);
+    }
+    fInfo.flash_persistent_blk_offset =  usedBlkSize - fInfo.flash_persistent_length;
+
+    // get the info for sp
+    if (!(pTag = kerSysImageTagGet()))
+    {
+        printk("Failed to read image tag from flash\n");
+        return;
+    }
+    kernelEndAddr = (unsigned long) simple_strtoul(pTag->kernelAddress, NULL, 10) + \
+        (unsigned long) simple_strtoul(pTag->kernelLen, NULL, 10);
+
+    // make suer sp does not share kernel block
+    fInfo.flash_scratch_pad_start_blk = flash_get_blk(spAddr+FLASH_BASE_ADDR_REG);
+    if (fInfo.flash_scratch_pad_start_blk != flash_get_blk(kernelEndAddr))
+    {
+        fInfo.flash_scratch_pad_length = SP_MAX_LEN;
+        if (fInfo.flash_persistent_start_blk == fInfo.flash_scratch_pad_start_blk)  // share blk
+        {
+#if 1 /* do not used scratch pad unless it's in its own sector */
+            printk("Scratch pad is not used for this flash part.\n");  
+            fInfo.flash_scratch_pad_length = 0;     // no sp
+#else /* allow scratch pad to share a sector with another section such as PSI */
+            fInfo.flash_scratch_pad_number_blk = 1;
+            fInfo.flash_scratch_pad_blk_offset = fInfo.flash_persistent_blk_offset - fInfo.flash_scratch_pad_length;
+#endif
+        }
+        else // on different blk
+        {
+            fInfo.flash_scratch_pad_number_blk = fInfo.flash_persistent_start_blk\
+                - fInfo.flash_scratch_pad_start_blk;
+            // find out the offset in the start_blk
+            usedBlkSize = 0;
+            for (i = fInfo.flash_scratch_pad_start_blk; 
+                i < (fInfo.flash_scratch_pad_start_blk + fInfo.flash_scratch_pad_number_blk); i++)
+                usedBlkSize += flash_get_sector_size((byte) i);
+                fInfo.flash_scratch_pad_blk_offset =  usedBlkSize - fInfo.flash_scratch_pad_length;
+        }
+    }
+    else
+    {
+        printk("No flash for scratch pad!\n");  
+        fInfo.flash_scratch_pad_length = 0;     // no sp
+    }
+
+#if defined(DEBUG_FLASH)
+    printk("fInfo.flash_scratch_pad_start_blk = %d\n", fInfo.flash_scratch_pad_start_blk);
+    printk("fInfo.flash_scratch_pad_number_blk = %d\n", fInfo.flash_scratch_pad_number_blk);
+    printk("fInfo.flash_scratch_pad_length = 0x%x\n", fInfo.flash_scratch_pad_length);
+    printk("fInfo.flash_scratch_pad_blk_offset = 0x%x\n", (unsigned int)fInfo.flash_scratch_pad_blk_offset);
+
+    printk("fInfo.flash_nvram_start_blk = %d\n", fInfo.flash_nvram_start_blk);
+    printk("fInfo.flash_nvram_blk_offset = 0x%x\n", (unsigned int)fInfo.flash_nvram_blk_offset);
+    printk("fInfo.flash_nvram_number_blk = %d\n", fInfo.flash_nvram_number_blk);
+
+    printk("psi startAddr = %x\n", startAddr+FLASH_BASE_ADDR_REG);
+    printk("fInfo.flash_persistent_start_blk = %d\n", fInfo.flash_persistent_start_blk);
+    printk("fInfo.flash_persistent_blk_offset = 0x%x\n", (unsigned int)fInfo.flash_persistent_blk_offset);
+    printk("fInfo.flash_persistent_number_blk = %d\n", fInfo.flash_persistent_number_blk);
+#endif
+
+}
+
+
+
+/***********************************************************************
+ * Function Name: kerSysFlashAddrInfoGet
+ * Description  : Fills in a structure with information about the NVRAM
+ *                and persistent storage sections of flash memory.  
+ *                Fro physmap.c to mount the fs vol.
+ * Returns      : None.
+ ***********************************************************************/
+void kerSysFlashAddrInfoGet(PFLASH_ADDR_INFO pflash_addr_info)
+{
+    pflash_addr_info->flash_nvram_blk_offset = fInfo.flash_nvram_blk_offset;
+    pflash_addr_info->flash_nvram_length = fInfo.flash_nvram_length;
+    pflash_addr_info->flash_nvram_number_blk = fInfo.flash_nvram_number_blk;
+    pflash_addr_info->flash_nvram_start_blk = fInfo.flash_nvram_start_blk;
+    pflash_addr_info->flash_persistent_blk_offset = fInfo.flash_persistent_blk_offset;
+    pflash_addr_info->flash_persistent_length = fInfo.flash_persistent_length;
+    pflash_addr_info->flash_persistent_number_blk = fInfo.flash_persistent_number_blk;
+    pflash_addr_info->flash_persistent_start_blk = fInfo.flash_persistent_start_blk;
+}
+
+
+// get shared blks into *** pTempBuf *** which has to be released bye the caller!
+// return: if pTempBuf != NULL, poits to the data with the dataSize of the buffer
+// !NULL -- ok
+// NULL  -- fail
+static char *getSharedBlks(int start_blk, int end_blk)
+{
+    int i = 0;
+    int usedBlkSize = 0;
+    int sect_size = 0;
+    char *pTempBuf = NULL;
+    char *pBuf = NULL;
+
+    for (i = start_blk; i < end_blk; i++)
+        usedBlkSize += flash_get_sector_size((byte) i);
+
+#if defined(DEBUG_FLASH)
+    printk("usedBlkSize = %d\n", usedBlkSize);
+#endif
+
+    if ((pTempBuf = (char *) retriedKmalloc(usedBlkSize)) == NULL)
+    {
+        printk("failed to allocate memory with size: %d\n", usedBlkSize);
+        return pTempBuf;
+    }
+    
+    pBuf = pTempBuf;
+    for (i = start_blk; i < end_blk; i++)
+    {
+        sect_size = flash_get_sector_size((byte) i);
+
+#if defined(DEBUG_FLASH)
+        printk("i = %d, sect_size = %d, end_blk = %d\n", i, sect_size, end_blk);
+#endif
+        flash_read_buf((byte)i, 0, pBuf, sect_size);
+        pBuf += sect_size;
+    }
+    
+    return pTempBuf;
+}
+
+
+
+// Set the pTempBuf to flash from start_blk to end_blk
+// return:
+// 0 -- ok
+// -1 -- fail
+static int setSharedBlks(int start_blk, int end_blk, char *pTempBuf)
+{
+    int i = 0;
+    int sect_size = 0;
+    int sts = 0;
+    char *pBuf = pTempBuf;
+
+    for (i = start_blk; i < end_blk; i++)
+    {
+        sect_size = flash_get_sector_size((byte) i);
+        flash_sector_erase_int(i);
+        if (flash_write_buf(i, 0, pBuf, sect_size) != sect_size)
+        {
+            printk("Error writing flash sector %d.", i);
+            sts = -1;
+            break;
+        }
+        pBuf += sect_size;
+    }
+
+    return sts;
+}
+
+
+
+/*******************************************************************************
+ * NVRAM functions
+ *******************************************************************************/
+
+// get nvram data
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysNvRamGet(char *string, int strLen, int offset)
+{
+    char *pBuf = NULL;
+
+    if (!flashInitialized)
+        kerSysFlashInit();
+
+    if (strLen > FLASH45_LENGTH_NVRAM)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_nvram_start_blk,
+        (fInfo.flash_nvram_start_blk + fInfo.flash_nvram_number_blk))) == NULL)
+        return -1;
+
+    // get string off the memory buffer
+    memcpy(string, (pBuf + fInfo.flash_nvram_blk_offset + offset), strLen);
+
+    retriedKfree(pBuf);
+
+    return 0;
+}
+
+
+// set nvram 
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysNvRamSet(char *string, int strLen, int offset)
+{
+    int sts = 0;
+    char *pBuf = NULL;
+
+    if (strLen > FLASH45_LENGTH_NVRAM)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_nvram_start_blk,
+        (fInfo.flash_nvram_start_blk + fInfo.flash_nvram_number_blk))) == NULL)
+        return -1;
+
+    // set string to the memory buffer
+    memcpy((pBuf + fInfo.flash_nvram_blk_offset + offset), string, strLen);
+
+    if (setSharedBlks(fInfo.flash_nvram_start_blk, 
+        (fInfo.flash_nvram_number_blk + fInfo.flash_nvram_start_blk), pBuf) != 0)
+        sts = -1;
+    
+    retriedKfree(pBuf);
+
+    return sts;
+}
+
+
+/***********************************************************************
+ * Function Name: kerSysEraseNvRam
+ * Description  : Erase the NVRAM storage section of flash memory.
+ * Returns      : 1 -- ok, 0 -- fail
+ ***********************************************************************/
+int kerSysEraseNvRam(void)
+{
+    int sts = 1;
+    char *tempStorage = retriedKmalloc(FLASH45_LENGTH_NVRAM);
+    
+    // just write the whole buf with '0xff' to the flash
+    if (!tempStorage)
+        sts = 0;
+    else
+    {
+        memset(tempStorage, 0xff, FLASH45_LENGTH_NVRAM);
+        if (kerSysNvRamSet(tempStorage, FLASH45_LENGTH_NVRAM, 0) != 0)
+            sts = 0;
+        retriedKfree(tempStorage);
+    }
+
+    return sts;
+}
+
+
+/*******************************************************************************
+ * PSI functions
+ *******************************************************************************/
+// get psi data
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysPersistentGet(char *string, int strLen, int offset)
+{
+    char *pBuf = NULL;
+
+    if (strLen > fInfo.flash_persistent_length)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_persistent_start_blk,
+        (fInfo.flash_persistent_start_blk + fInfo.flash_persistent_number_blk))) == NULL)
+        return -1;
+
+    // get string off the memory buffer
+    memcpy(string, (pBuf + fInfo.flash_persistent_blk_offset + offset), strLen);
+
+    retriedKfree(pBuf);
+
+    return 0;
+}
+
+
+// set psi 
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysPersistentSet(char *string, int strLen, int offset)
+{
+    int sts = 0;
+    char *pBuf = NULL;
+
+    if (strLen > fInfo.flash_persistent_length)
+        return -1;
+
+    if ((pBuf = getSharedBlks(fInfo.flash_persistent_start_blk,
+        (fInfo.flash_persistent_start_blk + fInfo.flash_persistent_number_blk))) == NULL)
+        return -1;
+
+    // set string to the memory buffer
+    memcpy((pBuf + fInfo.flash_persistent_blk_offset + offset), string, strLen);
+
+    if (setSharedBlks(fInfo.flash_persistent_start_blk, 
+        (fInfo.flash_persistent_number_blk + fInfo.flash_persistent_start_blk), pBuf) != 0)
+        sts = -1;
+    
+    retriedKfree(pBuf);
+
+    return sts;
+}
+
+
+// flash bcm image 
+// return: 
+// 0 - ok
+// !0 - the sector number fail to be flashed (should not be 0)
+int kerSysBcmImageSet( int flash_start_addr, char *string, int size)
+{
+    int sts;
+    int sect_size;
+    int blk_start;
+    int i;
+    char *pTempBuf = NULL;
+    int whole_image = 0;
+
+    blk_start = flash_get_blk(flash_start_addr);
+    if( blk_start < 0 )
+        return( -1 );
+
+    if (flash_start_addr == FLASH_BASE && size > FLASH45_LENGTH_BOOT_ROM)
+        whole_image = 1;
+
+   /* write image to flash memory */
+    do 
+    {
+        sect_size = flash_get_sector_size(blk_start);
+// NOTE: for memory problem in multiple PVC configuration, temporary get rid of kmalloc this 64K for now.
+//        if ((pTempBuf = (char *)retriedKmalloc(sect_size)) == NULL)
+//        {
+//            printk("Failed to allocate memory with size: %d.  Reset the router...\n", sect_size);
+//            kerSysMipsSoftReset();     // reset the board right away.
+//        }
+        // for whole image, no check on psi
+        if (!whole_image && blk_start == fInfo.flash_persistent_start_blk)  // share the blk with psi
+        {
+            if (size > (sect_size - fInfo.flash_persistent_length))
+            {
+                printk("Image is too big\n");
+                break;          // image is too big. Can not overwrite to nvram
+            }
+            if ((pTempBuf = (char *)retriedKmalloc(sect_size)) == NULL)
+            {
+               printk("Failed to allocate memory with size: %d.  Reset the router...\n", sect_size);
+               kerSysMipsSoftReset();     // reset the board right away.
+            }
+            flash_read_buf((byte)blk_start, 0, pTempBuf, sect_size);
+            if (copy_from_user((void *)pTempBuf,(void *)string, size) != 0)
+                break;  // failed ?
+            flash_sector_erase_int(blk_start);     // erase blk before flash
+            if (flash_write_buf(blk_start, 0, pTempBuf, sect_size) == sect_size) 
+                size = 0;   // break out and say all is ok
+            retriedKfree(pTempBuf);
+            break;
+        }
+        
+        flash_sector_erase_int(blk_start);     // erase blk before flash
+
+        if (sect_size > size) 
+        {
+            if (size & 1) 
+                size++;
+            sect_size = size;
+        }
+        
+        if ((i = flash_write_buf(blk_start, 0, string, sect_size)) != sect_size) {
+            break;
+        }
+        blk_start++;
+        string += sect_size;
+        size -= sect_size; 
+    } while (size > 0);
+
+    if (whole_image)  
+    {
+        // If flashing a whole image, erase to end of flash.
+        int total_blks = flash_get_numsectors();
+        while( blk_start < total_blks )
+        {
+            flash_sector_erase_int(blk_start);
+            blk_start++;
+        }
+    }
+    if (pTempBuf)
+        retriedKfree(pTempBuf);
+
+    if( size == 0 ) 
+        sts = 0;  // ok
+    else  
+        sts = blk_start;    // failed to flash this sector
+
+    return sts;
+}
+
+/*******************************************************************************
+ * SP functions
+ *******************************************************************************/
+// get sp data.  NOTE: memcpy work here -- not using copy_from/to_user
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysScratchPadGet(char *tokenId, char *tokBuf, int bufLen)
+{
+    PSP_HEADER pHead = NULL;
+    PSP_TOKEN pToken = NULL;
+    char *pBuf = NULL;
+    char *pShareBuf = NULL;
+    char *startPtr = NULL;
+    char *endPtr = NULL;
+    char *spEndPtr = NULL;
+    int sts = -1;
+
+    if (fInfo.flash_scratch_pad_length == 0)
+        return sts;
+
+    if (bufLen >= (fInfo.flash_scratch_pad_length - sizeof(SP_HEADER) - sizeof(SP_TOKEN))) 
+    {
+        printk("Exceed scratch pad space by %d\n", bufLen  - fInfo.flash_scratch_pad_length \
+            - sizeof(SP_HEADER) - sizeof(SP_TOKEN));
+        return sts;
+    }
+
+    if ((pShareBuf = getSharedBlks(fInfo.flash_scratch_pad_start_blk,
+        (fInfo.flash_scratch_pad_start_blk + fInfo.flash_scratch_pad_number_blk))) == NULL)
+        return sts;
+
+    // pBuf points to SP buf
+    pBuf = pShareBuf + fInfo.flash_scratch_pad_blk_offset;  
+
+    pHead = (PSP_HEADER) pBuf;
+    if (memcmp(pHead->SPMagicNum, MAGIC_NUMBER, MAGIC_NUM_LEN) != 0) 
+    {
+        printk("Scrap pad is not initialized.\n");
+        return sts;
+    }
+
+    // search up to SPUsedLen for the token
+    startPtr = pBuf + sizeof(SP_HEADER);
+    endPtr = pBuf + pHead->SPUsedLen;
+    spEndPtr = pBuf + SP_MAX_LEN;
+    while (startPtr < endPtr && startPtr < spEndPtr)
+    {
+        pToken = (PSP_TOKEN) startPtr;
+        if (strncmp(pToken->tokenName, tokenId, TOKEN_NAME_LEN) == 0)
+        {
+            memcpy(tokBuf, startPtr + sizeof(SP_TOKEN), bufLen);
+            sts = 0;
+            break;
+        }
+        // get next token
+        startPtr += sizeof(SP_TOKEN) + pToken->tokenLen;
+    }
+
+    retriedKfree(pShareBuf);
+
+    return sts;
+}
+
+
+// set sp.  NOTE: memcpy work here -- not using copy_from/to_user
+// return:
+//  0 - ok
+//  -1 - fail
+int kerSysScratchPadSet(char *tokenId, char *tokBuf, int bufLen)
+{
+    PSP_TOKEN pToken = NULL;
+    PSP_HEADER pHead = NULL;
+    char *pShareBuf = NULL;
+    char *pBuf = NULL;
+    SP_HEADER SPHead;
+    SP_TOKEN SPToken;
+    char *curPtr;
+    int sts = -1;
+
+    if (fInfo.flash_scratch_pad_length == 0)
+        return sts;
+
+    if (bufLen >= (fInfo.flash_scratch_pad_length - sizeof(SP_HEADER) - sizeof(SP_TOKEN))) 
+    {
+        printk("Exceed scratch pad space by %d\n", bufLen  - fInfo.flash_scratch_pad_length \
+            - sizeof(SP_HEADER) - sizeof(SP_TOKEN));
+        return sts;
+    }
+
+    if ((pShareBuf = getSharedBlks(fInfo.flash_scratch_pad_start_blk,
+        (fInfo.flash_scratch_pad_start_blk + fInfo.flash_scratch_pad_number_blk))) == NULL)
+        return sts;
+
+    // pBuf points to SP buf
+    pBuf = pShareBuf + fInfo.flash_scratch_pad_blk_offset;  
+    pHead = (PSP_HEADER) pBuf;
+
+    // form header info.  SPUsedLen later on...
+    memset((char *)&SPHead, 0, sizeof(SP_HEADER));
+    memcpy(SPHead.SPMagicNum, MAGIC_NUMBER, MAGIC_NUM_LEN);
+    SPHead.SPVersion = SP_VERSION;
+
+    // form token info.
+    memset((char*)&SPToken, 0, sizeof(SP_TOKEN));
+    strncpy(SPToken.tokenName, tokenId, TOKEN_NAME_LEN - 1);
+    SPToken.tokenLen = bufLen;
+    if (memcmp(pHead->SPMagicNum, MAGIC_NUMBER, MAGIC_NUM_LEN) != 0) 
+    {
+        // new sp, so just flash the token
+        printk("No Scrap pad found.  Initialize scratch pad...\n");
+        SPHead.SPUsedLen = sizeof(SP_HEADER) + sizeof(SP_TOKEN) + bufLen;
+        memcpy(pBuf, (char *)&SPHead, sizeof(SP_HEADER));
+        curPtr = pBuf + sizeof(SP_HEADER);
+        memcpy(curPtr, (char *)&SPToken, sizeof(SP_TOKEN));
+        curPtr += sizeof(SP_TOKEN);
+        memcpy(curPtr, tokBuf, bufLen);
+    }
+    else  
+    {
+        // need search for the token, if exist with same size overwrite it. if sizes differ, 
+        // move over the later token data over and put the new one at the end
+        char *endPtr = pBuf + pHead->SPUsedLen;
+        char *spEndPtr = pBuf + SP_MAX_LEN;
+        curPtr = pBuf + sizeof(SP_HEADER);
+        while (curPtr < endPtr && curPtr < spEndPtr)
+        {
+            pToken = (PSP_TOKEN) curPtr;
+            if (strncmp(pToken->tokenName, tokenId, TOKEN_NAME_LEN) == 0)
+            {
+                if (pToken->tokenLen == bufLen) // overwirte it
+                {
+                    memcpy((curPtr+sizeof(SP_TOKEN)), tokBuf, bufLen);
+                    break;
+                }
+                else // move later data over and put the new token at the end
+                {
+                    memcpy((curPtr+sizeof(SP_TOKEN)), tokBuf, bufLen);  // ~~~
+                    break;
+                }
+            }
+            else // not same token ~~~
+            {
+            }
+            // get next token
+            curPtr += sizeof(SP_TOKEN) + pToken->tokenLen;
+        } // end while
+        SPHead.SPUsedLen = sizeof(SP_HEADER) + sizeof(SP_TOKEN) + bufLen; // ~~~
+        if (SPHead.SPUsedLen > SP_MAX_LEN)
+        {
+            printk("No more Scratch pad space left! Over limit by %d bytes\n", SPHead.SPUsedLen - SP_MAX_LEN);
+            return sts;
+        }
+
+    } // else if not new sp
+
+    sts = setSharedBlks(fInfo.flash_scratch_pad_start_blk, 
+        (fInfo.flash_scratch_pad_number_blk + fInfo.flash_scratch_pad_start_blk), pShareBuf);
+    
+    retriedKfree(pShareBuf);
+
+    return sts;
+
+    
+}
+
+int kerSysFlashSizeGet(void)
+{
+   return flash_get_total_size();
+}
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_led.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_led.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_led.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/bcm63xx_led.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,582 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***************************************************************************
+ * File Name  : bcm63xx_led.c
+ *
+ * Description: 
+ *
+ *    This file contains bcm963xx board led control API functions. 
+ *
+ *    To use it, do the following
+ *
+ *    1). define in the board.c the following led mappping (this is for 6345GW board):
+ *        const LED_MAP_PAIR cLedMapping45GW[] =
+ *        {   // led name     Initial state       physical pin (ledMask)
+ *            {kLedUsb,       kLedStateOff,       GPIO_LED_PIN_7}, 
+ *            {kLedAdsl,      kLedStateOff,       GPIO_LED_PIN_8},
+ *            {kLedPPP,       kLedStateOff,       GPIO_LED_PIN_9},    // PPP and WanData share PIN_9
+ *            {kLedWanData,   kLedStateOff,       GPIO_LED_PIN_9},
+ *            {kLedWireless,  kLedStateOff,       GPIO_LED_PIN_10},
+ *            {kLedEnd,       kLedStateOff,       0              } // NOTE: kLedEnd has to be at the end.
+ *
+ *    2). };To initialize led API and initial state of the leds, call the following function with the mapping 
+ *        pointer from the above struct
+ *
+ *        boardLedInit((PLED_MAP_PAIR) &cLedMapping45R);
+ *
+ *    3). Sample call for kernel mode:
+ *
+ *        kerSysLedCtrl(kLedAdsl, kLedStateBlinkOnce);        // kLedxxx defines in board.h
+ *
+ *    4). Sample call for user mode
+ *
+ *        sysLedCtrl(kLedAdsl, kLedStateBlinkOnce);           // kLedxxx defines in board_api.h
+ *
+ *
+ * Created on :  10/28/2002  seanl
+ *
+ ***************************************************************************/
+
+/* Includes. */
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <asm/uaccess.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+
+#define k100ms              (HZ / 10)     // ~100 ms
+#define kFastBlinkCount     0             // ~100ms
+#define kSlowBlinkCount     5             // ~600ms
+
+#define MAX_VIRT_LEDS       12
+
+// uncomment // for debug led
+//#define DEBUG_LED
+
+// global variables:
+struct timer_list gLedTimer;
+int gTimerOn = FALSE;
+int gLedCount = 0;
+
+typedef struct ledinfo
+{
+    unsigned short ledMask;         // mask for led: ie. giop 10 = 0x0400
+    unsigned short ledActiveLow;    // GPIO bit reset to turn on LED
+    unsigned short ledMaskFail;     // mask for led: ie. giop 10 = 0x0400
+    unsigned short ledActiveLowFail;// GPIO bit reset to turn on LED
+    BOARD_LED_STATE ledState;       // current led state
+    BOARD_LED_STATE savedLedState;  // used in blink once for restore to the orignal ledState
+    int blinkCountDown;             // if == 0, do blink (toggle).  Is assgined value and dec by 1 at each timer.
+} LED_INFO, *PLED_INFO;
+
+static PLED_INFO gLed = NULL;
+static PLED_INFO gpVirtLeds[MAX_VIRT_LEDS];
+static HANDLE_LED_FUNC gLedHwFunc[MAX_VIRT_LEDS];
+static HANDLE_LED_FUNC gLedHwFailFunc[MAX_VIRT_LEDS];
+
+#if 0 /* BROKEN */
+#if defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+static int gLedOffInBridgeMode = 1;
+#elif defined(CONFIG_BCM96345)
+static int gLedOffInBridgeMode = 0;
+#endif
+#endif
+
+void ledTimerExpire(void);
+int initLedInfo( PLED_MAP_PAIR pCurMap, PLED_INFO pCurLed );
+
+//**************************************************************************************
+// LED operations
+//**************************************************************************************
+
+// turn led on and set the ledState
+void ledOn(PLED_INFO pLed)
+{
+    if( pLed->ledMask )
+    {
+        GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLow )
+            GPIO->GPIOio  &= ~pLed->ledMask;    // turn on the led
+        else
+            GPIO->GPIOio  |= pLed->ledMask;     // turn on the led
+        pLed->ledState = pLed->savedLedState = kLedStateOn;
+    }
+}
+
+
+// turn led off and set the ledState
+void ledOff(PLED_INFO pLed)
+{
+    if( pLed->ledMask )
+    {
+        GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLow )
+            GPIO->GPIOio  |= pLed->ledMask;     // turn off the led
+        else
+            GPIO->GPIOio  &= ~pLed->ledMask;    // turn off the led
+        pLed->ledState = pLed->savedLedState = kLedStateOff;
+    }
+}
+
+// turn led on and set the ledState
+void ledOnFail(PLED_INFO pLed)
+{
+    if( pLed->ledMaskFail )
+    {
+        GPIO->GPIODir |= pLed->ledMaskFail;     // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLowFail )
+            GPIO->GPIOio  &= ~pLed->ledMaskFail;// turn on the led
+        else
+            GPIO->GPIOio  |= pLed->ledMaskFail; // turn on the led
+        pLed->ledState = pLed->savedLedState = kLedStateFail;
+    }
+}
+
+
+// turn led off and set the ledState
+void ledOffFail(PLED_INFO pLed)
+{
+    if( pLed->ledMaskFail )
+    {
+        GPIO->GPIODir |= pLed->ledMaskFail;     // turn on the direction bit in case was turned off by some one
+        if( pLed->ledActiveLowFail )
+            GPIO->GPIOio  |= pLed->ledMaskFail; // turn off the led
+        else
+            GPIO->GPIOio  &= ~pLed->ledMaskFail;// turn off the led
+        pLed->ledState = pLed->savedLedState = kLedStateOff;
+    }
+}
+
+
+// toggle the led and return the current ledState
+BOARD_LED_STATE ledToggle(PLED_INFO pLed)
+{
+    GPIO->GPIODir |= pLed->ledMask;         // turn on the direction bit in case was turned off by some one
+    if (GPIO->GPIOio & pLed->ledMask)
+    {
+        GPIO->GPIOio &= ~(pLed->ledMask);
+        return( (pLed->ledActiveLow) ? kLedStateOn : kLedStateOff );
+    }
+    else
+    {
+        GPIO->GPIOio |= pLed->ledMask;
+        return( (pLed->ledActiveLow) ? kLedStateOff : kLedStateOn );
+    }
+}   
+
+
+// led timer.  Will return if timer is already on
+void ledTimerStart(void)
+{
+    if (gTimerOn)
+        return;
+
+#if defined(DEBUG_LED)
+    printk("led: add_timer\n");
+#endif
+
+    init_timer(&gLedTimer);
+    gLedTimer.function = (void*)ledTimerExpire;
+    gLedTimer.expires = jiffies + k100ms;        // timer expires in ~100ms
+    add_timer (&gLedTimer);
+    gTimerOn = TRUE;
+} 
+
+
+// led timer expire kicks in about ~100ms and perform the led operation according to the ledState and
+// restart the timer according to ledState
+void ledTimerExpire(void)
+{
+    int i;
+    PLED_INFO pCurLed;
+
+    gTimerOn = FALSE;
+
+    for (i = 0, pCurLed = gLed; i < gLedCount; i++, pCurLed++)
+    {
+#if defined(DEBUG_LED)
+        printk("led[%d]: Mask=0x%04x, State = %d, blcd=%d\n", i, pCurLed->ledMask, pCurLed->ledState, pCurLed->blinkCountDown);
+#endif
+        switch (pCurLed->ledState)
+        {
+            case kLedStateOn:
+            case kLedStateOff:
+            case kLedStateFail:
+                pCurLed->blinkCountDown = 0;            // reset the blink count down
+                break;
+
+            case kLedStateBlinkOnce:
+                ledToggle(pCurLed);
+                pCurLed->blinkCountDown = 0;                      // reset to 0
+                pCurLed->ledState = pCurLed->savedLedState;
+                if (pCurLed->ledState == kLedStateSlowBlinkContinues || 
+                    pCurLed->ledState == kLedStateFastBlinkContinues)
+                    ledTimerStart();                  // start timer if in blinkContinues stats
+                break;
+
+            case kLedStateSlowBlinkContinues:
+                if (pCurLed->blinkCountDown-- == 0)
+                {
+                    pCurLed->blinkCountDown = kSlowBlinkCount;
+                    ledToggle(pCurLed);
+                }
+                ledTimerStart();
+                break;
+
+            case kLedStateFastBlinkContinues:
+                if (pCurLed->blinkCountDown-- == 0)
+                {
+                    pCurLed->blinkCountDown = kFastBlinkCount;
+                    ledToggle(pCurLed);
+                }
+                ledTimerStart();
+                break;
+
+            default:
+                printk("Invalid state = %d\n", pCurLed->ledState);
+        }
+    }
+}
+
+// initialize the gLedCount and allocate and fill gLed struct
+void __init boardLedInit(PLED_MAP_PAIR cLedMapping)
+{
+    PLED_MAP_PAIR p1, p2;
+    PLED_INFO pCurLed;
+    int needTimer = FALSE;
+    int alreadyUsed = 0;
+
+#if defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+    /* Set blink rate for BCM6348/BCM6338 hardware LEDs. */
+    GPIO->LEDCtrl &= ~LED_INTERVAL_SET_MASK;
+    GPIO->LEDCtrl |= LED_INTERVAL_SET_80MS;
+#endif
+
+    memset( gpVirtLeds, 0x00, sizeof(gpVirtLeds) );
+    memset( gLedHwFunc, 0x00, sizeof(gLedHwFunc) );
+    memset( gLedHwFailFunc, 0x00, sizeof(gLedHwFailFunc) );
+
+    gLedCount = 0;
+
+    // Check for multiple LED names and multiple LED GPIO pins that share the
+    // same physical board LED.
+    for( p1 = cLedMapping; p1->ledName != kLedEnd; p1++ )
+    {
+        alreadyUsed = 0;
+        for( p2 = cLedMapping; p2 != p1; p2++ )
+        {
+            if( (p1->ledMask && p1->ledMask == p2->ledMask) ||
+                (p1->ledMaskFail && p1->ledMaskFail == p2->ledMaskFail) )
+            {
+                alreadyUsed = 1;
+                break;
+            }
+        }
+
+        if( alreadyUsed == 0  )
+            gLedCount++;
+    }
+
+    gLed = (PLED_INFO) kmalloc((gLedCount * sizeof(LED_INFO)), GFP_KERNEL);
+    if( gLed == NULL )
+    {
+        printk( "LED memory allocation error.\n" );
+        return;
+    }
+
+    memset( gLed, 0x00, gLedCount * sizeof(LED_INFO) );
+
+    // initial the gLed with unique ledMask and initial state. If more than 1 ledNames share the physical led 
+    // (ledMask) the first defined led's ledInitState will be used.
+    pCurLed = gLed;
+    for( p1 = cLedMapping; p1->ledName != kLedEnd; p1++ )
+    {
+        if( (int) p1->ledName > MAX_VIRT_LEDS )
+            continue;
+
+        alreadyUsed = 0;
+        for( p2 = cLedMapping; p2 != p1; p2++ )
+        {
+            if( (p1->ledMask && p1->ledMask == p2->ledMask) ||
+                (p1->ledMaskFail && p1->ledMaskFail == p2->ledMaskFail) )
+            {
+                alreadyUsed = 1;
+                break;
+            }
+        }
+
+        if( alreadyUsed == 0 )
+        {
+            // Initialize the board LED for the first time.
+            needTimer = initLedInfo( p1, pCurLed );
+            gpVirtLeds[(int) p1->ledName] = pCurLed;
+            pCurLed++;
+        }
+        else
+        {
+            PLED_INFO pLed;
+            for( pLed = gLed; pLed != pCurLed; pLed++ )
+            {
+                // Find the LED_INFO structure that has already been initialized.
+                if((pLed->ledMask && pLed->ledMask == p1->ledMask) ||
+                   (pLed->ledMaskFail && pLed->ledMaskFail==p1->ledMaskFail))
+                {
+                    // The board LED has already been initialized but possibly
+                    // not completely initialized.
+                    if( p1->ledMask )
+                    {
+                        pLed->ledMask = p1->ledMask;
+                        pLed->ledActiveLow = p1->ledActiveLow;
+                    }
+                    if( p1->ledMaskFail )
+                    {
+                        pLed->ledMaskFail = p1->ledMaskFail;
+                        pLed->ledActiveLowFail = p1->ledActiveLowFail;
+                    }
+                    gpVirtLeds[(int) p1->ledName] = pLed;
+                    break;
+                }
+            }
+        }
+    }
+
+    if (needTimer)
+        ledTimerStart();
+
+#if defined(DEBUG_LED)
+    int i;
+    for (i=0; i < gLedCount; i++)
+        printk("initLed: led[%d]: mask=0x%04x, state=%d\n", i,(gLed+i)->ledMask, (gLed+i)->ledState);
+#endif
+
+}
+
+// Initialize a structure that contains information about a physical board LED
+// control.  The board LED may contain more than one GPIO pin to control a
+// normal condition (green) or a failure condition (red).
+int initLedInfo( PLED_MAP_PAIR pCurMap, PLED_INFO pCurLed )
+{
+    int needTimer = FALSE;
+    pCurLed->ledState = pCurLed->savedLedState = pCurMap->ledInitState;
+    pCurLed->ledMask = pCurMap->ledMask;
+    pCurLed->ledActiveLow = pCurMap->ledActiveLow;
+    pCurLed->ledMaskFail = pCurMap->ledMaskFail;
+    pCurLed->ledActiveLowFail = pCurMap->ledActiveLowFail;
+
+    switch (pCurLed->ledState)
+    {
+        case kLedStateOn:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOn(pCurLed);
+            break;
+        case kLedStateOff:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOff(pCurLed);
+            break;
+        case kLedStateFail:
+            pCurLed->blinkCountDown = 0;            // reset the blink count down
+            ledOnFail(pCurLed);
+            break;
+        case kLedStateBlinkOnce:
+            pCurLed->blinkCountDown = 1;
+            needTimer = TRUE;
+            break;
+        case kLedStateSlowBlinkContinues:
+            pCurLed->blinkCountDown = kSlowBlinkCount;
+            needTimer = TRUE;
+            break;
+        case kLedStateFastBlinkContinues:
+            pCurLed->blinkCountDown = kFastBlinkCount;
+            needTimer = TRUE;
+            break;
+        default:
+            printk("Invalid state = %d\n", pCurLed->ledState);
+    }
+
+    return( needTimer );
+}
+
+#if 0 /* BROKEN */
+// Determines if there is at least one interface in bridge mode.  Bridge mode
+// is determined by the cfm convention of naming bridge interfaces nas17
+// through nas24.
+static int isBridgedProtocol(void)
+{
+    extern int dev_get(const char *name);
+    const int firstBridgeId = 17;
+    const int lastBridgeId = 24;
+    int i;
+    int ret = FALSE;
+    char name[16];
+
+    for( i = firstBridgeId; i <= lastBridgeId; i++ )
+    {
+        sprintf( name, "nas%d", i );
+
+        if( dev_get(name) )
+        {
+            ret = TRUE;
+            break;
+        }
+    }
+
+    return(ret);
+}
+#endif
+
+// led ctrl.  Maps the ledName to the corresponding ledInfoPtr and perform the led operation
+void boardLedCtrl(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState)
+{
+    PLED_INFO ledInfoPtr;
+
+    // do the mapping from virtual to physical led
+    if( (int) ledName < MAX_VIRT_LEDS )
+        ledInfoPtr = gpVirtLeds[(int) ledName];
+    else
+        ledInfoPtr = NULL;
+
+    if (ledInfoPtr == NULL)
+        return;
+
+    if( ledState != kLedStateFail && gLedHwFunc[(int) ledName] )
+    {
+        (*gLedHwFunc[(int) ledName]) (ledName, ledState);
+        ledOffFail(ledInfoPtr);
+        return;
+    }
+    else
+        if( ledState == kLedStateFail && gLedHwFailFunc[(int) ledName] )
+        {
+            (*gLedHwFailFunc[(int) ledName]) (ledName, ledState);
+            ledOff(ledInfoPtr);
+            return;
+        }
+
+#if 0 /* BROKEN */
+    // Do not blink the WAN Data LED if at least one interface is in bridge mode.
+    if(gLedOffInBridgeMode == 1 && (ledName == kLedWanData || ledName == kLedPPP))
+    {
+        static int BridgedProtocol = -1;
+
+        if( BridgedProtocol == -1 )
+            BridgedProtocol = isBridgedProtocol();
+
+        if( BridgedProtocol == TRUE )
+            return;
+    }
+#endif
+
+    // If the state is kLedStateFail and there is not a failure LED defined
+    // in the board parameters, change the state to kLedStateFastBlinkContinues.
+    if( ledState == kLedStateFail && ledInfoPtr->ledMaskFail == 0 )
+        ledState = kLedStateFastBlinkContinues;
+
+    switch (ledState)
+    {
+        case kLedStateOn:
+            // First, turn off the complimentary (failure) LED GPIO.
+            if( ledInfoPtr->ledMaskFail )
+                ledOffFail(ledInfoPtr);
+            else
+                if( gLedHwFailFunc[(int) ledName] )
+                    (*gLedHwFailFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn on the specified LED GPIO.
+            ledOn(ledInfoPtr);
+            break;
+
+        case kLedStateOff: 
+            // First, turn off the complimentary (failure) LED GPIO.
+            if( ledInfoPtr->ledMaskFail )
+                ledOffFail(ledInfoPtr);
+            else
+                if( gLedHwFailFunc[(int) ledName] )
+                    (*gLedHwFailFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn off the specified LED GPIO.
+            ledOff(ledInfoPtr);
+            break;
+
+        case kLedStateFail:
+            // First, turn off the complimentary (normal) LED GPIO.
+            if( ledInfoPtr->ledMask )
+                ledOff(ledInfoPtr);
+            else
+                if( gLedHwFunc[(int) ledName] )
+                    (*gLedHwFunc[(int) ledName]) (ledName, kLedStateOff);
+
+            // Next, turn on (red) the specified LED GPIO.
+            ledOnFail(ledInfoPtr);
+            break;
+
+        case kLedStateBlinkOnce:
+            // skip blinkOnce if it is already in Slow/Fast blink continues state
+            if (ledInfoPtr->savedLedState == kLedStateSlowBlinkContinues ||
+                ledInfoPtr->savedLedState == kLedStateFastBlinkContinues)
+                ;
+            else
+            {
+                if (ledInfoPtr->blinkCountDown == 0)  // skip the call if it is 1
+                {
+                    ledToggle(ledInfoPtr);
+                    ledInfoPtr->blinkCountDown = 1;  // it will be reset to 0 when timer expires
+                    ledInfoPtr->ledState = kLedStateBlinkOnce;
+                    ledTimerStart();
+                }
+            }
+            break;
+
+        case kLedStateSlowBlinkContinues:
+            ledInfoPtr->blinkCountDown = kSlowBlinkCount;
+            ledInfoPtr->ledState = kLedStateSlowBlinkContinues;
+            ledInfoPtr->savedLedState = kLedStateSlowBlinkContinues;
+            ledTimerStart();
+            break;
+
+        case kLedStateFastBlinkContinues:
+            ledInfoPtr->blinkCountDown = kFastBlinkCount;
+            ledInfoPtr->ledState = kLedStateFastBlinkContinues;
+            ledInfoPtr->savedLedState = kLedStateFastBlinkContinues;
+            ledTimerStart();
+            break;
+
+        default:
+            printk("Invalid led state\n");
+    }
+}
+
+// This function is called for an LED that is controlled by hardware.
+void kerSysLedRegisterHwHandler( BOARD_LED_NAME ledName,
+    HANDLE_LED_FUNC ledHwFunc, int ledFailType )
+{
+    if( (int) ledName < MAX_VIRT_LEDS )
+    {
+        if( ledFailType == 1 )
+            gLedHwFailFunc[(int) ledName] = ledHwFunc;
+        else
+            gLedHwFunc[(int) ledName] = ledHwFunc;
+    }
+}
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/board.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/board.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/board.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/board.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,1570 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***************************************************************************
+ * File Name  : board.c
+ *
+ * Description: This file contains Linux character device driver entry 
+ *              for the board related ioctl calls: flash, get free kernel
+ *              page and dump kernel memory, etc.
+ *
+ * Created on :  2/20/2002  seanl:  use cfiflash.c, cfliflash.h (AMD specific)
+ *
+ ***************************************************************************/
+
+
+/* Includes. */
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/capability.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <asm/uaccess.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/list.h>
+#include <linux/if.h>
+
+#include <bcm_map_part.h>
+#include <board.h>
+#include <bcmTag.h>
+#include "boardparms.h"
+#include "cfiflash.h"
+#include "bcm_intr.h"
+#include "board.h"
+#include "bcm_map_part.h"
+
+/* Typedefs. */
+#if defined (NON_CONSECUTIVE_MAC)
+// used to be the last octet. Now changed to the first 5 bits of the the forth octet
+// to reduced the duplicated MAC addresses.
+#define CHANGED_OCTET   3
+#define SHIFT_BITS      3
+#else
+#define CHANGED_OCTET   1
+#define SHIFT_BITS      0
+#endif
+
+#if defined (WIRELESS)
+#define SES_BTN_PRESSED 0x00000001
+#define SES_EVENTS      SES_BTN_PRESSED /*OR all values if any*/
+#define SES_LED_OFF     0
+#define SES_LED_ON      1
+#define SES_LED_BLINK   2
+#endif
+
+typedef struct
+{
+    unsigned long ulId;
+    char chInUse;
+    char chReserved[3];
+} MAC_ADDR_INFO, *PMAC_ADDR_INFO;
+
+typedef struct
+{
+    unsigned long ulSdramSize;
+    unsigned long ulPsiSize;
+    unsigned long ulNumMacAddrs;
+    unsigned long ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    MAC_ADDR_INFO MacAddrs[1];
+} NVRAM_INFO, *PNVRAM_INFO;
+
+typedef struct
+{
+    unsigned long eventmask;    
+} BOARD_IOC, *PBOARD_IOC;
+
+
+/*Dyinggasp callback*/
+typedef void (*cb_dgasp_t)(void *arg);
+typedef struct _CB_DGASP__LIST
+{
+    struct list_head list;
+    char name[IFNAMSIZ];
+    cb_dgasp_t cb_dgasp_fn;
+    void *context;
+}CB_DGASP_LIST , *PCB_DGASP_LIST;
+
+
+static LED_MAP_PAIR LedMapping[] =
+{   // led name     Initial state       physical pin (ledMask)
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0}, 
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0}, 
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0},     
+    {kLedEnd,       kLedStateOff,       0, 0, 0, 0} // NOTE: kLedEnd has to be at the end.
+};
+
+/* Externs. */
+extern struct file fastcall *fget_light(unsigned int fd, int *fput_needed);
+extern unsigned int nr_free_pages (void);
+extern const char *get_system_type(void);
+extern void kerSysFlashInit(void);
+extern unsigned long get_nvram_start_addr(void);
+extern unsigned long get_scratch_pad_start_addr(void);
+extern unsigned long getMemorySize(void);
+extern void __init boardLedInit(PLED_MAP_PAIR);
+extern void boardLedCtrl(BOARD_LED_NAME, BOARD_LED_STATE);
+extern void kerSysLedRegisterHandler( BOARD_LED_NAME ledName,
+    HANDLE_LED_FUNC ledHwFunc, int ledFailType );
+
+/* Prototypes. */
+void __init InitNvramInfo( void );
+static int board_open( struct inode *inode, struct file *filp );
+static int board_ioctl( struct inode *inode, struct file *flip, unsigned int command, unsigned long arg );
+static ssize_t board_read(struct file *filp,  char __user *buffer, size_t count, loff_t *ppos); 
+static unsigned int board_poll(struct file *filp, struct poll_table_struct *wait);
+static int board_release(struct inode *inode, struct file *filp);                        
+
+static BOARD_IOC* borad_ioc_alloc(void);
+static void borad_ioc_free(BOARD_IOC* board_ioc);
+
+/* DyingGasp function prototype */
+static void __init kerSysDyingGaspMapIntr(void);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+static irqreturn_t kerSysDyingGaspIsr(int irq, void * dev_id, struct pt_regs * regs);
+#else
+static unsigned int kerSysDyingGaspIsr(void);
+#endif
+static void __init kerSysInitDyingGaspHandler( void );
+static void __exit kerSysDeinitDyingGaspHandler( void );
+/* -DyingGasp function prototype - */
+
+
+#if defined (WIRELESS)
+static irqreturn_t sesBtn_isr(int irq, void *dev_id, struct pt_regs *ptregs);
+static void __init sesBtn_mapGpio(void);
+static void __init sesBtn_mapIntr(int context);
+static unsigned int sesBtn_poll(struct file *file, struct poll_table_struct *wait);
+static ssize_t sesBtn_read(struct file *file,  char __user *buffer, size_t count, loff_t *ppos);
+static void __init sesLed_mapGpio(void);
+static void sesLed_ctrl(int action);
+static void __init ses_board_init(void);
+static void __exit ses_board_deinit(void);
+#endif
+
+static PNVRAM_INFO g_pNvramInfo = NULL;
+static int g_ledInitialized = 0;
+static wait_queue_head_t g_board_wait_queue;
+static CB_DGASP_LIST *g_cb_dgasp_list_head = NULL;
+
+static int g_wakeup_monitor = 0;
+static struct file *g_monitor_file = NULL;
+static struct task_struct *g_monitor_task = NULL;
+static unsigned int (*g_orig_fop_poll)
+    (struct file *, struct poll_table_struct *) = NULL;
+
+static struct file_operations board_fops =
+{
+  open:       board_open,
+  ioctl:      board_ioctl,
+  poll:       board_poll,
+  read:       board_read,
+  release:    board_release,
+};
+
+uint32 board_major = 0;
+
+#if defined (WIRELESS)
+static unsigned short sesBtn_irq = BP_NOT_DEFINED;
+static unsigned short sesBtn_gpio = BP_NOT_DEFINED;
+static unsigned short sesLed_gpio = BP_NOT_DEFINED;
+#endif
+
+#if defined(MODULE)
+int init_module(void)
+{
+    return( brcm_board_init() );              
+}
+
+void cleanup_module(void)
+{
+    if (MOD_IN_USE)
+        printk("brcm flash: cleanup_module failed because module is in use\n");
+    else
+        brcm_board_cleanup();
+}
+#endif //MODULE 
+
+
+
+static int __init brcm_board_init( void )
+{
+    typedef int (*BP_LED_FUNC) (unsigned short *);
+    static struct BpLedInformation
+    {
+        BOARD_LED_NAME ledName;
+        BP_LED_FUNC bpFunc;
+        BP_LED_FUNC bpFuncFail;
+    } bpLedInfo[] =
+    {{kLedAdsl, BpGetAdslLedGpio, BpGetAdslFailLedGpio},
+     {kLedWireless, BpGetWirelessLedGpio, NULL},
+     {kLedUsb, BpGetUsbLedGpio, NULL},
+     {kLedHpna, BpGetHpnaLedGpio, NULL},
+     {kLedWanData, BpGetWanDataLedGpio, NULL},
+     {kLedPPP, BpGetPppLedGpio, BpGetPppFailLedGpio},
+     {kLedVoip, BpGetVoipLedGpio, NULL},
+     {kLedSes, BpGetWirelessSesLedGpio, NULL},     
+     {kLedEnd, NULL, NULL}
+    };
+
+    int ret;
+        
+    ret = register_chrdev(BOARD_DRV_MAJOR, "bcrmboard", &board_fops );
+    if (ret < 0)
+        printk( "brcm_board_init(major %d): fail to register device.\n",BOARD_DRV_MAJOR);
+    else 
+    {
+        PLED_MAP_PAIR pLedMap = LedMapping;
+        unsigned short gpio;
+        struct BpLedInformation *pInfo;
+
+        printk("brcmboard: brcm_board_init entry\n");
+        board_major = BOARD_DRV_MAJOR;
+        InitNvramInfo();
+
+        for( pInfo = bpLedInfo; pInfo->ledName != kLedEnd; pInfo++ )
+        {
+            if( pInfo->bpFunc && (*pInfo->bpFunc) (&gpio) == BP_SUCCESS )
+            {
+                pLedMap->ledName = pInfo->ledName;
+                pLedMap->ledMask = GPIO_NUM_TO_MASK(gpio);
+                pLedMap->ledActiveLow = (gpio & BP_ACTIVE_LOW) ? 1 : 0;
+            }
+            if( pInfo->bpFuncFail && (*pInfo->bpFuncFail) (&gpio) == BP_SUCCESS )
+            {
+                pLedMap->ledName = pInfo->ledName;
+                pLedMap->ledMaskFail = GPIO_NUM_TO_MASK(gpio);
+                pLedMap->ledActiveLowFail = (gpio & BP_ACTIVE_LOW) ? 1 : 0;
+            }
+            if( pLedMap->ledName != kLedEnd )
+                pLedMap++;
+        }
+        
+        init_waitqueue_head(&g_board_wait_queue);
+#if defined (WIRELESS)
+        ses_board_init();
+#endif        
+        kerSysInitDyingGaspHandler();
+        kerSysDyingGaspMapIntr();
+
+        boardLedInit(LedMapping);
+        g_ledInitialized = 1;
+    }
+
+    return ret;
+} 
+
+void __init InitNvramInfo( void )
+{
+    PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+    unsigned long ulNumMacAddrs = pNvramData->ulNumMacAddrs;
+
+    if( ulNumMacAddrs > 0 && ulNumMacAddrs <= NVRAM_MAC_COUNT_MAX )
+    {
+        unsigned long ulNvramInfoSize =
+            sizeof(NVRAM_INFO) + ((sizeof(MAC_ADDR_INFO) - 1) * ulNumMacAddrs);
+
+        g_pNvramInfo = (PNVRAM_INFO) kmalloc( ulNvramInfoSize, GFP_KERNEL );
+
+        if( g_pNvramInfo )
+        {
+            unsigned long ulPsiSize;
+            if( BpGetPsiSize( &ulPsiSize ) != BP_SUCCESS )
+                ulPsiSize = NVRAM_PSI_DEFAULT;
+            memset( g_pNvramInfo, 0x00, ulNvramInfoSize );
+            g_pNvramInfo->ulPsiSize = ulPsiSize * 1024;
+            g_pNvramInfo->ulNumMacAddrs = pNvramData->ulNumMacAddrs;
+            memcpy( g_pNvramInfo->ucaBaseMacAddr, pNvramData->ucaBaseMacAddr,
+                NVRAM_MAC_ADDRESS_LEN );
+            g_pNvramInfo->ulSdramSize = getMemorySize();
+        }
+        else
+            printk("ERROR - Could not allocate memory for NVRAM data\n");
+    }
+    else
+        printk("ERROR - Invalid number of MAC addresses (%ld) is configured.\n",
+            ulNumMacAddrs);
+}
+
+void __exit brcm_board_cleanup( void )
+{
+    printk("brcm_board_cleanup()\n");
+	
+    if (board_major != -1) 
+    {
+#if defined (WIRELESS)    	
+    	ses_board_deinit();
+#endif    	
+        kerSysDeinitDyingGaspHandler();
+        unregister_chrdev(board_major, "board_ioctl");
+    }
+} 
+
+static BOARD_IOC* borad_ioc_alloc(void)
+{
+    BOARD_IOC *board_ioc =NULL;
+    board_ioc = (BOARD_IOC*) kmalloc( sizeof(BOARD_IOC) , GFP_KERNEL );
+    if(board_ioc)
+    {
+        memset(board_ioc, 0, sizeof(BOARD_IOC));
+    }
+    return board_ioc;
+}
+
+static void borad_ioc_free(BOARD_IOC* board_ioc)
+{
+    if(board_ioc)
+    {
+        kfree(board_ioc);
+    }	
+}
+
+
+static int board_open( struct inode *inode, struct file *filp )
+{
+    filp->private_data = borad_ioc_alloc();
+
+    if (filp->private_data == NULL)
+        return -ENOMEM;
+            
+    return( 0 );
+} 
+
+static int board_release(struct inode *inode, struct file *filp)
+{
+    BOARD_IOC *board_ioc = filp->private_data;
+    
+    wait_event_interruptible(g_board_wait_queue, 1);    
+    borad_ioc_free(board_ioc);
+
+    return( 0 );
+} 
+
+
+static unsigned int board_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+#if defined (WIRELESS)        	
+    BOARD_IOC *board_ioc = filp->private_data;    	
+#endif
+    	
+    poll_wait(filp, &g_board_wait_queue, wait);
+#if defined (WIRELESS)        	
+    if(board_ioc->eventmask & SES_EVENTS){
+        mask |= sesBtn_poll(filp, wait);
+    }			
+#endif    
+
+    return mask;
+}
+
+
+static ssize_t board_read(struct file *filp,  char __user *buffer, size_t count, loff_t *ppos)
+{
+#if defined (WIRELESS)    
+    BOARD_IOC *board_ioc = filp->private_data;
+    if(board_ioc->eventmask & SES_EVENTS){
+    	return sesBtn_read(filp, buffer, count, ppos);
+    }
+#endif    
+    return 0;
+}
+
+//**************************************************************************************
+// Utitlities for dump memory, free kernel pages, mips soft reset, etc.
+//**************************************************************************************
+
+/***********************************************************************
+ * Function Name: dumpaddr
+ * Description  : Display a hex dump of the specified address.
+ ***********************************************************************/
+void dumpaddr( unsigned char *pAddr, int nLen )
+{
+    static char szHexChars[] = "0123456789abcdef";
+    char szLine[80];
+    char *p = szLine;
+    unsigned char ch, *q;
+    int i, j;
+    unsigned long ul;
+
+    while( nLen > 0 )
+    {
+        sprintf( szLine, "%8.8lx: ", (unsigned long) pAddr );
+        p = szLine + strlen(szLine);
+
+        for(i = 0; i < 16 && nLen > 0; i += sizeof(long), nLen -= sizeof(long))
+        {
+            ul = *(unsigned long *) &pAddr[i];
+            q = (unsigned char *) &ul;
+            for( j = 0; j < sizeof(long); j++ )
+            {
+                *p++ = szHexChars[q[j] >> 4];
+                *p++ = szHexChars[q[j] & 0x0f];
+                *p++ = ' ';
+            }
+        }
+
+        for( j = 0; j < 16 - i; j++ )
+            *p++ = ' ', *p++ = ' ', *p++ = ' ';
+
+        *p++ = ' ', *p++ = ' ', *p++ = ' ';
+
+        for( j = 0; j < i; j++ )
+        {
+            ch = pAddr[j];
+            *p++ = (ch > ' ' && ch < '~') ? ch : '.';
+        }
+
+        *p++ = '\0';
+        printk( "%s\r\n", szLine );
+
+        pAddr += i;
+    }
+    printk( "\r\n" );
+} /* dumpaddr */
+
+
+void kerSysMipsSoftReset(void)
+{
+#if defined(CONFIG_BCM96348)
+    if (PERF->RevID == 0x634800A1) {
+        typedef void (*FNPTR) (void);
+        FNPTR bootaddr = (FNPTR) FLASH_BASE;
+        int i;
+
+        /* Disable interrupts. */
+        cli();
+
+        /* Reset all blocks. */
+        PERF->BlockSoftReset &= ~BSR_ALL_BLOCKS;
+        for( i = 0; i < 1000000; i++ )
+            ;
+        PERF->BlockSoftReset |= BSR_ALL_BLOCKS;
+        /* Jump to the power on address. */
+        (*bootaddr) ();
+    }
+    else
+        PERF->pll_control |= SOFT_RESET;    // soft reset mips
+#else
+    PERF->pll_control |= SOFT_RESET;    // soft reset mips
+#endif
+}
+
+
+int kerSysGetMacAddress( unsigned char *pucaMacAddr, unsigned long ulId )
+{
+    int nRet = 0;
+    PMAC_ADDR_INFO pMai = NULL;
+    PMAC_ADDR_INFO pMaiFreeNoId = NULL;
+    PMAC_ADDR_INFO pMaiFreeId = NULL;
+    unsigned long i = 0, ulIdxNoId = 0, ulIdxId = 0, shiftedIdx = 0;
+
+    for( i = 0, pMai = g_pNvramInfo->MacAddrs; i < g_pNvramInfo->ulNumMacAddrs;
+        i++, pMai++ )
+    {
+        if( ulId == pMai->ulId || ulId == MAC_ADDRESS_ANY )
+        {
+            /* This MAC address has been used by the caller in the past. */
+            memcpy( pucaMacAddr, g_pNvramInfo->ucaBaseMacAddr,
+                NVRAM_MAC_ADDRESS_LEN );
+            shiftedIdx = i;
+            pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] += (shiftedIdx << SHIFT_BITS);
+            pMai->chInUse = 1;
+            pMaiFreeNoId = pMaiFreeId = NULL;
+            break;
+        }
+        else
+            if( pMai->chInUse == 0 )
+            {
+                if( pMai->ulId == 0 && pMaiFreeNoId == NULL )
+                {
+                    /* This is an available MAC address that has never been
+                     * used.
+                     */
+                    pMaiFreeNoId = pMai;
+                    ulIdxNoId = i;
+                }
+                else
+                    if( pMai->ulId != 0 && pMaiFreeId == NULL )
+                    {
+                        /* This is an available MAC address that has been used
+                         * before.  Use addresses that have never been used
+                         * first, before using this one.
+                         */
+                        pMaiFreeId = pMai;
+                        ulIdxId = i;
+                    }
+            }
+    }
+
+    if( pMaiFreeNoId || pMaiFreeId )
+    {
+        /* An available MAC address was found. */
+        memcpy(pucaMacAddr, g_pNvramInfo->ucaBaseMacAddr,NVRAM_MAC_ADDRESS_LEN);
+        if( pMaiFreeNoId )
+        {
+            shiftedIdx = ulIdxNoId;
+            pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] += (shiftedIdx << SHIFT_BITS);
+            pMaiFreeNoId->ulId = ulId;
+            pMaiFreeNoId->chInUse = 1;
+        }
+        else
+        {
+            shiftedIdx = ulIdxId;
+            pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] += (shiftedIdx << SHIFT_BITS);
+            pMaiFreeId->ulId = ulId;
+            pMaiFreeId->chInUse = 1;
+        }
+    }
+    else
+        if( i == g_pNvramInfo->ulNumMacAddrs )
+            nRet = -EADDRNOTAVAIL;
+
+    return( nRet );
+} /* kerSysGetMacAddr */
+
+int kerSysReleaseMacAddress( unsigned char *pucaMacAddr )
+{
+    int nRet = -EINVAL;
+    unsigned long ulIdx = 0;
+    int idx = (pucaMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET] -
+        g_pNvramInfo->ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN - CHANGED_OCTET]);
+
+    // if overflow 255 (negitive), add 256 to have the correct index
+    if (idx < 0)
+        idx += 256;
+    ulIdx = (unsigned long) (idx >> SHIFT_BITS);
+
+    if( ulIdx < g_pNvramInfo->ulNumMacAddrs )
+    {
+        PMAC_ADDR_INFO pMai = &g_pNvramInfo->MacAddrs[ulIdx];
+        if( pMai->chInUse == 1 )
+        {
+            pMai->chInUse = 0;
+            nRet = 0;
+        }
+    }
+
+    return( nRet );
+} /* kerSysReleaseMacAddr */
+
+int kerSysGetSdramSize( void )
+{
+    return( (int) g_pNvramInfo->ulSdramSize );
+} /* kerSysGetSdramSize */
+
+
+void kerSysLedCtrl(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState)
+{
+    if (g_ledInitialized)
+      boardLedCtrl(ledName, ledState);
+}
+
+unsigned int kerSysMonitorPollHook( struct file *f, struct poll_table_struct *t)
+{
+    int mask = (*g_orig_fop_poll) (f, t);
+
+    if( g_wakeup_monitor == 1 && g_monitor_file == f )
+    {
+        /* If g_wakeup_monitor is non-0, the user mode application needs to
+         * return from a blocking select function.  Return POLLPRI which will
+         * cause the select to return with the exception descriptor set.
+         */
+        mask |= POLLPRI;
+        g_wakeup_monitor = 0;
+    }
+
+    return( mask );
+}
+
+/* Put the user mode application that monitors link state on a run queue. */
+void kerSysWakeupMonitorTask( void )
+{
+    g_wakeup_monitor = 1;
+    if( g_monitor_task )
+        wake_up_process( g_monitor_task );
+}
+
+//********************************************************************************************
+// misc. ioctl calls come to here. (flash, led, reset, kernel memory access, etc.)
+//********************************************************************************************
+static int board_ioctl( struct inode *inode, struct file *flip,
+                        unsigned int command, unsigned long arg )
+{
+    int ret = 0;
+    BOARD_IOCTL_PARMS ctrlParms;
+    unsigned char ucaMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    int allowedSize;
+
+    switch (command) 
+    {
+        case BOARD_IOCTL_FLASH_INIT:
+            // not used for now.  kerSysBcmImageInit();
+            break;
+
+
+        case BOARD_IOCTL_FLASH_WRITE:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0)
+            {
+                NVRAM_DATA SaveNvramData;
+                PNVRAM_DATA pNvramData = (PNVRAM_DATA) get_nvram_start_addr();
+
+                switch (ctrlParms.action)
+                {
+                    case SCRATCH_PAD:
+                        ret = kerSysScratchPadSet(ctrlParms.string, ctrlParms.buf, ctrlParms.offset);
+                        break;
+
+                    case PERSISTENT:
+                        ret = kerSysPersistentSet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+                
+                    case NVRAM:
+                        ret = kerSysNvRamSet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+
+                    case BCM_IMAGE_CFE:
+                        if( ctrlParms.strLen <= 0 || ctrlParms.strLen > FLASH45_LENGTH_BOOT_ROM )
+                        {
+                            printk("Illegal CFE size [%d]. Size allowed: [%d]\n",
+                                ctrlParms.strLen, FLASH45_LENGTH_BOOT_ROM);
+                            ret = -1;
+                            break;
+                        }
+
+                        // save NVRAM data into a local structure
+                        memcpy( &SaveNvramData, pNvramData, sizeof(NVRAM_DATA) );
+
+                        // set memory type field
+                        BpGetSdramSize( (unsigned long *) &ctrlParms.string[SDRAM_TYPE_ADDRESS_OFFSET] );
+
+                        ret = kerSysBcmImageSet(ctrlParms.offset, ctrlParms.string, ctrlParms.strLen);
+
+                        // if nvram is not valid, restore the current nvram settings
+                        if( BpSetBoardId( pNvramData->szBoardId ) != BP_SUCCESS &&
+                            *(unsigned long *) pNvramData == NVRAM_DATA_ID )
+                        {
+                            kerSysNvRamSet((char *) &SaveNvramData, sizeof(SaveNvramData), 0);
+                        }
+                        break;
+                        
+                    case BCM_IMAGE_FS:
+                        allowedSize = (int) flash_get_total_size() - \
+                            FLASH_RESERVED_AT_END - TAG_LEN - FLASH45_LENGTH_BOOT_ROM;
+                        if( ctrlParms.strLen <= 0 || ctrlParms.strLen > allowedSize)
+                        {
+                            printk("Illegal root file system size [%d]. Size allowed: [%d]\n",
+                                ctrlParms.strLen,  allowedSize);
+                            ret = -1;
+                            break;
+                        }
+                        ret = kerSysBcmImageSet(ctrlParms.offset, ctrlParms.string, ctrlParms.strLen);
+                        kerSysMipsSoftReset();
+                        break;
+
+                    case BCM_IMAGE_KERNEL:  // not used for now.
+                        break;
+                    case BCM_IMAGE_WHOLE:
+                        if(ctrlParms.strLen <= 0)
+                        {
+                            printk("Illegal flash image size [%d].\n", ctrlParms.strLen);
+                            ret = -1;
+                            break;
+                        }
+
+                        // save NVRAM data into a local structure
+                        memcpy( &SaveNvramData, pNvramData, sizeof(NVRAM_DATA) );
+
+                        ret = kerSysBcmImageSet(ctrlParms.offset, ctrlParms.string, ctrlParms.strLen);
+
+                        // if nvram is not valid, restore the current nvram settings
+                        if( BpSetBoardId( pNvramData->szBoardId ) != BP_SUCCESS &&
+                            *(unsigned long *) pNvramData == NVRAM_DATA_ID )
+                        {
+                            kerSysNvRamSet((char *) &SaveNvramData, sizeof(SaveNvramData), 0);
+                        }
+
+                        kerSysMipsSoftReset();
+                        break;
+
+                    default:
+                        ret = -EINVAL;
+                        printk("flash_ioctl_command: invalid command %d\n", ctrlParms.action);
+                        break;
+                }
+                ctrlParms.result = ret;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_FLASH_READ:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                switch (ctrlParms.action)
+                {
+                    case SCRATCH_PAD:
+                        ret = kerSysScratchPadGet(ctrlParms.string, ctrlParms.buf, ctrlParms.offset);
+                        break;
+
+                    case PERSISTENT:
+                        ret = kerSysPersistentGet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+
+                    case NVRAM:
+                        ret = kerSysNvRamGet(ctrlParms.string, ctrlParms.strLen, ctrlParms.offset);
+                        break;
+
+                    case FLASH_SIZE:
+                        ret = kerSysFlashSizeGet();
+                        break;
+
+                    default:
+                        ret = -EINVAL;
+                        printk("Not supported.  invalid command %d\n", ctrlParms.action);
+                        break;
+                }
+                ctrlParms.result = ret;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_GET_NR_PAGES:
+            ctrlParms.result = nr_free_pages() + get_page_cache_size();
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_DUMP_ADDR:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                dumpaddr( (unsigned char *) ctrlParms.string, ctrlParms.strLen );
+                ctrlParms.result = 0;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_SET_MEMORY:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                unsigned long  *pul = (unsigned long *)  ctrlParms.string;
+                unsigned short *pus = (unsigned short *) ctrlParms.string;
+                unsigned char  *puc = (unsigned char *)  ctrlParms.string;
+                switch( ctrlParms.strLen )
+                {
+                    case 4:
+                        *pul = (unsigned long) ctrlParms.offset;
+                        break;
+                    case 2:
+                        *pus = (unsigned short) ctrlParms.offset;
+                        break;
+                    case 1:
+                        *puc = (unsigned char) ctrlParms.offset;
+                        break;
+                }
+                dumpaddr( (unsigned char *) ctrlParms.string, sizeof(long) );
+                ctrlParms.result = 0;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+      
+        case BOARD_IOCTL_MIPS_SOFT_RESET:
+            kerSysMipsSoftReset();
+            break;
+
+        case BOARD_IOCTL_LED_CTRL:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+	            kerSysLedCtrl((BOARD_LED_NAME)ctrlParms.strLen, (BOARD_LED_STATE)ctrlParms.offset);
+	            ret = 0;
+	        }
+            break;
+
+        case BOARD_IOCTL_GET_ID:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg,
+                sizeof(ctrlParms)) == 0) 
+            {
+                if( ctrlParms.string )
+                {
+                    char *p = (char *) get_system_type();
+                    if( strlen(p) + 1 < ctrlParms.strLen )
+                        ctrlParms.strLen = strlen(p) + 1;
+                    __copy_to_user(ctrlParms.string, p, ctrlParms.strLen);
+                }
+
+                ctrlParms.result = 0;
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+            }
+            break;
+
+        case BOARD_IOCTL_GET_MAC_ADDRESS:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                ctrlParms.result = kerSysGetMacAddress( ucaMacAddr,
+                    ctrlParms.offset );
+
+                if( ctrlParms.result == 0 )
+                {
+                    __copy_to_user(ctrlParms.string, ucaMacAddr,
+                        sizeof(ucaMacAddr));
+                }
+
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_RELEASE_MAC_ADDRESS:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                if (copy_from_user((void*)ucaMacAddr, (void*)ctrlParms.string, \
+                     NVRAM_MAC_ADDRESS_LEN) == 0) 
+                {
+                    ctrlParms.result = kerSysReleaseMacAddress( ucaMacAddr );
+                }
+                else
+                {
+                    ctrlParms.result = -EACCES;
+                }
+
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_GET_PSI_SIZE:
+            ctrlParms.result = (int) g_pNvramInfo->ulPsiSize;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_GET_SDRAM_SIZE:
+            ctrlParms.result = (int) g_pNvramInfo->ulSdramSize;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_GET_BASE_MAC_ADDRESS:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) 
+            {
+                __copy_to_user(ctrlParms.string, g_pNvramInfo->ucaBaseMacAddr, NVRAM_MAC_ADDRESS_LEN);
+                ctrlParms.result = 0;
+
+                __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,
+                    sizeof(BOARD_IOCTL_PARMS));
+                ret = 0;
+            }
+            else
+                ret = -EFAULT;
+            break;
+
+        case BOARD_IOCTL_GET_CHIP_ID:
+            ctrlParms.result = (int) (PERF->RevID & 0xFFFF0000) >> 16;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+            ret = 0;
+            break;
+
+        case BOARD_IOCTL_GET_NUM_ENET: {
+            ETHERNET_MAC_INFO EnetInfos[BP_MAX_ENET_MACS];
+            int i, numeth = 0;
+            if (BpGetEthernetMacInfo(EnetInfos, BP_MAX_ENET_MACS) == BP_SUCCESS) {
+            for( i = 0; i < BP_MAX_ENET_MACS; i++) {
+                if (EnetInfos[i].ucPhyType != BP_ENET_NO_PHY) {
+                numeth++;
+                }
+            }
+            ctrlParms.result = numeth;
+            __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms,	 sizeof(BOARD_IOCTL_PARMS));   
+            ret = 0;
+            }
+	        else {
+	            ret = -EFAULT;
+	        }
+	        break;
+            }
+
+        case BOARD_IOCTL_GET_CFE_VER:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                char *vertag =  (char *)(FLASH_BASE + CFE_VERSION_OFFSET);
+                if (ctrlParms.strLen < CFE_VERSION_SIZE) {
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                    ret = -EFAULT;
+                }
+                else if (strncmp(vertag, "cfe-v", 5)) { // no tag info in flash
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                    ret = 0;
+                }
+                else {
+                    ctrlParms.result = 1;
+                    __copy_to_user(ctrlParms.string, vertag+CFE_VERSION_MARK_SIZE, CFE_VERSION_SIZE);
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));
+                    ret = 0;
+                }
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;
+
+        case BOARD_IOCTL_GET_ENET_CFG:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                ETHERNET_MAC_INFO EnetInfos[BP_MAX_ENET_MACS];
+                if (BpGetEthernetMacInfo(EnetInfos, BP_MAX_ENET_MACS) == BP_SUCCESS) {
+                    if (ctrlParms.strLen == sizeof(EnetInfos)) {
+                        __copy_to_user(ctrlParms.string, EnetInfos, sizeof(EnetInfos));
+                        ctrlParms.result = 0;
+                        __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                        ret = 0;
+                    } else
+	                    ret = -EFAULT;
+                }
+	            else {
+	                ret = -EFAULT;
+	            }
+	            break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+
+#if defined (WIRELESS)
+        case BOARD_IOCTL_GET_WLAN_ANT_INUSE:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                unsigned short antInUse = 0;
+                if (BpGetWirelessAntInUse(&antInUse) == BP_SUCCESS) {
+                    if (ctrlParms.strLen == sizeof(antInUse)) {
+                        __copy_to_user(ctrlParms.string, &antInUse, sizeof(antInUse));
+                        ctrlParms.result = 0;
+                        __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                        ret = 0;
+                    } else
+	                    ret = -EFAULT;
+                }
+	        else {
+	           ret = -EFAULT;
+	        }
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+#endif            
+        case BOARD_IOCTL_SET_TRIGGER_EVENT:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {            	
+            	BOARD_IOC *board_ioc = (BOARD_IOC *)flip->private_data;            	
+                ctrlParms.result = -EFAULT;
+                ret = -EFAULT;
+                if (ctrlParms.strLen == sizeof(unsigned long)) {                 	                    
+                    board_ioc->eventmask |= *((int*)ctrlParms.string);                    
+#if defined (WIRELESS)                    
+                    if((board_ioc->eventmask & SES_EVENTS)) {
+                        if(sesBtn_irq != BP_NOT_DEFINED) {
+                            BcmHalInterruptEnable(sesBtn_irq);
+                            ctrlParms.result = 0;
+                            ret = 0;
+                        }                                                
+                    } 
+#endif                                                
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));                        
+                }
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;                        
+
+        case BOARD_IOCTL_GET_TRIGGER_EVENT:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+            	BOARD_IOC *board_ioc = (BOARD_IOC *)flip->private_data;
+                if (ctrlParms.strLen == sizeof(unsigned long)) {
+                    __copy_to_user(ctrlParms.string, &board_ioc->eventmask, sizeof(unsigned long));
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                    ret = 0;
+                } else
+	            ret = -EFAULT;
+
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;                
+            
+        case BOARD_IOCTL_UNSET_TRIGGER_EVENT:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                if (ctrlParms.strLen == sizeof(unsigned long)) {
+                    BOARD_IOC *board_ioc = (BOARD_IOC *)flip->private_data;                	
+                    board_ioc->eventmask &= (~(*((int*)ctrlParms.string)));                  
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                    ret = 0;
+                } else
+	            ret = -EFAULT;
+
+	        break;
+            } 
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+#if defined (WIRELESS)
+        case BOARD_IOCTL_SET_SES_LED:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                if (ctrlParms.strLen == sizeof(int)) {
+                    sesLed_ctrl(*(int*)ctrlParms.string);
+                    ctrlParms.result = 0;
+                    __copy_to_user((BOARD_IOCTL_PARMS*)arg, &ctrlParms, sizeof(BOARD_IOCTL_PARMS));   
+                    ret = 0;
+                } else
+	            ret = -EFAULT;
+
+	        break;
+            }
+            else {
+                ret = -EFAULT;
+            }
+            break;            
+#endif                                                            
+
+        case BOARD_IOCTL_SET_MONITOR_FD:
+            if (copy_from_user((void*)&ctrlParms, (void*)arg, sizeof(ctrlParms)) == 0) {
+                int fput_needed = 0;
+
+                g_monitor_file = fget_light( ctrlParms.offset, &fput_needed );
+                if( g_monitor_file ) {
+                    /* Hook this file descriptor's poll function in order to set
+                     * the exception descriptor when there is a change in link
+                     * state.
+                     */
+                    g_monitor_task = current;
+                    g_orig_fop_poll = g_monitor_file->f_op->poll;
+                    g_monitor_file->f_op->poll = kerSysMonitorPollHook;
+                }
+            }
+            break;
+
+        case BOARD_IOCTL_WAKEUP_MONITOR_TASK:
+            kerSysWakeupMonitorTask();
+            break;
+
+        default:
+            ret = -EINVAL;
+            ctrlParms.result = 0;
+            printk("board_ioctl: invalid command %x, cmd %d .\n",command,_IOC_NR(command));
+            break;
+
+  } /* switch */
+
+  return (ret);
+
+} /* board_ioctl */
+
+/***************************************************************************
+ * SES Button ISR/GPIO/LED functions.
+ ***************************************************************************/
+#if defined (WIRELESS) 
+static irqreturn_t sesBtn_isr(int irq, void *dev_id, struct pt_regs *ptregs)
+{   
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96345_) || defined(CONFIG_BCM96345)
+    unsigned short gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned short *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96348_) || defined (CONFIG_BCM96348)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+
+    if( (sesBtn_gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(sesBtn_gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+#endif 
+    		
+    if (!(*gpio_reg & gpio_mask)){
+        wake_up_interruptible(&g_board_wait_queue);
+        return IRQ_RETVAL(1);
+    } else {
+        return IRQ_RETVAL(0);    	
+    }
+}
+
+static void __init sesBtn_mapGpio()
+{	
+    if( BpGetWirelessSesBtnGpio(&sesBtn_gpio) == BP_SUCCESS )
+    {
+        printk("SES: Button GPIO 0x%x is enabled\n", sesBtn_gpio);    
+    }
+}
+
+static void __init sesBtn_mapIntr(int context)
+{    	
+    if( BpGetWirelessSesExtIntr(&sesBtn_irq) == BP_SUCCESS )
+    {
+    	printk("SES: Button Interrupt 0x%x is enabled\n", sesBtn_irq);
+    }
+    else
+    	return;
+    	    
+    sesBtn_irq += INTERRUPT_ID_EXTERNAL_0;	
+    		
+    if (BcmHalMapInterrupt((FN_HANDLER)sesBtn_isr, context, sesBtn_irq)) {
+    	printk("SES: Interrupt mapping failed\n");
+    }    
+    BcmHalInterruptEnable(sesBtn_irq);
+}
+
+
+static unsigned int sesBtn_poll(struct file *file, struct poll_table_struct *wait)
+{
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96345_) || defined(CONFIG_BCM96345)
+    unsigned short gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned short *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96348_) || defined (CONFIG_BCM96348)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+
+    if( (sesBtn_gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(sesBtn_gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+#endif 
+    		
+    if (!(*gpio_reg & gpio_mask)){
+	return POLLIN;
+    }	
+    return 0;
+}
+
+static ssize_t sesBtn_read(struct file *file,  char __user *buffer, size_t count, loff_t *ppos)
+{
+    volatile unsigned int event=0;
+    ssize_t ret=0;	
+
+#if defined(_BCM96338_) || defined (CONFIG_BCM96338)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96345_) || defined (CONFIG_BCM96345)
+    unsigned short gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned short *gpio_reg = &GPIO->GPIOio;
+#endif
+#if defined(_BCM96348_) || defined (CONFIG_BCM96348)
+    unsigned long gpio_mask = GPIO_NUM_TO_MASK(sesBtn_gpio);
+    volatile unsigned long *gpio_reg = &GPIO->GPIOio;
+    
+    if( (sesBtn_gpio & ~BP_ACTIVE_MASK) >= 32 )
+    {
+        gpio_mask = GPIO_NUM_TO_MASK_HIGH(sesBtn_gpio);
+        gpio_reg = &GPIO->GPIOio_high;
+    }
+#endif 
+
+    if(*gpio_reg & gpio_mask){
+	BcmHalInterruptEnable(sesBtn_irq);		
+	return ret;
+    }	
+    event = SES_EVENTS;
+    __copy_to_user((char*)buffer, (char*)&event, sizeof(event));	
+    BcmHalInterruptEnable(sesBtn_irq);	
+    count -= sizeof(event);
+    buffer += sizeof(event);
+    ret += sizeof(event);	
+    return ret;	
+}
+
+static void __init sesLed_mapGpio()
+{	
+    if( BpGetWirelessSesBtnGpio(&sesLed_gpio) == BP_SUCCESS )
+    {
+        printk("SES: LED GPIO 0x%x is enabled\n", sesBtn_gpio);    
+    }
+}
+
+static void sesLed_ctrl(int action)
+{
+
+    //char status = ((action >> 8) & 0xff); /* extract status */
+    //char event = ((action >> 16) & 0xff); /* extract event */        
+    //char blinktype = ((action >> 24) & 0xff); /* extract blink type for SES_LED_BLINK  */
+    
+    BOARD_LED_STATE led;
+    
+    if(sesLed_gpio == BP_NOT_DEFINED)
+        return;
+    	
+    action &= 0xff; /* extract led */
+
+    //printk("blinktype=%d, event=%d, status=%d\n",(int)blinktype, (int)event, (int)status);
+            	
+    switch (action) 
+    {
+        case SES_LED_ON:
+            //printk("SES: led on\n");
+            led = kLedStateOn;                                          
+            break;
+        case SES_LED_BLINK:
+            //printk("SES: led blink\n");
+            led = kLedStateSlowBlinkContinues;           		
+            break;
+        case SES_LED_OFF:
+            default:
+            //printk("SES: led off\n");
+            led = kLedStateOff;  						
+    }	
+    
+    kerSysLedCtrl(kLedSes, led);
+}
+
+static void __init ses_board_init()
+{
+    sesBtn_mapGpio();
+    sesBtn_mapIntr(0);
+    sesLed_mapGpio();
+}
+static void __exit ses_board_deinit()
+{
+    if(sesBtn_irq)
+        BcmHalInterruptDisable(sesBtn_irq);
+}
+#endif
+
+/***************************************************************************
+ * Dying gasp ISR and functions.
+ ***************************************************************************/
+#define KERSYS_DBG	printk
+
+#if defined(CONFIG_BCM96345)
+#define	CYCLE_PER_US	70
+#elif defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)
+/* The BCM6348 cycles per microsecond is really variable since the BCM6348
+ * MIPS speed can vary depending on the PLL settings.  However, an appoximate
+ * value of 120 will still work OK for the test being done.
+ */
+#define	CYCLE_PER_US	120
+#endif
+#define	DG_GLITCH_TO	(100*CYCLE_PER_US)
+ 
+static void __init kerSysDyingGaspMapIntr()
+{
+    unsigned long ulIntr;
+    	
+#if defined(CONFIG_BCM96348) || defined(_BCM96348_) || defined(CONFIG_BCM96338) || defined(_BCM96338_)
+    if( BpGetAdslDyingGaspExtIntr( &ulIntr ) == BP_SUCCESS ) {
+		BcmHalMapInterrupt((FN_HANDLER)kerSysDyingGaspIsr, 0, INTERRUPT_ID_DG);
+		BcmHalInterruptEnable( INTERRUPT_ID_DG );
+    }
+#elif defined(CONFIG_BCM96345) || defined(_BCM96345_)
+    if( BpGetAdslDyingGaspExtIntr( &ulIntr ) == BP_SUCCESS ) {
+        ulIntr += INTERRUPT_ID_EXTERNAL_0;
+        BcmHalMapInterrupt((FN_HANDLER)kerSysDyingGaspIsr, 0, ulIntr);
+        BcmHalInterruptEnable( ulIntr );
+    }
+#endif
+
+} 
+
+void kerSysSetWdTimer(ulong timeUs)
+{
+	TIMER->WatchDogDefCount = timeUs * (FPERIPH/1000000);
+	TIMER->WatchDogCtl = 0xFF00;
+	TIMER->WatchDogCtl = 0x00FF;
+}
+
+ulong kerSysGetCycleCount(void)
+{
+    ulong cnt; 
+#ifdef _WIN32_WCE
+    cnt = 0;
+#else
+    __asm volatile("mfc0 %0, $9":"=d"(cnt));
+#endif
+    return(cnt); 
+}
+
+static Bool kerSysDyingGaspCheckPowerLoss(void)
+{
+    ulong clk0;
+    ulong ulIntr;
+
+    ulIntr = 0;
+    clk0 = kerSysGetCycleCount();
+
+    UART->Data = 'D';
+    UART->Data = '%';
+    UART->Data = 'G';
+
+#if defined(CONFIG_BCM96345)
+    BpGetAdslDyingGaspExtIntr( &ulIntr );
+
+    do {
+        ulong clk1;
+        
+        clk1 = kerSysGetCycleCount();		/* time cleared */
+	/* wait a little to get new reading */
+        while ((kerSysGetCycleCount()-clk1) < CYCLE_PER_US*2)
+            ;
+    } while ((0 == (PERF->ExtIrqCfg & (1 << (ulIntr + EI_STATUS_SHFT)))) && ((kerSysGetCycleCount() - clk0) < DG_GLITCH_TO));
+
+    if (PERF->ExtIrqCfg & (1 << (ulIntr + EI_STATUS_SHFT))) {	/* power glitch */
+        BcmHalInterruptEnable( ulIntr + INTERRUPT_ID_EXTERNAL_0);
+        KERSYS_DBG(" - Power glitch detected. Duration: %ld us\n", (kerSysGetCycleCount() - clk0)/CYCLE_PER_US);
+        return 0;
+    }
+#elif (defined(CONFIG_BCM96348) || defined(CONFIG_BCM96338)) && !defined(VXWORKS)
+    do {
+        ulong clk1;
+        
+        clk1 = kerSysGetCycleCount();		/* time cleared */
+	/* wait a little to get new reading */
+        while ((kerSysGetCycleCount()-clk1) < CYCLE_PER_US*2)
+            ;
+     } while ((PERF->IrqStatus & (1 << (INTERRUPT_ID_DG - INTERNAL_ISR_TABLE_OFFSET))) && ((kerSysGetCycleCount() - clk0) < DG_GLITCH_TO));
+
+    if (!(PERF->IrqStatus & (1 << (INTERRUPT_ID_DG - INTERNAL_ISR_TABLE_OFFSET)))) {
+        BcmHalInterruptEnable( INTERRUPT_ID_DG );
+        KERSYS_DBG(" - Power glitch detected. Duration: %ld us\n", (kerSysGetCycleCount() - clk0)/CYCLE_PER_US);
+        return 0;
+    }
+#endif
+    return 1;
+}
+
+static void kerSysDyingGaspShutdown( void )
+{
+    kerSysSetWdTimer(1000000);
+#if defined(CONFIG_BCM96345)
+    PERF->blkEnables &= ~(EMAC_CLK_EN | USB_CLK_EN | CPU_CLK_EN);
+#elif defined(CONFIG_BCM96348)
+    PERF->blkEnables &= ~(EMAC_CLK_EN | USBS_CLK_EN | USBH_CLK_EN | SAR_CLK_EN);
+#endif
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+static irqreturn_t kerSysDyingGaspIsr(int irq, void * dev_id, struct pt_regs * regs)
+#else
+static unsigned int kerSysDyingGaspIsr(void)
+#endif
+{	
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp, *dsl = NULL;	
+
+    if (kerSysDyingGaspCheckPowerLoss()) {        
+
+        /* first to turn off everything other than dsl */        
+        list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+            tmp = list_entry(pos, CB_DGASP_LIST, list);
+    	    if(strncmp(tmp->name, "dsl", 3)) {
+    	        (tmp->cb_dgasp_fn)(tmp->context); 
+    	    }else {
+    		dsl = tmp;    		    	
+    	    }       
+        }  
+        
+        /* now send dgasp */
+        if(dsl)
+            (dsl->cb_dgasp_fn)(dsl->context); 
+
+        /* reset and shutdown system */
+        kerSysDyingGaspShutdown();
+    }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+return( IRQ_HANDLED );
+#else
+    return( 1 );
+#endif
+}
+
+static void __init kerSysInitDyingGaspHandler( void )
+{
+    CB_DGASP_LIST *new_node;
+
+    if( g_cb_dgasp_list_head != NULL) {
+        printk("Error: kerSysInitDyingGaspHandler: list head is not null\n");
+        return;	
+    }
+    new_node= (CB_DGASP_LIST *)kmalloc(sizeof(CB_DGASP_LIST), GFP_KERNEL);
+    memset(new_node, 0x00, sizeof(CB_DGASP_LIST));
+    INIT_LIST_HEAD(&new_node->list);    
+    g_cb_dgasp_list_head = new_node; 
+		
+} /* kerSysInitDyingGaspHandler */
+
+static void __exit kerSysDeinitDyingGaspHandler( void )
+{
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp; 
+     	
+    if(g_cb_dgasp_list_head == NULL)
+        return;
+        
+    list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+    	tmp = list_entry(pos, CB_DGASP_LIST, list);
+        list_del(pos);
+	kfree(tmp);
+    }       
+
+    kfree(g_cb_dgasp_list_head);	
+    g_cb_dgasp_list_head = NULL;
+    
+} /* kerSysDeinitDyingGaspHandler */
+
+void kerSysRegisterDyingGaspHandler(char *devname, void *cbfn, void *context)
+{
+    CB_DGASP_LIST *new_node;
+
+    if( g_cb_dgasp_list_head == NULL) {
+        printk("Error: kerSysRegisterDyingGaspHandler: list head is null\n");	
+        return;    
+    }
+    
+    if( devname == NULL || cbfn == NULL ) {
+        printk("Error: kerSysRegisterDyingGaspHandler: register info not enough (%s,%x,%x)\n", devname, (unsigned int)cbfn, (unsigned int)context);	    	
+        return;
+    }
+       
+    new_node= (CB_DGASP_LIST *)kmalloc(sizeof(CB_DGASP_LIST), GFP_KERNEL);
+    memset(new_node, 0x00, sizeof(CB_DGASP_LIST));    
+    INIT_LIST_HEAD(&new_node->list);
+    strncpy(new_node->name, devname, IFNAMSIZ);
+    new_node->cb_dgasp_fn = (cb_dgasp_t)cbfn;
+    new_node->context = context;
+    list_add(&new_node->list, &g_cb_dgasp_list_head->list);
+    
+    printk("dgasp: kerSysRegisterDyingGaspHandler: %s registered \n", devname);
+        	
+} /* kerSysRegisterDyingGaspHandler */
+
+void kerSysDeregisterDyingGaspHandler(char *devname)
+{
+    struct list_head *pos;
+    CB_DGASP_LIST *tmp;    
+    
+    if(g_cb_dgasp_list_head == NULL) {
+        printk("Error: kerSysDeregisterDyingGaspHandler: list head is null\n");
+        return;	
+    }
+
+    if(devname == NULL) {
+        printk("Error: kerSysDeregisterDyingGaspHandler: devname is null\n");
+        return;	
+    }
+    
+    printk("kerSysDeregisterDyingGaspHandler: %s is deregistering\n", devname);
+
+    list_for_each(pos, &g_cb_dgasp_list_head->list) {    	
+    	tmp = list_entry(pos, CB_DGASP_LIST, list);
+    	if(!strcmp(tmp->name, devname)) {
+            list_del(pos);
+	    kfree(tmp);
+	    printk("kerSysDeregisterDyingGaspHandler: %s is deregistered\n", devname);
+	    return;
+	}
+    }	
+    printk("kerSysDeregisterDyingGaspHandler: %s not (de)registered\n", devname);
+	
+} /* kerSysDeregisterDyingGaspHandler */
+
+/***************************************************************************
+ * MACRO to call driver initialization and cleanup functions.
+ ***************************************************************************/
+module_init( brcm_board_init );
+module_exit( brcm_board_cleanup );
+
+EXPORT_SYMBOL(kerSysNvRamGet);
+EXPORT_SYMBOL(dumpaddr);
+EXPORT_SYMBOL(kerSysGetMacAddress);
+EXPORT_SYMBOL(kerSysReleaseMacAddress);
+EXPORT_SYMBOL(kerSysGetSdramSize);
+EXPORT_SYMBOL(kerSysLedCtrl);
+EXPORT_SYMBOL(kerSysLedRegisterHwHandler);
+EXPORT_SYMBOL(BpGetBoardIds);
+EXPORT_SYMBOL(BpGetSdramSize);
+EXPORT_SYMBOL(BpGetPsiSize);
+EXPORT_SYMBOL(BpGetEthernetMacInfo);
+EXPORT_SYMBOL(BpGetRj11InnerOuterPairGpios);
+EXPORT_SYMBOL(BpGetPressAndHoldResetGpio);
+EXPORT_SYMBOL(BpGetVoipResetGpio);
+EXPORT_SYMBOL(BpGetVoipIntrGpio);
+EXPORT_SYMBOL(BpGetPcmciaResetGpio);
+EXPORT_SYMBOL(BpGetRtsCtsUartGpios);
+EXPORT_SYMBOL(BpGetAdslLedGpio);
+EXPORT_SYMBOL(BpGetAdslFailLedGpio);
+EXPORT_SYMBOL(BpGetWirelessLedGpio);
+EXPORT_SYMBOL(BpGetUsbLedGpio);
+EXPORT_SYMBOL(BpGetHpnaLedGpio);
+EXPORT_SYMBOL(BpGetWanDataLedGpio);
+EXPORT_SYMBOL(BpGetPppLedGpio);
+EXPORT_SYMBOL(BpGetPppFailLedGpio);
+EXPORT_SYMBOL(BpGetVoipLedGpio);
+EXPORT_SYMBOL(BpGetWirelessExtIntr);
+EXPORT_SYMBOL(BpGetAdslDyingGaspExtIntr);
+EXPORT_SYMBOL(BpGetVoipExtIntr);
+EXPORT_SYMBOL(BpGetHpnaExtIntr);
+EXPORT_SYMBOL(BpGetHpnaChipSelect);
+EXPORT_SYMBOL(BpGetVoipChipSelect);
+EXPORT_SYMBOL(BpGetWirelessSesBtnGpio);
+EXPORT_SYMBOL(BpGetWirelessSesExtIntr);
+EXPORT_SYMBOL(BpGetWirelessSesLedGpio);
+EXPORT_SYMBOL(kerSysRegisterDyingGaspHandler);
+EXPORT_SYMBOL(kerSysDeregisterDyingGaspHandler);
+EXPORT_SYMBOL(kerSysGetCycleCount);
+EXPORT_SYMBOL(kerSysSetWdTimer);
+EXPORT_SYMBOL(kerSysWakeupMonitorTask);
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,692 @@
+/************************************************************************/
+/*                                                                      */
+/*  AMD CFI Enabled Flash Memory Drivers                                */
+/*  File name: CFIFLASH.C                                               */
+/*  Revision:  1.0  5/07/98                                             */
+/*                                                                      */
+/* Copyright (c) 1998 ADVANCED MICRO DEVICES, INC. All Rights Reserved. */
+/* This software is unpublished and contains the trade secrets and      */
+/* confidential proprietary information of AMD. Unless otherwise        */
+/* provided in the Software Agreement associated herewith, it is        */
+/* licensed in confidence "AS IS" and is not to be reproduced in whole  */
+/* or part by any means except for backup. Use, duplication, or         */
+/* disclosure by the Government is subject to the restrictions in       */
+/* paragraph (b) (3) (B) of the Rights in Technical Data and Computer   */
+/* Software clause in DFAR 52.227-7013 (a) (Oct 1988).                  */
+/* Software owned by                                                    */
+/* Advanced Micro Devices, Inc.,                                        */
+/* One AMD Place,                                                       */
+/* P.O. Box 3453                                                        */
+/* Sunnyvale, CA 94088-3453.                                            */
+/************************************************************************/
+/*  This software constitutes a basic shell of source code for          */
+/*  programming all AMD Flash components. AMD                           */
+/*  will not be responsible for misuse or illegal use of this           */
+/*  software for devices not supported herein. AMD is providing         */
+/*  this source code "AS IS" and will not be responsible for            */
+/*  issues arising from incorrect user implementation of the            */
+/*  source code herein. It is the user's responsibility to              */
+/*  properly design-in this source code.                                */
+/*                                                                      */ 
+/************************************************************************/                        
+#ifdef _CFE_                                                
+#include "lib_types.h"
+#include "lib_printf.h"
+#include "lib_string.h"
+#include "cfe_timer.h"
+#define printk  printf
+#else       // linux
+#include <linux/param.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#endif
+
+#include "cfiflash.h"
+
+static int flash_wait(WORD sector, int offset, UINT16 data);
+static UINT16 flash_get_device_id(void);
+static int flash_get_cfi(struct cfi_query *query, UINT16 *cfi_struct, int flashFamily);
+static int flash_write(WORD sector, int offset, byte *buf, int nbytes);
+static void flash_command(int command, WORD sector, int offset, UINT16 data);
+
+/*********************************************************************/
+/* 'meminfo' should be a pointer, but most C compilers will not      */
+/* allocate static storage for a pointer without calling             */
+/* non-portable functions such as 'new'.  We also want to avoid      */
+/* the overhead of passing this pointer for every driver call.       */
+/* Systems with limited heap space will need to do this.             */
+/*********************************************************************/
+struct flashinfo meminfo; /* Flash information structure */
+static int flashFamily = FLASH_UNDEFINED;
+static int totalSize = 0;
+static struct cfi_query query;
+
+static UINT16 cfi_data_struct_29W160[] = {
+    0x0020, 0x0049, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0x0051, 0x0052, 0x0059, 0x0002, 0x0000, 0x0040, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0027, 0x0036, 0x0000, 0x0000, 0x0004,
+    0x0000, 0x000a, 0x0000, 0x0004, 0x0000, 0x0003, 0x0000, 0x0015,
+    0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0000, 0x0000, 0x0040,
+    0x0000, 0x0001, 0x0000, 0x0020, 0x0000, 0x0000, 0x0000, 0x0080,
+    0x0000, 0x001e, 0x0000, 0x0000, 0x0001, 0xffff, 0xffff, 0xffff,
+    0x0050, 0x0052, 0x0049, 0x0031, 0x0030, 0x0000, 0x0002, 0x0001,
+    0x0001, 0x0004, 0x0000, 0x0000, 0x0000, 0xffff, 0xffff, 0x0002,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0x0888, 0x252b, 0x8c84, 0x7dbc, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
+    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff
+};
+
+
+/*********************************************************************/
+/* Init_flash is used to build a sector table from the information   */
+/* provided through the CFI query.  This information is translated   */
+/* from erase_block information to base:offset information for each  */
+/* individual sector. This information is then stored in the meminfo */
+/* structure, and used throughout the driver to access sector        */
+/* information.                                                      */
+/*                                                                   */
+/* This is more efficient than deriving the sector base:offset       */
+/* information every time the memory map switches (since on the      */
+/* development platform can only map 64k at a time).  If the entire  */
+/* flash memory array can be mapped in, then the addition static     */
+/* allocation for the meminfo structure can be eliminated, but the   */
+/* drivers will have to be re-written.                               */
+/*                                                                   */
+/* The meminfo struct occupies 653 bytes of heap space, depending    */
+/* on the value of the define MAXSECTORS.  Adjust to suit            */
+/* application                                                       */ 
+/*********************************************************************/
+byte flash_init(void)
+{
+    int i=0, j=0, count=0;
+    int basecount=0L;
+    UINT16 device_id;
+    int flipCFIGeometry = FALSE;
+
+    /* First, assume
+    * a single 8k sector for sector 0.  This is to allow
+    * the system to perform memory mapping to the device,
+    * even though the actual physical layout is unknown.
+    * Once mapped in, the CFI query will produce all
+    * relevant information.
+    */
+    meminfo.addr = 0L;
+    meminfo.areg = 0;
+    meminfo.nsect = 1;
+    meminfo.bank1start = 0;
+    meminfo.bank2start = 0;
+    
+    meminfo.sec[0].size = 8192;
+    meminfo.sec[0].base = 0x00000;
+    meminfo.sec[0].bank = 1;
+        
+    flash_command(FLASH_RESET, 0, 0, 0);
+
+    device_id = flash_get_device_id();
+
+    switch (device_id) {
+        case ID_I28F160C3B:
+        case ID_I28F320C3B:
+        case ID_I28F160C3T:
+        case ID_I28F320C3T:
+            flashFamily = FLASH_INTEL;
+            break;
+        case ID_AM29DL800B:
+        case ID_AM29LV800B:
+        case ID_AM29LV400B:   
+        case ID_AM29LV160B:
+        case ID_AM29LV320B:
+        case ID_MX29LV320AB:
+        case ID_AM29LV320MB:
+        case ID_AM29DL800T:
+        case ID_AM29LV800T:
+        case ID_AM29LV160T:
+        case ID_AM29LV320T:
+        case ID_MX29LV320AT:
+        case ID_AM29LV320MT:
+            flashFamily = FLASH_AMD;
+            break;
+        case ID_SST39VF1601:
+		case ID_SST39VF3201:
+            flashFamily = FLASH_SST;
+            break;
+        default:
+            printk("Flash memory not supported!  Device id = %x\n", device_id);
+            return -1;           
+    }
+
+    if (flash_get_cfi(&query, 0, flashFamily) == -1) {
+        switch(device_id) {
+        case ID_AM29LV160T:
+        case ID_AM29LV160B:
+            flash_get_cfi(&query, cfi_data_struct_29W160, flashFamily);
+            break;
+        default:
+            printk("CFI data structure not found. Device id = %x\n", device_id);
+            return -1;           
+        }
+    }
+
+    // need to determine if it top or bottom boot here
+    switch (device_id)
+    {
+        case ID_AM29DL800B:
+        case ID_AM29LV800B:
+        case ID_AM29LV400B:   
+        case ID_AM29LV160B:
+        case ID_AM29LV320B:
+        case ID_MX29LV320AB:
+        case ID_AM29LV320MB:
+        case ID_I28F160C3B:
+        case ID_I28F320C3B:
+        case ID_I28F160C3T:
+        case ID_I28F320C3T:
+		case ID_SST39VF1601:
+		case ID_SST39VF3201:
+            flipCFIGeometry = FALSE;
+            break;
+        case ID_AM29DL800T:
+        case ID_AM29LV800T:
+        case ID_AM29LV160T:
+        case ID_AM29LV320T:
+        case ID_MX29LV320AT:
+        case ID_AM29LV320MT:
+            flipCFIGeometry = TRUE;
+            break;
+        default:
+            printk("Flash memory not supported!  Device id = %x\n", device_id);
+            return -1;           
+    }
+
+    count=0;basecount=0L;
+
+    if (!flipCFIGeometry)
+    {
+       for (i=0; i<query.num_erase_blocks; i++) {
+            for(j=0; j<query.erase_block[i].num_sectors; j++) {
+                meminfo.sec[count].size = (int) query.erase_block[i].sector_size;
+                meminfo.sec[count].base = (int) basecount;
+                basecount += (int) query.erase_block[i].sector_size;
+                count++;
+            }
+        }
+    }
+    else
+    {
+        for (i = (query.num_erase_blocks - 1); i >= 0; i--) {
+            for(j=0; j<query.erase_block[i].num_sectors; j++) {
+                meminfo.sec[count].size = (int) query.erase_block[i].sector_size;
+                meminfo.sec[count].base = (int) basecount;
+                basecount += (int) query.erase_block[i].sector_size;
+				count++;
+            }
+        }
+    }
+
+    meminfo.nsect = count;
+    totalSize = meminfo.sec[count-1].base + meminfo.sec[count-1].size;
+    return (0);
+}
+
+/*********************************************************************/
+/* Flash_sector_erase_int() is identical to flash_sector_erase(),    */
+/* except it will wait until the erase is completed before returning */
+/* control to the calling function.  This can be used in cases which */
+/* require the program to hold until a sector is erased, without     */
+/* adding the wait check external to this function.                  */
+/*********************************************************************/
+byte flash_sector_erase_int(WORD sector)
+{
+    int i;
+
+    for( i = 0; i < 3; i++ ) {
+        flash_command(FLASH_SERASE, sector, 0, 0);
+        if (flash_wait(sector, 0, 0xffff) == STATUS_READY)
+            break;
+    }
+
+    return(1);
+}
+
+/*********************************************************************/
+/* flash_read_buf() reads buffer of data from the specified          */
+/* offset from the sector parameter.                                 */
+/*********************************************************************/
+int flash_read_buf(WORD sector, int offset,
+                        byte *buffer, int numbytes)
+{
+    byte *fwp;
+
+    fwp = (byte *)flash_get_memptr(sector);
+
+	while (numbytes) {
+		*buffer++ = *(fwp + offset);
+		numbytes--;
+		fwp++;
+    }
+
+    return (1);
+}
+
+/*********************************************************************/
+/* flash_write_buf() utilizes                                        */
+/* the unlock bypass mode of the flash device.  This can remove      */
+/* significant overhead from the bulk programming operation, and     */
+/* when programming bulk data a sizeable performance increase can be */
+/* observed.                                                         */
+/*********************************************************************/
+int flash_write_buf(WORD sector, int offset, byte *buffer, int numbytes)
+{
+    int ret = -1;
+    int i;
+    unsigned char *p = flash_get_memptr(sector) + offset;
+
+    /* After writing the flash block, compare the contents to the source
+     * buffer.  Try to write the sector successfully up to three times.
+     */
+    for( i = 0; i < 3; i++ ) {
+        ret = flash_write(sector, offset, buffer, numbytes);
+        if( !memcmp( p, buffer, numbytes ) )
+            break;
+        /* Erase and try again */
+        flash_sector_erase_int(sector);
+        ret = -1;
+    }
+
+    if( ret == -1 )
+        printk( "Flash write error.  Verify failed\n" );
+
+    return( ret );
+}
+
+/*********************************************************************/
+/* Usefull funtion to return the number of sectors in the device.    */
+/* Can be used for functions which need to loop among all the        */
+/* sectors, or wish to know the number of the last sector.           */
+/*********************************************************************/
+int flash_get_numsectors(void)
+{
+    return meminfo.nsect;
+}
+
+/*********************************************************************/
+/* flash_get_sector_size() is provided for cases in which the size   */
+/* of a sector is required by a host application.  The sector size   */
+/* (in bytes) is returned in the data location pointed to by the     */
+/* 'size' parameter.                                                 */
+/*********************************************************************/
+int flash_get_sector_size(WORD sector)
+{
+    return meminfo.sec[sector].size;
+}
+
+/*********************************************************************/
+/* The purpose of flash_get_memptr() is to return a memory pointer   */
+/* which points to the beginning of memory space allocated for the   */
+/* flash.  All function pointers are then referenced from this       */
+/* pointer. 							     */
+/*                                                                   */
+/* Different systems will implement this in different ways:          */
+/* possibilities include:                                            */
+/*  - A direct memory pointer                                        */
+/*  - A pointer to a memory map                                      */
+/*  - A pointer to a hardware port from which the linear             */
+/*    address is translated                                          */
+/*  - Output of an MMU function / service                            */
+/*                                                                   */
+/* Also note that this function expects the pointer to a specific    */
+/* sector of the device.  This can be provided by dereferencing      */
+/* the pointer from a translated offset of the sector from a         */
+/* global base pointer (e.g. flashptr = base_pointer + sector_offset)*/
+/*                                                                   */
+/* Important: Many AMD flash devices need both bank and or sector    */
+/* address bits to be correctly set (bank address bits are A18-A16,  */
+/* and sector address bits are A18-A12, or A12-A15).  Flash parts    */
+/* which do not need these bits will ignore them, so it is safe to   */
+/* assume that every part will require these bits to be set.         */
+/*********************************************************************/
+unsigned char *flash_get_memptr(WORD sector)
+{
+	unsigned char *memptr = (unsigned char*)(FLASH_BASE_ADDR_REG + meminfo.sec[sector].base);
+
+	return (memptr);
+}
+
+/*********************************************************************/
+/* The purpose of flash_get_blk() is to return a the block number    */
+/* for a given memory address.                                       */
+/*********************************************************************/
+int flash_get_blk(int addr)
+{
+    int blk_start, i;
+    int last_blk = flash_get_numsectors();
+    int relative_addr = addr - (int) FLASH_BASE_ADDR_REG;
+
+    for(blk_start=0, i=0; i < relative_addr && blk_start < last_blk; blk_start++)
+        i += flash_get_sector_size(blk_start);
+
+    if( i > relative_addr )
+    {
+        blk_start--;        // last blk, dec by 1
+    }
+    else
+        if( blk_start == last_blk )
+        {
+            printk("Address is too big.\n");
+            blk_start = -1;
+        }
+
+    return( blk_start );
+}
+
+/************************************************************************/
+/* The purpose of flash_get_total_size() is to return the total size of */
+/* the flash                                                            */
+/************************************************************************/
+int flash_get_total_size()
+{
+    return totalSize;
+}
+
+/*********************************************************************/
+/* Flash_command() is the main driver function.  It performs         */
+/* every possible command available to AMD B revision                */
+/* flash parts. Note that this command is not used directly, but     */
+/* rather called through the API wrapper functions provided below.   */
+/*********************************************************************/
+static void flash_command(int command, WORD sector, int offset, UINT16 data)
+{
+    volatile UINT16 *flashptr;
+    volatile UINT16 *flashbase;
+
+    flashptr = (UINT16 *) flash_get_memptr(sector);
+    flashbase = (UINT16 *) flash_get_memptr(0);
+    
+    switch (flashFamily) {
+    case FLASH_UNDEFINED:
+        /* These commands should work for AMD, Intel and SST flashes */
+        switch (command) {
+        case FLASH_RESET:
+            flashptr[0] = 0xF0;
+            flashptr[0] = 0xFF;
+            break;
+        case FLASH_READ_ID:
+			flashptr[0x5555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AAA] = 0x55;       /* unlock 2 */
+            flashptr[0x5555] = 0x90;
+            break;
+        default:
+            break;
+        }
+        break;
+    case FLASH_AMD:
+        switch (command) {
+        case FLASH_RESET:
+            flashptr[0] = 0xF0;
+            break;
+        case FLASH_READ_ID:
+            flashptr[0x555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AA] = 0x55;       /* unlock 2 */
+            flashptr[0x555] = 0x90;
+            break;
+        case FLASH_CFIQUERY:
+            flashptr[0x55] = 0x98;
+            break;
+        case FLASH_UB:
+            flashptr[0x555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AA] = 0x55;       /* unlock 2 */
+            flashptr[0x555] = 0x20;
+            break;
+        case FLASH_PROG:
+            flashptr[0] = 0xA0;
+            flashptr[offset/2] = data;
+            break;
+        case FLASH_UBRESET:
+            flashptr[0] = 0x90;
+            flashptr[0] = 0x00;
+            break;
+        case FLASH_SERASE:
+            flashptr[0x555] = 0xAA;       /* unlock 1 */
+            flashptr[0x2AA] = 0x55;       /* unlock 2 */
+            flashptr[0x555] = 0x80;
+            flashptr[0x555] = 0xAA;
+            flashptr[0x2AA] = 0x55;
+            flashptr[0] = 0x30;
+            break;
+        default:
+            break;
+        }
+        break;
+    case FLASH_INTEL:
+        switch (command) {
+        case FLASH_RESET:
+            flashptr[0] = 0xFF;
+            break;
+        case FLASH_READ_ID:
+            flashptr[0] = 0x90;
+            break;
+        case FLASH_CFIQUERY:
+            flashptr[0] = 0x98;
+            break;
+        case FLASH_PROG:
+            flashptr[0] = 0x40;
+            flashptr[offset/2] = data;
+            break;
+        case FLASH_SERASE:
+            flashptr[0] = 0x60;
+            flashptr[0] = 0xD0;
+            flashptr[0] = 0x20;
+            flashptr[0] = 0xD0;
+            break;
+        default:
+            break;
+        }
+        break;
+    case FLASH_SST:
+        switch (command) {
+        case FLASH_RESET:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0xf0;
+            break;
+        case FLASH_READ_ID:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0x90;
+            break;
+        case FLASH_CFIQUERY:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0x98;
+            break;
+        case FLASH_UB:
+            break;
+        case FLASH_PROG:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0xa0;
+            flashptr[offset/2] = data;
+            break;
+        case FLASH_UBRESET:
+            break;
+        case FLASH_SERASE:
+            flashbase[0x5555] = 0xAA;       /* unlock 1 */
+            flashbase[0x2AAA] = 0x55;       /* unlock 2 */
+            flashbase[0x5555] = 0x80;
+            flashbase[0x5555] = 0xAA;
+            flashbase[0x2AAA] = 0x55;
+            flashptr[0] = 0x30;
+            break;
+        default:
+            break;
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+/*********************************************************************/
+/* flash_write extends the functionality of flash_program() by       */
+/* providing an faster way to program multiple data words, without   */
+/* needing the function overhead of looping algorithms which         */
+/* program word by word.  This function utilizes fast pointers       */
+/* to quickly loop through bulk data.                                */
+/*********************************************************************/
+static int flash_write(WORD sector, int offset, byte *buf, int nbytes)
+{
+    UINT16 *src;
+    src = (UINT16 *)buf;
+
+    if ((nbytes | offset) & 1) {
+        return -1;
+    }
+
+    flash_command(FLASH_UB, 0, 0, 0);
+    while (nbytes > 0) {
+        flash_command(FLASH_PROG, sector, offset, *src);
+        if (flash_wait(sector, offset, *src) != STATUS_READY)
+            break;
+        offset +=2;
+        nbytes -=2;
+        src++;
+    }
+    flash_command(FLASH_UBRESET, 0, 0, 0);
+    
+    return (byte*)src - buf;
+}
+
+/*********************************************************************/
+/* flash_wait utilizes the DQ6, DQ5, and DQ2 polling algorithms      */
+/* described in the flash data book.  It can quickly ascertain the   */
+/* operational status of the flash device, and return an             */
+/* appropriate status code (defined in flash.h)                      */
+/*********************************************************************/
+static int flash_wait(WORD sector, int offset, UINT16 data)
+{
+    volatile UINT16 *flashptr; /* flash window */
+    UINT16 d1;
+
+    flashptr = (UINT16 *) flash_get_memptr(sector);
+
+    if (flashFamily == FLASH_AMD || flashFamily == FLASH_SST) {
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+        do {
+            d1 = flashptr[offset/2];
+            if (d1 == data)
+                return STATUS_READY;
+        } while (!(d1 & 0x20));
+
+        d1 = flashptr[offset/2];
+
+        if (d1 != data) {
+            flash_command(FLASH_RESET, 0, 0, 0);
+            return STATUS_TIMEOUT;
+        }
+#else
+        do {
+            d1 = *flashptr;    /* read data */
+            d1 ^= *flashptr;   /* read it again and see what toggled */
+            if (d1 == 0)       /* no toggles, nothing's happening */
+                return STATUS_READY;
+        } while (!(d1 & 0x20));
+
+        d1 = *flashptr;        /* read data */
+        d1 ^= *flashptr;   /* read it again and see what toggled */
+
+        if (d1 != 0) {
+            flash_command(FLASH_RESET, 0, 0, 0);
+            return STATUS_TIMEOUT;
+        }
+#endif
+    } else if (flashFamily == FLASH_INTEL) {
+        flashptr[0] = 0x70;
+        /* Wait for completion */
+        while(!(*flashptr & 0x80));
+        if (*flashptr & 0x30) {
+            flashptr[0] = 0x50;
+            flash_command(FLASH_RESET, 0, 0, 0);
+            return STATUS_TIMEOUT;
+        }
+        flashptr[0] = 0x50;
+        flash_command(FLASH_RESET, 0, 0, 0);
+    }
+    
+    return STATUS_READY;
+}
+
+/*********************************************************************/
+/* flash_get_device_id() will perform an autoselect sequence on the  */
+/* flash device, and return the device id of the component.          */
+/* This function automatically resets to read mode.                  */
+/*********************************************************************/
+static UINT16 flash_get_device_id()
+{
+    volatile UINT16 *fwp; /* flash window */
+    UINT16 answer;
+    
+    fwp = (UINT16 *)flash_get_memptr(0);
+    
+    flash_command(FLASH_READ_ID, 0, 0, 0);
+    answer = *(fwp + 1);
+    if (answer == ID_AM29LV320M) {
+        answer = *(fwp + 0xe);
+        answer = *(fwp + 0xf);
+    }
+    
+    flash_command(FLASH_RESET, 0, 0, 0);
+    return( (UINT16) answer );
+}
+
+/*********************************************************************/
+/* flash_get_cfi() is the main CFI workhorse function.  Due to it's  */
+/* complexity and size it need only be called once upon              */
+/* initializing the flash system.  Once it is called, all operations */
+/* are performed by looking at the meminfo structure.                */
+/* All possible care was made to make this algorithm as efficient as */
+/* possible.  90% of all operations are memory reads, and all        */
+/* calculations are done using bit-shifts when possible              */
+/*********************************************************************/
+static int flash_get_cfi(struct cfi_query *query, UINT16 *cfi_struct, int flashFamily)
+{
+    volatile UINT16 *fwp; /* flash window */
+    int i=0;
+
+    flash_command(FLASH_CFIQUERY, 0, 0, 0);
+    
+    if (cfi_struct == 0)
+        fwp = (UINT16 *)flash_get_memptr(0);
+    else
+        fwp = cfi_struct;
+    
+    /* Initial house-cleaning */
+    for(i=0; i < 8; i++) {
+        query->erase_block[i].sector_size = 0;
+        query->erase_block[i].num_sectors = 0;
+    }
+    
+    /* If not 'QRY', then we dont have a CFI enabled device in the socket */
+    if( fwp[0x10] != 'Q' &&
+        fwp[0x11] != 'R' &&
+        fwp[0x12] != 'Y') {
+        flash_command(FLASH_RESET, 0, 0, 0);
+        return(-1);
+    }
+    
+	query->num_erase_blocks = fwp[0x2C];
+	if(flashFamily == FLASH_SST)
+		query->num_erase_blocks = 1;
+	
+    for(i=0; i < query->num_erase_blocks; i++) {
+			query->erase_block[i].num_sectors = fwp[(0x2D+(4*i))] + (fwp[0x2E + (4*i)] << 8);
+			query->erase_block[i].num_sectors++;
+			query->erase_block[i].sector_size = 256 * (256 * fwp[(0x30+(4*i))] + fwp[(0x2F+(4*i))]);
+    }
+    
+    flash_command(FLASH_RESET, 0, 0, 0);
+    return(1);
+}
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.h
--- linux-2.6.8.1/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/board/bcm963xx/impl1/cfiflash.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,150 @@
+/************************************************************************/
+/*                                                                      */
+/*  AMD CFI Enabled Flash Memory Drivers                                */
+/*  File name: CFIFLASH.H                                               */
+/*  Revision:  1.0  5/07/98                                             */
+/*                                                                      */
+/* Copyright (c) 1998 ADVANCED MICRO DEVICES, INC. All Rights Reserved. */
+/* This software is unpublished and contains the trade secrets and      */
+/* confidential proprietary information of AMD. Unless otherwise        */
+/* provided in the Software Agreement associated herewith, it is        */
+/* licensed in confidence "AS IS" and is not to be reproduced in whole  */
+/* or part by any means except for backup. Use, duplication, or         */
+/* disclosure by the Government is subject to the restrictions in       */
+/* paragraph (b) (3) (B) of the Rights in Technical Data and Computer   */
+/* Software clause in DFAR 52.227-7013 (a) (Oct 1988).                  */
+/* Software owned by                                                    */
+/* Advanced Micro Devices, Inc.,                                        */
+/* One AMD Place,                                                       */
+/* P.O. Box 3453                                                        */
+/* Sunnyvale, CA 94088-3453.                                            */
+/************************************************************************/
+/*  This software constitutes a basic shell of source code for          */
+/*  programming all AMD Flash components. AMD                           */
+/*  will not be responsible for misuse or illegal use of this           */
+/*  software for devices not supported herein. AMD is providing         */
+/*  this source code "AS IS" and will not be responsible for            */
+/*  issues arising from incorrect user implementation of the            */
+/*  source code herein. It is the user's responsibility to              */
+/*  properly design-in this source code.                                */
+/*                                                                      */ 
+/************************************************************************/
+#ifndef _CFIFLASH_H
+#define _CFIFLASH_H
+
+#if defined __cplusplus
+extern "C" {
+#endif
+
+/* include board/CPU specific definitions */
+#include "bcmtypes.h"
+#include "board.h"
+
+#define FLASH_BASE_ADDR_REG FLASH_BASE
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#define MAXSECTORS  1024      /* maximum number of sectors supported */
+
+/* A structure for identifying a flash part.  There is one for each
+ * of the flash part definitions.  We need to keep track of the
+ * sector organization, the address register used, and the size
+ * of the sectors.
+ */
+struct flashinfo {
+	 char *name;         /* "Am29DL800T", etc. */
+	 unsigned long addr; /* physical address, once translated */
+	 int areg;           /* Can be set to zero for all parts */
+	 int nsect;          /* # of sectors -- 19 in LV, 22 in DL */
+	 int bank1start;     /* first sector # in bank 1 */
+	 int bank2start;     /* first sector # in bank 2, if DL part */
+ struct {
+	long size;           /* # of bytes in this sector */
+	long base;           /* offset from beginning of device */
+	int bank;            /* 1 or 2 for DL; 1 for LV */
+	 } sec[MAXSECTORS];  /* per-sector info */
+};
+
+/*
+ * This structure holds all CFI query information as defined
+ * in the JEDEC standard. All information up to 
+ * primary_extended_query is standard among all manufactures
+ * with CFI enabled devices.
+ */
+
+struct cfi_query {
+	int num_erase_blocks;		/* Number of sector defs. */
+	struct {
+	  unsigned long sector_size;	/* byte size of sector */
+	  int num_sectors;		/* Num sectors of this size */
+	} erase_block[8];		/* Max of 256, but 8 is good */
+};
+
+/* Standard Boolean declarations */
+#define TRUE 				1
+#define FALSE 				0
+
+/* Define different type of flash */
+#define FLASH_UNDEFINED 0
+#define FLASH_AMD       1
+#define FLASH_INTEL     2
+#define FLASH_SST       3
+
+/* Command codes for the flash_command routine */
+#define FLASH_RESET     0       /* reset to read mode */
+#define FLASH_READ_ID   1       /* read device ID */
+#define FLASH_CFIQUERY  2       /* CFI query */
+#define FLASH_UB        3       /* go into unlock bypass mode */
+#define FLASH_PROG      4       /* program a word */
+#define FLASH_UBRESET   5       /* reset to read mode from unlock bypass mode */
+#define FLASH_SERASE    6       /* sector erase */
+
+/* Return codes from flash_status */
+#define STATUS_READY    0       /* ready for action */
+#define STATUS_TIMEOUT  1       /* operation timed out */
+
+/* A list of AMD compatible device ID's - add others as needed */
+#define ID_AM29DL800T   0x224A
+#define ID_AM29DL800B   0x22CB
+#define ID_AM29LV800T   0x22DA
+#define ID_AM29LV800B   0x225B
+#define ID_AM29LV400B   0x22BA
+
+#define ID_AM29LV160B   0x2249
+#define ID_AM29LV160T   0x22C4
+
+#define ID_AM29LV320T   0x22F6
+#define ID_MX29LV320AT  0x22A7
+#define ID_AM29LV320B   0x22F9
+#define ID_MX29LV320AB  0x22A8
+
+#define ID_AM29LV320M   0x227E
+#define ID_AM29LV320MB  0x2200
+#define ID_AM29LV320MT  0x2201
+
+#define ID_SST39VF1601  0x234B
+#define ID_SST39VF3201  0x235B
+
+/* A list of Intel compatible device ID's - add others as needed */
+#define ID_I28F160C3T   0x88C2
+#define ID_I28F160C3B   0x88C3
+#define ID_I28F320C3T   0x88C4
+#define ID_I28F320C3B   0x88C5
+
+extern byte flash_init(void);
+extern int flash_write_buf(WORD sector, int offset, byte *buffer, int numbytes);
+extern int flash_read_buf(WORD sector, int offset, byte *buffer, int numbytes);
+extern byte flash_sector_erase_int(WORD sector);
+extern int flash_get_numsectors(void);
+extern int flash_get_sector_size(WORD sector);
+extern int flash_get_total_size(void);
+extern unsigned char *flash_get_memptr(WORD sector);
+extern int flash_get_blk(int addr);
+
+#if defined __cplusplus
+}
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/serial/bcm96348/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/bcm96348/Makefile
--- linux-2.6.8.1/bcmdrivers/opensource/char/serial/bcm96348/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/bcm96348/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,13 @@
+# File: bcmdrivers/opensource/char/serial
+#
+# Makefile for the BCM63xx serial/console driver
+
+obj-$(CONFIG_BCM_SERIAL) += bcm63xx_cons.o
+
+EXTRA_CFLAGS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+
+-include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/serial/bcm96348/bcm63xx_cons.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/bcm96348/bcm63xx_cons.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/serial/bcm96348/bcm63xx_cons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/bcm96348/bcm63xx_cons.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,1035 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+/* Description: Serial port driver for the BCM963XX. */
+
+#define CARDNAME    "bcm963xx_serial driver"
+#define VERSION     "2.0"
+#define VER_STR     CARDNAME " v" VERSION "\n"
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h> 
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+/* for definition of struct console */
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <asm/uaccess.h>
+
+#include <bcmtypes.h>
+#include <board.h>
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+extern void _putc(char);
+extern void _puts(const char *);
+
+typedef struct bcm_serial {
+    volatile Uart *         port;
+    int                     type;
+    int                     flags; 
+    int                     irq;
+    int                     baud_base;
+    int                     blocked_open;
+    unsigned short          close_delay;
+    unsigned short          closing_wait;
+    unsigned short          line;                /* port/line number */
+    unsigned short          cflags;              /* line configuration flag */
+    unsigned short          x_char;              /* xon/xoff character */
+    unsigned short          read_status_mask;    /* mask for read condition */
+    unsigned short          ignore_status_mask;  /* mask for ignore condition */
+    unsigned long           event;               /* mask used in BH */
+    int                     xmit_head;           /* Position of the head */
+    int                     xmit_tail;           /* Position of the tail */
+    int                     xmit_cnt;            /* Count of the chars in the buffer */
+    int                     count;               /* indicates how many times it has been opened */
+    int                     magic;
+
+    struct async_icount     icount;              /* keep track of things ... */
+    struct tty_struct       *tty;                /* tty associated */    
+    struct termios          normal_termios;
+
+    wait_queue_head_t       open_wait;
+    wait_queue_head_t       close_wait;
+
+    long                    session;             /* Session of opening process */
+    long                    pgrp;                /* pgrp of opening process */
+
+    unsigned char           is_initialized;
+} Context;
+
+
+/*---------------------------------------------------------------------*/
+/* Define bits in the Interrupt Enable register                        */
+/*---------------------------------------------------------------------*/
+/* Enable receive interrupt              */
+#define RXINT   (RXFIFONE|RXOVFERR)
+
+/* Enable transmit interrupt             */
+#define TXINT    (TXFIFOEMT|TXUNDERR|TXOVFERR) 
+
+/* Enable receiver line status interrupt */
+#define LSINT    (RXBRK|RXPARERR|RXFRAMERR)
+
+#define BCM_NUM_UARTS                   1
+
+#define BD_BCM63XX_TIMER_CLOCK_INPUT    (FPERIPH)
+
+
+static struct bcm_serial multi[BCM_NUM_UARTS];
+static struct bcm_serial *lines[BCM_NUM_UARTS];
+static struct tty_driver serial_driver;
+static struct tty_struct *serial_table[BCM_NUM_UARTS];
+static struct termios *serial_termios[BCM_NUM_UARTS];
+static struct termios *serial_termios_locked[BCM_NUM_UARTS];
+static int serial_refcount;
+
+
+static void bcm_stop (struct tty_struct *tty);
+static void bcm_start (struct tty_struct *tty);
+static inline void receive_chars (struct bcm_serial * info);
+static int startup (struct bcm_serial *info);
+static void shutdown (struct bcm_serial * info);
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag );
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty);
+static int bcm63xx_cons_write (struct tty_struct *tty, int from_user,
+    const unsigned char *buf, int count);
+static int bcm63xx_cons_write_room (struct tty_struct *tty);
+static int bcm_chars_in_buffer (struct tty_struct *tty);
+static void bcm_flush_buffer (struct tty_struct *tty);
+static void bcm_throttle (struct tty_struct *tty);
+static void bcm_unthrottle (struct tty_struct *tty);
+static void bcm_send_xchar (struct tty_struct *tty, char ch);
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo);
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info);
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value);
+static void send_break (struct bcm_serial *info, int duration);
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg);
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios);
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp);
+static void bcm_hangup (struct tty_struct *tty);
+static int block_til_ready (struct tty_struct *tty, struct file *filp, struct bcm_serial *info);
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp);
+static int __init bcm63xx_serialinit(void);
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop () and rs_start ()
+ *
+ * These routines are called before setting or resetting 
+ * tty->stopped. They enable or disable transmitter interrupts, 
+ * as necessary.
+ * ------------------------------------------------------------
+ */
+static void bcm_stop (struct tty_struct *tty)
+{
+}  
+
+static void bcm_start (struct tty_struct *tty)
+{
+    _puts(CARDNAME " Start\n");
+}  
+
+/*
+ * ------------------------------------------------------------
+ * receive_char ()
+ *
+ * This routine deals with inputs from any lines.
+ * ------------------------------------------------------------
+ */
+static inline void receive_chars (struct bcm_serial * info)
+{
+    struct tty_struct *tty = 0;
+    struct async_icount * icount;
+    int ignore = 0;
+    unsigned short status, tmp;
+    UCHAR ch = 0;
+    while ((status = info->port->intStatus) & RXINT)
+    {
+        if (status & RXFIFONE)
+            ch = info->port->Data;  // Read the character
+        tty = info->tty;                  /* now tty points to the proper dev */
+        icount = &info->icount;
+        if (! tty)
+            break;
+        if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+            break;
+        *tty->flip.char_buf_ptr = ch;
+        *tty->flip.flag_buf_ptr = 0;
+        icount->rx++;
+        if (status & RXBRK)
+        {
+            *tty->flip.flag_buf_ptr = TTY_BREAK;
+            icount->brk++;
+        }
+        // keep track of the statistics
+        if (status & (RXFRAMERR | RXPARERR | RXOVFERR))
+        {
+            if (status & RXPARERR)                /* parity error */
+                icount->parity++;
+            else
+                if (status & RXFRAMERR)           /* frame error */
+                    icount->frame++;
+            if (status & RXOVFERR)
+            {
+                // Overflow. Reset the RX FIFO
+                info->port->fifoctl |= RSTRXFIFOS;
+                icount->overrun++;
+            }
+            // check to see if we should ignore the character
+            // and mask off conditions that should be ignored
+            if (status & info->ignore_status_mask)
+            {
+                if (++ignore > 100 )
+                    break;
+                goto ignore_char;
+            }
+            // Mask off the error conditions we want to ignore
+            tmp = status & info->read_status_mask;
+            if (tmp & RXPARERR)
+            {
+                *tty->flip.flag_buf_ptr = TTY_PARITY;
+            }
+            else
+                if (tmp & RXFRAMERR)
+                {
+                    *tty->flip.flag_buf_ptr = TTY_FRAME;
+                }
+            if (tmp & RXOVFERR)
+            {
+                if (tty->flip.count < TTY_FLIPBUF_SIZE)
+                {
+                    tty->flip.count++;
+                    tty->flip.flag_buf_ptr++;
+                    tty->flip.char_buf_ptr++;
+                    *tty->flip.flag_buf_ptr = TTY_OVERRUN;
+                }
+            }
+        }
+        tty->flip.flag_buf_ptr++;
+        tty->flip.char_buf_ptr++;
+        tty->flip.count++;
+    }
+ignore_char:
+    if (tty)
+        tty_flip_buffer_push(tty);
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * bcm_interrupt ()
+ *
+ * this is the main interrupt routine for the chip.
+ * It deals with the multiple ports.
+ * ------------------------------------------------------------
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static irqreturn_t bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#else
+static void bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#endif
+{
+    struct bcm_serial * info = lines[0];
+    UINT16  intStat;
+
+    /* get pending interrupt flags from UART  */
+
+    /* Mask with only the serial interrupts that are enabled */
+    intStat = info->port->intStatus & info->port->intMask;
+    while (intStat)
+    {
+        if (intStat & RXINT)
+            receive_chars (info);          
+        else
+            if (intStat & TXINT)
+                info->port->intStatus = TXINT;
+            else /* don't know what it was, so let's mask it */
+                info->port->intMask &= ~intStat;
+
+        intStat = info->port->intStatus & info->port->intMask;
+    }
+
+    // Clear the interrupt
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    return IRQ_HANDLED;
+#endif    
+}
+
+/*
+ * -------------------------------------------------------------------
+ * startup ()
+ *
+ * various initialization tasks
+ * ------------------------------------------------------------------- 
+ */
+static int startup (struct bcm_serial *info)
+{
+    // Port is already started...
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * shutdown ()
+ *
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ * ------------------------------------------------------------------- 
+ */
+static void shutdown (struct bcm_serial * info)
+{
+    unsigned long flags;
+    if (!info->is_initialized)
+        return;
+
+    save_flags (flags);
+    cli ();
+
+    info->port->control &= ~(BRGEN|TXEN|RXEN);
+    if (info->tty)
+        set_bit (TTY_IO_ERROR, &info->tty->flags);
+    info->is_initialized = 0;
+
+    restore_flags (flags);
+}
+/* 
+ * -------------------------------------------------------------------
+ * change_speed ()
+ *
+ * Set the baud rate, character size, parity and stop bits.
+ * ------------------------------------------------------------------- 
+ */
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag )
+{
+    unsigned long ulFlags, ulBaud, ulClockFreqHz, ulTmp;
+    save_flags(ulFlags);
+    cli();
+    switch( cFlag & (CBAUD | CBAUDEX) )
+    {
+    case B115200:
+        ulBaud = 115200;
+        break;
+    case B57600:
+        ulBaud = 57600;
+        break;
+    case B38400:
+        ulBaud = 38400;
+        break;
+    case B19200:
+        ulBaud = 19200;
+        break;
+    case B9600:
+        ulBaud = 9600;
+        break;
+    case B4800:
+        ulBaud = 4800;
+        break;
+    case B2400:
+        ulBaud = 2400;
+        break;
+    case B1800:
+        ulBaud = 1800;
+        break;
+    case B1200:
+        ulBaud = 1200;
+        break;
+    case B600:
+        ulBaud = 600;
+        break;
+    case B300:
+        ulBaud = 300;
+        break;
+    case B200:
+        ulBaud = 200;
+        break;
+    case B150:
+        ulBaud = 150;
+        break;
+    case B134:
+        ulBaud = 134;
+        break;
+    case B110:
+        ulBaud = 110;
+        break;
+    case B75:
+        ulBaud = 75;
+        break;
+    case B50:
+        ulBaud = 50;
+        break;
+    default:
+        ulBaud = 115200;
+        break;
+    }
+
+    /* Calculate buad rate.  */
+    ulClockFreqHz = BD_BCM63XX_TIMER_CLOCK_INPUT;
+    ulTmp = (ulClockFreqHz / ulBaud) / 16;
+    if( ulTmp & 0x01 )
+        ulTmp /= 2; /* Rounding up, so sub is already accounted for */
+    else
+        ulTmp = (ulTmp / 2) - 1; /* Rounding down so we must sub 1 */
+    pUart->baudword = ulTmp;
+
+    /* Set character size, stop bits and parity.  */
+    switch( cFlag & CSIZE )
+    {
+    case CS5:
+        ulTmp = BITS5SYM; /* select transmit 5 bit data size */
+        break;
+    case CS6:
+        ulTmp = BITS6SYM; /* select transmit 6 bit data size */
+        break;
+    case CS7:
+        ulTmp = BITS7SYM; /* select transmit 7 bit data size */
+        break;
+    /*case CS8:*/
+    default:
+        ulTmp = BITS8SYM; /* select transmit 8 bit data size */
+        break;
+    }
+    if( cFlag & CSTOPB )
+        ulTmp |= TWOSTOP;         /* select 2 stop bits */
+    else
+        ulTmp |= ONESTOP;         /* select one stop bit */
+
+    /* Write these values into the config reg.  */
+    pUart->config = ulTmp;
+    pUart->control &= ~(RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN);
+    switch( cFlag & (PARENB | PARODD) )
+    {
+    case PARENB|PARODD:
+        pUart->control |= RXPARITYEN | TXPARITYEN;
+        break;
+    case PARENB:
+        pUart->control |= RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN;
+        break;
+    default:
+        pUart->control |= 0;
+        break;
+    }
+
+    /* Reset and flush uart */
+    pUart->fifoctl = RSTTXFIFOS | RSTRXFIFOS;
+    restore_flags( ulFlags );
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_char ()
+ *
+ * Nothing to flush.  Polled I/O is used.
+ * ------------------------------------------------------------------- 
+ */
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty)
+{
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write ()
+ *
+ * Main output routine using polled I/O.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write (struct tty_struct *tty, int from_user,
+    const unsigned char *buf, int count)
+{
+    int c;
+
+    for (c = 0; c < count; c++)
+        _putc(buf[c]);
+    return count;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write_room ()
+ *
+ * Compute the amount of space available for writing.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write_room (struct tty_struct *tty)
+{
+    /* Pick a number.  Any number.  Polled I/O is used. */
+    return 1024;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_chars_in_buffer ()
+ *
+ * compute the amount of char left to be transmitted
+ * ------------------------------------------------------------------- 
+ */
+static int bcm_chars_in_buffer (struct tty_struct *tty)
+{
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_buffer ()
+ *
+ * Empty the output buffer
+ * ------------------------------------------------------------------- 
+ */
+static void bcm_flush_buffer (struct tty_struct *tty)
+{
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm_throttle () and bcm_unthrottle ()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled (or not).
+ * ------------------------------------------------------------
+ */
+static void bcm_throttle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+        info->x_char = STOP_CHAR(tty);
+}
+
+static void bcm_unthrottle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+    {
+        if (info->x_char)
+            info->x_char = 0;
+        else
+            info->x_char = START_CHAR(tty);
+    }
+}
+
+static void bcm_send_xchar (struct tty_struct *tty, char ch)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+    info->x_char = ch;
+    if (ch)
+        bcm_start (info->tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl () and friends
+ * ------------------------------------------------------------
+ */
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo)
+{
+    struct serial_struct tmp;
+
+    if (!retinfo)
+        return -EFAULT;
+
+    memset (&tmp, 0, sizeof(tmp));
+    tmp.type            = info->type;
+    tmp.line            = info->line;
+    tmp.port            = (int) info->port;
+    tmp.irq             = info->irq;
+    tmp.flags           = 0;
+    tmp.baud_base       = info->baud_base;
+    tmp.close_delay     = info->close_delay;
+    tmp.closing_wait    = info->closing_wait;
+
+    return copy_to_user (retinfo, &tmp, sizeof(*retinfo));
+}
+
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info)
+{
+    struct serial_struct new_serial;
+    struct bcm_serial old_info;
+    int retval = 0;
+
+    if (!new_info)
+        return -EFAULT;
+
+    copy_from_user (&new_serial, new_info, sizeof(new_serial));
+    old_info = *info;
+
+    if (!capable(CAP_SYS_ADMIN))
+        return -EPERM;
+
+
+    if (info->count > 1)
+        return -EBUSY;
+
+    /* OK, past this point, all the error checking has been done.
+     * At this point, we start making changes.....
+     */
+    info->baud_base = new_serial.baud_base;
+    info->type = new_serial.type;
+    info->close_delay = new_serial.close_delay;
+    info->closing_wait = new_serial.closing_wait;
+    retval = startup (info);
+    return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ *          is emptied.  On bus types like RS485, the transmitter must
+ *          release the bus after transmitting. This must be done when
+ *          the transmit shift register is empty, not be done when the
+ *          transmit holding register is empty.  This functionality
+ *          allows an RS485 driver to be written in user space. 
+ */
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value)
+{
+    return( 0 );
+}
+
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void send_break (struct bcm_serial *info, int duration)
+{
+    unsigned long flags;
+
+    if (!info->port)
+        return;
+
+    current->state = TASK_INTERRUPTIBLE;
+
+    save_flags (flags);
+    cli();
+
+    info->port->control |= XMITBREAK;
+    schedule_timeout(duration);
+    info->port->control &= ~XMITBREAK;
+
+    restore_flags (flags);
+}
+
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg)
+{
+    int error;
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    int retval;
+
+    if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+        (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD)  &&
+        (cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT))
+    {
+        if (tty->flags & (1 << TTY_IO_ERROR))
+            return -EIO;
+    }
+    switch (cmd) 
+    {
+
+    case TCSBRK:    /* SVID version: non-zero arg --> no break */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        if (!arg)
+            send_break (info, HZ/4); /* 1/4 second */
+        return 0;
+
+    case TCSBRKP:   /* support for POSIX tcsendbreak() */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        send_break (info, arg ? arg*(HZ/10) : HZ/4);
+        return 0;
+
+    case TIOCGSOFTCAR:
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(long));
+        if (error)
+            return error;
+        put_user (C_CLOCAL(tty) ? 1 : 0, (unsigned long *)arg);
+        return 0;
+
+    case TIOCSSOFTCAR:
+        error = get_user (arg, (unsigned long *)arg);
+        if (error)
+            return error;
+        tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+        return 0;
+
+    case TIOCGSERIAL:
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(struct serial_struct));
+        if (error)
+            return error;
+        return get_serial_info (info, (struct serial_struct *)arg);
+
+    case TIOCSSERIAL:
+        return set_serial_info (info, (struct serial_struct *) arg);
+
+    case TIOCSERGETLSR: /* Get line status register */
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(unsigned int));
+        if (error)
+            return error;
+        else
+            return get_lsr_info (info, (unsigned int *)arg);
+
+    case TIOCSERGSTRUCT:
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(struct bcm_serial));
+        if (error)
+            return error;
+        copy_to_user((struct bcm_serial *)arg, info, sizeof(struct bcm_serial));
+        return 0;
+
+    default:
+        return -ENOIOCTLCMD;
+    }
+    return 0;
+}
+
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    if( tty->termios->c_cflag != old_termios->c_cflag )
+        change_speed (info->port, tty->termios->c_cflag);
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm63xx_cons_close()
+ * 
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we turn off
+ * the transmit enable and receive enable flags.
+ * ------------------------------------------------------------
+ */
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp)
+{
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    unsigned long flags;
+
+    if (!info)
+        return;
+
+    save_flags (flags); 
+    cli();
+
+    if (tty_hung_up_p (filp))
+    {
+        restore_flags (flags);
+        return;
+    }
+
+    if ((tty->count == 1) && (info->count != 1))
+    {
+
+        /* Uh, oh.  tty->count is 1, which means that the tty
+         * structure will be freed.  Info->count should always
+         * be one in these conditions.  If it's greater than
+         * one, we've got real problems, since it means the
+         * serial port won't be shutdown.
+         */
+        printk("bcm63xx_cons_close: bad serial port count; tty->count is 1, "
+            "info->count is %d\n", info->count);
+        info->count = 1;
+    }
+
+    if (--info->count < 0)
+    {
+        printk("ds_close: bad serial port count for ttys%d: %d\n",
+        info->line, info->count);
+        info->count = 0;
+    }
+
+    if (info->count)
+    {
+        restore_flags (flags);
+        return;
+    }
+
+    /* Now we wait for the transmit buffer to clear; and we notify 
+     * the line discipline to only process XON/XOFF characters.
+     */
+    tty->closing = 1;
+
+    /* At this point we stop accepting input.  To do this, we
+     * disable the receive line status interrupts.
+     */
+    shutdown (info);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (tty->driver->flush_buffer)
+        tty->driver->flush_buffer (tty);
+#else    
+    if (tty->driver.flush_buffer)
+        tty->driver.flush_buffer (tty);
+#endif
+    if (tty->ldisc.flush_buffer)
+        tty->ldisc.flush_buffer (tty);
+
+    tty->closing = 0;
+    info->event = 0;
+    info->tty = 0;
+    if (tty->ldisc.num != ldiscs[N_TTY].num)
+    {
+        if (tty->ldisc.close)
+            (tty->ldisc.close)(tty);
+        tty->ldisc = ldiscs[N_TTY];
+        tty->termios->c_line = N_TTY;
+        if (tty->ldisc.open)
+            (tty->ldisc.open)(tty);
+    }
+    if (info->blocked_open)
+    {
+        if (info->close_delay)
+        {
+            current->state = TASK_INTERRUPTIBLE;
+            schedule_timeout(info->close_delay);
+        }
+        wake_up_interruptible (&info->open_wait);
+    }
+    wake_up_interruptible (&info->close_wait);
+
+    restore_flags (flags);
+}
+
+/*
+ * bcm_hangup () --- called by tty_hangup() when a hangup is signaled.
+ */
+static void bcm_hangup (struct tty_struct *tty)
+{
+
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    shutdown (info);
+    info->event = 0;
+    info->count = 0;
+    info->tty = 0;
+    wake_up_interruptible (&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready (struct tty_struct *tty, struct file *filp,
+    struct bcm_serial *info)
+{
+    return 0;
+}       
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port. It also performs the 
+ * serial-specific initialization for the tty structure.
+ */
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp)
+{
+    struct bcm_serial *info;
+    int retval, line;
+
+    // Make sure we're only opening on of the ports we support
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    line = MINOR(tty->driver->cdev.dev) - tty->driver->minor_start;
+#else
+    line = MINOR(tty->device) - tty->driver.minor_start;
+#endif    
+
+    if ((line < 0) || (line >= BCM_NUM_UARTS))
+        return -ENODEV;
+
+    info = lines[line];
+
+    info->port->intMask  = 0;     /* Clear any pending interrupts */
+    info->port->intMask  = RXINT; /* Enable RX */
+
+    info->count++;
+    tty->driver_data = info;
+    info->tty = tty;
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+
+    // Start up serial port
+    retval = startup (info);
+    if (retval)
+        return retval;
+
+    retval = block_til_ready (tty, filp, info);
+    if (retval)
+        return retval;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    info->pgrp = process_group(current);
+    info->session = current->signal->session;
+#else
+    info->session = current->session;    
+    info->pgrp = current->pgrp;
+#endif    
+
+    return 0;
+}
+
+/* --------------------------------------------------------------------------
+    Name: bcm63xx_serialinit
+ Purpose: Initialize our BCM63xx serial driver
+-------------------------------------------------------------------------- */
+static int __init bcm63xx_serialinit(void)
+{
+    int i, flags;
+    struct bcm_serial * info;
+
+    // Print the driver version information
+    printk(VER_STR);
+
+    memset(&serial_driver, 0, sizeof(struct tty_driver));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)     
+    serial_driver.owner 	    = THIS_MODULE;
+    serial_driver.devfs_name 	    = "tts/";
+#endif    
+    serial_driver.magic             = TTY_DRIVER_MAGIC;
+    serial_driver.name              = "ttyS";
+    serial_driver.major             = TTY_MAJOR;
+    serial_driver.minor_start       = 64;
+    serial_driver.num               = BCM_NUM_UARTS;
+    serial_driver.type              = TTY_DRIVER_TYPE_SERIAL;
+    serial_driver.subtype           = SERIAL_TYPE_NORMAL;
+    serial_driver.init_termios      = tty_std_termios;
+    serial_driver.init_termios.c_cflag = B115200 | CS8 | CREAD | CLOCAL;
+    serial_driver.flags             = TTY_DRIVER_REAL_RAW;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)    
+    serial_driver.refcount          = serial_refcount;
+    serial_driver.ttys	            = serial_table;    
+#else
+    serial_driver.refcount          = &serial_refcount;
+    serial_driver.table             = serial_table;    
+#endif    
+
+    serial_driver.termios           = serial_termios;
+    serial_driver.termios_locked    = serial_termios_locked;
+    serial_driver.open              = bcm63xx_cons_open;
+    serial_driver.close             = bcm63xx_cons_close;
+    serial_driver.write             = bcm63xx_cons_write;
+    serial_driver.flush_chars       = bcm63xx_cons_flush_chars;
+    serial_driver.write_room        = bcm63xx_cons_write_room;
+    serial_driver.chars_in_buffer   = bcm_chars_in_buffer;
+    serial_driver.flush_buffer      = bcm_flush_buffer;
+    serial_driver.ioctl             = bcm_ioctl;
+    serial_driver.throttle          = bcm_throttle;
+    serial_driver.unthrottle        = bcm_unthrottle;
+    serial_driver.send_xchar        = bcm_send_xchar;
+    serial_driver.set_termios       = bcm_set_termios;
+    serial_driver.stop              = bcm_stop;
+    serial_driver.start             = bcm_start;
+    serial_driver.hangup            = bcm_hangup;
+
+    if (tty_register_driver (&serial_driver))
+        panic("Couldn't register serial driver\n");
+
+    save_flags(flags); cli();
+    for (i = 0; i < BCM_NUM_UARTS; i++)
+    {
+        info = &multi[i]; 
+        lines[i] = info;
+        info->port                  = (Uart *) ((char *)UART_BASE + (i * 0x20));
+        info->irq                   = (2 - i) + 8;
+        info->line                  = i;
+        info->tty                   = 0;
+        info->close_delay           = 50;
+        info->closing_wait          = 3000;
+        info->x_char                = 0;
+        info->event                 = 0;
+        info->count                 = 0;
+        info->blocked_open          = 0;	
+        info->normal_termios        = serial_driver.init_termios;
+        init_waitqueue_head(&info->open_wait); 
+        init_waitqueue_head(&info->close_wait); 
+
+        /* If we are pointing to address zero then punt - not correctly
+         * set up in setup.c to handle this. 
+         */
+        if (! info->port)
+            return 0;
+        BcmHalMapInterrupt(bcm_interrupt, 0, INTERRUPT_ID_UART);
+    }
+
+    /* order matters here... the trick is that flags
+     * is updated... in request_irq - to immediatedly obliterate
+     * it is unwise. 
+     */
+    restore_flags(flags);
+    return 0;
+}
+
+module_init(bcm63xx_serialinit);
+
+/* --------------------------------------------------------------------------
+    Name: bcm_console_print
+ Purpose: bcm_console_print is registered for printk.
+          The console_lock must be held when we get here.
+-------------------------------------------------------------------------- */
+static void bcm_console_print (struct console * cons, const char * str,
+    unsigned int count)
+{
+    unsigned int i;
+    //_puts(str);
+    for(i=0; i<count; i++, str++)
+    {
+        _putc(*str);
+        if (*str == 10)
+        {
+            _putc(13);
+        }
+    }
+}
+
+static struct tty_driver * bcm_console_device(struct console * c, int *index)
+{
+    *index = c->index;
+    return &serial_driver;
+}
+
+static int __init bcm_console_setup(struct console * co, char * options)
+{
+    return 0;
+}
+
+static struct console bcm_sercons = {
+    .name	= "ttyS",
+    .write	= bcm_console_print,
+    .device	= bcm_console_device,
+    .setup	= bcm_console_setup,
+    .flags	= CON_PRINTBUFFER, // CON_CONSDEV, CONSOLE_LINE,
+    .index	= -1,
+};
+
+static int __init bcm63xx_console_init(void)
+{
+    register_console(&bcm_sercons);
+    return 0;
+}
+
+console_initcall(bcm63xx_console_init);
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/serial/impl1/Makefile linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/impl1/Makefile
--- linux-2.6.8.1/bcmdrivers/opensource/char/serial/impl1/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/impl1/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,13 @@
+# File: bcmdrivers/opensource/char/serial
+#
+# Makefile for the BCM63xx serial/console driver
+
+obj-$(CONFIG_BCM_SERIAL) += bcm63xx_cons.o
+
+EXTRA_CFLAGS += -I$(INC_BRCMDRIVER_PUB_PATH)/$(BRCM_BOARD)
+
+-include $(TOPDIR)/Rules.make
+
+clean:
+	rm -f core *.o *.a *.s
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c
--- linux-2.6.8.1/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/char/serial/impl1/bcm63xx_cons.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,1035 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+/* Description: Serial port driver for the BCM963XX. */
+
+#define CARDNAME    "bcm963xx_serial driver"
+#define VERSION     "2.0"
+#define VER_STR     CARDNAME " v" VERSION "\n"
+
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h> 
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+/* for definition of struct console */
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial.h>
+#include <asm/uaccess.h>
+
+#include <bcmtypes.h>
+#include <board.h>
+#include <bcm_map_part.h>
+#include <bcm_intr.h>
+
+extern void _putc(char);
+extern void _puts(const char *);
+
+typedef struct bcm_serial {
+    volatile Uart *         port;
+    int                     type;
+    int                     flags; 
+    int                     irq;
+    int                     baud_base;
+    int                     blocked_open;
+    unsigned short          close_delay;
+    unsigned short          closing_wait;
+    unsigned short          line;                /* port/line number */
+    unsigned short          cflags;              /* line configuration flag */
+    unsigned short          x_char;              /* xon/xoff character */
+    unsigned short          read_status_mask;    /* mask for read condition */
+    unsigned short          ignore_status_mask;  /* mask for ignore condition */
+    unsigned long           event;               /* mask used in BH */
+    int                     xmit_head;           /* Position of the head */
+    int                     xmit_tail;           /* Position of the tail */
+    int                     xmit_cnt;            /* Count of the chars in the buffer */
+    int                     count;               /* indicates how many times it has been opened */
+    int                     magic;
+
+    struct async_icount     icount;              /* keep track of things ... */
+    struct tty_struct       *tty;                /* tty associated */    
+    struct termios          normal_termios;
+
+    wait_queue_head_t       open_wait;
+    wait_queue_head_t       close_wait;
+
+    long                    session;             /* Session of opening process */
+    long                    pgrp;                /* pgrp of opening process */
+
+    unsigned char           is_initialized;
+} Context;
+
+
+/*---------------------------------------------------------------------*/
+/* Define bits in the Interrupt Enable register                        */
+/*---------------------------------------------------------------------*/
+/* Enable receive interrupt              */
+#define RXINT   (RXFIFONE|RXOVFERR)
+
+/* Enable transmit interrupt             */
+#define TXINT    (TXFIFOEMT|TXUNDERR|TXOVFERR) 
+
+/* Enable receiver line status interrupt */
+#define LSINT    (RXBRK|RXPARERR|RXFRAMERR)
+
+#define BCM_NUM_UARTS                   1
+
+#define BD_BCM63XX_TIMER_CLOCK_INPUT    (FPERIPH)
+
+
+static struct bcm_serial multi[BCM_NUM_UARTS];
+static struct bcm_serial *lines[BCM_NUM_UARTS];
+static struct tty_driver serial_driver;
+static struct tty_struct *serial_table[BCM_NUM_UARTS];
+static struct termios *serial_termios[BCM_NUM_UARTS];
+static struct termios *serial_termios_locked[BCM_NUM_UARTS];
+static int serial_refcount;
+
+
+static void bcm_stop (struct tty_struct *tty);
+static void bcm_start (struct tty_struct *tty);
+static inline void receive_chars (struct bcm_serial * info);
+static int startup (struct bcm_serial *info);
+static void shutdown (struct bcm_serial * info);
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag );
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty);
+static int bcm63xx_cons_write (struct tty_struct *tty, int from_user,
+    const unsigned char *buf, int count);
+static int bcm63xx_cons_write_room (struct tty_struct *tty);
+static int bcm_chars_in_buffer (struct tty_struct *tty);
+static void bcm_flush_buffer (struct tty_struct *tty);
+static void bcm_throttle (struct tty_struct *tty);
+static void bcm_unthrottle (struct tty_struct *tty);
+static void bcm_send_xchar (struct tty_struct *tty, char ch);
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo);
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info);
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value);
+static void send_break (struct bcm_serial *info, int duration);
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg);
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios);
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp);
+static void bcm_hangup (struct tty_struct *tty);
+static int block_til_ready (struct tty_struct *tty, struct file *filp, struct bcm_serial *info);
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp);
+static int __init bcm63xx_serialinit(void);
+
+
+/*
+ * ------------------------------------------------------------
+ * rs_stop () and rs_start ()
+ *
+ * These routines are called before setting or resetting 
+ * tty->stopped. They enable or disable transmitter interrupts, 
+ * as necessary.
+ * ------------------------------------------------------------
+ */
+static void bcm_stop (struct tty_struct *tty)
+{
+}  
+
+static void bcm_start (struct tty_struct *tty)
+{
+    _puts(CARDNAME " Start\n");
+}  
+
+/*
+ * ------------------------------------------------------------
+ * receive_char ()
+ *
+ * This routine deals with inputs from any lines.
+ * ------------------------------------------------------------
+ */
+static inline void receive_chars (struct bcm_serial * info)
+{
+    struct tty_struct *tty = 0;
+    struct async_icount * icount;
+    int ignore = 0;
+    unsigned short status, tmp;
+    UCHAR ch = 0;
+    while ((status = info->port->intStatus) & RXINT)
+    {
+        if (status & RXFIFONE)
+            ch = info->port->Data;  // Read the character
+        tty = info->tty;                  /* now tty points to the proper dev */
+        icount = &info->icount;
+        if (! tty)
+            break;
+        if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+            break;
+        *tty->flip.char_buf_ptr = ch;
+        *tty->flip.flag_buf_ptr = 0;
+        icount->rx++;
+        if (status & RXBRK)
+        {
+            *tty->flip.flag_buf_ptr = TTY_BREAK;
+            icount->brk++;
+        }
+        // keep track of the statistics
+        if (status & (RXFRAMERR | RXPARERR | RXOVFERR))
+        {
+            if (status & RXPARERR)                /* parity error */
+                icount->parity++;
+            else
+                if (status & RXFRAMERR)           /* frame error */
+                    icount->frame++;
+            if (status & RXOVFERR)
+            {
+                // Overflow. Reset the RX FIFO
+                info->port->fifoctl |= RSTRXFIFOS;
+                icount->overrun++;
+            }
+            // check to see if we should ignore the character
+            // and mask off conditions that should be ignored
+            if (status & info->ignore_status_mask)
+            {
+                if (++ignore > 100 )
+                    break;
+                goto ignore_char;
+            }
+            // Mask off the error conditions we want to ignore
+            tmp = status & info->read_status_mask;
+            if (tmp & RXPARERR)
+            {
+                *tty->flip.flag_buf_ptr = TTY_PARITY;
+            }
+            else
+                if (tmp & RXFRAMERR)
+                {
+                    *tty->flip.flag_buf_ptr = TTY_FRAME;
+                }
+            if (tmp & RXOVFERR)
+            {
+                if (tty->flip.count < TTY_FLIPBUF_SIZE)
+                {
+                    tty->flip.count++;
+                    tty->flip.flag_buf_ptr++;
+                    tty->flip.char_buf_ptr++;
+                    *tty->flip.flag_buf_ptr = TTY_OVERRUN;
+                }
+            }
+        }
+        tty->flip.flag_buf_ptr++;
+        tty->flip.char_buf_ptr++;
+        tty->flip.count++;
+    }
+ignore_char:
+    if (tty)
+        tty_flip_buffer_push(tty);
+}
+
+
+/*
+ * ------------------------------------------------------------
+ * bcm_interrupt ()
+ *
+ * this is the main interrupt routine for the chip.
+ * It deals with the multiple ports.
+ * ------------------------------------------------------------
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+static irqreturn_t bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#else
+static void bcm_interrupt (int irq, void * dev, struct pt_regs * regs)
+#endif
+{
+    struct bcm_serial * info = lines[0];
+    UINT16  intStat;
+
+    /* get pending interrupt flags from UART  */
+
+    /* Mask with only the serial interrupts that are enabled */
+    intStat = info->port->intStatus & info->port->intMask;
+    while (intStat)
+    {
+        if (intStat & RXINT)
+            receive_chars (info);          
+        else
+            if (intStat & TXINT)
+                info->port->intStatus = TXINT;
+            else /* don't know what it was, so let's mask it */
+                info->port->intMask &= ~intStat;
+
+        intStat = info->port->intStatus & info->port->intMask;
+    }
+
+    // Clear the interrupt
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    return IRQ_HANDLED;
+#endif    
+}
+
+/*
+ * -------------------------------------------------------------------
+ * startup ()
+ *
+ * various initialization tasks
+ * ------------------------------------------------------------------- 
+ */
+static int startup (struct bcm_serial *info)
+{
+    // Port is already started...
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * shutdown ()
+ *
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ * ------------------------------------------------------------------- 
+ */
+static void shutdown (struct bcm_serial * info)
+{
+    unsigned long flags;
+    if (!info->is_initialized)
+        return;
+
+    save_flags (flags);
+    cli ();
+
+    info->port->control &= ~(BRGEN|TXEN|RXEN);
+    if (info->tty)
+        set_bit (TTY_IO_ERROR, &info->tty->flags);
+    info->is_initialized = 0;
+
+    restore_flags (flags);
+}
+/* 
+ * -------------------------------------------------------------------
+ * change_speed ()
+ *
+ * Set the baud rate, character size, parity and stop bits.
+ * ------------------------------------------------------------------- 
+ */
+static void change_speed( volatile Uart *pUart, tcflag_t cFlag )
+{
+    unsigned long ulFlags, ulBaud, ulClockFreqHz, ulTmp;
+    save_flags(ulFlags);
+    cli();
+    switch( cFlag & (CBAUD | CBAUDEX) )
+    {
+    case B115200:
+        ulBaud = 115200;
+        break;
+    case B57600:
+        ulBaud = 57600;
+        break;
+    case B38400:
+        ulBaud = 38400;
+        break;
+    case B19200:
+        ulBaud = 19200;
+        break;
+    case B9600:
+        ulBaud = 9600;
+        break;
+    case B4800:
+        ulBaud = 4800;
+        break;
+    case B2400:
+        ulBaud = 2400;
+        break;
+    case B1800:
+        ulBaud = 1800;
+        break;
+    case B1200:
+        ulBaud = 1200;
+        break;
+    case B600:
+        ulBaud = 600;
+        break;
+    case B300:
+        ulBaud = 300;
+        break;
+    case B200:
+        ulBaud = 200;
+        break;
+    case B150:
+        ulBaud = 150;
+        break;
+    case B134:
+        ulBaud = 134;
+        break;
+    case B110:
+        ulBaud = 110;
+        break;
+    case B75:
+        ulBaud = 75;
+        break;
+    case B50:
+        ulBaud = 50;
+        break;
+    default:
+        ulBaud = 115200;
+        break;
+    }
+
+    /* Calculate buad rate.  */
+    ulClockFreqHz = BD_BCM63XX_TIMER_CLOCK_INPUT;
+    ulTmp = (ulClockFreqHz / ulBaud) / 16;
+    if( ulTmp & 0x01 )
+        ulTmp /= 2; /* Rounding up, so sub is already accounted for */
+    else
+        ulTmp = (ulTmp / 2) - 1; /* Rounding down so we must sub 1 */
+    pUart->baudword = ulTmp;
+
+    /* Set character size, stop bits and parity.  */
+    switch( cFlag & CSIZE )
+    {
+    case CS5:
+        ulTmp = BITS5SYM; /* select transmit 5 bit data size */
+        break;
+    case CS6:
+        ulTmp = BITS6SYM; /* select transmit 6 bit data size */
+        break;
+    case CS7:
+        ulTmp = BITS7SYM; /* select transmit 7 bit data size */
+        break;
+    /*case CS8:*/
+    default:
+        ulTmp = BITS8SYM; /* select transmit 8 bit data size */
+        break;
+    }
+    if( cFlag & CSTOPB )
+        ulTmp |= TWOSTOP;         /* select 2 stop bits */
+    else
+        ulTmp |= ONESTOP;         /* select one stop bit */
+
+    /* Write these values into the config reg.  */
+    pUart->config = ulTmp;
+    pUart->control &= ~(RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN);
+    switch( cFlag & (PARENB | PARODD) )
+    {
+    case PARENB|PARODD:
+        pUart->control |= RXPARITYEN | TXPARITYEN;
+        break;
+    case PARENB:
+        pUart->control |= RXPARITYEN | TXPARITYEN | RXPARITYEVEN | TXPARITYEVEN;
+        break;
+    default:
+        pUart->control |= 0;
+        break;
+    }
+
+    /* Reset and flush uart */
+    pUart->fifoctl = RSTTXFIFOS | RSTRXFIFOS;
+    restore_flags( ulFlags );
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_char ()
+ *
+ * Nothing to flush.  Polled I/O is used.
+ * ------------------------------------------------------------------- 
+ */
+static void bcm63xx_cons_flush_chars (struct tty_struct *tty)
+{
+}
+
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write ()
+ *
+ * Main output routine using polled I/O.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write (struct tty_struct *tty, int from_user,
+    const unsigned char *buf, int count)
+{
+    int c;
+
+    for (c = 0; c < count; c++)
+        _putc(buf[c]);
+    return count;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm63xx_cons_write_room ()
+ *
+ * Compute the amount of space available for writing.
+ * ------------------------------------------------------------------- 
+ */
+static int bcm63xx_cons_write_room (struct tty_struct *tty)
+{
+    /* Pick a number.  Any number.  Polled I/O is used. */
+    return 1024;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_chars_in_buffer ()
+ *
+ * compute the amount of char left to be transmitted
+ * ------------------------------------------------------------------- 
+ */
+static int bcm_chars_in_buffer (struct tty_struct *tty)
+{
+    return 0;
+}
+
+/* 
+ * -------------------------------------------------------------------
+ * bcm_flush_buffer ()
+ *
+ * Empty the output buffer
+ * ------------------------------------------------------------------- 
+ */
+static void bcm_flush_buffer (struct tty_struct *tty)
+{
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm_throttle () and bcm_unthrottle ()
+ * 
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled (or not).
+ * ------------------------------------------------------------
+ */
+static void bcm_throttle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+        info->x_char = STOP_CHAR(tty);
+}
+
+static void bcm_unthrottle (struct tty_struct *tty)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;  
+    if (I_IXOFF(tty))
+    {
+        if (info->x_char)
+            info->x_char = 0;
+        else
+            info->x_char = START_CHAR(tty);
+    }
+}
+
+static void bcm_send_xchar (struct tty_struct *tty, char ch)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+    info->x_char = ch;
+    if (ch)
+        bcm_start (info->tty);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl () and friends
+ * ------------------------------------------------------------
+ */
+static int get_serial_info(struct bcm_serial *info, struct serial_struct *retinfo)
+{
+    struct serial_struct tmp;
+
+    if (!retinfo)
+        return -EFAULT;
+
+    memset (&tmp, 0, sizeof(tmp));
+    tmp.type            = info->type;
+    tmp.line            = info->line;
+    tmp.port            = (int) info->port;
+    tmp.irq             = info->irq;
+    tmp.flags           = 0;
+    tmp.baud_base       = info->baud_base;
+    tmp.close_delay     = info->close_delay;
+    tmp.closing_wait    = info->closing_wait;
+
+    return copy_to_user (retinfo, &tmp, sizeof(*retinfo));
+}
+
+static int set_serial_info (struct bcm_serial *info, struct serial_struct *new_info)
+{
+    struct serial_struct new_serial;
+    struct bcm_serial old_info;
+    int retval = 0;
+
+    if (!new_info)
+        return -EFAULT;
+
+    copy_from_user (&new_serial, new_info, sizeof(new_serial));
+    old_info = *info;
+
+    if (!capable(CAP_SYS_ADMIN))
+        return -EPERM;
+
+
+    if (info->count > 1)
+        return -EBUSY;
+
+    /* OK, past this point, all the error checking has been done.
+     * At this point, we start making changes.....
+     */
+    info->baud_base = new_serial.baud_base;
+    info->type = new_serial.type;
+    info->close_delay = new_serial.close_delay;
+    info->closing_wait = new_serial.closing_wait;
+    retval = startup (info);
+    return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ *          is emptied.  On bus types like RS485, the transmitter must
+ *          release the bus after transmitting. This must be done when
+ *          the transmit shift register is empty, not be done when the
+ *          transmit holding register is empty.  This functionality
+ *          allows an RS485 driver to be written in user space. 
+ */
+static int get_lsr_info (struct bcm_serial *info, unsigned int *value)
+{
+    return( 0 );
+}
+
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void send_break (struct bcm_serial *info, int duration)
+{
+    unsigned long flags;
+
+    if (!info->port)
+        return;
+
+    current->state = TASK_INTERRUPTIBLE;
+
+    save_flags (flags);
+    cli();
+
+    info->port->control |= XMITBREAK;
+    schedule_timeout(duration);
+    info->port->control &= ~XMITBREAK;
+
+    restore_flags (flags);
+}
+
+static int bcm_ioctl (struct tty_struct * tty, struct file * file,
+    unsigned int cmd, unsigned long arg)
+{
+    int error;
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    int retval;
+
+    if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+        (cmd != TIOCSERCONFIG) && (cmd != TIOCSERGWILD)  &&
+        (cmd != TIOCSERSWILD) && (cmd != TIOCSERGSTRUCT))
+    {
+        if (tty->flags & (1 << TTY_IO_ERROR))
+            return -EIO;
+    }
+    switch (cmd) 
+    {
+
+    case TCSBRK:    /* SVID version: non-zero arg --> no break */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        if (!arg)
+            send_break (info, HZ/4); /* 1/4 second */
+        return 0;
+
+    case TCSBRKP:   /* support for POSIX tcsendbreak() */
+        retval = tty_check_change (tty);
+        if (retval)
+            return retval;
+        tty_wait_until_sent (tty, 0);
+        send_break (info, arg ? arg*(HZ/10) : HZ/4);
+        return 0;
+
+    case TIOCGSOFTCAR:
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(long));
+        if (error)
+            return error;
+        put_user (C_CLOCAL(tty) ? 1 : 0, (unsigned long *)arg);
+        return 0;
+
+    case TIOCSSOFTCAR:
+        error = get_user (arg, (unsigned long *)arg);
+        if (error)
+            return error;
+        tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+        return 0;
+
+    case TIOCGSERIAL:
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(struct serial_struct));
+        if (error)
+            return error;
+        return get_serial_info (info, (struct serial_struct *)arg);
+
+    case TIOCSSERIAL:
+        return set_serial_info (info, (struct serial_struct *) arg);
+
+    case TIOCSERGETLSR: /* Get line status register */
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(unsigned int));
+        if (error)
+            return error;
+        else
+            return get_lsr_info (info, (unsigned int *)arg);
+
+    case TIOCSERGSTRUCT:
+        error = verify_area (VERIFY_WRITE, (void *)arg, sizeof(struct bcm_serial));
+        if (error)
+            return error;
+        copy_to_user((struct bcm_serial *)arg, info, sizeof(struct bcm_serial));
+        return 0;
+
+    default:
+        return -ENOIOCTLCMD;
+    }
+    return 0;
+}
+
+static void bcm_set_termios (struct tty_struct *tty, struct termios *old_termios)
+{
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    if( tty->termios->c_cflag != old_termios->c_cflag )
+        change_speed (info->port, tty->termios->c_cflag);
+}
+
+/*
+ * ------------------------------------------------------------
+ * bcm63xx_cons_close()
+ * 
+ * This routine is called when the serial port gets closed.  First, we
+ * wait for the last remaining data to be sent.  Then, we turn off
+ * the transmit enable and receive enable flags.
+ * ------------------------------------------------------------
+ */
+static void bcm63xx_cons_close (struct tty_struct *tty, struct file *filp)
+{
+    struct bcm_serial * info = (struct bcm_serial *)tty->driver_data;
+    unsigned long flags;
+
+    if (!info)
+        return;
+
+    save_flags (flags); 
+    cli();
+
+    if (tty_hung_up_p (filp))
+    {
+        restore_flags (flags);
+        return;
+    }
+
+    if ((tty->count == 1) && (info->count != 1))
+    {
+
+        /* Uh, oh.  tty->count is 1, which means that the tty
+         * structure will be freed.  Info->count should always
+         * be one in these conditions.  If it's greater than
+         * one, we've got real problems, since it means the
+         * serial port won't be shutdown.
+         */
+        printk("bcm63xx_cons_close: bad serial port count; tty->count is 1, "
+            "info->count is %d\n", info->count);
+        info->count = 1;
+    }
+
+    if (--info->count < 0)
+    {
+        printk("ds_close: bad serial port count for ttys%d: %d\n",
+        info->line, info->count);
+        info->count = 0;
+    }
+
+    if (info->count)
+    {
+        restore_flags (flags);
+        return;
+    }
+
+    /* Now we wait for the transmit buffer to clear; and we notify 
+     * the line discipline to only process XON/XOFF characters.
+     */
+    tty->closing = 1;
+
+    /* At this point we stop accepting input.  To do this, we
+     * disable the receive line status interrupts.
+     */
+    shutdown (info);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    if (tty->driver->flush_buffer)
+        tty->driver->flush_buffer (tty);
+#else    
+    if (tty->driver.flush_buffer)
+        tty->driver.flush_buffer (tty);
+#endif
+    if (tty->ldisc.flush_buffer)
+        tty->ldisc.flush_buffer (tty);
+
+    tty->closing = 0;
+    info->event = 0;
+    info->tty = 0;
+    if (tty->ldisc.num != ldiscs[N_TTY].num)
+    {
+        if (tty->ldisc.close)
+            (tty->ldisc.close)(tty);
+        tty->ldisc = ldiscs[N_TTY];
+        tty->termios->c_line = N_TTY;
+        if (tty->ldisc.open)
+            (tty->ldisc.open)(tty);
+    }
+    if (info->blocked_open)
+    {
+        if (info->close_delay)
+        {
+            current->state = TASK_INTERRUPTIBLE;
+            schedule_timeout(info->close_delay);
+        }
+        wake_up_interruptible (&info->open_wait);
+    }
+    wake_up_interruptible (&info->close_wait);
+
+    restore_flags (flags);
+}
+
+/*
+ * bcm_hangup () --- called by tty_hangup() when a hangup is signaled.
+ */
+static void bcm_hangup (struct tty_struct *tty)
+{
+
+    struct bcm_serial *info = (struct bcm_serial *)tty->driver_data;
+
+    shutdown (info);
+    info->event = 0;
+    info->count = 0;
+    info->tty = 0;
+    wake_up_interruptible (&info->open_wait);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_open() and friends
+ * ------------------------------------------------------------
+ */
+static int block_til_ready (struct tty_struct *tty, struct file *filp,
+    struct bcm_serial *info)
+{
+    return 0;
+}       
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port. It also performs the 
+ * serial-specific initialization for the tty structure.
+ */
+static int bcm63xx_cons_open (struct tty_struct * tty, struct file * filp)
+{
+    struct bcm_serial *info;
+    int retval, line;
+
+    // Make sure we're only opening on of the ports we support
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    line = MINOR(tty->driver->cdev.dev) - tty->driver->minor_start;
+#else
+    line = MINOR(tty->device) - tty->driver.minor_start;
+#endif    
+
+    if ((line < 0) || (line >= BCM_NUM_UARTS))
+        return -ENODEV;
+
+    info = lines[line];
+
+    info->port->intMask  = 0;     /* Clear any pending interrupts */
+    info->port->intMask  = RXINT; /* Enable RX */
+
+    info->count++;
+    tty->driver_data = info;
+    info->tty = tty;
+    BcmHalInterruptEnable (INTERRUPT_ID_UART);
+
+    // Start up serial port
+    retval = startup (info);
+    if (retval)
+        return retval;
+
+    retval = block_til_ready (tty, filp, info);
+    if (retval)
+        return retval;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+    info->pgrp = process_group(current);
+    info->session = current->signal->session;
+#else
+    info->session = current->session;    
+    info->pgrp = current->pgrp;
+#endif    
+
+    return 0;
+}
+
+/* --------------------------------------------------------------------------
+    Name: bcm63xx_serialinit
+ Purpose: Initialize our BCM63xx serial driver
+-------------------------------------------------------------------------- */
+static int __init bcm63xx_serialinit(void)
+{
+    int i, flags;
+    struct bcm_serial * info;
+
+    // Print the driver version information
+    printk(VER_STR);
+
+    memset(&serial_driver, 0, sizeof(struct tty_driver));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)     
+    serial_driver.owner 	    = THIS_MODULE;
+    serial_driver.devfs_name 	    = "tts/";
+#endif    
+    serial_driver.magic             = TTY_DRIVER_MAGIC;
+    serial_driver.name              = "ttyS";
+    serial_driver.major             = TTY_MAJOR;
+    serial_driver.minor_start       = 64;
+    serial_driver.num               = BCM_NUM_UARTS;
+    serial_driver.type              = TTY_DRIVER_TYPE_SERIAL;
+    serial_driver.subtype           = SERIAL_TYPE_NORMAL;
+    serial_driver.init_termios      = tty_std_termios;
+    serial_driver.init_termios.c_cflag = B115200 | CS8 | CREAD | CLOCAL;
+    serial_driver.flags             = TTY_DRIVER_REAL_RAW;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)    
+    serial_driver.refcount          = serial_refcount;
+    serial_driver.ttys	            = serial_table;    
+#else
+    serial_driver.refcount          = &serial_refcount;
+    serial_driver.table             = serial_table;    
+#endif    
+
+    serial_driver.termios           = serial_termios;
+    serial_driver.termios_locked    = serial_termios_locked;
+    serial_driver.open              = bcm63xx_cons_open;
+    serial_driver.close             = bcm63xx_cons_close;
+    serial_driver.write             = bcm63xx_cons_write;
+    serial_driver.flush_chars       = bcm63xx_cons_flush_chars;
+    serial_driver.write_room        = bcm63xx_cons_write_room;
+    serial_driver.chars_in_buffer   = bcm_chars_in_buffer;
+    serial_driver.flush_buffer      = bcm_flush_buffer;
+    serial_driver.ioctl             = bcm_ioctl;
+    serial_driver.throttle          = bcm_throttle;
+    serial_driver.unthrottle        = bcm_unthrottle;
+    serial_driver.send_xchar        = bcm_send_xchar;
+    serial_driver.set_termios       = bcm_set_termios;
+    serial_driver.stop              = bcm_stop;
+    serial_driver.start             = bcm_start;
+    serial_driver.hangup            = bcm_hangup;
+
+    if (tty_register_driver (&serial_driver))
+        panic("Couldn't register serial driver\n");
+
+    save_flags(flags); cli();
+    for (i = 0; i < BCM_NUM_UARTS; i++)
+    {
+        info = &multi[i]; 
+        lines[i] = info;
+        info->port                  = (Uart *) ((char *)UART_BASE + (i * 0x20));
+        info->irq                   = (2 - i) + 8;
+        info->line                  = i;
+        info->tty                   = 0;
+        info->close_delay           = 50;
+        info->closing_wait          = 3000;
+        info->x_char                = 0;
+        info->event                 = 0;
+        info->count                 = 0;
+        info->blocked_open          = 0;	
+        info->normal_termios        = serial_driver.init_termios;
+        init_waitqueue_head(&info->open_wait); 
+        init_waitqueue_head(&info->close_wait); 
+
+        /* If we are pointing to address zero then punt - not correctly
+         * set up in setup.c to handle this. 
+         */
+        if (! info->port)
+            return 0;
+        BcmHalMapInterrupt(bcm_interrupt, 0, INTERRUPT_ID_UART);
+    }
+
+    /* order matters here... the trick is that flags
+     * is updated... in request_irq - to immediatedly obliterate
+     * it is unwise. 
+     */
+    restore_flags(flags);
+    return 0;
+}
+
+module_init(bcm63xx_serialinit);
+
+/* --------------------------------------------------------------------------
+    Name: bcm_console_print
+ Purpose: bcm_console_print is registered for printk.
+          The console_lock must be held when we get here.
+-------------------------------------------------------------------------- */
+static void bcm_console_print (struct console * cons, const char * str,
+    unsigned int count)
+{
+    unsigned int i;
+    //_puts(str);
+    for(i=0; i<count; i++, str++)
+    {
+        _putc(*str);
+        if (*str == 10)
+        {
+            _putc(13);
+        }
+    }
+}
+
+static struct tty_driver * bcm_console_device(struct console * c, int *index)
+{
+    *index = c->index;
+    return &serial_driver;
+}
+
+static int __init bcm_console_setup(struct console * co, char * options)
+{
+    return 0;
+}
+
+static struct console bcm_sercons = {
+    .name	= "ttyS",
+    .write	= bcm_console_print,
+    .device	= bcm_console_device,
+    .setup	= bcm_console_setup,
+    .flags	= CON_PRINTBUFFER, // CON_CONSDEV, CONSOLE_LINE,
+    .index	= -1,
+};
+
+static int __init bcm63xx_console_init(void)
+{
+    register_console(&bcm_sercons);
+    return 0;
+}
+
+console_initcall(bcm63xx_console_init);
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6338_intr.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6338_intr.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6338_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6338_intr.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6338_INTR_H
+#define __6338_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/*=====================================================================*/
+/* BCM6338 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6338 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+#define INTERRUPT_ID_TIMER               (INTERNAL_ISR_TABLE_OFFSET + 0)
+#define INTERRUPT_ID_SPI                 (INTERNAL_ISR_TABLE_OFFSET + 1)
+#define INTERRUPT_ID_UART                (INTERNAL_ISR_TABLE_OFFSET + 2)
+#define INTERRUPT_ID_DG                  (INTERNAL_ISR_TABLE_OFFSET + 4)
+#define INTERRUPT_ID_ADSL                (INTERNAL_ISR_TABLE_OFFSET + 5)
+#define INTERRUPT_ID_ATM                 (INTERNAL_ISR_TABLE_OFFSET + 6)
+#define INTERRUPT_ID_USBS                (INTERNAL_ISR_TABLE_OFFSET + 7)
+#define INTERRUPT_ID_EMAC1               (INTERNAL_ISR_TABLE_OFFSET + 8)
+#define INTERRUPT_ID_EPHY                (INTERNAL_ISR_TABLE_OFFSET + 9)
+#define INTERRUPT_ID_SDRAM               (INTERNAL_ISR_TABLE_OFFSET + 10)
+#define INTERRUPT_ID_USB_CNTL_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 11)
+#define INTERRUPT_ID_USB_CNTL_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 12)
+#define INTERRUPT_ID_USB_BULK_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 13)
+#define INTERRUPT_ID_USB_BULK_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 14)
+#define INTERRUPT_ID_EMAC1_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 15)
+#define INTERRUPT_ID_EMAC1_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 16)
+#define INTERRUPT_ID_SDIO                (INTERNAL_ISR_TABLE_OFFSET + 17)
+
+#ifdef __cplusplus
+    }
+#endif                    
+
+#endif  /* __BCM6338_H */
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6338_map_part.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,341 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6338_MAP_H
+#define __BCM6338_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+
+#define PERF_BASE           0xfffe0000
+#define TIMR_BASE           0xfffe0200 
+#define UART_BASE           0xfffe0300
+#define GPIO_BASE           0xfffe0400
+#define SPI_BASE            0xfffe0c00
+
+typedef struct PerfControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define EMAC_CLK_EN     0x0010
+#define USBS_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+
+#define SPI_CLK_EN      0x0200
+
+  uint32        pll_control;
+#define SOFT_RESET 0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint32        unused0;
+  uint32        GPIODir;      /* bits 7:0 */
+  uint32        unused1;
+  uint32        GPIOio;       /* bits 7:0 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        vRegConfig;
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+/*
+** Spi Controller
+*/
+
+typedef struct SpiControl {
+  uint16        spiCmd;                 /* (0x0): SPI command */
+#define SPI_CMD_START_IMMEDIATE         3
+
+#define SPI_CMD_COMMAND_SHIFT           0
+#define SPI_CMD_DEVICE_ID_SHIFT         4
+#define SPI_CMD_PREPEND_BYTE_CNT_SHIFT  8
+
+  byte          spiIntStatus;           /* (0x2): SPI interrupt status */
+  byte          spiMaskIntStatus;       /* (0x3): SPI masked interrupt status */
+
+  byte          spiIntMask;             /* (0x4): SPI interrupt mask */
+#define SPI_INTR_CMD_DONE               0x01
+#define SPI_INTR_CLEAR_ALL              0x1f
+
+  byte          spiStatus;              /* (0x5): SPI status */
+
+  byte          spiClkCfg;              /* (0x6): SPI clock configuration */
+
+  byte          spiFillByte;            /* (0x7): SPI fill byte */
+
+  byte          unused0; 
+  byte          spiMsgTail;             /* (0x9): msgtail */
+  byte          unused1; 
+  byte          spiRxTail;              /* (0xB): rxtail */
+
+  uint32        unused2[13];            /* (0x0c - 0x3c) reserved */
+
+  byte          spiMsgCtl;              /* (0x40) control byte */
+#define HALF_DUPLEX_W                   1
+#define HALF_DUPLEX_R                   2
+#define SPI_MSG_TYPE_SHIFT              6
+#define SPI_BYTE_CNT_SHIFT              0
+  byte          spiMsgData[63];         /* (0x41 - 0x7f) msg data */
+  byte          spiRxDataFifo[64];      /* (0x80 - 0xbf) rx data */
+  byte          unused3[64];            /* (0xc0 - 0xff) reserved */
+} SpiControl;
+
+#define SPI ((volatile SpiControl * const) SPI_BASE)
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[1];                  /* size chip select configuration */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6345_intr.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6345_intr.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6345_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6345_intr.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6345_INTR_H
+#define __6345_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/*=====================================================================*/
+/* BCM6345 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6345 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+#define DMA_ISR_TABLE_OFFSET            (INTERNAL_ISR_TABLE_OFFSET + 13)
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+/* Internal peripheral interrupt IDs */
+#define INTERRUPT_ID_TIMER              (INTERNAL_ISR_TABLE_OFFSET +  0)
+#define INTERRUPT_ID_UART               (INTERNAL_ISR_TABLE_OFFSET +  2)
+#define INTERRUPT_ID_ADSL               (INTERNAL_ISR_TABLE_OFFSET +  3)
+#define INTERRUPT_ID_ATM                (INTERNAL_ISR_TABLE_OFFSET +  4)
+#define INTERRUPT_ID_USB                (INTERNAL_ISR_TABLE_OFFSET +  5)
+#define INTERRUPT_ID_EMAC               (INTERNAL_ISR_TABLE_OFFSET +  8)
+#define INTERRUPT_ID_EPHY               (INTERNAL_ISR_TABLE_OFFSET +  12)
+
+/* DMA channel interrupt IDs */        
+#define INTERRUPT_ID_EMAC_RX_CHAN       (DMA_ISR_TABLE_OFFSET + EMAC_RX_CHAN)
+#define INTERRUPT_ID_EMAC_TX_CHAN       (DMA_ISR_TABLE_OFFSET + EMAC_TX_CHAN)
+#define INTERRUPT_ID_EBI_RX_CHAN        (DMA_ISR_TABLE_OFFSET + EBI_RX_CHAN)
+#define INTERRUPT_ID_EBI_TX_CHAN        (DMA_ISR_TABLE_OFFSET + EBI_TX_CHAN)
+#define INTERRUPT_ID_RESERVED_RX_CHAN   (DMA_ISR_TABLE_OFFSET + RESERVED_RX_CHAN)
+#define INTERRUPT_ID_RESERVED_TX_CHAN   (DMA_ISR_TABLE_OFFSET + RESERVED_TX_CHAN)
+#define INTERRUPT_ID_USB_BULK_RX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_BULK_RX_CHAN)
+#define INTERRUPT_ID_USB_BULK_TX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_BULK_TX_CHAN)
+#define INTERRUPT_ID_USB_CNTL_RX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_CNTL_RX_CHAN)
+#define INTERRUPT_ID_USB_CNTL_TX_CHAN   (DMA_ISR_TABLE_OFFSET + USB_CNTL_TX_CHAN)
+#define INTERRUPT_ID_USB_ISO_RX_CHAN    (DMA_ISR_TABLE_OFFSET + USB_ISO_RX_CHAN)
+#define INTERRUPT_ID_USB_ISO_TX_CHAN    (DMA_ISR_TABLE_OFFSET + USB_ISO_TX_CHAN)
+
+#ifdef __cplusplus
+    }
+#endif                    
+
+#endif  /* __BCM6345_H */
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6345_map_part.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,169 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6345_MAP_H
+#define __BCM6345_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+#include "6345_intr.h"
+
+typedef struct IntControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define USB_CLK_EN      0x0100
+#define EMAC_CLK_EN     0x0080
+#define UART_CLK_EN     0x0008
+#define CPU_CLK_EN      0x0001
+
+  uint32        pll_control;
+#define SOFT_RESET	0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  4
+#define EI_CLEAR_SHFT   8
+#define EI_MASK_SHFT    12
+#define EI_INSENS_SHFT  16
+#define EI_LEVEL_SHFT   20
+} IntControl;
+
+#define INTC_BASE     0xfffe0000
+#define PERF ((volatile IntControl * const) INTC_BASE)
+
+#define TIMR_BASE     0xfffe0200    
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+  byte          config;
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define XMITBREAK       0x40
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  uint32        baudword;
+
+  byte          txf_levl;
+  byte          rxf_levl;
+  byte          fifocfg;
+  byte          prog_out;
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;
+  byte          DeltaIPConfig_Mask;
+  byte          DeltaIP_SyncIP;
+  uint16        intMask;
+  uint16        intStatus;
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOEMT       0x0020
+#define RXOVFERR        0x0080
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART_BASE     0xfffe0300
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint16        unused0;
+  byte          unused1;
+  byte          TBusSel;
+
+  uint16        unused2;
+  uint16        GPIODir;
+  byte          unused3;
+  byte          Leds;
+  uint16        GPIOio;
+
+  uint32        UartCtl;
+} GpioControl;
+
+#define GPIO_BASE     0xfffe0400
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+#define GPIO_NUM_MAX_BITS_MASK          0x0f
+#define GPIO_NUM_TO_MASK(X)             (1 << ((X) & GPIO_NUM_MAX_BITS_MASK))
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6348_intr.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6348_intr.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6348_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6348_intr.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,80 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __6348_INTR_H
+#define __6348_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+/*=====================================================================*/
+/* BCM6348 External Interrupt Level Assignments                       */
+/*=====================================================================*/
+#define INTERRUPT_ID_EXTERNAL_0         3
+#define INTERRUPT_ID_EXTERNAL_1         4
+#define INTERRUPT_ID_EXTERNAL_2         5
+#define INTERRUPT_ID_EXTERNAL_3         6
+
+/*=====================================================================*/
+/* BCM6348 Timer Interrupt Level Assignments                          */
+/*=====================================================================*/
+#define MIPS_TIMER_INT                  7
+
+/*=====================================================================*/
+/* Peripheral ISR Table Offset                                              */
+/*=====================================================================*/
+#define INTERNAL_ISR_TABLE_OFFSET       8
+
+/*=====================================================================*/
+/* Logical Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+
+#define INTERRUPT_ID_TIMER               (INTERNAL_ISR_TABLE_OFFSET + 0)
+#define INTERRUPT_ID_SPI                 (INTERNAL_ISR_TABLE_OFFSET + 1)
+#define INTERRUPT_ID_UART                (INTERNAL_ISR_TABLE_OFFSET + 2)
+#define INTERRUPT_ID_ADSL                (INTERNAL_ISR_TABLE_OFFSET + 4)
+#define INTERRUPT_ID_ATM                 (INTERNAL_ISR_TABLE_OFFSET + 5)
+#define INTERRUPT_ID_USBS                (INTERNAL_ISR_TABLE_OFFSET + 6)
+#define INTERRUPT_ID_EMAC2               (INTERNAL_ISR_TABLE_OFFSET + 7)
+#define INTERRUPT_ID_EMAC1               (INTERNAL_ISR_TABLE_OFFSET + 8)
+#define INTERRUPT_ID_EPHY                (INTERNAL_ISR_TABLE_OFFSET + 9)
+#define INTERRUPT_ID_M2M                 (INTERNAL_ISR_TABLE_OFFSET + 10)
+#define INTERRUPT_ID_ACLC                (INTERNAL_ISR_TABLE_OFFSET + 11)
+#define INTERRUPT_ID_USBH                (INTERNAL_ISR_TABLE_OFFSET + 12)
+#define INTERRUPT_ID_SDRAM               (INTERNAL_ISR_TABLE_OFFSET + 13)
+#define INTERRUPT_ID_USB_CNTL_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 14)
+#define INTERRUPT_ID_USB_CNTL_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 15)
+#define INTERRUPT_ID_USB_BULK_RX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 16)
+#define INTERRUPT_ID_USB_BULK_TX_DMA     (INTERNAL_ISR_TABLE_OFFSET + 17)
+#define INTERRUPT_ID_USB_ISO_RX_DMA      (INTERNAL_ISR_TABLE_OFFSET + 18)
+#define INTERRUPT_ID_USB_ISO_TX_DMA      (INTERNAL_ISR_TABLE_OFFSET + 19)
+#define INTERRUPT_ID_EMAC1_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 20)
+#define INTERRUPT_ID_EMAC1_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 21)
+#define INTERRUPT_ID_EMAC2_RX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 22)
+#define INTERRUPT_ID_EMAC2_TX_DMA        (INTERNAL_ISR_TABLE_OFFSET + 23)
+#define INTERRUPT_ID_MPI                 (INTERNAL_ISR_TABLE_OFFSET + 24)
+#define INTERRUPT_ID_DG                  (INTERNAL_ISR_TABLE_OFFSET + 25)
+
+#ifdef __cplusplus
+    }
+#endif                    
+
+#endif  /* __BCM6348_H */
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/6348_map_part.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,508 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM6348_MAP_H
+#define __BCM6348_MAP_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#include "bcmtypes.h"
+
+#define PERF_BASE           0xfffe0000
+#define TIMR_BASE           0xfffe0200    
+#define UART_BASE           0xfffe0300
+#define GPIO_BASE           0xfffe0400
+#define MPI_BASE            0xfffe2000    /* MPI control registers */
+#define USB_HOST_BASE       0xfffe1b00    /* USB host registers */
+#define USB_HOST_NON_OHCI   0xfffe1c00    /* USB host non-OHCI registers */
+
+typedef struct PerfControl {
+  uint32        RevID;
+  uint16        testControl;
+  uint16        blkEnables;
+#define EMAC_CLK_EN     0x0010
+#define SAR_CLK_EN      0x0020
+#define USBS_CLK_EN     0x0040
+#define USBH_CLK_EN     0x0100
+
+  uint32        pll_control;
+#define SOFT_RESET 0x00000001
+
+  uint32        IrqMask;
+  uint32        IrqStatus;
+
+  uint32        ExtIrqCfg;
+#define EI_SENSE_SHFT   0
+#define EI_STATUS_SHFT  5
+#define EI_CLEAR_SHFT   10
+#define EI_MASK_SHFT    15
+#define EI_INSENS_SHFT  20
+#define EI_LEVEL_SHFT   25
+
+  uint32        unused[4];      /* (18) */
+  uint32        BlockSoftReset; /* (28) */
+#define BSR_SPI             0x00000001
+#define BSR_EMAC            0x00000004
+#define BSR_USBH            0x00000008
+#define BSR_USBS            0x00000010
+#define BSR_ADSL            0x00000020
+#define BSR_DMAMEM          0x00000040
+#define BSR_SAR             0x00000080
+#define BSR_ACLC            0x00000100
+#define BSR_ADSL_MIPS_PLL   0x00000400
+#define BSR_ALL_BLOCKS      \
+    (BSR_SPI | BSR_EMAC | BSR_USBH | BSR_USBS | BSR_ADSL | BSR_DMAMEM | \
+     BSR_SAR | BSR_ACLC | BSR_ADSL_MIPS_PLL) 
+  uint32        unused2[2];     /* (2c) */
+  uint32        PllStrap;       /* (34) */
+#define PLL_N1_SHFT         20
+#define PLL_N1_MASK         (7<<PLL_N1_SHFT)
+#define PLL_N2_SHFT         15
+#define PLL_N2_MASK         (0x1f<<PLL_N2_SHFT)
+#define PLL_M1_REF_SHFT     12
+#define PLL_M1_REF_MASK     (7<<PLL_M1_REF_SHFT)
+#define PLL_M2_REF_SHFT     9
+#define PLL_M2_REF_MASK     (7<<PLL_M2_REF_SHFT)
+#define PLL_M1_CPU_SHFT     6
+#define PLL_M1_CPU_MASK     (7<<PLL_M1_CPU_SHFT)
+#define PLL_M1_BUS_SHFT     3
+#define PLL_M1_BUS_MASK     (7<<PLL_M1_BUS_SHFT)
+#define PLL_M2_BUS_SHFT     0
+#define PLL_M2_BUS_MASK     (7<<PLL_M2_BUS_SHFT)
+} PerfControl;
+
+#define PERF ((volatile PerfControl * const) PERF_BASE)
+
+typedef struct Timer {
+  uint16        unused0;
+  byte          TimerMask;
+#define TIMER0EN        0x01
+#define TIMER1EN        0x02
+#define TIMER2EN        0x04
+  byte          TimerInts;
+#define TIMER0          0x01
+#define TIMER1          0x02
+#define TIMER2          0x04
+#define WATCHDOG        0x08
+  uint32        TimerCtl0;
+  uint32        TimerCtl1;
+  uint32        TimerCtl2;
+#define TIMERENABLE     0x80000000
+#define RSTCNTCLR       0x40000000      
+  uint32        TimerCnt0;
+  uint32        TimerCnt1;
+  uint32        TimerCnt2;
+  uint32        WatchDogDefCount;
+
+  /* Write 0xff00 0x00ff to Start timer
+   * Write 0xee00 0x00ee to Stop and re-load default count
+   * Read from this register returns current watch dog count
+   */
+  uint32        WatchDogCtl;
+
+  /* Number of 40-MHz ticks for WD Reset pulse to last */
+  uint32        WDResetCount;
+} Timer;
+
+#define TIMER ((volatile Timer * const) TIMR_BASE)
+
+typedef struct UartChannel {
+  byte          unused0;
+  byte          control;
+#define BRGEN           0x80    /* Control register bit defs */
+#define TXEN            0x40
+#define RXEN            0x20
+#define LOOPBK          0x10
+#define TXPARITYEN      0x08
+#define TXPARITYEVEN    0x04
+#define RXPARITYEN      0x02
+#define RXPARITYEVEN    0x01
+
+  byte          config;
+#define XMITBREAK       0x40
+#define BITS5SYM        0x00
+#define BITS6SYM        0x10
+#define BITS7SYM        0x20
+#define BITS8SYM        0x30
+#define ONESTOP         0x07
+#define TWOSTOP         0x0f
+  /* 4-LSBS represent STOP bits/char
+   * in 1/8 bit-time intervals.  Zero
+   * represents 1/8 stop bit interval.
+   * Fifteen represents 2 stop bits.
+   */
+  byte          fifoctl;
+#define RSTTXFIFOS      0x80
+#define RSTRXFIFOS      0x40
+  /* 5-bit TimeoutCnt is in low bits of this register.
+   *  This count represents the number of characters 
+   *  idle times before setting receive Irq when below threshold
+   */
+  uint32        baudword;
+  /* When divide SysClk/2/(1+baudword) we should get 32*bit-rate
+   */
+
+  byte          txf_levl;       /* Read-only fifo depth */
+  byte          rxf_levl;       /* Read-only fifo depth */
+  byte          fifocfg;        /* Upper 4-bits are TxThresh, Lower are
+                                 *      RxThreshold.  Irq can be asserted
+                                 *      when rx fifo> thresh, txfifo<thresh
+                                 */
+  byte          prog_out;       /* Set value of DTR (Bit0), RTS (Bit1)
+                                 *  if these bits are also enabled to GPIO_o
+                                 */
+#define	DTREN	0x01
+#define	RTSEN	0x02
+
+  byte          unused1;
+  byte          DeltaIPEdgeNoSense;     /* Low 4-bits, set corr bit to 1 to 
+                                         * detect irq on rising AND falling 
+                                         * edges for corresponding GPIO_i
+                                         * if enabled (edge insensitive)
+                                         */
+  byte          DeltaIPConfig_Mask;     /* Upper 4 bits: 1 for posedge sense
+                                         *      0 for negedge sense if
+                                         *      not configured for edge
+                                         *      insensitive (see above)
+                                         * Lower 4 bits: Mask to enable change
+                                         *  detection IRQ for corresponding
+                                         *  GPIO_i
+                                         */
+  byte          DeltaIP_SyncIP;         /* Upper 4 bits show which bits
+                                         *  have changed (may set IRQ).
+                                         *  read automatically clears bit
+                                         * Lower 4 bits are actual status
+                                         */
+
+  uint16        intMask;				/* Same Bit defs for Mask and status */
+  uint16        intStatus;
+#define DELTAIP         0x0001
+#define TXUNDERR        0x0002
+#define TXOVFERR        0x0004
+#define TXFIFOTHOLD     0x0008
+#define TXREADLATCH     0x0010
+#define TXFIFOEMT       0x0020
+#define RXUNDERR        0x0040
+#define RXOVFERR        0x0080
+#define RXTIMEOUT       0x0100
+#define RXFIFOFULL      0x0200
+#define RXFIFOTHOLD     0x0400
+#define RXFIFONE        0x0800
+#define RXFRAMERR       0x1000
+#define RXPARERR        0x2000
+#define RXBRK           0x4000
+
+  uint16        unused2;
+  uint16        Data;                   /* Write to TX, Read from RX */
+                                        /* bits 11:8 are BRK,PAR,FRM errors */
+
+  uint32		unused3;
+  uint32		unused4;
+} Uart;
+
+#define UART ((volatile Uart * const) UART_BASE)
+
+typedef struct GpioControl {
+  uint32        GPIODir_high; /* bits 36:32 */
+  uint32        GPIODir;      /* bits 31:00 */
+  uint32        GPIOio_high;  /* bits 36:32 */
+  uint32        GPIOio;       /* bits 31:00 */
+  uint32        LEDCtrl;
+#define         LED3_STROBE             0x08000000
+#define         LED2_STROBE             0x04000000
+#define         LED1_STROBE             0x02000000
+#define         LED0_STROBE             0x01000000
+#define         LED_TEST                0x00010000
+#define         LED3_DISABLE_LINK_ACT   0x00008000
+#define         LED2_DISABLE_LINK_ACT   0x00004000
+#define         LED1_DISABLE_LINK_ACT   0x00002000
+#define         LED0_DISABLE_LINK_ACT   0x00001000
+#define         LED_INTERVAL_SET_MASK   0x00000f00
+#define         LED_INTERVAL_SET_320MS  0x00000500
+#define         LED_INTERVAL_SET_160MS  0x00000400
+#define         LED_INTERVAL_SET_80MS   0x00000300
+#define         LED_INTERVAL_SET_40MS   0x00000200
+#define         LED_INTERVAL_SET_20MS   0x00000100
+#define         LED3_ON                 0x00000080
+#define         LED2_ON                 0x00000040
+#define         LED1_ON                 0x00000020
+#define         LED0_ON                 0x00000010
+#define         LED3_ENABLE             0x00000008
+#define         LED2_ENABLE             0x00000004
+#define         LED1_ENABLE             0x00000002
+#define         LED0_ENABLE             0x00000001
+  uint32        SpiSlaveCfg;
+#define         SPI_SLAVE_RESET         0x00010000
+#define         SPI_RESTRICT            0x00000400
+#define         SPI_DELAY_DISABLE       0x00000200
+#define         SPI_PROBE_MUX_SEL_MASK  0x000001e0
+#define         SPI_SER_ADDR_CFG_MASK   0x0000000c
+#define         SPI_MODE                0x00000001
+  uint32        GPIOMode;
+#define         GROUP4_DIAG             0x00090000
+#define         GROUP4_UTOPIA           0x00080000
+#define         GROUP4_LEGACY_LED       0x00030000
+#define         GROUP4_MII_SNOOP        0x00020000
+#define         GROUP4_EXT_EPHY         0x00010000
+#define         GROUP3_DIAG             0x00009000
+#define         GROUP3_UTOPIA           0x00008000
+#define         GROUP3_EXT_MII          0x00007000
+#define         GROUP2_DIAG             0x00000900
+#define         GROUP2_PCI              0x00000500
+#define         GROUP1_DIAG             0x00000090
+#define         GROUP1_UTOPIA           0x00000080
+#define         GROUP1_SPI_UART         0x00000060
+#define         GROUP1_SPI_MASTER       0x00000060
+#define         GROUP1_MII_PCCARD       0x00000040
+#define         GROUP1_MII_SNOOP        0x00000020
+#define         GROUP1_EXT_EPHY         0x00000010
+#define         GROUP0_DIAG             0x00000009
+#define         GROUP0_EXT_MII          0x00000007
+
+} GpioControl;
+
+#define GPIO ((volatile GpioControl * const) GPIO_BASE)
+
+/* Number to mask conversion macro used for GPIODir and GPIOio */
+#define GPIO_NUM_TOTAL_BITS_MASK        0x3f
+#define GPIO_NUM_MAX_BITS_MASK          0x1f
+#define GPIO_NUM_TO_MASK(X)             ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) < 32) ? (1 << ((X) & GPIO_NUM_MAX_BITS_MASK)) : (0) )
+
+/* Number to mask conversion macro used for GPIODir_high and GPIOio_high */
+#define GPIO_NUM_MAX_BITS_MASK_HIGH     0x07
+#define GPIO_NUM_TO_MASK_HIGH(X)        ( (((X) & GPIO_NUM_TOTAL_BITS_MASK) >= 32) ? (1 << ((X-32) & GPIO_NUM_MAX_BITS_MASK_HIGH)) : (0) )
+
+
+/*
+** External Bus Interface
+*/
+typedef struct EbiChipSelect {
+  uint32        base;                   /* base address in upper 24 bits */
+#define EBI_SIZE_8K         0
+#define EBI_SIZE_16K        1
+#define EBI_SIZE_32K        2
+#define EBI_SIZE_64K        3
+#define EBI_SIZE_128K       4
+#define EBI_SIZE_256K       5
+#define EBI_SIZE_512K       6
+#define EBI_SIZE_1M         7
+#define EBI_SIZE_2M         8
+#define EBI_SIZE_4M         9
+#define EBI_SIZE_8M         10
+#define EBI_SIZE_16M        11
+#define EBI_SIZE_32M        12
+#define EBI_SIZE_64M        13
+#define EBI_SIZE_128M       14
+#define EBI_SIZE_256M       15
+  uint32        config;
+#define EBI_ENABLE          0x00000001      /* .. enable this range */
+#define EBI_WAIT_STATES     0x0000000e      /* .. mask for wait states */
+#define EBI_WTST_SHIFT      1               /* .. for shifting wait states */
+#define EBI_WORD_WIDE       0x00000010      /* .. 16-bit peripheral, else 8 */
+#define EBI_WREN            0x00000020      /* enable posted writes */
+#define EBI_POLARITY        0x00000040      /* .. set to invert something, 
+                                        **    don't know what yet */
+#define EBI_TS_TA_MODE      0x00000080      /* .. use TS/TA mode */
+#define EBI_TS_SEL          0x00000100      /* .. drive tsize, not bs_b */
+#define EBI_FIFO            0x00000200      /* .. use fifo */
+#define EBI_RE              0x00000400      /* .. Reverse Endian */
+} EbiChipSelect;
+
+typedef struct MpiRegisters {
+  EbiChipSelect cs[7];                  /* size chip select configuration */
+#define EBI_CS0_BASE            0
+#define EBI_CS1_BASE            1
+#define EBI_CS2_BASE            2
+#define EBI_CS3_BASE            3
+#define PCMCIA_COMMON_BASE      4
+#define PCMCIA_ATTRIBUTE_BASE   5
+#define PCMCIA_IO_BASE          6
+  uint32        unused0[2];             /* reserved */
+  uint32        ebi_control;            /* ebi control */
+  uint32        unused1[4];             /* reserved */
+#define EBI_ACCESS_TIMEOUT      0x000007FF
+  uint32        pcmcia_cntl1;           /* pcmcia control 1 */
+#define PCCARD_CARD_RESET       0x00040000
+#define CARDBUS_ENABLE          0x00008000
+#define PCMCIA_ENABLE           0x00004000
+#define PCMCIA_GPIO_ENABLE      0x00002000
+#define CARDBUS_IDSEL           0x00001F00
+#define VS2_OEN                 0x00000080
+#define VS1_OEN                 0x00000040
+#define VS2_OUT                 0x00000020
+#define VS1_OUT                 0x00000010
+#define VS2_IN                  0x00000008
+#define VS1_IN                  0x00000004
+#define CD2_IN                  0x00000002
+#define CD1_IN                  0x00000001
+#define VS_MASK                 0x0000000C
+#define CD_MASK                 0x00000003
+  uint32        unused2;                /* reserved */
+  uint32        pcmcia_cntl2;           /* pcmcia control 2 */
+#define PCMCIA_BYTESWAP_DIS     0x00000002
+#define PCMCIA_HALFWORD_EN      0x00000001
+#define RW_ACTIVE_CNT_BIT       2
+#define INACTIVE_CNT_BIT        8
+#define CE_SETUP_CNT_BIT        16
+#define CE_HOLD_CNT_BIT         24
+  uint32        unused3[40];            /* reserved */
+
+  uint32        sp0range;               /* PCI to internal system bus address space */
+  uint32        sp0remap;
+  uint32        sp0cfg;
+  uint32        sp1range;
+  uint32        sp1remap;
+  uint32        sp1cfg;
+
+  uint32        EndianCfg;
+
+  uint32        l2pcfgctl;              /* internal system bus to PCI IO/Cfg control */
+#define DIR_CFG_SEL             0x80000000 /* change from PCI I/O access to PCI config access */
+#define DIR_CFG_USEREG          0x40000000 /* use this register info for PCI configuration access */
+#define DEVICE_NUMBER           0x00007C00 /* device number for the PCI configuration access */
+#define FUNC_NUMBER             0x00000300 /* function number for the PCI configuration access */
+#define REG_NUMBER              0x000000FC /* register number for the PCI configuration access */
+#define CONFIG_TYPE             0x00000003 /* configuration type for the PCI configuration access */
+
+  uint32        l2pmrange1;             /* internal system bus to PCI memory space */
+#define PCI_SIZE_64K            0xFFFF0000
+#define PCI_SIZE_128K           0xFFFE0000
+#define PCI_SIZE_256K           0xFFFC0000
+#define PCI_SIZE_512K           0xFFF80000
+#define PCI_SIZE_1M             0xFFF00000
+#define PCI_SIZE_2M             0xFFE00000
+#define PCI_SIZE_4M             0xFFC00000
+#define PCI_SIZE_8M             0xFF800000
+#define PCI_SIZE_16M            0xFF000000
+#define PCI_SIZE_32M            0xFE000000
+  uint32        l2pmbase1;              /* kseg0 or kseg1 address & 0x1FFFFFFF */
+  uint32        l2pmremap1;
+#define CARDBUS_MEM             0x00000004
+#define MEM_WINDOW_EN           0x00000001
+  uint32        l2pmrange2;
+  uint32        l2pmbase2;
+  uint32        l2pmremap2;
+  uint32        l2piorange;             /* internal system bus to PCI I/O space */
+  uint32        l2piobase;
+  uint32        l2pioremap;
+
+  uint32        pcimodesel;
+#define PCI2_INT_BUS_RD_PREFECH 0x000000F0
+#define PCI_BAR2_NOSWAP         0x00000002 /* BAR at offset 0x20 */
+#define PCI_BAR1_NOSWAP         0x00000001 /* BAR at affset 0x1c */
+
+  uint32        pciintstat;             /* PCI interrupt mask/status */
+#define MAILBOX1_SENT           0x08
+#define MAILBOX0_SENT           0x04
+#define MAILBOX1_MSG_RCV        0x02
+#define MAILBOX0_MSG_RCV        0x01
+  uint32        locbuscntrl;            /* internal system bus control */
+#define DIR_U2P_NOSWAP          0x00000002
+#define EN_PCI_GPIO             0x00000001
+  uint32        locintstat;             /* internal system bus interrupt mask/status */
+#define CSERR                   0x0200
+#define SERR                    0x0100
+#define EXT_PCI_INT             0x0080
+#define DIR_FAILED              0x0040
+#define DIR_COMPLETE            0x0020
+#define PCI_CFG                 0x0010
+  uint32        unused5[7];
+
+  uint32        mailbox0;
+  uint32        mailbox1;
+
+  uint32        pcicfgcntrl;            /* internal system bus PCI configuration control */
+#define PCI_CFG_REG_WRITE_EN    0x00000080
+#define PCI_CFG_ADDR            0x0000003C
+  uint32        pcicfgdata;             /* internal system bus PCI configuration data */
+
+  uint32        locch2ctl;              /* PCI to interrnal system bus DMA (downstream) local control */
+#define MPI_DMA_HALT            0x00000008  /* idle after finish current memory burst */
+#define MPI_DMA_PKT_HALT        0x00000004  /* idle after an EOP flag is detected */
+#define MPI_DMA_STALL           0x00000002  /* idle after an EOP flag is detected */
+#define MPI_DMA_ENABLE          0x00000001  /* set to enable channel */
+  uint32        locch2intStat;
+#define MPI_DMA_NO_DESC         0x00000004  /* no valid descriptors */
+#define MPI_DMA_DONE            0x00000002  /* packet xfer complete */
+#define MPI_DMA_BUFF_DONE       0x00000001  /* buffer done */
+  uint32        locch2intMask;
+  uint32        unused6;
+  uint32        locch2descaddr;
+  uint32        locch2status1;
+#define LOCAL_DESC_STATE        0xE0000000
+#define PCI_DESC_STATE          0x1C000000
+#define BYTE_DONE               0x03FFC000
+#define RING_ADDR               0x00003FFF
+  uint32        locch2status2;
+#define BUFPTR_OFFSET           0x1FFF0000
+#define PCI_MASTER_STATE        0x000000C0
+#define LOC_MASTER_STATE        0x00000038
+#define CONTROL_STATE           0x00000007
+  uint32        unused7;
+
+  uint32        locch1Ctl;              /*internal system bus to PCI DMA (upstream) local control */
+#define DMA_U2P_LE              0x00000200  /* local bus is little endian */
+#define DMA_U2P_NOSWAP          0x00000100  /* lccal bus is little endian but no data swapped */
+  uint32        locch1intstat;
+  uint32        locch1intmask;
+  uint32        unused8;
+  uint32        locch1descaddr;
+  uint32        locch1status1;
+  uint32        locch1status2;
+  uint32        unused9;
+
+  uint32        pcich1ctl;              /* internal system bus to PCI DMA PCI control */
+  uint32        pcich1intstat;
+  uint32        pcich1intmask;
+  uint32        pcich1descaddr;
+  uint32        pcich1status1;
+  uint32        pcich1status2;
+
+  uint32        pcich2Ctl;              /* PCI to internal system bus DMA PCI control */
+  uint32        pcich2intstat;
+  uint32        pcich2intmask;
+  uint32        pcich2descaddr;
+  uint32        pcich2status1;
+  uint32        pcich2status2;
+
+  uint32        perm_id;                /* permanent device and vendor id */
+  uint32        perm_rev;               /* permanent revision id */
+} MpiRegisters;
+
+#define MPI ((volatile MpiRegisters * const) MPI_BASE)
+
+/* PCI configuration address space start offset 0x40 */
+#define BRCM_PCI_CONFIG_TIMER               0x40
+#define BRCM_PCI_CONFIG_TIMER_RETRY_MASK	0x0000FF00
+#define BRCM_PCI_CONFIG_TIMER_TRDY_MASK		0x000000FF
+
+/* USB host non-Open HCI register, USB_HOST_NON_OHCI, bit definitions. */
+#define NON_OHCI_ENABLE_PORT1   0x00000001 /* Use USB port 1 for host, not dev */
+#define NON_OHCI_BYTE_SWAP      0x00000008 /* Swap USB host registers */
+
+#define USBH_NON_OHCI ((volatile unsigned long * const) USB_HOST_NON_OHCI)
+
+#if __cplusplus
+}
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcmTag.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcmTag.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcmTag.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcmTag.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,153 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+//**************************************************************************************
+// File Name  : bcmTag.h
+//
+// Description: add tag with validation system to the firmware image file to be uploaded
+//              via http
+//
+// Created    : 02/28/2002  seanl
+//**************************************************************************************
+
+#ifndef _BCMTAG_H_
+#define _BCMTAG_H_
+
+
+#define BCM_SIG_1   "Broadcom Corporation"
+#define BCM_SIG_2   "ver. 2.0"          // was "firmware version 2.0" now it is split 6 char out for chip id.
+
+#define BCM_TAG_VER         "6"
+#define BCM_TAG_VER_LAST    "26"
+
+// file tag (head) structure all is in clear text except validationTokens (crc, md5, sha1, etc). Total: 128 unsigned chars
+#define TAG_LEN         256
+#define TAG_VER_LEN     4
+#define SIG_LEN         20
+#define SIG_LEN_2       14   // Original second SIG = 20 is now devided into 14 for SIG_LEN_2 and 6 for CHIP_ID
+#define CHIP_ID_LEN		6	
+#define IMAGE_LEN       10
+#define ADDRESS_LEN     12
+#define FLAG_LEN        2
+#define TOKEN_LEN       20
+#define BOARD_ID_LEN    16
+#define RESERVED_LEN    (TAG_LEN - TAG_VER_LEN - SIG_LEN - SIG_LEN_2 - CHIP_ID_LEN - BOARD_ID_LEN - \
+                        (4*IMAGE_LEN) - (3*ADDRESS_LEN) - (3*FLAG_LEN) - (2*TOKEN_LEN))
+
+
+// TAG for downloadable image (kernel plus file system)
+typedef struct _FILE_TAG
+{
+    unsigned char tagVersion[TAG_VER_LEN];       // tag version.  Will be 2 here.
+    unsigned char signiture_1[SIG_LEN];          // text line for company info
+    unsigned char signiture_2[SIG_LEN_2];        // additional info (can be version number)
+    unsigned char chipId[CHIP_ID_LEN];			 // chip id 
+    unsigned char boardId[BOARD_ID_LEN];         // board id
+    unsigned char bigEndian[FLAG_LEN];           // if = 1 - big, = 0 - little endia of the host
+    unsigned char totalImageLen[IMAGE_LEN];      // the sum of all the following length
+    unsigned char cfeAddress[ADDRESS_LEN];       // if non zero, cfe starting address
+    unsigned char cfeLen[IMAGE_LEN];             // if non zero, cfe size in clear ASCII text.
+    unsigned char rootfsAddress[ADDRESS_LEN];    // if non zero, filesystem starting address
+    unsigned char rootfsLen[IMAGE_LEN];          // if non zero, filesystem size in clear ASCII text.
+    unsigned char kernelAddress[ADDRESS_LEN];    // if non zero, kernel starting address
+    unsigned char kernelLen[IMAGE_LEN];          // if non zero, kernel size in clear ASCII text.
+    unsigned char dualImage[FLAG_LEN];           // if 1, dual image
+    unsigned char inactiveLen[FLAG_LEN];         // if 1, the image is INACTIVE; if 0, active 
+    unsigned char reserved[RESERVED_LEN];        // reserved for later use
+    unsigned char imageValidationToken[TOKEN_LEN];// image validation token - can be crc, md5, sha;  for
+                                                 // now will be 4 unsigned char crc
+    unsigned char tagValidationToken[TOKEN_LEN]; // validation token for tag(from signiture_1 to end of // mageValidationToken)
+} FILE_TAG, *PFILE_TAG;
+
+#define CRC32_INIT_VALUE 0xffffffff /* Initial CRC32 checksum value */
+#define CRC_LEN 4
+
+// only included if for bcmTag.exe program
+#ifdef BCMTAG_EXE_USE
+
+static unsigned long Crc32_table[256] = {
+    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
+    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
+    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
+    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
+    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
+    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
+    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
+    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
+    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
+    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
+    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
+    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
+    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
+    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
+    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
+    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
+    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
+    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
+    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
+    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
+    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
+    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
+    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
+    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
+    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
+    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
+    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
+    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
+    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
+    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
+    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
+    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
+    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
+    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
+    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
+    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
+    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
+    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
+    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
+    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
+    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
+    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
+    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
+    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
+    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
+    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
+    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
+    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
+    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
+    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
+    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
+    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
+    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
+    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
+    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
+    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
+    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
+    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
+    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
+    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
+    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
+    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
+    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
+    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
+};
+#endif // BCMTAG_USE
+
+
+#endif // _BCMTAG_H_
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcm_intr.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+<:copyright-gpl 
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM_INTR_H
+#define __BCM_INTR_H
+
+#ifdef __cplusplus
+    extern "C" {
+#endif
+
+#if defined(CONFIG_BCM96338)
+#include <6338_intr.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_intr.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_intr.h>
+#endif
+
+/* defines */
+struct pt_regs;
+typedef int (*FN_HANDLER) (int, void *, struct pt_regs *);
+
+/* prototypes */
+extern void enable_brcm_irq(unsigned int irq);
+extern void disable_brcm_irq(unsigned int irq);
+extern int request_external_irq(unsigned int irq,
+    FN_HANDLER handler, unsigned long irqflags, 
+    const char * devname, void *dev_id);
+extern unsigned int BcmHalMapInterrupt(FN_HANDLER isr, unsigned int param,
+    unsigned int interruptId);
+extern void dump_intr_regs(void);
+
+/* compatibility definitions */
+#define BcmHalInterruptEnable(irq)      enable_brcm_irq( irq )
+#define BcmHalInterruptDisable(irq)     disable_brcm_irq( irq )
+
+#ifdef __cplusplus
+    }
+#endif
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcm_map_part.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+#ifndef __BCM_MAP_PART_H
+#define __BCM_MAP_PART_H
+
+#if defined(CONFIG_BCM96338)
+#include <6338_map_part.h>
+#endif
+#if defined(CONFIG_BCM96345)
+#include <6345_map_part.h>
+#endif
+#if defined(CONFIG_BCM96348)
+#include <6348_map_part.h>
+#endif
+
+#endif
+
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcmpci.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcmpci.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcmpci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcmpci.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,87 @@
+/*
+<:copyright-gpl 
+ Copyright 2004 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+//
+// bcmpci.h - bcm96348 PCI, Cardbus, and PCMCIA definition
+//
+#ifndef BCMPCI_H
+#define BCMPCI_H
+
+/* Memory window in internal system bus address space */ 
+#define BCM_PCI_MEM_BASE        0x08000000
+/* IO window in internal system bus address space */ 
+#define BCM_PCI_IO_BASE         0x0C000000
+
+#define BCM_PCI_ADDR_MASK       0x1fffffff
+
+/* Memory window size (range) */
+#define BCM_PCI_MEM_SIZE_16MB   0x01000000
+/* IO window size (range) */
+#define BCM_PCI_IO_SIZE_64KB    0x00010000
+
+/* PCI Configuration and I/O space acesss */
+#define BCM_PCI_CFG(d, f, o)    ( (d << 11) | (f << 8) | (o/4 << 2) )
+
+/* fake USB PCI slot */
+#define USB_HOST_SLOT           9
+#define USB_BAR0_MEM_SIZE       0x0800
+
+#define BCM_HOST_MEM_SPACE1     0x10000000
+#define BCM_HOST_MEM_SPACE2     0x00000000
+
+/* 
+ * EBI bus clock is 33MHz and share with PCI bus
+ * each clock cycle is 30ns.
+ */
+/* attribute memory access wait cnt for 4306 */
+#define PCMCIA_ATTR_CE_HOLD     3  // data hold time 70ns
+#define PCMCIA_ATTR_CE_SETUP    3  // data setup time 50ns
+#define PCMCIA_ATTR_INACTIVE    6  // time between read/write cycles 180ns. For the total cycle time 600ns (cnt1+cnt2+cnt3+cnt4)
+#define PCMCIA_ATTR_ACTIVE      10 // OE/WE pulse width 300ns
+
+/* common memory access wait cnt for 4306 */
+#define PCMCIA_MEM_CE_HOLD      1  // data hold time 30ns
+#define PCMCIA_MEM_CE_SETUP     1  // data setup time 30ns
+#define PCMCIA_MEM_INACTIVE     2  // time between read/write cycles 40ns. For the total cycle time 250ns (cnt1+cnt2+cnt3+cnt4)
+#define PCMCIA_MEM_ACTIVE       5  // OE/WE pulse width 150ns
+
+#define PCCARD_VCC_MASK     0x00070000  // Mask Reset also
+#define PCCARD_VCC_33V      0x00010000
+#define PCCARD_VCC_50V      0x00020000
+
+typedef enum {
+    MPI_CARDTYPE_NONE,      // No Card in slot
+    MPI_CARDTYPE_PCMCIA,    // 16-bit PCMCIA card in slot    
+    MPI_CARDTYPE_CARDBUS,   // 32-bit CardBus card in slot
+}   CardType;
+
+#define CARDBUS_SLOT        0    // Slot 0 is default for CardBus
+
+#define pcmciaAttrOffset    0x00200000
+#define pcmciaMemOffset     0x00000000
+// Needs to be right above PCI I/O space. Give 0x8000 (32K) to PCMCIA. 
+#define pcmciaIoOffset      (BCM_PCI_IO_BASE + 0x80000)
+// Base Address is that mapped into the MPI ChipSelect registers. 
+// UBUS bridge MemoryWindow 0 outputs a 0x00 for the base.
+#define pcmciaBase          0xbf000000
+#define pcmciaAttr          (pcmciaAttrOffset | pcmciaBase)
+#define pcmciaMem           (pcmciaMemOffset  | pcmciaBase)
+#define pcmciaIo            (pcmciaIoOffset   | pcmciaBase)
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/bcmtypes.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+
+//
+// bcmtypes.h - misc useful typedefs
+//
+#ifndef BCMTYPES_H
+#define BCMTYPES_H
+
+// These are also defined in typedefs.h in the application area, so I need to
+// protect against re-definition.
+
+#ifndef _TYPEDEFS_H_
+typedef unsigned char   uint8;
+typedef unsigned short  uint16;
+typedef unsigned long   uint32;
+typedef signed char     int8;
+typedef signed short    int16;
+typedef signed long     int32;
+#if !defined(__cplusplus)
+typedef	int	bool;
+#endif
+#endif
+
+typedef unsigned char   byte;
+// typedef unsigned long   sem_t;
+
+typedef unsigned long   HANDLE,*PULONG,DWORD,*PDWORD;
+typedef signed long     LONG,*PLONG;
+
+typedef unsigned int    *PUINT;
+typedef signed int      INT;
+
+typedef unsigned short  *PUSHORT;
+typedef signed short    SHORT,*PSHORT;
+typedef unsigned short  WORD,*PWORD;
+
+typedef unsigned char   *PUCHAR;
+typedef signed char     *PCHAR;
+
+typedef void            *PVOID;
+
+typedef unsigned char   BOOLEAN, *PBOOL, *PBOOLEAN;
+
+typedef unsigned char   BYTE,*PBYTE;
+
+//#ifndef __GNUC__
+//The following has been defined in Vxworks internally: vxTypesOld.h
+//redefine under vxworks will cause error
+typedef signed int      *PINT;
+
+typedef signed char     INT8;
+typedef signed short    INT16;
+typedef signed long     INT32;
+
+typedef unsigned char   UINT8;
+typedef unsigned short  UINT16;
+typedef unsigned long   UINT32;
+
+typedef unsigned char   UCHAR;
+typedef unsigned short  USHORT;
+typedef unsigned int    UINT;
+typedef unsigned long   ULONG;
+
+typedef void            VOID;
+typedef unsigned char   BOOL;
+
+//#endif  /* __GNUC__ */
+
+
+// These are also defined in typedefs.h in the application area, so I need to
+// protect against re-definition.
+#ifndef TYPEDEFS_H
+
+// Maximum and minimum values for a signed 16 bit integer.
+#define MAX_INT16 32767
+#define MIN_INT16 -32768
+
+// Useful for true/false return values.  This uses the
+// Taligent notation (k for constant).
+typedef enum
+{
+    kFalse = 0,
+    kTrue = 1
+} Bool;
+
+#endif
+
+/* macros to protect against unaligned accesses */
+
+#if 0
+/* first arg is an address, second is a value */
+#define PUT16( a, d ) { 		\
+  *((byte *)a) = (byte)((d)>>8); 	\
+  *(((byte *)a)+1) = (byte)(d); 	\
+}
+
+#define PUT32( a, d ) { 		\
+  *((byte *)a) = (byte)((d)>>24); 	\
+  *(((byte *)a)+1) = (byte)((d)>>16); 	\
+  *(((byte *)a)+2) = (byte)((d)>>8); 	\
+  *(((byte *)a)+3) = (byte)(d); 	\
+}
+
+/* first arg is an address, returns a value */
+#define GET16( a ) ( 			\
+  (*((byte *)a) << 8) |			\
+  (*(((byte *)a)+1))	 		\
+)
+
+#define GET32( a ) ( 			\
+  (*((byte *)a) << 24)     |		\
+  (*(((byte *)a)+1) << 16) | 		\
+  (*(((byte *)a)+2) << 8)  | 		\
+  (*(((byte *)a)+3))	 		\
+)
+#endif
+
+#ifndef YES
+#define YES 1
+#endif
+
+#ifndef NO
+#define NO  0
+#endif
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+#define READ32(addr)        (*(volatile UINT32 *)((ULONG)&addr))
+#define READ16(addr)        (*(volatile UINT16 *)((ULONG)&addr))
+#define READ8(addr)         (*(volatile UINT8  *)((ULONG)&addr))
+
+#endif
diff -urN linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/board.h linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/board.h
--- linux-2.6.8.1/bcmdrivers/opensource/include/bcm963xx/board.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/bcmdrivers/opensource/include/bcm963xx/board.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,368 @@
+/*
+<:copyright-gpl 
+ Copyright 2002 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+:>
+*/
+/***********************************************************************/
+/*                                                                     */
+/*   MODULE:  board.h                                                  */
+/*   DATE:    97/02/18                                                 */
+/*   PURPOSE: Board specific information.  This module should include  */
+/*            all base device addresses and board specific macros.     */
+/*                                                                     */
+/***********************************************************************/
+#ifndef _BOARD_H
+#define _BOARD_H
+
+#if __cplusplus
+extern "C" {
+#endif
+/*****************************************************************************/
+/*                    Misc board definitions                                 */
+/*****************************************************************************/
+
+#define	DYING_GASP_API
+
+/*****************************************************************************/
+/*                    Physical Memory Map                                    */
+/*****************************************************************************/
+
+#define PHYS_DRAM_BASE           0x00000000     /* Dynamic RAM Base */
+#define PHYS_FLASH_BASE          0x1FC00000     /* Flash Memory         */
+
+/*****************************************************************************/
+/* Note that the addresses above are physical addresses and that programs    */
+/* have to use converted addresses defined below:                            */
+/*****************************************************************************/
+#define DRAM_BASE           (0x80000000 | PHYS_DRAM_BASE)   /* cached DRAM */
+#define DRAM_BASE_NOCACHE   (0xA0000000 | PHYS_DRAM_BASE)   /* uncached DRAM */
+#define FLASH_BASE          (0xA0000000 | PHYS_FLASH_BASE)  /* uncached Flash  */
+
+/*****************************************************************************/
+/*  Select the PLL value to get the desired CPU clock frequency.             */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+#define FPERIPH            50000000
+
+#define ONEK                            1024
+#define BLK64K                          (64*ONEK)
+#define FLASH45_BLKS_BOOT_ROM           1
+#define FLASH45_LENGTH_BOOT_ROM         (FLASH45_BLKS_BOOT_ROM * BLK64K)
+#define FLASH_RESERVED_AT_END           (64*ONEK) /*reserved for PSI, scratch pad*/
+    
+/*****************************************************************************/
+/* Note that the addresses above are physical addresses and that programs    */
+/* have to use converted addresses defined below:                            */
+/*****************************************************************************/
+#define DRAM_BASE           (0x80000000 | PHYS_DRAM_BASE)   /* cached DRAM */
+#define DRAM_BASE_NOCACHE   (0xA0000000 | PHYS_DRAM_BASE)   /* uncached DRAM */
+#define FLASH_BASE          (0xA0000000 | PHYS_FLASH_BASE)  /* uncached Flash  */
+
+/*****************************************************************************/
+/*  Select the PLL value to get the desired CPU clock frequency.             */
+/*                                                                           */
+/*                                                                           */
+/*****************************************************************************/
+#define FPERIPH            50000000
+    
+#define SDRAM_TYPE_ADDRESS_OFFSET   16
+#define NVRAM_DATA_OFFSET           0x0580
+#define NVRAM_DATA_ID               0x0f1e2d3c
+#define BOARD_SDRAM_TYPE            *(unsigned long *) \
+                                    (FLASH_BASE + SDRAM_TYPE_ADDRESS_OFFSET)
+
+#define ONEK                1024
+#define BLK64K              (64*ONEK)
+
+// nvram and psi flash definitions for 45
+#define FLASH45_LENGTH_NVRAM            ONEK            // 1k nvram 
+#define NVRAM_PSI_DEFAULT               24              // default psi in K byes
+
+/*****************************************************************************/
+/*       NVRAM Offset and definition                                         */
+/*****************************************************************************/
+
+#define NVRAM_VERSION_NUMBER            2
+#define NVRAM_VERSION_NUMBER_ADDRESS    0
+
+#define NVRAM_BOOTLINE_LEN              256
+#define NVRAM_BOARD_ID_STRING_LEN       16
+#define NVRAM_MAC_ADDRESS_LEN           6
+#define NVRAM_MAC_COUNT_MAX             32
+
+/*****************************************************************************/
+/*       Misc Offsets                                                        */
+/*****************************************************************************/
+
+#define CFE_VERSION_OFFSET           0x0570
+#define CFE_VERSION_MARK_SIZE        5
+#define CFE_VERSION_SIZE             5
+
+typedef struct
+{
+    unsigned long ulVersion;
+    char szBootline[NVRAM_BOOTLINE_LEN];
+    char szBoardId[NVRAM_BOARD_ID_STRING_LEN];
+    unsigned long ulReserved1[2];
+    unsigned long ulNumMacAddrs;
+    unsigned char ucaBaseMacAddr[NVRAM_MAC_ADDRESS_LEN];
+    char chReserved[2];
+    unsigned long ulCheckSum;
+} NVRAM_DATA, *PNVRAM_DATA;
+
+
+/*****************************************************************************/
+/*          board ioctl calls for flash, led and some other utilities        */
+/*****************************************************************************/
+
+
+/* Defines. for board driver */
+#define BOARD_IOCTL_MAGIC       'B'
+#define BOARD_DRV_MAJOR          206
+
+#define MAC_ADDRESS_ANY         (unsigned long) -1
+
+#define BOARD_IOCTL_FLASH_INIT \
+    _IOWR(BOARD_IOCTL_MAGIC, 0, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_FLASH_WRITE \
+    _IOWR(BOARD_IOCTL_MAGIC, 1, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_FLASH_READ \
+    _IOWR(BOARD_IOCTL_MAGIC, 2, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_NR_PAGES \
+    _IOWR(BOARD_IOCTL_MAGIC, 3, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_DUMP_ADDR \
+    _IOWR(BOARD_IOCTL_MAGIC, 4, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_MEMORY \
+    _IOWR(BOARD_IOCTL_MAGIC, 5, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_MIPS_SOFT_RESET \
+    _IOWR(BOARD_IOCTL_MAGIC, 6, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_LED_CTRL \
+    _IOWR(BOARD_IOCTL_MAGIC, 7, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_ID \
+    _IOWR(BOARD_IOCTL_MAGIC, 8, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 9, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_RELEASE_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 10, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_PSI_SIZE \
+    _IOWR(BOARD_IOCTL_MAGIC, 11, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_SDRAM_SIZE \
+    _IOWR(BOARD_IOCTL_MAGIC, 12, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_MONITOR_FD \
+    _IOWR(BOARD_IOCTL_MAGIC, 13, BOARD_IOCTL_PARMS)
+    
+#define BOARD_IOCTL_WAKEUP_MONITOR_TASK \
+    _IOWR(BOARD_IOCTL_MAGIC, 14, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_BOOTLINE \
+    _IOWR(BOARD_IOCTL_MAGIC, 15, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_SET_BOOTLINE \
+    _IOWR(BOARD_IOCTL_MAGIC, 16, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_BASE_MAC_ADDRESS \
+    _IOWR(BOARD_IOCTL_MAGIC, 17, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_CHIP_ID \
+    _IOWR(BOARD_IOCTL_MAGIC, 18, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_NUM_ENET \
+    _IOWR(BOARD_IOCTL_MAGIC, 19, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_CFE_VER \
+    _IOWR(BOARD_IOCTL_MAGIC, 20, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_ENET_CFG \
+    _IOWR(BOARD_IOCTL_MAGIC, 21, BOARD_IOCTL_PARMS)
+
+#define BOARD_IOCTL_GET_WLAN_ANT_INUSE \
+    _IOWR(BOARD_IOCTL_MAGIC, 22, BOARD_IOCTL_PARMS)
+    
+#define BOARD_IOCTL_SET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 23, BOARD_IOCTL_PARMS)        
+
+#define BOARD_IOCTL_GET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 24, BOARD_IOCTL_PARMS)        
+
+#define BOARD_IOCTL_UNSET_TRIGGER_EVENT \
+    _IOWR(BOARD_IOCTL_MAGIC, 25, BOARD_IOCTL_PARMS) 
+
+#define BOARD_IOCTL_SET_SES_LED \
+    _IOWR(BOARD_IOCTL_MAGIC, 26, BOARD_IOCTL_PARMS)
+    
+    
+// for the action in BOARD_IOCTL_PARMS for flash operation
+typedef enum 
+{
+    PERSISTENT,
+    NVRAM,
+    BCM_IMAGE_CFE,
+    BCM_IMAGE_FS,
+    BCM_IMAGE_KERNEL,
+    BCM_IMAGE_WHOLE,
+    SCRATCH_PAD,
+    FLASH_SIZE,
+} BOARD_IOCTL_ACTION;
+    
+    
+typedef struct boardIoctParms
+{
+    char *string;
+    char *buf;
+    int strLen;
+    int offset;
+    BOARD_IOCTL_ACTION  action;        /* flash read/write: nvram, persistent, bcm image */
+    int result;
+} BOARD_IOCTL_PARMS;
+
+
+// LED defines 
+typedef enum
+{   
+    kLedAdsl,
+    kLedWireless,
+    kLedUsb,
+    kLedHpna,
+    kLedWanData,
+    kLedPPP,
+    kLedVoip,
+    kLedSes,
+    kLedEnd,                // NOTE: Insert the new led name before this one.  Alway stay at the end.
+} BOARD_LED_NAME;
+
+typedef enum
+{
+    kLedStateOff,                        /* turn led off */
+    kLedStateOn,                         /* turn led on */
+    kLedStateFail,                       /* turn led on red */
+    kLedStateBlinkOnce,                  /* blink once, ~100ms and ignore the same call during the 100ms period */
+    kLedStateSlowBlinkContinues,         /* slow blink continues at ~600ms interval */
+    kLedStateFastBlinkContinues,         /* fast blink continues at ~200ms interval */
+} BOARD_LED_STATE;
+
+
+// virtual and physical map pair defined in board.c
+typedef struct ledmappair
+{
+    BOARD_LED_NAME ledName;         // virtual led name
+    BOARD_LED_STATE ledInitState;   // initial led state when the board boots.
+    unsigned short ledMask;         // physical GPIO pin mask
+    unsigned short ledActiveLow;    // reset bit to turn on LED
+    unsigned short ledMaskFail;     // physical GPIO pin mask for state failure
+    unsigned short ledActiveLowFail;// reset bit to turn on LED
+} LED_MAP_PAIR, *PLED_MAP_PAIR;
+
+typedef void (*HANDLE_LED_FUNC)(BOARD_LED_NAME ledName, BOARD_LED_STATE ledState);
+
+/* Flash storage address information that is determined by the flash driver. */
+typedef struct flashaddrinfo
+{
+    int flash_persistent_start_blk;
+    int flash_persistent_number_blk;
+    int flash_persistent_length;
+    unsigned long flash_persistent_blk_offset;
+    int flash_scratch_pad_start_blk;         // start before psi (SP_BUF_LEN)
+    int flash_scratch_pad_number_blk;
+    int flash_scratch_pad_length;
+    unsigned long flash_scratch_pad_blk_offset;
+    int flash_nvram_start_blk;
+    int flash_nvram_number_blk;
+    int flash_nvram_length;
+    unsigned long flash_nvram_blk_offset;
+} FLASH_ADDR_INFO, *PFLASH_ADDR_INFO;
+
+// scratch pad defines
+/* SP - Persisten Scratch Pad format:
+       sp header        : 32 bytes
+       tokenId-1        : 8 bytes
+       tokenId-1 len    : 4 bytes
+       tokenId-1 data    
+       ....
+       tokenId-n        : 8 bytes
+       tokenId-n len    : 4 bytes
+       tokenId-n data    
+*/
+
+#define MAGIC_NUM_LEN       8
+#define MAGIC_NUMBER        "gOGoBrCm"
+#define TOKEN_NAME_LEN      16
+#define SP_VERSION          1
+#define SP_MAX_LEN          8 * 1024            // 8k buf before psi
+#define SP_RESERVERD        16
+
+typedef struct _SP_HEADER
+{
+    char SPMagicNum[MAGIC_NUM_LEN];             // 8 bytes of magic number
+    int SPVersion;                              // version number
+    int SPUsedLen;                              // used sp len   
+    char SPReserved[SP_RESERVERD];              // reservied, total 32 bytes
+} SP_HEADER, *PSP_HEADER;
+
+typedef struct _TOKEN_DEF
+{
+    char tokenName[TOKEN_NAME_LEN];
+    int tokenLen;
+} SP_TOKEN, *PSP_TOKEN;
+
+
+/*****************************************************************************/
+/*          Function Prototypes                                              */
+/*****************************************************************************/
+#if !defined(__ASM_ASM_H)
+void dumpaddr( unsigned char *pAddr, int nLen );
+
+void kerSysFlashAddrInfoGet(PFLASH_ADDR_INFO pflash_addr_info);
+int kerSysNvRamGet(char *string, int strLen, int offset);
+int kerSysNvRamSet(char *string, int strLen, int offset);
+int kerSysPersistentGet(char *string, int strLen, int offset);
+int kerSysPersistentSet(char *string, int strLen, int offset);
+int kerSysScratchPadGet(char *tokName, char *tokBuf, int tokLen);
+int kerSysScratchPadSet(char *tokName, char *tokBuf, int tokLen);
+int kerSysBcmImageSet( int flash_start_addr, char *string, int size);
+int kerSysGetMacAddress( unsigned char *pucaAddr, unsigned long ulId );
+int kerSysReleaseMacAddress( unsigned char *pucaAddr );
+int kerSysGetSdramSize( void );
+void kerSysGetBootline(char *string, int strLen);
+void kerSysSetBootline(char *string, int strLen);
+void kerSysMipsSoftReset(void);
+void kerSysLedCtrl(BOARD_LED_NAME, BOARD_LED_STATE);
+void kerSysLedRegisterHwHandler( BOARD_LED_NAME, HANDLE_LED_FUNC, int );
+int kerSysFlashSizeGet(void);
+void kerSysRegisterDyingGaspHandler(char *devname, void *cbfn, void *context);
+void kerSysDeregisterDyingGaspHandler(char *devname);    
+void kerSysWakeupMonitorTask( void );
+#endif
+
+#if __cplusplus
+}
+#endif
+
+#endif /* _BOARD_H */
+
diff -urN linux-2.6.8.1/boardparams/bcm963xx/Makefile linux-2.6.8.1-brcm63xx/boardparms/bcm963xx/Makefile
--- linux-2.6.8.1/boardparams/bcm963xx/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/boardparms/bcm963xx/Makefile	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,16 @@
+
+ifeq ($(CONFIG_MIPS_BRCM),y)
+
+# Linux
+obj-y		+= boardparms.o
+EXTRA_CFLAGS += -DCONFIG_BCM9$(BRCM_CHIP)
+-include $(TOPDIR)/Rules.make
+
+else
+
+# CFE
+BSPOBJS += boardparms.o
+
+endif
+
+
diff -urN linux-2.6.8.1/boardparams/bcm963xx/boardparms.c linux-2.6.8.1-brcm63xx/boardparms/bcm963xx/boardparms.c
--- linux-2.6.8.1/boardparams/bcm963xx/boardparms.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/boardparms/bcm963xx/boardparms.c	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,2382 @@
+/*
+<:copyright-gpl 
+
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+
+:>
+*/
+/**************************************************************************
+ * File Name  : boardparms.c
+ *
+ * Description: This file contains the implementation for the BCM63xx board
+ *              parameter access functions.
+ * 
+ * Updates    : 07/14/2003  Created.
+ ***************************************************************************/
+
+/* Includes. */
+#include "boardparms.h"
+
+/* Defines. */
+
+/* Default psi size in K bytes */
+#define BP_PSI_DEFAULT_SIZE                     24   
+
+/* Typedefs */
+typedef struct boardparameters
+{
+    char szBoardId[BP_BOARD_ID_LEN];        /* board id string */
+    ETHERNET_MAC_INFO EnetMacInfos[BP_MAX_ENET_MACS];
+    VOIP_DSP_INFO VoIPDspInfo[BP_MAX_VOIP_DSP];
+    unsigned short usSdramSize;             /* SDRAM size and type */
+    unsigned short usPsiSize;               /* persistent storage in K bytes */
+    unsigned short usGpioRj11InnerPair;     /* GPIO pin or not defined */
+    unsigned short usGpioRj11OuterPair;     /* GPIO pin or not defined */
+    unsigned short usGpioPressAndHoldReset; /* GPIO pin or not defined */
+    unsigned short usGpioPcmciaReset;       /* GPIO pin or not defined */
+    unsigned short usGpioUartRts;           /* GPIO pin or not defined */
+    unsigned short usGpioUartCts;           /* GPIO pin or not defined */
+    unsigned short usGpioLedAdsl;           /* GPIO pin or not defined */
+    unsigned short usGpioLedAdslFail;       /* GPIO pin or not defined */
+    unsigned short usGpioLedWireless;       /* GPIO pin or not defined */
+    unsigned short usGpioLedUsb;            /* GPIO pin or not defined */
+    unsigned short usGpioLedHpna;           /* GPIO pin or not defined */
+    unsigned short usGpioLedWanData;        /* GPIO pin or not defined */
+    unsigned short usGpioLedPpp;            /* GPIO pin or not defined */
+    unsigned short usGpioLedPppFail;        /* GPIO pin or not defined */
+    unsigned short usGpioLedBlPowerOn;      /* GPIO pin or not defined */
+    unsigned short usGpioLedBlAlarm;        /* GPIO pin or not defined */
+    unsigned short usGpioLedBlResetCfg;     /* GPIO pin or not defined */
+    unsigned short usGpioLedBlStop;         /* GPIO pin or not defined */
+    unsigned short usExtIntrWireless;       /* ext intr or not defined */
+    unsigned short usExtIntrAdslDyingGasp;  /* ext intr or not defined */
+    unsigned short usExtIntrHpna;           /* ext intr or not defined */
+    unsigned short usCsHpna;                /* chip select not defined */
+    unsigned short usAntInUseWireless;	    /* antenna in use or not defined */
+    unsigned short usGpioSesBtnWireless;    /* GPIO pin or not defined */
+    unsigned short usExtIntrSesBtnWireless; /* ext intr or not defined */        
+    unsigned short usGpioLedSesWireless;    /* GPIO pin or not defined */        
+} BOARD_PARAMETERS, *PBOARD_PARAMETERS;
+
+/* Variables */
+#if defined(_BCM96338_) || defined(CONFIG_BCM96338)
+static BOARD_PARAMETERS g_bcm96338sv =
+{
+    "96338SV",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_1_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_NOT_DEFINED,                         /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_NOT_DEFINED,                         /* usGpioLedBlResetCfg */
+    BP_NOT_DEFINED,                         /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */     
+};
+static BOARD_PARAMETERS g_bcm96338l2m8m =
+{
+    "96338L-2M-8M",                         /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */    
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */         
+};
+static PBOARD_PARAMETERS g_BoardParms[] =
+    {&g_bcm96338sv, &g_bcm96338l2m8m, 0};
+#endif
+
+#if defined(_BCM96345_) || defined(CONFIG_BCM96345)
+static BOARD_PARAMETERS g_bcm96345r =
+{
+    "96345R",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_GPIO_11_AH,                          /* usGpioRj11InnerPair */
+    BP_GPIO_12_AH,                          /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_GPIO_9_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_9_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96345gw2 =
+{
+    /* A hardware jumper determines whether GPIO 13 is used for Press and Hold
+     * Reset or RTS.
+     */
+    "96345GW2",                             /* szBoardId */
+    {{BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_GPIO_0_AH,                         /* usGpioPhySpiSck */
+      BP_GPIO_4_AH,                         /* usGpioPhySpiSs */
+      BP_GPIO_12_AH,                        /* usGpioPhySpiMosi */
+      BP_GPIO_11_AH,                        /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_GPIO,                  /* usConfigType */
+      BP_ENET_REVERSE_MII},                 /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_1,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_15_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_1_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_GPIO_2_AH,                           /* usGpioPcmciaReset */
+    BP_GPIO_13_AH,                          /* usGpioUartRts */
+    BP_GPIO_9_AH,                           /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_GPIO_7_AH,                           /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_7_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_EXT_INTR_2,                          /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96345gw =
+{
+    "96345GW",                              /* szBoardId */
+    {{BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_ENET_NO_REVERSE_MII},              /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_1,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_15_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_1_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_GPIO_11_AH,                          /* usGpioRj11InnerPair */
+    BP_GPIO_1_AH,                           /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_GPIO_2_AH,                           /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_GPIO_10_AH,                          /* usGpioLedWireless */
+    BP_GPIO_7_AH,                           /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_9_AH,                           /* usGpioLedBlAlarm */
+    BP_GPIO_10_AH,                          /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_EXT_INTR_2,                          /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_EXT_INTR_3,                          /* usExtIntrHpna */
+    BP_CS_1,                                /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96335r =
+{
+    "96335R",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_14_AH,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_9_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_9_AH,                           /* usGpioLedWanData */
+    BP_GPIO_8_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_8_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_9_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96345r0 =
+{
+    "96345R0",                              /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_9_AH,                           /* usGpioLedWanData */
+    BP_GPIO_9_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_9_AH,                           /* usGpioLedBlAlarm */
+    BP_GPIO_8_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */     
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96345rs =
+{
+    "96345RS",                              /* szBoardId */
+    {{BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_ENET_NO_REVERSE_MII},              /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_GPIO_11_AH,                          /* usGpioRj11InnerPair */
+    BP_GPIO_12_AH,                          /* usGpioRj11OuterPair */
+    BP_GPIO_13_AH,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_GPIO_8_AH,                           /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_8_AH,                           /* usGpioLedWanData */
+    BP_GPIO_9_AH,                           /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_GPIO_10_AH,                          /* usGpioLedBlAlarm */
+    BP_GPIO_9_AH,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_8_AH,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_EXT_INTR_0,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static PBOARD_PARAMETERS g_BoardParms[] =
+    {&g_bcm96345r, &g_bcm96345gw2, &g_bcm96345gw, &g_bcm96335r, &g_bcm96345r0,
+     &g_bcm96345rs, 0};
+#endif
+
+#if defined(_BCM96348_) || defined(CONFIG_BCM96348)
+
+static BOARD_PARAMETERS g_bcm96348r =
+{
+    "96348R",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY}},                     /* ucPhyType */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_8MB_1_CHIP,                   /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_7_AH,                           /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96348lv =
+{
+    "96348LV",                               /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_PHY,                 /* ucPhyType */
+      0x02,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_GPIO_5_AL,                         /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED}},                     /* usReverseMii */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_7_AH,                           /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96348gw =
+{
+    "96348GW",                              /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x03,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_0,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_34_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED, /* BP_GPIO_35_AH, */    /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED, /* BP_EXT_INTR_3, */    /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED  /* BP_GPIO_0_AL   */    /* usGpioLedSesWireless */
+};
+
+
+static BOARD_PARAMETERS g_bcm96348gw_10 =
+{
+    "96348GW-10",                           /* szBoardId */
+    {{BP_ENET_NO_PHY},                 /* ucPhyType */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_GPIO_6_AH,                         /* usGpioVoipReset */
+      BP_GPIO_34_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static BOARD_PARAMETERS g_bcm96348gw_11 =
+{
+    "96348GW-11",                           /* szBoardId */
+    {{BP_ENET_NO_PHY},                      /* ucPhyType */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x04,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */    
+};
+
+static BOARD_PARAMETERS g_bcm96348sv =
+{
+    "96348SV",                              /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_PHY,                 /* ucPhyType */
+      0x1f,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED}},                     /* usReverseMii */
+    {{BP_VOIP_NO_DSP},                      /* ucDspType */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_32MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_NOT_DEFINED,                         /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_NOT_DEFINED,                         /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_NOT_DEFINED,                         /* usGpioLedWanData */
+    BP_NOT_DEFINED,                         /* usGpioLedPpp */
+    BP_NOT_DEFINED,                         /* usGpioLedPppFail */
+    BP_NOT_DEFINED,                         /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_NOT_DEFINED,                         /* usGpioLedBlResetCfg */
+    BP_NOT_DEFINED,                         /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+
+static BOARD_PARAMETERS g_bcm96348gw_dualDsp =
+{
+    "96348GW-DualDSP",                      /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_EXTERNAL_SWITCH,              /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x03,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_UNEQUIPPED,                        /* usGpioVoipReset */
+      BP_GPIO_34_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_DSP,                          /* ucDspType */
+      0x01,                                 /* ucDspAddress */
+      BP_EXT_INTR_3,                        /* usExtIntrVoip */
+      BP_UNEQUIPPED ,                       /* usGpioVoipReset */
+      BP_GPIO_35_AH,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_3}},                            /* usCsVoip */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_HW_DEFINED,                          /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_WLAN_ANT_MAIN,                       /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+
+static BOARD_PARAMETERS g_bcmCustom_01 =
+{
+     "BCMCUST_01",                          /* szBoardId */
+    {{BP_ENET_INTERNAL_PHY,                 /* ucPhyType */
+      0x01,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_MDIO,                  /* usConfigType */
+      BP_NOT_DEFINED},                      /* usReverseMii */
+     {BP_ENET_NO_PHY,                       /* ucPhyType */
+      0x00,                                 /* ucPhyAddress */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSck */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiSs */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMosi */
+      BP_NOT_DEFINED,                       /* usGpioPhySpiMiso */
+      BP_NOT_DEFINED,                       /* usGpioPhyReset */
+      0x01,                                 /* numSwitchPorts */
+      BP_ENET_CONFIG_SPI_SSB_1,             /* usConfigType */
+      BP_ENET_REVERSE_MII}},                /* usReverseMii */
+    {{BP_VOIP_DSP,                          /* ucDspType */
+      0x00,                                 /* ucDspAddress */
+      BP_EXT_INTR_2,                        /* usExtIntrVoip */
+      BP_GPIO_36_AH,                        /* usGpioVoipReset */
+      BP_GPIO_34_AL,                        /* usGpioVoipIntr */
+      BP_NOT_DEFINED,                       /* usGpioLedVoip */
+      BP_CS_2},                             /* usCsVoip */
+     {BP_VOIP_NO_DSP}},                     /* ucDspType */
+    BP_MEMORY_16MB_2_CHIP,                  /* usSdramSize */
+    BP_PSI_DEFAULT_SIZE,                    /* usPsiSize */
+    BP_NOT_DEFINED,                         /* usGpioRj11InnerPair */
+    BP_NOT_DEFINED,                         /* usGpioRj11OuterPair */
+    BP_GPIO_33_AL,                          /* usGpioPressAndHoldReset */
+    BP_NOT_DEFINED,                         /* usGpioPcmciaReset */
+    BP_NOT_DEFINED,                         /* usGpioUartRts */
+    BP_NOT_DEFINED,                         /* usGpioUartCts */
+    BP_NOT_DEFINED,                         /* usGpioLedAdsl */
+    BP_GPIO_2_AL,                           /* usGpioLedAdslFail */
+    BP_NOT_DEFINED,                         /* usGpioLedWireless */
+    BP_NOT_DEFINED,                         /* usGpioLedUsb */
+    BP_NOT_DEFINED,                         /* usGpioLedHpna */
+    BP_GPIO_3_AL,                           /* usGpioLedWanData */
+    BP_GPIO_3_AL,                           /* usGpioLedPpp */
+    BP_GPIO_4_AL,                           /* usGpioLedPppFail */
+    BP_GPIO_0_AL,                           /* usGpioLedBlPowerOn */
+    BP_NOT_DEFINED,                         /* usGpioLedBlAlarm */
+    BP_GPIO_3_AL,                           /* usGpioLedBlResetCfg */
+    BP_GPIO_1_AL,                           /* usGpioLedBlStop */
+    BP_NOT_DEFINED,                         /* usExtIntrWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrAdslDyingGasp */
+    BP_NOT_DEFINED,                         /* usExtIntrHpna */
+    BP_NOT_DEFINED,                         /* usCsHpna */
+    BP_NOT_DEFINED,                         /* usAntInUseWireless */
+    BP_NOT_DEFINED,                         /* usGpioSesBtnWireless */
+    BP_NOT_DEFINED,                         /* usExtIntrSesBtnWireless */
+    BP_NOT_DEFINED                          /* usGpioLedSesWireless */
+};
+
+static PBOARD_PARAMETERS g_BoardParms[] =
+    {&g_bcm96348r, &g_bcm96348lv, &g_bcm96348gw, &g_bcm96348gw_10,
+     &g_bcm96348gw_11, &g_bcm96348sv, &g_bcm96348gw_dualDsp,
+     &g_bcmCustom_01, 0};
+#endif
+
+static PBOARD_PARAMETERS g_pCurrentBp = 0;
+
+/**************************************************************************
+ * Name       : bpstrcmp
+ *
+ * Description: String compare for this file so it does not depend on an OS.
+ *              (Linux kernel and CFE share this source file.)
+ *
+ * Parameters : [IN] dest - destination string
+ *              [IN] src - source string
+ *
+ * Returns    : -1 - dest < src, 1 - dest > src, 0 dest == src
+ ***************************************************************************/
+static int bpstrcmp(const char *dest,const char *src);
+static int bpstrcmp(const char *dest,const char *src)
+{
+    while (*src && *dest)
+    {
+        if (*dest < *src) return -1;
+        if (*dest > *src) return 1;
+        dest++;
+        src++;
+    }
+
+    if (*dest && !*src) return 1;
+    if (!*dest && *src) return -1;
+    return 0;
+} /* bpstrcmp */
+
+/**************************************************************************
+ * Name       : BpGetVoipDspConfig
+ *
+ * Description: Gets the DSP configuration from the board parameter
+ *              structure for a given DSP index.
+ *
+ * Parameters : [IN] dspNum - DSP index (number)
+ *
+ * Returns    : Pointer to DSP configuration block if found/valid, NULL
+ *              otherwise.
+ ***************************************************************************/
+VOIP_DSP_INFO *BpGetVoipDspConfig( unsigned char dspNum );
+VOIP_DSP_INFO *BpGetVoipDspConfig( unsigned char dspNum )
+{
+    VOIP_DSP_INFO *pDspConfig = 0;
+    int i;
+
+    if( g_pCurrentBp )
+    {
+        for( i = 0 ; i < BP_MAX_VOIP_DSP ; i++ )
+        {
+            if( g_pCurrentBp->VoIPDspInfo[i].ucDspType != BP_VOIP_NO_DSP &&
+                g_pCurrentBp->VoIPDspInfo[i].ucDspAddress == dspNum )
+            {
+                pDspConfig = &g_pCurrentBp->VoIPDspInfo[i];
+                break;
+            }
+        }
+    }
+
+    return pDspConfig;
+}
+
+
+/**************************************************************************
+ * Name       : BpSetBoardId
+ *
+ * Description: This function find the BOARD_PARAMETERS structure for the
+ *              specified board id string and assigns it to a global, static
+ *              variable.
+ *
+ * Parameters : [IN] pszBoardId - Board id string that is saved into NVRAM.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_FOUND - Error, board id input string does not
+ *                  have a board parameters configuration record.
+ ***************************************************************************/
+int BpSetBoardId( char *pszBoardId )
+{
+    int nRet = BP_BOARD_ID_NOT_FOUND;
+    PBOARD_PARAMETERS *ppBp;
+
+    for( ppBp = g_BoardParms; *ppBp; ppBp++ )
+    {
+        if( !bpstrcmp((*ppBp)->szBoardId, pszBoardId) )
+        {
+            g_pCurrentBp = *ppBp;
+            nRet = BP_SUCCESS;
+            break;
+        }
+    }
+
+    return( nRet );
+} /* BpSetBoardId */
+
+/**************************************************************************
+ * Name       : BpGetBoardIds
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pszBoardIds - Address of a buffer that the board id
+ *                  strings are returned in.  Each id starts at BP_BOARD_ID_LEN
+ *                  boundary.
+ *              [IN] nBoardIdsSize - Number of BP_BOARD_ID_LEN elements that
+ *                  were allocated in pszBoardIds.
+ *
+ * Returns    : Number of board id strings returned.
+ ***************************************************************************/
+int BpGetBoardIds( char *pszBoardIds, int nBoardIdsSize )
+{
+    PBOARD_PARAMETERS *ppBp;
+    int i;
+    char *src;
+    char *dest;
+
+    for( i = 0, ppBp = g_BoardParms; *ppBp && nBoardIdsSize;
+        i++, ppBp++, nBoardIdsSize--, pszBoardIds += BP_BOARD_ID_LEN )
+    {
+        dest = pszBoardIds;
+        src = (*ppBp)->szBoardId;
+        while( *src )
+            *dest++ = *src++;
+        *dest = '\0';
+    }
+
+    return( i );
+} /* BpGetBoardIds */
+
+/**************************************************************************
+ * Name       : BpGetEthernetMacInfo
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pEnetInfos - Address of an array of ETHERNET_MAC_INFO
+ *                  buffers.
+ *              [IN] nNumEnetInfos - Number of ETHERNET_MAC_INFO elements that
+ *                  are pointed to by pEnetInfos.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetEthernetMacInfo( PETHERNET_MAC_INFO pEnetInfos, int nNumEnetInfos )
+{
+    int i, nRet;
+
+    if( g_pCurrentBp )
+    {
+        for( i = 0; i < nNumEnetInfos; i++, pEnetInfos++ )
+        {
+            if( i < BP_MAX_ENET_MACS )
+            {
+                unsigned char *src = (unsigned char *)
+                    &g_pCurrentBp->EnetMacInfos[i];
+                unsigned char *dest = (unsigned char *) pEnetInfos;
+                int len = sizeof(ETHERNET_MAC_INFO);
+                while( len-- )
+                    *dest++ = *src++;
+            }
+            else
+                pEnetInfos->ucPhyType = BP_ENET_NO_PHY;
+        }
+
+        nRet = BP_SUCCESS;
+    }
+    else
+    {
+        for( i = 0; i < nNumEnetInfos; i++, pEnetInfos++ )
+            pEnetInfos->ucPhyType = BP_ENET_NO_PHY;
+
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetEthernetMacInfo */
+
+/**************************************************************************
+ * Name       : BpGetSdramSize
+ *
+ * Description: This function returns a constant that describees the board's
+ *              SDRAM type and size.
+ *
+ * Parameters : [OUT] pulSdramSize - Address of short word that the SDRAM size
+ *                  is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetSdramSize( unsigned long *pulSdramSize )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulSdramSize = g_pCurrentBp->usSdramSize;
+        nRet = BP_SUCCESS;
+    }
+    else
+    {
+        *pulSdramSize = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetSdramSize */
+
+/**************************************************************************
+ * Name       : BpGetPsiSize
+ *
+ * Description: This function returns the persistent storage size in K bytes.
+ *
+ * Parameters : [OUT] pulPsiSize - Address of short word that the persistent
+ *                  storage size is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetPsiSize( unsigned long *pulPsiSize )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulPsiSize = g_pCurrentBp->usPsiSize;
+        nRet = BP_SUCCESS;
+    }
+    else
+    {
+        *pulPsiSize = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPsiSize */
+
+/**************************************************************************
+ * Name       : BpGetRj11InnerOuterPairGpios
+ *
+ * Description: This function returns the GPIO pin assignments for changing
+ *              between the RJ11 inner pair and RJ11 outer pair.
+ *
+ * Parameters : [OUT] pusInner - Address of short word that the RJ11 inner pair
+ *                  GPIO pin is returned in.
+ *              [OUT] pusOuter - Address of short word that the RJ11 outer pair
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRj11InnerOuterPairGpios( unsigned short *pusInner,
+    unsigned short *pusOuter )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusInner = g_pCurrentBp->usGpioRj11InnerPair;
+        *pusOuter = g_pCurrentBp->usGpioRj11OuterPair;
+
+        if( g_pCurrentBp->usGpioRj11InnerPair != BP_NOT_DEFINED &&
+            g_pCurrentBp->usGpioRj11OuterPair != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusInner = *pusOuter = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetRj11InnerOuterPairGpios */
+
+/**************************************************************************
+ * Name       : BpGetPressAndHoldResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the press
+ *              and hold reset button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the press and hold
+ *                  reset button GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPressAndHoldResetGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioPressAndHoldReset;
+
+        if( g_pCurrentBp->usGpioPressAndHoldReset != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPressAndHoldResetGpio */
+
+/**************************************************************************
+ * Name       : BpGetVoipResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP reset
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipResetGpio( unsigned char dspNum, unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pusValue = pDspInfo->usGpioVoipReset;
+
+           if( *pusValue != BP_NOT_DEFINED ||
+               *pusValue == BP_UNEQUIPPED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pusValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipResetGpio */
+
+/**************************************************************************
+ * Name       : BpGetVoipIntrGpio
+ *
+ * Description: This function returns the GPIO pin assignment for VoIP interrupt.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP interrupt
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipIntrGpio( unsigned char dspNum, unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pusValue = pDspInfo->usGpioVoipIntr;
+
+           if( *pusValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pusValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipIntrGpio */
+
+/**************************************************************************
+ * Name       : BpGetPcmciaResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PCMCIA
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PCMCIA reset
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPcmciaResetGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioPcmciaReset;
+
+        if( g_pCurrentBp->usGpioPcmciaReset != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPcmciaResetGpio */
+
+/**************************************************************************
+ * Name       : BpGetUartRtsCtsGpios
+ *
+ * Description: This function returns the GPIO pin assignments for RTS and CTS
+ *              UART signals.
+ *
+ * Parameters : [OUT] pusRts - Address of short word that the UART RTS GPIO
+ *                  pin is returned in.
+ *              [OUT] pusCts - Address of short word that the UART CTS GPIO
+ *                  pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, board id input string does not
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRtsCtsUartGpios( unsigned short *pusRts, unsigned short *pusCts )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusRts = g_pCurrentBp->usGpioUartRts;
+        *pusCts = g_pCurrentBp->usGpioUartCts;
+
+        if( g_pCurrentBp->usGpioUartRts != BP_NOT_DEFINED &&
+            g_pCurrentBp->usGpioUartCts != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusRts = *pusCts = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetUartRtsCtsGpios */
+
+/**************************************************************************
+ * Name       : BpGetAdslLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedAdsl;
+
+        if( g_pCurrentBp->usGpioLedAdsl != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetAdslLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetAdslFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED that is used when there is a DSL connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslFailLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedAdslFail;
+
+        if( g_pCurrentBp->usGpioLedAdslFail != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetAdslFailLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedWireless;
+
+        if( g_pCurrentBp->usGpioLedWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetWirelessLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessAntInUse
+ *
+ * Description: This function returns the antennas in use for wireless
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Antenna
+ *                  is in use.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessAntInUse( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usAntInUseWireless;
+
+        if( g_pCurrentBp->usAntInUseWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );	
+} /* BpGetWirelessAntInUse */
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesBtnGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesBtnGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioSesBtnWireless;
+
+        if( g_pCurrentBp->usGpioSesBtnWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );	
+} /* BpGetWirelessSesBtnGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesExtIntr
+ *
+ * Description: This function returns the external interrupt number for the 
+ *              Wireless Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  external interrup is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesExtIntr( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usExtIntrSesBtnWireless;
+
+        if( g_pCurrentBp->usExtIntrSesBtnWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );	
+		
+} /* BpGetWirelessSesExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Led.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  Led GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedSesWireless;
+
+        if( g_pCurrentBp->usGpioLedSesWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+	
+} /* BpGetWirelessSesLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetUsbLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the USB
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the USB LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetUsbLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedUsb;
+
+        if( g_pCurrentBp->usGpioLedUsb != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetUsbLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetHpnaLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the HPNA
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the HPNA LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedHpna;
+
+        if( g_pCurrentBp->usGpioLedHpna != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetHpnaLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWanDataLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the WAN Data
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the WAN Data LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWanDataLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedWanData;
+
+        if( g_pCurrentBp->usGpioLedWanData != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetWanDataLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetPppLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedPpp;
+
+        if( g_pCurrentBp->usGpioLedPpp != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPppLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetPppFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED that is used when there is a PPP connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppFailLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedPppFail;
+
+        if( g_pCurrentBp->usGpioLedPppFail != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetPppFailLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderPowerOnLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the power
+ *              on LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderPowerOnLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlPowerOn;
+
+        if( g_pCurrentBp->usGpioLedBlPowerOn != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderPowerOn */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderAlarmLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the alarm
+ *              LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderAlarmLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlAlarm;
+
+        if( g_pCurrentBp->usGpioLedBlAlarm != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderAlarmLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderResetCfgLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the reset
+ *              configuration LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the reset
+ *                  configuration LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderResetCfgLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlResetCfg;
+
+        if( g_pCurrentBp->usGpioLedBlResetCfg != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderResetCfgLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetBootloaderStopLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the break
+ *              into bootloader LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the break into
+ *                  bootloader LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderStopLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pusValue = g_pCurrentBp->usGpioLedBlStop;
+
+        if( g_pCurrentBp->usGpioLedBlStop != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetBootloaderStopLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetVoipLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ *
+ * Note       : The VoIP structure would allow for having one LED per DSP
+ *              however, the board initialization function assumes only one
+ *              LED per functionality (ie one LED for VoIP).  Therefore in
+ *              order to keep this tidy and simple we do not make usage of the
+ *              one-LED-per-DSP function.  Instead, we assume that the LED for
+ *              VoIP is unique and associated with DSP 0 (always present on
+ *              any VoIP platform).  If changing this to a LED-per-DSP function
+ *              then one need to update the board initialization driver in
+ *              bcmdrivers\opensource\char\board\bcm963xx\impl1
+ ***************************************************************************/
+int BpGetVoipLedGpio( unsigned short *pusValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( 0 );
+
+        if( pDspInfo )
+        {
+           *pusValue = pDspInfo->usGpioLedVoip;
+
+           if( *pusValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pusValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pusValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipLedGpio */
+
+/**************************************************************************
+ * Name       : BpGetWirelessExtIntr
+ *
+ * Description: This function returns the Wireless external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the wireless
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessExtIntr( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usExtIntrWireless;
+
+        if( g_pCurrentBp->usExtIntrWireless != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetWirelessExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetAdslDyingGaspExtIntr
+ *
+ * Description: This function returns the ADSL Dying Gasp external interrupt
+ *              number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the ADSL Dying Gasp
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslDyingGaspExtIntr( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usExtIntrAdslDyingGasp;
+
+        if( g_pCurrentBp->usExtIntrAdslDyingGasp != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetAdslDyingGaspExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetVoipExtIntr
+ *
+ * Description: This function returns the VOIP external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  external interrupt number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipExtIntr( unsigned char dspNum, unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pulValue = pDspInfo->usExtIntrVoip;
+
+           if( *pulValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pulValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetHpnaExtIntr
+ *
+ * Description: This function returns the HPNA external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaExtIntr( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usExtIntrHpna;
+
+        if( g_pCurrentBp->usExtIntrHpna != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetHpnaExtIntr */
+
+/**************************************************************************
+ * Name       : BpGetHpnaChipSelect
+ *
+ * Description: This function returns the HPNA chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  chip select number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaChipSelect( unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        *pulValue = g_pCurrentBp->usCsHpna;
+
+        if( g_pCurrentBp->usCsHpna != BP_NOT_DEFINED )
+        {
+            nRet = BP_SUCCESS;
+        }
+        else
+        {
+            nRet = BP_VALUE_NOT_DEFINED;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetHpnaChipSelect */
+
+/**************************************************************************
+ * Name       : BpGetVoipChipSelect
+ *
+ * Description: This function returns the VOIP chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  chip select number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipChipSelect( unsigned char dspNum, unsigned long *pulValue )
+{
+    int nRet;
+
+    if( g_pCurrentBp )
+    {
+        VOIP_DSP_INFO *pDspInfo = BpGetVoipDspConfig( dspNum );
+
+        if( pDspInfo )
+        {
+           *pulValue = pDspInfo->usCsVoip;
+
+           if( *pulValue != BP_NOT_DEFINED )
+           {
+              nRet = BP_SUCCESS;
+           }
+           else
+           {
+              nRet = BP_VALUE_NOT_DEFINED;
+           }
+        }
+        else
+        {
+           *pulValue = BP_NOT_DEFINED;
+           nRet = BP_BOARD_ID_NOT_FOUND;
+        }
+    }
+    else
+    {
+        *pulValue = BP_NOT_DEFINED;
+        nRet = BP_BOARD_ID_NOT_SET;
+    }
+
+    return( nRet );
+} /* BpGetVoipChipSelect */
+
diff -urN linux-2.6.8.1/boardparams/bcm963xx/boardparms.h linux-2.6.8.1-brcm63xx/boardparms/bcm963xx/boardparms.h
--- linux-2.6.8.1/boardparams/bcm963xx/boardparms.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.8.1-brcm63xx/boardparms/bcm963xx/boardparms.h	2006-06-26 09:07:10.000000000 +0200
@@ -0,0 +1,766 @@
+/*
+<:copyright-gpl 
+
+ Copyright 2003 Broadcom Corp. All Rights Reserved. 
+ 
+ This program is free software; you can distribute it and/or modify it 
+ under the terms of the GNU General Public License (Version 2) as 
+ published by the Free Software Foundation. 
+ 
+ This program is distributed in the hope it will be useful, but WITHOUT 
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
+ for more details. 
+ 
+ You should have received a copy of the GNU General Public License along 
+ with this program; if not, write to the Free Software Foundation, Inc., 
+ 59 Temple Place - Suite 330, Boston MA 02111-1307, USA. 
+
+:>
+*/
+/**************************************************************************
+ * File Name  : boardparms.h
+ *
+ * Description: This file contains definitions and function prototypes for
+ *              the BCM63xx board parameter access functions.
+ * 
+ * Updates    : 07/14/2003  Created.
+ ***************************************************************************/
+
+#if !defined(_BOARDPARMS_H)
+#define _BOARDPARMS_H
+#define CONFIG_BCM96348
+#if __cplusplus
+extern "C" {
+#endif
+
+/* Return codes. */
+#define BP_SUCCESS                              0
+#define BP_BOARD_ID_NOT_FOUND                   1
+#define BP_VALUE_NOT_DEFINED                    2
+#define BP_BOARD_ID_NOT_SET                     3
+
+/* Values for BpGetSdramSize. */
+#define BP_MEMORY_8MB_1_CHIP                    0
+#define BP_MEMORY_16MB_1_CHIP                   1
+#define BP_MEMORY_32MB_1_CHIP                   2
+#define BP_MEMORY_64MB_2_CHIP                   3
+#define BP_MEMORY_32MB_2_CHIP                   4
+#define BP_MEMORY_16MB_2_CHIP                   5
+
+/* Values for EthernetMacInfo PhyType. */
+#define BP_ENET_NO_PHY                          0
+#define BP_ENET_INTERNAL_PHY                    1
+#define BP_ENET_EXTERNAL_PHY                    2
+#define BP_ENET_EXTERNAL_SWITCH                 3
+
+/* Values for EthernetMacInfo Configuration type. */
+#define BP_ENET_CONFIG_MDIO                     0       /* Internal PHY, External PHY, Switch+(no GPIO, no SPI, no MDIO Pseudo phy */
+#define BP_ENET_CONFIG_GPIO                     1       /* Bcm96345GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_MDIO_PSEUDO_PHY          2       /* Bcm96348GW board + Bcm5325E */
+#define BP_ENET_CONFIG_SPI_SSB_0                3       /* Bcm96348GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_SPI_SSB_1                4       /* Bcm96348GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_SPI_SSB_2                5       /* Bcm96348GW board + Bcm5325M/E */
+#define BP_ENET_CONFIG_SPI_SSB_3                6       /* Bcm96348GW board + Bcm5325M/E */
+
+/* Values for EthernetMacInfo Reverse MII. */
+#define BP_ENET_NO_REVERSE_MII                  0
+#define BP_ENET_REVERSE_MII                     1
+
+/* Values for VoIPDSPInfo DSPType. */
+#define BP_VOIP_NO_DSP                          0
+#define BP_VOIP_DSP                             1
+
+
+/* Values for GPIO pin assignments (AH = Active High, AL = Active Low). */
+#define BP_ACTIVE_MASK                          0x8000
+#define BP_ACTIVE_HIGH                          0x0000
+#define BP_ACTIVE_LOW                           0x8000
+#define BP_GPIO_0_AH                            (0  | BP_ACTIVE_HIGH)
+#define BP_GPIO_0_AL                            (0  | BP_ACTIVE_LOW)
+#define BP_GPIO_1_AH                            (1  | BP_ACTIVE_HIGH)
+#define BP_GPIO_1_AL                            (1  | BP_ACTIVE_LOW)
+#define BP_GPIO_2_AH                            (2  | BP_ACTIVE_HIGH)
+#define BP_GPIO_2_AL                            (2  | BP_ACTIVE_LOW)
+#define BP_GPIO_3_AH                            (3  | BP_ACTIVE_HIGH)
+#define BP_GPIO_3_AL                            (3  | BP_ACTIVE_LOW)
+#define BP_GPIO_4_AH                            (4  | BP_ACTIVE_HIGH)
+#define BP_GPIO_4_AL                            (4  | BP_ACTIVE_LOW)
+#define BP_GPIO_5_AH                            (5  | BP_ACTIVE_HIGH)
+#define BP_GPIO_5_AL                            (5  | BP_ACTIVE_LOW)
+#define BP_GPIO_6_AH                            (6  | BP_ACTIVE_HIGH)
+#define BP_GPIO_6_AL                            (6  | BP_ACTIVE_LOW)
+#define BP_GPIO_7_AH                            (7  | BP_ACTIVE_HIGH)
+#define BP_GPIO_7_AL                            (7  | BP_ACTIVE_LOW)
+#define BP_GPIO_8_AH                            (8  | BP_ACTIVE_HIGH)
+#define BP_GPIO_8_AL                            (8  | BP_ACTIVE_LOW)
+#define BP_GPIO_9_AH                            (9  | BP_ACTIVE_HIGH)
+#define BP_GPIO_9_AL                            (9  | BP_ACTIVE_LOW)
+#define BP_GPIO_10_AH                           (10 | BP_ACTIVE_HIGH)
+#define BP_GPIO_10_AL                           (10 | BP_ACTIVE_LOW)
+#define BP_GPIO_11_AH                           (11 | BP_ACTIVE_HIGH)
+#define BP_GPIO_11_AL                           (11 | BP_ACTIVE_LOW)
+#define BP_GPIO_12_AH                           (12 | BP_ACTIVE_HIGH)
+#define BP_GPIO_12_AL                           (12 | BP_ACTIVE_LOW)
+#define BP_GPIO_13_AH                           (13 | BP_ACTIVE_HIGH)
+#define BP_GPIO_13_AL                           (13 | BP_ACTIVE_LOW)
+#define BP_GPIO_14_AH                           (14 | BP_ACTIVE_HIGH)
+#define BP_GPIO_14_AL                           (14 | BP_ACTIVE_LOW)
+#define BP_GPIO_15_AH                           (15 | BP_ACTIVE_HIGH)
+#define BP_GPIO_15_AL                           (15 | BP_ACTIVE_LOW)
+#define BP_GPIO_16_AH                           (16 | BP_ACTIVE_HIGH)
+#define BP_GPIO_16_AL                           (16 | BP_ACTIVE_LOW)
+#define BP_GPIO_17_AH                           (17 | BP_ACTIVE_HIGH)
+#define BP_GPIO_17_AL                           (17 | BP_ACTIVE_LOW)
+#define BP_GPIO_18_AH                           (18 | BP_ACTIVE_HIGH)
+#define BP_GPIO_18_AL                           (18 | BP_ACTIVE_LOW)
+#define BP_GPIO_19_AH                           (19 | BP_ACTIVE_HIGH)
+#define BP_GPIO_19_AL                           (19 | BP_ACTIVE_LOW)
+#define BP_GPIO_20_AH                           (20 | BP_ACTIVE_HIGH)
+#define BP_GPIO_20_AL                           (20 | BP_ACTIVE_LOW)
+#define BP_GPIO_21_AH                           (21 | BP_ACTIVE_HIGH)
+#define BP_GPIO_21_AL                           (21 | BP_ACTIVE_LOW)
+#define BP_GPIO_22_AH                           (22 | BP_ACTIVE_HIGH)
+#define BP_GPIO_22_AL                           (22 | BP_ACTIVE_LOW)
+#define BP_GPIO_23_AH                           (23 | BP_ACTIVE_HIGH)
+#define BP_GPIO_23_AL                           (23 | BP_ACTIVE_LOW)
+#define BP_GPIO_24_AH                           (24 | BP_ACTIVE_HIGH)
+#define BP_GPIO_24_AL                           (24 | BP_ACTIVE_LOW)
+#define BP_GPIO_25_AH                           (25 | BP_ACTIVE_HIGH)
+#define BP_GPIO_25_AL                           (25 | BP_ACTIVE_LOW)
+#define BP_GPIO_26_AH                           (26 | BP_ACTIVE_HIGH)
+#define BP_GPIO_26_AL                           (26 | BP_ACTIVE_LOW)
+#define BP_GPIO_27_AH                           (27 | BP_ACTIVE_HIGH)
+#define BP_GPIO_27_AL                           (27 | BP_ACTIVE_LOW)
+#define BP_GPIO_28_AH                           (28 | BP_ACTIVE_HIGH)
+#define BP_GPIO_28_AL                           (28 | BP_ACTIVE_LOW)
+#define BP_GPIO_29_AH                           (29 | BP_ACTIVE_HIGH)
+#define BP_GPIO_29_AL                           (29 | BP_ACTIVE_LOW)
+#define BP_GPIO_30_AH                           (30 | BP_ACTIVE_HIGH)
+#define BP_GPIO_30_AL                           (30 | BP_ACTIVE_LOW)
+#define BP_GPIO_31_AH                           (31 | BP_ACTIVE_HIGH)
+#define BP_GPIO_31_AL                           (31 | BP_ACTIVE_LOW)
+#define BP_GPIO_32_AH                           (32 | BP_ACTIVE_HIGH)
+#define BP_GPIO_32_AL                           (32 | BP_ACTIVE_LOW)
+#define BP_GPIO_33_AH                           (33 | BP_ACTIVE_HIGH)
+#define BP_GPIO_33_AL                           (33 | BP_ACTIVE_LOW)
+#define BP_GPIO_34_AH                           (34 | BP_ACTIVE_HIGH)
+#define BP_GPIO_34_AL                           (34 | BP_ACTIVE_LOW)
+#define BP_GPIO_35_AH                           (35 | BP_ACTIVE_HIGH)
+#define BP_GPIO_35_AL                           (35 | BP_ACTIVE_LOW)
+#define BP_GPIO_36_AH                           (36 | BP_ACTIVE_HIGH)
+#define BP_GPIO_36_AL                           (36 | BP_ACTIVE_LOW)
+
+/* Values for external interrupt assignments. */
+#define BP_EXT_INTR_0                           0
+#define BP_EXT_INTR_1                           1
+#define BP_EXT_INTR_2                           2
+#define BP_EXT_INTR_3                           3
+
+/* Values for chip select assignments. */
+#define BP_CS_0                                 0
+#define BP_CS_1                                 1
+#define BP_CS_2                                 2
+#define BP_CS_3                                 3
+
+/* Value for GPIO and external interrupt fields that are not used. */
+#define BP_NOT_DEFINED                          0xffff
+#define BP_HW_DEFINED                           0xfff0
+#define BP_UNEQUIPPED                           0xfff1
+
+/* Maximum size of the board id string. */
+#define BP_BOARD_ID_LEN                         16
+
+/* Maximum number of Ethernet MACs. */
+#define BP_MAX_ENET_MACS                        2
+
+/* Maximum number of VoIP DSPs. */
+#define BP_MAX_VOIP_DSP                         2
+
+/* Wireless Antenna Settings. */
+#define BP_WLAN_ANT_MAIN                        0
+#define BP_WLAN_ANT_AUX                         1
+#define BP_WLAN_ANT_BOTH                        3
+
+#if !defined(__ASSEMBLER__)
+
+/* Information about an Ethernet MAC.  If ucPhyType is BP_ENET_NO_PHY,
+ * then the other fields are not valid.
+ */
+typedef struct EthernetMacInfo
+{
+    unsigned char ucPhyType;                    /* BP_ENET_xxx             */
+    unsigned char ucPhyAddress;                 /* 0 to 31                 */
+    unsigned short usGpioPhySpiSck;             /* GPIO pin or not defined */
+    unsigned short usGpioPhySpiSs;              /* GPIO pin or not defined */
+    unsigned short usGpioPhySpiMosi;            /* GPIO pin or not defined */
+    unsigned short usGpioPhySpiMiso;            /* GPIO pin or not defined */
+    unsigned short usGpioPhyReset;              /* GPIO pin or not defined (96348LV) */
+    unsigned short numSwitchPorts;              /* Number of PHY ports */
+    unsigned short usConfigType;                /* Configuration type */
+    unsigned short usReverseMii;                /* Reverse MII */
+} ETHERNET_MAC_INFO, *PETHERNET_MAC_INFO;
+
+
+/* Information about VoIP DSPs.  If ucDspType is BP_VOIP_NO_DSP,
+ * then the other fields are not valid.
+ */
+typedef struct VoIPDspInfo
+{
+    unsigned char  ucDspType;
+    unsigned char  ucDspAddress;
+    unsigned short usExtIntrVoip;
+    unsigned short usGpioVoipReset;
+    unsigned short usGpioVoipIntr;
+    unsigned short usGpioLedVoip;
+    unsigned short usCsVoip;
+
+} VOIP_DSP_INFO;
+
+
+/**************************************************************************
+ * Name       : BpSetBoardId
+ *
+ * Description: This function find the BOARD_PARAMETERS structure for the
+ *              specified board id string and assigns it to a global, static
+ *              variable.
+ *
+ * Parameters : [IN] pszBoardId - Board id string that is saved into NVRAM.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_FOUND - Error, board id input string does not
+ *                  have a board parameters configuration record.
+ ***************************************************************************/
+int BpSetBoardId( char *pszBoardId );
+
+/**************************************************************************
+ * Name       : BpGetBoardIds
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pszBoardIds - Address of a buffer that the board id
+ *                  strings are returned in.  Each id starts at BP_BOARD_ID_LEN
+ *                  boundary.
+ *              [IN] nBoardIdsSize - Number of BP_BOARD_ID_LEN elements that
+ *                  were allocated in pszBoardIds.
+ *
+ * Returns    : Number of board id strings returned.
+ ***************************************************************************/
+int BpGetBoardIds( char *pszBoardIds, int nBoardIdsSize );
+
+/**************************************************************************
+ * Name       : BpGetEthernetMacInfo
+ *
+ * Description: This function returns all of the supported board id strings.
+ *
+ * Parameters : [OUT] pEnetInfos - Address of an array of ETHERNET_MAC_INFO
+ *                  buffers.
+ *              [IN] nNumEnetInfos - Number of ETHERNET_MAC_INFO elements that
+ *                  are pointed to by pEnetInfos.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetEthernetMacInfo( PETHERNET_MAC_INFO pEnetInfos, int nNumEnetInfos );
+
+/**************************************************************************
+ * Name       : BpGetSdramSize
+ *
+ * Description: This function returns a constant that describees the board's
+ *              SDRAM type and size.
+ *
+ * Parameters : [OUT] pulSdramSize - Address of short word that the SDRAM size
+ *                  is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetSdramSize( unsigned long *pulSdramSize );
+
+/**************************************************************************
+ * Name       : BpGetPsiSize
+ *
+ * Description: This function returns the persistent storage size in K bytes.
+ *
+ * Parameters : [OUT] pulPsiSize - Address of short word that the persistent
+ *                  storage size is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ ***************************************************************************/
+int BpGetPsiSize( unsigned long *pulPsiSize );
+
+/**************************************************************************
+ * Name       : BpGetRj11InnerOuterPairGpios
+ *
+ * Description: This function returns the GPIO pin assignments for changing
+ *              between the RJ11 inner pair and RJ11 outer pair.
+ *
+ * Parameters : [OUT] pusInner - Address of short word that the RJ11 inner pair
+ *                  GPIO pin is returned in.
+ *              [OUT] pusOuter - Address of short word that the RJ11 outer pair
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRj11InnerOuterPairGpios( unsigned short *pusInner,
+    unsigned short *pusOuter );
+
+/**************************************************************************
+ * Name       : BpGetPressAndHoldResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the press
+ *              and hold reset button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the press and hold
+ *                  reset button GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPressAndHoldResetGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP reset
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipResetGpio( unsigned char dspNum, unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipIntrGpio
+ *
+ * Description: This function returns the GPIO pin assignment for VoIP interrupt.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP interrupt
+ *                  GPIO pin is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipIntrGpio( unsigned char dspNum, unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetPcmciaResetGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PCMCIA
+ *              Reset operation.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PCMCIA reset
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPcmciaResetGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetUartRtsCtsGpios
+ *
+ * Description: This function returns the GPIO pin assignments for RTS and CTS
+ *              UART signals.
+ *
+ * Parameters : [OUT] pusRts - Address of short word that the UART RTS GPIO
+ *                  pin is returned in.
+ *              [OUT] pusCts - Address of short word that the UART CTS GPIO
+ *                  pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, values are returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetRtsCtsUartGpios( unsigned short *pusRts, unsigned short *pusCts );
+
+/**************************************************************************
+ * Name       : BpGetAdslLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetAdslFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the ADSL
+ *              LED that is used when there is a DSL connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the ADSL LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslFailLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessAntInUse
+ *
+ * Description: This function returns the antennas in use for wireless
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Antenna
+ *                  is in use.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessAntInUse( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesBtnGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  Button GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesBtnGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesExtIntr
+ *
+ * Description: This function returns the external interrupt number for the 
+ *              Wireless Ses Button.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  external interrup is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesExtIntr( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessSesLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the Wireless
+ *              Ses Led.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the Wireless Ses
+ *                  Led GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessSesLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetUsbLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the USB
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the USB LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetUsbLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetHpnaLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the HPNA
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the HPNA LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWanDataLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the WAN Data
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the WAN Data LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWanDataLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetPppLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetPppFailLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the PPP
+ *              LED that is used when there is a PPP connection failure.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the PPP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetPppFailLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the VOIP
+ *              LED.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the VOIP LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderPowerOnLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the power
+ *              on LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderPowerOnLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderAlarmLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the alarm
+ *              LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the alarm LED
+ *                  GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderAlarmLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderResetCfgLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the reset
+ *              configuration LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the reset
+ *                  configuration LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderResetCfgLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetBootloaderStopLedGpio
+ *
+ * Description: This function returns the GPIO pin assignment for the break
+ *              into bootloader LED that is set by the bootloader.
+ *
+ * Parameters : [OUT] pusValue - Address of short word that the break into
+ *                  bootloader LED GPIO pin is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetBootloaderStopLedGpio( unsigned short *pusValue );
+
+/**************************************************************************
+ * Name       : BpGetWirelessExtIntr
+ *
+ * Description: This function returns the Wireless external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the wireless
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetWirelessExtIntr( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetAdslDyingGaspExtIntr
+ *
+ * Description: This function returns the ADSL Dying Gasp external interrupt
+ *              number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the ADSL Dying Gasp
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetAdslDyingGaspExtIntr( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipExtIntr
+ *
+ * Description: This function returns the VOIP external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  external interrupt number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipExtIntr( unsigned char dspNum, unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetHpnaExtIntr
+ *
+ * Description: This function returns the HPNA external interrupt number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  external interrupt number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaExtIntr( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetHpnaChipSelect
+ *
+ * Description: This function returns the HPNA chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the HPNA
+ *                  chip select number is returned in.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetHpnaChipSelect( unsigned long *pulValue );
+
+/**************************************************************************
+ * Name       : BpGetVoipChipSelect
+ *
+ * Description: This function returns the VOIP chip select number.
+ *
+ * Parameters : [OUT] pulValue - Address of short word that the VOIP
+ *                  chip select number is returned in.
+ *              [IN] dspNum - Address of the DSP to query.
+ *
+ * Returns    : BP_SUCCESS - Success, value is returned.
+ *              BP_BOARD_ID_NOT_SET - Error, BpSetBoardId has not been called.
+ *              BP_VALUE_NOT_DEFINED - At least one return value is not defined
+ *                  for the board.
+ ***************************************************************************/
+int BpGetVoipChipSelect( unsigned char dspNum, unsigned long *pulValue );
+
+#endif /* __ASSEMBLER__ */
+
+#if __cplusplus
+}
+#endif
+
+#endif /* _BOARDPARMS_H */
+
--- linux-2.6.8.1/scripts/kconfig/mconf.c	2004-08-14 12:54:51.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/scripts/kconfig/mconf.c	2006-06-26 10:07:52.000000000 +0200
@@ -88,7 +88,7 @@
 static int indent;
 static struct termios ios_org;
 static int rows = 0, cols = 0;
-static struct menu *current_menu;
+struct menu *current_menu; /* Fails while cross-compiling if keeping static */
 static int child_count;
 static int do_resize;
 static int single_menu_mode;
--- linux-2.6.8.1/Makefile	2004-08-14 12:55:35.000000000 +0200
+++ linux-2.6.8.1-brcm63xx/Makefile	2006-06-26 10:43:09.000000000 +0200
@@ -149,9 +149,7 @@
 # then ARCH is assigned, getting whatever value it gets normally, and 
 # SUBARCH is subsequently ignored.
 
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ )
+SUBARCH := mips
 
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
@@ -294,7 +292,7 @@
 
 NOSTDINC_FLAGS  = -nostdinc -iwithprefix include
 
-CPPFLAGS        := -D__KERNEL__ -Iinclude \
+CPPFLAGS        := -D__KERNEL__ -Iinclude -Ibcmdrivers/opensource/include/bcm963xx/ -Iboardparms/bcm963xx/ -Ibcmdrivers/broadcom/include/bcm963xx/ -Ibcmdrivers/broadcom/char/adsl/bcm96348\
 		   $(if $(KBUILD_SRC),-Iinclude2 -I$(srctree)/include)
 
 CFLAGS 		:= -Wall -Wstrict-prototypes -Wno-trigraphs \
@@ -405,6 +403,13 @@
 core-y		:= usr/
 endif # KBUILD_EXTMOD
 
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+BRCMDRIVERS_DIR := $(TOPDIR)/bcmdrivers
+export HPATH 	:= $(TOPDIR)/include
+brcmdrivers-y	:= $(TOPDIR)/boardparms/bcm963xx/ $(BRCMDRIVERS_DIR)/
+BRCMDRIVERS	:= $(brcmdrivers-y)
+# CONFIG_MIPS_BRCM End Broadcom changed code.
+
 ifeq ($(dot-config),1)
 # In this section, we need .config
 
@@ -473,6 +478,10 @@
 # makefile but the arguement can be passed to make if needed.
 #
 
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+INSTALL_MOD_PATH := $(PROFILE_DIR)/modules
+# CONFIG_MIPS_BRCM End Broadcom changed code.
+
 MODLIB	:= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
 export MODLIB
 
@@ -480,18 +489,25 @@
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/
 
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
+		     $(brcmdrivers-y) $(brcmdrivers-m) \
 		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
 		     $(init-n) $(init-) \
 		     $(core-n) $(core-) $(drivers-n) $(drivers-) \
+		     $(brcmdrivers-n) $(brcmdrivers-) \
 		     $(net-n)  $(net-)  $(libs-n)    $(libs-))))
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 
 init-y		:= $(patsubst %/, %/built-in.o, $(init-y))
 core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
 drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+brcmdrivers-y   := $(patsubst %/, %/built-in.o, $(brcmdrivers-y))
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
 libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
 libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
@@ -507,7 +523,8 @@
 #       we cannot yet know if we will need to relink vmlinux.
 #	So we descend into init/ inside the rule for vmlinux again.
 head-y += $(HEAD)
-vmlinux-objs := $(head-y) $(init-y) $(core-y) $(libs-y) $(drivers-y) $(net-y)
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+vmlinux-objs := $(head-y) $(init-y) $(core-y) $(libs-y) $(drivers-y) $(brcmdrivers-y) $(net-y)
 
 quiet_cmd_vmlinux__ = LD      $@
 define cmd_vmlinux__
@@ -516,11 +533,13 @@
 	$(core-y) \
 	$(libs-y) \
 	$(drivers-y) \
+	$(brcmdrivers-y) \
 	$(net-y) \
 	--end-group \
 	$(filter .tmp_kallsyms%,$^) \
 	-o $@
 endef
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 
 #	set -e makes the rule exit immediately on error
 
@@ -603,9 +622,12 @@
 	$(rule_verify_kallsyms)
 endef
 
-vmlinux: $(vmlinux-objs) $(kallsyms.o) arch/$(ARCH)/kernel/vmlinux.lds.s FORCE
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+vmlinux: preparebrcmdriver $(vmlinux-objs) $(kallsyms.o) arch/$(ARCH)/kernel/vmlinux.lds.s FORCE
 	$(call if_changed_rule,vmlinux)
 
+# CONFIG_MIPS_BRCM End Broadcom changed code.
+
 #	The actual objects are generated when descending, 
 #	make sure no implicit rule kicks in
 
@@ -626,7 +648,13 @@
 # A multi level approach is used. prepare1 is updated first, then prepare0.
 # prepare-all is the collection point for the prepare targets.
 
-.PHONY: prepare-all prepare prepare0 prepare1 prepare2
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+.PHONY: prepare-all prepare prepare0 prepare1 prepare2 preparebrcmdriver
+
+preparebrcmdriver:
+#	$(Q)$(MAKE) -C $(BRCMDRIVERS_DIR)/opensource symlinks
+	$(Q)$(MAKE) -C $(BRCMDRIVERS_DIR)/broadcom symlinks
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 
 # prepare 2 generate Makefile to be placed in output directory, if
 # using a seperate output directory. This allows convinient use
@@ -743,7 +771,10 @@
 #	Build modules
 
 .PHONY: modules
-modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux)
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+modules: preparebrcmdriver $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux)
+#modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux)
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 	@echo '  Building modules, stage 2.';
 	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modpost
 
@@ -754,23 +785,31 @@
 
 # Target to install modules
 .PHONY: modules_install
-modules_install: _modinst_ _modinst_post
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+#modules_install: _modinst_ _modinst_post
+#We have no need for it "_modinst_post"
+modules_install: _modinst_ 
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 
 .PHONY: _modinst_
 _modinst_:
-	@if [ -z "`$(DEPMOD) -V | grep module-init-tools`" ]; then \
-		echo "Warning: you may need to install module-init-tools"; \
-		echo "See http://www.codemonkey.org.uk/docs/post-halloween-2.6.txt";\
-		sleep 1; \
-	fi
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
+#	@if [ -z "`$(DEPMOD) -V | grep module-init-tools`" ]; then \
+#		echo "Warning: you may need to install module-init-tools"; \
+#		echo "See http://www.codemonkey.org.uk/docs/post-halloween-2.6.txt";\
+#		sleep 1; \
+#	fi
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 	@rm -rf $(MODLIB)/kernel
 	@rm -f $(MODLIB)/source
 	@mkdir -p $(MODLIB)/kernel
-	@ln -s $(srctree) $(MODLIB)/source
-	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
-		rm -f $(MODLIB)/build ; \
-		ln -s $(objtree) $(MODLIB)/build ; \
-	fi
+# CONFIG_MIPS_BRCM Begin Broadcom changed code	
+#	@ln -s $(srctree) $(MODLIB)/source
+#	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
+#		rm -f $(MODLIB)/build ; \
+#		ln -s $(objtree) $(MODLIB)/build ; \
+#	fi
+# CONFIG_MIPS_BRCM End Broadcom changed code.	
 	$(Q)$(MAKE) -rR -f $(srctree)/scripts/Makefile.modinst
 
 # If System.map exists, run depmod.  This deliberately does not have a
@@ -853,10 +892,12 @@
 clean: archclean $(clean-dirs)
 	$(call cmd,rmdirs)
 	$(call cmd,rmfiles)
+# CONFIG_MIPS_BRCM Begin Broadcom changed code.
 	@find . $(RCS_FIND_IGNORE) \
 	 	\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \) \
 		-type f -print | xargs rm -f
+# CONFIG_MIPS_BRCM End Broadcom changed code.
 
 # mrproper - Delete all generated files, including .config
 #
@@ -883,7 +924,7 @@
 	 	-o -name '.*.rej' -o -size 0 \
 		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
 		-type f -print | xargs rm -f
-
+	rm vmlinux.bin vmlinux.lz
 
 # Packaging of the kernel to various formats
 # ---------------------------------------------------------------------------
