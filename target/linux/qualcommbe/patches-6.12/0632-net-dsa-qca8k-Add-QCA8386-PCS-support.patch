From e5c1f410b7bf6d8703de206592c2fa025dfd746b Mon Sep 17 00:00:00 2001
From: Luo Jie <quic_luoj@quicinc.com>
Date: Fri, 8 Mar 2024 17:41:17 +0800
Subject: [PATCH 632/636] net: dsa: qca8k: Add QCA8386 PCS support

Port0 and port5 are connected with the SoC(such as IPQ platform)
via PCS.

There is PCS driver named as pcs-qca8k, which supports the SGMII
and 2500BASEX.

Signed-off-by: Luo Jie <quic_luoj@quicinc.com>
---
 drivers/net/dsa/qca/Kconfig      |   1 +
 drivers/net/dsa/qca/qca8k-8xxx.c | 201 ++++++++++++++++++++++++++++++-
 drivers/net/dsa/qca/qca8k.h      |   6 +
 3 files changed, 205 insertions(+), 3 deletions(-)

diff --git a/drivers/net/dsa/qca/Kconfig b/drivers/net/dsa/qca/Kconfig
index de9da469908b..dbb8a8ed657c 100644
--- a/drivers/net/dsa/qca/Kconfig
+++ b/drivers/net/dsa/qca/Kconfig
@@ -12,6 +12,7 @@ config NET_DSA_QCA8K
 	tristate "Qualcomm Atheros QCA8K Ethernet switch family support"
 	select NET_DSA_TAG_QCA
 	select REGMAP
+	select PCS_QCA8K
 	help
 	  This enables support for the Qualcomm Atheros QCA8K Ethernet
 	  switch chips.
diff --git a/drivers/net/dsa/qca/qca8k-8xxx.c b/drivers/net/dsa/qca/qca8k-8xxx.c
index c9d3196ee576..e74816905208 100644
--- a/drivers/net/dsa/qca/qca8k-8xxx.c
+++ b/drivers/net/dsa/qca/qca8k-8xxx.c
@@ -22,6 +22,7 @@
 #include <linux/dsa/tag_qca.h>
 #include <linux/clk.h>
 #include <linux/reset.h>
+#include <linux/pcs/pcs-qca8k.h>
 
 #include "qca8k.h"
 #include "qca8k_leds.h"
@@ -1216,9 +1217,17 @@ static void qca8386_port_reset_release(struct qca8k_priv *priv)
 	struct dsa_port *dp;
 	int ret;
 
-	dsa_switch_for_each_available_port(dp, priv->ds)
+	dsa_switch_for_each_available_port(dp, priv->ds) {
+		if (dsa_port_is_user(dp)) {
+			clk_set_rate(priv->port[dp->index].clk[EPHY_RX_CLK],
+				     P_XO_CLOCK_RATE);
+			clk_set_rate(priv->port[dp->index].clk[EPHY_TX_CLK],
+				     P_XO_CLOCK_RATE);
+		}
+
 		for (ret = 0; ret < PORT_RESET_CNT; ret++)
 			reset_control_put(priv->port[dp->index].reset[ret]);
+	}
 }
 
 static int qca8386_parse_port_config(struct qca8k_priv *priv)
@@ -1392,6 +1401,34 @@ qca8k_mac_config_setup_internal_delay(struct qca8k_priv *priv, int cpu_port_inde
 			cpu_port_index == QCA8K_CPU_PORT0 ? 0 : 6);
 }
 
+static struct phylink_pcs *
+qca8386_phylink_mac_select_pcs(struct qca8k_priv *priv, int port,
+			       phy_interface_t interface)
+{
+	struct phylink_pcs *pcs = NULL;
+
+	switch (interface) {
+	case PHY_INTERFACE_MODE_SGMII:
+	case PHY_INTERFACE_MODE_1000BASEX:
+	case PHY_INTERFACE_MODE_2500BASEX:
+		switch (port) {
+		case 0:
+			pcs = priv->pcs[0];
+			break;
+
+		case 5:
+			pcs = priv->pcs[1];
+			break;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return pcs;
+}
+
 static struct phylink_pcs *
 qca8k_phylink_mac_select_pcs(struct phylink_config *config,
 			     phy_interface_t interface)
@@ -1401,6 +1438,9 @@ qca8k_phylink_mac_select_pcs(struct phylink_config *config,
 	struct phylink_pcs *pcs = NULL;
 	int port = dp->index;
 
+	if (priv->switch_id == QCA8K_ID_QCA8386)
+		return qca8386_phylink_mac_select_pcs(priv, port, interface);
+
 	switch (interface) {
 	case PHY_INTERFACE_MODE_SGMII:
 	case PHY_INTERFACE_MODE_1000BASEX:
@@ -1435,6 +1475,9 @@ qca8k_phylink_mac_config(struct phylink_config *config, unsigned int mode,
 
 	priv = ds->priv;
 
+	if (priv->switch_id == QCA8K_ID_QCA8386)
+		return;
+
 	switch (port) {
 	case 0: /* 1st CPU port */
 		if (state->interface != PHY_INTERFACE_MODE_RGMII &&
@@ -1507,9 +1550,49 @@ qca8k_phylink_mac_config(struct phylink_config *config, unsigned int mode,
 	}
 }
 
+static void qca8386_phylink_get_caps(struct dsa_switch *ds, int port,
+				     struct phylink_config *config)
+{
+	switch (port) {
+	case 0: /* 1st CPU port */
+	case 5: /* 2nd CPU port */
+		__set_bit(PHY_INTERFACE_MODE_SGMII,
+			  config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_2500BASEX,
+			  config->supported_interfaces);
+		break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+		/* Internal PHY */
+		__set_bit(PHY_INTERFACE_MODE_GMII,
+			  config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_INTERNAL,
+			  config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_SGMII,
+			  config->supported_interfaces);
+		__set_bit(PHY_INTERFACE_MODE_2500BASEX,
+			  config->supported_interfaces);
+		break;
+
+	}
+
+	config->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |
+				   MAC_10 | MAC_100 | MAC_1000FD | MAC_2500FD;
+}
+
 static void qca8k_phylink_get_caps(struct dsa_switch *ds, int port,
 				   struct phylink_config *config)
 {
+	struct qca8k_priv *priv = ds->priv;
+
+	if (priv->switch_id == QCA8K_ID_QCA8386) {
+		qca8386_phylink_get_caps(ds, port, config);
+		return;
+	}
+
 	switch (port) {
 	case 0: /* 1st CPU port */
 		phy_interface_set_rgmii(config->supported_interfaces);
@@ -1550,6 +1633,14 @@ qca8k_phylink_mac_link_down(struct phylink_config *config, unsigned int mode,
 	struct qca8k_priv *priv = dp->ds->priv;
 
 	qca8k_port_set_status(priv, dp->index, 0);
+
+	if (priv->switch_id == QCA8K_ID_QCA8386 && dsa_port_is_user(dp)) {
+		clk_disable_unprepare(priv->port[dp->index].clk[EPHY_RX_CLK]);
+		clk_disable_unprepare(priv->port[dp->index].clk[EPHY_TX_CLK]);
+
+		reset_control_reset(priv->port[dp->index].reset[EPHY_RX_RESET]);
+		reset_control_reset(priv->port[dp->index].reset[EPHY_TX_RESET]);
+	}
 }
 
 static void
@@ -1561,6 +1652,7 @@ qca8k_phylink_mac_link_up(struct phylink_config *config,
 	struct dsa_port *dp = dsa_phylink_to_port(config);
 	struct qca8k_priv *priv = dp->ds->priv;
 	int port = dp->index;
+	unsigned long rate;
 	u32 reg;
 
 	if (phylink_autoneg_inband(mode)) {
@@ -1569,12 +1661,19 @@ qca8k_phylink_mac_link_up(struct phylink_config *config,
 		switch (speed) {
 		case SPEED_10:
 			reg = QCA8K_PORT_STATUS_SPEED_10;
+			rate = 2500000;
 			break;
 		case SPEED_100:
 			reg = QCA8K_PORT_STATUS_SPEED_100;
+			rate = 25000000;
 			break;
 		case SPEED_1000:
 			reg = QCA8K_PORT_STATUS_SPEED_1000;
+			rate = 125000000;
+			break;
+		case SPEED_2500:
+			reg = QCA8386_PORT_STATUS_SPEED_2500;
+			rate = 312500000;
 			break;
 		default:
 			reg = QCA8K_PORT_STATUS_LINK_AUTO;
@@ -1594,6 +1693,38 @@ qca8k_phylink_mac_link_up(struct phylink_config *config,
 	reg |= QCA8K_PORT_STATUS_TXMAC | QCA8K_PORT_STATUS_RXMAC;
 
 	qca8k_write(priv, QCA8K_REG_PORT_STATUS(port), reg);
+
+	if (priv->switch_id == QCA8K_ID_QCA8386 && dsa_port_is_user(dp)) {
+		/* The EPHY of port4 can be connected with MAC(switch mode) or
+		 * PCS(PHY mode), the clock parent is different for these two
+		 * work mode, for the switch mode(DSA) here, the parent clock of
+		 * port4 needs to be manually configured to the root clock
+		 * UNIPHY1_TX_312P5M_CLK.
+		 */
+		int ret;
+		ret = clk_set_parent(priv->port[port].clk[PORT_RX_SRC_CLK],
+				     priv->root_clk);
+		if (ret) {
+			dev_err(priv->dev, "set parent clock of port4 rx failed\n");
+			return;
+		}
+
+		ret = clk_set_parent(priv->port[port].clk[PORT_TX_SRC_CLK],
+				     priv->root_clk);
+		if (ret) {
+			dev_err(priv->dev, "set parent clock of port4 tx failed\n");
+			return;
+		}
+
+		clk_set_rate(priv->port[port].clk[EPHY_RX_CLK], rate);
+		clk_set_rate(priv->port[port].clk[EPHY_TX_CLK], rate);
+
+		clk_prepare_enable(priv->port[port].clk[EPHY_RX_CLK]);
+		clk_prepare_enable(priv->port[port].clk[EPHY_TX_CLK]);
+
+		reset_control_reset(priv->port[port].reset[EPHY_RX_RESET]);
+		reset_control_reset(priv->port[port].reset[EPHY_TX_RESET]);
+	}
 }
 
 static struct qca8k_pcs *pcs_to_qca8k_pcs(struct phylink_pcs *pcs)
@@ -2093,6 +2224,53 @@ static void qca8386_setup_hol_fixup(struct qca8k_priv *priv, int port)
 			   mask);
 }
 
+static struct phylink_pcs *qca8386_pcs_create(struct device_node *dp_node)
+{
+	struct device_node *node;
+
+	node = of_parse_phandle(dp_node, "pcsphy-handle", 0);
+	if (!node)
+		return ERR_PTR(-ENODEV);
+
+	return qca8k_pcs_create_fwnode(of_fwnode_handle(node));
+}
+
+static int qca8386_setup_pcs_and_clock(struct dsa_switch *ds)
+{
+	struct qca8k_priv *priv = ds->priv;
+	struct dsa_port *dp = NULL;
+	int ret = 0;
+
+	if (dsa_is_cpu_port(ds, 0)) {
+		dp = dsa_to_port(priv->ds, 0);
+		priv->pcs[0] = qca8386_pcs_create(dp->dn);
+	} else {
+		return -EINVAL;
+	}
+
+	/* CPU port 5 is optional to to used. */
+	if (dsa_is_cpu_port(ds, 5)) {
+		dp = dsa_to_port(priv->ds, 5);
+		priv->pcs[1] = qca8386_pcs_create(dp->dn);
+	}
+
+	dsa_switch_for_each_available_port(dp, ds) {
+		ret = clk_prepare_enable(priv->port[dp->index].clk[PORT_RX_CLK]);
+		if (ret) {
+			dev_err(priv->dev, "fail to enable rx clock of port %d\n", dp->index);
+			return ret;
+		}
+
+		ret = clk_prepare_enable(priv->port[dp->index].clk[PORT_TX_CLK]);
+		if (ret) {
+			dev_err(priv->dev, "fail to enable tx clock of port %d\n", dp->index);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int
 qca8k_setup(struct dsa_switch *ds)
 {
@@ -2128,8 +2306,14 @@ qca8k_setup(struct dsa_switch *ds)
 	if (ret)
 		return ret;
 
-	qca8k_setup_pcs(priv, &priv->pcs_port_0, 0);
-	qca8k_setup_pcs(priv, &priv->pcs_port_6, 6);
+	if (priv->switch_id == QCA8K_ID_QCA8386) {
+		ret = qca8386_setup_pcs_and_clock(ds);
+		if (ret)
+			return ret;
+	} else {
+		qca8k_setup_pcs(priv, &priv->pcs_port_0, 0);
+		qca8k_setup_pcs(priv, &priv->pcs_port_6, 6);
+	}
 
 	/* Make sure MAC06 is disabled */
 	ret = regmap_clear_bits(priv->regmap, QCA8K_REG_PORT0_PAD_CTRL,
@@ -2313,10 +2497,21 @@ static const struct phylink_mac_ops qca8k_phylink_mac_ops = {
 	.mac_link_up	= qca8k_phylink_mac_link_up,
 };
 
+static void qca8386_pcs_destory(struct phylink_pcs *pcs)
+{
+	if (IS_ERR_OR_NULL(pcs))
+		return;
+
+	qca8k_pcs_destroy(pcs);
+}
+
 static void qca8k_teardown(struct dsa_switch *ds)
 {
 	struct qca8k_priv *priv = ds->priv;
 	qca8386_port_reset_release(priv);
+
+	qca8386_pcs_destory(priv->pcs[0]);
+	qca8386_pcs_destory(priv->pcs[1]);
 }
 
 static const struct dsa_switch_ops qca8k_switch_ops = {
diff --git a/drivers/net/dsa/qca/qca8k.h b/drivers/net/dsa/qca/qca8k.h
index 2af23a1b6163..9c12f94f089e 100644
--- a/drivers/net/dsa/qca/qca8k.h
+++ b/drivers/net/dsa/qca/qca8k.h
@@ -142,6 +142,11 @@
 #define   QCA8K_PORT_STATUS_SPEED_10			0
 #define   QCA8K_PORT_STATUS_SPEED_100			0x1
 #define   QCA8K_PORT_STATUS_SPEED_1000			0x2
+/* The hardware register value of speed 2500 is same as the speed 1000, but
+ * the clock rate is different, speed 2500 uses the clock rate 312.5M, and
+ * speed 1000 uses the clock rate 125M.
+ */
+#define   QCA8386_PORT_STATUS_SPEED_2500		0x2
 #define   QCA8K_PORT_STATUS_TXMAC			BIT(2)
 #define   QCA8K_PORT_STATUS_RXMAC			BIT(3)
 #define   QCA8K_PORT_STATUS_TXFLOW			BIT(4)
@@ -546,6 +551,7 @@ struct qca8k_priv {
 	const struct qca8k_match_data *info;
 	struct qca8k_led ports_led[QCA8K_LED_COUNT];
 	struct qca8386_port port[QCA8386_NUM_PORTS];
+	struct phylink_pcs *pcs[QCA8K_NUM_CPU_PORTS]; /* CPU port0 and port5 */
 	struct clk *root_clk;   /* The root clock of qca8386 port */
 };
 
-- 
2.34.1

