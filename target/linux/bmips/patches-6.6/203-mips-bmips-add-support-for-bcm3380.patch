--- a/arch/mips/bmips/setup.c
+++ b/arch/mips/bmips/setup.c
@@ -32,6 +32,8 @@
 
 #define RELO_NORMAL_VEC		BIT(18)
 
+#define BCM3380_MEMC_ADDR	((void __iomem *)CKSEG1ADDR(0x12000000))
+
 #define REG_BCM6318_SOB		((void __iomem *)CKSEG1ADDR(0x10000900))
 #define BCM6318_FREQ_SHIFT	23
 #define BCM6318_FREQ_MASK	(0x3 << BCM6318_FREQ_SHIFT)
@@ -161,6 +163,51 @@ static void bcm63xx_fixup_cpu1(void)
 	cpumask_set_cpu(1, &bmips_booted_mask);
 }
 
+static void bcm3380_quirks(void)
+{
+	/*
+	* https://forum.openwrt.org/t/bringing-up-bcm3380-extremely-slow-instruction-execution
+	* Enable caches to increase the running speed:
+	* 1. In the BCM-specific CP0 config register($22, 0),
+	*    set CP0_BCM_CFG_ICSHEN(31) and CP0_BCM_CFG_DCSHEN(30) bits.
+	* 2. In the MIPS-generic CP0 config register($16, 0),
+	*    clear CONF_CM_CMASK and then set the CONF_CM_CACHABLE_NONCOHERENT.
+	*/
+	write_c0_brcm_config(read_c0_brcm_config() | (0x1 << 31) | (0x1 << 30));
+	change_c0_config(CONF_CM_CMASK, CONF_CM_CACHABLE_NONCOHERENT);
+
+	/*
+	 * RAC flush causes kernel panics on BCM6358 when booting from TP1
+	 * because the bootloader is not initializing it properly.
+	 */
+	bmips_rac_flush_disable = !!(read_c0_brcm_cmt_local() & (1 << 31)) ||
+				  !!bmips_cbr_addr;
+
+	bcm63xx_fixup_cpu1();
+
+	/*
+	* This function can only be called from CPU0.
+	*
+	* Linux only brings up CPU0 on boot.
+	* The highest bit of the CP0 CMT Local Register($22, 3) indicates which
+	* CPU the current code runs on.
+	* If set, we are on CPU1, otherwise, we are on CPU0.
+	*
+	* Route MIPS INT 2 & 4 to TP1 (CPU1).
+	* Set CP0_CMT_XIR_2(29) and CP0_CMT_XIR_4(31)
+	* in the CP0 CMT Interrupt Register($22, 1).
+	*/
+	write_c0_brcm_cmt_intr(read_c0_brcm_cmt_intr() | (1 << 29) | (1 << 31));
+
+	/*
+	* Configure the LSSPI mode:
+	* &GpioSpimasterControl = 0xb4e00188
+	* GpioSpimasterControl.SpimModeOverride (bit 19) = 1
+	* GpioSpimasterControl.HsSpimEn (bit 16) = 0
+	*/
+	*(unsigned int*)0xb4e00188 = (*(unsigned int*)0xb4e00188 | 1 << 19) & ~(1 << 16);
+}
+
 static void bcm6328_quirks(void)
 {
 	/* Check CPU1 status in OTP (it is usually disabled) */
@@ -193,6 +240,7 @@ static void bcm6368_quirks(void)
 
 static const struct bmips_quirk bmips_quirk_list[] = {
 	{ "brcm,bcm3368",		&bcm6358_quirks			},
+	{ "brcm,bcm3380",		&bcm3380_quirks			},
 	{ "brcm,bcm3384-viper",		&bcm3384_viper_quirks		},
 	{ "brcm,bcm33843-viper",	&bcm3384_viper_quirks		},
 	{ "brcm,bcm6328",		&bcm6328_quirks			},
@@ -228,6 +276,11 @@ const char *get_system_type(void)
 	return "Generic BMIPS kernel";
 }
 
+static u32 bcm3380_cpufreq(void)
+{
+	return 333000000;
+}
+
 static u32 bcm6318_cpufreq(void)
 {
 	u32 val = __raw_readl(REG_BCM6318_SOB);
@@ -351,6 +404,7 @@ static u32 bcm63268_cpufreq(void)
 }
 
 static const struct bmips_cpufreq bmips_cpufreq_list[] = {
+	{ "brcm,bcm3380", &bcm3380_cpufreq },
 	{ "brcm,bcm6318", &bcm6318_cpufreq },
 	{ "brcm,bcm6328", &bcm6328_cpufreq },
 	{ "brcm,bcm6358", &bcm6358_cpufreq },
@@ -427,6 +481,11 @@ static phys_addr_t _bcm6358_memsize(void
 	return bmips_dram_size(cols, rows, is_32b, 2);
 }
 
+static phys_addr_t bcm3380_memsize(void)
+{
+	return _bcm6328_memsize(BCM3380_MEMC_ADDR);
+}
+
 static phys_addr_t bcm6318_memsize(void)
 {
 	return _bcm6318_memsize(BCM6318_SDRAM_ADDR);
@@ -458,6 +517,7 @@ static phys_addr_t bcm63268_memsize(void
 }
 
 static const struct bmips_memsize bmips_memsize_list[] = {
+	{ "brcm,bcm3380", &bcm3380_memsize },
 	{ "brcm,bcm6318", &bcm6318_memsize },
 	{ "brcm,bcm6328", &bcm6328_memsize },
 	{ "brcm,bcm6358", &bcm6358_memsize },
